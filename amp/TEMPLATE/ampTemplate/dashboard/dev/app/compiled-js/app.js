(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./app/js/app.js":[function(require,module,exports){
require('./ugly/lib-load-hacks');
var App = require('./app/app-class');

var app = new App({ el: '#amp-dashboard' });
window.app = app;  // for debugging convenience

//Force call to the EP that sends the saved filters if any.
app.state.saved.load();
//app.render();

},{"./app/app-class":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/app-class.js","./ugly/lib-load-hacks":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-load-hacks.js"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/app-class.js":[function(require,module,exports){
var _ = require('underscore');
var Deferred = require('jquery').Deferred;
var BackboneDash = require('./backbone-dash');
var supportCheck = require('./check-support');

var URLService = require('amp-url/index');
var State = require('amp-state/index');
var StateLoadError = require('amp-state/index').StateLoadError;

var Translator = require('amp-translate');
var Filter = require('amp-filter/src/main');
var Settings = require('./models/settings-collection');
var SavedDashes = require('./models/saved-dashes-collection.js');

var MainView = require('./views/main');
var FailView = require('./views/fail');


function App() {
  if (!(this instanceof App)) {
    throw new Error('App needs to be instantiated with the `new` keyword.');
  }
  this.initialize.apply(this, arguments);
}


_.extend(App.prototype, BackboneDash.Events, {
	
  rendered: false,

  initialize: function(options) {
    var _initDefer = new Deferred(),
        missingFeatures;
    this.initialized = _initDefer.promise();

    try {    	
      this.settings = new Settings([], { app: this });

      // check our support level
      this.browserIssues = supportCheck();
      _(this.browserIssues).chain()
        .groupBy('severity')
        .each(function(severityGroup, severity) {
          missingFeatures = _(severityGroup).pluck('feature').join(', ');
          if (severity === 'critical') {
            throw {
              name: 'Incompatible Web Browser',
              message: 'Dashboards cannot work without these features, which are ' +
                       'not supported by your web browser: ' + missingFeatures + '. ' +
                       'Any <a href="http://browsehappy.com/">modern browser</a> will work.',
              toString: function() { return this.name + ': ' + this.message; }
            };
          } else if (severity === 'major') {
            this.report('Limited support for old web browsers', [
              'Your browser does not provide some features used by Dashboards: ' +
              missingFeatures + '.',
              'Some features may not work correctly, however any ' +
              '<a href="http://browsehappy.com/">modern browser</a> will provide ' +
              'a better experience.']);
          } else if (severity === 'minor') {
            console.warn('This browser is missing support for', missingFeatures);
          }
        }, this);

      // inject downloadify if we have no download but have flash (IE)
      if (this.hasIssue('download') && !this.hasIssue('flash')) {
        var swfObj = document.createElement('script'),
            downloadify = document.createElement('script');
        swfObj.src = '/TEMPLATE/ampTemplate/commonJs/swfobject-2.2.js';
        downloadify.src = '/TEMPLATE/ampTemplate/commonJs/downloadify-0.2.js';
        document.body.appendChild(swfObj);
        document.body.appendChild(downloadify);
      }

      // initialize app services
      this.url = new URLService();      
      this.savedDashes = new SavedDashes([], { app: this });
      this.state = new State({
        url: this.url,
        saved: this.savedDashes
      });
      
      // try to load an initial state from the url
      try {
    	  this.state.urlMaybeLoad();
      } catch (e) {
          if (e instanceof StateLoadError) {
        	  this.report('Could not load saved dashboard', ['If you are trying to load a shared link, please make sure the entire URL was copied']);
        	  this.url.hash('');  // clear the bad saved-state hash
          } else {
        	  throw e;
          }
      }

      var dashboardTranslateKeys = JSON.parse("{\n\"amp.common:footer\": \"Developed in partnership with OECD, UNDP, WB, Government of Ethiopia and DGF\",\n\n\"amp.common:title\": \"AMP\",\n\"amp.common:title-desktop\": \"Desktop\",\n\"amp.common:subtitle-my-desktop\": \"My Desktop\",\n\"amp.common:subtitle-add-tab\": \"Add Tab\",\n\"amp.common:subtitle-tab-manager\": \"Tab Manager\",\n\"amp.common:title-reports\": \"Reports\",\n\"amp.common:subtitle-all-reports\": \"All Reports\",\n\"amp.common:subtitle-fav-reports\": \"Favourite Reports\",\n\"amp.common:subtitle-report-generator\": \"Report Generator\",\n\"amp.common:subtitle-saiku\": \"Saiku\",\n\"amp.common:title-documents\": \"Documents\",\n\"amp.common:title-dashboards\": \"Dashboards\",\n\"amp.common:subtitle-gis\": \"New GIS (BETA)\",\n\"amp.common:subtitle-dashboards\": \"New Dashboard (BETA)\",\n\"amp.common:subtitle-dashboard-generator\": \"Dashboard Generator\",\n\"amp.common:subtitle-donor-profile\": \"Donor Profile\",\n\"amp.common:subtitle-region-profile\": \"Region Profile\",\n\"amp.common:subtitle-sector-profile\": \"Sector Profile\",\n\"amp.common:subtitle-executing-profile\": \"Executing Agency Profile\",\n\"amp.common:subtitle-beneficiary-profile\": \"Beneficiary Ministry Profile\",\n\"amp.common:title-tools\": \"Tools\",\n\"amp.common:subtitle-workspace-setup\": \"Workspace Setup\",\n\"amp.common:subtitle-advanced-mode\": \"Advanced Mode\",\n\"amp.common:subtitle-search\": \"Search\",\n\"amp.common:subtitle-addressbook\": \"Address Book\",\n\"amp.common:title-help\": \"Help\",\n\"amp.common:subtitle-amp-help\": \"AMP Help\",\n\"amp.common:subtitle-glossary\": \"Glossary\",\n\"amp.common:subtitle-email-support-team\": \"Email Support Team\",\n\"amp.common:title-logout\": \"Logout\",\n\"amp.common:filters-loading\": \"Loading...\",\n\"amp.dashboard:page-title\":\"AMP Dashboards\",\n\"amp.dashboard:loading\": \"Loading...\",\n\"amp.dashboard:title-projectdata\": \"Project Data\",\n\"amp.dashboard:sub-title-projectdata\": \"View where projects are being implemented throughout the country.\",\n\"amp.dashboard:title-Country\": \"Country\",\n\"amp.dashboard:title-Region\": \"Region\",\n\"amp.dashboard:title-Zone\": \"Zone\",\n\"amp.dashboard:title-District\": \"District\",\n\"amp.dashboard:chart-reset\": \"reset others\",\n\"amp.dashboard:chart-radioui-commitments\": \"Commitments\",\n\"amp.dashboard:chart-radioui-disbursements\": \"Disbursements\",\n\"amp.dashboard:filters-none-applied\": \"No filters applied\",\n\"amp.dashboard:close\": \"Close\",\n\"amp.dashboard:modal-sorry\": \"Sorry for any inconvenience\",\n\"amp.dashboard:share-dashboard-top\": \"Share dashboard\",\n\"amp.dashboard:share-dashboard\": \"Share this dashboard view\",\n\"amp.dashboard:share-link\": \"Link\",\n\"amp.dashboard:of\": \"of\",\n\"amp.dashboard:tooltip-predict-otherseries\": \"TRANSLATEME\",\n\"amp.dashboard:total\": \"total\",\n\"amp.common:title\": \"AMP Toolbar\",\n\"amp.common:title-filters\": \"Filters\",\n\"amp.dashboard:chart-TopDonorAgencies\": \"Top Donor Agencies\",\n\"amp.dashboard:chart-TopDonorGroups\": \"Top Donor Groups\",\n\"amp.dashboard:chart-TopRegions\": \"Top Regions\",\n\"amp.dashboard:chart-TopSectors\": \"Top Sectors\",\n\"amp.dashboard:chart-AidPredictability\": \"Aid Predictability\",\n\"amp.dashboard:chart-FundingType\": \"Funding Type\",\n\"amp.dashboard:chart-ResponsibleOrganizations\": \"Top Responsible Organizations\",\n\"amp.dashboard:chart-BeneficiaryAgencies\": \"Top Beneficiary Agencies\",\n\"amp.dashboard:chart-ExecutingAgencies\": \"Top Executing Agencies\",\n\"amp.dashboard:chart-ImplementingAgencies\": \"Top Implementing Agencies\",\n\"amp.dashboard:chart-Peace-buildingandState-buildingGoals\": \"Peace-building and State-building Goals\",\n\"amp.dashboard:predictability-planned\": \"Planned\",\n\"amp.dashboard:predictability-actual\": \"Actual\",\n\"amp.dashboard:chart-FundingType-Grant\": \"Grant\",\n\"amp.dashboard:chart-FundingType-Loan\": \"Loan\",\n\"amp.dashboard:chart-FundingType-others\": \"Others\",\n\"amp.dashboard:chart-TopRegions-DistrictUndefined\": \"District: U\",\n\"amp.dashboard:chart-TopRegions-others\": \"Others\",\n\"amp.dashboard:chart-TopSectors-others\": \"Others\",\n\"amp.dashboard:chart-TopDonorAgencies-others\": \"Others\",\n\"amp.dashboard:chart-TopDonorGroups-others\": \"Others\",\n\"amp.dashboard:chart-ResponsibleOrganizations-others\": \"Others\",\n\"amp.dashboard:chart-BeneficiaryAgencies-others\": \"Others\",\n\"amp.dashboard:chart-ExecutingAgencies-others\": \"Others\",\n\"amp.dashboard:chart-ImplementingAgencies-others\": \"Others\",\n\"amp.dashboard:chart-Peace-buildingandState-buildingGoals-others\":\"Others\",\n\"amp.dashboard:filters-edit\":\"edit filters\",\n\"amp.dashboard:dashboard-settings\":\"Settings\",\n\"amp.dashboard:settings-edit\":\"edit settings\",\n\"amp.dashboard:download-amount\":\"Amount\",\n\"amp.dashboard:download-preview\":\"Preview:\",\n\"amp.dashboard:download-rendering\":\"Rendering...\",\n\"amp.dashboard:download-download-chart\":\"Download chart\",\n\"amp.dashboard:download-download-data\":\"Download data\",\n\"amp.dashboard:chart-no-data-available\":\"No Data Available\",\n\"amp.dashboard:chart-loading-saved-settings\":\"Loading saved settings...\",\n\"amp.dashboard:filters-show-settings\":\"Show filter settings\",\n\"amp.dashboard:filters-chart-legends-Grouped\":\"Grouped\",\n\"amp.dashboard:filters-chart-legends-Stacked\":\"Stacked\",\n\"amp.dashboard:of-total\": \"of total\",\n\"amp.dashboard:aid-predictability-actual-disbursements\": \"Actual Disbursements\",\n\"amp.dashboard:aid-predictability-planned-disbursements\": \"Planned Disbursements\",\n\"amp.dashboard:filters-hide-details\": \"Hide filter details\",\n\"amp.dashboard:saving-state\": \"Saving dashboard state, please wait...\",\n\"amp.dashboard:date-range\": \"Date Range\",\n\"amp.dashboard:currency\" : \"Currency\",\n\"amp.dashboard:type\" : \"Type\",\n\"amp.dashboard:year\" : \"Year\",\n\"amp.dashboard:ftype-actual-commitment\": \"Actual Commitments\",\n\"amp.dashboard:ftype-actual-disbursement\": \"Actual Disbursements\",\n\"amp.dashboard:ftype-actual-expenditure\": \"Actual Expenditures\",\n\"amp.dashboard:ftype-planned-commitment\": \"Planned Commitments\" ,\n\"amp.dashboard:ftype-planned-disbursement\":\t\"Planned Disbursements\" ,\n\"amp.dashboard:ftype-planned-expenditures\":\t\"Planned Expenditures\",  \t\t\t\n\"amp.dashboard:dashboard-chart-tops-info-modal\": \"Category Detail\",\n\"amp.dashboard:chart-tops-table-projecttitle\": \"Project Title\",\n\"amp.dashboard:chart-tops-inunits\": \"In units\",\n\"amp.dashboard:chart-tops-inthousands\": \"In thousands\",\n\"amp.dashboard:chart-tops-inmillions\": \"In millions\"\n}\n\n");
      this.translator = new Translator({
        defaultKeys: dashboardTranslateKeys,
        ajax: BackboneDash.wrappedAjax
      });
      // TODO: handle translations load failure

      this.filter = new Filter({
        draggable: true,
        sync: options.sync || BackboneDash.sync,
        caller: 'DASHBOARD'
      });

      // initialize app components
      this.view = new MainView({ app: this, el: options.el });

      _initDefer.resolve(this);
    } catch (e) {
      _.defer(function() { throw e; });
      this.view = new FailView({ app: this, el: options.el, err: e});
      this.err = e;
      _initDefer.reject(this);
    }
  },

  render: function() {
    // TODO: fix some parts of the app so we can load translations async
    this.tryAfter(this.translator.promise, this.view.render, this.view);
    // this.tryTo(this.view.render, this.view);

    /* ensure entire page--header and footer, not just this view is translated */
    // TODO: if possible, move this out of app-class
    // or at least make it more targeted than document
    this.translator.translateDOM(document);
  },

  hasIssue: function(featureName) {
    return !!_(this.browserIssues).findWhere({feature: featureName});
  },

  viewFail: function(view, err) {
    view.$el.html(new FailView({ app: this, err: err }).render().el);
  },

  tryTo: function(fn, view) {
    try {
      return fn.call(view);
    } catch (e) {
      _.defer(function() { throw e; });
      this.viewFail(view, e);
    }
  },

  tryAfter: function(promise, fn, view) {
    promise
      .done(_(function() {
        this.tryTo(fn, view);
      }).bind(this))
      .fail(_(function() {
        this.viewFail(view, 'failed to load');
      }).bind(this));
  },

  report: function(title, messages) {
    this.initialized
      .done(function(app) {
        app.modal(title, {messages: messages, tone: 'warning'});
      })
      .fail(function() {
        console.warn('REPORT:', title, messages);
      });
  },

  modal: function(title, options) {
    options = _({}).extend(options, {tone: 'primary'});
    var modalReady = new Deferred();
    this.initialized
      .done(function(app) {
        var modalEl = app.view.modal(title, options);
        modalReady.resolve(modalEl);
      })
      .fail(function() {
        console.warn('failed to show modal because the app views did not initialize', title);
        modalReady.reject('app views did not init');
      });
    return modalReady.promise();
  }

});


module.exports = App;

},{"./backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","./check-support":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/check-support.js","./models/saved-dashes-collection.js":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/saved-dashes-collection.js","./models/settings-collection":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/settings-collection.js","./views/fail":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/fail.js","./views/main":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/main.js","amp-filter/src/main":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/main.js","amp-state/index":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-state/index.js","amp-translate":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-translate/index.js","amp-url/index":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-url/index.js","jquery":"jquery","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


// TODO: ... ... ...
var IS_PHILS_CORS = window && (window.location.host === 'localhost:3000');


var CACHE = ['/rest/dashboard'];


function InitError(instance) {
  this.instance = instance;
  this.toString = function() { return 'Module initialization error'; };
}


var ajaxOptionWrap = function(options) {
  options = _({}).extend(options, {
    // maybe use phil's DRC CORS dev server
    url: (IS_PHILS_CORS ? 'http://localhost:8080' : '') + options.url,
    headers: {
      // jscs:disable disallowQuotedKeysInObjects
      'Accept': 'application/json',
      'Content-Type': 'application/json'
      // jscs:enable disallowQuotedKeysInObjects
    }
  });
  return options;
};


var syncOverride = (function(bs) {
  var cache = {};

  function _doSync(url, method, model, options) {
    options = _({}).extend(options, { url: url });
    options = ajaxOptionWrap(options);
    return bs.call(this, method, model, options);
  }

  function _cacheSync(url, method, model, options) {
    var key = url + '+POST:' + options.data;
    if (cache[key]) { return cache[key](); }

    var xhr = _doSync(url, method, model, options);

    cache[key] = function() {
      // calling this function will make the xhr re-call its callbacks
      return xhr
        .done(options.success)
        .always(options.complete);
    };

    // do not cache failed requests
    xhr.fail(function() { delete cache[key]; });

    return xhr;
  }

  return function(method, model, options) {
    var url = options.url || _(model).result('url') || Backbone.Model.prototype.url.call(model),
        cacheable = false;
    if (options.type === 'POST' &&
      _.some(CACHE, function(i) { return url.indexOf(i) === 0; })) {
      cacheable = true;
    }
    return (cacheable ? _cacheSync : _doSync)(url, method, model, options);
  };
})(Backbone.sync);


// mixed into all models, collections and views to ensure we have a convenient
// reference to the app instance everywhere.
function mixDash(Class) {
  return Class.extend({

    constructor: function() {
      var constructed = Class.apply(this, arguments);
      if (!this.app) {
        throw new InitError(this);
      }
      return constructed;
    },

    sync: syncOverride

  });
}


module.exports = _({}).extend(Backbone, {
  // errors
  InitError: InitError,

  Model: mixDash(Backbone.Model),
  Collection: mixDash(Backbone.Collection),
  View: mixDash(Backbone.View),

  sync: syncOverride,
  wrappedAjax: function(o) { return Backbone.ajax(ajaxOptionWrap(o)); }
});

},{"backbone":"backbone","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_bar.js":[function(require,module,exports){
/*
 * Drawing a bar chart in AMP? Please use ./chart.js instead.
 */

var nv = window.nv;  // nvd3 is a pain
var d3 = require('d3-browserify');
var util = require('../../ugly/util');


function dataToNv(data) {
  return data;
}


function countCategories(data) {
  // note: this takes regular data, not dataToNv data.
  return data[0].values.length - 1;  // 1 for others...?
}


function chart(options) {
  var _chart = nv.models.discreteBarChart()
    .valueFormat(options.shortFormatter)
    .showValues(true)
    .showYAxis(false)
    .showXAxis(false)
    .margin({ top: 5, right: 10, bottom: 10, left: 10 });
  return _chart;
}


function addLegend(svg, chart, nvData, trimLabels, width) {
  var legendHeight;

  var legend = nv.models.legend()
    .width(width || svg.clientWidth)
    .margin({left: 20, right: 20})
    .rightAlign(false)
    .color(util.categoryColours(nvData[0].values.length))
    .key(function(d) { return trimLabels ? util.formatShortText(12)(d.x) : d.x; });

  d3.select(svg)
    .datum(nvData)
    .append('g')
      .attr('class', 'legend')
      .datum(nvData[0].values)
      .call(legend);

  legendHeight = svg.querySelector('.legend').getBBox().height;
  chart.margin({top: legendHeight + 15});
}


module.exports = {
  dispatchName: 'discretebar',
  countCategories: countCategories,
  addLegend: addLegend,
  dataToNv: dataToNv,
  chart: chart
};

},{"../../ugly/util":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","d3-browserify":"d3-browserify"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_multibar.js":[function(require,module,exports){
/*
 * Drawing a multibar chart in AMP? Please use ./chart.js instead.
 */

var nv = window.nv;  // nvd3 is a pain
var customizedMultiBarChart = require('./customized/multiBarChart.js');
// var d3 = require('d3-browserify');


function dataToNv(data) {
  return data;
}


function countCategories(data) {
  // note: this takes regular data, not dataToNv data.
  return data.length;
}


function staggerX(chart, nvData) {
  if (!nvData[0]) { return; }
  if (nvData[0].values.length < 5) { return; }
  chart
    .staggerLabels(true)
    .margin({bottom: 40});
}


function chart(options) {
  var maxValue = 10;
  var _chart = nv.models.customizedMultiBarChart()  
    .forceY([0, maxValue])  // ensures yAxis is showing at least 0 and 10, but won't restrict the domain
                            // (meaning if the are values falling outside the range it will show then).
    .reduceXTicks(false)
    .margin({ top: 5, right: 10, bottom: 20, left: 50 });

  if (!options.nvControls) {
    _chart.showControls(false);
  }

  _chart.yAxis
    .tickFormat(options.shortFormatter)
    .showMaxMin(false);

  return _chart;
}


module.exports = {
  dispatchName: 'multibar',
  countCategories: countCategories,
  dataToNv: dataToNv,
  staggerX: staggerX,
  chart: chart
};

},{"./customized/multiBarChart.js":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/customized/multiBarChart.js"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_pie.js":[function(require,module,exports){
/*
 * Drawing a pie chart in AMP? Please use ./chart.js instead.
 */

var nv = window.nv;  // nvd3 is a pain
// var d3 = require('d3-browserify');

var _ = require('underscore');
var common = require('./common');
var util = require('../../ugly/util');


function dataToNv(data) {
  if (data.length !== 1) {
    common.fail('Pie charts can only show one series of data. got', data.length);
  }
  if (!_.isArray(data[0].values)) {
    common.fail('Data series did not have a "values" array. Instead', data[0].values);
  }
  return data[0].values;
}


function countCategories(data) {
  // note: this takes regular data, not dataToNv data.
  return data[0].values.length;
}


function chart(options) {
  var _chart = nv.models.pieChart()
    .valueFormat(options.shortFormatter)
    .labelType('percent')
    .donut(true)
    .donutRatio(0.35)
    .showLegend(false);
  return _chart;
}


function removeLegend(chart) {
  chart.showLegend(false);
}


function normalizeNvTTArgs(fmtX, fmtY, raw) {
  // nv pie charts drop the seriesName as first arg
  return [void 0, fmtX, fmtY, raw];
}

function addLegend(svg, chart, nvData, trimLabels, width) {
  var legend = nv.models.legend()
    .width(width || svg.clientWidth)
    .margin({left: 20, right: 20})
    .rightAlign(false)
    .color(util.categoryColours(nvData.length))
    .key(function(d) { return trimLabels ? util.formatShortText(12)(d.x) : d.x; });

  d3.select(svg)
    .datum(nvData)
    .call(legend);

  var legendHeight = svg.querySelector('.nv-legend').getBBox().height;
  chart.margin({top: legendHeight + 15});
}


module.exports = {
  dispatchName: 'pie',
  normalizeNvTTArgs: normalizeNvTTArgs,
  countCategories: countCategories,
  addLegend: addLegend,
  removeLegend: removeLegend,
  dataToNv: dataToNv,
  chart: chart
};

},{"../../ugly/util":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","./common":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_table.js":[function(require,module,exports){

var _ = require('underscore');
var util = require('../../ugly/util');
var common = require('./common');
var tableTemplate = _.template("<div class=\"table-responsive\">\n  <table class=\"table table-striped table-condensed\">\n\n    <% if (_(keys).some()) { %>\n      <thead>\n        <tr>\n          <td></td>\n          <% _(keys).each(function(key, colIndex) { %>\n            <th data-series-index=\"<%= colIndex %>\">\n              <%= key %>\n            </th>\n          <% }); %>\n        </tr>\n      </thead>\n    <% } %>\n\n    <tbody>\n      <% _(values).each(function(row, rowIndex) { %>\n        <tr>\n          <th data-x-index=\"<%= rowIndex %>\">\n            <%= row[0].x %>\n          </th>\n          <% _(row).each(function(datum, colIndex) { %>\n            <td data-x-index=\"<%= rowIndex %>\" data-series-index=\"<%= colIndex %>\">\n              <%= moneyFormat(datum.y) %>\n            </td>\n          <% }) %>\n        </tr>\n      <% }) %>\n    </tbody>\n\n  </table>\n</div>\n");


function fakeRawContext(e, data) {
  // transform a table-click event into something that looks like it came from
  // an nvd3 handler
  var t = e.target,
      seriesIndex = parseInt(util.data(t, 'seriesIndex'), 10) || 0,
      xIndex = parseInt(util.data(t, 'xIndex'), 10);
  return {
    label: data[seriesIndex].values[xIndex].x || xIndex,
    seriesIndex: seriesIndex,
    pointIndex: xIndex,
    point: data[seriesIndex].values[xIndex] || xIndex
  };
}


function bindClickHandler(el, data, options) {
  el.addEventListener('click', function(e) {
    var fakeRaw = fakeRawContext(e, data),  // so we can use the shared context transformer
        context = common.getNiceContext(fakeRaw, data, e.target.innerText);
    options.clickHandler(context);
  });
}


function charter(data, options) {

  var keys = _(data).pluck('key');

  var values = _(data)
    .chain()
    .map(function(datum) { return datum.values; })
    .transpose()
    .value();

  var html = tableTemplate({
    keys: keys,
    values: values,
    moneyFormat: options.shortFormatter
  });

  var chartEl = document.createElement('div');
  chartEl.innerHTML = html;

  bindClickHandler(chartEl, data, options);

  return chartEl;
}


module.exports = {
  charter: charter
};

},{"../../ugly/util":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","./common":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/chart.js":[function(require,module,exports){

var _ = require('underscore');
var d3 = require('d3-browserify');
var util = require('../../ugly/util');
var common = require('./common');
var barSpecific = require('./_bar');
var multibarSpecific = require('./_multibar');
var pieSpecific = require('./_pie');
var table = require('./_table');
var defaultTTTemplate = _.template("<div class=\"panel panel-primary panel-popover\">\n  <% if (tt.heading) { %>\n    <div class=\"panel-heading\"><%= tt.heading %></div>\n  <% } %>\n  <div class=\"panel-body\">\n    <span class=\"dollaz\">\n      <% if (tt.bodyText) { %>\n        <%= tt.bodyText %>\n      <% } %>\n      <% if (tt.bodyList) { %>\n        <ul class=\"list-unstyled\">\n          <% _(tt.bodyList).each(function(item) { %>\n            <li><b><%= item.k %></b> <%= item.v %></li>\n          <% }) %>\n        </ul>\n      <% } %>\n    </span>\n  </div>\n  <% if (tt.footerText) { %>\n    <div class=\"panel-footer\">\n      <%= tt.footerText %>\n    </div>\n  <% } %>\n</div>\n");


var charters = {
  bar: common.nvCharter(barSpecific),
  pie: common.nvCharter(pieSpecific),
  multibar: common.nvCharter(multibarSpecific),
  table: table.charter
};


function chart(type, data, options) {
  /*
   * @param type: 'bar' (default), 'pie', or 'multibar'
   * @param data: [{key: 'serisName', values: [{x:NN, y:NN}]}]
   * @param options: optional extra stuff
   */

  options = options || {};

  // settings defaults
  options = _(_(options).clone()).defaults({
    height: void 0,  // should fill container in most cases by default
    width: void 0,
    numberFormatter: d3.format(','),
    shortFormatter: options.numberFormatter || util.formatKMB(3, app.settings.numberFormatSettings.decimalSeparator),
    addLegend: true,
    trimLabels: true,
    getTTContent: common.defaultGetTTContent,
    ttTemplate: defaultTTTemplate,
    clickHandler: common.defaultClickHandler,
    nvControls: true
  });

  var charter = charters[type] || common.fail('unrecognized chart type', type);

  return {
    el: charter(data, options)
  };
}


module.exports = chart;

},{"../../ugly/util":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","./_bar":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_bar.js","./_multibar":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_multibar.js","./_pie":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_pie.js","./_table":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/_table.js","./common":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js","d3-browserify":"d3-browserify","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js":[function(require,module,exports){
var nv = window.nv;  // nvd3 is a pain
var d3 = require('d3-browserify');
var util = require('../../ugly/util');
var Numeral = require('numeral');
var _ = require('underscore');


// hack nvd3's calcApproxTextWidth because it is terrrrrrrrrrible
// this solution is just as bad :(
// nvd3 makes me so sad :(
(function(unfortunateLib) {
  var sadWayOfCalculatingTextWidth = unfortunateLib.utils.calcApproxTextWidth;
  unfortunateLib.utils.calcApproxTextWidth = function(svgTextEl) {
    var originalText = svgTextEl.text(),
        spacePaddedText = originalText,
        numberOfDots = (originalText.match(/\./g) || []).length,
        poorlyCalculatedWidth;

    if (originalText.toUpperCase() === originalText) {
      for (var i = 0; i < originalText.length / 5; i++) { spacePaddedText += ' '; }
      svgTextEl.text(spacePaddedText);
      poorlyCalculatedWidth = sadWayOfCalculatingTextWidth(svgTextEl);
      svgTextEl.text(originalText);
    } else {
      poorlyCalculatedWidth = sadWayOfCalculatingTextWidth(svgTextEl);
    }

    // ♪ do you believe in maaaagic ♫
    poorlyCalculatedWidth -=
      (poorlyCalculatedWidth / spacePaddedText.length) * (numberOfDots / 3);
    // ♪ magic magic magic ♫
    poorlyCalculatedWidth += 6;

    return poorlyCalculatedWidth;
  };
})(nv);


function fail(/* arguments */) {
  throw {
    name: 'Chart Error',
    message: Array.prototype.join.call(arguments, ', '),
    toString: function() { return this.name + ': ' + this.message; }
  };
}


function nvChartCommon(nvChart, maxCategories) {
  return nvChart
    .x(function(d) { return util.formatShortText(19)(d.x); })  // fix overflows in legends
    .color(util.categoryColours(maxCategories));
}


function getSecretRenderArea(height, width) {
  var secretArea = document.getElementById('super-secret-render-area-shh');
  if (!secretArea) {
    secretArea = document.createElement('div');
    secretArea.id = 'super-secret-render-area-shh';
    secretArea.style.position = 'absolute';
    secretArea.style.left = '-9999em';
    secretArea.style.top = '-9999em';  // for IE :(
    document.body.appendChild(secretArea);
  }
  if (height) { secretArea.style.height = height + 'px'; }
  if (width) { secretArea.style.width = width + 'px'; }
  return secretArea;
}


function mkChartSVG(height, width) {
  var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('class', 'dash-chart');
  // put it in the dom but out of the way, so we can compute styles n stuff
  getSecretRenderArea(height, width).appendChild(svg);
  return svg;
}


function nvBoiler(nvData, chart, svg, specific, trimLabels, addLegend, width) {
  if (trimLabels) {
	  chart.x(function(d) { return util.formatShortText(50)(d.x); });
  }
  if (addLegend && specific.addLegend) {
    specific.addLegend(svg, chart, nvData, trimLabels, width);
  } else if (!addLegend && specific.removeLegend) {
    specific.removeLegend(chart);
  }
  if (specific.staggerX) {
    specific.staggerX(chart, nvData);
  }
  d3.select(svg)
    .datum(nvData)
    .call(chart);
  nv.utils.windowResize(chart.update);  // uuuuuguggggh
  window.setTimeout(chart.update, 0);  // fixes wierd slightly-off bugs
  nv.addGraph(function() { return chart; });  // uuuuugly is nvd3
  return svg;
}


function nvColorifyCategories(chart, data, specific) {
  var numberOfCategories = specific.countCategories(data);
  chart.color(util.categoryColours(numberOfCategories));
  return chart;
}


function defaultGetTTContent(context) {
  return {tt: {
    heading: context.x.raw,
    bodyText: context.y.raw,
    formattedAmount: context.z.raw
  }};
}


function getNiceContext(raw, data, fmtY) {
  var seriesIndex = raw.seriesIndex || 0;
  return {
    data: data,
    series: {
      key: data[seriesIndex].key,
      index: seriesIndex,
      values: data[seriesIndex].values
    },
    x: {
      raw: raw.point.x,
      fmt: raw.label,
      index: raw.pointIndex || raw.index || 0
    },
    y: {
      raw: raw.point.y,
      fmt: raw.point.z || fmtY
    }
  };
}


function nvBindTooltip(chart, data, specific, template, getTTContent) {
  var nvTTHandler = function(seriesName, fmtX, fmtY, raw) {
    return template(getTTContent(getNiceContext(raw, data, fmtY)));
  };

  if (specific.normalizeNvTTArgs) { // we might have to fix nv's inconsistent TT args
    nvTTHandler = util.transformArgs(specific.normalizeNvTTArgs, nvTTHandler);
  }
  chart.tooltipContent(nvTTHandler);
}


function defaultClickHandler(/* context */) {
  // does nothing
}


function nvBindOthersCb(chart, data, specific, clickHandler) {
  chart[specific.dispatchName].dispatch.on('elementClick', function(raw) {
    clickHandler(getNiceContext(raw, data));
  });
}


function nvCharter(specific) {
  return function(data, options) {
    var svg = mkChartSVG(options.height, options.width),
        nvChart = specific.chart(options),
        nvData = specific.dataToNv(data);
    nvColorifyCategories(nvChart, data, specific);
    nvBindTooltip(nvChart, data, specific, options.ttTemplate, options.getTTContent);
    nvBoiler(nvData, nvChart, svg, specific, options.trimLabels, options.addLegend, options.width);
    nvBindOthersCb(nvChart, data, specific, options.clickHandler);
    return svg;
  };
}

function formatNumber(number) {
	var format = "";
	if (app.settings.numberFormatSettings.groupSeparator.length > 0) {
		format = "0,0";
	} else {
		format = "0";
	}
	if (app.settings.numberFormatSettings.numberFormat.indexOf('.') > 0) {
		var decimalDigits = app.settings.numberFormatSettings.numberFormat.length 
			- app.settings.numberFormatSettings.numberFormat.indexOf('.');
		format = format + "." + new Array(decimalDigits).join("0");
	}
	
	// Define a new "language" for Numeral where we can change the default
	// delimiters.
	var ampLang = {
		delimiters : {
			thousands : app.settings.numberFormatSettings.groupSeparator,
			decimal : app.settings.numberFormatSettings.decimalSeparator
		},
		abbreviations : {
			thousand : 'K',
			million : 'M',
			billion : 'B',
			trillion : 'T'
		},
		ordinal : function(number) {
			return number === 1 ? 'st' : 'rds';
		},
		currency : {
			symbol : '$'
		}
	};
	Numeral.language('amp', ampLang);
	// Apply new language.
	Numeral.language('amp');
	// Apply the format.
	var stringNumber = new Numeral(number).format(format);
	return stringNumber;
}

var ampLang = 


module.exports = {
  fail: fail,
  nvChartCommon: nvChartCommon,
  getNiceContext: getNiceContext,
  defaultGetTTContent: defaultGetTTContent,
  defaultClickHandler: defaultClickHandler,
  mkChartSVG: mkChartSVG,
  nvBoiler: nvBoiler,
  nvCharter: nvCharter,
  formatNumber: formatNumber
};

},{"../../ugly/util":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","d3-browserify":"d3-browserify","numeral":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/node_modules/numeral/numeral.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/customized/multiBarChart.js":[function(require,module,exports){

nv.models.customizedMultiBarChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var multibar = nv.models.multiBar()
    , xAxis = nv.models.axis()
    , yAxis = nv.models.axis()
    , legend = nv.models.legend()
    , controls = nv.models.legend() //this isn't exposed by default :(
    ;

  var margin = {top: 30, right: 20, bottom: 50, left: 60}
    , width = null
    , height = null
    , color = nv.utils.defaultColor()
    , showControls = true
    , showLegend = true
    , showXAxis = true
    , showYAxis = true
    , rightAlignYAxis = false
    , reduceXTicks = true // if false a tick will show for every data point
    , staggerLabels = false
    , rotateLabels = 0
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
        return '<h3>' + key + '</h3>' +
               '<p>' +  y + ' on ' + x + '</p>'
      }
    , x //can be accessed via chart.xScale()
    , y //can be accessed via chart.yScale()
    , state = { stacked: false }
    , defaultState = null
    , noData = "No Data Available."
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    , controlWidth = function() { return showControls ? 300 : 0 } /*Increased from 180 in original file.*/
    , transitionDuration = 250
    ;

  multibar
    .stacked(false)
    ;
  xAxis
    .orient('bottom')
    .tickPadding(7)
    .highlightZero(true)
    .showMaxMin(false)
    .tickFormat(function(d) { return d })
    ;
  yAxis
    .orient((rightAlignYAxis) ? 'right' : 'left')
    .tickFormat(d3.format(',.1f'))
    ;

  controls.updateState(false);
  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)),
        y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)),
        content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
  };

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;

      chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
      chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });

      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }
      //------------------------------------------------------------
      // Display noData message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x = multibar.xScale();
      y = multibar.yScale();

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-multiBarWithLegend').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarWithLegend').append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-x nv-axis');
      gEnter.append('g').attr('class', 'nv-y nv-axis');
      gEnter.append('g').attr('class', 'nv-barsWrap');
      gEnter.append('g').attr('class', 'nv-legendWrap');
      gEnter.append('g').attr('class', 'nv-controlsWrap');

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend.width(availableWidth - controlWidth());

        if (multibar.barColor())
          data.forEach(function(series,i) {
            series.color = d3.rgb('#ccc').darker(i * 1.5).toString();
          })

        g.select('.nv-legendWrap')
            .datum(data)
            .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }

        g.select('.nv-legendWrap')
            .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Controls

      var groupedLegendTrn = app.translator.translateSync("amp.dashboard:filters-chart-legends-Grouped","Grouped");
      var stackedLegendTrn = app.translator.translateSync("amp.dashboard:filters-chart-legends-Stacked","Stacked");
      if (showControls) {
        var controlsData = [
          { key: groupedLegendTrn, disabled: multibar.stacked() },
          { key: stackedLegendTrn, disabled: !multibar.stacked() }
        ];

        controls.width(controlWidth()).color(['#444', '#444', '#444']);
        g.select('.nv-controlsWrap')
            .datum(controlsData)
            .attr('transform', 'translate(0,' + (-margin.top) +')')
            .call(controls);
      }

      //------------------------------------------------------------


      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      if (rightAlignYAxis) {
          g.select(".nv-y.nv-axis")
              .attr("transform", "translate(" + availableWidth + ",0)");
      }

      //------------------------------------------------------------
      // Main Chart Component(s)

      multibar
        .disabled(data.map(function(series) { return series.disabled }))
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled }))


      var barsWrap = g.select('.nv-barsWrap')
          .datum(data.filter(function(d) { return !d.disabled }))

      barsWrap.transition().call(multibar);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Axes

      if (showXAxis) {
          xAxis
            .scale(x)
            .ticks( availableWidth / 100 )
            .tickSize(-availableHeight, 0);

          g.select('.nv-x.nv-axis')
              .attr('transform', 'translate(0,' + y.range()[0] + ')');
          g.select('.nv-x.nv-axis').transition()
              .call(xAxis);

          var xTicks = g.select('.nv-x.nv-axis > g').selectAll('g');

          xTicks
              .selectAll('line, text')
              .style('opacity', 1)

          if (staggerLabels) {
              var getTranslate = function(x,y) {
                  return "translate(" + x + "," + y + ")";
              };

              var staggerUp = 5, staggerDown = 17;  //pixels to stagger by
              // Issue #140
              xTicks
                .selectAll("text")
                .attr('transform', function(d,i,j) { 
                    return  getTranslate(0, (j % 2 == 0 ? staggerUp : staggerDown));
                  });

              var totalInBetweenTicks = d3.selectAll(".nv-x.nv-axis .nv-wrap g g text")[0].length;
              g.selectAll(".nv-x.nv-axis .nv-axisMaxMin text")
                .attr("transform", function(d,i) {
                    return getTranslate(0, (i === 0 || totalInBetweenTicks % 2 !== 0) ? staggerDown : staggerUp);
                });
          }

          if (reduceXTicks)
            xTicks
              .filter(function(d,i) {
                  return i % Math.ceil(data[0].values.length / (availableWidth / 100)) !== 0;
                })
              .selectAll('text, line')
              .style('opacity', 0);

          if(rotateLabels)
            xTicks
              .selectAll('.tick text')
              .attr('transform', 'rotate(' + rotateLabels + ' 0,0)')
              .style('text-anchor', rotateLabels > 0 ? 'start' : 'end');
          
          g.select('.nv-x.nv-axis').selectAll('g.nv-axisMaxMin text')
              .style('opacity', 1);
      }


      if (showYAxis) {      
          yAxis
            .scale(y)
            .ticks( availableHeight / 36 )
            .tickSize( -availableWidth, 0);

          g.select('.nv-y.nv-axis').transition()
              .call(yAxis);
      }


      //------------------------------------------------------------



      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      legend.dispatch.on('stateChange', function(newState) { 
        state = newState;
        dispatch.stateChange(state);
        chart.update();
      });

      controls.dispatch.on('legendClick', function(d,i) {
        if (!d.disabled) return;
        controlsData = controlsData.map(function(s) {
          s.disabled = true;
          return s;
        });
        d.disabled = false;

        switch (d.key) {
          case groupedLegendTrn:
            multibar.stacked(false);
            break;
          case stackedLegendTrn:
            multibar.stacked(true);
            break;
        }

        state.stacked = multibar.stacked();
        dispatch.stateChange(state);

        chart.update();
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode)
      });

      // Update chart from a state object passed to event handler
      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined') {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }

        if (typeof e.stacked !== 'undefined') {
          multibar.stacked(e.stacked);
          state.stacked = e.stacked;
        }

        chart.update();
      });

      //============================================================


    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  multibar.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  multibar.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });
  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.multibar = multibar;
  chart.legend = legend;
  chart.controls = controls;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;

  d3.rebind(chart, multibar, 'x', 'y', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'clipEdge',
   'id', 'stacked', 'stackOffset', 'delay', 'barColor','groupSpacing');

  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    return chart;
  };

  chart.showControls = function(_) {
    if (!arguments.length) return showControls;
    showControls = _;
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.showXAxis = function(_) {
    if (!arguments.length) return showXAxis;
    showXAxis = _;
    return chart;
  };

  chart.showYAxis = function(_) {
    if (!arguments.length) return showYAxis;
    showYAxis = _;
    return chart;
  };

  chart.rightAlignYAxis = function(_) {
    if(!arguments.length) return rightAlignYAxis;
    rightAlignYAxis = _;
    yAxis.orient( (_) ? 'right' : 'left');
    return chart;
  };

  chart.reduceXTicks= function(_) {
    if (!arguments.length) return reduceXTicks;
    reduceXTicks = _;
    return chart;
  };

  chart.rotateLabels = function(_) {
    if (!arguments.length) return rotateLabels;
    rotateLabels = _;
    return chart;
  }

  chart.staggerLabels = function(_) {
    if (!arguments.length) return staggerLabels;
    staggerLabels = _;
    return chart;
  };

  chart.tooltip = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };
  
  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };

  //============================================================


  return chart;
}
},{}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/check-support.js":[function(require,module,exports){
function queryselector() {
  return !!document.querySelector;  // fails on oooooooooold IE
}


function svg() {
  try {
    document.createElementNS('http://w3.org/2000/svg', 'svg');
    return true;
  } catch (err) { return false; }
}


function canvas() {
  return !!document.createElement('canvas').getContext;
}


function canvasText() {
  if (!canvas()) { return false; }
  var textFn = document.createElement('canvas').getContext('2d').fillText;
  return (typeof textFn === 'function');
}


var isIE = (function() {
  // http://stackoverflow.com/a/2401861/1299695
  // Magic. Do not touch.
  var yesItIs = !!(function() {
    var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (/trident/i.test(M[1])) {
      tem =  /\brv[ :]+(\d+)/g.exec(ua) || [];
      return 'MSIE ' + (tem[1] || '');
    }
    if (M[1] === 'Chrome') {
      tem = ua.match(/\bOPR\/(\d+)/);
      if (!!tem) { return 'Opera ' + tem[1]; }
    }
    M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
    if ((tem = !!ua.match(/version\/(\d+)/i))) { M.splice(1, 1, tem[1]); }
    return M.join(' ');
  })().match(/^MSIE/);

  return function() { return yesItIs; };
})();


function dataURLHref() {
  // I don't know how to feature-detect this :(
  // we will be optimisitic an only say "no" if we see IE.
  return !isIE();
}


function flash() {
  // http://stackoverflow.com/a/20095467/1299695
  // gross...
  try {
    return !!(new ActiveXObject('ShockwaveFlash.ShockwaveFlash')); // jshint ignore:line
  } catch (e) {
    return navigator.mimeTypes &&
      navigator.mimeTypes['application/x-shockwave-flash'] !== void 0 &&
      navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin;
  }
}


module.exports = function() {
  var missingFeatures = [];  // an empty array will cast to bool false. handy!

  if (!queryselector()) {
    missingFeatures.push({
      feature: 'querySelector',
      severity: 'critical'
    });
  }

  if (!svg()) {
    missingFeatures.push({
      feature: 'SVG',
      severity: 'critical'
    });
  }

  if (!canvasText()) {
    missingFeatures.push({
      feature: 'canvas',
      severity: 'major'
    });
  }

  if (!dataURLHref()) {
    missingFeatures.push({
      feature: 'download',
      severity: flash() ? 'minor' : 'major'
    });
  }

  if (!flash()) {
    missingFeatures.push({
      feature: 'flash',
      severity: isIE() ? 'major' : 'minor'
    });
  }

  return missingFeatures;
};

},{}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-aid-predictability.js":[function(require,module,exports){
var _ = require('underscore');
var ChartModel = require('./chart-model-base');


module.exports = ChartModel.extend({
	

	defaults : {
		title : ''
	},

  _prepareTranslations: function() {
    var self = this;
    var predictabilityBaseLanguage = {};

    /* Prepare the translations for the chart */
    predictabilityBaseLanguage['amp.dashboard:aid-predictability-planned-disbursements'] = 'Planned Disbursements';
    predictabilityBaseLanguage['amp.dashboard:aid-predictability-actual-disbursements'] = 'Actual Disbursements';

    this.localizedPredictability = this.app.translator.translateList(predictabilityBaseLanguage).then(
      function(localizedPredictabilityList) {
        self.localizedPredictabilityList = localizedPredictabilityList;
      });
  },

  parse: function(data) {
	this.set('title', data.title);
	
    function pick(which) {
      return function(d) {
        return {
          x: d.year,
          y: d[which]['amount'],
          z: d[which]['formattedAmount']
        };
      };
    }
    /* returns from map() like [{amp.gis:title-Region: 'Region'}, ... ]*/

    data.processed = [
      {
        key: this.localizedPredictabilityList['amp.dashboard:aid-predictability-planned-disbursements'],
        originalKey: 'planned',
        values: _(data.years).map(pick('planned disbursements'))
      },
      {
        key: this.localizedPredictabilityList['amp.dashboard:aid-predictability-actual-disbursements'],
        originalKey: 'actual',
        values: _(data.years).map(pick('actual disbursements'))
      }
    ];
    return data;
  }

});

},{"./chart-model-base":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-model-base.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-funding-type.js":[function(require,module,exports){
var _ = require('underscore');
var ChartModel = require('./chart-model-base');
var common = require('../charts/common');

module.exports = ChartModel.extend({

  defaults: {
    typed: true,
    limit: 3,
    title: ''
  },

  _prepareTranslations: function() {
    var self = this;
    var ftypeBaseLanguage = {};

    /* Prepare the translations for the chart */
    var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');

    /*
     * TODO: load all the localizations in this chart's namespace to this array
     * from initial-translation-request.json -- For now just hardcode the two sorts.
     */
    if (this.get('name') === 'Funding Type') {
      ftypeBaseLanguage[chartName + 'Grant'] = 'Grant';
      ftypeBaseLanguage[chartName + 'Loan'] = 'Loan';
      ftypeBaseLanguage[chartName + 'others'] = 'Others';
    }

    this.localizedFType = this.app.translator.translateList(ftypeBaseLanguage).then(
      function(localizedKeyVal) {
        self.localizedLookup = localizedKeyVal;
      });
  },

  parse: function(data) {
	this.set('title', data.title);
	
    var self = this;
    var years;
    if (data.values.length > 0 && !isNaN(parseInt((data.values)[0].Year, 10))) {
      years = _.sortBy(data.values, function(obj) { return parseInt(obj.Year, 10); });
    } else {
      years = _(data.values).sortBy('Year');
    }

    var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');
    var localizedOthers = self.localizedLookup[chartName + 'others'];

    // reformat the data for nvd3
    data.processed = _(years)
      .chain()
      .reduce(function(series, year) {
        series.push.apply(series, _(year.values).pluck('type'));
        return series;
      }, [])
      .uniq()
      .map(function(s) {
        var cleanName = s.replace(/[ :.]/g, '');
        var localizedName = s;
        if (self.localizedLookup[chartName + cleanName]) {
          localizedName = self.localizedLookup[chartName + cleanName];
        }
        return {
          key: localizedName,
          values: _(years).map(function(y) {
            var yearValue = _(y.values).findWhere({type: s});
            return {
              x: y.Year,
              y: yearValue && yearValue.amount || 0,
              z: yearValue && yearValue.formattedAmount || 0,
            };
          })
        };
      })
      .value();

    // group smallest contributors as "other"s
    if (this.get('limit') < data.processed.length) {
      var othersNames = _(data.processed)
        .chain()
        .map(function(series) {
          return {
            key: series.key,
            total: _(series.values).reduce(function(t, v) { return t + v.y; }, 0)
          };
        })
        .sortBy('total')
        .reverse()
        .rest(this.get('limit') - 2)  // 1 for .length offset, 1 for .rest offset
        .pluck('key')
        .value();

      var othersSeries = {
        key: localizedOthers,
        color: '#777',
        special: 'others',
        values: _(data.processed)
          .chain()
          .filter(function(series) { return _(othersNames).contains(series.key); })
          .map(function(series) { return series.values; })
          .transpose()
          .map(function(othersYear) {
            return {
              x: othersYear[0].x,
              y: _(othersYear).reduce(function(t, s) { return t + s.y; }, 0),
              z: ''
            };
          })
          .map(function(item) {
        	  return {
        		  x: item.x,
        		  y: item.y,
        		  z: common.formatNumber(item.y /** parseFloat(app.settings.numberMultiplier.name)*/)
        	  };
          })
          .value()
      };
      data.processed = data.processed.slice(0, this.get('limit'));
      data.processed.push(othersSeries);
    }

    return data;
  }

});

},{"../charts/common":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js","./chart-model-base":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-model-base.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-model-base.js":[function(require,module,exports){
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');


module.exports = BackboneDash.Model.extend({

  defaults: {},

  initialize: function(attrs, options) {
    this.app = options.app;
    this.url = options.url;
    this._prepareTranslations();  // TODO: refactor this implementation into here
  },

  hasData: function() {
    return _(this.get('processed'))
      .chain()
      .pluck('values')
      .reduce(function(result, values) {
        return values.length && true || result;
      }, false)
      .value();
  },

  fetch: function(options) {
    var data = JSON.parse(options.data);
    data.settings = this.app.settings.toAPI();

    if (this.get('adjtype')) {
      // TODO adjtype hard-coding key for now, should get from settings...
      data.settings = _({}).extend(data.settings, {0: this.get('adjtype')});
    }

    options.data = JSON.stringify(data);
    return BackboneDash.Model.prototype.fetch.call(this, options);
  }

});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-tops.js":[function(require,module,exports){
var param = require('jquery').param;
var _ = require('underscore');
var ChartModel = require('./chart-model-base');
var common = require('../charts/common');


module.exports = ChartModel.extend({

  defaults: {
    limit: 5,
    title: ''
  },

  _prepareTranslations: function() {
    var topBaseLanguage = {};

    this.chartName = 'amp.dashboard:chart-' + this.get('name').replace(/ /g, '');

    /*
     * TODO: load all the localizations in this chart's namespace to this array
     * from initial-translation-request.json -- For now just hardcode the two sorts.
     */
    if (this.get('name') === 'Top Regions') {
      topBaseLanguage[this.chartName + '-DistrictUndefined'] = 'Districts: Undefined';
    }
    topBaseLanguage[this.chartName + '-others'] = 'Others';

    this.localizedTopChart = this.app.translator.translateList(topBaseLanguage)
      .done(_(function(localizedTopChartKeyVal) {
        this.localizedLookup = localizedTopChartKeyVal;
      }).bind(this));
  },

  parse: function(data) {
	this.set('title', data.title);
	  
    if (!this.localizedLookup) {
      // we can't procede if we don't have translations yet :(
      // this code should now be unreachable, but y'never know...
      this.app.report('Loading error', [
      'Translations for the application were not loaded before rendering']);
    }

    this.localizedOthers = this.localizedLookup[this.chartName + '-others'];
    if (this.localizedOthers === undefined) {
    	console.error('missing translation in .json file: ' + this.chartName + '-others');
    }

    var values = _(data.values.slice()).map(function(v) {
      var cleanName = v.name.replace(/[ :.]/g, '');
      var localizedName = this.localizedLookup[this.chartName + '-' + cleanName] || v.name;

      return {
        x: localizedName,
        y: v.amount,
        z: v.formattedAmount,
        id: v.id
      };
    }, this);

    if (data.maxLimit > values.length) {
    	var other = {
    		x: this.localizedOthers,
    	    y: data.total -  // total minus the sum of what we have
    	    	_.chain(values).pluck('y').reduce(function(l, r) { return l + r; }, 0).value(),
    	    color: '#777',
    	    special: 'others'
    	};
    	//AMP-18740: We changed the EP to send raw numbers expressed in units so we need to apply the GS here.
    	other.z = common.formatNumber(other.y * parseFloat(app.settings.numberMultiplier.name));
    	values.push(other);
    }

    data.processed = [{values: values}];
    return data;
  },

  fetch: function(options) {
    options = _.defaults(
      options || {},
      { url: this.url + '?' + param(this.pick('limit')) });
    return ChartModel.prototype.fetch.call(this, options);
  }

});

},{"../charts/common":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/common.js","./chart-model-base":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-model-base.js","jquery":"jquery","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/charts-collection.js":[function(require,module,exports){
var BackboneDash = require('../backbone-dash');


module.exports = BackboneDash.Collection.extend({
  initialize: function(models, options) {
    this.app = options.app;
  }
});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/enabled-charts-collection.js":[function(require,module,exports){
var Backbone = require('backbone');
var _ = require('underscore');

var EnabledChartModel = Backbone.Model.extend({

});

var EnabledChartsCollection = Backbone.Collection.extend({
	model : EnabledChartModel,
	url : '/rest/common/fm',
	fetchData : function() {
		var params = {
			"detail-modules" : [ "DASHBOARDS" ]
		};
		this.fetch({
			type : 'POST',
			async : false,
			processData : false,
			mimeType : 'application/json',
			traditional : true,
			headers : {
				'Content-Type' : 'application/json',
				'Cache-Control' : 'no-cache'
			},
			data : JSON.stringify(params), // This is necessary due to
											// incompatibilities with Jersey
											// when receiving the params.
			error : function(collection, response) {
				console.error('error loading charts.');
			},
			success : function(collection, response) {
				// console.log(response);
			}
		});
	}
});

module.exports = EnabledChartsCollection;
},{"backbone":"backbone","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/saved-dash.js":[function(require,module,exports){
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');


var API_ID_KEY = 'mapId';


module.exports = BackboneDash.Model.extend({

  defaults: {
    name: undefined,
    description: undefined,
    stateBlob: undefined
  },

  // parse and toJSON map the id field to mapId for the API.
  parse: function(obj) {
    if (_(obj).has(API_ID_KEY)) {
      obj.id = obj[API_ID_KEY];
      delete obj[API_ID_KEY];
    }
    return obj;
  },

  initialize: function(attrs, options) {
    this.app = options.app;
    this.url = options.url;
  },

  toJSON: function() {
    var copy = BackboneDash.Model.prototype.toJSON.apply(this, arguments);
    if (_(copy).has('id')) {
      copy[API_ID_KEY] = copy.id;
      delete copy.id;
    }
    return copy;
  }

}, {
  fromId: function(id, options) {
    return new this({ id: id }, options);
  }
});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/saved-dashes-collection.js":[function(require,module,exports){
var _ = require('underscore');
var Deferred = require('jquery').Deferred;
var BackboneDash = require('../backbone-dash');
var SavedChart = require('./saved-dash');


module.exports = BackboneDash.Collection.extend({

  url: '/rest/dashboard/saved-charts',

  model: SavedChart,
  timer: undefined,
  initializedOnce: false,

  initialize: function(models, options) {
    this.app = options.app;
  },

  load: function(stateId) {
	var self = this;
	if (self.initializedOnce !== false) { return; }
	self.initializedOnce = true;
	 
	//console.log('load saved dashboard: ' + stateId);
    var deferred = new Deferred();
    var loaded = this.get(stateId);
    if (loaded) {
      deferred.resolve(loaded);
    } else {
      var model = this.model.fromId(stateId, { app: this.app });
      this.add(model);  // sets up collection so the model can find a URL
      model.fetch().done(function() {
          deferred.resolve(model);
          
          // AMP-19803 and AMP-20206: Here we wait until the filter widget has been loaded to trigger the 'apply' event and force each chart to redraw with the saved filters.
	      // Tried to do something similar before we reach this stage (ie: in app-class.js, chart-view-base.js, charts.js, etc) but without luck because the render is triggered automatically.
	      // TODO: We need more time to evaluate a solution using this.app.filter.loaded promise but that didnt work consistently on IE.          
          if (self.timer === undefined) {
        	  self.timer = setInterval(function() {
		    	  if (this.app !== undefined && this.app.filter !== undefined && this.app.filter.finishedFirstLoad === true) {
		    		  clearInterval(self.timer);
		    		  this.app.filter.trigger('apply');			    		  
		    		  // Only make 1 render call to the main app view, this will prevent other bugs (ie: the double and triple chart rendering).
		    		  if (this.app.rendered === false) {
		    			  this.app.rendered = true;
		    			  app.render();
		    		  }
		    	  }
		      }, 100);
          }
        }).fail(_(function() {
          this.app.report('Failed to load saved dashboard', ['Could not retrieve the saved state.']);
          deferred.reject();
        }).bind(this));
    }

    return deferred.promise();
   }
});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","./saved-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/saved-dash.js","jquery":"jquery","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/setting.js":[function(require,module,exports){
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');


module.exports = BackboneDash.Model.extend({

  initialize: function(attrs, options) {
    this.app = options.app;
    this.url = options.url;
  },

  select: function(optionId) {
    // unselect old
    var old = _(this.attributes.options).findWhere({selected: true});
    delete old.selected;
    // select new
    var newOpt = _(this.attributes.options).findWhere({id: optionId});
    newOpt.selected = true;

    this.trigger('change');  // sort of a hack to do this manually...
  }

});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/settings-collection.js":[function(require,module,exports){
var Deferred = require('jquery').Deferred;
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var Setting = require('./setting');


function isIntStr(n) {
  // test whether a string starts with is a base-10 int
  return !isNaN(parseInt(n, 10));
}


function tagIf(test, tag) {
  return function(setting) {
    if (test(setting)) {
      setting[tag] = true;
    }
    return setting;
  };
}


module.exports = BackboneDash.Collection.extend({

  url: '/rest/amp/settings',

  model: Setting,

  comparator: 'id',

  initialize: function(models, options) {
    this.app = options.app;
    this._loaded = null;
    _.bindAll(this, 'toAPI', 'fromState');
  },

  parse: function(settings) {
	this.extractNumberFormatSettings(settings);
    return _(settings).chain()
      // mark weird options with non-int keys hidden
      .map(tagIf(function(setting) { return !isIntStr(setting.id); }, 'ignore'))
      // mark funding type setting hidden, since it's set per-chart...
      .map(tagIf(function(setting) { return setting.id === '0'; }, 'ignore'))
      // ...but also flag it so the charts can see the the funding type options
      .map(tagIf(function(setting) { return setting.id === '0'; }, 'ftype'))
      // mark all options as selected per the defaults provided
      .map(function(setting) {
        return _(setting).extend({
          options: _(setting.options).map(tagIf(function(option) {
            return option.id === setting.defaultId;
          }, 'selected'))
        });
      })
      .value();
  },

  load: function() {
    if (this._loaded) {
      return this._loaded.promise();
    } else {
      this._loaded = new Deferred();
    }

    this.fetch({app: this.app })
      .then(_(function() {
        this._loaded.resolve();
      }).bind(this))
      .fail(_(function() {
        this.app.report('Failed to load dashboard settings',
          ['Could not connect to the server.']);
        this._loaded.reject();
      }).bind(this));

    return this._loaded.promise();
  },

  toAPI: function(overrides) {
    // format selected filter options the way the api wants
    // ignored filters are skipped (overrides are never removed though)
    // overrides should be in the {settingId: settingOptionId} format the api expects
    if (this.length === 0) { return {}; }  // cop out early if we don't have settings yet
    return this.chain()
      .map(function(model) { return model.toJSON(); })
      .filter(function(setting) { return !setting.ignore; })
      .reduce(function(apiFormatted, setting) {
        apiFormatted[setting.id] = _(setting.options)
          .findWhere({selected: true}).id;
        return apiFormatted;
      }, {})
      .extend(overrides || {})
      .value();
  },

  fromState: function(state) {
    // select options from an array with the same format we send to the api
    _(state).each(function(optId, settingId) {
      this.get(settingId).select(optId);
    }, this);
  },

  getVisible: function() {
    return this.filter(function(setting) { return !setting.get('ignore'); });
  },
  
  extractNumberFormatSettings: function(settings) {
	  var numberFormat = {}; 
	  var foundNF =_.find(settings, function(item) {return item.id === 'number-format'});
	  numberFormat.numberFormat = _.find(foundNF.options, function(item) { return item.id === foundNF.defaultId}).name || '#,#.#';

	  // If the format pattern doesnt have thousands grouping then ignore 'number-group-separator' param or it will 
	  // be used by JS to group by thousands (ie: in the 'Others' columns).
	  if(numberFormat.numberFormat.indexOf(',') !== -1) {
		  var foundNGS =_.find(settings, function(item) {return item.id === 'number-group-separator'});
		  numberFormat.groupSeparator = _.find(foundNGS.options, function(item) { return item.id === foundNGS.defaultId}).name || ',';
	  } else {
		  numberFormat.groupSeparator = '';
	  }
	  var foundDS =_.find(settings, function(item) {return item.id === 'number-decimal-separator'});
	  numberFormat.decimalSeparator = _.find(foundDS.options, function(item) { return item.id === foundDS.defaultId}).name || '.';
	  this.app.settings.numberFormatSettings = numberFormat;
	  
	  var foundNM =_.find(settings, function(item) {return item.id === 'number-multiplier'});
	  this.app.settings.numberMultiplier = _.find(foundNM.options, function(item) { return item.id === foundNM.defaultId});
	  if (this.app.settings.numberMultiplier.name === '1.0') {
		  this.app.settings.numberMultiplierDescription = 'amp.dashboard:chart-tops-inunits';
	  } else if(this.app.settings.numberMultiplier.name === '0.001') {
		  this.app.settings.numberMultiplierDescription = 'amp.dashboard:chart-tops-inthousands';
	  } else {
		  this.app.settings.numberMultiplierDescription = 'amp.dashboard:chart-tops-inmillions';
	  }
  }

});
},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","./setting":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/setting.js","jquery":"jquery","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-aid-predictability.js":[function(require,module,exports){
var d3 = require('d3-browserify');
var ChartViewBase = require('./chart-view-base');


module.exports = ChartViewBase.extend({

  uiDefaults: {
    big: false,
    view: 'multibar'
  },

  chartViews: [
    'multibar',
    'table'
  ],

  chartOptions: {
    nvControls: false
  },

  downloadChartOptions: {
    nvControls: false,
    trimLabels: false
  },

  getTTContent: function(context) {
  var of = app.translator.translateSync("amp.dashboard:of","of");
  var total = app.translator.translateSync("amp.dashboard:total","total");
  var units = app.translator.translateSync(app.settings.numberMultiplierDescription);

  // IMPORTANT: We assume this chart will ALWAYS show 2 data series.
  var index = -1;
  if (context.data[0].disabled === true) {
    index = 1;
  } else {
    index = context.series.index;
  }
  var header = context.x.raw + " " +
        app.translator.translateSync("amp.dashboard:aid-predictability-" +
        context.data[index].originalKey + "-" + this.model.get('measure'), "");

  var otherSeries = context.data[1 - index];  // WARNING: assumes only 2 series
  var otherHere = otherSeries.values[context.x.index];
  var line2Amount = 0;
  if(otherHere.y > 0) {
	  line2Amount = context.y.raw / otherHere.y;
  }
  var line2 = '<b>' + d3.format('%')(line2Amount) +
        '</b>&nbsp<span>' + of + '</span>&nbsp' + context.x.raw +
        '&nbsp<span>' + total + '</span>';

  return {tt: {
      heading: header,
      bodyText: '<b>' + context.y.fmt + '</b> ' + this.model.get('currency') + ' (' + units + ')',
      footerText: line2
    }};
  }

});

},{"./chart-view-base":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-view-base.js","d3-browserify":"d3-browserify"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-funding-type.js":[function(require,module,exports){
var d3 = require('d3-browserify');
var ChartViewBase = require('./chart-view-base');


module.exports = ChartViewBase.extend({

  uiDefaults: {
    big: true,
    adjtype: 'FAKE',
    view: 'multibar'
  },

  chartViews: [
    'multibar',
    'table'
  ],

  downloadChartOptions: {
    trimLabels: false
  },

  getTTContent: function(context) {
	var of = app.translator.translateSync("amp.dashboard:of","of");
	var total = app.translator.translateSync("amp.dashboard:total","total");
	var units = app.translator.translateSync(app.settings.numberMultiplierDescription);
    return {tt: {
      heading: context.x.raw + ' ' + context.series.key,
      bodyText: '<b>' + context.y.fmt + '</b> ' + this.model.get('currency') + ' (' + units + ')',
      footerText: '<b>' + d3.format('%')(context.y.raw / this.model.get('total')) + '</b>&nbsp<span>' + of + '</span>&nbsp' + context.x.raw + '&nbsp<span>' + total + '</span>'
    }};
  },

  chartClickHandler: function(context) {
    // clicking on the "others" bar loads five more.
    if (context.data[context.series.index].special === 'others') {
      this.model.set('limit', this.model.get('limit') + 1);
    }
  }

});

},{"./chart-view-base":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-view-base.js","d3-browserify":"d3-browserify"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-tops-info-modal.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<script type=\"text/javascript\">\n\tfunction openPreviewActivity(id) {\n\t\twindow.open('/aim/viewActivityPreview.do~public=true~pageId=2~activityId=' + id, '_blank');\n\t}\n</script>\n\n<div class='chart-tops-info-category'>\n\t<span>\n\t\t<b><%= (context.x.fmt || context.x.raw) %></b> - <%= model.get('adjtype')%> -  \t\t\n\t\t<span data-i18n=\"<%= app.settings.numberMultiplierDescription %>\"></span>\n\t\t<%= model.get('currency') %>\n\t</span>\n</div>\n<div class=\"chart-tops-info-container\">\n\t<div class=\"chart-tops-info-content\">\n\t\t<% if(values === undefined) { %>\n\t\t\t<img alt=\"\" src=\"/TEMPLATE/ampTemplate/dashboard/build/img/loading-icon.gif\">\n\t\t\t<span data-i18n=\"amp.dashboard:download-rendering\">Rendering...</span>\n\t\t<% } else { %>\n\t\t\t<% var rowClass = ''; %>\n\t\t\t<table>\n\t\t\t\t<tr>\n\t\t\t\t\t<th><span data-i18n=\"amp.dashboard:chart-tops-table-projecttitle\">Project Title</span></th>\n\t\t\t\t\t<th><span data-i18n=\"amp.dashboard:chart-tops-table-amount\">Amount</span></th>\n\t\t\t\t</tr>\t\t\t\n\t\t\t<% _(values).each(function(row, i) { %>\n          \t\t<% \tif (i % 2 === 0) rowClass = 'odd_row';\n    \t\t\t\telse rowClass = ''; %>\n    \t\t\t<tr class=\"<%=rowClass%>\">\n    \t\t\t\t<td>\n    \t\t\t\t\t<span class='pointer' onclick='openPreviewActivity(<%=row.id%>)'><%=row.name%></span>\n    \t\t\t\t</td>\n    \t\t\t\t<td><%=row.formattedAmount%></td>\n    \t\t\t</tr>\n        \t<% }) %>\n        \t</table>\n\t\t<% } %>\n\t</div>\n</div>");

module.exports = BackboneDash.View.extend({

	initialize: function(options) {
		this.app = options.app;
		this.context = options.context;
		this.model = options.model;
		this.numberMultiplier = app.settings.find(function(item) {return item.id === 'number-multiplier'});
	},

	render: function() {
		var self = this;
		this.$el.html(template({
			model: this.model,
			context: this.context,
			values: undefined,
			numberMultiplier: this.numberMultiplier
		}));
		app.translator.translateDOM($(".dash-settings-modal"));
		
		//TODO: move this code to a new model so the API call is made automatically.
    	var config = this.app.filter.serialize();
    	config.settings = this.app.settings.toAPI();
    	config.settings['0'] = this.model.get('adjtype');
    	$.ajax({
    		method: 'POST',
    		url: self.model.url + '/' + this.context.data[0].values[this.context.x.index].id,
    		dataType: 'json',
    		contentType: 'application/json',
    		processData: false,
    		data: JSON.stringify(config)
    	})
    	.done(function(data) {
    		//TODO: Can we avoid re-calling the template by binding the changes in the 'values' field? 
    		self.$el.html(template({
    			model: self.model,
    			context: self.context,
    			values: data.values,
    			numberMultiplier: self.numberMultiplier
    		}));
    		app.translator.translateDOM($(".dash-settings-modal"));
    	});
    	
		return this;
	},

});
},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-tops.js":[function(require,module,exports){
var d3 = require('d3-browserify');
var ChartViewBase = require('./chart-view-base');
var ModalView = require('./chart-tops-info-modal');

module.exports = ChartViewBase.extend({

  uiDefaults: {
    adjtype: 'FAKE'    
  },
  
  modalView: undefined,
  
  //Dont try to call initialize here because it throws a 'Module initialization error' :((
  /*initialize: function(options) {
	  this.modalView = new ModalView({ app: options.app, collection: this.model.collection });
  },*/

  downloadChartOptions: {
    trimLabels: false
  },

  getTTContent: function(context) {
	var ofTotal = app.translator.translateSync("amp.dashboard:of-total","of total");
	var units = app.translator.translateSync(app.settings.numberMultiplierDescription);
    return {tt: {
      heading: context.x.raw,
      bodyText: '<b>' + context.y.fmt + '</b> ' + this.model.get('currency') + ' (' + units + ')',
      footerText: '<b>' + d3.format('%')(context.y.raw / this.model.get('total')) + '</b>&nbsp<span>' + ofTotal + '</span>'
    }};
  },

  chartClickHandler: function(context) {	  
    // clicking on the "others" bar loads five more.
    if (context.data[context.series.index]
               .values[context.x.index].special === 'others') {
      this.model.set('limit', this.model.get('limit') + 5);
      if (this.model.get('limit') > 10) {  // also make the chart bigger if lots of bars are shown
        this.model.set('big', true);
      }
    } else if (this.model.get('showCategoriesInfo') === true) {    	
    	this.modalView = new ModalView({ app: app, context: context, model: this.model });
    	this.openInfoWindow();    	    	
    }
  },
  
  openInfoWindow: function() {
	  var specialClass = 'dash-settings-modal';
	  this.app.modal('Category Detail', {
		  specialClass: specialClass,
	      bodyEl: this.modalView.render().el,
	      i18nTitle: 'amp.dashboard:dashboard-chart-tops-info-modal'
	  });	    
	  // Translate modal popup.
	  app.translator.translateDOM($("." + specialClass));
  }

});

},{"./chart-tops-info-modal":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-tops-info-modal.js","./chart-view-base":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-view-base.js","d3-browserify":"d3-browserify"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-view-base.js":[function(require,module,exports){

var Deferred = require('jquery').Deferred;
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var getChart = require('../charts/chart');
var util = require('../../ugly/util');
var DownloadView = require('./download');
var template = _.template("<div class=\"col-xs-12 <% if (!model.get('big')) { %>col-md-6<% } else { %> big-chart<% } %>\">\n\n  <div class=\"panel panel-chart\">\n    <div class=\"panel-heading fix-title-height\">\n      <span class=\"pull-right big-number\">\n        <b class=\"chart-total\"></b>\n        <span class=\"chart-currency\"></span>\n      </span>\n      <h2 data-i18n=\"amp.dashboard:chart-<%= model.get('name').replace(/ /g,'') %>\"><%= model.get('title') %></h2>\n    </div>\n\n    <div class=\"panel-body\">\n      <div class=\"chart-container\">\n        <h3 class=\"dash-chart-diagnostic text-center\"></h3>\n        <div class=\"dash-chart-wrap\">\n        </div>\n        <button type=\"button\" class=\"btn btn-link btn-xs pull-right reset\" style=\"display:none\" data-i18n=\"amp.dashboard:chart-reset\">reset others</button>\n      </div>\n    </div>\n\n    <div class=\"panel-footer clearfix\">\n\n      <div class=\"pull-right\">\n\n        <div class=\"btn-group\">\n          <% _(views).each(function(view) { %>\n            <button type=\"button\" data-view=\"<%= view %>\"\n                class=\"chart-view btn btn-sm btn-<%= (view === model.get('view')) ? 'primary' : 'default' %>\">\n              <span class=\"glyphicon glyphicon-<%= {\n                bar: 'signal',\n                multibar: 'signal',\n                pie: 'adjust',\n                table: 'th-list'\n              }[view] %>\"></span>\n            </button>\n          <% }) %>\n        </div>\n\n        <div class=\"btn-group\">\n          <a\n            class=\"btn btn-sm btn-default download\"\n            download=\"AMP <%= model.get('title') %> - <%= (new Date()).toISOString().split('T')[0] %>.png\"\n            target=\"_blank\">\n            <span class=\"glyphicon glyphicon-cloud-download\"></span>\n          </a>\n          <button type=\"button\" class=\"btn btn-sm btn-<%= model.get('big') ? 'primary' : 'default' %> expand hidden-xs hidden-sm\">\n            <span class=\"glyphicon glyphicon-fullscreen\"></span>\n          </button>\n        </div>\n\n      </div><!-- buttons in .pull-right -->\n\n      <% if (model.get('adjtype')) { %>\n        <form class=\"form-inline dash-form dash-adj-type\" role=\"form\">\n          <select class=\"form-control like-btn-sm ftype-options\">\n            <option>...</option>\n            <!-- gets populated after settings load -->\n          </select>\n          <span class=\"cheat-lineheight\"></span>\n        </form>\n      <% } %>\n\n    </div>\n  </div>\n\n  <div class=\"export-modal\"></div>\n</div>\n\n");


var adjOptTemplate = _.template('<option value="<%=opt.id%>" ' +
  '<%= current ? selected="selected" : \'\' %>><%=opt.name%></option>');


module.exports = BackboneDash.View.extend({

  uiDefaults: {
    big: false,
    view: 'bar'
  },

  events: {
    'change .dash-adj-type select': 'changeAdjType',
    'click .reset': 'resetLimit',
    'click .chart-view': 'changeChartView',
    'click .download': 'download',
    'click .expand': 'big',
    'click .retry': 'render'
  },

  chartViews: [
    'bar',
    'pie',
    'table'
  ],

  initialize: function(options) {
    this.app = options.app;
    this.model.set(this.uiDefaults);
    this.rendered = false;
    this._stateWait = new Deferred();
    this.message = null;

    if (this.app.savedDashes.length) {
      // a bit sketch....
      this.app.state.loadPromise.always(this._stateWait.resolve);
    } else {
      this._stateWait.resolve();
    }

    this.listenTo(this.app.filter, 'apply', this.updateData);
    this.listenTo(this.app.settings, 'change', this.updateData);
    this.listenTo(this.model, 'change:adjtype', this.render);
    this.listenTo(this.model, 'change:limit', this.updateData);
    this.listenTo(this.model, 'change:view', this.render);

    this.app.state.register(this, 'chart:' + this.model.url, {
      get: _.partial(_(this.model.pick).bind(this.model), 'limit', 'adjtype', 'view', 'big'),
      set: _(this.model.set).bind(this.model),
      empty: null
    });

    _.bindAll(this, 'showChart', 'failLoading');
    if (this.getTTContent) { _.bindAll(this, 'getTTContent'); }
    if (this.chartClickHandler) { _.bindAll(this, 'chartClickHandler'); }
  },

  render: function() {    
    var renderOptions = {
      views: this.chartViews,
      model: this.model,
      chart: this.chartEl,
      util: util
    };
    this.$el.html(template(renderOptions));
    this.message = this.$('.dash-chart-diagnostic');
    this.chartContainer = this.$('.dash-chart-wrap');

    if (this.model.get('adjtype') !== void 0) {  // this chart has adj settings
    	this.app.settings.load().done(_(function() {
    		this.rendered = true;
        var adjSettings = this.app.settings.get('0');  // id for Funding Type
        if (!adjSettings) { 
        	this.app.report('Could not find Funding Type settings'); 
        } else {
        	if (this.model.get('adjtype') === 'FAKE') {
        		this.model.set('adjtype', adjSettings.get('defaultId'));
        	}
        }
        this.$('.ftype-options').html(
          _(adjSettings.get('options')).map(function(opt) {
            return adjOptTemplate({
              opt: opt,
              current: (opt.id === this.model.get('adjtype'))
            });
          }, this)
        );
      }).bind(this));
    } else {
    	this.rendered = true;
    }

    if (this._stateWait.state() !== 'pending') {
      this.updateData();
    }

    this.app.translator.translateDOM(this.el);
    return this;
  },

  updateData: function() {
	if(this.app.rendered !== true) { return; }
    if (!this.rendered) { return; }  // short-circuit on early filters apply event
    if (this._stateWait.state() === 'pending' ||  // short-circuit until we have state
        this.app.settings.load().state() === 'pending') {  // short-circuit until we have settings
      this.message.html('Loading saved settings...').attr('data-i18n', 'amp.dashboard:chart-loading-saved-settings');
      app.translator.translateDOM($('.chart-container'));
      //this.message.fadeIn(100);
      return;
    }

    this.chartContainer.empty();
    this.message.html('<span data-i18n="amp.dashboard:loading">...</span>').fadeIn(100);

    this.app.translator.getTranslations()
      .done(_(function() {  // defer here to prevent a race with translations loading

        /* TODO: Do we really want to localize this and slow things?*/
        //this.app.translator.translateDOM(this.el);

        this.model.fetch({
          type: 'POST',  // TODO: move fetch options to model?
          data: JSON.stringify(this.app.filter.serialize())
        })
        .always(_(function() {  }).bind(this))
        .done(this.showChart)
        .fail(this.failLoading);
      }).bind(this))
      .fail(_(function() {
        this.app.report('Could not load translations', [
          'Refreshing the page may fix the issue.']);
      }).bind(this));

  },

  showChart: function() {
    // TODO: why are we triggering twice on load???
    if (!this.model.hasData()) {
      this.message.html('No Data Available').attr('data-i18n','amp.dashboard:chart-no-data-available');
      app.translator.translateDOM($('.chart-container'));
      this.resetNumbers();
      return;
    }
    var chart = getChart(this.model.get('view'), this.model.get('processed'), this.getChartOptions());
    this.chartContainer.html(chart.el);

    this.renderNumbers();
    var limit = this.model.get('limit');
    if (limit) {
      this.$('.reset')[limit === this.model.defaults.limit ? 'hide' : 'show']();
    }
    this.message.stop().fadeOut(200);
    
    this.beautifyLegends(this);
  },

  getChartOptions: function() {
    var co = _(_(this.chartOptions).clone() || {}).defaults({
      trimLabels: !this.model.get('big'),
      getTTContent: this.getTTContent,
      clickHandler: this.chartClickHandler,
      width: this.$('.panel-body').width(),
      height: this.$('.panel-body').height()
    });
    return co;
  },

  failLoading: function() {
    this.message.html('Failed to load data <small>' + arguments[2] +
      ' <button type="button" class="retry btn btn-warning btn-sm">' +
      '<span class="glyphicon glyphicon-refresh"></span> Retry</button></small>').show();
    console.error('failed loading chart :(', arguments);
  },

  renderNumbers: function() {
    if (this.model.get('total')) {
      //this.$('.chart-total').html(util.formatKMB(3, app.settings.numberFormatSettings.decimalSeparator)(this.model.get('total')));
    	this.$('.chart-total').html(this.model.get('sumarizedTotal'));
    }
    this.$('.chart-currency').html(this.model.get('currency'));
  },

  resetNumbers: function() {
    this.$('.chart-total').html('');
    this.$('.chart-currency').html('');
  },

  resetLimit: function() {
    this.model.set('limit', this.model.defaults.limit);
  },

  changeAdjType: function(e) {
    var newType = e.currentTarget.value;
    this.model.set('adjtype', newType);
  },

  changeChartView: function(e) {
    var view = util.data(e.currentTarget, 'view');
    this.model.set('view', view);
  },

  big: function() {
    // toggle big/small charts on large screens
    this.model.set('big', !this.model.get('big'));
  },

  setClear: function(shouldBreak) {
    // layout hints, should only be called by ./charts.js
    this.$el[shouldBreak ? 'addClass' : 'removeClass']('clearfix');
  },

  download: function() {
    var downloadView = new DownloadView({
      app: this.app,
      model: this.model,
      chartOptions: _(this.getChartOptions()).omit('height', 'width')
    });
    var specialClass = 'dash-download-modal';
    this.app.modal('Download chart', {
      bodyEl: downloadView.render().el,
      specialClass: specialClass,
      i18nTitle: 'amp.dashboard:download-download-chart'
    });
    
    // Translate modal popup.	
   	app.translator.translateDOM($("." + specialClass));
  },
  
  //AMP-18630: Here we setup a simple tooltip for each legend element.
  beautifyLegends : function(self) {	  
	  var hasValues = false;
	  var hasProcessed = false;
	  if(self.model != undefined && self.model.get('values') != undefined && self.model.get('values').length > 0) {
		  hasValues = true;
	  }
	  if(self.model != undefined && self.model.get('processed') != undefined && self.model.get('processed').length > 1) {
		  hasProcessed = true;
	  }
	  
	  // Iterate the list of legend elements in DOM (only for this chart) and set a data element called 'data-title' that
	  // will be then used when a hover event is fired.
	  $(this.$el).find(".nv-series").each(function(i, elem) {
		  if(hasValues && !hasProcessed) {
			  // Top charts.
			  if(self.model.get('values')[i] != undefined) {
				  $(elem).data('data-title', self.model.get('values')[i].name);
			  } else {
				// This the last legend "Others" (doesnt come in the data).
		    	$(elem).data('data-title', app.translator.translateSync("amp.dashboard:chart-FundingType-others", "Others"));
			  }
		  } else if(hasProcessed) {
			  // Aid Predictability charts and Funding Type charts.
			  if(self.model.get('processed')[i] != undefined) {
				  // The extra check is for FT charts that have more legends (grouped, stacked, etc).
				  $(elem).data('data-title', self.model.get('processed')[i].key);
			  }
		  }
	    
		  // Now bind NV tooltip mechanism to hover event for each legend.
		  if($(elem).data('data-title')) {
			  $(elem).hover(function() {
	    		var offset = $(this).offset();
	    		//TODO: Remove hardcoded html and use a template.
	    	    nv.tooltip.show([offset.left, offset.top], "<div class='panel panel-primary panel-popover'><div class='panel-heading'>" + $(elem).data('data-title') + "</div></div>");
	    	        
	    	    // TODO: Find a way to trigger the mouseover on the bar.
	    	    // $($(this).closest('svg').find(".nv-groups").find(".nv-bar")[i]).trigger('hover');
	    	   }, function() {
	    		   nv.tooltip.cleanup();
	    	   });
		  }
	  });
  }

});

},{"../../ugly/util":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","../charts/chart":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/chart.js","./download":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/download.js","jquery":"jquery","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/charts.js":[function(require,module,exports){
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');

var Tops = require('../models/chart-tops');
var Predictability = require('../models/chart-aid-predictability');
var FundingType = require('../models/chart-funding-type');

var TopsChartView = require('./chart-tops');
var PredictabilityChartView = require('./chart-aid-predictability');
var FundingTypeChartView = require('./chart-funding-type');


module.exports = BackboneDash.View.extend({

  className: 'row',

  initialize: function(options) {
    this.app = options.app;
    this.chartViews = this.collection.map(function(chart) {
      var ChartView = chart instanceof Tops ? TopsChartView
                    : chart instanceof Predictability ? PredictabilityChartView
                    : chart instanceof FundingType ? FundingTypeChartView
                    : null;
      return new ChartView({ model: chart, app: this.app });
    }, this);
    this.listenToOnce(this.app.filter, 'apply', this.applyFilter);
    this.listenTo(this.collection, 'change:big', this.injectBreaks);
  },

  render: function() {
    this.$el.html(_(this.chartViews).map(function(view) {
      return view.render().el;
    }));
    this.injectBreaks();
    return this;
  },

  injectBreaks: function(chartModel) {
    _(this.chartViews).reduce(function(breakAfter, thisView) {
      thisView.setClear(breakAfter);
      if (!breakAfter) {
        return thisView.model.get('big') ? false : true;
      } else {
        return false;
      }
    }, false);

    if (chartModel) {
      var chartView = _(this.chartViews).find(function(v) {
        return v.model === chartModel;
      });
      if (chartView) { chartView.render(); }
    }
  }

});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","../models/chart-aid-predictability":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-aid-predictability.js","../models/chart-funding-type":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-funding-type.js","../models/chart-tops":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-tops.js","./chart-aid-predictability":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-aid-predictability.js","./chart-funding-type":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-funding-type.js","./chart-tops":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/chart-tops.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/controls.js":[function(require,module,exports){
var BackboneDash = require('../backbone-dash');
var Filters = require('./filters');
var Settings = require('./settings');
var Share = require('./share');


module.exports = BackboneDash.View.extend({

  className: 'row',

  initialize: function(options) {
    this.app = options.app;    
    this.settings = new Settings({ app: this.app });
    this.filters = new Filters({ app: this.app });
    this.share = new Share({ app: this.app });
  },

  render: function() {
    this.$el.html([
      this.filters.render().el,
      this.settings.render().el,
      this.share.render().el
    ]);
    return this;
  }

});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","./filters":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/filters.js","./settings":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/settings.js","./share":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/share.js"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/download.js":[function(require,module,exports){
var _ = require('underscore');
var baby = require('babyparse');
var canvg = require('../../ugly/lib-load-hacks').canvg;
var util = require('../../ugly/util');


var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var getChart = require('../charts/chart');
var util = require('../../ugly/util');
var template = _.template("<h4 data-i18n=\"amp.dashboard:download-preview\">Preview:</h4>\n\n<!-- This 'modal' div fixes AMP-19525: In FF when the chart is drawn (for less than a second) in 'svg-wrap', sometimes the mouse cursor is over one of the bars and triggers the tooltip,\nthat process is not fully performed thus resulting in incomplete html which is rejected by the browser :(  -->\n<div class=\"modal-preview-area\">\n</div>\n<div class=\"preview-area\">\n\t<div class=\"svg-wrap hidden\">\n  \t</div>\n  \t<div class=\"canvas-wrap hidden\">\n  \t</div>\n  \t<div class=\"table-wrap hidden\">\n  \t</div>\n</div>\n\n<div class=\"text-center\">\n  <a class=\"btn btn-success download-chart disabled\">\n    <span class=\"glyphicon glyphicon-download\"></span>\n    <span data-i18n=\"amp.dashboard:download-rendering\" class=\"word\">Rendering...</span>\n  </a>\n</div>\n");


module.exports = BackboneDash.View.extend({
 
  //TODO: This is wrong because different countries have other measures (ie: ssc).	
  adjTypeTranslation : {"Actual Commitments":"amp.dashboard:ftype-actual-commitment",
			"Actual Disbursements":"amp.dashboard:ftype-actual-disbursement",
				"Actual Expenditures":"amp.dashboard:ftype-actual-expenditure",
				"Planned Commitments": "amp.dashboard:ftype-planned-commitment",
				"Planned Disbursements": "amp.dashboard:ftype-planned-disbursement",
				"Planned Expenditures": "amp.dashboard:ftype-planned-expenditures"
			    },
  initialize: function(options) {
    this.app = options.app;
    this.dashChartOptions = _({}).extend(options.chartOptions, {
      height: 450,  // sync with css!!!
      width: 970,	// sync with css!!!
      trimLabels: false
    });
  },

  render: function() {
    this.$el.html(template());

    if (this.model.get('view') === 'table') {
      this.renderCSV(this.$('.preview-area .table-wrap').removeClass('hidden'));
    } else {
    	// Here we will define an interval that will check periodically if the bootstrap modal is fully rendered.
    	// In that moment the interval is finished and the chart is rendered.
    	var self = this;
    	var rendered = false; // This flag is used to avoid triggering the render process twice in case the browser mess up the interval.
    	var interval = window.setInterval(function() {
    		if ($('.dash-download-modal').closest('.in').length > 0) {
    			window.clearInterval(interval);    			   			
    			nv.tooltip.cleanup();
    			if (rendered === false) {
    				rendered = true;
    				self.renderChart(self.$('.preview-area .svg-wrap').removeClass('hidden'), 
    						self.$('.preview-area .canvas-wrap'));
    			}
    		}
    	}, 100);      
    }
    return this;
  },

  renderChart: function(svgContainer, canvasContainer) {
    if (_(this.app.browserIssues).findWhere({feature: 'canvas'})) {
      this.app.viewFail(this, 'Chart export requires a modern web browser');
    }
    var view = this.model.get('view'),
        data = this.model.get('processed'),
        canvas = document.createElement('canvas'),
        chartEl = getChart(view, data,
          _({}).extend(this.dashChartOptions, { height: this.dashChartOptions.height - 42 })).el;

    svgContainer.html(chartEl);

    this.prepareCanvas(canvas, this.dashChartOptions.height, this.dashChartOptions.width);

    this.chartToCanvas(chartEl, canvas, function() {
      svgContainer.hide();
      var img = new Image();
      img.src = canvas.toDataURL('image/png');
      canvasContainer.html(img);
      $(canvasContainer).removeClass('hidden');
      $('.modal-preview-area').remove();
      this.makeDownloadable(img.src, 'chart', '.png');      
    });

  },

  prepareCanvas: function(canvas, h, w) {
    var ctx = canvas.getContext('2d'),
        moneyContext = (this.model.get('sumarizedTotal') !== undefined ? ': ' + this.model.get('sumarizedTotal') + ' ': ' ') + this.model.get('currency'),        
        adjType = this.model.get('adjtype');

    if (adjType) {
      var adjSettings = this.app.settings.get('0');  // id for Funding Type
      if (!adjSettings) { this.app.report('Could not find Funding Type settings'); }
      var adjName = _(adjSettings.get('options')).find(function(s) {
        return s.id === adjType;
      }).name;

      // var localAdj = this.app.translator.translateSync()
      // TODO: localize adjtype? is that necessary?
      moneyContext = adjName + moneyContext;
    }

    // size the canvas
    canvas.setAttribute('width', w);
    canvas.setAttribute('height', h);

    // make the background opaque white
    ctx.beginPath();
    ctx.rect(0, 0, w, h);
    ctx.fillStyle = '#fff';
    ctx.fill();

    // Add the chart title
    ctx.fillStyle = '#163f66';
    ctx.font = 'bold 22px "Open Sans"';
    var localName = this.app.translator.translateSync('amp.dashboard:chart-' +
      this.model.get('name').replace(/ /g, ''), this.model.get('name'));
    ctx.fillText(localName.toUpperCase(), 10, 10 + 22);
    // what money are we talking about?
    ctx.fillStyle = '#333';
    ctx.textAlign = 'right';
    ctx.fillText(moneyContext, w - 10, 10 + 22);
    ctx.textAlign = 'left';  // reset it

    // reset font to something normal (nvd3 uses css ugh...)
    ctx.font = 'normal 12px "sans-serif"';
  },

  chartToCanvas: function(svg, canvas, cb) {
    var boundCB = _(cb).bind(this);
    window.setTimeout(function() {
      this.app.tryTo(function() {
        canvg(canvas, svg.parentNode.innerHTML, { // note: svg.outerHTML breaks IE
          offsetY: 42,
          ignoreDimensions: true,
          ignoreClear: true,
          ignoreMouse: true,
          renderCallback: boundCB
        });
      }, this);
    }.bind(this), 1500);  // we have to wait for stupid nvd3...
  },

  renderCSV: function(csvContainer) {
    var data = this.model.get('processed'),
        currency = this.model.get('currency'),
        adjtype = this.model.get('adjtype') || false,
        csvTransformed,
        headerRow,
        textContent,
        preview;

    var self = this;
    var keys = _(data).pluck('key');
    // table of all the data
    csvTransformed = _(data)
      .chain()
      .pluck('values')
      .transpose()
      .map(function(row) {
        return _(row).reduce(function(csvRow, cell) {
          csvRow.push(cell.y);
          return csvRow;
        }, [row[0].x]);
      })
      .map(function(row) {
        row.push(currency || '');
        if (adjtype) {
        	var key = self.adjTypeTranslation [adjtype];
            var trnAdjType = this.app.translator.translateSync(key, adjtype);
            row.push(trnAdjType);
        }
        return row;
      })
      .value();  
    
    // prepend a header row
    headerRow = [];
    var amountTrn = this.app.translator.translateSync('amp.dashboard:download-amount', 'Amount');
    var currencyTrn = this.app.translator.translateSync('amp.dashboard:currency', 'Currency');
    var typeTrn = this.app.translator.translateSync('amp.dashboard:type', 'Type');
    var yearTrn = this.app.translator.translateSync('amp.dashboard:year', 'Year');
    
	if (this.model.url.indexOf('/tops') > -1) {
	    headerRow.push(this.model.get('title'));
	    headerRow.push(amountTrn);
	    headerRow.push(currencyTrn);
	    headerRow.push(typeTrn);
	} else if (this.model.url.indexOf('/aid-predictability') > -1) {
	    headerRow.push(yearTrn);
	    _.each(keys, function(item) {
	    	headerRow.push(item);
	    });
	    headerRow.push(currencyTrn);
	} else if (this.model.url.indexOf('/ftype') > -1) {
		headerRow.push(yearTrn);
	    _.each(keys, function(item) {
	    	headerRow.push(item);
	    });
	    headerRow.push(currencyTrn);
	    headerRow.push(typeTrn);
	}    

    csvTransformed.unshift(headerRow);

    textContent = baby.unparse(csvTransformed, {
    	quotes: true
    });

    preview = document.createElement('textarea');
    preview.setAttribute('class', 'csv-preview');
    preview.value = textContent;
    csvContainer.html(preview);

    if (!this.app.hasIssue('download')) {
      textContent = util.textAsDataURL(textContent);
    }

    window.setTimeout(_(function() {  // stupid bootstrap modals...
      // this setTimeout is needed for the flash fallback :(
      this.makeDownloadable(textContent, 'data', '.csv');
    }).bind(this), 100);
  },

  makeDownloadable: function(stuff, what, ext) {
    var fileName = this.model.get('name') + ext,
        dlButton = this.$('.download-chart').removeClass('disabled');
    dlButton.find('.word').text('Download ' + what).attr('data-i18n', 'amp.dashboard:download-download-' + what);
    app.translator.translateDOM(dlButton);

    if (this.app.hasIssue('download')) {
      if (this.app.hasIssue('flash')) {
        this.app.report('Your browser is missing features to initiate the download', [
          'You might be able to save this chart manually by right-clicking the ' +
          'preview and selecting "Save Picture As...']);
      } else {
        // bad browser, but has flash! fallback to downloadify
        this.app.tryTo(function() {
          window.Downloadify.create(dlButton[0], {
            swf: '/TEMPLATE/ampTemplate/commonMedia/downloadify.swf',
            downloadImage: '/TEMPLATE/ampTemplate/commonMedia/download-button-states.png?rev=4',
            transparent: true,
            width: 176,
            height: 34,
            filename: fileName,
            data: stuff
              .replace('data:text/plain;base64,//', '')
              .replace('data:image/png;base64,', ''),
            dataType: ext === '.csv' ? 'string' : 'base64',
            append: true,
            onError: function() {
              this.app.report('Could not download the file.');
            }
          });
        }, this);
      }
    } else {
      this.$('.download-chart')
        .attr('href', stuff)
        .attr('download', fileName);
    }
    
    // AMP-19813
    if (ext.indexOf('csv') !== -1) {
    	$('.modal-preview-area').remove();
    }
  }

});

},{"../../ugly/lib-load-hacks":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-load-hacks.js","../../ugly/util":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js","../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","../charts/chart":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/charts/chart.js","babyparse":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/node_modules/babyparse/babyparse.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/fail.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<div class=\"container\">\n  <header class=\"spaced text-center\">\n    <h2>\n      The application encountered an\n      <span class=\"text-danger\">error</span>\n      <small>:(</small>\n    </h2>\n    <p><%= err %></p>\n  </header>\n</div>\n");


module.exports = BackboneDash.View.extend({

  initialize: function(options) {
    this.app = options.app;
    this.err = options.err;
  },

  render: function() {
    this.$el.html(template({ err: this.err }));
    return this;
  }

});


},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/filters.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<div class=\"col-xs-12 col-md-5\">\n  <div class=\"panel\">\n    <div class=\"panel-body\">\n      <button type=\"button\" class=\"btn btn-sm btn-default pull-right show-filters\">\n        <span class=\"glyphicon glyphicon-edit\"></span>\n        <span data-i18n=\"amp.dashboard:filters-edit\">Edit filters</span>\n      </button>\n      <h3 class=\"inline-heading\" data-i18n=\"amp.common:title-filters\">Filters</h3>\n      <div class=\"applied-filters\">\n        <em data-i18n=\"amp.common:filters-loading\">Loading...</em>\n      </div>\n    </div>\n  </div>\n</div>\n<div id=\"filter-popup\"></div>\n");
var summaryTemplate = _.template("<% if (!countApplied) { %>\n  <em data-i18n=\"amp.dashboard:filters-none-applied\">No filters applied</em>\n<% } else { %>\n  <span>\n    <button class=\"btn btn-default btn-sm show-filter-details\">\n      <span class=\"glyphicon glyphicon-eye-open\"></span>\n      <span data-i18n=\"amp.dashboard:filters-show-settings\">Show filter settings</span>\n      (<b><%= countApplied %></b>)\n    </button>\n  </span>\n<% } %>\n");
var detailsTemplate = _.template("<% _(applied).each(function(filter) { %>\n  <h5>\n    <a href=\"#filter-detail-<%= filter.id %>\" data-toggle=\"collapse\" aria-expanded=\"false\"><%= filter.name %></a>\n    (<%= filter.detail.length %>)\n  </h5>\n  <ul id=\"filter-detail-<%= filter.id %>\" class=\"collapse\">\n    <% _(filter.detail).each(function(detail) { %>\n      <li><%= detail %></li>\n    <% }) %>\n  </ul>\n<% }) %>\n\n<div>\n  <button type=\"button\" class=\"btn btn-sm btn-default hide-filter-details\">\n    <span class=\"glyphicon glyphicon-eye-close\"></span>\n    <span data-i18n=\"amp.dashboard:filters-hide-details\">Hide filter details</span>\n  </button>\n</div>\n");


module.exports = BackboneDash.View.extend({

  events: {
    'click .show-filters': 'showFilter',
    'click .show-filter-details': 'showFilterDetails',
    'click .hide-filter-details': 'hideFilterDetails'
  },
  
  initialize: function(options) {
    this.finishedFirstLoad = false;
	this.app = options.app;
    this.listenTo(this.app.filter, 'cancel', this.hideFilter);
    this.listenTo(this.app.filter, 'apply', this.applyFilter);
    this.app.settings.load().done(_(function() {
    	// Extract default dates from Global Settings.
    	var blob = {};
    	// AMP-19254, AMP-20537: override the "date" range with the Dashboards-specific one from the settings blob (a hack...) 
    	this.app.filter.extractDates(this.app.settings.models, blob, 'dashboard-default-min-date', 'dashboard-default-max-date');
    	
	    this.app.filter.loaded.done(_(function() {
	    	console.error('filters loaded');
	      this.app.state.register(this, 'filters', {
	        // namespace serialized filters so we can hook in extra state to store
	        // later if desired (anything dashboards-ui related, for example)
	        get: _(function() { 
	        	return {filter: this.app.filter.serialize() }; 
	        }).bind(this),
	        set: _(function(state) {
	        	if (state.filter.otherFilters !== undefined && state.filter.otherFilters.date !== undefined) {
	        		console.log('Using saved filters.');	        		
	        	} else {
	        		console.log('Using default filter dates.');
	        		state.filter = blob;
	        	}
	        	this.app.filter.deserialize(state.filter);
	        	this.app.filter.finishedFirstLoad = true;
	        }).bind(this),
	        empty: {filter: {}}
	      });
	    }).bind(this));
    }).bind(this));
  },

  render: function() {
    this.$el.html(template());
    this.app.filter.setElement(this.el.querySelector('#filter-popup'));
    this.hideFilter();
    this.app.filter.loaded
      .done(_(this.renderApplied).bind(this))
      .fail(_(function() {
        this.$('.applied-filters').html('<strong class="text-danger filters-err">' +
          'Failed to load filters</strong> <a href="" class="btn btn-warning btn-sm">' +
          '<span class="glyphicon glyphicon-refresh"></span> Refresh page</a>');
        this.$('button').addClass('disabled');
      }).bind(this));
    return this;
  },

  renderApplied: function() {
    var filters = this.app.filter.serializeToModels();
    var countApplied = _(filters.columnFilters).keys().length;
    countApplied += !!filters.otherFilters;
    this.$('.applied-filters').html(summaryTemplate({ countApplied: countApplied }));
    this.app.translator.translateDOM(this.el);
  },

  showFilter: function() {
    this.app.filter.showFilters();
    this.$('#filter-popup').show();
  },

  hideFilter: function() {
    this.$('#filter-popup').hide();
  },

  applyFilter: function() {
    // todo: actually do an effect for changed filters...
    this.hideFilter();
    this.renderApplied();
  },

  showFilterDetails: function() {
    var filters = this.app.filter.serializeToModels();
    var applied = _(filters.columnFilters).map(function(filter, key) {
      return {
        name: filter.filterName || key,
        id: key.replace(/[^\w]/g, ''),  // remove anything non-alphanum
        detail: _(filter).map(function(value) {
        	if (value.attributes !== undefined) {
        		return value.get('name');
        	} else {       		
        		// To fix problem with dates.
        		if (value !== key && value !== filter.filterName) {
        			return value;
        		}
        	}
        })
      };
    });
    if (filters.otherFilters) {
      // Currently assumes that any otherFilters just implies Date Range
      // ... there is no obvious way to get nice strings out.
      var dateRange = filters.otherFilters.date;
      var dateRangeText = app.translator.translateSync("amp.dashboard:date-range","Date Range");
	  applied.push({
        name: dateRangeText,
        detail: [dateRange.start + '&mdash;' + dateRange.end]
      });
    }
    this.$('.applied-filters').html(detailsTemplate({ applied: applied }));
    this.app.translator.translateDOM(this.el);
  },

  hideFilterDetails: function() {
    this.renderApplied();
  }

});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/footer.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var footerTemplate = _.template("<style>\n.footerText {\n  padding: 0;\n  font-family: arial;\n  font-size: 11px;\n  border: 1px solid rgb(221, 221, 221);\n  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);\n}\n.footer {\n  background-color: #8B8B8B;\n  color: #FFF;\n  margin-top: 0;\n  padding-bottom: 10px;\n  padding-top: 10px;\n  text-align: center;\n}\n.dgf_footer {\n  color: #8B8B8B;\n  line-height: 18px;\n  margin: 15px 0;\n  text-align: center;\n}\n.dgf_footer img {\n  line-height: 18px;\n  margin-bottom: 5px;\n}\n</style>\n\n<div class=\"col-xs-12\">\n  <div class=\"panel dash-row footerText\">\n    <div class=\"dgf_footer\">\n      <img src=\"/TEMPLATE/ampTemplate/img_2/dgf_logo_bottom.gif\" class=\"dgf_logo_footer\"><br>\n      1110 Vermont Ave NW, Washington, D.C. 20005, USA<br>\n      info@developmentgateway.org, Tel: +1.202.572.9200, Fax: +1 202.572.9290\n    </div>\n  </div>\n</div>\n");


module.exports = BackboneDash.View.extend({

  className: 'row',

  initialize: function(options) {
    this.app = options.app;
  },

  render: function() {
    this.$el.html(footerTemplate());
    return this;
  }

});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/header.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var headerTemplate = _.template("<div class=\"col-xs-12\">\n  <div class=\"panel dash-row footerText\">\n    <div class=\"panel-body dash-header\">\n      <h1 data-i18n=\"amp.common:title\" class=\"inline-heading\">\n        AMP\n        <small data-i18n=\"amp.common:title-dashboards\">Dashboards</small>\n      </h1>\n    </div>\n  </div>\n</div>\n");


module.exports = BackboneDash.View.extend({

  className: 'row',

  initialize: function(options) {
    this.app = options.app;
  },

  render: function() {
    this.$el.html(headerTemplate());
    return this;
  }

});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/main.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');

var StateLoadError = require('amp-state/index').StateLoadError;

var Header = require('./header');
var Controls = require('./controls');
var ChartsView = require('./charts');
var Charts = require('../models/charts-collection');
var Footer = require('./footer');

var TopsChart = require('../models/chart-tops');
var PredictabilityChart = require('../models/chart-aid-predictability');
var FundingTypeChart = require('../models/chart-funding-type');

var template = _.template("<div class=\"container\">\n</div>\n");
var modalTemplate = _.template("<div class=\"modal fade\" id=\"<%= m.id %>\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\n  <div class=\"modal-dialog <%= m.specialClass %>\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\"><span aria-hidden=\"true\">&times;</span><span data-i18n=\"amp.dashboard:close\" class=\"sr-only\">Close</span></button>\n        <h4 class=\"modal-title text-<%= m.tone %>\" data-i18n=\"<%= m.i18nTitle %>\"><%= m.title %></h4>\n      </div>\n      <div class=\"modal-body\">\n        <% if (m.content) { %>\n          <%= m.content %>\n        <% } %>\n        <% if (m.messages) { %>\n          <% _(m.messages).each(function(message) { %>\n            <p><%= message %></p>\n          <% }) %>\n        <% } %>\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-<%= m.tone %>\" data-i18n=\"amp.dashboard:close\" data-dismiss=\"modal\">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n");

var EnabledChartsCollection = require('../models/enabled-charts-collection');

module.exports = BackboneDash.View.extend({

  initialize: function(options) {
    this.app = options.app;    

    this.header = new Header({ app: this.app });    
    this.app.settings.load();  // maybe should go in render or something
                               // but we already do other fetches on init so...
    this.controls = new Controls({ app: this.app });

    // AMP-19545: We instantiate the collection of enabled charts (from FM) and use it to enable or not each chart.
    var enabledChartsFM = new EnabledChartsCollection();
    enabledChartsFM.fetchData();
    if(enabledChartsFM.models[0].get('error') !== undefined) {
    	// The same endpoint will send an error if 'DASHBOARDS' is not active in the Feature Manager.
    	window.location = '/';
    }
    var col = [];
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Top Donors'})) {
    	col.push(new TopsChart(
  	          { name: 'Top Donor Agencies', big: false, view: 'bar' },
  	          { app: this.app, url: '/rest/dashboard/tops/do' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Top Donor Group'})) {
    	col.push(new TopsChart(
  	          { name: 'Top Donor Groups', big: false, view: 'bar' },
  	          { app: this.app, url: '/rest/dashboard/tops/dg' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Top Regions'})) {
    	col.push(new TopsChart(
  	          { name: 'Top Regions', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/re' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Top Sectors'})) {
    	col.push(new TopsChart(
  	          { name: 'Top Sectors', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ps' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Aid Predictability'})) {
    	col.push(new PredictabilityChart(
  	          { name: 'Aid Predictability' },
	          { app: this.app, url: '/rest/dashboard/aid-predictability' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Funding Type'})) {
    	col.push(new FundingTypeChart(
  	          { name: 'Funding Type' },
	          { app: this.app, url: '/rest/dashboard/ftype' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Responsible Organizations'})) {
    	col.push(new TopsChart(
  	          { name: 'Responsible Organizations', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ro' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Beneficiary Agencies'})) {
    	col.push(new TopsChart(
  	          { name: 'Beneficiary Agencies', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ba' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Executing Agencies'})) {
    	col.push(new TopsChart(
  	          { name: 'Executing Agencies', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ea' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Implementing Agencies'})) {
    	col.push(new TopsChart(
  	          { name: 'Implementing Agencies', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ia' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Peace-building and State-building Goals'})) {
    	col.push(new TopsChart(
    			{ name: 'Peace-building and State-building Goals', big: true, showCategoriesInfo: true, view: 'pie' },
    			{ app: this.app, url: '/rest/dashboard/tops/ndd' }));
    }
       
    var chartsCollection = new Charts(col, { app: this.app });
    this.charts = new ChartsView({
      app: this.app,
      collection: chartsCollection
    });

    this.footer = new Footer({ app: this.app });
  },

  render: function() {
    this.$el.html(template());
    this.$('.container').html([
      this.header.render().el,
      this.controls.render().el,
      this.charts.render().el,
      this.footer.render().el
    ]);
    return this;
  },

  modal: function(title, options) {
    options = _({
      title: title,
      id: _.uniqueId('modal')
    }).extend(options);
    this.$el.parent().append(modalTemplate({m: options}));
    var thisModal = this.$el.parent().find('#' + options.id);
    if (options.bodyEl) { thisModal.find('.modal-body').html(options.bodyEl); }
    thisModal.modal();
    return thisModal[0];  // the actual DOM element
  }

});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","../models/chart-aid-predictability":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-aid-predictability.js","../models/chart-funding-type":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-funding-type.js","../models/chart-tops":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/chart-tops.js","../models/charts-collection":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/charts-collection.js","../models/enabled-charts-collection":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/models/enabled-charts-collection.js","./charts":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/charts.js","./controls":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/controls.js","./footer":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/footer.js","./header":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/header.js","amp-state/index":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-state/index.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/settings-modal.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<div class=\"tab-content filter-options\">\n  <div class=\"tab-pane active\">\n    <ul class=\"sub-filters-titles nav nav-pills nav-stacked\">\n      <% _(settings.getVisible()).each(function(setting) { %>\n        <li <%= setting.id === current.id ? 'class=\"active\"' : '' %>>\n          <a class=\"setting-select\" href=\"#<%= setting.id %>\"><span><%= setting.get('name') %></span></a>\n        </li>\n      <% }) %>\n    </ul>\n    <div class=\"sub-filters-content\">\n      <select class=\"form-control setting-value\">\n        <% _(current.get('options')).each(function(option) { %>\n          <option value=\"<%= option.value %>\" <%= option.selected ? 'selected=\"selected\"' : '' %>><%= option.name %></option>\n        <% }) %>\n      </select>\n    </div>\n  </div>\n</div>\n");


module.exports = BackboneDash.View.extend({

  events: {
    'click .setting-select': 'selectSetting',
    'change .setting-value': 'changeSetting'
  },

  initialize: function(options) {
    this.app = options.app;
  },

  render: function() {
    if (!this.current) { this.current = this.app.settings.getVisible()[0]; }
    this.$el.html(template({
      settings: this.app.settings,
      current: this.current
    }));
    return this;
  },

  selectSetting: function(e) {
    e.preventDefault();  // don't change URL
    var settingId = e.currentTarget.hash.slice(1);  // removes '#'
    this.current = this.app.settings.get(settingId);
    this.render();
  },

  changeSetting: function(e) {
    var optionId = e.currentTarget.value;
    this.current.select(optionId);
  }

});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/settings.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var ModalView = require('./settings-modal');
var template = _.template("<div class=\"col-xs-12 col-sm-6 col-md-3\">\n  <div class=\"panel\">\n    <div class=\"panel-body\">\n      <h3 data-i18n=\"amp.dashboard:dashboard-settings\" class=\"inline-heading\">Settings</h3>\n      <button type=\"button\" class=\"btn btn-sm btn-default pull-right dash-settings-button\">\n        <span class=\"glyphicon glyphicon-edit\"></span>\n        <span data-i18n=\"amp.dashboard:settings-edit\">edit settings</span>\n      </button>\n    </div>\n  </div>\n</div>\n");


module.exports = BackboneDash.View.extend({

  events: {
    'click .dash-settings-button': 'editSettings'
  },

  initialize: function(options) {
    this.app = options.app;
    this.modalView = new ModalView({ app: this.app, collection: this.collection });

    this.app.settings.load().done(_(function() {
      this.app.state.register(this, 'settings', {
        get: this.app.settings.toAPI,
        set: this.app.settings.fromState
      });
    }).bind(this));
  },

  render: function() {
    this.$el.html(template());  
    return this;
  },

  editSettings: function() {
	var specialClass = 'dash-settings-modal';
    this.app.modal('Settings', {
      specialClass: specialClass,
      bodyEl: this.modalView.render().el,
      i18nTitle: 'amp.dashboard:dashboard-settings'
    });
    
    // Translate modal popup.
    app.translator.translateDOM($("." + specialClass));
  }

});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","./settings-modal":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/settings-modal.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/views/share.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<div class=\"col-xs-12 col-sm-6 col-md-4\">\n  <div class=\"panel\">\n    <div class=\"panel-body\">\n      <h3 data-i18n=\"amp.dashboard:share-dashboard-top\" class=\"inline-heading\">Share</h3>\n      <button type=\"button\" class=\"btn btn-sm btn-default pull-right dash-share-button\">\n        <span class=\"glyphicon glyphicon-link\"></span>\n        <span data-i18n=\"amp.dashboard:share-link\">link</span>\n      </button>\n    </div>\n  </div>\n</div>\n\n<div class=\"dash-share-modal modal fade\" id=\"<%= details.id %>\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\n  <div class=\"modal-dialog\">\n    <div class=\"panel panel-primary\">\n      <div class=\"panel-heading fix-title-height\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\"><span aria-hidden=\"true\">&times;</span><span data-i18n=\"amp.dashboard:close\" class=\"sr-only\">Close</span></button>\n        <span data-i18n=\"amp.dashboard:share-dashboard\">Share this dashboard view</span>\n      </div>\n      <div class=\"panel-body\">\n        <form role=\"form\">\n          <label data-i18n=\"amp.dashboard:share-link\" for=\"dash-share-url\">Link</label>\n          <input type=\"url\" class=\"form-control\" id=\"dash-share-url\" />\n        </form>\n      </div>\n      <div class=\"panel-footer\">\n        <button type=\"button\" class=\"btn btn-primary\" data-i18n=\"amp.dashboard:close\" data-dismiss=\"modal\">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n");


module.exports = BackboneDash.View.extend({

  events: {
    'click .dash-share-button': 'share'
  },

  initialize: function(options) {
    this.app = options.app;
  },

  render: function() {
    this.$el.html(template({ details: {} }));
    return this;
  },

  share: function() {
    var saving = app.translator.translateSync("amp.dashboard:saving-state","Saving dashboard state, please wait...");
	  
    this.$('#dash-share-url')
      .attr('disabled', 'disabled')
      .val(saving);

    var stateBlob = this.app.state.freeze();

    this.listenToOnce(this.app.savedDashes, 'request', function(model, xhr) {
      // this has to be set up before .create, so we don't miss it
      xhr
        .done(_(function() {
          var id = model.get('id');
          this.app.url.hash(this.app.state.toHash(id), { silent: true });
          this.$('#dash-share-url')
            .removeAttr('disabled')
            .val(this.app.url.full());
        }).bind(this))
        .fail(_(function() {
          this.$('#dash-share-url').val('Error: could not save dashboard for sharing.');
        }).bind(this));
    });

    this.app.savedDashes.create({  // create does POST
      title: 'Dashboard',
      description: 'Saved dashboard',
      stateBlob: stateBlob
    }, { app: this.app });

    this.$('.dash-share-modal').modal();
  }

});

},{"../backbone-dash":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/app/backbone-dash.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-load-hacks.js":[function(require,module,exports){
// nvd3 goes global sigh... make sure d3 is already global
require('nvd3');

// make stupid nvd3 dev logs go away >:(
window.nv.dev = false;

// load underscore mixins
require('./underscore-transpose');

// load canvg stuff
window.RGBColor = require('./lib-src/rgbcolor');
require('./lib-src/canvg');


module.exports = {
  canvg: window.canvg
};

},{"./lib-src/canvg":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-src/canvg.js","./lib-src/rgbcolor":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-src/rgbcolor.js","./underscore-transpose":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/underscore-transpose.js","nvd3":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/node_modules/nvd3/nv.d3.js"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-src/canvg.js":[function(require,module,exports){
/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed 
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */
(function(){
    // canvg(target, s)
    // empty parameters: replace all 'svg' elements on page with 'canvas' elements
    // target: canvas element or the id of a canvas element
    // s: svg string, url to svg file, or xml document
    // opts: optional hash of options
    //       ignoreMouse: true => ignore mouse events
    //       ignoreAnimation: true => ignore animations
    //       ignoreDimensions: true => does not try to resize canvas
    //       ignoreClear: true => does not clear canvas
    //       offsetX: int => draws at a x offset
    //       offsetY: int => draws at a y offset
    //       scaleWidth: int => scales horizontally to width
    //       scaleHeight: int => scales vertically to height
    //       renderCallback: function => will call the function after the first render is completed
    //       forceRedraw: function => will call the function on every frame, if it returns true, will redraw
    this.canvg = function (target, s, opts) {
        // no parameters
        if (target == null && s == null && opts == null) {
            var svgTags = document.querySelectorAll('svg');
            for (var i=0; i<svgTags.length; i++) {
                var svgTag = svgTags[i];
                var c = document.createElement('canvas');
                c.width = svgTag.clientWidth;
                c.height = svgTag.clientHeight;
                svgTag.parentNode.insertBefore(c, svgTag);
                svgTag.parentNode.removeChild(svgTag);
                var div = document.createElement('div');
                div.appendChild(svgTag);
                canvg(c, div.innerHTML);
            }
            return;
        }
    
        if (typeof target == 'string') {
            target = document.getElementById(target);
        }
        
        // store class on canvas
        if (target.svg != null) target.svg.stop();
        var svg = build(opts || {});
        // on i.e. 8 for flash canvas, we can't assign the property so check for it
        if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;
        
        var ctx = target.getContext('2d');
        if (typeof(s.documentElement) != 'undefined') {
            // load from xml doc
            svg.loadXmlDoc(ctx, s);
        }
        else if (s.substr(0,1) == '<') {
            // load from xml string
            svg.loadXml(ctx, s);
        }
        else {
            // load from url
            svg.load(ctx, s);
        }
    }

    function build(opts) {
        var svg = { opts: opts };
        
        svg.FRAMERATE = 30;
        svg.MAX_VIRTUAL_PIXELS = 30000;
        
        svg.log = function(msg) {};
        if (svg.opts['log'] == true && typeof(console) != 'undefined') {
            svg.log = function(msg) { console.log(msg); };
        };
        
        // globals
        svg.init = function(ctx) {
            var uniqueId = 0;
            svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId; };
            svg.Definitions = {};
            svg.Styles = {};
            svg.Animations = [];
            svg.Images = [];
            svg.ctx = ctx;
            svg.ViewPort = new (function () {
                this.viewPorts = [];
                this.Clear = function() { this.viewPorts = []; }
                this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }
                this.RemoveCurrent = function() { this.viewPorts.pop(); }
                this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }
                this.width = function() { return this.Current().width; }
                this.height = function() { return this.Current().height; }
                this.ComputeSize = function(d) {
                    if (d != null && typeof(d) == 'number') return d;
                    if (d == 'x') return this.width();
                    if (d == 'y') return this.height();
                    return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);            
                }
            });
        }
        svg.init();
        
        // images loaded
        svg.ImagesLoaded = function() { 
            for (var i=0; i<svg.Images.length; i++) {
                if (!svg.Images[i].loaded) return false;
            }
            return true;
        }

        // trim
        svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }
        
        // compress spaces
        svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }
        
        // ajax
        svg.ajax = function(url) {
            var AJAX;
            if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
            else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
            if(AJAX){
               AJAX.open('GET',url,false);
               AJAX.send(null);
               return AJAX.responseText;
            }
            return null;
        } 
        
        // parse xml
        svg.parseXml = function(xml) {
            if (typeof(Windows) != 'undefined' && typeof(Windows.Data) != 'undefined' && typeof(Windows.Data.Xml) != 'undefined') {
                var xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();
                var settings = new Windows.Data.Xml.Dom.XmlLoadSettings();
                settings.prohibitDtd = false;
                xmlDoc.loadXml(xml, settings);
                return xmlDoc;
            }
            else if (window.DOMParser)
            {
                var parser = new DOMParser();
                return parser.parseFromString(xml, 'text/xml');
            }
            else 
            {
                xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
                var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
                xmlDoc.async = 'false';
                xmlDoc.loadXML(xml); 
                return xmlDoc;
            }       
        }
        
        svg.Property = function(name, value) {
            this.name = name;
            this.value = value;
        }   
            svg.Property.prototype.getValue = function() {
                return this.value;
            }
        
            svg.Property.prototype.hasValue = function() {
                return (this.value != null && this.value !== '');
            }
                            
            // return the numerical value of the property
            svg.Property.prototype.numValue = function() {
                if (!this.hasValue()) return 0;
                
                var n = parseFloat(this.value);
                if ((this.value + '').match(/%$/)) {
                    n = n / 100.0;
                }
                return n;
            }
            
            svg.Property.prototype.valueOrDefault = function(def) {
                if (this.hasValue()) return this.value;
                return def;
            }
            
            svg.Property.prototype.numValueOrDefault = function(def) {
                if (this.hasValue()) return this.numValue();
                return def;
            }
            
            // color extensions
                // augment the current color value with the opacity
                svg.Property.prototype.addOpacity = function(opacityProp) {
                    var newValue = this.value;
                    if (opacityProp.value != null && opacityProp.value != '' && typeof(this.value)=='string') { // can only add opacity to colors, not patterns
                        var color = new RGBColor(this.value);
                        if (color.ok) {
                            newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';
                        }
                    }
                    return new svg.Property(this.name, newValue);
                }
            
            // definition extensions
                // get the definition from the definitions table
                svg.Property.prototype.getDefinition = function() {
                    var name = this.value.match(/#([^\)'"]+)/);
                    if (name) { name = name[1]; }
                    if (!name) { name = this.value; }
                    return svg.Definitions[name];
                }
                
                svg.Property.prototype.isUrlDefinition = function() {
                    return this.value.indexOf('url(') == 0
                }
                
                svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
                    var def = this.getDefinition();
                    
                    // gradient
                    if (def != null && def.createGradient) {
                        return def.createGradient(svg.ctx, e, opacityProp);
                    }
                    
                    // pattern
                    if (def != null && def.createPattern) {
                        if (def.getHrefAttribute().hasValue()) {
                            var pt = def.attribute('patternTransform');
                            def = def.getHrefAttribute().getDefinition();
                            if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
                        }
                        return def.createPattern(svg.ctx, e);
                    }
                    
                    return null;
                }
            
            // length extensions
                svg.Property.prototype.getDPI = function(viewPort) {
                    return 96.0; // TODO: compute?
                }
                
                svg.Property.prototype.getEM = function(viewPort) {
                    var em = 12;
                    
                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);
                    
                    return em;
                }
                
                svg.Property.prototype.getUnits = function() {
                    var s = this.value+'';
                    return s.replace(/[0-9\.\-]/g,'');
                }
            
                // get the length as pixels
                svg.Property.prototype.toPixels = function(viewPort, processPercent) {
                    if (!this.hasValue()) return 0;
                    var s = this.value+'';
                    if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
                    if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
                    if (s.match(/px$/)) return this.numValue();
                    if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
                    if (s.match(/pc$/)) return this.numValue() * 15;
                    if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
                    if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
                    if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
                    if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
                    var n = this.numValue();
                    if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
                    return n;
                }

            // time extensions
                // get the time as milliseconds
                svg.Property.prototype.toMilliseconds = function() {
                    if (!this.hasValue()) return 0;
                    var s = this.value+'';
                    if (s.match(/s$/)) return this.numValue() * 1000;
                    if (s.match(/ms$/)) return this.numValue();
                    return this.numValue();
                }
            
            // angle extensions
                // get the angle as radians
                svg.Property.prototype.toRadians = function() {
                    if (!this.hasValue()) return 0;
                    var s = this.value+'';
                    if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
                    if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
                    if (s.match(/rad$/)) return this.numValue();
                    return this.numValue() * (Math.PI / 180.0);
                }
        
            // text extensions
                // get the text baseline
                var textBaselineMapping = {
                    'baseline': 'alphabetic',
                    'before-edge': 'top',
                    'text-before-edge': 'top',
                    'middle': 'middle',
                    'central': 'middle',
                    'after-edge': 'bottom',
                    'text-after-edge': 'bottom',
                    'ideographic': 'ideographic',
                    'alphabetic': 'alphabetic',
                    'hanging': 'hanging',
                    'mathematical': 'alphabetic'
                };
                svg.Property.prototype.toTextBaseline = function () {
                    if (!this.hasValue()) return null;
                    return textBaselineMapping[this.value];
                }
                
        // fonts
        svg.Font = new (function() {
            this.Styles = 'normal|italic|oblique|inherit';
            this.Variants = 'normal|small-caps|inherit';
            this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';
            
            this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
                var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
                return { 
                    fontFamily: fontFamily || f.fontFamily, 
                    fontSize: fontSize || f.fontSize, 
                    fontStyle: fontStyle || f.fontStyle, 
                    fontWeight: fontWeight || f.fontWeight, 
                    fontVariant: fontVariant || f.fontVariant,
                    toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') } 
                } 
            }
            
            var that = this;
            this.Parse = function(s) {
                var f = {};
                var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
                var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
                var ff = '';
                for (var i=0; i<d.length; i++) {
                    if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
                    else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;  }
                    else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
                    else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
                    else { if (d[i] != 'inherit') ff += d[i]; }
                } if (ff != '') f.fontFamily = ff;
                return f;
            }
        });
        
        // points and paths
        svg.ToNumberArray = function(s) {
            var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
            for (var i=0; i<a.length; i++) {
                a[i] = parseFloat(a[i]);
            }
            return a;
        }       
        svg.Point = function(x, y) {
            this.x = x;
            this.y = y;
        }   
            svg.Point.prototype.angleTo = function(p) {
                return Math.atan2(p.y - this.y, p.x - this.x);
            }
            
            svg.Point.prototype.applyTransform = function(v) {
                var xp = this.x * v[0] + this.y * v[2] + v[4];
                var yp = this.x * v[1] + this.y * v[3] + v[5];
                this.x = xp;
                this.y = yp;
            }

        svg.CreatePoint = function(s) {
            var a = svg.ToNumberArray(s);
            return new svg.Point(a[0], a[1]);
        }
        svg.CreatePath = function(s) {
            var a = svg.ToNumberArray(s);
            var path = [];
            for (var i=0; i<a.length; i+=2) {
                path.push(new svg.Point(a[i], a[i+1]));
            }
            return path;
        }
        
        // bounding box
        svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
            this.x1 = Number.NaN;
            this.y1 = Number.NaN;
            this.x2 = Number.NaN;
            this.y2 = Number.NaN;
            
            this.x = function() { return this.x1; }
            this.y = function() { return this.y1; }
            this.width = function() { return this.x2 - this.x1; }
            this.height = function() { return this.y2 - this.y1; }
            
            this.addPoint = function(x, y) {    
                if (x != null) {
                    if (isNaN(this.x1) || isNaN(this.x2)) {
                        this.x1 = x;
                        this.x2 = x;
                    }
                    if (x < this.x1) this.x1 = x;
                    if (x > this.x2) this.x2 = x;
                }
            
                if (y != null) {
                    if (isNaN(this.y1) || isNaN(this.y2)) {
                        this.y1 = y;
                        this.y2 = y;
                    }
                    if (y < this.y1) this.y1 = y;
                    if (y > this.y2) this.y2 = y;
                }
            }           
            this.addX = function(x) { this.addPoint(x, null); }
            this.addY = function(y) { this.addPoint(null, y); }
            
            this.addBoundingBox = function(bb) {
                this.addPoint(bb.x1, bb.y1);
                this.addPoint(bb.x2, bb.y2);
            }
            
            this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
                var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
                var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
                var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
                var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
                this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
            }
            
            this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
                // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
                var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
                this.addPoint(p0[0], p0[1]);
                this.addPoint(p3[0], p3[1]);
                
                for (i=0; i<=1; i++) {
                    var f = function(t) { 
                        return Math.pow(1-t, 3) * p0[i]
                        + 3 * Math.pow(1-t, 2) * t * p1[i]
                        + 3 * (1-t) * Math.pow(t, 2) * p2[i]
                        + Math.pow(t, 3) * p3[i];
                    }
                    
                    var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                    var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                    var c = 3 * p1[i] - 3 * p0[i];
                    
                    if (a == 0) {
                        if (b == 0) continue;
                        var t = -c / b;
                        if (0 < t && t < 1) {
                            if (i == 0) this.addX(f(t));
                            if (i == 1) this.addY(f(t));
                        }
                        continue;
                    }
                    
                    var b2ac = Math.pow(b, 2) - 4 * c * a;
                    if (b2ac < 0) continue;
                    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                        if (i == 0) this.addX(f(t1));
                        if (i == 1) this.addY(f(t1));
                    }
                    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t2 && t2 < 1) {
                        if (i == 0) this.addX(f(t2));
                        if (i == 1) this.addY(f(t2));
                    }
                }
            }
            
            this.isPointInBox = function(x, y) {
                return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
            }
            
            this.addPoint(x1, y1);
            this.addPoint(x2, y2);
        }
        
        // transforms
        svg.Transform = function(v) {   
            var that = this;
            this.Type = {}
        
            // translate
            this.Type.translate = function(s) {
                this.p = svg.CreatePoint(s);            
                this.apply = function(ctx) {
                    ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
                }
                this.unapply = function(ctx) {
                    ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                }
            }
            
            // rotate
            this.Type.rotate = function(s) {
                var a = svg.ToNumberArray(s);
                this.angle = new svg.Property('angle', a[0]);
                this.cx = a[1] || 0;
                this.cy = a[2] || 0;
                this.apply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                }
                this.unapply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(-1.0 * this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                }
                this.applyToPoint = function(p) {
                    var a = this.angle.toRadians();
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                    p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
                    p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
                }           
            }
            
            this.Type.scale = function(s) {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx) {
                    ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
                }
                this.unapply = function(ctx) {
                    ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
                }               
            }
            
            this.Type.matrix = function(s) {
                this.m = svg.ToNumberArray(s);
                this.apply = function(ctx) {
                    ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
                }
                this.unapply = function(ctx) {
                    var a = this.m[0];
                    var b = this.m[2];
                    var c = this.m[4];
                    var d = this.m[1];
                    var e = this.m[3];
                    var f = this.m[5];
                    var g = 0.0;
                    var h = 0.0;
                    var i = 1.0;
                    var det = 1 / (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g));
                    ctx.transform(
                        det*(e*i-f*h),
                        det*(f*g-d*i),
                        det*(c*h-b*i),
                        det*(a*i-c*g),
                        det*(b*f-c*e),
                        det*(c*d-a*f)
                    );
                }
                this.applyToPoint = function(p) {
                    p.applyTransform(this.m);
                }                   
            }
            
            this.Type.SkewBase = function(s) {
                this.base = that.Type.matrix;
                this.base(s);
                this.angle = new svg.Property('angle', s);
            }
            this.Type.SkewBase.prototype = new this.Type.matrix;
            
            this.Type.skewX = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
            }
            this.Type.skewX.prototype = new this.Type.SkewBase;
            
            this.Type.skewY = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
            }
            this.Type.skewY.prototype = new this.Type.SkewBase;
        
            this.transforms = [];
            
            this.apply = function(ctx) {
                for (var i=0; i<this.transforms.length; i++) {
                    this.transforms[i].apply(ctx);
                }
            }
            
            this.unapply = function(ctx) {
                for (var i=this.transforms.length-1; i>=0; i--) {
                    this.transforms[i].unapply(ctx);
                }
            }
            
            this.applyToPoint = function(p) {
                for (var i=0; i<this.transforms.length; i++) {
                    this.transforms[i].applyToPoint(p);
                }
            }
            
            var data = svg.trim(svg.compressSpaces(v)).replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
            for (var i=0; i<data.length; i++) {
                var type = svg.trim(data[i].split('(')[0]);
                var s = data[i].split('(')[1].replace(')','');
                var transform = new this.Type[type](s);
                transform.type = type;
                this.transforms.push(transform);
            }
        }
        
        // aspect ratio
        svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
            // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
            aspectRatio = svg.compressSpaces(aspectRatio);
            aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
            var align = aspectRatio.split(' ')[0] || 'xMidYMid';
            var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';                  
    
            // calculate scale
            var scaleX = width / desiredWidth;
            var scaleY = height / desiredHeight;
            var scaleMin = Math.min(scaleX, scaleY);
            var scaleMax = Math.max(scaleX, scaleY);
            if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
            if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }    
            
            refX = new svg.Property('refX', refX);
            refY = new svg.Property('refY', refY);
            if (refX.hasValue() && refY.hasValue()) {               
                ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
            } 
            else {                  
                // align
                if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0); 
                if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0); 
                if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0); 
                if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight); 
            }
            
            // scale
            if (align == 'none') ctx.scale(scaleX, scaleY);
            else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin); 
            else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);     
            
            // translate
            ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);          
        }
        
        // elements
        svg.Element = {}
        
        svg.EmptyProperty = new svg.Property('EMPTY', '');
        
        svg.Element.ElementBase = function(node) {  
            this.attributes = {};
            this.styles = {};
            this.children = [];
            
            // get or create attribute
            this.attribute = function(name, createIfNotExists) {
                var a = this.attributes[name];
                if (a != null) return a;
                            
                if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
                return a || svg.EmptyProperty;
            }
            
            this.getHrefAttribute = function() {
                for (var a in this.attributes) { 
                    if (a.match(/:href$/)) { 
                        return this.attributes[a]; 
                    } 
                }
                return svg.EmptyProperty;
            }
            
            // get or create style, crawls up node tree
            this.style = function(name, createIfNotExists, skipAncestors) {
                var s = this.styles[name];
                if (s != null) return s;
                
                var a = this.attribute(name);
                if (a != null && a.hasValue()) {
                    this.styles[name] = a; // move up to me to cache
                    return a;
                }
                
                if (skipAncestors != true) {
                    var p = this.parent;
                    if (p != null) {
                        var ps = p.style(name);
                        if (ps != null && ps.hasValue()) {
                            return ps;
                        }
                    }
                }
                    
                if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
                return s || svg.EmptyProperty;
            }
            
            // base render
            this.render = function(ctx) {
                // don't render display=none
                if (this.style('display').value == 'none') return;
                
                // don't render visibility=hidden
                if (this.style('visibility').value == 'hidden') return;
            
                ctx.save();
                if (this.attribute('mask').hasValue()) { // mask
                    var mask = this.attribute('mask').getDefinition();
                    if (mask != null) mask.apply(ctx, this);
                }
                else if (this.style('filter').hasValue()) { // filter
                    var filter = this.style('filter').getDefinition();
                    if (filter != null) filter.apply(ctx, this);
                }
                else {  
                    this.setContext(ctx);
                    this.renderChildren(ctx);   
                    this.clearContext(ctx);                         
                }
                ctx.restore();
            }
            
            // base set context
            this.setContext = function(ctx) {
                // OVERRIDE ME!
            }
            
            // base clear context
            this.clearContext = function(ctx) {
                // OVERRIDE ME!
            }           
            
            // base render children
            this.renderChildren = function(ctx) {
                for (var i=0; i<this.children.length; i++) {
                    this.children[i].render(ctx);
                }
            }
            
            this.addChild = function(childNode, create) {
                var child = childNode;
                if (create) child = svg.CreateElement(childNode);
                child.parent = this;
                if (child.type != 'title') { this.children.push(child); }
            }
                
            if (node != null && node.nodeType == 1) { //ELEMENT_NODE
                // add attributes
                for (var i=0; i<node.attributes.length; i++) {
                    var attribute = node.attributes[i];
                    this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.nodeValue);
                }
                                        
                // add tag styles
                var styles = svg.Styles[node.nodeName];
                if (styles != null) {
                    for (var name in styles) {
                        this.styles[name] = styles[name];
                    }
                }                   
                
                // add class styles
                if (this.attribute('class').hasValue()) {
                    var classes = svg.compressSpaces(this.attribute('class').value).split(' ');
                    for (var j=0; j<classes.length; j++) {
                        styles = svg.Styles['.'+classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name];
                            }
                        }
                        styles = svg.Styles[node.nodeName+'.'+classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name];
                            }
                        }
                    }
                }
                
                // add id styles
                if (this.attribute('id').hasValue()) {
                    var styles = svg.Styles['#' + this.attribute('id').value];
                    if (styles != null) {
                        for (var name in styles) {
                            this.styles[name] = styles[name];
                        }
                    }
                }
                
                // add inline styles
                if (this.attribute('style').hasValue()) {
                    var styles = this.attribute('style').value.split(';');
                    for (var i=0; i<styles.length; i++) {
                        if (svg.trim(styles[i]) != '') {
                            var style = styles[i].split(':');
                            var name = svg.trim(style[0]);
                            var value = svg.trim(style[1]);
                            this.styles[name] = new svg.Property(name, value);
                        }
                    }
                }   

                // add id
                if (this.attribute('id').hasValue()) {
                    if (svg.Definitions[this.attribute('id').value] == null) {
                        svg.Definitions[this.attribute('id').value] = this;
                    }
                }
                
                // add children
                for (var i=0; i<node.childNodes.length; i++) {
                    var childNode = node.childNodes[i];
                    if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
                    if (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {
                        var text = childNode.nodeValue || childNode.text || '';
                        if (svg.trim(svg.compressSpaces(text)) != '') {
                            this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
                        }
                    }
                }
            }
        }
        
        svg.Element.RenderedElementBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.setContext = function(ctx) {
                // fill
                if (this.style('fill').isUrlDefinition()) {
                    var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
                    if (fs != null) ctx.fillStyle = fs;
                }
                else if (this.style('fill').hasValue()) {
                    var fillStyle = this.style('fill');
                    if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
                    ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
                }
                if (this.style('fill-opacity').hasValue()) {
                    var fillStyle = new svg.Property('fill', ctx.fillStyle);
                    fillStyle = fillStyle.addOpacity(this.style('fill-opacity'));
                    ctx.fillStyle = fillStyle.value;
                }
                                    
                // stroke
                if (this.style('stroke').isUrlDefinition()) {
                    var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
                    if (fs != null) ctx.strokeStyle = fs;
                }
                else if (this.style('stroke').hasValue()) {
                    var strokeStyle = this.style('stroke');
                    if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
                    ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
                }
                if (this.style('stroke-opacity').hasValue()) {
                    var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
                    strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));
                    ctx.strokeStyle = strokeStyle.value;
                }
                if (this.style('stroke-width').hasValue()) {
                    var newLineWidth = this.style('stroke-width').toPixels();
                    ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
                }
                if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
                if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
                if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
                if (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {
                    var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
                    if (typeof(ctx.setLineDash) != 'undefined') { ctx.setLineDash(gaps); }
                    else if (typeof(ctx.webkitLineDash) != 'undefined') { ctx.webkitLineDash = gaps; }
                    else if (typeof(ctx.mozDash) != 'undefined' && !(gaps.length==1 && gaps[0]==0)) { ctx.mozDash = gaps; }
                    
                    var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
                    if (typeof(ctx.lineDashOffset) != 'undefined') { ctx.lineDashOffset = offset; }
                    else if (typeof(ctx.webkitLineDashOffset) != 'undefined') { ctx.webkitLineDashOffset = offset; }
                    else if (typeof(ctx.mozDashOffset) != 'undefined') { ctx.mozDashOffset = offset; }
                }

                // font
                if (typeof(ctx.font) != 'undefined') {
                    ctx.font = svg.Font.CreateFont( 
                        this.style('font-style').value, 
                        this.style('font-variant').value, 
                        this.style('font-weight').value, 
                        this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '', 
                        this.style('font-family').value).toString();
                }
                
                // transform
                if (this.attribute('transform').hasValue()) { 
                    var transform = new svg.Transform(this.attribute('transform').value);
                    transform.apply(ctx);
                }
                
                // clip
                if (this.style('clip-path', false, true).hasValue()) {
                    var clip = this.style('clip-path', false, true).getDefinition();
                    if (clip != null) clip.apply(ctx);
                }
                
                // opacity
                if (this.style('opacity').hasValue()) {
                    ctx.globalAlpha = this.style('opacity').numValue();
                }
            }       
        }
        svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;
        
        svg.Element.PathElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                if (ctx != null) ctx.beginPath();
                return new svg.BoundingBox();
            }
            
            this.renderChildren = function(ctx) {
                this.path(ctx);
                svg.Mouse.checkPath(this, ctx);
                if (ctx.fillStyle != '') {
                    if (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') { ctx.fill(this.style('fill-rule').value); }
                    else { ctx.fill(); }
                }
                if (ctx.strokeStyle != '') ctx.stroke();
                
                var markers = this.getMarkers();
                if (markers != null) {
                    if (this.style('marker-start').isUrlDefinition()) {
                        var marker = this.style('marker-start').getDefinition();
                        marker.render(ctx, markers[0][0], markers[0][1]);
                    }
                    if (this.style('marker-mid').isUrlDefinition()) {
                        var marker = this.style('marker-mid').getDefinition();
                        for (var i=1;i<markers.length-1;i++) {
                            marker.render(ctx, markers[i][0], markers[i][1]);
                        }
                    }
                    if (this.style('marker-end').isUrlDefinition()) {
                        var marker = this.style('marker-end').getDefinition();
                        marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
                    }
                }                   
            }
            
            this.getBoundingBox = function() {
                return this.path();
            }
            
            this.getMarkers = function() {
                return null;
            }
        }
        svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;
        
        // svg element
        svg.Element.svg = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseClearContext = this.clearContext;
            this.clearContext = function(ctx) {
                this.baseClearContext(ctx);
                svg.ViewPort.RemoveCurrent();
            }
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                // initial values and defaults
                ctx.strokeStyle = 'rgba(0,0,0,0)';
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'miter';
                ctx.miterLimit = 4; 
                if (typeof(ctx.font) != 'undefined' && typeof(window.getComputedStyle) != 'undefined') {
                    ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');
                }
            
                this.baseSetContext(ctx);
                
                // create new view port
                if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
                if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
                ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));
                
                var width = svg.ViewPort.width();
                var height = svg.ViewPort.height();
                
                if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
                if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
                if (typeof(this.root) == 'undefined') {
                    width = this.attribute('width').toPixels('x');
                    height = this.attribute('height').toPixels('y');
                    
                    var x = 0;
                    var y = 0;
                    if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
                        x = -this.attribute('refX').toPixels('x');
                        y = -this.attribute('refY').toPixels('y');
                    }
                    
                    if (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(width, y);
                        ctx.lineTo(width, height);
                        ctx.lineTo(x, height);
                        ctx.closePath();
                        ctx.clip();
                    }
                }
                svg.ViewPort.SetCurrent(width, height); 
                        
                // viewbox
                if (this.attribute('viewBox').hasValue()) {             
                    var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
                    var minX = viewBox[0];
                    var minY = viewBox[1];
                    width = viewBox[2];
                    height = viewBox[3];
                    
                    svg.AspectRatio(ctx,
                                    this.attribute('preserveAspectRatio').value, 
                                    svg.ViewPort.width(), 
                                    width,
                                    svg.ViewPort.height(),
                                    height,
                                    minX,
                                    minY,
                                    this.attribute('refX').value,
                                    this.attribute('refY').value);
                    
                    svg.ViewPort.RemoveCurrent();
                    svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
                }               
            }
        }
        svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

        // rect element
        svg.Element.rect = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                var rx = this.attribute('rx').toPixels('x');
                var ry = this.attribute('ry').toPixels('y');
                if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
                if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
                rx = Math.min(rx, width / 2.0);
                ry = Math.min(ry, height / 2.0);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(x + rx, y);
                    ctx.lineTo(x + width - rx, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
                    ctx.lineTo(x + width, y + height - ry);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
                    ctx.lineTo(x + rx, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
                    ctx.lineTo(x, y + ry);
                    ctx.quadraticCurveTo(x, y, x + rx, y)
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        }
        svg.Element.rect.prototype = new svg.Element.PathElementBase;
        
        // circle element
        svg.Element.circle = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var cx = this.attribute('cx').toPixels('x');
                var cy = this.attribute('cy').toPixels('y');
                var r = this.attribute('r').toPixels();
            
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2, true); 
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
            }
        }
        svg.Element.circle.prototype = new svg.Element.PathElementBase; 

        // ellipse element
        svg.Element.ellipse = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
                var rx = this.attribute('rx').toPixels('x');
                var ry = this.attribute('ry').toPixels('y');
                var cx = this.attribute('cx').toPixels('x');
                var cy = this.attribute('cy').toPixels('y');
                
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - ry);
                    ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
                    ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
                    ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
                    ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
            }
        }
        svg.Element.ellipse.prototype = new svg.Element.PathElementBase;            
        
        // line element
        svg.Element.line = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.getPoints = function() {
                return [
                    new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
                    new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
            }
                                
            this.path = function(ctx) {
                var points = this.getPoints();
                
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                }
                
                return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
            }
            
            this.getMarkers = function() {
                var points = this.getPoints();  
                var a = points[0].angleTo(points[1]);
                return [[points[0], a], [points[1], a]];
            }
        }
        svg.Element.line.prototype = new svg.Element.PathElementBase;       
                
        // polyline element
        svg.Element.polyline = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.points = svg.CreatePath(this.attribute('points').value);
            this.path = function(ctx) {
                var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                }
                for (var i=1; i<this.points.length; i++) {
                    bb.addPoint(this.points[i].x, this.points[i].y);
                    if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                return bb;
            }
            
            this.getMarkers = function() {
                var markers = [];
                for (var i=0; i<this.points.length - 1; i++) {
                    markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
                }
                markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
                return markers;
            }           
        }
        svg.Element.polyline.prototype = new svg.Element.PathElementBase;               
                
        // polygon element
        svg.Element.polygon = function(node) {
            this.base = svg.Element.polyline;
            this.base(node);
            
            this.basePath = this.path;
            this.path = function(ctx) {
                var bb = this.basePath(ctx);
                if (ctx != null) {
                    ctx.lineTo(this.points[0].x, this.points[0].y);
                    ctx.closePath();
                }
                return bb;
            }
        }
        svg.Element.polygon.prototype = new svg.Element.polyline;

        // path element
        svg.Element.path = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
                    
            var d = this.attribute('d').value;
            // TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
            d = d.replace(/,/gm,' '); // get rid of all commas
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // separate commands from points
            d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from points
            d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits when no comma
            d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when no comma
            d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
            d = svg.compressSpaces(d); // compress multiple spaces
            d = svg.trim(d);
            this.PathParser = new (function(d) {
                this.tokens = d.split(' ');
                
                this.reset = function() {
                    this.i = -1;
                    this.command = '';
                    this.previousCommand = '';
                    this.start = new svg.Point(0, 0);
                    this.control = new svg.Point(0, 0);
                    this.current = new svg.Point(0, 0);
                    this.points = [];
                    this.angles = [];
                }
                                
                this.isEnd = function() {
                    return this.i >= this.tokens.length - 1;
                }
                
                this.isCommandOrEnd = function() {
                    if (this.isEnd()) return true;
                    return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
                }
                
                this.isRelativeCommand = function() {
                    switch(this.command)
                    {
                        case 'm':
                        case 'l':
                        case 'h':
                        case 'v':
                        case 'c':
                        case 's':
                        case 'q':
                        case 't':
                        case 'a':
                        case 'z':
                            return true;
                            break;
                    }
                    return false;
                }
                            
                this.getToken = function() {
                    this.i++;
                    return this.tokens[this.i];
                }
                
                this.getScalar = function() {
                    return parseFloat(this.getToken());
                }
                
                this.nextCommand = function() {
                    this.previousCommand = this.command;
                    this.command = this.getToken();
                }               
                
                this.getPoint = function() {
                    var p = new svg.Point(this.getScalar(), this.getScalar());
                    return this.makeAbsolute(p);
                }
                
                this.getAsControlPoint = function() {
                    var p = this.getPoint();
                    this.control = p;
                    return p;
                }
                
                this.getAsCurrentPoint = function() {
                    var p = this.getPoint();
                    this.current = p;
                    return p;   
                }
                
                this.getReflectedControlPoint = function() {
                    if (this.previousCommand.toLowerCase() != 'c' && 
                        this.previousCommand.toLowerCase() != 's' &&
                        this.previousCommand.toLowerCase() != 'q' && 
                        this.previousCommand.toLowerCase() != 't' ){
                        return this.current;
                    }
                    
                    // reflect point
                    var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);                    
                    return p;
                }
                
                this.makeAbsolute = function(p) {
                    if (this.isRelativeCommand()) {
                        p.x += this.current.x;
                        p.y += this.current.y;
                    }
                    return p;
                }
                
                this.addMarker = function(p, from, priorTo) {
                    // if the last angle isn't filled in because we didn't have this point yet ...
                    if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
                        this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
                    }
                    this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
                }
                
                this.addMarkerAngle = function(p, a) {
                    this.points.push(p);
                    this.angles.push(a);
                }               
                
                this.getMarkerPoints = function() { return this.points; }
                this.getMarkerAngles = function() {
                    for (var i=0; i<this.angles.length; i++) {
                        if (this.angles[i] == null) {
                            for (var j=i+1; j<this.angles.length; j++) {
                                if (this.angles[j] != null) {
                                    this.angles[i] = this.angles[j];
                                    break;
                                }
                            }
                        }
                    }
                    return this.angles;
                }
            })(d);

            this.path = function(ctx) {
                var pp = this.PathParser;
                pp.reset();

                var bb = new svg.BoundingBox();
                if (ctx != null) ctx.beginPath();
                while (!pp.isEnd()) {
                    pp.nextCommand();
                    switch (pp.command) {
                    case 'M':
                    case 'm':
                        var p = pp.getAsCurrentPoint();
                        pp.addMarker(p);
                        bb.addPoint(p.x, p.y);
                        if (ctx != null) ctx.moveTo(p.x, p.y);
                        pp.start = pp.current;
                        while (!pp.isCommandOrEnd()) {
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p, pp.start);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null) ctx.lineTo(p.x, p.y);
                        }
                        break;
                    case 'L':
                    case 'l':
                        while (!pp.isCommandOrEnd()) {
                            var c = pp.current;
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p, c);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null) ctx.lineTo(p.x, p.y);
                        }
                        break;
                    case 'H':
                    case 'h':
                        while (!pp.isCommandOrEnd()) {
                            var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
                            pp.addMarker(newP, pp.current);
                            pp.current = newP;
                            bb.addPoint(pp.current.x, pp.current.y);
                            if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                        }
                        break;
                    case 'V':
                    case 'v':
                        while (!pp.isCommandOrEnd()) {
                            var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
                            pp.addMarker(newP, pp.current);
                            pp.current = newP;
                            bb.addPoint(pp.current.x, pp.current.y);
                            if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                        }
                        break;
                    case 'C':
                    case 'c':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var p1 = pp.getPoint();
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, p1);
                            bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'S':
                    case 's':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var p1 = pp.getReflectedControlPoint();
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, p1);
                            bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'Q':
                    case 'q':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, cntrl);
                            bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'T':
                    case 't':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var cntrl = pp.getReflectedControlPoint();
                            pp.control = cntrl;
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, cntrl);
                            bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'A':
                    case 'a':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var rx = pp.getScalar();
                            var ry = pp.getScalar();
                            var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
                            var largeArcFlag = pp.getScalar();
                            var sweepFlag = pp.getScalar();
                            var cp = pp.getAsCurrentPoint();

                            // Conversion from endpoint to center parameterization
                            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                            // x1', y1'
                            var currp = new svg.Point(
                                Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
                                -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
                            );
                            // adjust radii
                            var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
                            if (l > 1) {
                                rx *= Math.sqrt(l);
                                ry *= Math.sqrt(l);
                            }
                            // cx', cy'
                            var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
                                ((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
                                (Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
                            );
                            if (isNaN(s)) s = 0;
                            var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
                            // cx, cy
                            var centp = new svg.Point(
                                (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
                                (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
                            );
                            // vector magnitude
                            var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
                            // ratio between two vectors
                            var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
                            // angle between two vectors
                            var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
                            // initial angle
                            var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
                            // angle delta
                            var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
                            var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
                            var ad = a(u, v);
                            if (r(u,v) <= -1) ad = Math.PI;
                            if (r(u,v) >= 1) ad = 0;

                            // for markers
                            var dir = 1 - sweepFlag ? 1.0 : -1.0;
                            var ah = a1 + dir * (ad / 2.0);
                            var halfWay = new svg.Point(
                                centp.x + rx * Math.cos(ah),
                                centp.y + ry * Math.sin(ah)
                            );
                            pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
                            pp.addMarkerAngle(cp, ah - dir * Math.PI);

                            bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
                            if (ctx != null) {
                                var r = rx > ry ? rx : ry;
                                var sx = rx > ry ? 1 : rx / ry;
                                var sy = rx > ry ? ry / rx : 1;

                                ctx.translate(centp.x, centp.y);
                                ctx.rotate(xAxisRotation);
                                ctx.scale(sx, sy);
                                ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                                ctx.scale(1/sx, 1/sy);
                                ctx.rotate(-xAxisRotation);
                                ctx.translate(-centp.x, -centp.y);
                            }
                        }
                        break;
                    case 'Z':
                    case 'z':
                        if (ctx != null) ctx.closePath();
                        pp.current = pp.start;
                    }
                }

                return bb;
            }

            this.getMarkers = function() {
                var points = this.PathParser.getMarkerPoints();
                var angles = this.PathParser.getMarkerAngles();
                
                var markers = [];
                for (var i=0; i<points.length; i++) {
                    markers.push([points[i], angles[i]]);
                }
                return markers;
            }
        }
        svg.Element.path.prototype = new svg.Element.PathElementBase;
        
        // pattern element
        svg.Element.pattern = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.createPattern = function(ctx, element) {
                var width = this.attribute('width').toPixels('x', true);
                var height = this.attribute('height').toPixels('y', true);
            
                // render me using a temporary svg element
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
                tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
                tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
                tempSvg.children = this.children;
                
                var c = document.createElement('canvas');
                c.width = width;
                c.height = height;
                var cctx = c.getContext('2d');
                if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
                    cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
                }
                // render 3x3 grid so when we transform there's no white space on edges
                for (var x=-1; x<=1; x++) {
                    for (var y=-1; y<=1; y++) {
                        cctx.save();
                        cctx.translate(x * c.width, y * c.height);
                        tempSvg.render(cctx);
                        cctx.restore();
                    }
                }
                var pattern = ctx.createPattern(c, 'repeat');
                return pattern;
            }
        }
        svg.Element.pattern.prototype = new svg.Element.ElementBase;
        
        // marker element
        svg.Element.marker = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.baseRender = this.render;
            this.render = function(ctx, point, angle) {
                ctx.translate(point.x, point.y);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
                ctx.save();
                            
                // render me using a temporary svg element
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
                tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
                tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
                tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
                tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
                tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
                tempSvg.children = this.children;
                tempSvg.render(ctx);
                
                ctx.restore();
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
                ctx.translate(-point.x, -point.y);
            }
        }
        svg.Element.marker.prototype = new svg.Element.ElementBase;
        
        // definitions element
        svg.Element.defs = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);    
            
            this.render = function(ctx) {
                // NOOP
            }
        }
        svg.Element.defs.prototype = new svg.Element.ElementBase;
        
        // base for gradients
        svg.Element.GradientBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.gradientUnits = this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
            
            this.stops = [];            
            for (var i=0; i<this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'stop') this.stops.push(child);
            }   
            
            this.getGradient = function() {
                // OVERRIDE ME!
            }           

            this.createGradient = function(ctx, element, parentOpacityProp) {
                var stopsContainer = this;
                if (this.getHrefAttribute().hasValue()) {
                    stopsContainer = this.getHrefAttribute().getDefinition();
                }
                
                var addParentOpacity = function (color) {
                    if (parentOpacityProp.hasValue()) {
                        var p = new svg.Property('color', color);
                        return p.addOpacity(parentOpacityProp).value;
                    }
                    return color;
                };
            
                var g = this.getGradient(ctx, element);
                if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
                for (var i=0; i<stopsContainer.stops.length; i++) {
                    g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
                }
                
                if (this.attribute('gradientTransform').hasValue()) {
                    // render as transformed pattern on temporary canvas
                    var rootView = svg.ViewPort.viewPorts[0];
                    
                    var rect = new svg.Element.rect();
                    rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
                    rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
                    rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
                    rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);
                    
                    var group = new svg.Element.g();
                    group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
                    group.children = [ rect ];
                    
                    var tempSvg = new svg.Element.svg();
                    tempSvg.attributes['x'] = new svg.Property('x', 0);
                    tempSvg.attributes['y'] = new svg.Property('y', 0);
                    tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
                    tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
                    tempSvg.children = [ group ];
                    
                    var c = document.createElement('canvas');
                    c.width = rootView.width;
                    c.height = rootView.height;
                    var tempCtx = c.getContext('2d');
                    tempCtx.fillStyle = g;
                    tempSvg.render(tempCtx);        
                    return tempCtx.createPattern(c, 'no-repeat');
                }
                
                return g;               
            }
        }
        svg.Element.GradientBase.prototype = new svg.Element.ElementBase;
        
        // linear gradient element
        svg.Element.linearGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            
            this.getGradient = function(ctx, element) {
                var bb = this.gradientUnits == 'objectBoundingBox' ? element.getBoundingBox() : null;
                
                if (!this.attribute('x1').hasValue()
                 && !this.attribute('y1').hasValue()
                 && !this.attribute('x2').hasValue()
                 && !this.attribute('y2').hasValue()) {
                    this.attribute('x1', true).value = 0;
                    this.attribute('y1', true).value = 0;
                    this.attribute('x2', true).value = 1;
                    this.attribute('y2', true).value = 0;
                 }
                
                var x1 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('x1').numValue() 
                    : this.attribute('x1').toPixels('x'));
                var y1 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('y1').numValue()
                    : this.attribute('y1').toPixels('y'));
                var x2 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('x2').numValue()
                    : this.attribute('x2').toPixels('x'));
                var y2 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('y2').numValue()
                    : this.attribute('y2').toPixels('y'));

                if (x1 == x2 && y1 == y2) return null;
                return ctx.createLinearGradient(x1, y1, x2, y2);
            }
        }
        svg.Element.linearGradient.prototype = new svg.Element.GradientBase;
        
        // radial gradient element
        svg.Element.radialGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            
            this.getGradient = function(ctx, element) {
                var bb = element.getBoundingBox();
                
                if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
                if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
                if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';
                
                var cx = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('cx').numValue() 
                    : this.attribute('cx').toPixels('x'));
                var cy = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('cy').numValue() 
                    : this.attribute('cy').toPixels('y'));
                
                var fx = cx;
                var fy = cy;
                if (this.attribute('fx').hasValue()) {
                    fx = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('fx').numValue() 
                    : this.attribute('fx').toPixels('x'));
                }
                if (this.attribute('fy').hasValue()) {
                    fy = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('fy').numValue() 
                    : this.attribute('fy').toPixels('y'));
                }
                
                var r = (this.gradientUnits == 'objectBoundingBox' 
                    ? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
                    : this.attribute('r').toPixels());
                
                return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
            }
        }
        svg.Element.radialGradient.prototype = new svg.Element.GradientBase;
        
        // gradient stop element
        svg.Element.stop = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.offset = this.attribute('offset').numValue();
            if (this.offset < 0) this.offset = 0;
            if (this.offset > 1) this.offset = 1;
            
            var stopColor = this.style('stop-color');
            if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));
            this.color = stopColor.value;
        }
        svg.Element.stop.prototype = new svg.Element.ElementBase;
        
        // animation base element
        svg.Element.AnimateBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            svg.Animations.push(this);
            
            this.duration = 0.0;
            this.begin = this.attribute('begin').toMilliseconds();
            this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();
            
            this.getProperty = function() {
                var attributeType = this.attribute('attributeType').value;
                var attributeName = this.attribute('attributeName').value;
                
                if (attributeType == 'CSS') {
                    return this.parent.style(attributeName, true);
                }
                return this.parent.attribute(attributeName, true);          
            };
            
            this.initialValue = null;
            this.initialUnits = '';
            this.removed = false;       

            this.calcValue = function() {
                // OVERRIDE ME!
                return '';
            }
                    
            this.update = function(delta) { 
                // set initial value
                if (this.initialValue == null) {
                    this.initialValue = this.getProperty().value;
                    this.initialUnits = this.getProperty().getUnits();
                }
            
                // if we're past the end time
                if (this.duration > this.maxDuration) {
                    // loop for indefinitely repeating animations
                    if (this.attribute('repeatCount').value == 'indefinite'
                     || this.attribute('repeatDur').value == 'indefinite') {
                        this.duration = 0.0
                    }
                    else if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {
                        this.frozen = true;
                        this.parent.animationFrozen = true;
                        this.parent.animationFrozenValue = this.getProperty().value;
                    }
                    else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
                        this.removed = true;
                        this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;
                        return true;
                    }
                    return false;
                }           
                this.duration = this.duration + delta;
            
                // if we're past the begin time
                var updated = false;
                if (this.begin < this.duration) {
                    var newValue = this.calcValue(); // tween
                    
                    if (this.attribute('type').hasValue()) {
                        // for transform, etc.
                        var type = this.attribute('type').value;
                        newValue = type + '(' + newValue + ')';
                    }
                    
                    this.getProperty().value = newValue;
                    updated = true;
                }
                
                return updated;
            }
            
            this.from = this.attribute('from');
            this.to = this.attribute('to');
            this.values = this.attribute('values');
            if (this.values.hasValue()) this.values.value = this.values.value.split(';');
            
            // fraction of duration we've covered
            this.progress = function() {
                var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
                if (this.values.hasValue()) {
                    var p = ret.progress * (this.values.value.length - 1);
                    var lb = Math.floor(p), ub = Math.ceil(p);
                    ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
                    ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
                    ret.progress = (p - lb) / (ub - lb);
                }
                else {
                    ret.from = this.from;
                    ret.to = this.to;
                }
                return ret;
            }           
        }
        svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;
        
        // animate element
        svg.Element.animate = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            
            this.calcValue = function() {
                var p = this.progress();
                
                // tween value linearly
                var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress; 
                return newValue + this.initialUnits;
            };
        }
        svg.Element.animate.prototype = new svg.Element.AnimateBase;
            
        // animate color element
        svg.Element.animateColor = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);

            this.calcValue = function() {
                var p = this.progress();
                var from = new RGBColor(p.from.value);
                var to = new RGBColor(p.to.value);
                
                if (from.ok && to.ok) {
                    // tween color linearly
                    var r = from.r + (to.r - from.r) * p.progress;
                    var g = from.g + (to.g - from.g) * p.progress;
                    var b = from.b + (to.b - from.b) * p.progress;
                    return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
                }
                return this.attribute('from').value;
            };
        }
        svg.Element.animateColor.prototype = new svg.Element.AnimateBase;
        
        // animate transform element
        svg.Element.animateTransform = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            
            this.calcValue = function() {
                var p = this.progress();
                
                // tween value linearly
                var from = svg.ToNumberArray(p.from.value);
                var to = svg.ToNumberArray(p.to.value);
                var newValue = '';
                for (var i=0; i<from.length; i++) {
                    newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
                }
                return newValue;
            };
        }
        svg.Element.animateTransform.prototype = new svg.Element.animate;
        
        // font element
        svg.Element.font = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.horizAdvX = this.attribute('horiz-adv-x').numValue();          
            
            this.isRTL = false;
            this.isArabic = false;
            this.fontFace = null;
            this.missingGlyph = null;
            this.glyphs = [];           
            for (var i=0; i<this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'font-face') {
                    this.fontFace = child;
                    if (child.style('font-family').hasValue()) {
                        svg.Definitions[child.style('font-family').value] = this;
                    }
                }
                else if (child.type == 'missing-glyph') this.missingGlyph = child;
                else if (child.type == 'glyph') {
                    if (child.arabicForm != '') {
                        this.isRTL = true;
                        this.isArabic = true;
                        if (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];
                        this.glyphs[child.unicode][child.arabicForm] = child;
                    }
                    else {
                        this.glyphs[child.unicode] = child;
                    }
                }
            }   
        }
        svg.Element.font.prototype = new svg.Element.ElementBase;
        
        // font-face element
        svg.Element.fontface = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);    
            
            this.ascent = this.attribute('ascent').value;
            this.descent = this.attribute('descent').value;
            this.unitsPerEm = this.attribute('units-per-em').numValue();                
        }
        svg.Element.fontface.prototype = new svg.Element.ElementBase;
        
        // missing-glyph element
        svg.Element.missingglyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);    
            
            this.horizAdvX = 0;
        }
        svg.Element.missingglyph.prototype = new svg.Element.path;
        
        // glyph element
        svg.Element.glyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);    
            
            this.horizAdvX = this.attribute('horiz-adv-x').numValue();
            this.unicode = this.attribute('unicode').value;
            this.arabicForm = this.attribute('arabic-form').value;
        }
        svg.Element.glyph.prototype = new svg.Element.path;
        
        // text element
        svg.Element.text = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                
                var textBaseline = this.style('dominant-baseline').toTextBaseline();
                if (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();
                if (textBaseline != null) ctx.textBaseline = textBaseline;
            }
            
            this.getBoundingBox = function () {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);
            }
            
            this.renderChildren = function(ctx) {
                this.x = this.attribute('x').toPixels('x');
                this.y = this.attribute('y').toPixels('y');
                this.x += this.getAnchorDelta(ctx, this, 0);
                for (var i=0; i<this.children.length; i++) {
                    this.renderChild(ctx, this, i);
                }
            }
            
            this.getAnchorDelta = function (ctx, parent, startI) {
                var textAnchor = this.style('text-anchor').valueOrDefault('start');
                if (textAnchor != 'start') {
                    var width = 0;
                    for (var i=startI; i<parent.children.length; i++) {
                        var child = parent.children[i];
                        if (i > startI && child.attribute('x').hasValue()) break; // new group
                        width += child.measureTextRecursive(ctx);
                    }
                    return -1 * (textAnchor == 'end' ? width : width / 2.0);
                }
                return 0;
            }
            
            this.renderChild = function(ctx, parent, i) {
                var child = parent.children[i];
                if (child.attribute('x').hasValue()) {
                    child.x = child.attribute('x').toPixels('x') + this.getAnchorDelta(ctx, parent, i);
                    if (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');
                }
                else {
                    if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
                    if (child.attribute('dx').hasValue()) this.x += child.attribute('dx').toPixels('x');
                    child.x = this.x;
                }
                this.x = child.x + child.measureText(ctx);
                
                if (child.attribute('y').hasValue()) {
                    child.y = child.attribute('y').toPixels('y');
                    if (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');
                }
                else {
                    if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
                    if (child.attribute('dy').hasValue()) this.y += child.attribute('dy').toPixels('y');
                    child.y = this.y;
                }
                this.y = child.y;
                
                child.render(ctx);
                
                for (var i=0; i<child.children.length; i++) {
                    this.renderChild(ctx, child, i);
                }
            }
        }
        svg.Element.text.prototype = new svg.Element.RenderedElementBase;
        
        // text base
        svg.Element.TextElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.getGlyph = function(font, text, i) {
                var c = text[i];
                var glyph = null;
                if (font.isArabic) {
                    var arabicForm = 'isolated';
                    if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal'; 
                    if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
                    if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
                    if (typeof(font.glyphs[c]) != 'undefined') {
                        glyph = font.glyphs[c][arabicForm];
                        if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
                    }
                }
                else {
                    glyph = font.glyphs[c];
                }
                if (glyph == null) glyph = font.missingGlyph;
                return glyph;
            }
            
            this.renderChildren = function(ctx) {
                var customFont = this.parent.style('font-family').getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
                    var text = this.getText();
                    if (customFont.isRTL) text = text.split("").reverse().join("");
                    
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i=0; i<text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        var scale = fontSize / customFont.fontFace.unitsPerEm;
                        ctx.translate(this.x, this.y);
                        ctx.scale(scale, -scale);
                        var lw = ctx.lineWidth;
                        ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
                        if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
                        glyph.render(ctx);
                        if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
                        ctx.lineWidth = lw;
                        ctx.scale(1/scale, -1/scale);
                        ctx.translate(-this.x, -this.y);    
                        
                        this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            this.x += dx[i];
                        }
                    }
                    return;
                }
            
                if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
                if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
            }
            
            this.getText = function() {
                // OVERRIDE ME
            }
            
            this.measureTextRecursive = function(ctx) {
                var width = this.measureText(ctx);
                for (var i=0; i<this.children.length; i++) {
                    width += this.children[i].measureTextRecursive(ctx);
                }
                return width;
            }
            
            this.measureText = function(ctx) {
                var customFont = this.parent.style('font-family').getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var measure = 0;
                    var text = this.getText();
                    if (customFont.isRTL) text = text.split("").reverse().join("");
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i=0; i<text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            measure += dx[i];
                        }
                    }
                    return measure;
                }
            
                var textToMeasure = svg.compressSpaces(this.getText());
                if (!ctx.measureText) return textToMeasure.length * 10;
                
                ctx.save();
                this.setContext(ctx);
                var width = ctx.measureText(textToMeasure).width;
                ctx.restore();
                return width;
            }
        }
        svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;
        
        // tspan 
        svg.Element.tspan = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.TextElementBase;
            this.base(node);
            
            this.text = node.nodeValue || node.text || '';
            this.getText = function() {
                return this.text;
            }
        }
        svg.Element.tspan.prototype = new svg.Element.TextElementBase;
        
        // tref
        svg.Element.tref = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            
            this.getText = function() {
                var element = this.getHrefAttribute().getDefinition();
                if (element != null) return element.children[0].getText();
            }
        }
        svg.Element.tref.prototype = new svg.Element.TextElementBase;       
        
        // a element
        svg.Element.a = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            
            this.hasText = true;
            for (var i=0; i<node.childNodes.length; i++) {
                if (node.childNodes[i].nodeType != 3) this.hasText = false;
            }
            
            // this might contain text
            this.text = this.hasText ? node.childNodes[0].nodeValue : '';
            this.getText = function() {
                return this.text;
            }       

            this.baseRenderChildren = this.renderChildren;
            this.renderChildren = function(ctx) {
                if (this.hasText) {
                    // render as text element
                    this.baseRenderChildren(ctx);
                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));                 
                }
                else {
                    // render as temporary group
                    var g = new svg.Element.g();
                    g.children = this.children;
                    g.parent = this;
                    g.render(ctx);
                }
            }
            
            this.onclick = function() {
                window.open(this.getHrefAttribute().value);
            }
            
            this.onmousemove = function() {
                svg.ctx.canvas.style.cursor = 'pointer';
            }
        }
        svg.Element.a.prototype = new svg.Element.TextElementBase;      
        
        // image element
        svg.Element.image = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            var href = this.getHrefAttribute().value;
            if (href == '') { return; }
            var isSvg = href.match(/\.svg$/)
            
            svg.Images.push(this);
            this.loaded = false;
            if (!isSvg) {
                this.img = document.createElement('img');
                if (svg.opts['useCORS'] == true) { this.img.crossOrigin = 'Anonymous'; }
                var self = this;
                this.img.onload = function() { self.loaded = true; }
                this.img.onerror = function() { svg.log('ERROR: image "' + href + '" not found'); self.loaded = true; }
                this.img.src = href;
            }
            else {
                this.img = svg.ajax(href);
                this.loaded = true;
            }
            
            this.renderChildren = function(ctx) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');            
                if (width == 0 || height == 0) return;
            
                ctx.save();
                if (isSvg) {
                    ctx.drawSvg(this.img, x, y, width, height);
                }
                else {
                    ctx.translate(x, y);
                    svg.AspectRatio(ctx,
                                    this.attribute('preserveAspectRatio').value,
                                    width,
                                    this.img.width,
                                    height,
                                    this.img.height,
                                    0,
                                    0); 
                    ctx.drawImage(this.img, 0, 0);      
                }
                ctx.restore();
            }
            
            this.getBoundingBox = function() {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        }
        svg.Element.image.prototype = new svg.Element.RenderedElementBase;
        
        // group element
        svg.Element.g = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.getBoundingBox = function() {
                var bb = new svg.BoundingBox();
                for (var i=0; i<this.children.length; i++) {
                    bb.addBoundingBox(this.children[i].getBoundingBox());
                }
                return bb;
            };
        }
        svg.Element.g.prototype = new svg.Element.RenderedElementBase;

        // symbol element
        svg.Element.symbol = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.render = function(ctx) {
                // NO RENDER
            };
        }
        svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;     
            
        // style element
        svg.Element.style = function(node) { 
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            // text, or spaces then CDATA
            var css = ''
            for (var i=0; i<node.childNodes.length; i++) {
              css += node.childNodes[i].nodeValue;
            }
            css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
            css = svg.compressSpaces(css); // replace whitespace
            var cssDefs = css.split('}');
            for (var i=0; i<cssDefs.length; i++) {
                if (svg.trim(cssDefs[i]) != '') {
                    var cssDef = cssDefs[i].split('{');
                    var cssClasses = cssDef[0].split(',');
                    var cssProps = cssDef[1].split(';');
                    for (var j=0; j<cssClasses.length; j++) {
                        var cssClass = svg.trim(cssClasses[j]);
                        if (cssClass != '') {
                            var props = {};
                            for (var k=0; k<cssProps.length; k++) {
                                var prop = cssProps[k].indexOf(':');
                                var name = cssProps[k].substr(0, prop);
                                var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
                                if (name != null && value != null) {
                                    props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
                                }
                            }
                            svg.Styles[cssClass] = props;
                            if (cssClass == '@font-face') {
                                var fontFamily = props['font-family'].value.replace(/"/g,'');
                                var srcs = props['src'].value.split(',');
                                for (var s=0; s<srcs.length; s++) {
                                    if (srcs[s].indexOf('format("svg")') > 0) {
                                        var urlStart = srcs[s].indexOf('url');
                                        var urlEnd = srcs[s].indexOf(')', urlStart);
                                        var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
                                        var doc = svg.parseXml(svg.ajax(url));
                                        var fonts = doc.getElementsByTagName('font');
                                        for (var f=0; f<fonts.length; f++) {
                                            var font = svg.CreateElement(fonts[f]);
                                            svg.Definitions[fontFamily] = font;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        svg.Element.style.prototype = new svg.Element.ElementBase;
        
        // use element 
        svg.Element.use = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
                if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
            }
            
            var element = this.getHrefAttribute().getDefinition();
            
            this.path = function(ctx) {
                if (element != null) element.path(ctx);
            }
            
            this.getBoundingBox = function() {
                if (element != null) return element.getBoundingBox();
            }
            
            this.renderChildren = function(ctx) {
                if (element != null) {
                    var tempSvg = element;
                    if (element.type == 'symbol') {
                        // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
                        tempSvg = new svg.Element.svg();
                        tempSvg.type = 'svg';
                        tempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);
                        tempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);
                        tempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);
                        tempSvg.children = element.children;
                    }
                    if (tempSvg.type == 'svg') {
                        // if symbol or svg, inherit width/height from me
                        if (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
                        if (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
                    }
                    var oldParent = tempSvg.parent;
                    tempSvg.parent = null;
                    tempSvg.render(ctx);
                    tempSvg.parent = oldParent;
                }
            }
        }
        svg.Element.use.prototype = new svg.Element.RenderedElementBase;
        
        // mask element
        svg.Element.mask = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
                        
            this.apply = function(ctx, element) {
                // render as temp svg   
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                
                if (width == 0 && height == 0) {
                    var bb = new svg.BoundingBox();
                    for (var i=0; i<this.children.length; i++) {
                        bb.addBoundingBox(this.children[i].getBoundingBox());
                    }
                    var x = Math.floor(bb.x1);
                    var y = Math.floor(bb.y1);
                    var width = Math.floor(bb.width());
                    var height = Math.floor(bb.height());
                }
                
                // temporarily remove mask to avoid recursion
                var mask = element.attribute('mask').value;
                element.attribute('mask').value = '';
                
                    var cMask = document.createElement('canvas');
                    cMask.width = x + width;
                    cMask.height = y + height;
                    var maskCtx = cMask.getContext('2d');
                    this.renderChildren(maskCtx);
                
                    var c = document.createElement('canvas');
                    c.width = x + width;
                    c.height = y + height;
                    var tempCtx = c.getContext('2d');
                    element.render(tempCtx);
                    tempCtx.globalCompositeOperation = 'destination-in';
                    tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
                    tempCtx.fillRect(0, 0, x + width, y + height);
                    
                    ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
                    ctx.fillRect(0, 0, x + width, y + height);
                    
                // reassign mask
                element.attribute('mask').value = mask; 
            }
            
            this.render = function(ctx) {
                // NO RENDER
            }
        }
        svg.Element.mask.prototype = new svg.Element.ElementBase;
        
        // clip element
        svg.Element.clipPath = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx) {
                var oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;
                CanvasRenderingContext2D.prototype.beginPath = function () { };
                
                var oldClosePath = CanvasRenderingContext2D.prototype.closePath;
                CanvasRenderingContext2D.prototype.closePath = function () { };
            
                oldBeginPath.call(ctx);
                for (var i=0; i<this.children.length; i++) {
                    var child = this.children[i];
                    if (typeof(child.path) != 'undefined') {
                        var transform = null;
                        if (child.attribute('transform').hasValue()) { 
                            transform = new svg.Transform(child.attribute('transform').value);
                            transform.apply(ctx);
                        }
                        child.path(ctx);
                        CanvasRenderingContext2D.prototype.closePath = oldClosePath;
                        if (transform) { transform.unapply(ctx); }
                    }
                }
                oldClosePath.call(ctx);
                ctx.clip();
                
                CanvasRenderingContext2D.prototype.beginPath = oldBeginPath;
                CanvasRenderingContext2D.prototype.closePath = oldClosePath;
            }
            
            this.render = function(ctx) {
                // NO RENDER
            }
        }
        svg.Element.clipPath.prototype = new svg.Element.ElementBase;

        // filters
        svg.Element.filter = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
                        
            this.apply = function(ctx, element) {
                // render as temp svg   
                var bb = element.getBoundingBox();
                var x = Math.floor(bb.x1);
                var y = Math.floor(bb.y1);
                var width = Math.floor(bb.width());
                var height = Math.floor(bb.height());

                // temporarily remove filter to avoid recursion
                var filter = element.style('filter').value;
                element.style('filter').value = '';
                
                var px = 0, py = 0;
                for (var i=0; i<this.children.length; i++) {
                    var efd = this.children[i].extraFilterDistance || 0;
                    px = Math.max(px, efd);
                    py = Math.max(py, efd);
                }
                
                var c = document.createElement('canvas');
                c.width = width + 2*px;
                c.height = height + 2*py;
                var tempCtx = c.getContext('2d');
                tempCtx.translate(-x + px, -y + py);
                element.render(tempCtx);
            
                // apply filters
                for (var i=0; i<this.children.length; i++) {
                    this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
                }
                
                // render on me
                ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);
                
                // reassign filter
                element.style('filter', true).value = filter;   
            }
            
            this.render = function(ctx) {
                // NO RENDER
            }       
        }
        svg.Element.filter.prototype = new svg.Element.ElementBase;
        
        svg.Element.feMorphology = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx, x, y, width, height) {
                // TODO: implement
            }
        }
        svg.Element.feMorphology.prototype = new svg.Element.ElementBase;
        
        svg.Element.feComposite = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx, x, y, width, height) {
                // TODO: implement
            }
        }
        svg.Element.feComposite.prototype = new svg.Element.ElementBase;
        
        svg.Element.feColorMatrix = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            var matrix = svg.ToNumberArray(this.attribute('values').value);
            switch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
                case 'saturate':
                    var s = matrix[0];
                    matrix = [0.213+0.787*s,0.715-0.715*s,0.072-0.072*s,0,0,
                              0.213-0.213*s,0.715+0.285*s,0.072-0.072*s,0,0,
                              0.213-0.213*s,0.715-0.715*s,0.072+0.928*s,0,0,
                              0,0,0,1,0,
                              0,0,0,0,1];
                    break;
                case 'hueRotate':
                    var a = matrix[0] * Math.PI / 180.0;
                    var c = function (m1,m2,m3) { return m1 + Math.cos(a)*m2 + Math.sin(a)*m3; };
                    matrix = [c(0.213,0.787,-0.213),c(0.715,-0.715,-0.715),c(0.072,-0.072,0.928),0,0,
                              c(0.213,-0.213,0.143),c(0.715,0.285,0.140),c(0.072,-0.072,-0.283),0,0,
                              c(0.213,-0.213,-0.787),c(0.715,-0.715,0.715),c(0.072,0.928,0.072),0,0,
                              0,0,0,1,0,
                              0,0,0,0,1];
                    break;
                case 'luminanceToAlpha':
                    matrix = [0,0,0,0,0,
                              0,0,0,0,0,
                              0,0,0,0,0,
                              0.2125,0.7154,0.0721,0,0,
                              0,0,0,0,1];
                    break;
            }
            
            function imGet(img, x, y, width, height, rgba) {
                return img[y*width*4 + x*4 + rgba];
            }
            
            function imSet(img, x, y, width, height, rgba, val) {
                img[y*width*4 + x*4 + rgba] = val;
            }
            
            function m(i, v) {
                var mi = matrix[i];
                return mi * (mi < 0 ? v - 255 : v);
            }
                        
            this.apply = function(ctx, x, y, width, height) {
                // assuming x==0 && y==0 for now
                var srcData = ctx.getImageData(0, 0, width, height);
                for (var y = 0; y < height; y++) {
                    for (var x = 0; x < width; x++) {
                        var r = imGet(srcData.data, x, y, width, height, 0);
                        var g = imGet(srcData.data, x, y, width, height, 1);
                        var b = imGet(srcData.data, x, y, width, height, 2);
                        var a = imGet(srcData.data, x, y, width, height, 3);
                        imSet(srcData.data, x, y, width, height, 0, m(0,r)+m(1,g)+m(2,b)+m(3,a)+m(4,1));
                        imSet(srcData.data, x, y, width, height, 1, m(5,r)+m(6,g)+m(7,b)+m(8,a)+m(9,1));
                        imSet(srcData.data, x, y, width, height, 2, m(10,r)+m(11,g)+m(12,b)+m(13,a)+m(14,1));
                        imSet(srcData.data, x, y, width, height, 3, m(15,r)+m(16,g)+m(17,b)+m(18,a)+m(19,1));
                    }
                }
                ctx.clearRect(0, 0, width, height);
                ctx.putImageData(srcData, 0, 0);
            }
        }
        svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;
        
        svg.Element.feGaussianBlur = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
            this.extraFilterDistance = this.blurRadius;
            
            this.apply = function(ctx, x, y, width, height) {
                if (typeof(stackBlurCanvasRGBA) == 'undefined') {
                    svg.log('ERROR: StackBlur.js must be included for blur to work');
                    return;
                }
                
                // StackBlur requires canvas be on document
                ctx.canvas.id = svg.UniqueId();
                ctx.canvas.style.display = 'none';
                document.body.appendChild(ctx.canvas);
                stackBlurCanvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
                document.body.removeChild(ctx.canvas);
            }
        }
        svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;
        
        // title element, do nothing
        svg.Element.title = function(node) {
        }
        svg.Element.title.prototype = new svg.Element.ElementBase;

        // desc element, do nothing
        svg.Element.desc = function(node) {
        }
        svg.Element.desc.prototype = new svg.Element.ElementBase;       
        
        svg.Element.MISSING = function(node) {
            svg.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
        }
        svg.Element.MISSING.prototype = new svg.Element.ElementBase;
        
        // element factory
        svg.CreateElement = function(node) {    
            var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
            className = className.replace(/\-/g,''); // remove dashes
            var e = null;
            if (typeof(svg.Element[className]) != 'undefined') {
                e = new svg.Element[className](node);
            }
            else {
                e = new svg.Element.MISSING(node);
            }

            e.type = node.nodeName;
            return e;
        }
                
        // load from url
        svg.load = function(ctx, url) {
            svg.loadXml(ctx, svg.ajax(url));
        }
        
        // load from xml
        svg.loadXml = function(ctx, xml) {
            svg.loadXmlDoc(ctx, svg.parseXml(xml));
        }
        
        svg.loadXmlDoc = function(ctx, dom) {
            svg.init(ctx);
            
            var mapXY = function(p) {
                var e = ctx.canvas;
                while (e) {
                    p.x -= e.offsetLeft;
                    p.y -= e.offsetTop;
                    e = e.offsetParent;
                }
                if (window.scrollX) p.x += window.scrollX;
                if (window.scrollY) p.y += window.scrollY;
                return p;
            }
            
            // bind mouse
            if (svg.opts['ignoreMouse'] != true) {
                ctx.canvas.onclick = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onclick(p.x, p.y);
                };
                ctx.canvas.onmousemove = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onmousemove(p.x, p.y);
                };
            }
        
            var e = svg.CreateElement(dom.documentElement);
            e.root = true;
                    
            // render loop
            var isFirstRender = true;
            var draw = function() {
                svg.ViewPort.Clear();
                if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);
            
                if (svg.opts['ignoreDimensions'] != true) {
                    // set canvas size
                    if (e.style('width').hasValue()) {
                        ctx.canvas.width = e.style('width').toPixels('x');
                        ctx.canvas.style.width = ctx.canvas.width + 'px';
                    }
                    if (e.style('height').hasValue()) {
                        ctx.canvas.height = e.style('height').toPixels('y');
                        ctx.canvas.style.height = ctx.canvas.height + 'px';
                    }
                }
                var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
                var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
                if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
                    cWidth = e.style('width').toPixels('x');
                    cHeight = e.style('height').toPixels('y');
                }
                svg.ViewPort.SetCurrent(cWidth, cHeight);       
                
                if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
                if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
                if (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {
                    var xRatio = null, yRatio = null, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);
                    
                    if (svg.opts['scaleWidth'] != null) {
                        if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
                        else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
                    }
                    
                    if (svg.opts['scaleHeight'] != null) {
                        if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
                        else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
                    }

                    if (xRatio == null) { xRatio = yRatio; }
                    if (yRatio == null) { yRatio = xRatio; }
                    
                    e.attribute('width', true).value = svg.opts['scaleWidth'];
                    e.attribute('height', true).value = svg.opts['scaleHeight'];
                    e.attribute('transform', true).value += ' scale('+(1.0/xRatio)+','+(1.0/yRatio)+')';
                }
            
                // clear and render
                if (svg.opts['ignoreClear'] != true) {
                    ctx.clearRect(0, 0, cWidth, cHeight);
                }
                e.render(ctx);
                if (isFirstRender) {
                    isFirstRender = false;
                    if (typeof(svg.opts['renderCallback']) == 'function') svg.opts['renderCallback'](dom);
                }           
            }
            
            var waitingForImages = true;
            if (svg.ImagesLoaded()) {
                waitingForImages = false;
                draw();
            }
            svg.intervalID = setInterval(function() { 
                var needUpdate = false;
                
                if (waitingForImages && svg.ImagesLoaded()) {
                    waitingForImages = false;
                    needUpdate = true;
                }
            
                // need update from mouse events?
                if (svg.opts['ignoreMouse'] != true) {
                    needUpdate = needUpdate | svg.Mouse.hasEvents();
                }
            
                // need update from animations?
                if (svg.opts['ignoreAnimation'] != true) {
                    for (var i=0; i<svg.Animations.length; i++) {
                        needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
                    }
                }
                
                // need update from redraw?
                if (typeof(svg.opts['forceRedraw']) == 'function') {
                    if (svg.opts['forceRedraw']() == true) needUpdate = true;
                }
                
                // render if needed
                if (needUpdate) {
                    draw();             
                    svg.Mouse.runEvents(); // run and clear our events
                }
            }, 1000 / svg.FRAMERATE);
        }
        
        svg.stop = function() {
            if (svg.intervalID) {
                clearInterval(svg.intervalID);
            }
        }
        
        svg.Mouse = new (function() {
            this.events = [];
            this.hasEvents = function() { return this.events.length != 0; }
        
            this.onclick = function(x, y) {
                this.events.push({ type: 'onclick', x: x, y: y, 
                    run: function(e) { if (e.onclick) e.onclick(); }
                });
            }
            
            this.onmousemove = function(x, y) {
                this.events.push({ type: 'onmousemove', x: x, y: y,
                    run: function(e) { if (e.onmousemove) e.onmousemove(); }
                });
            }           
            
            this.eventElements = [];
            
            this.checkPath = function(element, ctx) {
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
                }
            }
            
            this.checkBoundingBox = function(element, bb) {
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
                }           
            }
            
            this.runEvents = function() {
                svg.ctx.canvas.style.cursor = '';
                
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    var element = this.eventElements[i];
                    while (element) {
                        e.run(element);
                        element = element.parent;
                    }
                }       
            
                // done running, clear
                this.events = []; 
                this.eventElements = [];
            }
        });
        
        return svg;
    }
})();

if (typeof(CanvasRenderingContext2D) != 'undefined') {
    CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
        canvg(this.canvas, s, { 
            ignoreMouse: true, 
            ignoreAnimation: true, 
            ignoreDimensions: true, 
            ignoreClear: true, 
            offsetX: dx, 
            offsetY: dy, 
            scaleWidth: dw, 
            scaleHeight: dh
        });
    }
}

},{}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/lib-src/rgbcolor.js":[function(require,module,exports){
// dependency for canvg
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license Use it if you like it
 */
function RGBColor(color_string)
{
    this.ok = false;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    for (var key in simple_colors) {
        if (color_string == key) {
            color_string = simple_colors[key];
        }
    }
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}


module.exports = RGBColor;

},{}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/underscore-transpose.js":[function(require,module,exports){
var _ = require('underscore');

_.mixin({
  transpose: function(arrs) {
    return _.zip.apply(_, arrs);
  }
});

},{"underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/app/js/ugly/util.js":[function(require,module,exports){
// hopefully not that ugly, but seemed as good a place as any for this stuff...

var d3 = require('d3-browserify');


var formatKMB = function(precision, decimalSeparator) {
  var formatSI = d3.format('.' + (precision || 3) + 's');
  decimalSeparator = decimalSeparator || '.';
  return function(value) {
    return formatSI(value)
      .replace('G', 'B')  // now just need to convert G Gigia -> B Billion
      .replace('.', decimalSeparator);
  };
};


var formatShortText = function(maxWidth) {
  var ellipseWidth = 1;
  return function(text) {
    if (text.length - ellipseWidth > maxWidth) {
      text = text.slice(0, maxWidth - ellipseWidth) + '...';
    }
    return text;
  };
};


var categoryColours = function(cats) {
  // get an appropriate colour scale for the number of categories we are
  // dealing with
  var colours = d3.scale['category' + (cats > 10 ? '20' : '10')]().range();
  return function(d, i) {
    return d.color || (d.data && d.data.color) || colours[i % colours.length];
  };
};


var u16le64 = function(str) {
  // base64-encode a string as UTF-16-LE (for MS Excel, probably). It will only
  // work for 2-byte-wide utf-16 characters, and will break at the first hint
  // of any 4-byte char. Two bytes covers the Basic Multiningual Plane, so we
  // should be good.
  var u16num,
      asciiBytePairString = String.fromCharCode(0xFF) + String.fromCharCode(0xFE);
  asciiBytePairString += Array.prototype.reduce.call(str, function(acc, chr) {
    u16num = chr.charCodeAt(0);
    /* jshint bitwise:false */
    return acc + String.fromCharCode(u16num & 0xFF) + String.fromCharCode(u16num >> 8);
    /* jshint bitwise:true */
  }, '');
  return btoa(asciiBytePairString);
};


var textAsDataURL = function(str) {
  return 'data:text/plain;base64,' + u16le64(str);
};


function transformArgs(transformer, wrapped) {
  return function(/* arguments */) {
    var transformedArgs = transformer.apply(null, arguments);
    return wrapped.apply(null, transformedArgs);
  };
}


function toDashed(name) {
  // transform namesLikeThis to names-like-this
  return name.replace(/([A-Z])/g, function(u) {
    return '-' + u.toLowerCase();
  });
}


function data(el, name, newValue) {
  if (newValue === void 0) {
    return el.getAttribute('data-' + toDashed(name));
  }
  el.setAttribute('data-' + toDashed(name), newValue);
}


module.exports = {
  formatKMB: formatKMB,
  formatShortText: formatShortText,
  categoryColours: categoryColours,
  u16le64: u16le64,
  textAsDataURL: textAsDataURL,
  transformArgs: transformArgs,
  data: data
};

},{"d3-browserify":"d3-browserify"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/node_modules/babyparse/babyparse.js":[function(require,module,exports){
/*
	Baby Parse
	v0.2.1
	https://github.com/Rich-Harris/BabyParse

	based on Papa Parse v3.0.1
	https://github.com/mholt/PapaParse
*/


(function ( global ) {

	// A configuration object from which to draw default settings
	var DEFAULTS = {
		delimiter: "",	// empty: auto-detect
		header: false,
		dynamicTyping: false,
		preview: 0,
		step: undefined,
		comments: false,
		complete: undefined,
		keepEmptyRows: false
	};

	var Baby = {};
	Baby.parse = CsvToJson;
	Baby.unparse = JsonToCsv;
	Baby.RECORD_SEP = String.fromCharCode(30);
	Baby.UNIT_SEP = String.fromCharCode(31);
	Baby.BYTE_ORDER_MARK = "\ufeff";
	Baby.BAD_DELIMITERS = ["\r", "\n", "\"", Baby.BYTE_ORDER_MARK];


	function CsvToJson(_input, _config)
	{
		var config = copyAndValidateConfig(_config);
		var ph = new ParserHandle(config);
		var results = ph.parse(_input);
		if (isFunction(config.complete))
			config.complete(results);
		return results;
	}




	function JsonToCsv(_input, _config)
	{
		var _output = "";
		var _fields = [];

		// Default configuration
		var _quotes = false;	// whether to surround every datum with quotes
		var _delimiter = ",";	// delimiting character
		var _newline = "\r\n";	// newline character(s)

		unpackConfig();

		if (typeof _input === 'string')
			_input = JSON.parse(_input);

		if (_input instanceof Array)
		{
			if (!_input.length || _input[0] instanceof Array)
				return serialize(null, _input);
			else if (typeof _input[0] === 'object')
				return serialize(objectKeys(_input[0]), _input);
		}
		else if (typeof _input === 'object')
		{
			if (typeof _input.data === 'string')
				_input.data = JSON.parse(_input.data);

			if (_input.data instanceof Array)
			{
				if (!_input.fields)
					_input.fields = _input.data[0] instanceof Array
									? _input.fields
									: objectKeys(_input.data[0]);

				if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')
					_input.data = [_input.data];	// handles input like [1,2,3] or ["asdf"]
			}

			return serialize(_input.fields || [], _input.data || []);
		}

		// Default (any valid paths should return before this)
		throw "exception: Unable to serialize unrecognized input";


		function unpackConfig()
		{
			if (typeof _config !== 'object')
				return;

			if (typeof _config.delimiter === 'string'
				&& _config.delimiter.length == 1
				&& Baby.BAD_DELIMITERS.indexOf(_config.delimiter) == -1)
			{
				_delimiter = _config.delimiter;
			}

			if (typeof _config.quotes === 'boolean'
				|| _config.quotes instanceof Array)
				_quotes = _config.quotes;

			if (typeof _config.newline === 'string')
				_newline = _config.newline;
		}


		// Turns an object's keys into an array
		function objectKeys(obj)
		{
			if (typeof obj !== 'object')
				return [];
			var keys = [];
			for (var key in obj)
				keys.push(key);
			return keys;
		}

		// The double for loop that iterates the data and writes out a CSV string including header row
		function serialize(fields, data)
		{
			var csv = "";

			if (typeof fields === 'string')
				fields = JSON.parse(fields);
			if (typeof data === 'string')
				data = JSON.parse(data);

			var hasHeader = fields instanceof Array && fields.length > 0;
			var dataKeyedByField = !(data[0] instanceof Array);

			// If there a header row, write it first
			if (hasHeader)
			{
				for (var i = 0; i < fields.length; i++)
				{
					if (i > 0)
						csv += _delimiter;
					csv += safe(fields[i], i);
				}
				if (data.length > 0)
					csv += _newline;
			}

			// Then write out the data
			for (var row = 0; row < data.length; row++)
			{
				var maxCol = hasHeader ? fields.length : data[row].length;

				for (var col = 0; col < maxCol; col++)
				{
					if (col > 0)
						csv += _delimiter;
					var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
					csv += safe(data[row][colIdx], col);
				}

				if (row < data.length - 1)
					csv += _newline;
			}

			return csv;
		}

		// Encloses a value around quotes if needed (makes a value safe for CSV insertion)
		function safe(str, col)
		{
			if (typeof str === "undefined")
				return "";

			str = str.toString().replace(/"/g, '""');

			var needsQuotes = (typeof _quotes === 'boolean' && _quotes)
							|| (_quotes instanceof Array && _quotes[col])
							|| hasAny(str, Baby.BAD_DELIMITERS)
							|| str.indexOf(_delimiter) > -1
							|| str.charAt(0) == ' '
							|| str.charAt(str.length - 1) == ' ';

			return needsQuotes ? '"' + str + '"' : str;
		}

		function hasAny(str, substrings)
		{
			for (var i = 0; i < substrings.length; i++)
				if (str.indexOf(substrings[i]) > -1)
					return true;
			return false;
		}
	}






	// Use one ParserHandle per entire CSV file or string
	function ParserHandle(_config)
	{
		// One goal is to minimize the use of regular expressions...
		var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;

		var _delimiterError;	// Temporary state between delimiter detection and processing results
		var _fields = [];		// Fields are from the header row of the input, if there is one
		var _results = {		// The last results returned from the parser
			data: [],
			errors: [],
			meta: {}
		};
		_config = copy(_config);

		this.parse = function(input)
		{
			_delimiterError = false;
			if (!_config.delimiter)
			{
				var delimGuess = guessDelimiter(input);
				if (delimGuess.successful)
					_config.delimiter = delimGuess.bestDelimiter;
				else
				{
					_delimiterError = true;	// add error after parsing (otherwise it would be overwritten)
					_config.delimiter = ",";
				}
				_results.meta.delimiter = _config.delimiter;
			}

			if (isFunction(_config.step))
			{
				var userStep = _config.step;
				_config.step = function(results, parser)
				{
					_results = results;
					if (needsHeaderRow())
						processResults();
					else
						userStep(processResults(), parser);
				};
			}

			_results = new Parser(_config).parse(input);
			return processResults();
		};

		function processResults()
		{
			if (_results && _delimiterError)
			{
				addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to comma");
				_delimiterError = false;
			}

			if (needsHeaderRow())
				fillHeaderFields();

			return applyHeaderAndDynamicTyping();
		}

		function needsHeaderRow()
		{
			return _config.header && _fields.length == 0;
		}

		function fillHeaderFields()
		{
			if (!_results)
				return;
			for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
				for (var j = 0; j < _results.data[i].length; j++)
					_fields.push(_results.data[i][j]);
			_results.data.splice(0, 1);
		}

		function applyHeaderAndDynamicTyping()
		{
			if (!_results || (!_config.header && !_config.dynamicTyping))
				return _results;

			for (var i = 0; i < _results.data.length; i++)
			{
				var row = {};
				for (var j = 0; j < _results.data[i].length; j++)
				{
					if (_config.dynamicTyping)
					{
						var value = _results.data[i][j];
						if (value == "true")
							_results.data[i][j] = true;
						else if (value == "false")
							_results.data[i][j] = false;
						else
							_results.data[i][j] = tryParseFloat(value);
					}

					if (_config.header)
					{
						if (j >= _fields.length)
						{
							if (!row["__parsed_extra"])
								row["__parsed_extra"] = [];
							row["__parsed_extra"].push(_results.data[i][j]);
						}
						row[_fields[j]] = _results.data[i][j];
					}
				}

				if (_config.header)
				{
					_results.data[i] = row;
					if (j > _fields.length)
						addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + _fields.length + " fields but parsed " + j, i);
					else if (j < _fields.length)
						addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + _fields.length + " fields but parsed " + j, i);
				}
			}

			if (_config.header && _results.meta);
				_results.meta.fields = _fields;

			return _results;
		}

		function guessDelimiter(input)
		{
			var delimChoices = [",", "\t", "|", ";", Baby.RECORD_SEP, Baby.UNIT_SEP];
			var bestDelim, bestDelta, fieldCountPrevRow;

			for (var i = 0; i < delimChoices.length; i++)
			{
				var delim = delimChoices[i];
				var delta = 0, avgFieldCount = 0;
				fieldCountPrevRow = undefined;

				var preview = new Parser({
					delimiter: delim,
					preview: 10
				}).parse(input);

				for (var j = 0; j < preview.data.length; j++)
				{
					var fieldCount = preview.data[j].length;
					avgFieldCount += fieldCount;

					if (typeof fieldCountPrevRow === 'undefined')
					{
						fieldCountPrevRow = fieldCount;
						continue;
					}
					else if (fieldCount > 1)
					{
						delta += Math.abs(fieldCount - fieldCountPrevRow);
						fieldCountPrevRow = fieldCount;
					}
				}

				avgFieldCount /= preview.data.length;

				if ((typeof bestDelta === 'undefined' || delta < bestDelta)
					&& avgFieldCount > 1.99)
				{
					bestDelta = delta;
					bestDelim = delim;
				}
			}

			_config.delimiter = bestDelim;

			return {
				successful: !!bestDelim,
				bestDelimiter: bestDelim
			}
		}

		function tryParseFloat(val)
		{
			var isNumber = FLOAT.test(val);
			return isNumber ? parseFloat(val) : val;
		}

		function addError(type, code, msg, row)
		{
			_results.errors.push({
				type: type,
				code: code,
				message: msg,
				row: row
			});
		}
	}







	function Parser(config)
	{
		var self = this;
		var EMPTY = /^\s*$/;

		var _input;		// The input text being parsed
		var _delimiter;	// The delimiting character
		var _comments;	// Comment character (default '#') or boolean
		var _step;		// The step (streaming) function
		var _callback;	// The callback to invoke when finished
		var _preview;	// Maximum number of lines (not rows) to parse
		var _ch;		// Current character
		var _i;			// Current character's positional index
		var _inQuotes;	// Whether in quotes or not
		var _lineNum;	// Current line number (1-based indexing)
		var _data;		// Parsed data (results)
		var _errors;	// Parse errors
		var _rowIdx;	// Current row index within results (0-based)
		var _colIdx;	// Current col index within result row (0-based)
		var _runningRowIdx;		// Cumulative row index, used by the preview feature
		var _aborted = false;	// Abort flag
		var _paused = false;	// Pause flag

		// Unpack the config object
		config = config || {};
		_delimiter = config.delimiter;
		_comments = config.comments;
		_step = config.step;
		_preview = config.preview;

		// Delimiter integrity check
		if (typeof _delimiter !== 'string'
			|| _delimiter.length != 1
			|| Baby.BAD_DELIMITERS.indexOf(_delimiter) > -1)
			_delimiter = ",";

		// Comment character integrity check
		if (_comments === true)
			_comments = "#";
		else if (typeof _comments !== 'string'
			|| _comments.length != 1
			|| Baby.BAD_DELIMITERS.indexOf(_comments) > -1
			|| _comments == _delimiter)
			_comments = false;


		this.parse = function(input)
		{
			if (typeof input !== 'string')
				throw "Input must be a string";
			reset(input);
			return parserLoop();
		};

		this.abort = function()
		{
			_aborted = true;
		};

		function parserLoop()
		{
			while (_i < _input.length)
			{
				if (_aborted) break;
				if (_preview > 0 && _runningRowIdx >= _preview) break;
				if (_paused) return finishParsing();

				if (_ch == '"')
					parseQuotes();
				else if (_inQuotes)
					parseInQuotes();
				else
					parseNotInQuotes();

				nextChar();
			}

			return finishParsing();
		}

		function nextChar()
		{
			_i++;
			_ch = _input[_i];
		}

		function finishParsing()
		{
			if (_aborted)
				addError("Abort", "ParseAbort", "Parsing was aborted by the user's step function");
			if (_inQuotes)
				addError("Quotes", "MissingQuotes", "Unescaped or mismatched quotes");
			endRow();	// End of input is also end of the last row
			if (!isFunction(_step))
				return returnable();
		}

		function parseQuotes()
		{
			if (quotesOnBoundary() && !quotesEscaped())
				_inQuotes = !_inQuotes;
			else
			{
				saveChar();
				if (_inQuotes && quotesEscaped())
					_i++
				else
					addError("Quotes", "UnexpectedQuotes", "Unexpected quotes");
			}
		}

		function parseInQuotes()
		{
			if (twoCharLineBreak(_i) || oneCharLineBreak(_i))
				_lineNum++;
			saveChar();
		}

		function parseNotInQuotes()
		{
			if (_ch == _delimiter)
				newField();
			else if (twoCharLineBreak(_i))
			{
				newRow();
				nextChar();
			}
			else if (oneCharLineBreak(_i))
				newRow();
			else if (isCommentStart())
				skipLine();
			else
				saveChar();
		}

		function isCommentStart()
		{
			if (!_comments)
				return false;

			var firstCharOfLine = _i == 0
									|| oneCharLineBreak(_i-1)
									|| twoCharLineBreak(_i-2);
			return firstCharOfLine && _input[_i] === _comments;
		}

		function skipLine()
		{
			while (!twoCharLineBreak(_i)
				&& !oneCharLineBreak(_i)
				&& _i < _input.length)
			{
				nextChar();
			}
		}

		function saveChar()
		{
			_data[_rowIdx][_colIdx] += _ch;
		}

		function newField()
		{
			_data[_rowIdx].push("");
			_colIdx = _data[_rowIdx].length - 1;
		}

		function newRow()
		{
			endRow();

			_lineNum++;
			_runningRowIdx++;
			_data.push([]);
			_rowIdx = _data.length - 1;
			newField();
		}

		function endRow()
		{
			trimEmptyLastRow();
			if (isFunction(_step))
			{
				if (_data[_rowIdx])
					_step(returnable(), self);
				clearErrorsAndData();
			}
		}

		function trimEmptyLastRow()
		{
			if (_data[_rowIdx].length == 1 && EMPTY.test(_data[_rowIdx][0]))
			{
				if (config.keepEmptyRows)
					_data[_rowIdx].splice(0, 1);	// leave row, but no fields
				else
					_data.splice(_rowIdx, 1);		// cut out row entirely
				_rowIdx = _data.length - 1;
			}
		}

		function twoCharLineBreak(i)
		{
			return i < _input.length - 1 &&
				((_input[i] == "\r" && _input[i+1] == "\n")
				|| (_input[i] == "\n" && _input[i+1] == "\r"))
		}

		function oneCharLineBreak(i)
		{
			return _input[i] == "\r" || _input[i] == "\n";
		}

		function quotesEscaped()
		{
			// Quotes as data cannot be on boundary, for example: ,"", are not escaped quotes
			return !quotesOnBoundary() && _i < _input.length - 1 && _input[_i+1] == '"';
		}

		function quotesOnBoundary()
		{
			return (!_inQuotes && isBoundary(_i-1)) || isBoundary(_i+1);
		}

		function isBoundary(i)
		{
			if (typeof i != 'number')
				i = _i;

			var ch = _input[i];

			return (i <= -1 || i >= _input.length)
				|| (ch == _delimiter
					|| ch == "\r"
					|| ch == "\n");
		}

		function addError(type, code, msg)
		{
			_errors.push({
				type: type,
				code: code,
				message: msg,
				line: _lineNum,
				row: _rowIdx,
				index: _i
			});
		}

		function reset(input)
		{
			_input = input;
			_inQuotes = false;
			_i = 0, _runningRowIdx = 0, _lineNum = 1;
			clearErrorsAndData();
			_data = [ [""] ];	// starting parsing requires an empty field
			_ch = _input[_i];
		}

		function clearErrorsAndData()
		{
			_data = [];
			_errors = [];
			_rowIdx = 0;
			_colIdx = 0;
		}

		function returnable()
		{
			return {
				data: _data,
				errors: _errors,
				meta: {
					lines: _lineNum,
					delimiter: _delimiter,
					aborted: _aborted
				}
			};
		}
	}

	// Replaces bad config values with good, default ones
	function copyAndValidateConfig(origConfig)
	{
		if (typeof origConfig !== 'object')
			origConfig = {};

		var config = copy(origConfig);

		if (typeof config.delimiter !== 'string'
			|| config.delimiter.length != 1
			|| Baby.BAD_DELIMITERS.indexOf(config.delimiter) > -1)
			config.delimiter = DEFAULTS.delimiter;

		if (typeof config.header !== 'boolean')
			config.header = DEFAULTS.header;

		if (typeof config.dynamicTyping !== 'boolean')
			config.dynamicTyping = DEFAULTS.dynamicTyping;

		if (typeof config.preview !== 'number')
			config.preview = DEFAULTS.preview;

		if (typeof config.step !== 'function')
			config.step = DEFAULTS.step;

		if (typeof config.complete !== 'function')
			config.complete = DEFAULTS.complete;

		if (typeof config.keepEmptyRows !== 'boolean')
			config.keepEmptyRows = DEFAULTS.keepEmptyRows;

		return config;
	}

	function copy(obj)
	{
		if (typeof obj !== 'object')
			return obj;
		var cpy = obj instanceof Array ? [] : {};
		for (var key in obj)
			cpy[key] = copy(obj[key]);
		return cpy;
	}

	function isFunction(func)
	{
		return typeof func === 'function';
	}






	// export to Node...
	if ( typeof module !== 'undefined' && module.exports ) {
		module.exports = Baby;
	}

	// ...or as AMD module...
	else if ( typeof define === 'function' && define.amd ) {
		define( function () { return Baby; });
	}

	// ...or as browser global
	else {
		global.Baby = Baby;
	}



}( typeof window !== 'undefined' ? window : this ));

},{}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/node_modules/numeral/numeral.js":[function(require,module,exports){
/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var numeral,
        VERSION = '1.5.3',
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',
        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports);


    /************************************
        Constructors
    ************************************/


    // Numeral prototype object
    function Numeral (number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed (value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;
            
        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral (n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) { // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) { // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) { // time
            output = formatTime(n, format);
        } else { // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral (n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency (n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage (n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);
        
        if (output.indexOf(')') > -1 ) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime (n) {
        var hours = Math.floor(n._value/60/60),
            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
    }

    function unformatTime (string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
            // minutes
            seconds = seconds + (Number(timeArray[1]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + (Number(timeArray[0]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber (value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false, // force abbreviation to thousands
            abbrM = false, // force abbreviation to millions
            abbrB = false, // force abbreviation to billions
            abbrT = false, // force abbreviation to trillions
            abbrForce = false, // force abbreviation
            bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power+1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    numeral = function (input) {
        if (numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if(!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return numeral;
    };
    
    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }
        
        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }
        
        return languages[key];
    };

    numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    numeral.zeroFormat = function (format) {
        zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function (format) {
        defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';
            
            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }
            
            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    
    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
        return mp > mn ? mp : mn;
        }, -Infinity);
    }        


    /************************************
        Numeral Prototype
    ************************************/


    numeral.fn = Numeral.prototype = {

        clone : function () {
            return numeral(this);
        },

        format : function (inputString, roundingFunction) {
            return formatNumeral(this, 
                  inputString ? inputString : defaultFormat, 
                  (roundingFunction !== undefined) ? roundingFunction : Math.round
              );
        },

        unformat : function (inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') { 
                return inputString; 
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value : function () {
            return this._value;
        },

        valueOf : function () {
            return this._value;
        },

        set : function (value) {
            this._value = Number(value);
            return this;
        },

        add : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            
            return this;
        },

        multiply : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) * (curr * corrFactor) /
                    (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);            
            return this;
        },

        difference : function (value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    // CommonJS module is defined
    if (hasModule) {
        module.exports = numeral;
    }

    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `numeral` as a global object via a string identifier,
        // for Closure Compiler 'advanced' mode
        this['numeral'] = numeral;
    }

    /*global define:false */
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return numeral;
        });
    }
}).call(this);

},{}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/dashboard/dev/node_modules/nvd3/nv.d3.js":[function(require,module,exports){
(function(){

var nv = window.nv || {};


nv.version = '1.1.15b';
nv.dev = true //set false when in production

window.nv = nv;

nv.tooltip = nv.tooltip || {}; // For the tooltip system
nv.utils = nv.utils || {}; // Utility subsystem
nv.models = nv.models || {}; //stores all the possible models/components
nv.charts = {}; //stores all the ready to use charts
nv.graphs = []; //stores all the graphs currently on the page
nv.logs = {}; //stores some statistics and potential error messages

nv.dispatch = d3.dispatch('render_start', 'render_end');

// *************************************************************************
//  Development render timers - disabled if dev = false

if (nv.dev) {
  nv.dispatch.on('render_start', function(e) {
    nv.logs.startTime = +new Date();
  });

  nv.dispatch.on('render_end', function(e) {
    nv.logs.endTime = +new Date();
    nv.logs.totalTime = nv.logs.endTime - nv.logs.startTime;
    nv.log('total', nv.logs.totalTime); // used for development, to keep track of graph generation times
  });
}

// ********************************************
//  Public Core NV functions

// Logs all arguments, and returns the last so you can test things in place
// Note: in IE8 console.log is an object not a function, and if modernizr is used
// then calling Function.prototype.bind with with anything other than a function
// causes a TypeError to be thrown.
nv.log = function() {
  if (nv.dev && console.log && console.log.apply)
    console.log.apply(console, arguments)
  else if (nv.dev && typeof console.log == "function" && Function.prototype.bind) {
    var log = Function.prototype.bind.call(console.log, console);
    log.apply(console, arguments);
  }
  return arguments[arguments.length - 1];
};


nv.render = function render(step) {
  step = step || 1; // number of graphs to generate in each timeout loop

  nv.render.active = true;
  nv.dispatch.render_start();

  setTimeout(function() {
    var chart, graph;

    for (var i = 0; i < step && (graph = nv.render.queue[i]); i++) {
      chart = graph.generate();
      if (typeof graph.callback == typeof(Function)) graph.callback(chart);
      nv.graphs.push(chart);
    }

    nv.render.queue.splice(0, i);

    if (nv.render.queue.length) setTimeout(arguments.callee, 0);
    else {
      nv.dispatch.render_end();
      nv.render.active = false;
    }
  }, 0);
};

nv.render.active = false;
nv.render.queue = [];

nv.addGraph = function(obj) {
  if (typeof arguments[0] === typeof(Function))
    obj = {generate: arguments[0], callback: arguments[1]};

  nv.render.queue.push(obj);

  if (!nv.render.active) nv.render();
};

nv.identity = function(d) { return d; };

nv.strip = function(s) { return s.replace(/(\s|&)/g,''); };

function daysInMonth(month,year) {
  return (new Date(year, month+1, 0)).getDate();
}

function d3_time_range(floor, step, number) {
  return function(t0, t1, dt) {
    var time = floor(t0), times = [];
    if (time < t0) step(time);
    if (dt > 1) {
      while (time < t1) {
        var date = new Date(+time);
        if ((number(date) % dt === 0)) times.push(date);
        step(time);
      }
    } else {
      while (time < t1) { times.push(new Date(+time)); step(time); }
    }
    return times;
  };
}

d3.time.monthEnd = function(date) {
  return new Date(date.getFullYear(), date.getMonth(), 0);
};

d3.time.monthEnds = d3_time_range(d3.time.monthEnd, function(date) {
    date.setUTCDate(date.getUTCDate() + 1);
    date.setDate(daysInMonth(date.getMonth() + 1, date.getFullYear()));
  }, function(date) {
    return date.getMonth();
  }
);

/* Utility class to handle creation of an interactive layer.
This places a rectangle on top of the chart. When you mouse move over it, it sends a dispatch
containing the X-coordinate. It can also render a vertical line where the mouse is located.

dispatch.elementMousemove is the important event to latch onto.  It is fired whenever the mouse moves over
the rectangle. The dispatch is given one object which contains the mouseX/Y location.
It also has 'pointXValue', which is the conversion of mouseX to the x-axis scale.
*/
nv.interactiveGuideline = function() {
	"use strict";
	var tooltip = nv.models.tooltip();
	//Public settings
	var width = null
	, height = null
    //Please pass in the bounding chart's top and left margins
    //This is important for calculating the correct mouseX/Y positions.
	, margin = {left: 0, top: 0}
	, xScale = d3.scale.linear()
	, yScale = d3.scale.linear()
	, dispatch = d3.dispatch('elementMousemove', 'elementMouseout','elementDblclick')
	, showGuideLine = true
	, svgContainer = null  
    //Must pass in the bounding chart's <svg> container.
    //The mousemove event is attached to this container.
	;

	//Private variables
	var isMSIE = navigator.userAgent.indexOf("MSIE") !== -1  //Check user-agent for Microsoft Internet Explorer.
	;


	function layer(selection) {
		selection.each(function(data) {
				var container = d3.select(this);
				
				var availableWidth = (width || 960), availableHeight = (height || 400);

				var wrap = container.selectAll("g.nv-wrap.nv-interactiveLineLayer").data([data]);
				var wrapEnter = wrap.enter()
								.append("g").attr("class", " nv-wrap nv-interactiveLineLayer");
								
				
				wrapEnter.append("g").attr("class","nv-interactiveGuideLine");
				
				if (!svgContainer) {
					return;
				}

                function mouseHandler() {
                      var d3mouse = d3.mouse(this);
                      var mouseX = d3mouse[0];
                      var mouseY = d3mouse[1];
                      var subtractMargin = true;
                      var mouseOutAnyReason = false;
                      if (isMSIE) {
                         /*
                            D3.js (or maybe SVG.getScreenCTM) has a nasty bug in Internet Explorer 10.
                            d3.mouse() returns incorrect X,Y mouse coordinates when mouse moving
                            over a rect in IE 10.
                            However, d3.event.offsetX/Y also returns the mouse coordinates
                            relative to the triggering <rect>. So we use offsetX/Y on IE.  
                         */
                         mouseX = d3.event.offsetX;
                         mouseY = d3.event.offsetY;

                         /*
                            On IE, if you attach a mouse event listener to the <svg> container,
                            it will actually trigger it for all the child elements (like <path>, <circle>, etc).
                            When this happens on IE, the offsetX/Y is set to where ever the child element
                            is located.
                            As a result, we do NOT need to subtract margins to figure out the mouse X/Y
                            position under this scenario. Removing the line below *will* cause 
                            the interactive layer to not work right on IE.
                         */
                         if(d3.event.target.tagName !== "svg")
                            subtractMargin = false;

                         if (d3.event.target.className.baseVal.match("nv-legend"))
                         	mouseOutAnyReason = true;
                          
                      }

                      if(subtractMargin) {
                         mouseX -= margin.left;
                         mouseY -= margin.top;
                      }

                      /* If mouseX/Y is outside of the chart's bounds,
                      trigger a mouseOut event.
                      */
                      if (mouseX < 0 || mouseY < 0 
                        || mouseX > availableWidth || mouseY > availableHeight
                        || (d3.event.relatedTarget && d3.event.relatedTarget.ownerSVGElement === undefined)
                        || mouseOutAnyReason
                        ) 
                      {
                      		if (isMSIE) {
                      			if (d3.event.relatedTarget 
                      				&& d3.event.relatedTarget.ownerSVGElement === undefined
                      				&& d3.event.relatedTarget.className.match(tooltip.nvPointerEventsClass)) {
                      				return;
                      			}
                      		}
                            dispatch.elementMouseout({
                               mouseX: mouseX,
                               mouseY: mouseY
                            });
                            layer.renderGuideLine(null); //hide the guideline
                            return;
                      }
                      
                      var pointXValue = xScale.invert(mouseX);
                      dispatch.elementMousemove({
                            mouseX: mouseX,
                            mouseY: mouseY,
                            pointXValue: pointXValue
                      });

                      //If user double clicks the layer, fire a elementDblclick dispatch.
                      if (d3.event.type === "dblclick") {
                        dispatch.elementDblclick({
                            mouseX: mouseX,
                            mouseY: mouseY,
                            pointXValue: pointXValue
                        });
                      }
                }

				svgContainer
				      .on("mousemove",mouseHandler, true)
				      .on("mouseout" ,mouseHandler,true)
                      .on("dblclick" ,mouseHandler)
				      ;

				 //Draws a vertical guideline at the given X postion.
				layer.renderGuideLine = function(x) {
				 	if (!showGuideLine) return;
				 	var line = wrap.select(".nv-interactiveGuideLine")
				 	      .selectAll("line")
				 	      .data((x != null) ? [nv.utils.NaNtoZero(x)] : [], String);

				 	line.enter()
				 		.append("line")
				 		.attr("class", "nv-guideline")
				 		.attr("x1", function(d) { return d;})
				 		.attr("x2", function(d) { return d;})
				 		.attr("y1", availableHeight)
				 		.attr("y2",0)
				 		;
				 	line.exit().remove();

				}
		});
	}

	layer.dispatch = dispatch;
	layer.tooltip = tooltip;

	layer.margin = function(_) {
	    if (!arguments.length) return margin;
	    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
	    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
	    return layer;
    };

	layer.width = function(_) {
		if (!arguments.length) return width;
		width = _;
		return layer;
	};

	layer.height = function(_) {
		if (!arguments.length) return height;
		height = _;
		return layer;
	};

	layer.xScale = function(_) {
		if (!arguments.length) return xScale;
		xScale = _;
		return layer;
	};

	layer.showGuideLine = function(_) {
		if (!arguments.length) return showGuideLine;
		showGuideLine = _;
		return layer;
	};

	layer.svgContainer = function(_) {
		if (!arguments.length) return svgContainer;
		svgContainer = _;
		return layer;
	};


	return layer;
};

/* Utility class that uses d3.bisect to find the index in a given array, where a search value can be inserted.
This is different from normal bisectLeft; this function finds the nearest index to insert the search value.

For instance, lets say your array is [1,2,3,5,10,30], and you search for 28. 
Normal d3.bisectLeft will return 4, because 28 is inserted after the number 10.  But interactiveBisect will return 5
because 28 is closer to 30 than 10.

Unit tests can be found in: interactiveBisectTest.html

Has the following known issues:
   * Will not work if the data points move backwards (ie, 10,9,8,7, etc) or if the data points are in random order.
   * Won't work if there are duplicate x coordinate values.
*/
nv.interactiveBisect = function (values, searchVal, xAccessor) {
	  "use strict";
      if (! values instanceof Array) return null;
      if (typeof xAccessor !== 'function') xAccessor = function(d,i) { return d.x;}

      var bisect = d3.bisector(xAccessor).left;
      var index = d3.max([0, bisect(values,searchVal) - 1]);
      var currentValue = xAccessor(values[index], index);
      if (typeof currentValue === 'undefined') currentValue = index;

      if (currentValue === searchVal) return index;  //found exact match

      var nextIndex = d3.min([index+1, values.length - 1]);
      var nextValue = xAccessor(values[nextIndex], nextIndex);
      if (typeof nextValue === 'undefined') nextValue = nextIndex;

      if (Math.abs(nextValue - searchVal) >= Math.abs(currentValue - searchVal))
          return index;
      else
          return nextIndex
};

/*
Returns the index in the array "values" that is closest to searchVal.
Only returns an index if searchVal is within some "threshold".
Otherwise, returns null.
*/
nv.nearestValueIndex = function (values, searchVal, threshold) {
      "use strict";
      var yDistMax = Infinity, indexToHighlight = null;
      values.forEach(function(d,i) {
         var delta = Math.abs(searchVal - d);
         if ( delta <= yDistMax && delta < threshold) {
            yDistMax = delta;
            indexToHighlight = i;
         }
      });
      return indexToHighlight;
};/* Tooltip rendering model for nvd3 charts.
window.nv.models.tooltip is the updated,new way to render tooltips.

window.nv.tooltip.show is the old tooltip code.
window.nv.tooltip.* also has various helper methods.
*/
(function() {
  "use strict";
  window.nv.tooltip = {};

  /* Model which can be instantiated to handle tooltip rendering.
    Example usage: 
    var tip = nv.models.tooltip().gravity('w').distance(23)
                .data(myDataObject);

        tip();    //just invoke the returned function to render tooltip.
  */
  window.nv.models.tooltip = function() {
        var content = null    //HTML contents of the tooltip.  If null, the content is generated via the data variable.
        ,   data = null     /* Tooltip data. If data is given in the proper format, a consistent tooltip is generated.
        Format of data:
        {
            key: "Date",
            value: "August 2009", 
            series: [
                    {
                        key: "Series 1",
                        value: "Value 1",
                        color: "#000"
                    },
                    {
                        key: "Series 2",
                        value: "Value 2",
                        color: "#00f"
                    }
            ]

        }

        */
        ,   gravity = 'w'   //Can be 'n','s','e','w'. Determines how tooltip is positioned.
        ,   distance = 50   //Distance to offset tooltip from the mouse location.
        ,   snapDistance = 25   //Tolerance allowed before tooltip is moved from its current position (creates 'snapping' effect)
        ,   fixedTop = null //If not null, this fixes the top position of the tooltip.
        ,   classes = null  //Attaches additional CSS classes to the tooltip DIV that is created.
        ,   chartContainer = null   //Parent DIV, of the SVG Container that holds the chart.
        ,   tooltipElem = null  //actual DOM element representing the tooltip.
        ,   position = {left: null, top: null}      //Relative position of the tooltip inside chartContainer.
        ,   enabled = true  //True -> tooltips are rendered. False -> don't render tooltips.
        //Generates a unique id when you create a new tooltip() object
        ,   id = "nvtooltip-" + Math.floor(Math.random() * 100000)
        ;

        //CSS class to specify whether element should not have mouse events.
        var  nvPointerEventsClass = "nv-pointer-events-none";

        //Format function for the tooltip values column
        var valueFormatter = function(d,i) {
            return d;
        };

        //Format function for the tooltip header value.
        var headerFormatter = function(d) {
            return d;
        };

        //By default, the tooltip model renders a beautiful table inside a DIV.
        //You can override this function if a custom tooltip is desired.
        var contentGenerator = function(d) {
            if (content != null) return content;

            if (d == null) return '';

            var table = d3.select(document.createElement("table"));
            var theadEnter = table.selectAll("thead")
                .data([d])
                .enter().append("thead");
            theadEnter.append("tr")
                .append("td")
                .attr("colspan",3)
                .append("strong")
                    .classed("x-value",true)
                    .html(headerFormatter(d.value));

            var tbodyEnter = table.selectAll("tbody")
                .data([d])
                .enter().append("tbody");
            var trowEnter = tbodyEnter.selectAll("tr")
                .data(function(p) { return p.series})
                .enter()
                .append("tr")
                .classed("highlight", function(p) { return p.highlight})
                ;

            trowEnter.append("td")
                .classed("legend-color-guide",true)
                .append("div")
                    .style("background-color", function(p) { return p.color});
            trowEnter.append("td")
                .classed("key",true)
                .html(function(p) {return p.key});
            trowEnter.append("td")
                .classed("value",true)
                .html(function(p,i) { return valueFormatter(p.value,i) });


            trowEnter.selectAll("td").each(function(p) {
                if (p.highlight) {
                    var opacityScale = d3.scale.linear().domain([0,1]).range(["#fff",p.color]);
                    var opacity = 0.6;
                    d3.select(this)
                        .style("border-bottom-color", opacityScale(opacity))
                        .style("border-top-color", opacityScale(opacity))
                        ;
                }
            });

            var html = table.node().outerHTML;
            if (d.footer !== undefined)
                html += "<div class='footer'>" + d.footer + "</div>";
            return html;

        };

        var dataSeriesExists = function(d) {
            if (d && d.series && d.series.length > 0) return true;

            return false;
        };

        //In situations where the chart is in a 'viewBox', re-position the tooltip based on how far chart is zoomed.
        function convertViewBoxRatio() {
            if (chartContainer) {
              var svg = d3.select(chartContainer);
              if (svg.node().tagName !== "svg") {
                 svg = svg.select("svg");
              }
              var viewBox = (svg.node()) ? svg.attr('viewBox') : null;
              if (viewBox) {
                viewBox = viewBox.split(' ');
                var ratio = parseInt(svg.style('width')) / viewBox[2];
                
                position.left = position.left * ratio;
                position.top  = position.top * ratio;
              }
            }
        }

        //Creates new tooltip container, or uses existing one on DOM.
        function getTooltipContainer(newContent) {
            var body;
            if (chartContainer)
                body = d3.select(chartContainer);
            else
                body = d3.select("body");

            var container = body.select(".nvtooltip");
            if (container.node() === null) {
                //Create new tooltip div if it doesn't exist on DOM.
                container = body.append("div")
                    .attr("class", "nvtooltip " + (classes? classes: "xy-tooltip"))
                    .attr("id",id)
                    ;
            }
        

            container.node().innerHTML = newContent;
            container.style("top",0).style("left",0).style("opacity",0);
            container.selectAll("div, table, td, tr").classed(nvPointerEventsClass,true)
            container.classed(nvPointerEventsClass,true);
            return container.node();
        }

        

        //Draw the tooltip onto the DOM.
        function nvtooltip() {
            if (!enabled) return;
            if (!dataSeriesExists(data)) return;

            convertViewBoxRatio();

            var left = position.left;
            var top = (fixedTop != null) ? fixedTop : position.top;
            var container = getTooltipContainer(contentGenerator(data));
            tooltipElem = container;
            if (chartContainer) {
                var svgComp = chartContainer.getElementsByTagName("svg")[0];
                var boundRect = (svgComp) ? svgComp.getBoundingClientRect() : chartContainer.getBoundingClientRect();
                var svgOffset = {left:0,top:0};
                if (svgComp) {
                    var svgBound = svgComp.getBoundingClientRect();
                    var chartBound = chartContainer.getBoundingClientRect();
                    var svgBoundTop = svgBound.top;
                    
                    //Defensive code. Sometimes, svgBoundTop can be a really negative
                    //  number, like -134254. That's a bug. 
                    //  If such a number is found, use zero instead. FireFox bug only
                    if (svgBoundTop < 0) {
                        var containerBound = chartContainer.getBoundingClientRect();
                        svgBoundTop = (Math.abs(svgBoundTop) > containerBound.height) ? 0 : svgBoundTop;
                    } 
                    svgOffset.top = Math.abs(svgBoundTop - chartBound.top);
                    svgOffset.left = Math.abs(svgBound.left - chartBound.left);
                }
                //If the parent container is an overflow <div> with scrollbars, subtract the scroll offsets.
                //You need to also add any offset between the <svg> element and its containing <div>
                //Finally, add any offset of the containing <div> on the whole page.
                left += chartContainer.offsetLeft + svgOffset.left - 2*chartContainer.scrollLeft;
                top += chartContainer.offsetTop + svgOffset.top - 2*chartContainer.scrollTop;
            }

            if (snapDistance && snapDistance > 0) {
                top = Math.floor(top/snapDistance) * snapDistance;
            }

            nv.tooltip.calcTooltipPosition([left,top], gravity, distance, container);
            return nvtooltip;
        };

        nvtooltip.nvPointerEventsClass = nvPointerEventsClass;
        
        nvtooltip.content = function(_) {
            if (!arguments.length) return content;
            content = _;
            return nvtooltip;
        };

        //Returns tooltipElem...not able to set it.
        nvtooltip.tooltipElem = function() {
            return tooltipElem;
        };

        nvtooltip.contentGenerator = function(_) {
            if (!arguments.length) return contentGenerator;
            if (typeof _ === 'function') {
                contentGenerator = _;
            }
            return nvtooltip;
        };

        nvtooltip.data = function(_) {
            if (!arguments.length) return data;
            data = _;
            return nvtooltip;
        };

        nvtooltip.gravity = function(_) {
            if (!arguments.length) return gravity;
            gravity = _;
            return nvtooltip;
        };

        nvtooltip.distance = function(_) {
            if (!arguments.length) return distance;
            distance = _;
            return nvtooltip;
        };

        nvtooltip.snapDistance = function(_) {
            if (!arguments.length) return snapDistance;
            snapDistance = _;
            return nvtooltip;
        };

        nvtooltip.classes = function(_) {
            if (!arguments.length) return classes;
            classes = _;
            return nvtooltip;
        };

        nvtooltip.chartContainer = function(_) {
            if (!arguments.length) return chartContainer;
            chartContainer = _;
            return nvtooltip;
        };

        nvtooltip.position = function(_) {
            if (!arguments.length) return position;
            position.left = (typeof _.left !== 'undefined') ? _.left : position.left;
            position.top = (typeof _.top !== 'undefined') ? _.top : position.top;
            return nvtooltip;
        };

        nvtooltip.fixedTop = function(_) {
            if (!arguments.length) return fixedTop;
            fixedTop = _;
            return nvtooltip;
        };

        nvtooltip.enabled = function(_) {
            if (!arguments.length) return enabled;
            enabled = _;
            return nvtooltip;
        };

        nvtooltip.valueFormatter = function(_) {
            if (!arguments.length) return valueFormatter;
            if (typeof _ === 'function') {
                valueFormatter = _;
            }
            return nvtooltip;
        };

        nvtooltip.headerFormatter = function(_) {
            if (!arguments.length) return headerFormatter;
            if (typeof _ === 'function') {
                headerFormatter = _;
            }
            return nvtooltip;
        };

        //id() is a read-only function. You can't use it to set the id.
        nvtooltip.id = function() {
            return id;
        };


        return nvtooltip;
  };


  //Original tooltip.show function. Kept for backward compatibility.
  // pos = [left,top]
  nv.tooltip.show = function(pos, content, gravity, dist, parentContainer, classes) {
      
        //Create new tooltip div if it doesn't exist on DOM.
        var   container = document.createElement('div');
        container.className = 'nvtooltip ' + (classes ? classes : 'xy-tooltip');

        var body = parentContainer;
        if ( !parentContainer || parentContainer.tagName.match(/g|svg/i)) {
            //If the parent element is an SVG element, place tooltip in the <body> element.
            body = document.getElementsByTagName('body')[0];
        }
   
        container.style.left = 0;
        container.style.top = 0;
        container.style.opacity = 0;
        container.innerHTML = content;
        body.appendChild(container);
        
        //If the parent container is an overflow <div> with scrollbars, subtract the scroll offsets.
        if (parentContainer) {
           pos[0] = pos[0] - parentContainer.scrollLeft;
           pos[1] = pos[1] - parentContainer.scrollTop;
        }
        nv.tooltip.calcTooltipPosition(pos, gravity, dist, container);
  };

  //Looks up the ancestry of a DOM element, and returns the first NON-svg node.
  nv.tooltip.findFirstNonSVGParent = function(Elem) {
            while(Elem.tagName.match(/^g|svg$/i) !== null) {
                Elem = Elem.parentNode;
            }
            return Elem;
  };

  //Finds the total offsetTop of a given DOM element.
  //Looks up the entire ancestry of an element, up to the first relatively positioned element.
  nv.tooltip.findTotalOffsetTop = function ( Elem, initialTop ) {
                var offsetTop = initialTop;
                
                do {
                    if( !isNaN( Elem.offsetTop ) ) {
                        offsetTop += (Elem.offsetTop);
                    }
                } while( Elem = Elem.offsetParent );
                return offsetTop;
  };

  //Finds the total offsetLeft of a given DOM element.
  //Looks up the entire ancestry of an element, up to the first relatively positioned element.
  nv.tooltip.findTotalOffsetLeft = function ( Elem, initialLeft) {
                var offsetLeft = initialLeft;
                
                do {
                    if( !isNaN( Elem.offsetLeft ) ) {
                        offsetLeft += (Elem.offsetLeft);
                    }
                } while( Elem = Elem.offsetParent );
                return offsetLeft;
  };

  //Global utility function to render a tooltip on the DOM.
  //pos = [left,top] coordinates of where to place the tooltip, relative to the SVG chart container.
  //gravity = how to orient the tooltip
  //dist = how far away from the mouse to place tooltip
  //container = tooltip DIV
  nv.tooltip.calcTooltipPosition = function(pos, gravity, dist, container) {

            var height = parseInt(container.offsetHeight),
                width = parseInt(container.offsetWidth),
                windowWidth = nv.utils.windowSize().width,
                windowHeight = nv.utils.windowSize().height,
                scrollTop = window.pageYOffset,
                scrollLeft = window.pageXOffset,
                left, top;

            windowHeight = window.innerWidth >= document.body.scrollWidth ? windowHeight : windowHeight - 16;
            windowWidth = window.innerHeight >= document.body.scrollHeight ? windowWidth : windowWidth - 16;

            gravity = gravity || 's';
            dist = dist || 20;

            var tooltipTop = function ( Elem ) {
                return nv.tooltip.findTotalOffsetTop(Elem, top);
            };

            var tooltipLeft = function ( Elem ) {
                return nv.tooltip.findTotalOffsetLeft(Elem,left);
            };

            switch (gravity) {
              case 'e':
                left = pos[0] - width - dist;
                top = pos[1] - (height / 2);
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft < scrollLeft) left = pos[0] + dist > scrollLeft ? pos[0] + dist : scrollLeft - tLeft + left;
                if (tTop < scrollTop) top = scrollTop - tTop + top;
                if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;
                break;
              case 'w':
                left = pos[0] + dist;
                top = pos[1] - (height / 2);
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft + width > windowWidth) left = pos[0] - width - dist;
                if (tTop < scrollTop) top = scrollTop + 5;
                if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;
                break;
              case 'n':
                left = pos[0] - (width / 2) - 5;
                top = pos[1] + dist;
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft < scrollLeft) left = scrollLeft + 5;
                if (tLeft + width > windowWidth) left = left - width/2 + 5;
                if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;
                break;
              case 's':
                left = pos[0] - (width / 2);
                top = pos[1] - height - dist;
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft < scrollLeft) left = scrollLeft + 5;
                if (tLeft + width > windowWidth) left = left - width/2 + 5;
                if (scrollTop > tTop) top = scrollTop;
                break;
              case 'none':
                left = pos[0];
                top = pos[1] - dist;
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                break;
            }


            container.style.left = left+'px';
            container.style.top = top+'px';
            container.style.opacity = 1;
            container.style.position = 'absolute'; 

            return container;
    };

    //Global utility function to remove tooltips from the DOM.
    nv.tooltip.cleanup = function() {

              // Find the tooltips, mark them for removal by this class (so others cleanups won't find it)
              var tooltips = document.getElementsByClassName('nvtooltip');
              var purging = [];
              while(tooltips.length) {
                purging.push(tooltips[0]);
                tooltips[0].style.transitionDelay = '0 !important';
                tooltips[0].style.opacity = 0;
                tooltips[0].className = 'nvtooltip-pending-removal';
              }

              setTimeout(function() {

                  while (purging.length) {
                     var removeMe = purging.pop();
                      removeMe.parentNode.removeChild(removeMe);
                  }
            }, 500);
    };

})();

nv.utils.windowSize = function() {
    // Sane defaults
    var size = {width: 640, height: 480};

    // Earlier IE uses Doc.body
    if (document.body && document.body.offsetWidth) {
        size.width = document.body.offsetWidth;
        size.height = document.body.offsetHeight;
    }

    // IE can use depending on mode it is in
    if (document.compatMode=='CSS1Compat' &&
        document.documentElement &&
        document.documentElement.offsetWidth ) {
        size.width = document.documentElement.offsetWidth;
        size.height = document.documentElement.offsetHeight;
    }

    // Most recent browsers use
    if (window.innerWidth && window.innerHeight) {
        size.width = window.innerWidth;
        size.height = window.innerHeight;
    }
    return (size);
};



// Easy way to bind multiple functions to window.onresize
// TODO: give a way to remove a function after its bound, other than removing all of them
nv.utils.windowResize = function(fun){
  if (fun === undefined) return;
  var oldresize = window.onresize;

  window.onresize = function(e) {
    if (typeof oldresize == 'function') oldresize(e);
    fun(e);
  }
}

// Backwards compatible way to implement more d3-like coloring of graphs.
// If passed an array, wrap it in a function which implements the old default
// behavior
nv.utils.getColor = function(color) {
    if (!arguments.length) return nv.utils.defaultColor(); //if you pass in nothing, get default colors back

    if( Object.prototype.toString.call( color ) === '[object Array]' )
        return function(d, i) { return d.color || color[i % color.length]; };
    else
        return color;
        //can't really help it if someone passes rubbish as color
}

// Default color chooser uses the index of an object as before.
nv.utils.defaultColor = function() {
    var colors = d3.scale.category20().range();
    return function(d, i) { return d.color || colors[i % colors.length] };
}


// Returns a color function that takes the result of 'getKey' for each series and
// looks for a corresponding color from the dictionary,
nv.utils.customTheme = function(dictionary, getKey, defaultColors) {
  getKey = getKey || function(series) { return series.key }; // use default series.key if getKey is undefined
  defaultColors = defaultColors || d3.scale.category20().range(); //default color function

  var defIndex = defaultColors.length; //current default color (going in reverse)

  return function(series, index) {
    var key = getKey(series);

    if (!defIndex) defIndex = defaultColors.length; //used all the default colors, start over

    if (typeof dictionary[key] !== "undefined")
      return (typeof dictionary[key] === "function") ? dictionary[key]() : dictionary[key];
    else
      return defaultColors[--defIndex]; // no match in dictionary, use default color
  }
}



// From the PJAX example on d3js.org, while this is not really directly needed
// it's a very cool method for doing pjax, I may expand upon it a little bit,
// open to suggestions on anything that may be useful
nv.utils.pjax = function(links, content) {
  d3.selectAll(links).on("click", function() {
    history.pushState(this.href, this.textContent, this.href);
    load(this.href);
    d3.event.preventDefault();
  });

  function load(href) {
    d3.html(href, function(fragment) {
      var target = d3.select(content).node();
      target.parentNode.replaceChild(d3.select(fragment).select(content).node(), target);
      nv.utils.pjax(links, content);
    });
  }

  d3.select(window).on("popstate", function() {
    if (d3.event.state) load(d3.event.state);
  });
}

/* For situations where we want to approximate the width in pixels for an SVG:text element.
Most common instance is when the element is in a display:none; container.
Forumla is : text.length * font-size * constant_factor
*/
nv.utils.calcApproxTextWidth = function (svgTextElem) {
    if (typeof svgTextElem.style === 'function'
        && typeof svgTextElem.text === 'function') {
        var fontSize = parseInt(svgTextElem.style("font-size").replace("px",""));
        var textLength = svgTextElem.text().length;

        return textLength * fontSize * 0.5;
    }
    return 0;
};

/* Numbers that are undefined, null or NaN, convert them to zeros.
*/
nv.utils.NaNtoZero = function(n) {
    if (typeof n !== 'number'
        || isNaN(n)
        || n === null
        || n === Infinity) return 0;

    return n;
};

/*
Snippet of code you can insert into each nv.models.* to give you the ability to
do things like:
chart.options({
  showXAxis: true,
  tooltips: true
});

To enable in the chart:
chart.options = nv.utils.optionsFunc.bind(chart);
*/
nv.utils.optionsFunc = function(args) {
    if (args) {
      d3.map(args).forEach((function(key,value) {
        if (typeof this[key] === "function") {
           this[key](value);
        }
      }).bind(this));
    }
    return this;
};nv.models.axis = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var axis = d3.svg.axis()
    ;

  var margin = {top: 0, right: 0, bottom: 0, left: 0}
    , width = 75 //only used for tickLabel currently
    , height = 60 //only used for tickLabel currently
    , scale = d3.scale.linear()
    , axisLabelText = null
    , showMaxMin = true //TODO: showMaxMin should be disabled on all ordinal scaled axes
    , highlightZero = true
    , rotateLabels = 0
    , rotateYLabel = true
    , staggerLabels = false
    , isOrdinal = false
    , ticks = null
    , axisLabelDistance = 12 //The larger this number is, the closer the axis label is to the axis.
    ;

  axis
    .scale(scale)
    .orient('bottom')
    .tickFormat(function(d) { return d })
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var scale0;

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this);


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-axis').data([data]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-axis');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g')

      //------------------------------------------------------------


      if (ticks !== null)
        axis.ticks(ticks);
      else if (axis.orient() == 'top' || axis.orient() == 'bottom')
        axis.ticks(Math.abs(scale.range()[1] - scale.range()[0]) / 100);


      //TODO: consider calculating width/height based on whether or not label is added, for reference in charts using this component


      g.transition().call(axis);

      scale0 = scale0 || axis.scale();

      var fmt = axis.tickFormat();
      if (fmt == null) {
        fmt = scale0.tickFormat();
      }

      var axisLabel = g.selectAll('text.nv-axislabel')
          .data([axisLabelText || null]);
      axisLabel.exit().remove();
      switch (axis.orient()) {
        case 'top':
          axisLabel.enter().append('text').attr('class', 'nv-axislabel');
          var w = (scale.range().length==2) ? scale.range()[1] : (scale.range()[scale.range().length-1]+(scale.range()[1]-scale.range()[0]));
          axisLabel
              .attr('text-anchor', 'middle')
              .attr('y', 0)
              .attr('x', w/2);
          if (showMaxMin) {
            var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                           .data(scale.domain());
            axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text');
            axisMaxMin.exit().remove();
            axisMaxMin
                .attr('transform', function(d,i) {
                  return 'translate(' + scale(d) + ',0)'
                })
              .select('text')
                .attr('dy', '-0.5em')
                .attr('y', -axis.tickPadding())
                .attr('text-anchor', 'middle')
                .text(function(d,i) {
                  var v = fmt(d);
                  return ('' + v).match('NaN') ? '' : v;
                });
            axisMaxMin.transition()
                .attr('transform', function(d,i) {
                  return 'translate(' + scale.range()[i] + ',0)'
                });
          }
          break;
        case 'bottom':
          var xLabelMargin = 36;
          var maxTextWidth = 30;
          var xTicks = g.selectAll('g').select("text");
          if (rotateLabels%360) {
            //Calculate the longest xTick width
            xTicks.each(function(d,i){
              var width = this.getBBox().width;
              if(width > maxTextWidth) maxTextWidth = width;
            });
            //Convert to radians before calculating sin. Add 30 to margin for healthy padding.
            var sin = Math.abs(Math.sin(rotateLabels*Math.PI/180));
            var xLabelMargin = (sin ? sin*maxTextWidth : maxTextWidth)+30;
            //Rotate all xTicks
            xTicks
              .attr('transform', function(d,i,j) { return 'rotate(' + rotateLabels + ' 0,0)' })
              .style('text-anchor', rotateLabels%360 > 0 ? 'start' : 'end');
          }
          axisLabel.enter().append('text').attr('class', 'nv-axislabel');
          var w = (scale.range().length==2) ? scale.range()[1] : (scale.range()[scale.range().length-1]+(scale.range()[1]-scale.range()[0]));
          axisLabel
              .attr('text-anchor', 'middle')
              .attr('y', xLabelMargin)
              .attr('x', w/2);
          if (showMaxMin) {
          //if (showMaxMin && !isOrdinal) {
            var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                           //.data(scale.domain())
                           .data([scale.domain()[0], scale.domain()[scale.domain().length - 1]]);
            axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text');
            axisMaxMin.exit().remove();
            axisMaxMin
                .attr('transform', function(d,i) {
                  return 'translate(' + (scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0)) + ',0)'
                })
              .select('text')
                .attr('dy', '.71em')
                .attr('y', axis.tickPadding())
                .attr('transform', function(d,i,j) { return 'rotate(' + rotateLabels + ' 0,0)' })
                .style('text-anchor', rotateLabels ? (rotateLabels%360 > 0 ? 'start' : 'end') : 'middle')
                .text(function(d,i) {
                  var v = fmt(d);
                  return ('' + v).match('NaN') ? '' : v;
                });
            axisMaxMin.transition()
                .attr('transform', function(d,i) {
                  //return 'translate(' + scale.range()[i] + ',0)'
                  //return 'translate(' + scale(d) + ',0)'
                  return 'translate(' + (scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0)) + ',0)'
                });
          }
          if (staggerLabels)
            xTicks
                .attr('transform', function(d,i) { return 'translate(0,' + (i % 2 == 0 ? '0' : '12') + ')' });

          break;
        case 'right':
          axisLabel.enter().append('text').attr('class', 'nv-axislabel');
          axisLabel
              .style('text-anchor', rotateYLabel ? 'middle' : 'begin')
              .attr('transform', rotateYLabel ? 'rotate(90)' : '')
              .attr('y', rotateYLabel ? (-Math.max(margin.right,width) + 12) : -10) //TODO: consider calculating this based on largest tick width... OR at least expose this on chart
              .attr('x', rotateYLabel ? (scale.range()[0] / 2) : axis.tickPadding());
          if (showMaxMin) {
            var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                           .data(scale.domain());
            axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text')
                .style('opacity', 0);
            axisMaxMin.exit().remove();
            axisMaxMin
                .attr('transform', function(d,i) {
                  return 'translate(0,' + scale(d) + ')'
                })
              .select('text')
                .attr('dy', '.32em')
                .attr('y', 0)
                .attr('x', axis.tickPadding())
                .style('text-anchor', 'start')
                .text(function(d,i) {
                  var v = fmt(d);
                  return ('' + v).match('NaN') ? '' : v;
                });
            axisMaxMin.transition()
                .attr('transform', function(d,i) {
                  return 'translate(0,' + scale.range()[i] + ')'
                })
              .select('text')
                .style('opacity', 1);
          }
          break;
        case 'left':
          /*
          //For dynamically placing the label. Can be used with dynamically-sized chart axis margins
          var yTicks = g.selectAll('g').select("text");
          yTicks.each(function(d,i){
            var labelPadding = this.getBBox().width + axis.tickPadding() + 16;
            if(labelPadding > width) width = labelPadding;
          });
          */
          axisLabel.enter().append('text').attr('class', 'nv-axislabel');
          axisLabel
              .style('text-anchor', rotateYLabel ? 'middle' : 'end')
              .attr('transform', rotateYLabel ? 'rotate(-90)' : '')
              .attr('y', rotateYLabel ? (-Math.max(margin.left,width) + axisLabelDistance) : -10) //TODO: consider calculating this based on largest tick width... OR at least expose this on chart
              .attr('x', rotateYLabel ? (-scale.range()[0] / 2) : -axis.tickPadding());
          if (showMaxMin) {
            var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                           .data(scale.domain());
            axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text')
                .style('opacity', 0);
            axisMaxMin.exit().remove();
            axisMaxMin
                .attr('transform', function(d,i) {
                  return 'translate(0,' + scale0(d) + ')'
                })
              .select('text')
                .attr('dy', '.32em')
                .attr('y', 0)
                .attr('x', -axis.tickPadding())
                .attr('text-anchor', 'end')
                .text(function(d,i) {
                  var v = fmt(d);
                  return ('' + v).match('NaN') ? '' : v;
                });
            axisMaxMin.transition()
                .attr('transform', function(d,i) {
                  return 'translate(0,' + scale.range()[i] + ')'
                })
              .select('text')
                .style('opacity', 1);
          }
          break;
      }
      axisLabel
          .text(function(d) { return d });


      if (showMaxMin && (axis.orient() === 'left' || axis.orient() === 'right')) {
        //check if max and min overlap other values, if so, hide the values that overlap
        g.selectAll('g') // the g's wrapping each tick
            .each(function(d,i) {
              d3.select(this).select('text').attr('opacity', 1);
              if (scale(d) < scale.range()[1] + 10 || scale(d) > scale.range()[0] - 10) { // 10 is assuming text height is 16... if d is 0, leave it!
                if (d > 1e-10 || d < -1e-10) // accounts for minor floating point errors... though could be problematic if the scale is EXTREMELY SMALL
                  d3.select(this).attr('opacity', 0);

                d3.select(this).select('text').attr('opacity', 0); // Don't remove the ZERO line!!
              }
            });

        //if Max and Min = 0 only show min, Issue #281
        if (scale.domain()[0] == scale.domain()[1] && scale.domain()[0] == 0)
          wrap.selectAll('g.nv-axisMaxMin')
            .style('opacity', function(d,i) { return !i ? 1 : 0 });

      }

      if (showMaxMin && (axis.orient() === 'top' || axis.orient() === 'bottom')) {
        var maxMinRange = [];
        wrap.selectAll('g.nv-axisMaxMin')
            .each(function(d,i) {
              try {
                  if (i) // i== 1, max position
                      maxMinRange.push(scale(d) - this.getBBox().width - 4)  //assuming the max and min labels are as wide as the next tick (with an extra 4 pixels just in case)
                  else // i==0, min position
                      maxMinRange.push(scale(d) + this.getBBox().width + 4)
              }catch (err) {
                  if (i) // i== 1, max position
                      maxMinRange.push(scale(d) - 4)  //assuming the max and min labels are as wide as the next tick (with an extra 4 pixels just in case)
                  else // i==0, min position
                      maxMinRange.push(scale(d) + 4)
              }
            });
        g.selectAll('g') // the g's wrapping each tick
            .each(function(d,i) {
              if (scale(d) < maxMinRange[0] || scale(d) > maxMinRange[1]) {
                if (d > 1e-10 || d < -1e-10) // accounts for minor floating point errors... though could be problematic if the scale is EXTREMELY SMALL
                  d3.select(this).remove();
                else
                  d3.select(this).select('text').remove(); // Don't remove the ZERO line!!
              }
            });
      }


      //highlight zero line ... Maybe should not be an option and should just be in CSS?
      if (highlightZero)
        g.selectAll('.tick')
          .filter(function(d) { return !parseFloat(Math.round(d.__data__*100000)/1000000) && (d.__data__ !== undefined) }) //this is because sometimes the 0 tick is a very small fraction, TODO: think of cleaner technique
            .classed('zero', true);

      //store old scales for use in transitions on update
      scale0 = scale.copy();

    });

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.axis = axis;

  d3.rebind(chart, axis, 'orient', 'tickValues', 'tickSubdivide', 'tickSize', 'tickPadding', 'tickFormat');
  d3.rebind(chart, scale, 'domain', 'range', 'rangeBand', 'rangeBands'); //these are also accessible by chart.scale(), but added common ones directly for ease of use

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.margin = function(_) {
    if(!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  }

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.ticks = function(_) {
    if (!arguments.length) return ticks;
    ticks = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.axisLabel = function(_) {
    if (!arguments.length) return axisLabelText;
    axisLabelText = _;
    return chart;
  }

  chart.showMaxMin = function(_) {
    if (!arguments.length) return showMaxMin;
    showMaxMin = _;
    return chart;
  }

  chart.highlightZero = function(_) {
    if (!arguments.length) return highlightZero;
    highlightZero = _;
    return chart;
  }

  chart.scale = function(_) {
    if (!arguments.length) return scale;
    scale = _;
    axis.scale(scale);
    isOrdinal = typeof scale.rangeBands === 'function';
    d3.rebind(chart, scale, 'domain', 'range', 'rangeBand', 'rangeBands');
    return chart;
  }

  chart.rotateYLabel = function(_) {
    if(!arguments.length) return rotateYLabel;
    rotateYLabel = _;
    return chart;
  }

  chart.rotateLabels = function(_) {
    if(!arguments.length) return rotateLabels;
    rotateLabels = _;
    return chart;
  }

  chart.staggerLabels = function(_) {
    if (!arguments.length) return staggerLabels;
    staggerLabels = _;
    return chart;
  };

  chart.axisLabelDistance = function(_) {
    if (!arguments.length) return axisLabelDistance;
    axisLabelDistance = _;
    return chart;
  };

  //============================================================


  return chart;
}
//TODO: consider deprecating and using multibar with single series for this
nv.models.historicalBar = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 0, right: 0, bottom: 0, left: 0}
    , width = 960
    , height = 500
    , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
    , x = d3.scale.linear()
    , y = d3.scale.linear()
    , getX = function(d) { return d.x }
    , getY = function(d) { return d.y }
    , forceX = []
    , forceY = [0]
    , padData = false
    , clipEdge = true
    , color = nv.utils.defaultColor()
    , xDomain
    , yDomain
    , xRange
    , yRange
    , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout')
    , interactive = true
    ;

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var availableWidth = width - margin.left - margin.right,
          availableHeight = height - margin.top - margin.bottom,
          container = d3.select(this);


      //------------------------------------------------------------
      // Setup Scales

      x   .domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX) ))

      if (padData)
        x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
      else
        x.range(xRange || [0, availableWidth]);

      y   .domain(yDomain || d3.extent(data[0].values.map(getY).concat(forceY) ))
          .range(yRange || [availableHeight, 0]);

      // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point

      if (x.domain()[0] === x.domain()[1])
        x.domain()[0] ?
            x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
          : x.domain([-1,1]);

      if (y.domain()[0] === y.domain()[1])
        y.domain()[0] ?
            y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
          : y.domain([-1,1]);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-historicalBar-' + id).data([data[0].values]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBar-' + id);
      var defsEnter = wrapEnter.append('defs');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-bars');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //------------------------------------------------------------


      container
          .on('click', function(d,i) {
            dispatch.chartClick({
                data: d,
                index: i,
                pos: d3.event,
                id: id
            });
          });


      defsEnter.append('clipPath')
          .attr('id', 'nv-chart-clip-path-' + id)
        .append('rect');

      wrap.select('#nv-chart-clip-path-' + id + ' rect')
          .attr('width', availableWidth)
          .attr('height', availableHeight);

      g   .attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');



      var bars = wrap.select('.nv-bars').selectAll('.nv-bar')
          .data(function(d) { return d }, function(d,i) {return getX(d,i)});

      bars.exit().remove();


      var barsEnter = bars.enter().append('rect')
          //.attr('class', function(d,i,j) { return (getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive') + ' nv-bar-' + j + '-' + i })
          .attr('x', 0 )
          .attr('y', function(d,i) {  return nv.utils.NaNtoZero(y(Math.max(0, getY(d,i)))) })
          .attr('height', function(d,i) { return nv.utils.NaNtoZero(Math.abs(y(getY(d,i)) - y(0))) })
          .attr('transform', function(d,i) { return 'translate(' + (x(getX(d,i)) - availableWidth / data[0].values.length * .45) + ',0)'; }) 
          .on('mouseover', function(d,i) {
            if (!interactive) return;
            d3.select(this).classed('hover', true);
            dispatch.elementMouseover({
                point: d,
                series: data[0],
                pos: [x(getX(d,i)), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
                pointIndex: i,
                seriesIndex: 0,
                e: d3.event
            });

          })
          .on('mouseout', function(d,i) {
                if (!interactive) return;
                d3.select(this).classed('hover', false);
                dispatch.elementMouseout({
                    point: d,
                    series: data[0],
                    pointIndex: i,
                    seriesIndex: 0,
                    e: d3.event
                });
          })
          .on('click', function(d,i) {
                if (!interactive) return;
                dispatch.elementClick({
                    //label: d[label],
                    value: getY(d,i),
                    data: d,
                    index: i,
                    pos: [x(getX(d,i)), y(getY(d,i))],
                    e: d3.event,
                    id: id
                });
              d3.event.stopPropagation();
          })
          .on('dblclick', function(d,i) {
              if (!interactive) return;
              dispatch.elementDblClick({
                  //label: d[label],
                  value: getY(d,i),
                  data: d,
                  index: i,
                  pos: [x(getX(d,i)), y(getY(d,i))],
                  e: d3.event,
                  id: id
              });
              d3.event.stopPropagation();
          });

      bars
          .attr('fill', function(d,i) { return color(d, i); })
          .attr('class', function(d,i,j) { return (getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive') + ' nv-bar-' + j + '-' + i })
          .transition()
          .attr('transform', function(d,i) { return 'translate(' + (x(getX(d,i)) - availableWidth / data[0].values.length * .45) + ',0)'; }) 
           //TODO: better width calculations that don't assume always uniform data spacing;w
          .attr('width', (availableWidth / data[0].values.length) * .9 );


      bars.transition()
          .attr('y', function(d,i) {
            var rval = getY(d,i) < 0 ?
                    y(0) :
                    y(0) - y(getY(d,i)) < 1 ?
                      y(0) - 1 :
                      y(getY(d,i));
            return nv.utils.NaNtoZero(rval);
          })
          .attr('height', function(d,i) { return nv.utils.NaNtoZero(Math.max(Math.abs(y(getY(d,i)) - y(0)),1)) });

    });

    return chart;
  }

  //Create methods to allow outside functions to highlight a specific bar.
  chart.highlightPoint = function(pointIndex, isHoverOver) {
      d3.select(".nv-historicalBar-" + id)
        .select(".nv-bars .nv-bar-0-" + pointIndex)
              .classed("hover", isHoverOver)
               ;
  };

  chart.clearHighlights = function() {
      d3.select(".nv-historicalBar-" + id)
        .select(".nv-bars .nv-bar.hover")
              .classed("hover", false)
               ;
  };
  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  chart.dispatch = dispatch;

  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = _;
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = _;
    return chart;
  };

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.xScale = function(_) {
    if (!arguments.length) return x;
    x = _;
    return chart;
  };

  chart.yScale = function(_) {
    if (!arguments.length) return y;
    y = _;
    return chart;
  };

  chart.xDomain = function(_) {
    if (!arguments.length) return xDomain;
    xDomain = _;
    return chart;
  };

  chart.yDomain = function(_) {
    if (!arguments.length) return yDomain;
    yDomain = _;
    return chart;
  };

  chart.xRange = function(_) {
    if (!arguments.length) return xRange;
    xRange = _;
    return chart;
  };

  chart.yRange = function(_) {
    if (!arguments.length) return yRange;
    yRange = _;
    return chart;
  };

  chart.forceX = function(_) {
    if (!arguments.length) return forceX;
    forceX = _;
    return chart;
  };

  chart.forceY = function(_) {
    if (!arguments.length) return forceY;
    forceY = _;
    return chart;
  };

  chart.padData = function(_) {
    if (!arguments.length) return padData;
    padData = _;
    return chart;
  };

  chart.clipEdge = function(_) {
    if (!arguments.length) return clipEdge;
    clipEdge = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    return chart;
  };

  chart.id = function(_) {
    if (!arguments.length) return id;
    id = _;
    return chart;
  };

  chart.interactive = function(_) {
    if(!arguments.length) return interactive;
    interactive = false;
    return chart;
  };

  //============================================================


  return chart;
}

// Chart design based on the recommendations of Stephen Few. Implementation
// based on the work of Clint Ivy, Jamie Love, and Jason Davies.
// http://projects.instantcognition.com/protovis/bulletchart/

nv.models.bullet = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 0, right: 0, bottom: 0, left: 0}
    , orient = 'left' // TODO top & bottom
    , reverse = false
    , ranges = function(d) { return d.ranges }
    , markers = function(d) { return d.markers }
    , measures = function(d) { return d.measures }
    , rangeLabels = function(d) { return d.rangeLabels ? d.rangeLabels : [] }
    , markerLabels = function(d) { return d.markerLabels ? d.markerLabels : []  }
    , measureLabels = function(d) { return d.measureLabels ? d.measureLabels : []  }
    , forceX = [0] // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)
    , width = 380
    , height = 30
    , tickFormat = null
    , color = nv.utils.getColor(['#1f77b4'])
    , dispatch = d3.dispatch('elementMouseover', 'elementMouseout')
    ;

  //============================================================


  function chart(selection) {
    selection.each(function(d, i) {
      var availableWidth = width - margin.left - margin.right,
          availableHeight = height - margin.top - margin.bottom,
          container = d3.select(this);

      var rangez = ranges.call(this, d, i).slice().sort(d3.descending),
          markerz = markers.call(this, d, i).slice().sort(d3.descending),
          measurez = measures.call(this, d, i).slice().sort(d3.descending),
          rangeLabelz = rangeLabels.call(this, d, i).slice(),
          markerLabelz = markerLabels.call(this, d, i).slice(),
          measureLabelz = measureLabels.call(this, d, i).slice();


      //------------------------------------------------------------
      // Setup Scales

      // Compute the new x-scale.
      var x1 = d3.scale.linear()
          .domain( d3.extent(d3.merge([forceX, rangez])) )
          .range(reverse ? [availableWidth, 0] : [0, availableWidth]);

      // Retrieve the old x-scale, if this is an update.
      var x0 = this.__chart__ || d3.scale.linear()
          .domain([0, Infinity])
          .range(x1.range());

      // Stash the new scale.
      this.__chart__ = x1;


      var rangeMin = d3.min(rangez), //rangez[2]
          rangeMax = d3.max(rangez), //rangez[0]
          rangeAvg = rangez[1];

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-bullet').data([d]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bullet');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      gEnter.append('rect').attr('class', 'nv-range nv-rangeMax');
      gEnter.append('rect').attr('class', 'nv-range nv-rangeAvg');
      gEnter.append('rect').attr('class', 'nv-range nv-rangeMin');
      gEnter.append('rect').attr('class', 'nv-measure');
      gEnter.append('path').attr('class', 'nv-markerTriangle');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //------------------------------------------------------------



      var w0 = function(d) { return Math.abs(x0(d) - x0(0)) }, // TODO: could optimize by precalculating x0(0) and x1(0)
          w1 = function(d) { return Math.abs(x1(d) - x1(0)) };
      var xp0 = function(d) { return d < 0 ? x0(d) : x0(0) },
          xp1 = function(d) { return d < 0 ? x1(d) : x1(0) };


      g.select('rect.nv-rangeMax')
          .attr('height', availableHeight)
          .attr('width', w1(rangeMax > 0 ? rangeMax : rangeMin))
          .attr('x', xp1(rangeMax > 0 ? rangeMax : rangeMin))
          .datum(rangeMax > 0 ? rangeMax : rangeMin)
          /*
          .attr('x', rangeMin < 0 ?
                         rangeMax > 0 ?
                             x1(rangeMin)
                           : x1(rangeMax)
                       : x1(0))
                      */

      g.select('rect.nv-rangeAvg')
          .attr('height', availableHeight)
          .attr('width', w1(rangeAvg))
          .attr('x', xp1(rangeAvg))
          .datum(rangeAvg)
          /*
          .attr('width', rangeMax <= 0 ?
                             x1(rangeMax) - x1(rangeAvg)
                           : x1(rangeAvg) - x1(rangeMin))
          .attr('x', rangeMax <= 0 ?
                         x1(rangeAvg)
                       : x1(rangeMin))
                      */

      g.select('rect.nv-rangeMin')
          .attr('height', availableHeight)
          .attr('width', w1(rangeMax))
          .attr('x', xp1(rangeMax))
          .attr('width', w1(rangeMax > 0 ? rangeMin : rangeMax))
          .attr('x', xp1(rangeMax > 0 ? rangeMin : rangeMax))
          .datum(rangeMax > 0 ? rangeMin : rangeMax)
          /*
          .attr('width', rangeMax <= 0 ?
                             x1(rangeAvg) - x1(rangeMin)
                           : x1(rangeMax) - x1(rangeAvg))
          .attr('x', rangeMax <= 0 ?
                         x1(rangeMin)
                       : x1(rangeAvg))
                      */

      g.select('rect.nv-measure')
          .style('fill', color)
          .attr('height', availableHeight / 3)
          .attr('y', availableHeight / 3)
          .attr('width', measurez < 0 ?
                             x1(0) - x1(measurez[0])
                           : x1(measurez[0]) - x1(0))
          .attr('x', xp1(measurez))
          .on('mouseover', function() {
              dispatch.elementMouseover({
                value: measurez[0],
                label: measureLabelz[0] || 'Current',
                pos: [x1(measurez[0]), availableHeight/2]
              })
          })
          .on('mouseout', function() {
              dispatch.elementMouseout({
                value: measurez[0],
                label: measureLabelz[0] || 'Current'
              })
          })

      var h3 =  availableHeight / 6;
      if (markerz[0]) {
        g.selectAll('path.nv-markerTriangle')
            .attr('transform', function(d) { return 'translate(' + x1(markerz[0]) + ',' + (availableHeight / 2) + ')' })
            .attr('d', 'M0,' + h3 + 'L' + h3 + ',' + (-h3) + ' ' + (-h3) + ',' + (-h3) + 'Z')
            .on('mouseover', function() {
              dispatch.elementMouseover({
                value: markerz[0],
                label: markerLabelz[0] || 'Previous',
                pos: [x1(markerz[0]), availableHeight/2]
              })
            })
            .on('mouseout', function() {
              dispatch.elementMouseout({
                value: markerz[0],
                label: markerLabelz[0] || 'Previous'
              })
            });
      } else {
        g.selectAll('path.nv-markerTriangle').remove();
      }


      wrap.selectAll('.nv-range')
          .on('mouseover', function(d,i) {
            var label = rangeLabelz[i] || (!i ? "Maximum" : i == 1 ? "Mean" : "Minimum");

            dispatch.elementMouseover({
              value: d,
              label: label,
              pos: [x1(d), availableHeight/2]
            })
          })
          .on('mouseout', function(d,i) {
            var label = rangeLabelz[i] || (!i ? "Maximum" : i == 1 ? "Mean" : "Minimum");

            dispatch.elementMouseout({
              value: d,
              label: label
            })
          })

/* // THIS IS THE PREVIOUS BULLET IMPLEMENTATION, WILL REMOVE SHORTLY
      // Update the range rects.
      var range = g.selectAll('rect.nv-range')
          .data(rangez);

      range.enter().append('rect')
          .attr('class', function(d, i) { return 'nv-range nv-s' + i; })
          .attr('width', w0)
          .attr('height', availableHeight)
          .attr('x', reverse ? x0 : 0)
          .on('mouseover', function(d,i) { 
              dispatch.elementMouseover({
                value: d,
                label: (i <= 0) ? 'Maximum' : (i > 1) ? 'Minimum' : 'Mean', //TODO: make these labels a variable
                pos: [x1(d), availableHeight/2]
              })
          })
          .on('mouseout', function(d,i) { 
              dispatch.elementMouseout({
                value: d,
                label: (i <= 0) ? 'Minimum' : (i >=1) ? 'Maximum' : 'Mean' //TODO: make these labels a variable
              })
          })

      d3.transition(range)
          .attr('x', reverse ? x1 : 0)
          .attr('width', w1)
          .attr('height', availableHeight);


      // Update the measure rects.
      var measure = g.selectAll('rect.nv-measure')
          .data(measurez);

      measure.enter().append('rect')
          .attr('class', function(d, i) { return 'nv-measure nv-s' + i; })
          .style('fill', function(d,i) { return color(d,i ) })
          .attr('width', w0)
          .attr('height', availableHeight / 3)
          .attr('x', reverse ? x0 : 0)
          .attr('y', availableHeight / 3)
          .on('mouseover', function(d) { 
              dispatch.elementMouseover({
                value: d,
                label: 'Current', //TODO: make these labels a variable
                pos: [x1(d), availableHeight/2]
              })
          })
          .on('mouseout', function(d) { 
              dispatch.elementMouseout({
                value: d,
                label: 'Current' //TODO: make these labels a variable
              })
          })

      d3.transition(measure)
          .attr('width', w1)
          .attr('height', availableHeight / 3)
          .attr('x', reverse ? x1 : 0)
          .attr('y', availableHeight / 3);



      // Update the marker lines.
      var marker = g.selectAll('path.nv-markerTriangle')
          .data(markerz);

      var h3 =  availableHeight / 6;
      marker.enter().append('path')
          .attr('class', 'nv-markerTriangle')
          .attr('transform', function(d) { return 'translate(' + x0(d) + ',' + (availableHeight / 2) + ')' })
          .attr('d', 'M0,' + h3 + 'L' + h3 + ',' + (-h3) + ' ' + (-h3) + ',' + (-h3) + 'Z')
          .on('mouseover', function(d,i) {
              dispatch.elementMouseover({
                value: d,
                label: 'Previous',
                pos: [x1(d), availableHeight/2]
              })
          })
          .on('mouseout', function(d,i) {
              dispatch.elementMouseout({
                value: d,
                label: 'Previous'
              })
          });

      d3.transition(marker)
          .attr('transform', function(d) { return 'translate(' + (x1(d) - x1(0)) + ',' + (availableHeight / 2) + ')' });

      marker.exit().remove();
*/

    });

    // d3.timer.flush();  // Not needed?

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  chart.dispatch = dispatch;

  chart.options = nv.utils.optionsFunc.bind(chart);
  
  // left, right, top, bottom
  chart.orient = function(_) {
    if (!arguments.length) return orient;
    orient = _;
    reverse = orient == 'right' || orient == 'bottom';
    return chart;
  };

  // ranges (bad, satisfactory, good)
  chart.ranges = function(_) {
    if (!arguments.length) return ranges;
    ranges = _;
    return chart;
  };

  // markers (previous, goal)
  chart.markers = function(_) {
    if (!arguments.length) return markers;
    markers = _;
    return chart;
  };

  // measures (actual, forecast)
  chart.measures = function(_) {
    if (!arguments.length) return measures;
    measures = _;
    return chart;
  };

  chart.forceX = function(_) {
    if (!arguments.length) return forceX;
    forceX = _;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.tickFormat = function(_) {
    if (!arguments.length) return tickFormat;
    tickFormat = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    return chart;
  };

  //============================================================


  return chart;
};



// Chart design based on the recommendations of Stephen Few. Implementation
// based on the work of Clint Ivy, Jamie Love, and Jason Davies.
// http://projects.instantcognition.com/protovis/bulletchart/
nv.models.bulletChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var bullet = nv.models.bullet()
    ;

  var orient = 'left' // TODO top & bottom
    , reverse = false
    , margin = {top: 5, right: 40, bottom: 20, left: 120}
    , ranges = function(d) { return d.ranges }
    , markers = function(d) { return d.markers }
    , measures = function(d) { return d.measures }
    , width = null
    , height = 55
    , tickFormat = null
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
        return '<h3>' + x + '</h3>' +
               '<p>' + y + '</p>'
      }
    , noData = 'No Data Available.'
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide')
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ) + margin.left,
        top = e.pos[1] + ( offsetElement.offsetTop || 0) + margin.top,
        content = tooltip(e.key, e.label, e.value, e, chart);

    nv.tooltip.show([left, top], content, e.value < 0 ? 'e' : 'w', null, offsetElement);
  };

  //============================================================


  function chart(selection) {
    selection.each(function(d, i) {
      var container = d3.select(this);

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = height - margin.top - margin.bottom,
          that = this;


      chart.update = function() { chart(selection) };
      chart.container = this;

      //------------------------------------------------------------
      // Display No Data message if there's nothing to show.

      if (!d || !ranges.call(this, d, i)) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', 18 + margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------



      var rangez = ranges.call(this, d, i).slice().sort(d3.descending),
          markerz = markers.call(this, d, i).slice().sort(d3.descending),
          measurez = measures.call(this, d, i).slice().sort(d3.descending);


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-bulletChart').data([d]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bulletChart');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-bulletWrap');
      gEnter.append('g').attr('class', 'nv-titles');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //------------------------------------------------------------


      // Compute the new x-scale.
      var x1 = d3.scale.linear()
          .domain([0, Math.max(rangez[0], markerz[0], measurez[0])])  // TODO: need to allow forceX and forceY, and xDomain, yDomain
          .range(reverse ? [availableWidth, 0] : [0, availableWidth]);

      // Retrieve the old x-scale, if this is an update.
      var x0 = this.__chart__ || d3.scale.linear()
          .domain([0, Infinity])
          .range(x1.range());

      // Stash the new scale.
      this.__chart__ = x1;

      /*
      // Derive width-scales from the x-scales.
      var w0 = bulletWidth(x0),
          w1 = bulletWidth(x1);

      function bulletWidth(x) {
        var x0 = x(0);
        return function(d) {
          return Math.abs(x(d) - x(0));
        };
      }

      function bulletTranslate(x) {
        return function(d) {
          return 'translate(' + x(d) + ',0)';
        };
      }
      */

      var w0 = function(d) { return Math.abs(x0(d) - x0(0)) }, // TODO: could optimize by precalculating x0(0) and x1(0)
          w1 = function(d) { return Math.abs(x1(d) - x1(0)) };


      var title = gEnter.select('.nv-titles').append('g')
          .attr('text-anchor', 'end')
          .attr('transform', 'translate(-6,' + (height - margin.top - margin.bottom) / 2 + ')');
      title.append('text')
          .attr('class', 'nv-title')
          .text(function(d) { return d.title; });

      title.append('text')
          .attr('class', 'nv-subtitle')
          .attr('dy', '1em')
          .text(function(d) { return d.subtitle; });



      bullet
        .width(availableWidth)
        .height(availableHeight)

      var bulletWrap = g.select('.nv-bulletWrap');

      d3.transition(bulletWrap).call(bullet);



      // Compute the tick format.
      var format = tickFormat || x1.tickFormat( availableWidth / 100 );

      // Update the tick groups.
      var tick = g.selectAll('g.nv-tick')
          .data(x1.ticks( availableWidth / 50 ), function(d) {
            return this.textContent || format(d);
          });

      // Initialize the ticks with the old scale, x0.
      var tickEnter = tick.enter().append('g')
          .attr('class', 'nv-tick')
          .attr('transform', function(d) { return 'translate(' + x0(d) + ',0)' })
          .style('opacity', 1e-6);

      tickEnter.append('line')
          .attr('y1', availableHeight)
          .attr('y2', availableHeight * 7 / 6);

      tickEnter.append('text')
          .attr('text-anchor', 'middle')
          .attr('dy', '1em')
          .attr('y', availableHeight * 7 / 6)
          .text(format);


      // Transition the updating ticks to the new scale, x1.
      var tickUpdate = d3.transition(tick)
          .attr('transform', function(d) { return 'translate(' + x1(d) + ',0)' })
          .style('opacity', 1);

      tickUpdate.select('line')
          .attr('y1', availableHeight)
          .attr('y2', availableHeight * 7 / 6);

      tickUpdate.select('text')
          .attr('y', availableHeight * 7 / 6);

      // Transition the exiting ticks to the new scale, x1.
      d3.transition(tick.exit())
          .attr('transform', function(d) { return 'translate(' + x1(d) + ',0)' })
          .style('opacity', 1e-6)
          .remove();


      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      dispatch.on('tooltipShow', function(e) {
        e.key = d.title;
        if (tooltips) showTooltip(e, that.parentNode);
      });

      //============================================================

    });

    d3.timer.flush();

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  bullet.dispatch.on('elementMouseover.tooltip', function(e) {
    dispatch.tooltipShow(e);
  });

  bullet.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  chart.dispatch = dispatch;
  chart.bullet = bullet;

  d3.rebind(chart, bullet, 'color');

  chart.options = nv.utils.optionsFunc.bind(chart);
  
  // left, right, top, bottom
  chart.orient = function(x) {
    if (!arguments.length) return orient;
    orient = x;
    reverse = orient == 'right' || orient == 'bottom';
    return chart;
  };

  // ranges (bad, satisfactory, good)
  chart.ranges = function(x) {
    if (!arguments.length) return ranges;
    ranges = x;
    return chart;
  };

  // markers (previous, goal)
  chart.markers = function(x) {
    if (!arguments.length) return markers;
    markers = x;
    return chart;
  };

  // measures (actual, forecast)
  chart.measures = function(x) {
    if (!arguments.length) return measures;
    measures = x;
    return chart;
  };

  chart.width = function(x) {
    if (!arguments.length) return width;
    width = x;
    return chart;
  };

  chart.height = function(x) {
    if (!arguments.length) return height;
    height = x;
    return chart;
  };

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.tickFormat = function(x) {
    if (!arguments.length) return tickFormat;
    tickFormat = x;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  //============================================================


  return chart;
};



nv.models.cumulativeLineChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var lines = nv.models.line()
    , xAxis = nv.models.axis()
    , yAxis = nv.models.axis()
    , legend = nv.models.legend()
    , controls = nv.models.legend()
    , interactiveLayer = nv.interactiveGuideline()
    ;

  var margin = {top: 30, right: 30, bottom: 50, left: 60}
    , color = nv.utils.defaultColor()
    , width = null
    , height = null
    , showLegend = true
    , showXAxis = true
    , showYAxis = true
    , rightAlignYAxis = false
    , tooltips = true
    , showControls = true
    , useInteractiveGuideline = false
    , rescaleY = true
    , tooltip = function(key, x, y, e, graph) {
        return '<h3>' + key + '</h3>' +
               '<p>' +  y + ' at ' + x + '</p>'
      }
    , x //can be accessed via chart.xScale()
    , y //can be accessed via chart.yScale()
    , id = lines.id()
    , state = { index: 0, rescaleY: rescaleY }
    , defaultState = null
    , noData = 'No Data Available.'
    , average = function(d) { return d.average }
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    , transitionDuration = 250
    , noErrorCheck = false  //if set to TRUE, will bypass an error check in the indexify function.
    ;

  xAxis
    .orient('bottom')
    .tickPadding(7)
    ;
  yAxis
    .orient((rightAlignYAxis) ? 'right' : 'left')
    ;

  //============================================================
  controls.updateState(false);

  //============================================================
  // Private Variables
  //------------------------------------------------------------

   var dx = d3.scale.linear()
     , index = {i: 0, x: 0}
     ;

  var showTooltip = function(e, offsetElement) {
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
        y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)),
        content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, null, null, offsetElement);
  };

  //============================================================

  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this).classed('nv-chart-' + id, true),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;


      chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
      chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });

      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }

      var indexDrag = d3.behavior.drag()
                        .on('dragstart', dragStart)
                        .on('drag', dragMove)
                        .on('dragend', dragEnd);


      function dragStart(d,i) {
        d3.select(chart.container)
            .style('cursor', 'ew-resize');
      }

      function dragMove(d,i) {
        index.x = d3.event.x;
        index.i = Math.round(dx.invert(index.x));
        updateZero();
      }

      function dragEnd(d,i) {
        d3.select(chart.container)
            .style('cursor', 'auto');

        // update state and send stateChange with new index
        state.index = index.i;
        dispatch.stateChange(state);
      }

      //------------------------------------------------------------
      // Display No Data message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x = lines.xScale();
      y = lines.yScale();


      if (!rescaleY) {
        var seriesDomains = data
          .filter(function(series) { return !series.disabled })
          .map(function(series,i) {
            var initialDomain = d3.extent(series.values, lines.y());

            //account for series being disabled when losing 95% or more
            if (initialDomain[0] < -.95) initialDomain[0] = -.95;

            return [
              (initialDomain[0] - initialDomain[1]) / (1 + initialDomain[1]),
              (initialDomain[1] - initialDomain[0]) / (1 + initialDomain[0])
            ];
          });

        var completeDomain = [
          d3.min(seriesDomains, function(d) { return d[0] }),
          d3.max(seriesDomains, function(d) { return d[1] })
        ]

        lines.yDomain(completeDomain);
      } else {
        lines.yDomain(null);
      }


      dx  .domain([0, data[0].values.length - 1]) //Assumes all series have same length
          .range([0, availableWidth])
          .clamp(true);

      //------------------------------------------------------------


      var data = indexify(index.i, data);


      //------------------------------------------------------------
      // Setup containers and skeleton of chart
      var interactivePointerEvents = (useInteractiveGuideline) ? "none" : "all";
      var wrap = container.selectAll('g.nv-wrap.nv-cumulativeLine').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-cumulativeLine').append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-interactive');
      gEnter.append('g').attr('class', 'nv-x nv-axis').style("pointer-events","none");
      gEnter.append('g').attr('class', 'nv-y nv-axis');
      gEnter.append('g').attr('class', 'nv-background');
      gEnter.append('g').attr('class', 'nv-linesWrap').style("pointer-events",interactivePointerEvents);
      gEnter.append('g').attr('class', 'nv-avgLinesWrap').style("pointer-events","none");
      gEnter.append('g').attr('class', 'nv-legendWrap');
      gEnter.append('g').attr('class', 'nv-controlsWrap');


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend.width(availableWidth);

        g.select('.nv-legendWrap')
            .datum(data)
            .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }

        g.select('.nv-legendWrap')
            .attr('transform', 'translate(0,' + (-margin.top) +')')
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Controls

      if (showControls) {
        var controlsData = [
          { key: 'Re-scale y-axis', disabled: !rescaleY }
        ];

        controls
            .width(140)
            .color(['#444', '#444', '#444'])
            .rightAlign(false)
            .margin({top: 5, right: 0, bottom: 5, left: 20})
            ;

        g.select('.nv-controlsWrap')
            .datum(controlsData)
            .attr('transform', 'translate(0,' + (-margin.top) +')')
            .call(controls);
      }

      //------------------------------------------------------------


      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      if (rightAlignYAxis) {
          g.select(".nv-y.nv-axis")
              .attr("transform", "translate(" + availableWidth + ",0)");
      }

      // Show error if series goes below 100%
      var tempDisabled = data.filter(function(d) { return d.tempDisabled });

      wrap.select('.tempDisabled').remove(); //clean-up and prevent duplicates
      if (tempDisabled.length) {
        wrap.append('text').attr('class', 'tempDisabled')
            .attr('x', availableWidth / 2)
            .attr('y', '-.71em')
            .style('text-anchor', 'end')
            .text(tempDisabled.map(function(d) { return d.key }).join(', ') + ' values cannot be calculated for this time period.');
      }

      //------------------------------------------------------------
      // Main Chart Component(s)

      //------------------------------------------------------------
      //Set up interactive layer
      if (useInteractiveGuideline) {
        interactiveLayer
          .width(availableWidth)
          .height(availableHeight)
          .margin({left:margin.left,top:margin.top})
          .svgContainer(container)
          .xScale(x);
        wrap.select(".nv-interactive").call(interactiveLayer);
      }

      gEnter.select('.nv-background')
        .append('rect');

      g.select('.nv-background rect')
          .attr('width', availableWidth)
          .attr('height', availableHeight);

      lines
        //.x(function(d) { return d.x })
        .y(function(d) { return d.display.y })
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled && !data[i].tempDisabled; }));



      var linesWrap = g.select('.nv-linesWrap')
          .datum(data.filter(function(d) { return  !d.disabled && !d.tempDisabled }));

      //d3.transition(linesWrap).call(lines);
      linesWrap.call(lines);

      /*Handle average lines [AN-612] ----------------------------*/

      //Store a series index number in the data array.
      data.forEach(function(d,i) {
            d.seriesIndex = i;
      });

      var avgLineData = data.filter(function(d) {
          return !d.disabled && !!average(d);
      });

      var avgLines = g.select(".nv-avgLinesWrap").selectAll("line")
              .data(avgLineData, function(d) { return d.key; });

      var getAvgLineY = function(d) {
          //If average lines go off the svg element, clamp them to the svg bounds.
          var yVal = y(average(d));
          if (yVal < 0) return 0;
          if (yVal > availableHeight) return availableHeight;
          return yVal;
      };

      avgLines.enter()
              .append('line')
              .style('stroke-width',2)
              .style('stroke-dasharray','10,10')
              .style('stroke',function (d,i) {
                  return lines.color()(d,d.seriesIndex);
              })
              .attr('x1',0)
              .attr('x2',availableWidth)
              .attr('y1', getAvgLineY)
              .attr('y2', getAvgLineY);

      avgLines
              .style('stroke-opacity',function(d){
                  //If average lines go offscreen, make them transparent
                  var yVal = y(average(d));
                  if (yVal < 0 || yVal > availableHeight) return 0;
                  return 1;
              })
              .attr('x1',0)
              .attr('x2',availableWidth)
              .attr('y1', getAvgLineY)
              .attr('y2', getAvgLineY);

      avgLines.exit().remove();

      //Create index line -----------------------------------------

      var indexLine = linesWrap.selectAll('.nv-indexLine')
          .data([index]);
      indexLine.enter().append('rect').attr('class', 'nv-indexLine')
          .attr('width', 3)
          .attr('x', -2)
          .attr('fill', 'red')
          .attr('fill-opacity', .5)
          .style("pointer-events","all")
          .call(indexDrag)

      indexLine
          .attr('transform', function(d) { return 'translate(' + dx(d.i) + ',0)' })
          .attr('height', availableHeight)

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Axes

      if (showXAxis) {
        xAxis
          .scale(x)
          //Suggest how many ticks based on the chart width and D3 should listen (70 is the optimal number for MM/DD/YY dates)
          .ticks( Math.min(data[0].values.length,availableWidth/70) )
          .tickSize(-availableHeight, 0);

        g.select('.nv-x.nv-axis')
            .attr('transform', 'translate(0,' + y.range()[0] + ')');
        d3.transition(g.select('.nv-x.nv-axis'))
            .call(xAxis);
      }


      if (showYAxis) {
        yAxis
          .scale(y)
          .ticks( availableHeight / 36 )
          .tickSize( -availableWidth, 0);

        d3.transition(g.select('.nv-y.nv-axis'))
            .call(yAxis);
      }
      //------------------------------------------------------------


      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------


      function updateZero() {
        indexLine
          .data([index]);

        //When dragging the index line, turn off line transitions.
        // Then turn them back on when done dragging.
        var oldDuration = chart.transitionDuration();
        chart.transitionDuration(0);
        chart.update();
        chart.transitionDuration(oldDuration);
      }

      g.select('.nv-background rect')
          .on('click', function() {
            index.x = d3.mouse(this)[0];
            index.i = Math.round(dx.invert(index.x));

            // update state and send stateChange with new index
            state.index = index.i;
            dispatch.stateChange(state);

            updateZero();
          });

      lines.dispatch.on('elementClick', function(e) {
        index.i = e.pointIndex;
        index.x = dx(index.i);

        // update state and send stateChange with new index
        state.index = index.i;
        dispatch.stateChange(state);

        updateZero();
      });

      controls.dispatch.on('legendClick', function(d,i) {
        d.disabled = !d.disabled;
        rescaleY = !d.disabled;

        state.rescaleY = rescaleY;
        dispatch.stateChange(state);
        chart.update();
      });


      legend.dispatch.on('stateChange', function(newState) {
        state.disabled = newState.disabled;
        dispatch.stateChange(state);
        chart.update();
      });

      interactiveLayer.dispatch.on('elementMousemove', function(e) {
          lines.clearHighlights();
          var singlePoint, pointIndex, pointXLocation, allData = [];


          data
          .filter(function(series, i) {
            series.seriesIndex = i;
            return !series.disabled;
          })
          .forEach(function(series,i) {
              pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
              lines.highlightPoint(i, pointIndex, true);
              var point = series.values[pointIndex];
              if (typeof point === 'undefined') return;
              if (typeof singlePoint === 'undefined') singlePoint = point;
              if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
              allData.push({
                  key: series.key,
                  value: chart.y()(point, pointIndex),
                  color: color(series,series.seriesIndex)
              });
          });

          //Highlight the tooltip entry based on which point the mouse is closest to.
          if (allData.length > 2) {
            var yValue = chart.yScale().invert(e.mouseY);
            var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
            var threshold = 0.03 * domainExtent;
            var indexToHighlight = nv.nearestValueIndex(allData.map(function(d){return d.value}),yValue,threshold);
            if (indexToHighlight !== null)
              allData[indexToHighlight].highlight = true;
          }

          var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex), pointIndex);
          interactiveLayer.tooltip
                  .position({left: pointXLocation + margin.left, top: e.mouseY + margin.top})
                  .chartContainer(that.parentNode)
                  .enabled(tooltips)
                  .valueFormatter(function(d,i) {
                     return yAxis.tickFormat()(d);
                  })
                  .data(
                      {
                        value: xValue,
                        series: allData
                      }
                  )();

          interactiveLayer.renderGuideLine(pointXLocation);

      });

      interactiveLayer.dispatch.on("elementMouseout",function(e) {
          dispatch.tooltipHide();
          lines.clearHighlights();
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode);
      });


      // Update chart from a state object passed to event handler
      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined') {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }


        if (typeof e.index !== 'undefined') {
          index.i = e.index;
          index.x = dx(index.i);

          state.index = e.index;

          indexLine
            .data([index]);
        }


        if (typeof e.rescaleY !== 'undefined') {
          rescaleY = e.rescaleY;
        }

        chart.update();
      });

      //============================================================

    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  lines.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  lines.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.lines = lines;
  chart.legend = legend;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;
  chart.interactiveLayer = interactiveLayer;

  d3.rebind(chart, lines, 'defined', 'isArea', 'x', 'y', 'xScale','yScale', 'size', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'interactive', 'clipEdge', 'clipVoronoi','useVoronoi',  'id');

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    return chart;
  };

  chart.rescaleY = function(_) {
    if (!arguments.length) return rescaleY;
    rescaleY = _;
    return chart;
  };

  chart.showControls = function(_) {
    if (!arguments.length) return showControls;
    showControls = _;
    return chart;
  };

  chart.useInteractiveGuideline = function(_) {
    if(!arguments.length) return useInteractiveGuideline;
    useInteractiveGuideline = _;
    if (_ === true) {
       chart.interactive(false);
       chart.useVoronoi(false);
    }
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.showXAxis = function(_) {
    if (!arguments.length) return showXAxis;
    showXAxis = _;
    return chart;
  };

  chart.showYAxis = function(_) {
    if (!arguments.length) return showYAxis;
    showYAxis = _;
    return chart;
  };

  chart.rightAlignYAxis = function(_) {
    if(!arguments.length) return rightAlignYAxis;
    rightAlignYAxis = _;
    yAxis.orient( (_) ? 'right' : 'left');
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.average = function(_) {
     if(!arguments.length) return average;
     average = _;
     return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };

  chart.noErrorCheck = function(_) {
    if (!arguments.length) return noErrorCheck;
    noErrorCheck = _;
    return chart;
  };

  //============================================================


  //============================================================
  // Functions
  //------------------------------------------------------------

  /* Normalize the data according to an index point. */
  function indexify(idx, data) {
    return data.map(function(line, i) {
      if (!line.values) {
         return line;
      }
      var v = lines.y()(line.values[idx], idx);

      //TODO: implement check below, and disable series if series loses 100% or more cause divide by 0 issue
      if (v < -.95 && !noErrorCheck) {
        //if a series loses more than 100%, calculations fail.. anything close can cause major distortion (but is mathematically correct till it hits 100)

        line.tempDisabled = true;
        return line;
      }

      line.tempDisabled = false;

      line.values = line.values.map(function(point, pointIndex) {
        point.display = {'y': (lines.y()(point, pointIndex) - v) / (1 + v) };
        return point;
      })

      return line;
    })
  }

  //============================================================


  return chart;
}
//TODO: consider deprecating by adding necessary features to multiBar model
nv.models.discreteBar = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 0, right: 0, bottom: 0, left: 0}
    , width = 960
    , height = 500
    , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
    , x = d3.scale.ordinal()
    , y = d3.scale.linear()
    , getX = function(d) { return d.x }
    , getY = function(d) { return d.y }
    , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove
    , color = nv.utils.defaultColor()
    , showValues = false
    , valueFormat = d3.format(',.2f')
    , xDomain
    , yDomain
    , xRange
    , yRange
    , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout')
    , rectClass = 'discreteBar'
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var x0, y0;

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var availableWidth = width - margin.left - margin.right,
          availableHeight = height - margin.top - margin.bottom,
          container = d3.select(this);


      //add series index to each data point for reference
      data.forEach(function(series, i) {
        series.values.forEach(function(point) {
          point.series = i;
        });
      });


      //------------------------------------------------------------
      // Setup Scales

      // remap and flatten the data for use in calculating the scales' domains
      var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate
            data.map(function(d) {
              return d.values.map(function(d,i) {
                return { x: getX(d,i), y: getY(d,i), y0: d.y0 }
              })
            });

      x   .domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))
          .rangeBands(xRange || [0, availableWidth], .1);

      y   .domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return d.y }).concat(forceY)));


      // If showValues, pad the Y axis range to account for label height
      if (showValues) y.range(yRange || [availableHeight - (y.domain()[0] < 0 ? 12 : 0), y.domain()[1] > 0 ? 12 : 0]);
      else y.range(yRange || [availableHeight, 0]);

      //store old scales if they exist
      x0 = x0 || x;
      y0 = y0 || y.copy().range([y(0),y(0)]);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-discretebar').data([data]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discretebar');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-groups');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //------------------------------------------------------------



      //TODO: by definition, the discrete bar should not have multiple groups, will modify/remove later
      var groups = wrap.select('.nv-groups').selectAll('.nv-group')
          .data(function(d) { return d }, function(d) { return d.key });
      groups.enter().append('g')
          .style('stroke-opacity', 1e-6)
          .style('fill-opacity', 1e-6);
      groups.exit()
          .transition()
          .style('stroke-opacity', 1e-6)
          .style('fill-opacity', 1e-6)
          .remove();
      groups
          .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
          .classed('hover', function(d) { return d.hover });
      groups
          .transition()
          .style('stroke-opacity', 1)
          .style('fill-opacity', .75);


      var bars = groups.selectAll('g.nv-bar')
          .data(function(d) { return d.values });

      bars.exit().remove();


      var barsEnter = bars.enter().append('g')
          .attr('transform', function(d,i,j) {
              return 'translate(' + (x(getX(d,i)) + x.rangeBand() * .05 ) + ', ' + y(0) + ')'
          })
          .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here
            d3.select(this).classed('hover', true);
            dispatch.elementMouseover({
              value: getY(d,i),
              point: d,
              series: data[d.series],
              pos: [x(getX(d,i)) + (x.rangeBand() * (d.series + .5) / data.length), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
              pointIndex: i,
              seriesIndex: d.series,
              e: d3.event
            });
          })
          .on('mouseout', function(d,i) {
            d3.select(this).classed('hover', false);
            dispatch.elementMouseout({
              value: getY(d,i),
              point: d,
              series: data[d.series],
              pointIndex: i,
              seriesIndex: d.series,
              e: d3.event
            });
          })
          .on('click', function(d,i) {
            dispatch.elementClick({
              value: getY(d,i),
              point: d,
              series: data[d.series],
              pos: [x(getX(d,i)) + (x.rangeBand() * (d.series + .5) / data.length), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
              pointIndex: i,
              seriesIndex: d.series,
              e: d3.event
            });
            d3.event.stopPropagation();
          })
          .on('dblclick', function(d,i) {
            dispatch.elementDblClick({
              value: getY(d,i),
              point: d,
              series: data[d.series],
              pos: [x(getX(d,i)) + (x.rangeBand() * (d.series + .5) / data.length), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
              pointIndex: i,
              seriesIndex: d.series,
              e: d3.event
            });
            d3.event.stopPropagation();
          });

      barsEnter.append('rect')
          .attr('height', 0)
          .attr('width', x.rangeBand() * .9 / data.length )

      if (showValues) {
        barsEnter.append('text')
          .attr('text-anchor', 'middle')
          ;

        bars.select('text')
          .text(function(d,i) { return valueFormat(getY(d,i)) })
          .transition()
          .attr('x', x.rangeBand() * .9 / 2)
          .attr('y', function(d,i) { return getY(d,i) < 0 ? y(getY(d,i)) - y(0) + 12 : -4 })

          ;
      } else {
        bars.selectAll('text').remove();
      }

      bars
          .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive' })
          .style('fill', function(d,i) { return d.color || color(d,i) })
          .style('stroke', function(d,i) { return d.color || color(d,i) })
        .select('rect')
          .attr('class', rectClass)
          .transition()
          .attr('width', x.rangeBand() * .9 / data.length);
      bars.transition()
        //.delay(function(d,i) { return i * 1200 / data[0].values.length })
          .attr('transform', function(d,i) {
            var left = x(getX(d,i)) + x.rangeBand() * .05,
                top = getY(d,i) < 0 ?
                        y(0) :
                        y(0) - y(getY(d,i)) < 1 ?
                          y(0) - 1 : //make 1 px positive bars show up above y=0
                          y(getY(d,i));

              return 'translate(' + left + ', ' + top + ')'
          })
        .select('rect')
          .attr('height', function(d,i) {
            return  Math.max(Math.abs(y(getY(d,i)) - y((yDomain && yDomain[0]) || 0)) || 1)
          });


      //store old scales for use in transitions on update
      x0 = x.copy();
      y0 = y.copy();

    });

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  chart.dispatch = dispatch;

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = _;
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = _;
    return chart;
  };

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.xScale = function(_) {
    if (!arguments.length) return x;
    x = _;
    return chart;
  };

  chart.yScale = function(_) {
    if (!arguments.length) return y;
    y = _;
    return chart;
  };

  chart.xDomain = function(_) {
    if (!arguments.length) return xDomain;
    xDomain = _;
    return chart;
  };

  chart.yDomain = function(_) {
    if (!arguments.length) return yDomain;
    yDomain = _;
    return chart;
  };

  chart.xRange = function(_) {
    if (!arguments.length) return xRange;
    xRange = _;
    return chart;
  };

  chart.yRange = function(_) {
    if (!arguments.length) return yRange;
    yRange = _;
    return chart;
  };

  chart.forceY = function(_) {
    if (!arguments.length) return forceY;
    forceY = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    return chart;
  };

  chart.id = function(_) {
    if (!arguments.length) return id;
    id = _;
    return chart;
  };

  chart.showValues = function(_) {
    if (!arguments.length) return showValues;
    showValues = _;
    return chart;
  };

  chart.valueFormat= function(_) {
    if (!arguments.length) return valueFormat;
    valueFormat = _;
    return chart;
  };

  chart.rectClass= function(_) {
    if (!arguments.length) return rectClass;
    rectClass = _;
    return chart;
  };
  //============================================================


  return chart;
}

nv.models.discreteBarChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var discretebar = nv.models.discreteBar()
    , xAxis = nv.models.axis()
    , yAxis = nv.models.axis()
    ;

  var margin = {top: 15, right: 10, bottom: 50, left: 60}
    , width = null
    , height = null
    , color = nv.utils.getColor()
    , showXAxis = true
    , showYAxis = true
    , rightAlignYAxis = false
    , staggerLabels = false
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
        return '<h3>' + x + '</h3>' +
               '<p>' +  y + '</p>'
      }
    , x
    , y
    , noData = "No Data Available."
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'beforeUpdate')
    , transitionDuration = 250
    ;

  xAxis
    .orient('bottom')
    .highlightZero(false)
    .showMaxMin(false)
    .tickFormat(function(d) { return d })
    ;
  yAxis
    .orient((rightAlignYAxis) ? 'right' : 'left')
    .tickFormat(d3.format(',.1f'))
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        x = xAxis.tickFormat()(discretebar.x()(e.point, e.pointIndex)),
        y = yAxis.tickFormat()(discretebar.y()(e.point, e.pointIndex)),
        content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
  };

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;


      chart.update = function() { 
        dispatch.beforeUpdate(); 
        container.transition().duration(transitionDuration).call(chart); 
      };
      chart.container = this;


      //------------------------------------------------------------
      // Display No Data message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x = discretebar.xScale();
      y = discretebar.yScale().clamp(true);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-discreteBarWithAxes').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discreteBarWithAxes').append('g');
      var defsEnter = gEnter.append('defs');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-x nv-axis');
      gEnter.append('g').attr('class', 'nv-y nv-axis')
            .append('g').attr('class', 'nv-zeroLine')
            .append('line');
        
      gEnter.append('g').attr('class', 'nv-barsWrap');

      g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      if (rightAlignYAxis) {
          g.select(".nv-y.nv-axis")
              .attr("transform", "translate(" + availableWidth + ",0)");
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Main Chart Component(s)

      discretebar
        .width(availableWidth)
        .height(availableHeight);


      var barsWrap = g.select('.nv-barsWrap')
          .datum(data.filter(function(d) { return !d.disabled }))

      barsWrap.transition().call(discretebar);

      //------------------------------------------------------------



      defsEnter.append('clipPath')
          .attr('id', 'nv-x-label-clip-' + discretebar.id())
        .append('rect');

      g.select('#nv-x-label-clip-' + discretebar.id() + ' rect')
          .attr('width', x.rangeBand() * (staggerLabels ? 2 : 1))
          .attr('height', 16)
          .attr('x', -x.rangeBand() / (staggerLabels ? 1 : 2 ));


      //------------------------------------------------------------
      // Setup Axes

      if (showXAxis) {
          xAxis
            .scale(x)
            .ticks( availableWidth / 100 )
            .tickSize(-availableHeight, 0);

          g.select('.nv-x.nv-axis')
              .attr('transform', 'translate(0,' + (y.range()[0] + ((discretebar.showValues() && y.domain()[0] < 0) ? 16 : 0)) + ')');
          //d3.transition(g.select('.nv-x.nv-axis'))
          g.select('.nv-x.nv-axis').transition()
              .call(xAxis);


          var xTicks = g.select('.nv-x.nv-axis').selectAll('g');

          if (staggerLabels) {
            xTicks
                .selectAll('text')
                .attr('transform', function(d,i,j) { return 'translate(0,' + (j % 2 == 0 ? '5' : '17') + ')' })
          }
      }

      if (showYAxis) {
          yAxis
            .scale(y)
            .ticks( availableHeight / 36 )
            .tickSize( -availableWidth, 0);

          g.select('.nv-y.nv-axis').transition()
              .call(yAxis);
      }

      // Zero line
      g.select(".nv-zeroLine line")
        .attr("x1",0)
        .attr("x2",availableWidth)
        .attr("y1", y(0))
        .attr("y2", y(0))
        ;

      //------------------------------------------------------------


      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode);
      });

      //============================================================


    });

    return chart;
  }

  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  discretebar.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  discretebar.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.discretebar = discretebar;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;

  d3.rebind(chart, discretebar, 'x', 'y', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'id', 'showValues', 'valueFormat');

  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    discretebar.color(color);
    return chart;
  };

  chart.showXAxis = function(_) {
    if (!arguments.length) return showXAxis;
    showXAxis = _;
    return chart;
  };

  chart.showYAxis = function(_) {
    if (!arguments.length) return showYAxis;
    showYAxis = _;
    return chart;
  };

  chart.rightAlignYAxis = function(_) {
    if(!arguments.length) return rightAlignYAxis;
    rightAlignYAxis = _;
    yAxis.orient( (_) ? 'right' : 'left');
    return chart;
  };

  chart.staggerLabels = function(_) {
    if (!arguments.length) return staggerLabels;
    staggerLabels = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.distribution = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 0, right: 0, bottom: 0, left: 0}
    , width = 400 //technically width or height depending on x or y....
    , size = 8
    , axis = 'x' // 'x' or 'y'... horizontal or vertical
    , getData = function(d) { return d[axis] }  // defaults d.x or d.y
    , color = nv.utils.defaultColor()
    , scale = d3.scale.linear()
    , domain
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var scale0;

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var availableLength = width - (axis === 'x' ? margin.left + margin.right : margin.top + margin.bottom),
          naxis = axis == 'x' ? 'y' : 'x',
          container = d3.select(this);


      //------------------------------------------------------------
      // Setup Scales

      scale0 = scale0 || scale;

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-distribution').data([data]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-distribution');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

      //------------------------------------------------------------


      var distWrap = g.selectAll('g.nv-dist')
          .data(function(d) { return d }, function(d) { return d.key });

      distWrap.enter().append('g');
      distWrap
          .attr('class', function(d,i) { return 'nv-dist nv-series-' + i })
          .style('stroke', function(d,i) { return color(d, i) });

      var dist = distWrap.selectAll('line.nv-dist' + axis)
          .data(function(d) { return d.values })
      dist.enter().append('line')
          .attr(axis + '1', function(d,i) { return scale0(getData(d,i)) })
          .attr(axis + '2', function(d,i) { return scale0(getData(d,i)) })
      distWrap.exit().selectAll('line.nv-dist' + axis)
          .transition()
          .attr(axis + '1', function(d,i) { return scale(getData(d,i)) })
          .attr(axis + '2', function(d,i) { return scale(getData(d,i)) })
          .style('stroke-opacity', 0)
          .remove();
      dist
          .attr('class', function(d,i) { return 'nv-dist' + axis + ' nv-dist' + axis + '-' + i })
          .attr(naxis + '1', 0)
          .attr(naxis + '2', size);
      dist
          .transition()
          .attr(axis + '1', function(d,i) { return scale(getData(d,i)) })
          .attr(axis + '2', function(d,i) { return scale(getData(d,i)) })


      scale0 = scale.copy();

    });

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------
  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.axis = function(_) {
    if (!arguments.length) return axis;
    axis = _;
    return chart;
  };

  chart.size = function(_) {
    if (!arguments.length) return size;
    size = _;
    return chart;
  };

  chart.getData = function(_) {
    if (!arguments.length) return getData;
    getData = d3.functor(_);
    return chart;
  };

  chart.scale = function(_) {
    if (!arguments.length) return scale;
    scale = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    return chart;
  };
  //============================================================


  return chart;
}

nv.models.historicalBarChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var bars = nv.models.historicalBar()
    , xAxis = nv.models.axis()
    , yAxis = nv.models.axis()
    , legend = nv.models.legend()
    ;


  var margin = {top: 30, right: 90, bottom: 50, left: 90}
    , color = nv.utils.defaultColor()
    , width = null
    , height = null
    , showLegend = false
    , showXAxis = true
    , showYAxis = true
    , rightAlignYAxis = false
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
        return '<h3>' + key + '</h3>' +
               '<p>' +  y + ' at ' + x + '</p>'
      }
    , x
    , y
    , state = {}
    , defaultState = null
    , noData = 'No Data Available.'
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    , transitionDuration = 250
    ;

  xAxis
    .orient('bottom')
    .tickPadding(7)
    ;
  yAxis
    .orient( (rightAlignYAxis) ? 'right' : 'left')
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {

    // New addition to calculate position if SVG is scaled with viewBox, may move TODO: consider implementing everywhere else
    if (offsetElement) {
      var svg = d3.select(offsetElement).select('svg');
      var viewBox = (svg.node()) ? svg.attr('viewBox') : null;
      if (viewBox) {
        viewBox = viewBox.split(' ');
        var ratio = parseInt(svg.style('width')) / viewBox[2];
        e.pos[0] = e.pos[0] * ratio;
        e.pos[1] = e.pos[1] * ratio;
      }
    }

    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        x = xAxis.tickFormat()(bars.x()(e.point, e.pointIndex)),
        y = yAxis.tickFormat()(bars.y()(e.point, e.pointIndex)),
        content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, null, null, offsetElement);
  };

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;


      chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
      chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });

      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }

      //------------------------------------------------------------
      // Display noData message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x = bars.xScale();
      y = bars.yScale();

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-historicalBarChart').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBarChart').append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-x nv-axis');
      gEnter.append('g').attr('class', 'nv-y nv-axis');
      gEnter.append('g').attr('class', 'nv-barsWrap');
      gEnter.append('g').attr('class', 'nv-legendWrap');

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend.width(availableWidth);

        g.select('.nv-legendWrap')
            .datum(data)
            .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }

        wrap.select('.nv-legendWrap')
            .attr('transform', 'translate(0,' + (-margin.top) +')')
      }

      //------------------------------------------------------------

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      if (rightAlignYAxis) {
        g.select(".nv-y.nv-axis")
            .attr("transform", "translate(" + availableWidth + ",0)");
      }


      //------------------------------------------------------------
      // Main Chart Component(s)

      bars
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled }));


      var barsWrap = g.select('.nv-barsWrap')
          .datum(data.filter(function(d) { return !d.disabled }))

      barsWrap.transition().call(bars);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Axes

      if (showXAxis) {
        xAxis
          .scale(x)
          .tickSize(-availableHeight, 0);

        g.select('.nv-x.nv-axis')
            .attr('transform', 'translate(0,' + y.range()[0] + ')');
        g.select('.nv-x.nv-axis')
            .transition()
            .call(xAxis);
      }

      if (showYAxis) {
        yAxis
          .scale(y)
          .ticks( availableHeight / 36 )
          .tickSize( -availableWidth, 0);

        g.select('.nv-y.nv-axis')
          .transition()
            .call(yAxis);
      }
      //------------------------------------------------------------


      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      legend.dispatch.on('legendClick', function(d,i) {
        d.disabled = !d.disabled;

        if (!data.filter(function(d) { return !d.disabled }).length) {
          data.map(function(d) {
            d.disabled = false;
            wrap.selectAll('.nv-series').classed('disabled', false);
            return d;
          });
        }

        state.disabled = data.map(function(d) { return !!d.disabled });
        dispatch.stateChange(state);

        selection.transition().call(chart);
      });

      legend.dispatch.on('legendDblclick', function(d) {
          //Double clicking should always enable current series, and disabled all others.
          data.forEach(function(d) {
             d.disabled = true;
          });
          d.disabled = false;

          state.disabled = data.map(function(d) { return !!d.disabled });
          dispatch.stateChange(state);
          chart.update();
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode);
      });


      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined') {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }

        chart.update();
      });

      //============================================================

    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  bars.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  bars.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.bars = bars;
  chart.legend = legend;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;

  d3.rebind(chart, bars, 'defined', 'isArea', 'x', 'y', 'size', 'xScale', 'yScale',
    'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'interactive', 'clipEdge', 'clipVoronoi', 'id', 'interpolate','highlightPoint','clearHighlights', 'interactive');

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.showXAxis = function(_) {
    if (!arguments.length) return showXAxis;
    showXAxis = _;
    return chart;
  };

  chart.showYAxis = function(_) {
    if (!arguments.length) return showYAxis;
    showYAxis = _;
    return chart;
  };

  chart.rightAlignYAxis = function(_) {
    if(!arguments.length) return rightAlignYAxis;
    rightAlignYAxis = _;
    yAxis.orient( (_) ? 'right' : 'left');
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };

  //============================================================


  return chart;
}
nv.models.indentedTree = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 0, right: 0, bottom: 0, left: 0} //TODO: implement, maybe as margin on the containing div
    , width = 960
    , height = 500
    , color = nv.utils.defaultColor()
    , id = Math.floor(Math.random() * 10000)
    , header = true
    , filterZero = false
    , noData = "No Data Available."
    , childIndent = 20
    , columns = [{key:'key', label: 'Name', type:'text'}] //TODO: consider functions like chart.addColumn, chart.removeColumn, instead of a block like this
    , tableClass = null
    , iconOpen = 'images/grey-plus.png' //TODO: consider removing this and replacing with a '+' or '-' unless user defines images
    , iconClose = 'images/grey-minus.png'
    , dispatch = d3.dispatch('elementClick', 'elementDblclick', 'elementMouseover', 'elementMouseout')
    , getUrl = function(d) { return d.url }
    ;

  //============================================================

  var idx = 0;

  function chart(selection) {
    selection.each(function(data) {
      var depth = 1,
          container = d3.select(this);

      var tree = d3.layout.tree()
          .children(function(d) { return d.values })
          .size([height, childIndent]); //Not sure if this is needed now that the result is HTML

      chart.update = function() { container.transition().duration(600).call(chart) };


      //------------------------------------------------------------
      // Display No Data message if there's nothing to show.
      if (!data[0]) data[0] = {key: noData};

      //------------------------------------------------------------


      var nodes = tree.nodes(data[0]);

      // nodes.map(function(d) {
      //   d.id = i++;
      // })

      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = d3.select(this).selectAll('div').data([[nodes]]);
      var wrapEnter = wrap.enter().append('div').attr('class', 'nvd3 nv-wrap nv-indentedtree');
      var tableEnter = wrapEnter.append('table');
      var table = wrap.select('table').attr('width', '100%').attr('class', tableClass);

      //------------------------------------------------------------


      if (header) {
        var thead = tableEnter.append('thead');

        var theadRow1 = thead.append('tr');

        columns.forEach(function(column) {
          theadRow1
            .append('th')
              .attr('width', column.width ? column.width : '10%')
              .style('text-align', column.type == 'numeric' ? 'right' : 'left')
            .append('span')
              .text(column.label);
        });
      }


      var tbody = table.selectAll('tbody')
                    .data(function(d) { return d });
      tbody.enter().append('tbody');



      //compute max generations
      depth = d3.max(nodes, function(node) { return node.depth });
      tree.size([height, depth * childIndent]); //TODO: see if this is necessary at all


      // Update the nodes…
      var node = tbody.selectAll('tr')
          // .data(function(d) { return d; }, function(d) { return d.id || (d.id == ++i)});
          .data(function(d) { return d.filter(function(d) { return (filterZero && !d.children) ? filterZero(d) :  true; } )}, function(d,i) { return d.id || (d.id || ++idx)});
          //.style('display', 'table-row'); //TODO: see if this does anything

      node.exit().remove();

      node.select('img.nv-treeicon')
          .attr('src', icon)
          .classed('folded', folded);

      var nodeEnter = node.enter().append('tr');


      columns.forEach(function(column, index) {

        var nodeName = nodeEnter.append('td')
            .style('padding-left', function(d) { return (index ? 0 : d.depth * childIndent + 12 + (icon(d) ? 0 : 16)) + 'px' }, 'important') //TODO: check why I did the ternary here
            .style('text-align', column.type == 'numeric' ? 'right' : 'left');


        if (index == 0) {
          nodeName.append('img')
              .classed('nv-treeicon', true)
              .classed('nv-folded', folded)
              .attr('src', icon)
              .style('width', '14px')
              .style('height', '14px')
              .style('padding', '0 1px')
              .style('display', function(d) { return icon(d) ? 'inline-block' : 'none'; })
              .on('click', click);
        }


        nodeName.each(function(d) {
          if (!index && getUrl(d))
            d3.select(this)
              .append('a')
              .attr('href',getUrl)
              .attr('class', d3.functor(column.classes))
              .append('span')
          else
            d3.select(this)
              .append('span')

            d3.select(this).select('span')
              .attr('class', d3.functor(column.classes) )
              .text(function(d) { return column.format ? column.format(d) :
                                        (d[column.key] || '-') });
          });

        if  (column.showCount) {
          nodeName.append('span')
              .attr('class', 'nv-childrenCount');

          node.selectAll('span.nv-childrenCount').text(function(d) {
                return ((d.values && d.values.length) || (d._values && d._values.length)) ?                                   //If this is a parent
                    '(' + ((d.values && (d.values.filter(function(d) { return filterZero ? filterZero(d) :  true; }).length)) //If children are in values check its children and filter
                    || (d._values && d._values.filter(function(d) { return filterZero ? filterZero(d) :  true; }).length)     //Otherwise, do the same, but with the other name, _values...
                    || 0) + ')'                                                                                               //This is the catch-all in case there are no children after a filter
                    : ''                                                                                                     //If this is not a parent, just give an empty string
            });
        }

        // if (column.click)
        //   nodeName.select('span').on('click', column.click);

      });

      node
        .order()
        .on('click', function(d) { 
          dispatch.elementClick({
            row: this, //TODO: decide whether or not this should be consistent with scatter/line events or should be an html link (a href)
            data: d,
            pos: [d.x, d.y]
          });
        })
        .on('dblclick', function(d) { 
          dispatch.elementDblclick({
            row: this,
            data: d,
            pos: [d.x, d.y]
          });
        })
        .on('mouseover', function(d) { 
          dispatch.elementMouseover({
            row: this,
            data: d,
            pos: [d.x, d.y]
          });
        })
        .on('mouseout', function(d) { 
          dispatch.elementMouseout({
            row: this,
            data: d,
            pos: [d.x, d.y]
          });
        });




      // Toggle children on click.
      function click(d, _, unshift) {
        d3.event.stopPropagation();

        if(d3.event.shiftKey && !unshift) {
          //If you shift-click, it'll toggle fold all the children, instead of itself
          d3.event.shiftKey = false;
          d.values && d.values.forEach(function(node){
            if (node.values || node._values) {
              click(node, 0, true);
            }
          });
          return true;
        }
        if(!hasChildren(d)) {
          //download file
          //window.location.href = d.url;
          return true;
        }
        if (d.values) {
          d._values = d.values;
          d.values = null;
        } else {
          d.values = d._values;
          d._values = null;
        }
        chart.update();
      }


      function icon(d) {
        return (d._values && d._values.length) ? iconOpen : (d.values && d.values.length) ? iconClose : '';
      }

      function folded(d) {
        return (d._values && d._values.length);
      }

      function hasChildren(d) {
        var values = d.values || d._values;

        return (values && values.length);
      }


    });

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------
  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    scatter.color(color);
    return chart;
  };

  chart.id = function(_) {
    if (!arguments.length) return id;
    id = _;
    return chart;
  };

  chart.header = function(_) {
    if (!arguments.length) return header;
    header = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.filterZero = function(_) {
    if (!arguments.length) return filterZero;
    filterZero = _;
    return chart;
  };

  chart.columns = function(_) {
    if (!arguments.length) return columns;
    columns = _;
    return chart;
  };

  chart.tableClass = function(_) {
    if (!arguments.length) return tableClass;
    tableClass = _;
    return chart;
  };

  chart.iconOpen = function(_){
     if (!arguments.length) return iconOpen;
    iconOpen = _;
    return chart;
  }

  chart.iconClose = function(_){
     if (!arguments.length) return iconClose;
    iconClose = _;
    return chart;
  }

  chart.getUrl = function(_){
     if (!arguments.length) return getUrl;
    getUrl = _;
    return chart;
  }

  //============================================================


  return chart;
};nv.models.legend = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 5, right: 0, bottom: 5, left: 0}
    , width = 400
    , height = 20
    , getKey = function(d) { return d.key }
    , color = nv.utils.defaultColor()
    , align = true
    , rightAlign = true
    , updateState = true   //If true, legend will update data.disabled and trigger a 'stateChange' dispatch.
    , radioButtonMode = false   //If true, clicking legend items will cause it to behave like a radio button. (only one can be selected at a time)
    , dispatch = d3.dispatch('legendClick', 'legendDblclick', 'legendMouseover', 'legendMouseout', 'stateChange')
    ;

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var availableWidth = width - margin.left - margin.right,
          container = d3.select(this);


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-legend').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-legend').append('g');
      var g = wrap.select('g');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //------------------------------------------------------------


      var series = g.selectAll('.nv-series')
          .data(function(d) { return d });
      var seriesEnter = series.enter().append('g').attr('class', 'nv-series')
          .on('mouseover', function(d,i) {
            dispatch.legendMouseover(d,i);  //TODO: Make consistent with other event objects
          })
          .on('mouseout', function(d,i) {
            dispatch.legendMouseout(d,i);
          })
          .on('click', function(d,i) {
            dispatch.legendClick(d,i);
            if (updateState) {
               if (radioButtonMode) {
                   //Radio button mode: set every series to disabled,
                   //  and enable the clicked series.
                   data.forEach(function(series) { series.disabled = true});
                   d.disabled = false;
               }
               else {
                   d.disabled = !d.disabled;
                   if (data.every(function(series) { return series.disabled})) {
                       //the default behavior of NVD3 legends is, if every single series
                       // is disabled, turn all series' back on.
                       data.forEach(function(series) { series.disabled = false});
                   }
               }
               dispatch.stateChange({
                  disabled: data.map(function(d) { return !!d.disabled })
               });
            }
          })
          .on('dblclick', function(d,i) {
            dispatch.legendDblclick(d,i);
            if (updateState) {
                //the default behavior of NVD3 legends, when double clicking one,
                // is to set all other series' to false, and make the double clicked series enabled.
                data.forEach(function(series) {
                   series.disabled = true;
                });
                d.disabled = false;
                dispatch.stateChange({
                    disabled: data.map(function(d) { return !!d.disabled })
                });
            }
          });
      seriesEnter.append('circle')
          .style('stroke-width', 2)
          .attr('class','nv-legend-symbol')
          .attr('r', 5);
      seriesEnter.append('text')
          .attr('text-anchor', 'start')
          .attr('class','nv-legend-text')
          .attr('dy', '.32em')
          .attr('dx', '8');
      series.classed('disabled', function(d) { return d.disabled });
      series.exit().remove();
      series.select('circle')
          .style('fill', function(d,i) { return d.color || color(d,i)})
          .style('stroke', function(d,i) { return d.color || color(d, i) });
      series.select('text').text(getKey);


      //TODO: implement fixed-width and max-width options (max-width is especially useful with the align option)

      // NEW ALIGNING CODE, TODO: clean up
      if (align) {

        var seriesWidths = [];
        series.each(function(d,i) {
              var legendText = d3.select(this).select('text');
              var nodeTextLength;
              try {
                nodeTextLength = legendText.getComputedTextLength();
                // If the legendText is display:none'd (nodeTextLength == 0), simulate an error so we approximate, instead
                if(nodeTextLength <= 0) throw Error();
              }
              catch(e) {
                nodeTextLength = nv.utils.calcApproxTextWidth(legendText);
              }

              seriesWidths.push(nodeTextLength + 28); // 28 is ~ the width of the circle plus some padding
            });

        var seriesPerRow = 0;
        var legendWidth = 0;
        var columnWidths = [];

        while ( legendWidth < availableWidth && seriesPerRow < seriesWidths.length) {
          columnWidths[seriesPerRow] = seriesWidths[seriesPerRow];
          legendWidth += seriesWidths[seriesPerRow++];
        }
        if (seriesPerRow === 0) seriesPerRow = 1; //minimum of one series per row


        while ( legendWidth > availableWidth && seriesPerRow > 1 ) {
          columnWidths = [];
          seriesPerRow--;

          for (var k = 0; k < seriesWidths.length; k++) {
            if (seriesWidths[k] > (columnWidths[k % seriesPerRow] || 0) )
              columnWidths[k % seriesPerRow] = seriesWidths[k];
          }

          legendWidth = columnWidths.reduce(function(prev, cur, index, array) {
                          return prev + cur;
                        });
        }

        var xPositions = [];
        for (var i = 0, curX = 0; i < seriesPerRow; i++) {
            xPositions[i] = curX;
            curX += columnWidths[i];
        }

        series
            .attr('transform', function(d, i) {
              return 'translate(' + xPositions[i % seriesPerRow] + ',' + (5 + Math.floor(i / seriesPerRow) * 20) + ')';
            });

        //position legend as far right as possible within the total width
        if (rightAlign) {
           g.attr('transform', 'translate(' + (width - margin.right - legendWidth) + ',' + margin.top + ')');
        }
        else {
           g.attr('transform', 'translate(0' + ',' + margin.top + ')');
        }

        height = margin.top + margin.bottom + (Math.ceil(seriesWidths.length / seriesPerRow) * 20);

      } else {

        var ypos = 5,
            newxpos = 5,
            maxwidth = 0,
            xpos;
        series
            .attr('transform', function(d, i) {
              var length = d3.select(this).select('text').node().getComputedTextLength() + 28;
              xpos = newxpos;

              if (width < margin.left + margin.right + xpos + length) {
                newxpos = xpos = 5;
                ypos += 20;
              }

              newxpos += length;
              if (newxpos > maxwidth) maxwidth = newxpos;

              return 'translate(' + xpos + ',' + ypos + ')';
            });

        //position legend as far right as possible within the total width
        g.attr('transform', 'translate(' + (width - margin.right - maxwidth) + ',' + margin.top + ')');

        height = margin.top + margin.bottom + ypos + 15;

      }

    });

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  chart.dispatch = dispatch;
  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.key = function(_) {
    if (!arguments.length) return getKey;
    getKey = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    return chart;
  };

  chart.align = function(_) {
    if (!arguments.length) return align;
    align = _;
    return chart;
  };

  chart.rightAlign = function(_) {
    if (!arguments.length) return rightAlign;
    rightAlign = _;
    return chart;
  };

  chart.updateState = function(_) {
    if (!arguments.length) return updateState;
    updateState = _;
    return chart;
  };

  chart.radioButtonMode = function(_) {
    if (!arguments.length) return radioButtonMode;
    radioButtonMode = _;
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.line = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var  scatter = nv.models.scatter()
    ;

  var margin = {top: 0, right: 0, bottom: 0, left: 0}
    , width = 960
    , height = 500
    , color = nv.utils.defaultColor() // a function that returns a color
    , getX = function(d) { return d.x } // accessor to get the x value from a data point
    , getY = function(d) { return d.y } // accessor to get the y value from a data point
    , defined = function(d,i) { return !isNaN(getY(d,i)) && getY(d,i) !== null } // allows a line to be not continuous when it is not defined
    , isArea = function(d) { return d.area } // decides if a line is an area or just a line
    , clipEdge = false // if true, masks lines within x and y scale
    , x //can be accessed via chart.xScale()
    , y //can be accessed via chart.yScale()
    , interpolate = "linear" // controls the line interpolation
    ;

  scatter
    .size(16) // default size
    .sizeDomain([16,256]) //set to speed up calculation, needs to be unset if there is a custom size accessor
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var x0, y0 //used to store previous scales
      ;

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var availableWidth = width - margin.left - margin.right,
          availableHeight = height - margin.top - margin.bottom,
          container = d3.select(this);

      //------------------------------------------------------------
      // Setup Scales

      x = scatter.xScale();
      y = scatter.yScale();

      x0 = x0 || x;
      y0 = y0 || y;

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-line').data([data]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-line');
      var defsEnter = wrapEnter.append('defs');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g')

      gEnter.append('g').attr('class', 'nv-groups');
      gEnter.append('g').attr('class', 'nv-scatterWrap');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //------------------------------------------------------------




      scatter
        .width(availableWidth)
        .height(availableHeight)

      var scatterWrap = wrap.select('.nv-scatterWrap');
          //.datum(data); // Data automatically trickles down from the wrap

      scatterWrap.transition().call(scatter);



      defsEnter.append('clipPath')
          .attr('id', 'nv-edge-clip-' + scatter.id())
        .append('rect');

      wrap.select('#nv-edge-clip-' + scatter.id() + ' rect')
          .attr('width', availableWidth)
          .attr('height', (availableHeight > 0) ? availableHeight : 0);

      g   .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');
      scatterWrap
          .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');




      var groups = wrap.select('.nv-groups').selectAll('.nv-group')
          .data(function(d) { return d }, function(d) { return d.key });
      groups.enter().append('g')
          .style('stroke-opacity', 1e-6)
          .style('fill-opacity', 1e-6);

      groups.exit().remove();

      groups
          .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
          .classed('hover', function(d) { return d.hover })
          .style('fill', function(d,i){ return color(d, i) })
          .style('stroke', function(d,i){ return color(d, i)});
      groups
          .transition()
          .style('stroke-opacity', 1)
          .style('fill-opacity', .5);



      var areaPaths = groups.selectAll('path.nv-area')
          .data(function(d) { return isArea(d) ? [d] : [] }); // this is done differently than lines because I need to check if series is an area
      areaPaths.enter().append('path')
          .attr('class', 'nv-area')
          .attr('d', function(d) {
            return d3.svg.area()
                .interpolate(interpolate)
                .defined(defined)
                .x(function(d,i) { return nv.utils.NaNtoZero(x0(getX(d,i))) })
                .y0(function(d,i) { return nv.utils.NaNtoZero(y0(getY(d,i))) })
                .y1(function(d,i) { return y0( y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0] ) })
                //.y1(function(d,i) { return y0(0) }) //assuming 0 is within y domain.. may need to tweak this
                .apply(this, [d.values])
          });
      groups.exit().selectAll('path.nv-area')
           .remove();

      areaPaths
          .transition()
          .attr('d', function(d) {
            return d3.svg.area()
                .interpolate(interpolate)
                .defined(defined)
                .x(function(d,i) { return nv.utils.NaNtoZero(x(getX(d,i))) })
                .y0(function(d,i) { return nv.utils.NaNtoZero(y(getY(d,i))) })
                .y1(function(d,i) { return y( y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0] ) })
                //.y1(function(d,i) { return y0(0) }) //assuming 0 is within y domain.. may need to tweak this
                .apply(this, [d.values])
          });



      var linePaths = groups.selectAll('path.nv-line')
          .data(function(d) { return [d.values] });
      linePaths.enter().append('path')
          .attr('class', 'nv-line')
          .attr('d',
            d3.svg.line()
              .interpolate(interpolate)
              .defined(defined)
              .x(function(d,i) { return nv.utils.NaNtoZero(x0(getX(d,i))) })
              .y(function(d,i) { return nv.utils.NaNtoZero(y0(getY(d,i))) })
          );

      linePaths
          .transition()
          .attr('d',
            d3.svg.line()
              .interpolate(interpolate)
              .defined(defined)
              .x(function(d,i) { return nv.utils.NaNtoZero(x(getX(d,i))) })
              .y(function(d,i) { return nv.utils.NaNtoZero(y(getY(d,i))) })
          );



      //store old scales for use in transitions on update
      x0 = x.copy();
      y0 = y.copy();

    });

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  chart.dispatch = scatter.dispatch;
  chart.scatter = scatter;

  d3.rebind(chart, scatter, 'id', 'interactive', 'size', 'xScale', 'yScale', 'zScale', 'xDomain', 'yDomain', 'xRange', 'yRange',
    'sizeDomain', 'forceX', 'forceY', 'forceSize', 'clipVoronoi', 'useVoronoi', 'clipRadius', 'padData','highlightPoint','clearHighlights');

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = _;
    scatter.x(_);
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = _;
    scatter.y(_);
    return chart;
  };

  chart.clipEdge = function(_) {
    if (!arguments.length) return clipEdge;
    clipEdge = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    scatter.color(color);
    return chart;
  };

  chart.interpolate = function(_) {
    if (!arguments.length) return interpolate;
    interpolate = _;
    return chart;
  };

  chart.defined = function(_) {
    if (!arguments.length) return defined;
    defined = _;
    return chart;
  };

  chart.isArea = function(_) {
    if (!arguments.length) return isArea;
    isArea = d3.functor(_);
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.lineChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var lines = nv.models.line()
    , xAxis = nv.models.axis()
    , yAxis = nv.models.axis()
    , legend = nv.models.legend()
    , interactiveLayer = nv.interactiveGuideline()
    ;

  var margin = {top: 30, right: 20, bottom: 50, left: 60}
    , color = nv.utils.defaultColor()
    , width = null
    , height = null
    , showLegend = true
    , showXAxis = true
    , showYAxis = true
    , rightAlignYAxis = false
    , useInteractiveGuideline = false
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
        return '<h3>' + key + '</h3>' +
               '<p>' +  y + ' at ' + x + '</p>'
      }
    , x
    , y
    , state = {}
    , defaultState = null
    , noData = 'No Data Available.'
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    , transitionDuration = 250
    ;

  xAxis
    .orient('bottom')
    .tickPadding(7)
    ;
  yAxis
    .orient((rightAlignYAxis) ? 'right' : 'left')
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
        y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)),
        content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, null, null, offsetElement);
  };

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;


      chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
      chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });


      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }

      //------------------------------------------------------------
      // Display noData message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x = lines.xScale();
      y = lines.yScale();

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-lineChart').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineChart').append('g');
      var g = wrap.select('g');

      gEnter.append("rect").style("opacity",0);
      gEnter.append('g').attr('class', 'nv-x nv-axis');
      gEnter.append('g').attr('class', 'nv-y nv-axis');
      gEnter.append('g').attr('class', 'nv-linesWrap');
      gEnter.append('g').attr('class', 'nv-legendWrap');
      gEnter.append('g').attr('class', 'nv-interactive');

      g.select("rect")
        .attr("width",availableWidth)
        .attr("height",(availableHeight > 0) ? availableHeight : 0);
      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend.width(availableWidth);

        g.select('.nv-legendWrap')
            .datum(data)
            .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }

        wrap.select('.nv-legendWrap')
            .attr('transform', 'translate(0,' + (-margin.top) +')')
      }

      //------------------------------------------------------------

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      if (rightAlignYAxis) {
          g.select(".nv-y.nv-axis")
              .attr("transform", "translate(" + availableWidth + ",0)");
      }

      //------------------------------------------------------------
      // Main Chart Component(s)


      //------------------------------------------------------------
      //Set up interactive layer
      if (useInteractiveGuideline) {
        interactiveLayer
           .width(availableWidth)
           .height(availableHeight)
           .margin({left:margin.left, top:margin.top})
           .svgContainer(container)
           .xScale(x);
        wrap.select(".nv-interactive").call(interactiveLayer);
      }


      lines
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled }));


      var linesWrap = g.select('.nv-linesWrap')
          .datum(data.filter(function(d) { return !d.disabled }))

      linesWrap.transition().call(lines);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Axes

      if (showXAxis) {
        xAxis
          .scale(x)
          .ticks( availableWidth / 100 )
          .tickSize(-availableHeight, 0);

        g.select('.nv-x.nv-axis')
            .attr('transform', 'translate(0,' + y.range()[0] + ')');
        g.select('.nv-x.nv-axis')
            .transition()
            .call(xAxis);
      }

      if (showYAxis) {
        yAxis
          .scale(y)
          .ticks( availableHeight / 36 )
          .tickSize( -availableWidth, 0);

        g.select('.nv-y.nv-axis')
            .transition()
            .call(yAxis);
      }
      //------------------------------------------------------------


      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      legend.dispatch.on('stateChange', function(newState) {
          state = newState;
          dispatch.stateChange(state);
          chart.update();
      });

      interactiveLayer.dispatch.on('elementMousemove', function(e) {
          lines.clearHighlights();
          var singlePoint, pointIndex, pointXLocation, allData = [];
          data
          .filter(function(series, i) {
            series.seriesIndex = i;
            return !series.disabled;
          })
          .forEach(function(series,i) {
              pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
              lines.highlightPoint(i, pointIndex, true);
              var point = series.values[pointIndex];
              if (typeof point === 'undefined') return;
              if (typeof singlePoint === 'undefined') singlePoint = point;
              if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
              allData.push({
                  key: series.key,
                  value: chart.y()(point, pointIndex),
                  color: color(series,series.seriesIndex)
              });
          });
          //Highlight the tooltip entry based on which point the mouse is closest to.
          if (allData.length > 2) {
            var yValue = chart.yScale().invert(e.mouseY);
            var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
            var threshold = 0.03 * domainExtent;
            var indexToHighlight = nv.nearestValueIndex(allData.map(function(d){return d.value}),yValue,threshold);
            if (indexToHighlight !== null)
              allData[indexToHighlight].highlight = true;
          }

          var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex));
          interactiveLayer.tooltip
                  .position({left: pointXLocation + margin.left, top: e.mouseY + margin.top})
                  .chartContainer(that.parentNode)
                  .enabled(tooltips)
                  .valueFormatter(function(d,i) {
                     return yAxis.tickFormat()(d);
                  })
                  .data(
                      {
                        value: xValue,
                        series: allData
                      }
                  )();

          interactiveLayer.renderGuideLine(pointXLocation);

      });

      interactiveLayer.dispatch.on("elementMouseout",function(e) {
          dispatch.tooltipHide();
          lines.clearHighlights();
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode);
      });


      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }

        chart.update();
      });

      //============================================================

    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  lines.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  lines.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.lines = lines;
  chart.legend = legend;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;
  chart.interactiveLayer = interactiveLayer;

  d3.rebind(chart, lines, 'defined', 'isArea', 'x', 'y', 'size', 'xScale', 'yScale', 'xDomain', 'yDomain', 'xRange', 'yRange'
    , 'forceX', 'forceY', 'interactive', 'clipEdge', 'clipVoronoi', 'useVoronoi','id', 'interpolate');

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.showXAxis = function(_) {
    if (!arguments.length) return showXAxis;
    showXAxis = _;
    return chart;
  };

  chart.showYAxis = function(_) {
    if (!arguments.length) return showYAxis;
    showYAxis = _;
    return chart;
  };

  chart.rightAlignYAxis = function(_) {
    if(!arguments.length) return rightAlignYAxis;
    rightAlignYAxis = _;
    yAxis.orient( (_) ? 'right' : 'left');
    return chart;
  };

  chart.useInteractiveGuideline = function(_) {
    if(!arguments.length) return useInteractiveGuideline;
    useInteractiveGuideline = _;
    if (_ === true) {
       chart.interactive(false);
       chart.useVoronoi(false);
    }
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.linePlusBarChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var lines = nv.models.line()
    , bars = nv.models.historicalBar()
    , xAxis = nv.models.axis()
    , y1Axis = nv.models.axis()
    , y2Axis = nv.models.axis()
    , legend = nv.models.legend()
    ;

  var margin = {top: 30, right: 60, bottom: 50, left: 60}
    , width = null
    , height = null
    , getX = function(d) { return d.x }
    , getY = function(d) { return d.y }
    , color = nv.utils.defaultColor()
    , showLegend = true
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
        return '<h3>' + key + '</h3>' +
               '<p>' +  y + ' at ' + x + '</p>';
      }
    , x
    , y1
    , y2
    , state = {}
    , defaultState = null
    , noData = "No Data Available."
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    ;

  bars
    .padData(true)
    ;
  lines
    .clipEdge(false)
    .padData(true)
    ;
  xAxis
    .orient('bottom')
    .tickPadding(7)
    .highlightZero(false)
    ;
  y1Axis
    .orient('left')
    ;
  y2Axis
    .orient('right')
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
      var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
          top = e.pos[1] + ( offsetElement.offsetTop || 0),
          x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
          y = (e.series.bar ? y1Axis : y2Axis).tickFormat()(lines.y()(e.point, e.pointIndex)),
          content = tooltip(e.series.key, x, y, e, chart);

      nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    }
    ;

  //------------------------------------------------------------



  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;

      chart.update = function() { container.transition().call(chart); };
      // chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });

      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }

      //------------------------------------------------------------
      // Display No Data message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      var dataBars = data.filter(function(d) { return !d.disabled && d.bar });
      var dataLines = data.filter(function(d) { return !d.bar }); // removed the !d.disabled clause here to fix Issue #240

      //x = xAxis.scale();
       x = dataLines.filter(function(d) { return !d.disabled; }).length && dataLines.filter(function(d) { return !d.disabled; })[0].values.length ? lines.xScale() : bars.xScale();
      //x = dataLines.filter(function(d) { return !d.disabled; }).length ? lines.xScale() : bars.xScale(); //old code before change above
      y1 = bars.yScale();
      y2 = lines.yScale();

      //------------------------------------------------------------

      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = d3.select(this).selectAll('g.nv-wrap.nv-linePlusBar').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-linePlusBar').append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-x nv-axis');
      gEnter.append('g').attr('class', 'nv-y1 nv-axis');
      gEnter.append('g').attr('class', 'nv-y2 nv-axis');
      gEnter.append('g').attr('class', 'nv-barsWrap');
      gEnter.append('g').attr('class', 'nv-linesWrap');
      gEnter.append('g').attr('class', 'nv-legendWrap');

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend.width( availableWidth / 2 );

        g.select('.nv-legendWrap')
            .datum(data.map(function(series) {
              series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
              series.key = series.originalKey + (series.bar ? ' (left axis)' : ' (right axis)');
              return series;
            }))
          .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }

        g.select('.nv-legendWrap')
            .attr('transform', 'translate(' + ( availableWidth / 2 ) + ',' + (-margin.top) +')');
      }

      //------------------------------------------------------------


      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');


      //------------------------------------------------------------
      // Main Chart Component(s)


      lines
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled && !data[i].bar }))

      bars
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled && data[i].bar }))



      var barsWrap = g.select('.nv-barsWrap')
          .datum(dataBars.length ? dataBars : [{values:[]}])

      var linesWrap = g.select('.nv-linesWrap')
          .datum(dataLines[0] && !dataLines[0].disabled ? dataLines : [{values:[]}] );
          //.datum(!dataLines[0].disabled ? dataLines : [{values:dataLines[0].values.map(function(d) { return [d[0], null] }) }] );

      d3.transition(barsWrap).call(bars);
      d3.transition(linesWrap).call(lines);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Axes

      xAxis
        .scale(x)
        .ticks( availableWidth / 100 )
        .tickSize(-availableHeight, 0);

      g.select('.nv-x.nv-axis')
          .attr('transform', 'translate(0,' + y1.range()[0] + ')');
      d3.transition(g.select('.nv-x.nv-axis'))
          .call(xAxis);


      y1Axis
        .scale(y1)
        .ticks( availableHeight / 36 )
        .tickSize(-availableWidth, 0);

      d3.transition(g.select('.nv-y1.nv-axis'))
          .style('opacity', dataBars.length ? 1 : 0)
          .call(y1Axis);


      y2Axis
        .scale(y2)
        .ticks( availableHeight / 36 )
        .tickSize(dataBars.length ? 0 : -availableWidth, 0); // Show the y2 rules only if y1 has none

      g.select('.nv-y2.nv-axis')
          .style('opacity', dataLines.length ? 1 : 0)
          .attr('transform', 'translate(' + availableWidth + ',0)');
          //.attr('transform', 'translate(' + x.range()[1] + ',0)');

      d3.transition(g.select('.nv-y2.nv-axis'))
          .call(y2Axis);

      //------------------------------------------------------------


      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      legend.dispatch.on('stateChange', function(newState) { 
        state = newState;
        dispatch.stateChange(state);
        chart.update();
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode);
      });


      // Update chart from a state object passed to event handler
      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined') {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }

        chart.update();
      });

      //============================================================


    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  lines.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  lines.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  bars.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  bars.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.legend = legend;
  chart.lines = lines;
  chart.bars = bars;
  chart.xAxis = xAxis;
  chart.y1Axis = y1Axis;
  chart.y2Axis = y2Axis;

  d3.rebind(chart, lines, 'defined', 'size', 'clipVoronoi', 'interpolate');
  //TODO: consider rebinding x, y and some other stuff, and simply do soemthign lile bars.x(lines.x()), etc.
  //d3.rebind(chart, lines, 'x', 'y', 'size', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'interactive', 'clipEdge', 'clipVoronoi', 'id');

  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = _;
    lines.x(_);
    bars.x(_);
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = _;
    lines.y(_);
    bars.y(_);
    return chart;
  };

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  //============================================================


  return chart;
}
nv.models.lineWithFocusChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var lines = nv.models.line()
    , lines2 = nv.models.line()
    , xAxis = nv.models.axis()
    , yAxis = nv.models.axis()
    , x2Axis = nv.models.axis()
    , y2Axis = nv.models.axis()
    , legend = nv.models.legend()
    , brush = d3.svg.brush()
    ;

  var margin = {top: 30, right: 30, bottom: 30, left: 60}
    , margin2 = {top: 0, right: 30, bottom: 20, left: 60}
    , color = nv.utils.defaultColor()
    , width = null
    , height = null
    , height2 = 100
    , x
    , y
    , x2
    , y2
    , showLegend = true
    , brushExtent = null
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
        return '<h3>' + key + '</h3>' +
               '<p>' +  y + ' at ' + x + '</p>'
      }
    , noData = "No Data Available."
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'brush')
    , transitionDuration = 250
    ;

  lines
    .clipEdge(true)
    ;
  lines2
    .interactive(false)
    ;
  xAxis
    .orient('bottom')
    .tickPadding(5)
    ;
  yAxis
    .orient('left')
    ;
  x2Axis
    .orient('bottom')
    .tickPadding(5)
    ;
  y2Axis
    .orient('left')
    ;
  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
        y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)),
        content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, null, null, offsetElement);
  };

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight1 = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom - height2,
          availableHeight2 = height2 - margin2.top - margin2.bottom;

      chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
      chart.container = this;


      //------------------------------------------------------------
      // Display No Data message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight1 / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x = lines.xScale();
      y = lines.yScale();
      x2 = lines2.xScale();
      y2 = lines2.yScale();

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-lineWithFocusChart').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineWithFocusChart').append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-legendWrap');

      var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
      focusEnter.append('g').attr('class', 'nv-x nv-axis');
      focusEnter.append('g').attr('class', 'nv-y nv-axis');
      focusEnter.append('g').attr('class', 'nv-linesWrap');

      var contextEnter = gEnter.append('g').attr('class', 'nv-context');
      contextEnter.append('g').attr('class', 'nv-x nv-axis');
      contextEnter.append('g').attr('class', 'nv-y nv-axis');
      contextEnter.append('g').attr('class', 'nv-linesWrap');
      contextEnter.append('g').attr('class', 'nv-brushBackground');
      contextEnter.append('g').attr('class', 'nv-x nv-brush');

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend.width(availableWidth);

        g.select('.nv-legendWrap')
            .datum(data)
            .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight1 = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom - height2;
        }

        g.select('.nv-legendWrap')
            .attr('transform', 'translate(0,' + (-margin.top) +')')
      }

      //------------------------------------------------------------


      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');


      //------------------------------------------------------------
      // Main Chart Component(s)

      lines
        .width(availableWidth)
        .height(availableHeight1)
        .color(
          data
            .map(function(d,i) {
              return d.color || color(d, i);
            })
            .filter(function(d,i) {
              return !data[i].disabled;
          })
        );

      lines2
        .defined(lines.defined())
        .width(availableWidth)
        .height(availableHeight2)
        .color(
          data
            .map(function(d,i) {
              return d.color || color(d, i);
            })
            .filter(function(d,i) {
              return !data[i].disabled;
          })
        );

      g.select('.nv-context')
          .attr('transform', 'translate(0,' + ( availableHeight1 + margin.bottom + margin2.top) + ')')

      var contextLinesWrap = g.select('.nv-context .nv-linesWrap')
          .datum(data.filter(function(d) { return !d.disabled }))

      d3.transition(contextLinesWrap).call(lines2);

      //------------------------------------------------------------


      /*
      var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')
          .datum(data.filter(function(d) { return !d.disabled }))

      d3.transition(focusLinesWrap).call(lines);
     */


      //------------------------------------------------------------
      // Setup Main (Focus) Axes

      xAxis
        .scale(x)
        .ticks( availableWidth / 100 )
        .tickSize(-availableHeight1, 0);

      yAxis
        .scale(y)
        .ticks( availableHeight1 / 36 )
        .tickSize( -availableWidth, 0);

      g.select('.nv-focus .nv-x.nv-axis')
          .attr('transform', 'translate(0,' + availableHeight1 + ')');

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Brush

      brush
        .x(x2)
        .on('brush', function() {
            //When brushing, turn off transitions because chart needs to change immediately.
            var oldTransition = chart.transitionDuration();
            chart.transitionDuration(0); 
            onBrush();
            chart.transitionDuration(oldTransition);
        });

      if (brushExtent) brush.extent(brushExtent);

      var brushBG = g.select('.nv-brushBackground').selectAll('g')
          .data([brushExtent || brush.extent()])

      var brushBGenter = brushBG.enter()
          .append('g');

      brushBGenter.append('rect')
          .attr('class', 'left')
          .attr('x', 0)
          .attr('y', 0)
          .attr('height', availableHeight2);

      brushBGenter.append('rect')
          .attr('class', 'right')
          .attr('x', 0)
          .attr('y', 0)
          .attr('height', availableHeight2);

      var gBrush = g.select('.nv-x.nv-brush')
          .call(brush);
      gBrush.selectAll('rect')
          //.attr('y', -5)
          .attr('height', availableHeight2);
      gBrush.selectAll('.resize').append('path').attr('d', resizePath);

      onBrush();

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Secondary (Context) Axes

      x2Axis
        .scale(x2)
        .ticks( availableWidth / 100 )
        .tickSize(-availableHeight2, 0);

      g.select('.nv-context .nv-x.nv-axis')
          .attr('transform', 'translate(0,' + y2.range()[0] + ')');
      d3.transition(g.select('.nv-context .nv-x.nv-axis'))
          .call(x2Axis);


      y2Axis
        .scale(y2)
        .ticks( availableHeight2 / 36 )
        .tickSize( -availableWidth, 0);

      d3.transition(g.select('.nv-context .nv-y.nv-axis'))
          .call(y2Axis);

      g.select('.nv-context .nv-x.nv-axis')
          .attr('transform', 'translate(0,' + y2.range()[0] + ')');

      //------------------------------------------------------------


      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      legend.dispatch.on('stateChange', function(newState) { 
        chart.update();
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode);
      });

      //============================================================


      //============================================================
      // Functions
      //------------------------------------------------------------

      // Taken from crossfilter (http://square.github.com/crossfilter/)
      function resizePath(d) {
        var e = +(d == 'e'),
            x = e ? 1 : -1,
            y = availableHeight2 / 3;
        return 'M' + (.5 * x) + ',' + y
            + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)
            + 'V' + (2 * y - 6)
            + 'A6,6 0 0 ' + e + ' ' + (.5 * x) + ',' + (2 * y)
            + 'Z'
            + 'M' + (2.5 * x) + ',' + (y + 8)
            + 'V' + (2 * y - 8)
            + 'M' + (4.5 * x) + ',' + (y + 8)
            + 'V' + (2 * y - 8);
      }


      function updateBrushBG() {
        if (!brush.empty()) brush.extent(brushExtent);
        brushBG
            .data([brush.empty() ? x2.domain() : brushExtent])
            .each(function(d,i) {
              var leftWidth = x2(d[0]) - x.range()[0],
                  rightWidth = x.range()[1] - x2(d[1]);
              d3.select(this).select('.left')
                .attr('width',  leftWidth < 0 ? 0 : leftWidth);

              d3.select(this).select('.right')
                .attr('x', x2(d[1]))
                .attr('width', rightWidth < 0 ? 0 : rightWidth);
            });
      }


      function onBrush() {
        brushExtent = brush.empty() ? null : brush.extent();
        var extent = brush.empty() ? x2.domain() : brush.extent();

        //The brush extent cannot be less than one.  If it is, don't update the line chart.
        if (Math.abs(extent[0] - extent[1]) <= 1) {
          return;
        }

        dispatch.brush({extent: extent, brush: brush});


        updateBrushBG();

        // Update Main (Focus)
        var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')
            .datum(
              data
                .filter(function(d) { return !d.disabled })
                .map(function(d,i) {
                  return {
                    key: d.key,
                    values: d.values.filter(function(d,i) {
                      return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                    })
                  }
                })
            );
        focusLinesWrap.transition().duration(transitionDuration).call(lines);


        // Update Main (Focus) Axes
        g.select('.nv-focus .nv-x.nv-axis').transition().duration(transitionDuration)
            .call(xAxis);
        g.select('.nv-focus .nv-y.nv-axis').transition().duration(transitionDuration)
            .call(yAxis);
      }

      //============================================================


    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  lines.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  lines.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.legend = legend;
  chart.lines = lines;
  chart.lines2 = lines2;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;
  chart.x2Axis = x2Axis;
  chart.y2Axis = y2Axis;

  d3.rebind(chart, lines, 'defined', 'isArea', 'size', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'interactive', 'clipEdge', 'clipVoronoi', 'id');

  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.x = function(_) {
    if (!arguments.length) return lines.x;
    lines.x(_);
    lines2.x(_);
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return lines.y;
    lines.y(_);
    lines2.y(_);
    return chart;
  };

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.margin2 = function(_) {
    if (!arguments.length) return margin2;
    margin2 = _;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.height2 = function(_) {
    if (!arguments.length) return height2;
    height2 = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color =nv.utils.getColor(_);
    legend.color(color);
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.interpolate = function(_) {
    if (!arguments.length) return lines.interpolate();
    lines.interpolate(_);
    lines2.interpolate(_);
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  // Chart has multiple similar Axes, to prevent code duplication, probably need to link all axis functions manually like below
  chart.xTickFormat = function(_) {
    if (!arguments.length) return xAxis.tickFormat();
    xAxis.tickFormat(_);
    x2Axis.tickFormat(_);
    return chart;
  };

  chart.yTickFormat = function(_) {
    if (!arguments.length) return yAxis.tickFormat();
    yAxis.tickFormat(_);
    y2Axis.tickFormat(_);
    return chart;
  };
  
  chart.brushExtent = function(_) {
    if (!arguments.length) return brushExtent;
    brushExtent = _;
    return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.linePlusBarWithFocusChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var lines = nv.models.line()
    , lines2 = nv.models.line()
    , bars = nv.models.historicalBar()
    , bars2 = nv.models.historicalBar()
    , xAxis = nv.models.axis()
    , x2Axis = nv.models.axis()
    , y1Axis = nv.models.axis()
    , y2Axis = nv.models.axis()
    , y3Axis = nv.models.axis()
    , y4Axis = nv.models.axis()
    , legend = nv.models.legend()
    , brush = d3.svg.brush()
    ;

  var margin = {top: 30, right: 30, bottom: 30, left: 60}
    , margin2 = {top: 0, right: 30, bottom: 20, left: 60}
    , width = null
    , height = null
    , height2 = 100
    , getX = function(d) { return d.x }
    , getY = function(d) { return d.y }
    , color = nv.utils.defaultColor()
    , showLegend = true
    , extent
    , brushExtent = null
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
        return '<h3>' + key + '</h3>' +
               '<p>' +  y + ' at ' + x + '</p>';
      }
    , x
    , x2
    , y1
    , y2
    , y3
    , y4
    , noData = "No Data Available."
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'brush')
    , transitionDuration = 0
    ;

  lines
    .clipEdge(true)
    ;
  lines2
    .interactive(false)
    ;
  xAxis
    .orient('bottom')
    .tickPadding(5)
    ;
  y1Axis
    .orient('left')
    ;
  y2Axis
    .orient('right')
    ;
  x2Axis
    .orient('bottom')
    .tickPadding(5)
    ;
  y3Axis
    .orient('left')
    ;
  y4Axis
    .orient('right')
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
    if (extent) {
        e.pointIndex += Math.ceil(extent[0]);
    }
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
        y = (e.series.bar ? y1Axis : y2Axis).tickFormat()(lines.y()(e.point, e.pointIndex)),
        content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
  };

  //------------------------------------------------------------



  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight1 = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom - height2,
          availableHeight2 = height2 - margin2.top - margin2.bottom;

      chart.update = function() { container.transition().duration(transitionDuration).call(chart); };
      chart.container = this;


      //------------------------------------------------------------
      // Display No Data message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight1 / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      var dataBars = data.filter(function(d) { return !d.disabled && d.bar });
      var dataLines = data.filter(function(d) { return !d.bar }); // removed the !d.disabled clause here to fix Issue #240

      x = bars.xScale();
      x2 = x2Axis.scale();
      y1 = bars.yScale();
      y2 = lines.yScale();
      y3 = bars2.yScale();
      y4 = lines2.yScale();

      var series1 = data
        .filter(function(d) { return !d.disabled && d.bar })
        .map(function(d) {
          return d.values.map(function(d,i) {
            return { x: getX(d,i), y: getY(d,i) }
          })
        });

      var series2 = data
        .filter(function(d) { return !d.disabled && !d.bar })
        .map(function(d) {
          return d.values.map(function(d,i) {
            return { x: getX(d,i), y: getY(d,i) }
          })
        });

      x   .range([0, availableWidth]);
      
      x2  .domain(d3.extent(d3.merge(series1.concat(series2)), function(d) { return d.x } ))
          .range([0, availableWidth]);


      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-linePlusBar').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-linePlusBar').append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-legendWrap');
      
      var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
      focusEnter.append('g').attr('class', 'nv-x nv-axis');
      focusEnter.append('g').attr('class', 'nv-y1 nv-axis');
      focusEnter.append('g').attr('class', 'nv-y2 nv-axis');
      focusEnter.append('g').attr('class', 'nv-barsWrap');
      focusEnter.append('g').attr('class', 'nv-linesWrap');

      var contextEnter = gEnter.append('g').attr('class', 'nv-context');
      contextEnter.append('g').attr('class', 'nv-x nv-axis');
      contextEnter.append('g').attr('class', 'nv-y1 nv-axis');
      contextEnter.append('g').attr('class', 'nv-y2 nv-axis');
      contextEnter.append('g').attr('class', 'nv-barsWrap');
      contextEnter.append('g').attr('class', 'nv-linesWrap');
      contextEnter.append('g').attr('class', 'nv-brushBackground');
      contextEnter.append('g').attr('class', 'nv-x nv-brush');


      //------------------------------------------------------------


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend.width( availableWidth / 2 );

        g.select('.nv-legendWrap')
            .datum(data.map(function(series) {
              series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
              series.key = series.originalKey + (series.bar ? ' (left axis)' : ' (right axis)');
              return series;
            }))
          .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight1 = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom - height2;
        }

        g.select('.nv-legendWrap')
            .attr('transform', 'translate(' + ( availableWidth / 2 ) + ',' + (-margin.top) +')');
      }

      //------------------------------------------------------------


      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');


      //------------------------------------------------------------
      // Context Components

      bars2
        .width(availableWidth)
        .height(availableHeight2)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled && data[i].bar }));

      lines2
        .width(availableWidth)
        .height(availableHeight2)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled && !data[i].bar }));
        
      var bars2Wrap = g.select('.nv-context .nv-barsWrap')
          .datum(dataBars.length ? dataBars : [{values:[]}]);

      var lines2Wrap = g.select('.nv-context .nv-linesWrap')
          .datum(!dataLines[0].disabled ? dataLines : [{values:[]}]);
          
      g.select('.nv-context')
          .attr('transform', 'translate(0,' + ( availableHeight1 + margin.bottom + margin2.top) + ')')

      bars2Wrap.transition().call(bars2);
      lines2Wrap.transition().call(lines2);

      //------------------------------------------------------------



      //------------------------------------------------------------
      // Setup Brush

      brush
        .x(x2)
        .on('brush', onBrush);

      if (brushExtent) brush.extent(brushExtent);

      var brushBG = g.select('.nv-brushBackground').selectAll('g')
          .data([brushExtent || brush.extent()])

      var brushBGenter = brushBG.enter()
          .append('g');

      brushBGenter.append('rect')
          .attr('class', 'left')
          .attr('x', 0)
          .attr('y', 0)
          .attr('height', availableHeight2);

      brushBGenter.append('rect')
          .attr('class', 'right')
          .attr('x', 0)
          .attr('y', 0)
          .attr('height', availableHeight2);

      var gBrush = g.select('.nv-x.nv-brush')
          .call(brush);
      gBrush.selectAll('rect')
          //.attr('y', -5)
          .attr('height', availableHeight2);
      gBrush.selectAll('.resize').append('path').attr('d', resizePath);

      //------------------------------------------------------------

      //------------------------------------------------------------
      // Setup Secondary (Context) Axes

      x2Axis
        .ticks( availableWidth / 100 )
        .tickSize(-availableHeight2, 0);

      g.select('.nv-context .nv-x.nv-axis')
          .attr('transform', 'translate(0,' + y3.range()[0] + ')');
      g.select('.nv-context .nv-x.nv-axis').transition()
          .call(x2Axis);


      y3Axis
        .scale(y3)
        .ticks( availableHeight2 / 36 )
        .tickSize( -availableWidth, 0);

      g.select('.nv-context .nv-y1.nv-axis')
          .style('opacity', dataBars.length ? 1 : 0)
          .attr('transform', 'translate(0,' + x2.range()[0] + ')');
          
      g.select('.nv-context .nv-y1.nv-axis').transition()
          .call(y3Axis);
          

      y4Axis
        .scale(y4)
        .ticks( availableHeight2 / 36 )
        .tickSize(dataBars.length ? 0 : -availableWidth, 0); // Show the y2 rules only if y1 has none

      g.select('.nv-context .nv-y2.nv-axis')
          .style('opacity', dataLines.length ? 1 : 0)
          .attr('transform', 'translate(' + x2.range()[1] + ',0)');

      g.select('.nv-context .nv-y2.nv-axis').transition()
          .call(y4Axis);
          
      //------------------------------------------------------------

      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      legend.dispatch.on('stateChange', function(newState) { 
        chart.update();
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode);
      });

      //============================================================


      //============================================================
      // Functions
      //------------------------------------------------------------

      // Taken from crossfilter (http://square.github.com/crossfilter/)
      function resizePath(d) {
        var e = +(d == 'e'),
            x = e ? 1 : -1,
            y = availableHeight2 / 3;
        return 'M' + (.5 * x) + ',' + y
            + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)
            + 'V' + (2 * y - 6)
            + 'A6,6 0 0 ' + e + ' ' + (.5 * x) + ',' + (2 * y)
            + 'Z'
            + 'M' + (2.5 * x) + ',' + (y + 8)
            + 'V' + (2 * y - 8)
            + 'M' + (4.5 * x) + ',' + (y + 8)
            + 'V' + (2 * y - 8);
      }


      function updateBrushBG() {
        if (!brush.empty()) brush.extent(brushExtent);
        brushBG
            .data([brush.empty() ? x2.domain() : brushExtent])
            .each(function(d,i) {
              var leftWidth = x2(d[0]) - x2.range()[0],
                  rightWidth = x2.range()[1] - x2(d[1]);
              d3.select(this).select('.left')
                .attr('width',  leftWidth < 0 ? 0 : leftWidth);

              d3.select(this).select('.right')
                .attr('x', x2(d[1]))
                .attr('width', rightWidth < 0 ? 0 : rightWidth);
            });
      }


      function onBrush() {
        brushExtent = brush.empty() ? null : brush.extent();
        extent = brush.empty() ? x2.domain() : brush.extent();


        dispatch.brush({extent: extent, brush: brush});

        updateBrushBG();


        //------------------------------------------------------------
        // Prepare Main (Focus) Bars and Lines
        
        bars
        .width(availableWidth)
        .height(availableHeight1)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled && data[i].bar }));


        lines
        .width(availableWidth)
        .height(availableHeight1)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled && !data[i].bar }));

        var focusBarsWrap = g.select('.nv-focus .nv-barsWrap')
            .datum(!dataBars.length ? [{values:[]}] :
              dataBars
                .map(function(d,i) {
                  return {
                    key: d.key,
                    values: d.values.filter(function(d,i) {
                      return bars.x()(d,i) >= extent[0] && bars.x()(d,i) <= extent[1];
                    })
                  }
                })
            );
        
        var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')
            .datum(dataLines[0].disabled ? [{values:[]}] :
              dataLines
                .map(function(d,i) {
                  return {
                    key: d.key,
                    values: d.values.filter(function(d,i) {
                      return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                    })
                  }
                })
             );
                 
        //------------------------------------------------------------
        
        
        //------------------------------------------------------------
        // Update Main (Focus) X Axis

        if (dataBars.length) {
            x = bars.xScale();
        } else {
            x = lines.xScale();
        }
        
        xAxis
        .scale(x)
        .ticks( availableWidth / 100 )
        .tickSize(-availableHeight1, 0);

        xAxis.domain([Math.ceil(extent[0]), Math.floor(extent[1])]);
        
        g.select('.nv-x.nv-axis').transition().duration(transitionDuration)
          .call(xAxis);
        //------------------------------------------------------------
        
        
        //------------------------------------------------------------
        // Update Main (Focus) Bars and Lines

        focusBarsWrap.transition().duration(transitionDuration).call(bars);
        focusLinesWrap.transition().duration(transitionDuration).call(lines);
        
        //------------------------------------------------------------
        
          
        //------------------------------------------------------------
        // Setup and Update Main (Focus) Y Axes
        
        g.select('.nv-focus .nv-x.nv-axis')
          .attr('transform', 'translate(0,' + y1.range()[0] + ')');


        y1Axis
        .scale(y1)
        .ticks( availableHeight1 / 36 )
        .tickSize(-availableWidth, 0);

        g.select('.nv-focus .nv-y1.nv-axis')
          .style('opacity', dataBars.length ? 1 : 0);


        y2Axis
        .scale(y2)
        .ticks( availableHeight1 / 36 )
        .tickSize(dataBars.length ? 0 : -availableWidth, 0); // Show the y2 rules only if y1 has none

        g.select('.nv-focus .nv-y2.nv-axis')
          .style('opacity', dataLines.length ? 1 : 0)
          .attr('transform', 'translate(' + x.range()[1] + ',0)');

        g.select('.nv-focus .nv-y1.nv-axis').transition().duration(transitionDuration)
            .call(y1Axis);
        g.select('.nv-focus .nv-y2.nv-axis').transition().duration(transitionDuration)
            .call(y2Axis);
      }

      //============================================================

      onBrush();

    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  lines.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  lines.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  bars.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  bars.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.legend = legend;
  chart.lines = lines;
  chart.lines2 = lines2;
  chart.bars = bars;
  chart.bars2 = bars2;
  chart.xAxis = xAxis;
  chart.x2Axis = x2Axis;
  chart.y1Axis = y1Axis;
  chart.y2Axis = y2Axis;
  chart.y3Axis = y3Axis;
  chart.y4Axis = y4Axis;

  d3.rebind(chart, lines, 'defined', 'size', 'clipVoronoi', 'interpolate');
  //TODO: consider rebinding x, y and some other stuff, and simply do soemthign lile bars.x(lines.x()), etc.
  //d3.rebind(chart, lines, 'x', 'y', 'size', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'interactive', 'clipEdge', 'clipVoronoi', 'id');

  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = _;
    lines.x(_);
    bars.x(_);
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = _;
    lines.y(_);
    bars.y(_);
    return chart;
  };

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.brushExtent = function(_) {
    if (!arguments.length) return brushExtent;
    brushExtent = _;
    return chart;
  };


  //============================================================


  return chart;
}

nv.models.multiBar = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 0, right: 0, bottom: 0, left: 0}
    , width = 960
    , height = 500
    , x = d3.scale.ordinal()
    , y = d3.scale.linear()
    , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
    , getX = function(d) { return d.x }
    , getY = function(d) { return d.y }
    , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove
    , clipEdge = true
    , stacked = false
    , stackOffset = 'zero' // options include 'silhouette', 'wiggle', 'expand', 'zero', or a custom function
    , color = nv.utils.defaultColor()
    , hideable = false
    , barColor = null // adding the ability to set the color for each rather than the whole group
    , disabled // used in conjunction with barColor to communicate from multiBarHorizontalChart what series are disabled
    , delay = 1200
    , xDomain
    , yDomain
    , xRange
    , yRange
    , groupSpacing = 0.1
    , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout')
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var x0, y0 //used to store previous scales
      ;

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var availableWidth = width - margin.left - margin.right,
          availableHeight = height - margin.top - margin.bottom,
          container = d3.select(this);

      if(hideable && data.length) hideable = [{
        values: data[0].values.map(function(d) {
        return {
          x: d.x,
          y: 0,
          series: d.series,
          size: 0.01
        };}
      )}];

      if (stacked)
        data = d3.layout.stack()
                 .offset(stackOffset)
                 .values(function(d){ return d.values })
                 .y(getY)
                 (!data.length && hideable ? hideable : data);


      //add series index to each data point for reference
      data.forEach(function(series, i) {
        series.values.forEach(function(point) {
          point.series = i;
        });
      });


      //------------------------------------------------------------
      // HACK for negative value stacking
      if (stacked)
        data[0].values.map(function(d,i) {
          var posBase = 0, negBase = 0;
          data.map(function(d) {
            var f = d.values[i]
            f.size = Math.abs(f.y);
            if (f.y<0)  {
              f.y1 = negBase;
              negBase = negBase - f.size;
            } else
            {
              f.y1 = f.size + posBase;
              posBase = posBase + f.size;
            }
          });
        });

      //------------------------------------------------------------
      // Setup Scales

      // remap and flatten the data for use in calculating the scales' domains
      var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate
            data.map(function(d) {
              return d.values.map(function(d,i) {
                return { x: getX(d,i), y: getY(d,i), y0: d.y0, y1: d.y1 }
              })
            });

      x   .domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))
          .rangeBands(xRange || [0, availableWidth], groupSpacing);

      //y   .domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return d.y + (stacked ? d.y1 : 0) }).concat(forceY)))
      y   .domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return stacked ? (d.y > 0 ? d.y1 : d.y1 + d.y ) : d.y }).concat(forceY)))
          .range(yRange || [availableHeight, 0]);

      // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
      if (x.domain()[0] === x.domain()[1])
        x.domain()[0] ?
            x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
          : x.domain([-1,1]);

      if (y.domain()[0] === y.domain()[1])
        y.domain()[0] ?
            y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
          : y.domain([-1,1]);


      x0 = x0 || x;
      y0 = y0 || y;

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-multibar').data([data]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibar');
      var defsEnter = wrapEnter.append('defs');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g')

      gEnter.append('g').attr('class', 'nv-groups');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //------------------------------------------------------------



      defsEnter.append('clipPath')
          .attr('id', 'nv-edge-clip-' + id)
        .append('rect');
      wrap.select('#nv-edge-clip-' + id + ' rect')
          .attr('width', availableWidth)
          .attr('height', availableHeight);

      g   .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');



      var groups = wrap.select('.nv-groups').selectAll('.nv-group')
          .data(function(d) { return d }, function(d,i) { return i });
      groups.enter().append('g')
          .style('stroke-opacity', 1e-6)
          .style('fill-opacity', 1e-6);
      groups.exit()
        .transition()
        .selectAll('rect.nv-bar')
        .delay(function(d,i) {
             return i * delay/ data[0].values.length;
        })
          .attr('y', function(d) { return stacked ? y0(d.y0) : y0(0) })
          .attr('height', 0)
          .remove();
      groups
          .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
          .classed('hover', function(d) { return d.hover })
          .style('fill', function(d,i){ return color(d, i) })
          .style('stroke', function(d,i){ return color(d, i) });
      groups
          .transition()
          .style('stroke-opacity', 1)
          .style('fill-opacity', .75);


      var bars = groups.selectAll('rect.nv-bar')
          .data(function(d) { return (hideable && !data.length) ? hideable.values : d.values });

      bars.exit().remove();


      var barsEnter = bars.enter().append('rect')
          .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})
          .attr('x', function(d,i,j) {
              return stacked ? 0 : (j * x.rangeBand() / data.length )
          })
          .attr('y', function(d) { return y0(stacked ? d.y0 : 0) })
          .attr('height', 0)
          .attr('width', x.rangeBand() / (stacked ? 1 : data.length) )
          .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',0)'; })
          ;
      bars
          .style('fill', function(d,i,j){ return color(d, j, i);  })
          .style('stroke', function(d,i,j){ return color(d, j, i); })
          .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here
            d3.select(this).classed('hover', true);
            dispatch.elementMouseover({
              value: getY(d,i),
              point: d,
              series: data[d.series],
              pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
              pointIndex: i,
              seriesIndex: d.series,
              e: d3.event
            });
          })
          .on('mouseout', function(d,i) {
            d3.select(this).classed('hover', false);
            dispatch.elementMouseout({
              value: getY(d,i),
              point: d,
              series: data[d.series],
              pointIndex: i,
              seriesIndex: d.series,
              e: d3.event
            });
          })
          .on('click', function(d,i) {
            dispatch.elementClick({
              value: getY(d,i),
              point: d,
              series: data[d.series],
              pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
              pointIndex: i,
              seriesIndex: d.series,
              e: d3.event
            });
            d3.event.stopPropagation();
          })
          .on('dblclick', function(d,i) {
            dispatch.elementDblClick({
              value: getY(d,i),
              point: d,
              series: data[d.series],
              pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
              pointIndex: i,
              seriesIndex: d.series,
              e: d3.event
            });
            d3.event.stopPropagation();
          });
      bars
          .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})
          .transition()
          .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',0)'; })

      if (barColor) {
        if (!disabled) disabled = data.map(function() { return true });
        bars
          .style('fill', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); })
          .style('stroke', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); });
      }


      if (stacked)
          bars.transition()
            .delay(function(d,i) {

                  return i * delay / data[0].values.length;
            })
            .attr('y', function(d,i) {

              return y((stacked ? d.y1 : 0));
            })
            .attr('height', function(d,i) {
              return Math.max(Math.abs(y(d.y + (stacked ? d.y0 : 0)) - y((stacked ? d.y0 : 0))),1);
            })
            .attr('x', function(d,i) {
                  return stacked ? 0 : (d.series * x.rangeBand() / data.length )
            })
            .attr('width', x.rangeBand() / (stacked ? 1 : data.length) );
      else
          bars.transition()
            .delay(function(d,i) {
                return i * delay/ data[0].values.length;
            })
            .attr('x', function(d,i) {
              return d.series * x.rangeBand() / data.length
            })
            .attr('width', x.rangeBand() / data.length)
            .attr('y', function(d,i) {
                return getY(d,i) < 0 ?
                        y(0) :
                        y(0) - y(getY(d,i)) < 1 ?
                          y(0) - 1 :
                        y(getY(d,i)) || 0;
            })
            .attr('height', function(d,i) {
                return Math.max(Math.abs(y(getY(d,i)) - y(0)),1) || 0;
            });



      //store old scales for use in transitions on update
      x0 = x.copy();
      y0 = y.copy();

    });

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  chart.dispatch = dispatch;

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = _;
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = _;
    return chart;
  };

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.xScale = function(_) {
    if (!arguments.length) return x;
    x = _;
    return chart;
  };

  chart.yScale = function(_) {
    if (!arguments.length) return y;
    y = _;
    return chart;
  };

  chart.xDomain = function(_) {
    if (!arguments.length) return xDomain;
    xDomain = _;
    return chart;
  };

  chart.yDomain = function(_) {
    if (!arguments.length) return yDomain;
    yDomain = _;
    return chart;
  };

  chart.xRange = function(_) {
    if (!arguments.length) return xRange;
    xRange = _;
    return chart;
  };

  chart.yRange = function(_) {
    if (!arguments.length) return yRange;
    yRange = _;
    return chart;
  };

  chart.forceY = function(_) {
    if (!arguments.length) return forceY;
    forceY = _;
    return chart;
  };

  chart.stacked = function(_) {
    if (!arguments.length) return stacked;
    stacked = _;
    return chart;
  };

  chart.stackOffset = function(_) {
    if (!arguments.length) return stackOffset;
    stackOffset = _;
    return chart;
  };

  chart.clipEdge = function(_) {
    if (!arguments.length) return clipEdge;
    clipEdge = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    return chart;
  };

  chart.barColor = function(_) {
    if (!arguments.length) return barColor;
    barColor = nv.utils.getColor(_);
    return chart;
  };

  chart.disabled = function(_) {
    if (!arguments.length) return disabled;
    disabled = _;
    return chart;
  };

  chart.id = function(_) {
    if (!arguments.length) return id;
    id = _;
    return chart;
  };

  chart.hideable = function(_) {
    if (!arguments.length) return hideable;
    hideable = _;
    return chart;
  };

  chart.delay = function(_) {
    if (!arguments.length) return delay;
    delay = _;
    return chart;
  };

  chart.groupSpacing = function(_) {
    if (!arguments.length) return groupSpacing;
    groupSpacing = _;
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.multiBarChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var multibar = nv.models.multiBar()
    , xAxis = nv.models.axis()
    , yAxis = nv.models.axis()
    , legend = nv.models.legend()
    , controls = nv.models.legend()
    ;

  var margin = {top: 30, right: 20, bottom: 50, left: 60}
    , width = null
    , height = null
    , color = nv.utils.defaultColor()
    , showControls = true
    , showLegend = true
    , showXAxis = true
    , showYAxis = true
    , rightAlignYAxis = false
    , reduceXTicks = true // if false a tick will show for every data point
    , staggerLabels = false
    , rotateLabels = 0
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
        return '<h3>' + key + '</h3>' +
               '<p>' +  y + ' on ' + x + '</p>'
      }
    , x //can be accessed via chart.xScale()
    , y //can be accessed via chart.yScale()
    , state = { stacked: false }
    , defaultState = null
    , noData = "No Data Available."
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    , controlWidth = function() { return showControls ? 180 : 0 }
    , transitionDuration = 250
    ;

  multibar
    .stacked(false)
    ;
  xAxis
    .orient('bottom')
    .tickPadding(7)
    .highlightZero(true)
    .showMaxMin(false)
    .tickFormat(function(d) { return d })
    ;
  yAxis
    .orient((rightAlignYAxis) ? 'right' : 'left')
    .tickFormat(d3.format(',.1f'))
    ;

  controls.updateState(false);
  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)),
        y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)),
        content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
  };

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;

      chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
      chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });

      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }
      //------------------------------------------------------------
      // Display noData message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x = multibar.xScale();
      y = multibar.yScale();

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-multiBarWithLegend').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarWithLegend').append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-x nv-axis');
      gEnter.append('g').attr('class', 'nv-y nv-axis');
      gEnter.append('g').attr('class', 'nv-barsWrap');
      gEnter.append('g').attr('class', 'nv-legendWrap');
      gEnter.append('g').attr('class', 'nv-controlsWrap');

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend.width(availableWidth - controlWidth());

        if (multibar.barColor())
          data.forEach(function(series,i) {
            series.color = d3.rgb('#ccc').darker(i * 1.5).toString();
          })

        g.select('.nv-legendWrap')
            .datum(data)
            .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }

        g.select('.nv-legendWrap')
            .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Controls

      if (showControls) {
        var controlsData = [
          { key: 'Grouped', disabled: multibar.stacked() },
          { key: 'Stacked', disabled: !multibar.stacked() }
        ];

        controls.width(controlWidth()).color(['#444', '#444', '#444']);
        g.select('.nv-controlsWrap')
            .datum(controlsData)
            .attr('transform', 'translate(0,' + (-margin.top) +')')
            .call(controls);
      }

      //------------------------------------------------------------


      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      if (rightAlignYAxis) {
          g.select(".nv-y.nv-axis")
              .attr("transform", "translate(" + availableWidth + ",0)");
      }

      //------------------------------------------------------------
      // Main Chart Component(s)

      multibar
        .disabled(data.map(function(series) { return series.disabled }))
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled }))


      var barsWrap = g.select('.nv-barsWrap')
          .datum(data.filter(function(d) { return !d.disabled }))

      barsWrap.transition().call(multibar);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Axes

      if (showXAxis) {
          xAxis
            .scale(x)
            .ticks( availableWidth / 100 )
            .tickSize(-availableHeight, 0);

          g.select('.nv-x.nv-axis')
              .attr('transform', 'translate(0,' + y.range()[0] + ')');
          g.select('.nv-x.nv-axis').transition()
              .call(xAxis);

          var xTicks = g.select('.nv-x.nv-axis > g').selectAll('g');

          xTicks
              .selectAll('line, text')
              .style('opacity', 1)

          if (staggerLabels) {
              var getTranslate = function(x,y) {
                  return "translate(" + x + "," + y + ")";
              };

              var staggerUp = 5, staggerDown = 17;  //pixels to stagger by
              // Issue #140
              xTicks
                .selectAll("text")
                .attr('transform', function(d,i,j) { 
                    return  getTranslate(0, (j % 2 == 0 ? staggerUp : staggerDown));
                  });

              var totalInBetweenTicks = d3.selectAll(".nv-x.nv-axis .nv-wrap g g text")[0].length;
              g.selectAll(".nv-x.nv-axis .nv-axisMaxMin text")
                .attr("transform", function(d,i) {
                    return getTranslate(0, (i === 0 || totalInBetweenTicks % 2 !== 0) ? staggerDown : staggerUp);
                });
          }

          if (reduceXTicks)
            xTicks
              .filter(function(d,i) {
                  return i % Math.ceil(data[0].values.length / (availableWidth / 100)) !== 0;
                })
              .selectAll('text, line')
              .style('opacity', 0);

          if(rotateLabels)
            xTicks
              .selectAll('.tick text')
              .attr('transform', 'rotate(' + rotateLabels + ' 0,0)')
              .style('text-anchor', rotateLabels > 0 ? 'start' : 'end');
          
          g.select('.nv-x.nv-axis').selectAll('g.nv-axisMaxMin text')
              .style('opacity', 1);
      }


      if (showYAxis) {      
          yAxis
            .scale(y)
            .ticks( availableHeight / 36 )
            .tickSize( -availableWidth, 0);

          g.select('.nv-y.nv-axis').transition()
              .call(yAxis);
      }


      //------------------------------------------------------------



      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      legend.dispatch.on('stateChange', function(newState) { 
        state = newState;
        dispatch.stateChange(state);
        chart.update();
      });

      controls.dispatch.on('legendClick', function(d,i) {
        if (!d.disabled) return;
        controlsData = controlsData.map(function(s) {
          s.disabled = true;
          return s;
        });
        d.disabled = false;

        switch (d.key) {
          case 'Grouped':
            multibar.stacked(false);
            break;
          case 'Stacked':
            multibar.stacked(true);
            break;
        }

        state.stacked = multibar.stacked();
        dispatch.stateChange(state);

        chart.update();
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode)
      });

      // Update chart from a state object passed to event handler
      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined') {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }

        if (typeof e.stacked !== 'undefined') {
          multibar.stacked(e.stacked);
          state.stacked = e.stacked;
        }

        chart.update();
      });

      //============================================================


    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  multibar.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  multibar.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });
  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.multibar = multibar;
  chart.legend = legend;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;

  d3.rebind(chart, multibar, 'x', 'y', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'clipEdge',
   'id', 'stacked', 'stackOffset', 'delay', 'barColor','groupSpacing');

  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    return chart;
  };

  chart.showControls = function(_) {
    if (!arguments.length) return showControls;
    showControls = _;
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.showXAxis = function(_) {
    if (!arguments.length) return showXAxis;
    showXAxis = _;
    return chart;
  };

  chart.showYAxis = function(_) {
    if (!arguments.length) return showYAxis;
    showYAxis = _;
    return chart;
  };

  chart.rightAlignYAxis = function(_) {
    if(!arguments.length) return rightAlignYAxis;
    rightAlignYAxis = _;
    yAxis.orient( (_) ? 'right' : 'left');
    return chart;
  };

  chart.reduceXTicks= function(_) {
    if (!arguments.length) return reduceXTicks;
    reduceXTicks = _;
    return chart;
  };

  chart.rotateLabels = function(_) {
    if (!arguments.length) return rotateLabels;
    rotateLabels = _;
    return chart;
  }

  chart.staggerLabels = function(_) {
    if (!arguments.length) return staggerLabels;
    staggerLabels = _;
    return chart;
  };

  chart.tooltip = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };
  
  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.multiBarHorizontal = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 0, right: 0, bottom: 0, left: 0}
    , width = 960
    , height = 500
    , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
    , x = d3.scale.ordinal()
    , y = d3.scale.linear()
    , getX = function(d) { return d.x }
    , getY = function(d) { return d.y }
    , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove
    , color = nv.utils.defaultColor()
    , barColor = null // adding the ability to set the color for each rather than the whole group
    , disabled // used in conjunction with barColor to communicate from multiBarHorizontalChart what series are disabled
    , stacked = false
    , showValues = false
    , showBarLabels = false
    , valuePadding = 60
    , valueFormat = d3.format(',.2f')
    , delay = 1200
    , xDomain
    , yDomain
    , xRange
    , yRange
    , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout')
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var x0, y0 //used to store previous scales
      ;

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var availableWidth = width - margin.left - margin.right,
          availableHeight = height - margin.top - margin.bottom,
          container = d3.select(this);


      if (stacked)
        data = d3.layout.stack()
                 .offset('zero')
                 .values(function(d){ return d.values })
                 .y(getY)
                 (data);


      //add series index to each data point for reference
      data.forEach(function(series, i) {
        series.values.forEach(function(point) {
          point.series = i;
        });
      });



      //------------------------------------------------------------
      // HACK for negative value stacking
      if (stacked)
        data[0].values.map(function(d,i) {
          var posBase = 0, negBase = 0;
          data.map(function(d) {
            var f = d.values[i]
            f.size = Math.abs(f.y);
            if (f.y<0)  {
              f.y1 = negBase - f.size;
              negBase = negBase - f.size;
            } else
            {
              f.y1 = posBase;
              posBase = posBase + f.size;
            }
          });
        });



      //------------------------------------------------------------
      // Setup Scales

      // remap and flatten the data for use in calculating the scales' domains
      var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate
            data.map(function(d) {
              return d.values.map(function(d,i) {
                return { x: getX(d,i), y: getY(d,i), y0: d.y0, y1: d.y1 }
              })
            });

      x   .domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))
          .rangeBands(xRange || [0, availableHeight], .1);

      //y   .domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return d.y + (stacked ? d.y0 : 0) }).concat(forceY)))
      y   .domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return stacked ? (d.y > 0 ? d.y1 + d.y : d.y1 ) : d.y }).concat(forceY)))

      if (showValues && !stacked)
        y.range(yRange || [(y.domain()[0] < 0 ? valuePadding : 0), availableWidth - (y.domain()[1] > 0 ? valuePadding : 0) ]);
      else
        y.range(yRange || [0, availableWidth]);

      x0 = x0 || x;
      y0 = y0 || d3.scale.linear().domain(y.domain()).range([y(0),y(0)]);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = d3.select(this).selectAll('g.nv-wrap.nv-multibarHorizontal').data([data]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibarHorizontal');
      var defsEnter = wrapEnter.append('defs');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-groups');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //------------------------------------------------------------



      var groups = wrap.select('.nv-groups').selectAll('.nv-group')
          .data(function(d) { return d }, function(d,i) { return i });
      groups.enter().append('g')
          .style('stroke-opacity', 1e-6)
          .style('fill-opacity', 1e-6);
      groups.exit().transition()
          .style('stroke-opacity', 1e-6)
          .style('fill-opacity', 1e-6)
          .remove();
      groups
          .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
          .classed('hover', function(d) { return d.hover })
          .style('fill', function(d,i){ return color(d, i) })
          .style('stroke', function(d,i){ return color(d, i) });
      groups.transition()
          .style('stroke-opacity', 1)
          .style('fill-opacity', .75);


      var bars = groups.selectAll('g.nv-bar')
          .data(function(d) { return d.values });

      bars.exit().remove();


      var barsEnter = bars.enter().append('g')
          .attr('transform', function(d,i,j) {
              return 'translate(' + y0(stacked ? d.y0 : 0) + ',' + (stacked ? 0 : (j * x.rangeBand() / data.length ) + x(getX(d,i))) + ')'
          });

      barsEnter.append('rect')
          .attr('width', 0)
          .attr('height', x.rangeBand() / (stacked ? 1 : data.length) )

      bars
          .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here
            d3.select(this).classed('hover', true);
            dispatch.elementMouseover({
              value: getY(d,i),
              point: d,
              series: data[d.series],
              pos: [ y(getY(d,i) + (stacked ? d.y0 : 0)), x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length) ],
              pointIndex: i,
              seriesIndex: d.series,
              e: d3.event
            });
          })
          .on('mouseout', function(d,i) {
            d3.select(this).classed('hover', false);
            dispatch.elementMouseout({
              value: getY(d,i),
              point: d,
              series: data[d.series],
              pointIndex: i,
              seriesIndex: d.series,
              e: d3.event
            });
          })
          .on('click', function(d,i) {
            dispatch.elementClick({
              value: getY(d,i),
              point: d,
              series: data[d.series],
              pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
              pointIndex: i,
              seriesIndex: d.series,
              e: d3.event
            });
            d3.event.stopPropagation();
          })
          .on('dblclick', function(d,i) {
            dispatch.elementDblClick({
              value: getY(d,i),
              point: d,
              series: data[d.series],
              pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
              pointIndex: i,
              seriesIndex: d.series,
              e: d3.event
            });
            d3.event.stopPropagation();
          });


      barsEnter.append('text');

      if (showValues && !stacked) {
        bars.select('text')
            .attr('text-anchor', function(d,i) { return getY(d,i) < 0 ? 'end' : 'start' })
            .attr('y', x.rangeBand() / (data.length * 2))
            .attr('dy', '.32em')
            .text(function(d,i) { return valueFormat(getY(d,i)) })
        bars.transition()
          .select('text')
            .attr('x', function(d,i) { return getY(d,i) < 0 ? -4 : y(getY(d,i)) - y(0) + 4 })
      } else {
        bars.selectAll('text').text('');
      }

      if (showBarLabels && !stacked) {
        barsEnter.append('text').classed('nv-bar-label',true);
        bars.select('text.nv-bar-label')
            .attr('text-anchor', function(d,i) { return getY(d,i) < 0 ? 'start' : 'end' })
            .attr('y', x.rangeBand() / (data.length * 2))
            .attr('dy', '.32em')
            .text(function(d,i) { return getX(d,i) });
        bars.transition()
          .select('text.nv-bar-label')
            .attr('x', function(d,i) { return getY(d,i) < 0 ? y(0) - y(getY(d,i)) + 4 : -4 });
      }
      else {
        bars.selectAll('text.nv-bar-label').text('');
      }

      bars
          .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})

      if (barColor) {
        if (!disabled) disabled = data.map(function() { return true });
        bars
          .style('fill', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); })
          .style('stroke', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); });
      }

      if (stacked)
        bars.transition()
            .attr('transform', function(d,i) {
              return 'translate(' + y(d.y1) + ',' + x(getX(d,i)) + ')'
            })
          .select('rect')
            .attr('width', function(d,i) {
              return Math.abs(y(getY(d,i) + d.y0) - y(d.y0))
            })
            .attr('height', x.rangeBand() );
      else
        bars.transition()
            .attr('transform', function(d,i) {
              //TODO: stacked must be all positive or all negative, not both?
              return 'translate(' +
              (getY(d,i) < 0 ? y(getY(d,i)) : y(0))
              + ',' +
              (d.series * x.rangeBand() / data.length
              +
              x(getX(d,i)) )
              + ')'
            })
          .select('rect')
            .attr('height', x.rangeBand() / data.length )
            .attr('width', function(d,i) {
              return Math.max(Math.abs(y(getY(d,i)) - y(0)),1)
            });


      //store old scales for use in transitions on update
      x0 = x.copy();
      y0 = y.copy();

    });

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  chart.dispatch = dispatch;

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = _;
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = _;
    return chart;
  };

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.xScale = function(_) {
    if (!arguments.length) return x;
    x = _;
    return chart;
  };

  chart.yScale = function(_) {
    if (!arguments.length) return y;
    y = _;
    return chart;
  };

  chart.xDomain = function(_) {
    if (!arguments.length) return xDomain;
    xDomain = _;
    return chart;
  };

  chart.yDomain = function(_) {
    if (!arguments.length) return yDomain;
    yDomain = _;
    return chart;
  };

  chart.xRange = function(_) {
    if (!arguments.length) return xRange;
    xRange = _;
    return chart;
  };

  chart.yRange = function(_) {
    if (!arguments.length) return yRange;
    yRange = _;
    return chart;
  };

  chart.forceY = function(_) {
    if (!arguments.length) return forceY;
    forceY = _;
    return chart;
  };

  chart.stacked = function(_) {
    if (!arguments.length) return stacked;
    stacked = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    return chart;
  };

  chart.barColor = function(_) {
    if (!arguments.length) return barColor;
    barColor = nv.utils.getColor(_);
    return chart;
  };

  chart.disabled = function(_) {
    if (!arguments.length) return disabled;
    disabled = _;
    return chart;
  };

  chart.id = function(_) {
    if (!arguments.length) return id;
    id = _;
    return chart;
  };

  chart.delay = function(_) {
    if (!arguments.length) return delay;
    delay = _;
    return chart;
  };

  chart.showValues = function(_) {
    if (!arguments.length) return showValues;
    showValues = _;
    return chart;
  };

  chart.showBarLabels = function(_) {
    if (!arguments.length) return showBarLabels;
    showBarLabels = _;
    return chart;
  };


  chart.valueFormat= function(_) {
    if (!arguments.length) return valueFormat;
    valueFormat = _;
    return chart;
  };

  chart.valuePadding = function(_) {
    if (!arguments.length) return valuePadding;
    valuePadding = _;
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.multiBarHorizontalChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var multibar = nv.models.multiBarHorizontal()
    , xAxis = nv.models.axis()
    , yAxis = nv.models.axis()
    , legend = nv.models.legend().height(30)
    , controls = nv.models.legend().height(30)
    ;

  var margin = {top: 30, right: 20, bottom: 50, left: 60}
    , width = null
    , height = null
    , color = nv.utils.defaultColor()
    , showControls = true
    , showLegend = true
    , showXAxis = true
    , showYAxis = true
    , stacked = false
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
        return '<h3>' + key + ' - ' + x + '</h3>' +
               '<p>' +  y + '</p>'
      }
    , x //can be accessed via chart.xScale()
    , y //can be accessed via chart.yScale()
    , state = { stacked: stacked }
    , defaultState = null
    , noData = 'No Data Available.'
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    , controlWidth = function() { return showControls ? 180 : 0 }
    , transitionDuration = 250
    ;

  multibar
    .stacked(stacked)
    ;
  xAxis
    .orient('left')
    .tickPadding(5)
    .highlightZero(false)
    .showMaxMin(false)
    .tickFormat(function(d) { return d })
    ;
  yAxis
    .orient('bottom')
    .tickFormat(d3.format(',.1f'))
    ;

  controls.updateState(false);
  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)),
        y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)),
        content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, e.value < 0 ? 'e' : 'w', null, offsetElement);
  };

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;

      chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
      chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });

      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }

      //------------------------------------------------------------
      // Display No Data message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x = multibar.xScale();
      y = multibar.yScale();

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-multiBarHorizontalChart').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarHorizontalChart').append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-x nv-axis');
      gEnter.append('g').attr('class', 'nv-y nv-axis')
            .append('g').attr('class', 'nv-zeroLine')
            .append('line');
      gEnter.append('g').attr('class', 'nv-barsWrap');
      gEnter.append('g').attr('class', 'nv-legendWrap');
      gEnter.append('g').attr('class', 'nv-controlsWrap');

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend.width(availableWidth - controlWidth());

        if (multibar.barColor())
          data.forEach(function(series,i) {
            series.color = d3.rgb('#ccc').darker(i * 1.5).toString();
          })

        g.select('.nv-legendWrap')
            .datum(data)
            .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }

        g.select('.nv-legendWrap')
            .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Controls

      if (showControls) {
        var controlsData = [
          { key: 'Grouped', disabled: multibar.stacked() },
          { key: 'Stacked', disabled: !multibar.stacked() }
        ];

        controls.width(controlWidth()).color(['#444', '#444', '#444']);
        g.select('.nv-controlsWrap')
            .datum(controlsData)
            .attr('transform', 'translate(0,' + (-margin.top) +')')
            .call(controls);
      }

      //------------------------------------------------------------


      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');


      //------------------------------------------------------------
      // Main Chart Component(s)

      multibar
        .disabled(data.map(function(series) { return series.disabled }))
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled }))


      var barsWrap = g.select('.nv-barsWrap')
          .datum(data.filter(function(d) { return !d.disabled }))

      barsWrap.transition().call(multibar);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Axes

      if (showXAxis) {
          xAxis
            .scale(x)
            .ticks( availableHeight / 24 )
            .tickSize(-availableWidth, 0);

          g.select('.nv-x.nv-axis').transition()
              .call(xAxis);

          var xTicks = g.select('.nv-x.nv-axis').selectAll('g');

          xTicks
              .selectAll('line, text');
      }

      if (showYAxis) {
          yAxis
            .scale(y)
            .ticks( availableWidth / 100 )
            .tickSize( -availableHeight, 0);

          g.select('.nv-y.nv-axis')
              .attr('transform', 'translate(0,' + availableHeight + ')');
          g.select('.nv-y.nv-axis').transition()
              .call(yAxis);
      }

      // Zero line
      g.select(".nv-zeroLine line")
        .attr("x1", y(0))
        .attr("x2", y(0))
        .attr("y1", 0)
        .attr("y2", -availableHeight)
        ;

      //------------------------------------------------------------



      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      legend.dispatch.on('stateChange', function(newState) {
        state = newState;
        dispatch.stateChange(state);
        chart.update();
      });

      controls.dispatch.on('legendClick', function(d,i) {
        if (!d.disabled) return;
        controlsData = controlsData.map(function(s) {
          s.disabled = true;
          return s;
        });
        d.disabled = false;

        switch (d.key) {
          case 'Grouped':
            multibar.stacked(false);
            break;
          case 'Stacked':
            multibar.stacked(true);
            break;
        }

        state.stacked = multibar.stacked();
        dispatch.stateChange(state);

        chart.update();
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode);
      });

      // Update chart from a state object passed to event handler
      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined') {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }

        if (typeof e.stacked !== 'undefined') {
          multibar.stacked(e.stacked);
          state.stacked = e.stacked;
        }

        chart.update();
      });
      //============================================================


    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  multibar.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  multibar.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });
  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.multibar = multibar;
  chart.legend = legend;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;

  d3.rebind(chart, multibar, 'x', 'y', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY',
    'clipEdge', 'id', 'delay', 'showValues','showBarLabels', 'valueFormat', 'stacked', 'barColor');

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    return chart;
  };

  chart.showControls = function(_) {
    if (!arguments.length) return showControls;
    showControls = _;
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.showXAxis = function(_) {
    if (!arguments.length) return showXAxis;
    showXAxis = _;
    return chart;
  };

  chart.showYAxis = function(_) {
    if (!arguments.length) return showYAxis;
    showYAxis = _;
    return chart;
  };

  chart.tooltip = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };
  //============================================================


  return chart;
}
nv.models.multiChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 30, right: 20, bottom: 50, left: 60},
      color = d3.scale.category20().range(),
      width = null, 
      height = null,
      showLegend = true,
      tooltips = true,
      tooltip = function(key, x, y, e, graph) {
        return '<h3>' + key + '</h3>' +
               '<p>' +  y + ' at ' + x + '</p>'
      },
      x,
      y,
      yDomain1,
      yDomain2
      ; //can be accessed via chart.lines.[x/y]Scale()

  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var x = d3.scale.linear(),
      yScale1 = d3.scale.linear(),
      yScale2 = d3.scale.linear(),

      lines1 = nv.models.line().yScale(yScale1),
      lines2 = nv.models.line().yScale(yScale2),

      bars1 = nv.models.multiBar().stacked(false).yScale(yScale1),
      bars2 = nv.models.multiBar().stacked(false).yScale(yScale2),

      stack1 = nv.models.stackedArea().yScale(yScale1),
      stack2 = nv.models.stackedArea().yScale(yScale2),

      xAxis = nv.models.axis().scale(x).orient('bottom').tickPadding(5),
      yAxis1 = nv.models.axis().scale(yScale1).orient('left'),
      yAxis2 = nv.models.axis().scale(yScale2).orient('right'),

      legend = nv.models.legend().height(30),
      dispatch = d3.dispatch('tooltipShow', 'tooltipHide');

  var showTooltip = function(e, offsetElement) {
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        x = xAxis.tickFormat()(lines1.x()(e.point, e.pointIndex)),
        y = ((e.series.yAxis == 2) ? yAxis2 : yAxis1).tickFormat()(lines1.y()(e.point, e.pointIndex)),
        content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, undefined, undefined, offsetElement.offsetParent);
  };

  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      chart.update = function() { container.transition().call(chart); };
      chart.container = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;

      var dataLines1 = data.filter(function(d) {return !d.disabled && d.type == 'line' && d.yAxis == 1})
      var dataLines2 = data.filter(function(d) {return !d.disabled && d.type == 'line' && d.yAxis == 2})
      var dataBars1 = data.filter(function(d) {return !d.disabled && d.type == 'bar' && d.yAxis == 1})
      var dataBars2 = data.filter(function(d) {return !d.disabled && d.type == 'bar' && d.yAxis == 2})
      var dataStack1 = data.filter(function(d) {return !d.disabled && d.type == 'area' && d.yAxis == 1})
      var dataStack2 = data.filter(function(d) {return !d.disabled && d.type == 'area' && d.yAxis == 2})

      var series1 = data.filter(function(d) {return !d.disabled && d.yAxis == 1})
            .map(function(d) {
              return d.values.map(function(d,i) {
                return { x: d.x, y: d.y }
              })
            })

      var series2 = data.filter(function(d) {return !d.disabled && d.yAxis == 2})
            .map(function(d) {
              return d.values.map(function(d,i) {
                return { x: d.x, y: d.y }
              })
            })

      x   .domain(d3.extent(d3.merge(series1.concat(series2)), function(d) { return d.x } ))
          .range([0, availableWidth]);

      var wrap = container.selectAll('g.wrap.multiChart').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'wrap nvd3 multiChart').append('g');

      gEnter.append('g').attr('class', 'x axis');
      gEnter.append('g').attr('class', 'y1 axis');
      gEnter.append('g').attr('class', 'y2 axis');
      gEnter.append('g').attr('class', 'lines1Wrap');
      gEnter.append('g').attr('class', 'lines2Wrap');
      gEnter.append('g').attr('class', 'bars1Wrap');
      gEnter.append('g').attr('class', 'bars2Wrap');
      gEnter.append('g').attr('class', 'stack1Wrap');
      gEnter.append('g').attr('class', 'stack2Wrap');
      gEnter.append('g').attr('class', 'legendWrap');

      var g = wrap.select('g');

      if (showLegend) {
        legend.width( availableWidth / 2 );

        g.select('.legendWrap')
            .datum(data.map(function(series) { 
              series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
              series.key = series.originalKey + (series.yAxis == 1 ? '' : ' (right axis)');
              return series;
            }))
          .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }

        g.select('.legendWrap')
            .attr('transform', 'translate(' + ( availableWidth / 2 ) + ',' + (-margin.top) +')');
      }


      lines1
        .width(availableWidth)
        .height(availableHeight)
        .interpolate("monotone")
        .color(data.map(function(d,i) {
          return d.color || color[i % color.length];
        }).filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'line'}));

      lines2
        .width(availableWidth)
        .height(availableHeight)
        .interpolate("monotone")
        .color(data.map(function(d,i) {
          return d.color || color[i % color.length];
        }).filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'line'}));

      bars1
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color[i % color.length];
        }).filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'bar'}));

      bars2
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color[i % color.length];
        }).filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'bar'}));

      stack1
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color[i % color.length];
        }).filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'area'}));

      stack2
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color[i % color.length];
        }).filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'area'}));

      g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');


      var lines1Wrap = g.select('.lines1Wrap')
          .datum(dataLines1)
      var bars1Wrap = g.select('.bars1Wrap')
          .datum(dataBars1)
      var stack1Wrap = g.select('.stack1Wrap')
          .datum(dataStack1)

      var lines2Wrap = g.select('.lines2Wrap')
          .datum(dataLines2)
      var bars2Wrap = g.select('.bars2Wrap')
          .datum(dataBars2)
      var stack2Wrap = g.select('.stack2Wrap')
          .datum(dataStack2)

      var extraValue1 = dataStack1.length ? dataStack1.map(function(a){return a.values}).reduce(function(a,b){
        return a.map(function(aVal,i){return {x: aVal.x, y: aVal.y + b[i].y}})
      }).concat([{x:0, y:0}]) : []
      var extraValue2 = dataStack2.length ? dataStack2.map(function(a){return a.values}).reduce(function(a,b){
        return a.map(function(aVal,i){return {x: aVal.x, y: aVal.y + b[i].y}})
      }).concat([{x:0, y:0}]) : []

      yScale1 .domain(yDomain1 || d3.extent(d3.merge(series1).concat(extraValue1), function(d) { return d.y } ))
              .range([0, availableHeight])

      yScale2 .domain(yDomain2 || d3.extent(d3.merge(series2).concat(extraValue2), function(d) { return d.y } ))
              .range([0, availableHeight])

      lines1.yDomain(yScale1.domain())
      bars1.yDomain(yScale1.domain())
      stack1.yDomain(yScale1.domain())

      lines2.yDomain(yScale2.domain())
      bars2.yDomain(yScale2.domain())
      stack2.yDomain(yScale2.domain())

      if(dataStack1.length){d3.transition(stack1Wrap).call(stack1);}
      if(dataStack2.length){d3.transition(stack2Wrap).call(stack2);}

      if(dataBars1.length){d3.transition(bars1Wrap).call(bars1);}
      if(dataBars2.length){d3.transition(bars2Wrap).call(bars2);}

      if(dataLines1.length){d3.transition(lines1Wrap).call(lines1);}
      if(dataLines2.length){d3.transition(lines2Wrap).call(lines2);}
      


      xAxis
        .ticks( availableWidth / 100 )
        .tickSize(-availableHeight, 0);

      g.select('.x.axis')
          .attr('transform', 'translate(0,' + availableHeight + ')');
      d3.transition(g.select('.x.axis'))
          .call(xAxis);

      yAxis1
        .ticks( availableHeight / 36 )
        .tickSize( -availableWidth, 0);


      d3.transition(g.select('.y1.axis'))
          .call(yAxis1);

      yAxis2
        .ticks( availableHeight / 36 )
        .tickSize( -availableWidth, 0);

      d3.transition(g.select('.y2.axis'))
          .call(yAxis2);

      g.select('.y2.axis')
          .style('opacity', series2.length ? 1 : 0)
          .attr('transform', 'translate(' + x.range()[1] + ',0)');

      legend.dispatch.on('stateChange', function(newState) { 
        chart.update();
      });
     
      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode);
      });

    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  lines1.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  lines1.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  lines2.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  lines2.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  bars1.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  bars1.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  bars2.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  bars2.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  stack1.dispatch.on('tooltipShow', function(e) {
    //disable tooltips when value ~= 0
    //// TODO: consider removing points from voronoi that have 0 value instead of this hack
    if (!Math.round(stack1.y()(e.point) * 100)) {  // 100 will not be good for very small numbers... will have to think about making this valu dynamic, based on data range
      setTimeout(function() { d3.selectAll('.point.hover').classed('hover', false) }, 0);
      return false;
    }

    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top],
    dispatch.tooltipShow(e);
  });

  stack1.dispatch.on('tooltipHide', function(e) {
    dispatch.tooltipHide(e);
  });

  stack2.dispatch.on('tooltipShow', function(e) {
    //disable tooltips when value ~= 0
    //// TODO: consider removing points from voronoi that have 0 value instead of this hack
    if (!Math.round(stack2.y()(e.point) * 100)) {  // 100 will not be good for very small numbers... will have to think about making this valu dynamic, based on data range
      setTimeout(function() { d3.selectAll('.point.hover').classed('hover', false) }, 0);
      return false;
    }

    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top],
    dispatch.tooltipShow(e);
  });

  stack2.dispatch.on('tooltipHide', function(e) {
    dispatch.tooltipHide(e);
  });

    lines1.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  lines1.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  lines2.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  lines2.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });

  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });



  //============================================================
  // Global getters and setters
  //------------------------------------------------------------

  chart.dispatch = dispatch;
  chart.lines1 = lines1;
  chart.lines2 = lines2;
  chart.bars1 = bars1;
  chart.bars2 = bars2;
  chart.stack1 = stack1;
  chart.stack2 = stack2;
  chart.xAxis = xAxis;
  chart.yAxis1 = yAxis1;
  chart.yAxis2 = yAxis2;
  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = _;
    lines1.x(_);
    bars1.x(_);
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = _;
    lines1.y(_);
    bars1.y(_);
    return chart;
  };

  chart.yDomain1 = function(_) {
    if (!arguments.length) return yDomain1;
    yDomain1 = _;
    return chart;
  };

  chart.yDomain2 = function(_) {
    if (!arguments.length) return yDomain2;
    yDomain2 = _;
    return chart;
  };

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin = _;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = _;
    legend.color(_);
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  return chart;
}


nv.models.ohlcBar = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 0, right: 0, bottom: 0, left: 0}
    , width = 960
    , height = 500
    , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
    , x = d3.scale.linear()
    , y = d3.scale.linear()
    , getX = function(d) { return d.x }
    , getY = function(d) { return d.y }
    , getOpen = function(d) { return d.open }
    , getClose = function(d) { return d.close }
    , getHigh = function(d) { return d.high }
    , getLow = function(d) { return d.low }
    , forceX = []
    , forceY = []
    , padData     = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart
    , clipEdge = true
    , color = nv.utils.defaultColor()
    , xDomain
    , yDomain
    , xRange
    , yRange
    , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout')
    ;

  //============================================================

  //============================================================
  // Private Variables
  //------------------------------------------------------------

  //TODO: store old scales for transitions

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var availableWidth = width - margin.left - margin.right,
          availableHeight = height - margin.top - margin.bottom,
          container = d3.select(this);


      //------------------------------------------------------------
      // Setup Scales

      x   .domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX) ));

      if (padData)
        x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
      else
        x.range(xRange || [0, availableWidth]);

      y   .domain(yDomain || [
            d3.min(data[0].values.map(getLow).concat(forceY)),
            d3.max(data[0].values.map(getHigh).concat(forceY))
          ])
          .range(yRange || [availableHeight, 0]);

      // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
      if (x.domain()[0] === x.domain()[1])
        x.domain()[0] ?
            x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
          : x.domain([-1,1]);

      if (y.domain()[0] === y.domain()[1])
        y.domain()[0] ?
            y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
          : y.domain([-1,1]);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = d3.select(this).selectAll('g.nv-wrap.nv-ohlcBar').data([data[0].values]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-ohlcBar');
      var defsEnter = wrapEnter.append('defs');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-ticks');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //------------------------------------------------------------


      container
          .on('click', function(d,i) {
            dispatch.chartClick({
                data: d,
                index: i,
                pos: d3.event,
                id: id
            });
          });


      defsEnter.append('clipPath')
          .attr('id', 'nv-chart-clip-path-' + id)
        .append('rect');

      wrap.select('#nv-chart-clip-path-' + id + ' rect')
          .attr('width', availableWidth)
          .attr('height', availableHeight);

      g   .attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');



      var ticks = wrap.select('.nv-ticks').selectAll('.nv-tick')
          .data(function(d) { return d });

      ticks.exit().remove();


      var ticksEnter = ticks.enter().append('path')
          .attr('class', function(d,i,j) { return (getOpen(d,i) > getClose(d,i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i })
          .attr('d', function(d,i) {
            var w = (availableWidth / data[0].values.length) * .9;
            return 'm0,0l0,'
                 + (y(getOpen(d,i))
                 - y(getHigh(d,i)))
                 + 'l'
                 + (-w/2)
                 + ',0l'
                 + (w/2)
                 + ',0l0,'
                 + (y(getLow(d,i)) - y(getOpen(d,i)))
                 + 'l0,'
                 + (y(getClose(d,i))
                 - y(getLow(d,i)))
                 + 'l'
                 + (w/2)
                 + ',0l'
                 + (-w/2)
                 + ',0z';
          })
          .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',' + y(getHigh(d,i)) + ')'; })
          //.attr('fill', function(d,i) { return color[0]; })
          //.attr('stroke', function(d,i) { return color[0]; })
          //.attr('x', 0 )
          //.attr('y', function(d,i) {  return y(Math.max(0, getY(d,i))) })
          //.attr('height', function(d,i) { return Math.abs(y(getY(d,i)) - y(0)) })
          .on('mouseover', function(d,i) {
            d3.select(this).classed('hover', true);
            dispatch.elementMouseover({
                point: d,
                series: data[0],
                pos: [x(getX(d,i)), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
                pointIndex: i,
                seriesIndex: 0,
                e: d3.event
            });

          })
          .on('mouseout', function(d,i) {
                d3.select(this).classed('hover', false);
                dispatch.elementMouseout({
                    point: d,
                    series: data[0],
                    pointIndex: i,
                    seriesIndex: 0,
                    e: d3.event
                });
          })
          .on('click', function(d,i) {
                dispatch.elementClick({
                    //label: d[label],
                    value: getY(d,i),
                    data: d,
                    index: i,
                    pos: [x(getX(d,i)), y(getY(d,i))],
                    e: d3.event,
                    id: id
                });
              d3.event.stopPropagation();
          })
          .on('dblclick', function(d,i) {
              dispatch.elementDblClick({
                  //label: d[label],
                  value: getY(d,i),
                  data: d,
                  index: i,
                  pos: [x(getX(d,i)), y(getY(d,i))],
                  e: d3.event,
                  id: id
              });
              d3.event.stopPropagation();
          });

      ticks
          .attr('class', function(d,i,j) { return (getOpen(d,i) > getClose(d,i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i })
      d3.transition(ticks)
          .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',' + y(getHigh(d,i)) + ')'; })
          .attr('d', function(d,i) {
            var w = (availableWidth / data[0].values.length) * .9;
            return 'm0,0l0,'
                 + (y(getOpen(d,i))
                 - y(getHigh(d,i)))
                 + 'l'
                 + (-w/2)
                 + ',0l'
                 + (w/2)
                 + ',0l0,'
                 + (y(getLow(d,i))
                 - y(getOpen(d,i)))
                 + 'l0,'
                 + (y(getClose(d,i))
                 - y(getLow(d,i)))
                 + 'l'
                 + (w/2)
                 + ',0l'
                 + (-w/2)
                 + ',0z';
          })
          //.attr('width', (availableWidth / data[0].values.length) * .9 )


      //d3.transition(ticks)
          //.attr('y', function(d,i) {  return y(Math.max(0, getY(d,i))) })
          //.attr('height', function(d,i) { return Math.abs(y(getY(d,i)) - y(0)) });
          //.order();  // not sure if this makes any sense for this model

    });

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  chart.dispatch = dispatch;

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = _;
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = _;
    return chart;
  };

  chart.open = function(_) {
    if (!arguments.length) return getOpen;
    getOpen = _;
    return chart;
  };

  chart.close = function(_) {
    if (!arguments.length) return getClose;
    getClose = _;
    return chart;
  };

  chart.high = function(_) {
    if (!arguments.length) return getHigh;
    getHigh = _;
    return chart;
  };

  chart.low = function(_) {
    if (!arguments.length) return getLow;
    getLow = _;
    return chart;
  };

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.xScale = function(_) {
    if (!arguments.length) return x;
    x = _;
    return chart;
  };

  chart.yScale = function(_) {
    if (!arguments.length) return y;
    y = _;
    return chart;
  };

  chart.xDomain = function(_) {
    if (!arguments.length) return xDomain;
    xDomain = _;
    return chart;
  };

  chart.yDomain = function(_) {
    if (!arguments.length) return yDomain;
    yDomain = _;
    return chart;
  };

  chart.xRange = function(_) {
    if (!arguments.length) return xRange;
    xRange = _;
    return chart;
  };

  chart.yRange = function(_) {
    if (!arguments.length) return yRange;
    yRange = _;
    return chart;
  };

  chart.forceX = function(_) {
    if (!arguments.length) return forceX;
    forceX = _;
    return chart;
  };

  chart.forceY = function(_) {
    if (!arguments.length) return forceY;
    forceY = _;
    return chart;
  };

  chart.padData = function(_) {
    if (!arguments.length) return padData;
    padData = _;
    return chart;
  };

  chart.clipEdge = function(_) {
    if (!arguments.length) return clipEdge;
    clipEdge = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    return chart;
  };

  chart.id = function(_) {
    if (!arguments.length) return id;
    id = _;
    return chart;
  };

  //============================================================


  return chart;
}
nv.models.pie = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 0, right: 0, bottom: 0, left: 0}
    , width = 500
    , height = 500
    , getX = function(d) { return d.x }
    , getY = function(d) { return d.y }
    , getDescription = function(d) { return d.description }
    , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
    , color = nv.utils.defaultColor()
    , valueFormat = d3.format(',.2f')
    , showLabels = true
    , pieLabelsOutside = true
    , donutLabelsOutside = false
    , labelType = "key"
    , labelThreshold = .02 //if slice percentage is under this, don't show label
    , donut = false
    , labelSunbeamLayout = false
    , startAngle = false
    , endAngle = false
    , donutRatio = 0.5
    , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout')
    ;

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var availableWidth = width - margin.left - margin.right,
          availableHeight = height - margin.top - margin.bottom,
          radius = Math.min(availableWidth, availableHeight) / 2,
          arcRadius = radius-(radius / 5),
          container = d3.select(this);


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      //var wrap = container.selectAll('.nv-wrap.nv-pie').data([data]);
      var wrap = container.selectAll('.nv-wrap.nv-pie').data(data);
      var wrapEnter = wrap.enter().append('g').attr('class','nvd3 nv-wrap nv-pie nv-chart-' + id);
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-pie');
      gEnter.append('g').attr('class', 'nv-pieLabels');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
      g.select('.nv-pie').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');
      g.select('.nv-pieLabels').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');

      //------------------------------------------------------------


      container
          .on('click', function(d,i) {
              dispatch.chartClick({
                  data: d,
                  index: i,
                  pos: d3.event,
                  id: id
              });
          });


      var arc = d3.svg.arc()
                  .outerRadius(arcRadius);

      if (startAngle) arc.startAngle(startAngle)
      if (endAngle) arc.endAngle(endAngle);
      if (donut) arc.innerRadius(radius * donutRatio);

      // Setup the Pie chart and choose the data element
      var pie = d3.layout.pie()
          .sort(null)
          .value(function(d) { return d.disabled ? 0 : getY(d) });

      var slices = wrap.select('.nv-pie').selectAll('.nv-slice')
          .data(pie);

      var pieLabels = wrap.select('.nv-pieLabels').selectAll('.nv-label')
          .data(pie);

      slices.exit().remove();
      pieLabels.exit().remove();

      var ae = slices.enter().append('g')
              .attr('class', 'nv-slice')
              .on('mouseover', function(d,i){
                d3.select(this).classed('hover', true);
                dispatch.elementMouseover({
                    label: getX(d.data),
                    value: getY(d.data),
                    point: d.data,
                    pointIndex: i,
                    pos: [d3.event.pageX, d3.event.pageY],
                    id: id
                });
              })
              .on('mouseout', function(d,i){
                d3.select(this).classed('hover', false);
                dispatch.elementMouseout({
                    label: getX(d.data),
                    value: getY(d.data),
                    point: d.data,
                    index: i,
                    id: id
                });
              })
              .on('click', function(d,i) {
                dispatch.elementClick({
                    label: getX(d.data),
                    value: getY(d.data),
                    point: d.data,
                    index: i,
                    pos: d3.event,
                    id: id
                });
                d3.event.stopPropagation();
              })
              .on('dblclick', function(d,i) {
                dispatch.elementDblClick({
                    label: getX(d.data),
                    value: getY(d.data),
                    point: d.data,
                    index: i,
                    pos: d3.event,
                    id: id
                });
                d3.event.stopPropagation();
              });

        slices
            .attr('fill', function(d,i) { return color(d, i); })
            .attr('stroke', function(d,i) { return color(d, i); });

        var paths = ae.append('path')
            .each(function(d) { this._current = d; });
            //.attr('d', arc);

        slices.select('path')
          .transition()
            .attr('d', arc)
            .attrTween('d', arcTween);

        if (showLabels) {
          // This does the normal label
          var labelsArc = d3.svg.arc().innerRadius(0);

          if (pieLabelsOutside){ labelsArc = arc; }

          if (donutLabelsOutside) { labelsArc = d3.svg.arc().outerRadius(arc.outerRadius()); }

          pieLabels.enter().append("g").classed("nv-label",true)
            .each(function(d,i) {
                var group = d3.select(this);

                group
                  .attr('transform', function(d) {
                       if (labelSunbeamLayout) {
                         d.outerRadius = arcRadius + 10; // Set Outer Coordinate
                         d.innerRadius = arcRadius + 15; // Set Inner Coordinate
                         var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);
                         if ((d.startAngle+d.endAngle)/2 < Math.PI) {
                           rotateAngle -= 90;
                         } else {
                           rotateAngle += 90;
                         }
                         return 'translate(' + labelsArc.centroid(d) + ') rotate(' + rotateAngle + ')';
                       } else {
                         d.outerRadius = radius + 10; // Set Outer Coordinate
                         d.innerRadius = radius + 15; // Set Inner Coordinate
                         return 'translate(' + labelsArc.centroid(d) + ')'
                       }
                  });

                group.append('rect')
                    .style('stroke', '#fff')
                    .style('fill', '#fff')
                    .attr("rx", 3)
                    .attr("ry", 3);

                group.append('text')
                    .style('text-anchor', labelSunbeamLayout ? ((d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end') : 'middle') //center the text on it's origin or begin/end if orthogonal aligned
                    .style('fill', '#000')

            });

          var labelLocationHash = {};
          var avgHeight = 14;
          var avgWidth = 140;
          var createHashKey = function(coordinates) {

              return Math.floor(coordinates[0]/avgWidth) * avgWidth + ',' + Math.floor(coordinates[1]/avgHeight) * avgHeight;
          };
          pieLabels.transition()
                .attr('transform', function(d) {
                  if (labelSunbeamLayout) {
                      d.outerRadius = arcRadius + 10; // Set Outer Coordinate
                      d.innerRadius = arcRadius + 15; // Set Inner Coordinate
                      var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);
                      if ((d.startAngle+d.endAngle)/2 < Math.PI) {
                        rotateAngle -= 90;
                      } else {
                        rotateAngle += 90;
                      }
                      return 'translate(' + labelsArc.centroid(d) + ') rotate(' + rotateAngle + ')';
                    } else {
                      d.outerRadius = radius + 10; // Set Outer Coordinate
                      d.innerRadius = radius + 15; // Set Inner Coordinate

                      /*
                      Overlapping pie labels are not good. What this attempts to do is, prevent overlapping.
                      Each label location is hashed, and if a hash collision occurs, we assume an overlap.
                      Adjust the label's y-position to remove the overlap.
                      */
                      var center = labelsArc.centroid(d);
                      var hashKey = createHashKey(center);
                      if (labelLocationHash[hashKey]) {
                        center[1] -= avgHeight;
                      }
                      labelLocationHash[createHashKey(center)] = true;
                      return 'translate(' + center + ')'
                    }
                });
          pieLabels.select(".nv-label text")
                .style('text-anchor', labelSunbeamLayout ? ((d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end') : 'middle') //center the text on it's origin or begin/end if orthogonal aligned
                .text(function(d, i) {
                  var percent = (d.endAngle - d.startAngle) / (2 * Math.PI);
                  var labelTypes = {
                    "key" : getX(d.data),
                    "value": getY(d.data),
                    "percent": d3.format('%')(percent)
                  };
                  return (d.value && percent > labelThreshold) ? labelTypes[labelType] : '';
                });
        }


        // Computes the angle of an arc, converting from radians to degrees.
        function angle(d) {
          var a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;
          return a > 90 ? a - 180 : a;
        }

        function arcTween(a) {
          a.endAngle = isNaN(a.endAngle) ? 0 : a.endAngle;
          a.startAngle = isNaN(a.startAngle) ? 0 : a.startAngle;
          if (!donut) a.innerRadius = 0;
          var i = d3.interpolate(this._current, a);
          this._current = i(0);
          return function(t) {
            return arc(i(t));
          };
        }

        function tweenPie(b) {
          b.innerRadius = 0;
          var i = d3.interpolate({startAngle: 0, endAngle: 0}, b);
          return function(t) {
              return arc(i(t));
          };
        }

    });

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  chart.dispatch = dispatch;
  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.values = function(_) {
    nv.log("pie.values() is no longer supported.");
    return chart;
  };

  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = _;
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = d3.functor(_);
    return chart;
  };

  chart.description = function(_) {
    if (!arguments.length) return getDescription;
    getDescription = _;
    return chart;
  };

  chart.showLabels = function(_) {
    if (!arguments.length) return showLabels;
    showLabels = _;
    return chart;
  };

  chart.labelSunbeamLayout = function(_) {
    if (!arguments.length) return labelSunbeamLayout;
    labelSunbeamLayout = _;
    return chart;
  };

  chart.donutLabelsOutside = function(_) {
    if (!arguments.length) return donutLabelsOutside;
    donutLabelsOutside = _;
    return chart;
  };

  chart.pieLabelsOutside = function(_) {
    if (!arguments.length) return pieLabelsOutside;
    pieLabelsOutside = _;
    return chart;
  };

  chart.labelType = function(_) {
    if (!arguments.length) return labelType;
    labelType = _;
    labelType = labelType || "key";
    return chart;
  };

  chart.donut = function(_) {
    if (!arguments.length) return donut;
    donut = _;
    return chart;
  };

  chart.donutRatio = function(_) {
    if (!arguments.length) return donutRatio;
    donutRatio = _;
    return chart;
  };

  chart.startAngle = function(_) {
    if (!arguments.length) return startAngle;
    startAngle = _;
    return chart;
  };

  chart.endAngle = function(_) {
    if (!arguments.length) return endAngle;
    endAngle = _;
    return chart;
  };

  chart.id = function(_) {
    if (!arguments.length) return id;
    id = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    return chart;
  };

  chart.valueFormat = function(_) {
    if (!arguments.length) return valueFormat;
    valueFormat = _;
    return chart;
  };

  chart.labelThreshold = function(_) {
    if (!arguments.length) return labelThreshold;
    labelThreshold = _;
    return chart;
  };
  //============================================================


  return chart;
}
nv.models.pieChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var pie = nv.models.pie()
    , legend = nv.models.legend()
    ;

  var margin = {top: 30, right: 20, bottom: 20, left: 20}
    , width = null
    , height = null
    , showLegend = true
    , color = nv.utils.defaultColor()
    , tooltips = true
    , tooltip = function(key, y, e, graph) {
        return '<h3>' + key + '</h3>' +
               '<p>' +  y + '</p>'
      }
    , state = {}
    , defaultState = null
    , noData = "No Data Available."
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
    var tooltipLabel = pie.description()(e.point) || pie.x()(e.point)
    var left = e.pos[0] + ( (offsetElement && offsetElement.offsetLeft) || 0 ),
        top = e.pos[1] + ( (offsetElement && offsetElement.offsetTop) || 0),
        y = pie.valueFormat()(pie.y()(e.point)),
        content = tooltip(tooltipLabel, y, e, chart);

    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
  };

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;

      chart.update = function() { container.transition().call(chart); };
      chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });

      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }

      //------------------------------------------------------------
      // Display No Data message if there's nothing to show.

      if (!data || !data.length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-pieChart').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-pieChart').append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-pieWrap');
      gEnter.append('g').attr('class', 'nv-legendWrap');

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend
          .width( availableWidth )
          .key(pie.x());

        wrap.select('.nv-legendWrap')
            .datum(data)
            .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }

        wrap.select('.nv-legendWrap')
            .attr('transform', 'translate(0,' + (-margin.top) +')');
      }

      //------------------------------------------------------------


      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');


      //------------------------------------------------------------
      // Main Chart Component(s)

      pie
        .width(availableWidth)
        .height(availableHeight);


      var pieWrap = g.select('.nv-pieWrap')
          .datum([data]);

      d3.transition(pieWrap).call(pie);

      //------------------------------------------------------------


      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      legend.dispatch.on('stateChange', function(newState) {
        state = newState;
        dispatch.stateChange(state);
        chart.update();
      });

      pie.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
      });

      // Update chart from a state object passed to event handler
      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined') {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }

        chart.update();
      });

      //============================================================


    });

    return chart;
  }

  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  pie.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  dispatch.on('tooltipShow', function(e) {
    if (tooltips) showTooltip(e);
  });

  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.legend = legend;
  chart.dispatch = dispatch;
  chart.pie = pie;

  d3.rebind(chart, pie, 'valueFormat', 'values', 'x', 'y', 'description', 'id', 'showLabels', 'donutLabelsOutside', 'pieLabelsOutside', 'labelType', 'donut', 'donutRatio', 'labelThreshold');
  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    pie.color(color);
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.scatter = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin       = {top: 0, right: 0, bottom: 0, left: 0}
    , width        = 960
    , height       = 500
    , color        = nv.utils.defaultColor() // chooses color
    , id           = Math.floor(Math.random() * 100000) //Create semi-unique ID incase user doesn't select one
    , x            = d3.scale.linear()
    , y            = d3.scale.linear()
    , z            = d3.scale.linear() //linear because d3.svg.shape.size is treated as area
    , getX         = function(d) { return d.x } // accessor to get the x value
    , getY         = function(d) { return d.y } // accessor to get the y value
    , getSize      = function(d) { return d.size || 1} // accessor to get the point size
    , getShape     = function(d) { return d.shape || 'circle' } // accessor to get point shape
    , onlyCircles  = true // Set to false to use shapes
    , forceX       = [] // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)
    , forceY       = [] // List of numbers to Force into the Y scale
    , forceSize    = [] // List of numbers to Force into the Size scale
    , interactive  = true // If true, plots a voronoi overlay for advanced point intersection
    , pointKey     = null
    , pointActive  = function(d) { return !d.notActive } // any points that return false will be filtered out
    , padData      = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart
    , padDataOuter = .1 //outerPadding to imitate ordinal scale outer padding
    , clipEdge     = false // if true, masks points within x and y scale
    , clipVoronoi  = true // if true, masks each point with a circle... can turn off to slightly increase performance
    , clipRadius   = function() { return 25 } // function to get the radius for voronoi point clips
    , xDomain      = null // Override x domain (skips the calculation from data)
    , yDomain      = null // Override y domain
    , xRange       = null // Override x range
    , yRange       = null // Override y range
    , sizeDomain   = null // Override point size domain
    , sizeRange    = null
    , singlePoint  = false
    , dispatch     = d3.dispatch('elementClick', 'elementMouseover', 'elementMouseout')
    , useVoronoi   = true
    ;

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var x0, y0, z0 // used to store previous scales
    , timeoutID
    , needsUpdate = false // Flag for when the points are visually updating, but the interactive layer is behind, to disable tooltips
    ;

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var availableWidth = width - margin.left - margin.right,
          availableHeight = height - margin.top - margin.bottom,
          container = d3.select(this);

      //add series index to each data point for reference
      data.forEach(function(series, i) {
        series.values.forEach(function(point) {
          point.series = i;
        });
      });

      //------------------------------------------------------------
      // Setup Scales

      // remap and flatten the data for use in calculating the scales' domains
      var seriesData = (xDomain && yDomain && sizeDomain) ? [] : // if we know xDomain and yDomain and sizeDomain, no need to calculate.... if Size is constant remember to set sizeDomain to speed up performance
            d3.merge(
              data.map(function(d) {
                return d.values.map(function(d,i) {
                  return { x: getX(d,i), y: getY(d,i), size: getSize(d,i) }
                })
              })
            );

      x   .domain(xDomain || d3.extent(seriesData.map(function(d) { return d.x; }).concat(forceX)))

      if (padData && data[0])
        x.range(xRange || [(availableWidth * padDataOuter +  availableWidth) / (2 *data[0].values.length), availableWidth - availableWidth * (1 + padDataOuter) / (2 * data[0].values.length)  ]);
        //x.range([availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
      else
        x.range(xRange || [0, availableWidth]);

      y   .domain(yDomain || d3.extent(seriesData.map(function(d) { return d.y }).concat(forceY)))
          .range(yRange || [availableHeight, 0]);

      z   .domain(sizeDomain || d3.extent(seriesData.map(function(d) { return d.size }).concat(forceSize)))
          .range(sizeRange || [16, 256]);

      // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
      if (x.domain()[0] === x.domain()[1] || y.domain()[0] === y.domain()[1]) singlePoint = true;
      if (x.domain()[0] === x.domain()[1])
        x.domain()[0] ?
            x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
          : x.domain([-1,1]);

      if (y.domain()[0] === y.domain()[1])
        y.domain()[0] ?
            y.domain([y.domain()[0] - y.domain()[0] * 0.01, y.domain()[1] + y.domain()[1] * 0.01])
          : y.domain([-1,1]);

      if ( isNaN(x.domain()[0])) {
          x.domain([-1,1]);
      }

      if ( isNaN(y.domain()[0])) {
          y.domain([-1,1]);
      }


      x0 = x0 || x;
      y0 = y0 || y;
      z0 = z0 || z;

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-scatter').data([data]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatter nv-chart-' + id + (singlePoint ? ' nv-single-point' : ''));
      var defsEnter = wrapEnter.append('defs');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-groups');
      gEnter.append('g').attr('class', 'nv-point-paths');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //------------------------------------------------------------


      defsEnter.append('clipPath')
          .attr('id', 'nv-edge-clip-' + id)
        .append('rect');

      wrap.select('#nv-edge-clip-' + id + ' rect')
          .attr('width', availableWidth)
          .attr('height', (availableHeight > 0) ? availableHeight : 0);

      g   .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');


      function updateInteractiveLayer() {

        if (!interactive) return false;

        var eventElements;

        var vertices = d3.merge(data.map(function(group, groupIndex) {
            return group.values
              .map(function(point, pointIndex) {
                // *Adding noise to make duplicates very unlikely
                // *Injecting series and point index for reference
                /* *Adding a 'jitter' to the points, because there's an issue in d3.geom.voronoi.
                */
                var pX = getX(point,pointIndex);
                var pY = getY(point,pointIndex);

                return [x(pX)+ Math.random() * 1e-7,
                        y(pY)+ Math.random() * 1e-7,
                        groupIndex,
                        pointIndex, point]; //temp hack to add noise untill I think of a better way so there are no duplicates
              })
              .filter(function(pointArray, pointIndex) {
                return pointActive(pointArray[4], pointIndex); // Issue #237.. move filter to after map, so pointIndex is correct!
              })
          })
        );



        //inject series and point index for reference into voronoi
        if (useVoronoi === true) {

          if (clipVoronoi) {
            var pointClipsEnter = wrap.select('defs').selectAll('.nv-point-clips')
                .data([id])
              .enter();

            pointClipsEnter.append('clipPath')
                  .attr('class', 'nv-point-clips')
                  .attr('id', 'nv-points-clip-' + id);

            var pointClips = wrap.select('#nv-points-clip-' + id).selectAll('circle')
                .data(vertices);
            pointClips.enter().append('circle')
                .attr('r', clipRadius);
            pointClips.exit().remove();
            pointClips
                .attr('cx', function(d) { return d[0] })
                .attr('cy', function(d) { return d[1] });

            wrap.select('.nv-point-paths')
                .attr('clip-path', 'url(#nv-points-clip-' + id + ')');
          }


          if(vertices.length) {
            // Issue #283 - Adding 2 dummy points to the voronoi b/c voronoi requires min 3 points to work
            vertices.push([x.range()[0] - 20, y.range()[0] - 20, null, null]);
            vertices.push([x.range()[1] + 20, y.range()[1] + 20, null, null]);
            vertices.push([x.range()[0] - 20, y.range()[0] + 20, null, null]);
            vertices.push([x.range()[1] + 20, y.range()[1] - 20, null, null]);
          }

          var bounds = d3.geom.polygon([
              [-10,-10],
              [-10,height + 10],
              [width + 10,height + 10],
              [width + 10,-10]
          ]);

          var voronoi = d3.geom.voronoi(vertices).map(function(d, i) {
              return {
                'data': bounds.clip(d),
                'series': vertices[i][2],
                'point': vertices[i][3]
              }
            });


          var pointPaths = wrap.select('.nv-point-paths').selectAll('path')
              .data(voronoi);
          pointPaths.enter().append('path')
              .attr('class', function(d,i) { return 'nv-path-'+i; });
          pointPaths.exit().remove();
          pointPaths
              .attr('d', function(d) {
                if (d.data.length === 0)
                    return 'M 0 0'
                else
                    return 'M' + d.data.join('L') + 'Z';
              });

          var mouseEventCallback = function(d,mDispatch) {
                if (needsUpdate) return 0;
                var series = data[d.series];
                if (typeof series === 'undefined') return;

                var point  = series.values[d.point];

                mDispatch({
                  point: point,
                  series: series,
                  pos: [x(getX(point, d.point)) + margin.left, y(getY(point, d.point)) + margin.top],
                  seriesIndex: d.series,
                  pointIndex: d.point
                });
          };

          pointPaths
              .on('click', function(d) {
                mouseEventCallback(d, dispatch.elementClick);
              })
              .on('mouseover', function(d) {
                mouseEventCallback(d, dispatch.elementMouseover);
              })
              .on('mouseout', function(d, i) {
                mouseEventCallback(d, dispatch.elementMouseout);
              });


        } else {
          /*
          // bring data in form needed for click handlers
          var dataWithPoints = vertices.map(function(d, i) {
              return {
                'data': d,
                'series': vertices[i][2],
                'point': vertices[i][3]
              }
            });
           */

          // add event handlers to points instead voronoi paths
          wrap.select('.nv-groups').selectAll('.nv-group')
            .selectAll('.nv-point')
              //.data(dataWithPoints)
              //.style('pointer-events', 'auto') // recativate events, disabled by css
              .on('click', function(d,i) {
                //nv.log('test', d, i);
                if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point
                var series = data[d.series],
                    point  = series.values[i];

                dispatch.elementClick({
                  point: point,
                  series: series,
                  pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],
                  seriesIndex: d.series,
                  pointIndex: i
                });
              })
              .on('mouseover', function(d,i) {
                if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point
                var series = data[d.series],
                    point  = series.values[i];

                dispatch.elementMouseover({
                  point: point,
                  series: series,
                  pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],
                  seriesIndex: d.series,
                  pointIndex: i
                });
              })
              .on('mouseout', function(d,i) {
                if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point
                var series = data[d.series],
                    point  = series.values[i];

                dispatch.elementMouseout({
                  point: point,
                  series: series,
                  seriesIndex: d.series,
                  pointIndex: i
                });
              });
          }

          needsUpdate = false;
      }

      needsUpdate = true;

      var groups = wrap.select('.nv-groups').selectAll('.nv-group')
          .data(function(d) { return d }, function(d) { return d.key });
      groups.enter().append('g')
          .style('stroke-opacity', 1e-6)
          .style('fill-opacity', 1e-6);
      groups.exit()
          .remove();
      groups
          .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
          .classed('hover', function(d) { return d.hover });
      groups
          .transition()
          .style('fill', function(d,i) { return color(d, i) })
          .style('stroke', function(d,i) { return color(d, i) })
          .style('stroke-opacity', 1)
          .style('fill-opacity', .5);


      if (onlyCircles) {

        var points = groups.selectAll('circle.nv-point')
            .data(function(d) { return d.values }, pointKey);
        points.enter().append('circle')
            .style('fill', function (d,i) { return d.color })
            .style('stroke', function (d,i) { return d.color })
            .attr('cx', function(d,i) { return nv.utils.NaNtoZero(x0(getX(d,i))) })
            .attr('cy', function(d,i) { return nv.utils.NaNtoZero(y0(getY(d,i))) })
            .attr('r', function(d,i) { return Math.sqrt(z(getSize(d,i))/Math.PI) });
        points.exit().remove();
        groups.exit().selectAll('path.nv-point').transition()
            .attr('cx', function(d,i) { return nv.utils.NaNtoZero(x(getX(d,i))) })
            .attr('cy', function(d,i) { return nv.utils.NaNtoZero(y(getY(d,i))) })
            .remove();
        points.each(function(d,i) {
          d3.select(this)
            .classed('nv-point', true)
            .classed('nv-point-' + i, true)
            .classed('hover',false)
            ;
        });
        points.transition()
            .attr('cx', function(d,i) { return nv.utils.NaNtoZero(x(getX(d,i))) })
            .attr('cy', function(d,i) { return nv.utils.NaNtoZero(y(getY(d,i))) })
            .attr('r', function(d,i) { return Math.sqrt(z(getSize(d,i))/Math.PI) });

      } else {

        var points = groups.selectAll('path.nv-point')
            .data(function(d) { return d.values });
        points.enter().append('path')
            .style('fill', function (d,i) { return d.color })
            .style('stroke', function (d,i) { return d.color })
            .attr('transform', function(d,i) {
              return 'translate(' + x0(getX(d,i)) + ',' + y0(getY(d,i)) + ')'
            })
            .attr('d',
              d3.svg.symbol()
                .type(getShape)
                .size(function(d,i) { return z(getSize(d,i)) })
            );
        points.exit().remove();
        groups.exit().selectAll('path.nv-point')
            .transition()
            .attr('transform', function(d,i) {
              return 'translate(' + x(getX(d,i)) + ',' + y(getY(d,i)) + ')'
            })
            .remove();
        points.each(function(d,i) {
          d3.select(this)
            .classed('nv-point', true)
            .classed('nv-point-' + i, true)
            .classed('hover',false)
            ;
        });
        points.transition()
            .attr('transform', function(d,i) {
              //nv.log(d,i,getX(d,i), x(getX(d,i)));
              return 'translate(' + x(getX(d,i)) + ',' + y(getY(d,i)) + ')'
            })
            .attr('d',
              d3.svg.symbol()
                .type(getShape)
                .size(function(d,i) { return z(getSize(d,i)) })
            );
      }


      // Delay updating the invisible interactive layer for smoother animation
      clearTimeout(timeoutID); // stop repeat calls to updateInteractiveLayer
      timeoutID = setTimeout(updateInteractiveLayer, 300);
      //updateInteractiveLayer();

      //store old scales for use in transitions on update
      x0 = x.copy();
      y0 = y.copy();
      z0 = z.copy();

    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------
  chart.clearHighlights = function() {
      //Remove the 'hover' class from all highlighted points.
      d3.selectAll(".nv-chart-" + id + " .nv-point.hover").classed("hover",false);
  };

  chart.highlightPoint = function(seriesIndex,pointIndex,isHoverOver) {
      d3.select(".nv-chart-" + id + " .nv-series-" + seriesIndex + " .nv-point-" + pointIndex)
          .classed("hover",isHoverOver);
  };


  dispatch.on('elementMouseover.point', function(d) {
     if (interactive) chart.highlightPoint(d.seriesIndex,d.pointIndex,true);
  });

  dispatch.on('elementMouseout.point', function(d) {
     if (interactive) chart.highlightPoint(d.seriesIndex,d.pointIndex,false);
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  chart.dispatch = dispatch;
  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = d3.functor(_);
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = d3.functor(_);
    return chart;
  };

  chart.size = function(_) {
    if (!arguments.length) return getSize;
    getSize = d3.functor(_);
    return chart;
  };

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.xScale = function(_) {
    if (!arguments.length) return x;
    x = _;
    return chart;
  };

  chart.yScale = function(_) {
    if (!arguments.length) return y;
    y = _;
    return chart;
  };

  chart.zScale = function(_) {
    if (!arguments.length) return z;
    z = _;
    return chart;
  };

  chart.xDomain = function(_) {
    if (!arguments.length) return xDomain;
    xDomain = _;
    return chart;
  };

  chart.yDomain = function(_) {
    if (!arguments.length) return yDomain;
    yDomain = _;
    return chart;
  };

  chart.sizeDomain = function(_) {
    if (!arguments.length) return sizeDomain;
    sizeDomain = _;
    return chart;
  };

  chart.xRange = function(_) {
    if (!arguments.length) return xRange;
    xRange = _;
    return chart;
  };

  chart.yRange = function(_) {
    if (!arguments.length) return yRange;
    yRange = _;
    return chart;
  };

  chart.sizeRange = function(_) {
    if (!arguments.length) return sizeRange;
    sizeRange = _;
    return chart;
  };

  chart.forceX = function(_) {
    if (!arguments.length) return forceX;
    forceX = _;
    return chart;
  };

  chart.forceY = function(_) {
    if (!arguments.length) return forceY;
    forceY = _;
    return chart;
  };

  chart.forceSize = function(_) {
    if (!arguments.length) return forceSize;
    forceSize = _;
    return chart;
  };

  chart.interactive = function(_) {
    if (!arguments.length) return interactive;
    interactive = _;
    return chart;
  };

  chart.pointKey = function(_) {
    if (!arguments.length) return pointKey;
    pointKey = _;
    return chart;
  };

  chart.pointActive = function(_) {
    if (!arguments.length) return pointActive;
    pointActive = _;
    return chart;
  };

  chart.padData = function(_) {
    if (!arguments.length) return padData;
    padData = _;
    return chart;
  };

  chart.padDataOuter = function(_) {
    if (!arguments.length) return padDataOuter;
    padDataOuter = _;
    return chart;
  };

  chart.clipEdge = function(_) {
    if (!arguments.length) return clipEdge;
    clipEdge = _;
    return chart;
  };

  chart.clipVoronoi= function(_) {
    if (!arguments.length) return clipVoronoi;
    clipVoronoi = _;
    return chart;
  };

  chart.useVoronoi= function(_) {
    if (!arguments.length) return useVoronoi;
    useVoronoi = _;
    if (useVoronoi === false) {
        clipVoronoi = false;
    }
    return chart;
  };

  chart.clipRadius = function(_) {
    if (!arguments.length) return clipRadius;
    clipRadius = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    return chart;
  };

  chart.shape = function(_) {
    if (!arguments.length) return getShape;
    getShape = _;
    return chart;
  };

  chart.onlyCircles = function(_) {
    if (!arguments.length) return onlyCircles;
    onlyCircles = _;
    return chart;
  };

  chart.id = function(_) {
    if (!arguments.length) return id;
    id = _;
    return chart;
  };

  chart.singlePoint = function(_) {
    if (!arguments.length) return singlePoint;
    singlePoint = _;
    return chart;
  };

  //============================================================


  return chart;
}
nv.models.scatterChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var scatter      = nv.models.scatter()
    , xAxis        = nv.models.axis()
    , yAxis        = nv.models.axis()
    , legend       = nv.models.legend()
    , controls     = nv.models.legend()
    , distX        = nv.models.distribution()
    , distY        = nv.models.distribution()
    ;

  var margin       = {top: 30, right: 20, bottom: 50, left: 75}
    , width        = null
    , height       = null
    , color        = nv.utils.defaultColor()
    , x            = d3.fisheye ? d3.fisheye.scale(d3.scale.linear).distortion(0) : scatter.xScale()
    , y            = d3.fisheye ? d3.fisheye.scale(d3.scale.linear).distortion(0) : scatter.yScale()
    , xPadding     = 0
    , yPadding     = 0
    , showDistX    = false
    , showDistY    = false
    , showLegend   = true
    , showXAxis    = true
    , showYAxis    = true
    , rightAlignYAxis = false
    , showControls = !!d3.fisheye
    , fisheye      = 0
    , pauseFisheye = false
    , tooltips     = true
    , tooltipX     = function(key, x, y) { return '<strong>' + x + '</strong>' }
    , tooltipY     = function(key, x, y) { return '<strong>' + y + '</strong>' }
    , tooltip      = null
    , state = {}
    , defaultState = null
    , dispatch     = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    , noData       = "No Data Available."
    , transitionDuration = 250
    ;

  scatter
    .xScale(x)
    .yScale(y)
    ;
  xAxis
    .orient('bottom')
    .tickPadding(10)
    ;
  yAxis
    .orient((rightAlignYAxis) ? 'right' : 'left')
    .tickPadding(10)
    ;
  distX
    .axis('x')
    ;
  distY
    .axis('y')
    ;

  controls.updateState(false);

  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var x0, y0;

  var showTooltip = function(e, offsetElement) {
    //TODO: make tooltip style an option between single or dual on axes (maybe on all charts with axes?)

    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        leftX = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        topX = y.range()[0] + margin.top + ( offsetElement.offsetTop || 0),
        leftY = x.range()[0] + margin.left + ( offsetElement.offsetLeft || 0 ),
        topY = e.pos[1] + ( offsetElement.offsetTop || 0),
        xVal = xAxis.tickFormat()(scatter.x()(e.point, e.pointIndex)),
        yVal = yAxis.tickFormat()(scatter.y()(e.point, e.pointIndex));

      if( tooltipX != null )
          nv.tooltip.show([leftX, topX], tooltipX(e.series.key, xVal, yVal, e, chart), 'n', 1, offsetElement, 'x-nvtooltip');
      if( tooltipY != null )
          nv.tooltip.show([leftY, topY], tooltipY(e.series.key, xVal, yVal, e, chart), 'e', 1, offsetElement, 'y-nvtooltip');
      if( tooltip != null )
          nv.tooltip.show([left, top], tooltip(e.series.key, xVal, yVal, e, chart), e.value < 0 ? 'n' : 's', null, offsetElement);
  };

  var controlsData = [
    { key: 'Magnify', disabled: true }
  ];

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;

      chart.update = function() { container.transition().duration(transitionDuration).call(chart); };
      chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });

      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }

      //------------------------------------------------------------
      // Display noData message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x0 = x0 || x;
      y0 = y0 || y;

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-scatterChart').data([data]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatterChart nv-chart-' + scatter.id());
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      // background for pointer events
      gEnter.append('rect').attr('class', 'nvd3 nv-background');

      gEnter.append('g').attr('class', 'nv-x nv-axis');
      gEnter.append('g').attr('class', 'nv-y nv-axis');
      gEnter.append('g').attr('class', 'nv-scatterWrap');
      gEnter.append('g').attr('class', 'nv-distWrap');
      gEnter.append('g').attr('class', 'nv-legendWrap');
      gEnter.append('g').attr('class', 'nv-controlsWrap');

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        var legendWidth = (showControls) ? availableWidth / 2 : availableWidth;
        legend.width(legendWidth);

        wrap.select('.nv-legendWrap')
            .datum(data)
            .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }

        wrap.select('.nv-legendWrap')
            .attr('transform', 'translate(' + (availableWidth - legendWidth) + ',' + (-margin.top) +')');
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Controls

      if (showControls) {
        controls.width(180).color(['#444']);
        g.select('.nv-controlsWrap')
            .datum(controlsData)
            .attr('transform', 'translate(0,' + (-margin.top) +')')
            .call(controls);
      }

      //------------------------------------------------------------


      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      if (rightAlignYAxis) {
          g.select(".nv-y.nv-axis")
              .attr("transform", "translate(" + availableWidth + ",0)");
      }

      //------------------------------------------------------------
      // Main Chart Component(s)

      scatter
          .width(availableWidth)
          .height(availableHeight)
          .color(data.map(function(d,i) {
            return d.color || color(d, i);
          }).filter(function(d,i) { return !data[i].disabled }));

      if (xPadding !== 0)
        scatter.xDomain(null);

      if (yPadding !== 0)
        scatter.yDomain(null);

      wrap.select('.nv-scatterWrap')
          .datum(data.filter(function(d) { return !d.disabled }))
          .call(scatter);

      //Adjust for x and y padding
      if (xPadding !== 0) {
        var xRange = x.domain()[1] - x.domain()[0];
        scatter.xDomain([x.domain()[0] - (xPadding * xRange), x.domain()[1] + (xPadding * xRange)]);
      }

      if (yPadding !== 0) {
        var yRange = y.domain()[1] - y.domain()[0];
        scatter.yDomain([y.domain()[0] - (yPadding * yRange), y.domain()[1] + (yPadding * yRange)]);
      }

      //Only need to update the scatter again if x/yPadding changed the domain.
      if (yPadding !== 0 || xPadding !== 0) {
        wrap.select('.nv-scatterWrap')
            .datum(data.filter(function(d) { return !d.disabled }))
            .call(scatter);
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Axes
      if (showXAxis) {
        xAxis
            .scale(x)
            .ticks( xAxis.ticks() && xAxis.ticks().length ? xAxis.ticks() : availableWidth / 100 )
            .tickSize( -availableHeight , 0);

        g.select('.nv-x.nv-axis')
            .attr('transform', 'translate(0,' + y.range()[0] + ')')
            .call(xAxis);

      }

      if (showYAxis) {
        yAxis
            .scale(y)
            .ticks( yAxis.ticks() && yAxis.ticks().length ? yAxis.ticks() : availableHeight / 36 )
            .tickSize( -availableWidth, 0);

        g.select('.nv-y.nv-axis')
            .call(yAxis);
      }


      if (showDistX) {
        distX
            .getData(scatter.x())
            .scale(x)
            .width(availableWidth)
            .color(data.map(function(d,i) {
              return d.color || color(d, i);
            }).filter(function(d,i) { return !data[i].disabled }));
        gEnter.select('.nv-distWrap').append('g')
            .attr('class', 'nv-distributionX');
        g.select('.nv-distributionX')
            .attr('transform', 'translate(0,' + y.range()[0] + ')')
            .datum(data.filter(function(d) { return !d.disabled }))
            .call(distX);
      }

      if (showDistY) {
        distY
            .getData(scatter.y())
            .scale(y)
            .width(availableHeight)
            .color(data.map(function(d,i) {
              return d.color || color(d, i);
            }).filter(function(d,i) { return !data[i].disabled }));
        gEnter.select('.nv-distWrap').append('g')
            .attr('class', 'nv-distributionY');
        g.select('.nv-distributionY')
            .attr('transform', 
              'translate(' + (rightAlignYAxis ? availableWidth : -distY.size() ) + ',0)')
            .datum(data.filter(function(d) { return !d.disabled }))
            .call(distY);
      }

      //------------------------------------------------------------




      if (d3.fisheye) {
        g.select('.nv-background')
            .attr('width', availableWidth)
            .attr('height', availableHeight);

        g.select('.nv-background').on('mousemove', updateFisheye);
        g.select('.nv-background').on('click', function() { pauseFisheye = !pauseFisheye;});
        scatter.dispatch.on('elementClick.freezeFisheye', function() {
          pauseFisheye = !pauseFisheye;
        });
      }


      function updateFisheye() {
        if (pauseFisheye) {
          g.select('.nv-point-paths').style('pointer-events', 'all');
          return false;
        }

        g.select('.nv-point-paths').style('pointer-events', 'none' );

        var mouse = d3.mouse(this);
        x.distortion(fisheye).focus(mouse[0]);
        y.distortion(fisheye).focus(mouse[1]);

        g.select('.nv-scatterWrap')
            .call(scatter);

        if (showXAxis)
          g.select('.nv-x.nv-axis').call(xAxis);
        
        if (showYAxis)
          g.select('.nv-y.nv-axis').call(yAxis);
        
        g.select('.nv-distributionX')
            .datum(data.filter(function(d) { return !d.disabled }))
            .call(distX);
        g.select('.nv-distributionY')
            .datum(data.filter(function(d) { return !d.disabled }))
            .call(distY);
      }



      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      controls.dispatch.on('legendClick', function(d,i) {
        d.disabled = !d.disabled;

        fisheye = d.disabled ? 0 : 2.5;
        g.select('.nv-background') .style('pointer-events', d.disabled ? 'none' : 'all');
        g.select('.nv-point-paths').style('pointer-events', d.disabled ? 'all' : 'none' );

        if (d.disabled) {
          x.distortion(fisheye).focus(0);
          y.distortion(fisheye).focus(0);

          g.select('.nv-scatterWrap').call(scatter);
          g.select('.nv-x.nv-axis').call(xAxis);
          g.select('.nv-y.nv-axis').call(yAxis);
        } else {
          pauseFisheye = false;
        }

        chart.update();
      });

      legend.dispatch.on('stateChange', function(newState) {
        state.disabled = newState.disabled;
        dispatch.stateChange(state);
        chart.update();
      });

      scatter.dispatch.on('elementMouseover.tooltip', function(e) {
        d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-distx-' + e.pointIndex)
            .attr('y1', function(d,i) { return e.pos[1] - availableHeight;});
        d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-disty-' + e.pointIndex)
            .attr('x2', e.pos[0] + distX.size());

        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode);
      });

      // Update chart from a state object passed to event handler
      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined') {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }

        chart.update();
      });

      //============================================================


      //store old scales for use in transitions on update
      x0 = x.copy();
      y0 = y.copy();


    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  scatter.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);

    d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-distx-' + e.pointIndex)
        .attr('y1', 0);
    d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-disty-' + e.pointIndex)
        .attr('x2', distY.size());
  });
  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.scatter = scatter;
  chart.legend = legend;
  chart.controls = controls;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;
  chart.distX = distX;
  chart.distY = distY;

  d3.rebind(chart, scatter, 'id', 'interactive', 'pointActive', 'x', 'y', 'shape', 'size', 'xScale', 'yScale', 'zScale', 'xDomain', 'yDomain', 'xRange', 'yRange', 'sizeDomain', 'sizeRange', 'forceX', 'forceY', 'forceSize', 'clipVoronoi', 'clipRadius', 'useVoronoi');
  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    distX.color(color);
    distY.color(color);
    return chart;
  };

  chart.showDistX = function(_) {
    if (!arguments.length) return showDistX;
    showDistX = _;
    return chart;
  };

  chart.showDistY = function(_) {
    if (!arguments.length) return showDistY;
    showDistY = _;
    return chart;
  };

  chart.showControls = function(_) {
    if (!arguments.length) return showControls;
    showControls = _;
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.showXAxis = function(_) {
    if (!arguments.length) return showXAxis;
    showXAxis = _;
    return chart;
  };

  chart.showYAxis = function(_) {
    if (!arguments.length) return showYAxis;
    showYAxis = _;
    return chart;
  };

  chart.rightAlignYAxis = function(_) {
    if(!arguments.length) return rightAlignYAxis;
    rightAlignYAxis = _;
    yAxis.orient( (_) ? 'right' : 'left');
    return chart;
  };


  chart.fisheye = function(_) {
    if (!arguments.length) return fisheye;
    fisheye = _;
    return chart;
  };

  chart.xPadding = function(_) {
    if (!arguments.length) return xPadding;
    xPadding = _;
    return chart;
  };

  chart.yPadding = function(_) {
    if (!arguments.length) return yPadding;
    yPadding = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.tooltipXContent = function(_) {
    if (!arguments.length) return tooltipX;
    tooltipX = _;
    return chart;
  };

  chart.tooltipYContent = function(_) {
    if (!arguments.length) return tooltipY;
    tooltipY = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };
  
  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.scatterPlusLineChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var scatter      = nv.models.scatter()
    , xAxis        = nv.models.axis()
    , yAxis        = nv.models.axis()
    , legend       = nv.models.legend()
    , controls     = nv.models.legend()
    , distX        = nv.models.distribution()
    , distY        = nv.models.distribution()
    ;

  var margin       = {top: 30, right: 20, bottom: 50, left: 75}
    , width        = null
    , height       = null
    , color        = nv.utils.defaultColor()
    , x            = d3.fisheye ? d3.fisheye.scale(d3.scale.linear).distortion(0) : scatter.xScale()
    , y            = d3.fisheye ? d3.fisheye.scale(d3.scale.linear).distortion(0) : scatter.yScale()
    , showDistX    = false
    , showDistY    = false
    , showLegend   = true
    , showXAxis    = true
    , showYAxis    = true
    , rightAlignYAxis = false
    , showControls = !!d3.fisheye
    , fisheye      = 0
    , pauseFisheye = false
    , tooltips     = true
    , tooltipX     = function(key, x, y) { return '<strong>' + x + '</strong>' }
    , tooltipY     = function(key, x, y) { return '<strong>' + y + '</strong>' }
    , tooltip      = function(key, x, y, date) { return '<h3>' + key + '</h3>' 
                                                      + '<p>' + date + '</p>' }
    , state = {}
    , defaultState = null
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    , noData       = "No Data Available."
    , transitionDuration = 250
    ;

  scatter
    .xScale(x)
    .yScale(y)
    ;
  xAxis
    .orient('bottom')
    .tickPadding(10)
    ;
  yAxis
    .orient((rightAlignYAxis) ? 'right' : 'left')
    .tickPadding(10)
    ;
  distX
    .axis('x')
    ;
  distY
    .axis('y')
    ;
  
  controls.updateState(false);
  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var x0, y0;

  var showTooltip = function(e, offsetElement) {
    //TODO: make tooltip style an option between single or dual on axes (maybe on all charts with axes?)

    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        leftX = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        topX = y.range()[0] + margin.top + ( offsetElement.offsetTop || 0),
        leftY = x.range()[0] + margin.left + ( offsetElement.offsetLeft || 0 ),
        topY = e.pos[1] + ( offsetElement.offsetTop || 0),
        xVal = xAxis.tickFormat()(scatter.x()(e.point, e.pointIndex)),
        yVal = yAxis.tickFormat()(scatter.y()(e.point, e.pointIndex));

      if( tooltipX != null )
          nv.tooltip.show([leftX, topX], tooltipX(e.series.key, xVal, yVal, e, chart), 'n', 1, offsetElement, 'x-nvtooltip');
      if( tooltipY != null )
          nv.tooltip.show([leftY, topY], tooltipY(e.series.key, xVal, yVal, e, chart), 'e', 1, offsetElement, 'y-nvtooltip');
      if( tooltip != null )
          nv.tooltip.show([left, top], tooltip(e.series.key, xVal, yVal, e.point.tooltip, e, chart), e.value < 0 ? 'n' : 's', null, offsetElement);
  };

  var controlsData = [
    { key: 'Magnify', disabled: true }
  ];

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;

      chart.update = function() { container.transition().duration(transitionDuration).call(chart); };
      chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });

      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }

      //------------------------------------------------------------
      // Display noData message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x = scatter.xScale();
      y = scatter.yScale();

      x0 = x0 || x;
      y0 = y0 || y;

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-scatterChart').data([data]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatterChart nv-chart-' + scatter.id());
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g')

      // background for pointer events
      gEnter.append('rect').attr('class', 'nvd3 nv-background').style("pointer-events","none");

      gEnter.append('g').attr('class', 'nv-x nv-axis');
      gEnter.append('g').attr('class', 'nv-y nv-axis');
      gEnter.append('g').attr('class', 'nv-scatterWrap');
      gEnter.append('g').attr('class', 'nv-regressionLinesWrap');
      gEnter.append('g').attr('class', 'nv-distWrap');
      gEnter.append('g').attr('class', 'nv-legendWrap');
      gEnter.append('g').attr('class', 'nv-controlsWrap');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      if (rightAlignYAxis) {
          g.select(".nv-y.nv-axis")
              .attr("transform", "translate(" + availableWidth + ",0)");
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend.width( availableWidth / 2 );

        wrap.select('.nv-legendWrap')
            .datum(data)
            .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }

        wrap.select('.nv-legendWrap')
            .attr('transform', 'translate(' + (availableWidth / 2) + ',' + (-margin.top) +')');
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Controls

      if (showControls) {
        controls.width(180).color(['#444']);
        g.select('.nv-controlsWrap')
            .datum(controlsData)
            .attr('transform', 'translate(0,' + (-margin.top) +')')
            .call(controls);
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Main Chart Component(s)

      scatter
          .width(availableWidth)
          .height(availableHeight)
          .color(data.map(function(d,i) {
            return d.color || color(d, i);
          }).filter(function(d,i) { return !data[i].disabled }))

      wrap.select('.nv-scatterWrap')
          .datum(data.filter(function(d) { return !d.disabled }))
          .call(scatter);

      wrap.select('.nv-regressionLinesWrap')
          .attr('clip-path', 'url(#nv-edge-clip-' + scatter.id() + ')');

      var regWrap = wrap.select('.nv-regressionLinesWrap').selectAll('.nv-regLines')
                      .data(function(d) {return d });
      
      regWrap.enter().append('g').attr('class', 'nv-regLines');

      var regLine = regWrap.selectAll('.nv-regLine').data(function(d){return [d]});
      var regLineEnter = regLine.enter()
                       .append('line').attr('class', 'nv-regLine')
                       .style('stroke-opacity', 0);

      regLine
          .transition()
          .attr('x1', x.range()[0])
          .attr('x2', x.range()[1])
          .attr('y1', function(d,i) {return y(x.domain()[0] * d.slope + d.intercept) })
          .attr('y2', function(d,i) { return y(x.domain()[1] * d.slope + d.intercept) })
          .style('stroke', function(d,i,j) { return color(d,j) })
          .style('stroke-opacity', function(d,i) {
            return (d.disabled || typeof d.slope === 'undefined' || typeof d.intercept === 'undefined') ? 0 : 1 
          });

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Axes

      if (showXAxis) {
        xAxis
            .scale(x)
            .ticks( xAxis.ticks() ? xAxis.ticks() : availableWidth / 100 )
            .tickSize( -availableHeight , 0);

        g.select('.nv-x.nv-axis')
            .attr('transform', 'translate(0,' + y.range()[0] + ')')
            .call(xAxis);
      }

      if (showYAxis) {
        yAxis
            .scale(y)
            .ticks( yAxis.ticks() ? yAxis.ticks() : availableHeight / 36 )
            .tickSize( -availableWidth, 0);

        g.select('.nv-y.nv-axis')
            .call(yAxis);
      }


      if (showDistX) {
        distX
            .getData(scatter.x())
            .scale(x)
            .width(availableWidth)
            .color(data.map(function(d,i) {
              return d.color || color(d, i);
            }).filter(function(d,i) { return !data[i].disabled }));
        gEnter.select('.nv-distWrap').append('g')
            .attr('class', 'nv-distributionX');
        g.select('.nv-distributionX')
            .attr('transform', 'translate(0,' + y.range()[0] + ')')
            .datum(data.filter(function(d) { return !d.disabled }))
            .call(distX);
      }

      if (showDistY) {
        distY
            .getData(scatter.y())
            .scale(y)
            .width(availableHeight)
            .color(data.map(function(d,i) {
              return d.color || color(d, i);
            }).filter(function(d,i) { return !data[i].disabled }));
        gEnter.select('.nv-distWrap').append('g')
            .attr('class', 'nv-distributionY');
        g.select('.nv-distributionY')
            .attr('transform', 'translate(' + (rightAlignYAxis ? availableWidth : -distY.size() ) + ',0)')
            .datum(data.filter(function(d) { return !d.disabled }))
            .call(distY);
      }

      //------------------------------------------------------------




      if (d3.fisheye) {
        g.select('.nv-background')
            .attr('width', availableWidth)
            .attr('height', availableHeight)
            ;

        g.select('.nv-background').on('mousemove', updateFisheye);
        g.select('.nv-background').on('click', function() { pauseFisheye = !pauseFisheye;});
        scatter.dispatch.on('elementClick.freezeFisheye', function() {
          pauseFisheye = !pauseFisheye;
        });
      }


      function updateFisheye() {
        if (pauseFisheye) {
          g.select('.nv-point-paths').style('pointer-events', 'all');
          return false;
        }

        g.select('.nv-point-paths').style('pointer-events', 'none' );

        var mouse = d3.mouse(this);
        x.distortion(fisheye).focus(mouse[0]);
        y.distortion(fisheye).focus(mouse[1]);

        g.select('.nv-scatterWrap')
            .datum(data.filter(function(d) { return !d.disabled }))
            .call(scatter);

        if (showXAxis)
          g.select('.nv-x.nv-axis').call(xAxis);

        if (showYAxis)
          g.select('.nv-y.nv-axis').call(yAxis);
        
        g.select('.nv-distributionX')
            .datum(data.filter(function(d) { return !d.disabled }))
            .call(distX);
        g.select('.nv-distributionY')
            .datum(data.filter(function(d) { return !d.disabled }))
            .call(distY);
      }



      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      controls.dispatch.on('legendClick', function(d,i) {
        d.disabled = !d.disabled;

        fisheye = d.disabled ? 0 : 2.5;
        g.select('.nv-background') .style('pointer-events', d.disabled ? 'none' : 'all');
        g.select('.nv-point-paths').style('pointer-events', d.disabled ? 'all' : 'none' );

        if (d.disabled) {
          x.distortion(fisheye).focus(0);
          y.distortion(fisheye).focus(0);

          g.select('.nv-scatterWrap').call(scatter);
          g.select('.nv-x.nv-axis').call(xAxis);
          g.select('.nv-y.nv-axis').call(yAxis);
        } else {
          pauseFisheye = false;
        }

        chart.update();
      });

      legend.dispatch.on('stateChange', function(newState) { 
        state = newState;
        dispatch.stateChange(state);
        chart.update();
      });


      scatter.dispatch.on('elementMouseover.tooltip', function(e) {
        d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-distx-' + e.pointIndex)
            .attr('y1', e.pos[1] - availableHeight);
        d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-disty-' + e.pointIndex)
            .attr('x2', e.pos[0] + distX.size());

        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode);
      });

      // Update chart from a state object passed to event handler
      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined') {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }

        chart.update();
      });

      //============================================================


      //store old scales for use in transitions on update
      x0 = x.copy();
      y0 = y.copy();


    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  scatter.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);

    d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-distx-' + e.pointIndex)
        .attr('y1', 0);
    d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-disty-' + e.pointIndex)
        .attr('x2', distY.size());
  });
  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.scatter = scatter;
  chart.legend = legend;
  chart.controls = controls;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;
  chart.distX = distX;
  chart.distY = distY;

  d3.rebind(chart, scatter, 'id', 'interactive', 'pointActive', 'x', 'y', 'shape', 'size', 'xScale', 'yScale', 'zScale', 'xDomain', 'yDomain', 'xRange', 'yRange', 'sizeDomain', 'sizeRange', 'forceX', 'forceY', 'forceSize', 'clipVoronoi', 'clipRadius', 'useVoronoi');

  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    distX.color(color);
    distY.color(color);
    return chart;
  };

  chart.showDistX = function(_) {
    if (!arguments.length) return showDistX;
    showDistX = _;
    return chart;
  };

  chart.showDistY = function(_) {
    if (!arguments.length) return showDistY;
    showDistY = _;
    return chart;
  };

  chart.showControls = function(_) {
    if (!arguments.length) return showControls;
    showControls = _;
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.showXAxis = function(_) {
    if (!arguments.length) return showXAxis;
    showXAxis = _;
    return chart;
  };

  chart.showYAxis = function(_) {
    if (!arguments.length) return showYAxis;
    showYAxis = _;
    return chart;
  };

  chart.rightAlignYAxis = function(_) {
    if(!arguments.length) return rightAlignYAxis;
    rightAlignYAxis = _;
    yAxis.orient( (_) ? 'right' : 'left');
    return chart;
  };

  chart.fisheye = function(_) {
    if (!arguments.length) return fisheye;
    fisheye = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.tooltipXContent = function(_) {
    if (!arguments.length) return tooltipX;
    tooltipX = _;
    return chart;
  };

  chart.tooltipYContent = function(_) {
    if (!arguments.length) return tooltipY;
    tooltipY = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.sparkline = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 2, right: 0, bottom: 2, left: 0}
    , width = 400
    , height = 32
    , animate = true
    , x = d3.scale.linear()
    , y = d3.scale.linear()
    , getX = function(d) { return d.x }
    , getY = function(d) { return d.y }
    , color = nv.utils.getColor(['#000'])
    , xDomain
    , yDomain
    , xRange
    , yRange
    ;

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var availableWidth = width - margin.left - margin.right,
          availableHeight = height - margin.top - margin.bottom,
          container = d3.select(this);


      //------------------------------------------------------------
      // Setup Scales

      x   .domain(xDomain || d3.extent(data, getX ))
          .range(xRange || [0, availableWidth]);

      y   .domain(yDomain || d3.extent(data, getY ))
          .range(yRange || [availableHeight, 0]);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-sparkline').data([data]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparkline');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

      //------------------------------------------------------------


      var paths = wrap.selectAll('path')
          .data(function(d) { return [d] });
      paths.enter().append('path');
      paths.exit().remove();
      paths
          .style('stroke', function(d,i) { return d.color || color(d, i) })
          .attr('d', d3.svg.line()
            .x(function(d,i) { return x(getX(d,i)) })
            .y(function(d,i) { return y(getY(d,i)) })
          );


      // TODO: Add CURRENT data point (Need Min, Mac, Current / Most recent)
      var points = wrap.selectAll('circle.nv-point')
          .data(function(data) {
              var yValues = data.map(function(d, i) { return getY(d,i); });
              function pointIndex(index) {
                  if (index != -1) {
	              var result = data[index];
                      result.pointIndex = index;
                      return result;
                  } else {
                      return null;
                  }
              }
              var maxPoint = pointIndex(yValues.lastIndexOf(y.domain()[1])),
                  minPoint = pointIndex(yValues.indexOf(y.domain()[0])),
                  currentPoint = pointIndex(yValues.length - 1);
              return [minPoint, maxPoint, currentPoint].filter(function (d) {return d != null;});
          });
      points.enter().append('circle');
      points.exit().remove();
      points
          .attr('cx', function(d,i) { return x(getX(d,d.pointIndex)) })
          .attr('cy', function(d,i) { return y(getY(d,d.pointIndex)) })
          .attr('r', 2)
          .attr('class', function(d,i) {
            return getX(d, d.pointIndex) == x.domain()[1] ? 'nv-point nv-currentValue' :
                   getY(d, d.pointIndex) == y.domain()[0] ? 'nv-point nv-minValue' : 'nv-point nv-maxValue'
          });
    });

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------
  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = d3.functor(_);
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = d3.functor(_);
    return chart;
  };

  chart.xScale = function(_) {
    if (!arguments.length) return x;
    x = _;
    return chart;
  };

  chart.yScale = function(_) {
    if (!arguments.length) return y;
    y = _;
    return chart;
  };

  chart.xDomain = function(_) {
    if (!arguments.length) return xDomain;
    xDomain = _;
    return chart;
  };

  chart.yDomain = function(_) {
    if (!arguments.length) return yDomain;
    yDomain = _;
    return chart;
  };

  chart.xRange = function(_) {
    if (!arguments.length) return xRange;
    xRange = _;
    return chart;
  };

  chart.yRange = function(_) {
    if (!arguments.length) return yRange;
    yRange = _;
    return chart;
  };

  chart.animate = function(_) {
    if (!arguments.length) return animate;
    animate = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.sparklinePlus = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var sparkline = nv.models.sparkline();

  var margin = {top: 15, right: 100, bottom: 10, left: 50}
    , width = null
    , height = null
    , x
    , y
    , index = []
    , paused = false
    , xTickFormat = d3.format(',r')
    , yTickFormat = d3.format(',.2f')
    , showValue = true
    , alignValue = true
    , rightAlignValue = false
    , noData = "No Data Available."
    ;

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this);

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;

      

      chart.update = function() { chart(selection) };
      chart.container = this;


      //------------------------------------------------------------
      // Display No Data message if there's nothing to show.

      if (!data || !data.length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      var currentValue = sparkline.y()(data[data.length-1], data.length-1);

      //------------------------------------------------------------



      //------------------------------------------------------------
      // Setup Scales

      x = sparkline.xScale();
      y = sparkline.yScale();

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-sparklineplus').data([data]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparklineplus');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-sparklineWrap');
      gEnter.append('g').attr('class', 'nv-valueWrap');
      gEnter.append('g').attr('class', 'nv-hoverArea');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Main Chart Component(s)

      var sparklineWrap = g.select('.nv-sparklineWrap');

      sparkline
        .width(availableWidth)
        .height(availableHeight);

      sparklineWrap
          .call(sparkline);

      //------------------------------------------------------------


      var valueWrap = g.select('.nv-valueWrap');
      
      var value = valueWrap.selectAll('.nv-currentValue')
          .data([currentValue]);

      value.enter().append('text').attr('class', 'nv-currentValue')
          .attr('dx', rightAlignValue ? -8 : 8)
          .attr('dy', '.9em')
          .style('text-anchor', rightAlignValue ? 'end' : 'start');

      value
          .attr('x', availableWidth + (rightAlignValue ? margin.right : 0))
          .attr('y', alignValue ? function(d) { return y(d) } : 0)
          .style('fill', sparkline.color()(data[data.length-1], data.length-1))
          .text(yTickFormat(currentValue));



      gEnter.select('.nv-hoverArea').append('rect')
          .on('mousemove', sparklineHover)
          .on('click', function() { paused = !paused })
          .on('mouseout', function() { index = []; updateValueLine(); });
          //.on('mouseout', function() { index = null; updateValueLine(); });

      g.select('.nv-hoverArea rect')
          .attr('transform', function(d) { return 'translate(' + -margin.left + ',' + -margin.top + ')' })
          .attr('width', availableWidth + margin.left + margin.right)
          .attr('height', availableHeight + margin.top);



      function updateValueLine() { //index is currently global (within the chart), may or may not keep it that way
        if (paused) return;

        var hoverValue = g.selectAll('.nv-hoverValue').data(index)

        var hoverEnter = hoverValue.enter()
          .append('g').attr('class', 'nv-hoverValue')
            .style('stroke-opacity', 0)
            .style('fill-opacity', 0);

        hoverValue.exit()
          .transition().duration(250)
            .style('stroke-opacity', 0)
            .style('fill-opacity', 0)
            .remove();

        hoverValue
            .attr('transform', function(d) { return 'translate(' + x(sparkline.x()(data[d],d)) + ',0)' })
          .transition().duration(250)
            .style('stroke-opacity', 1)
            .style('fill-opacity', 1);

        if (!index.length) return;

        hoverEnter.append('line')
            .attr('x1', 0)
            .attr('y1', -margin.top)
            .attr('x2', 0)
            .attr('y2', availableHeight);


        hoverEnter.append('text').attr('class', 'nv-xValue')
            .attr('x', -6)
            .attr('y', -margin.top)
            .attr('text-anchor', 'end')
            .attr('dy', '.9em')


        g.select('.nv-hoverValue .nv-xValue')
            .text(xTickFormat(sparkline.x()(data[index[0]], index[0])));

        hoverEnter.append('text').attr('class', 'nv-yValue')
            .attr('x', 6)
            .attr('y', -margin.top)
            .attr('text-anchor', 'start')
            .attr('dy', '.9em')

        g.select('.nv-hoverValue .nv-yValue')
            .text(yTickFormat(sparkline.y()(data[index[0]], index[0])));

      }


      function sparklineHover() {
        if (paused) return;

        var pos = d3.mouse(this)[0] - margin.left;

        function getClosestIndex(data, x) {
          var distance = Math.abs(sparkline.x()(data[0], 0) - x);
          var closestIndex = 0;
          for (var i = 0; i < data.length; i++){
            if (Math.abs(sparkline.x()(data[i], i) - x) < distance) {
              distance = Math.abs(sparkline.x()(data[i], i) - x);
              closestIndex = i;
            }
          }
          return closestIndex;
        }

        index = [getClosestIndex(data, Math.round(x.invert(pos)))];

        updateValueLine();
      }

    });

    return chart;
  }


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.sparkline = sparkline;

  d3.rebind(chart, sparkline, 'x', 'y', 'xScale', 'yScale', 'color');

  chart.options = nv.utils.optionsFunc.bind(chart);
  
  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.xTickFormat = function(_) {
    if (!arguments.length) return xTickFormat;
    xTickFormat = _;
    return chart;
  };

  chart.yTickFormat = function(_) {
    if (!arguments.length) return yTickFormat;
    yTickFormat = _;
    return chart;
  };

  chart.showValue = function(_) {
    if (!arguments.length) return showValue;
    showValue = _;
    return chart;
  };

  chart.alignValue = function(_) {
    if (!arguments.length) return alignValue;
    alignValue = _;
    return chart;
  };

  chart.rightAlignValue = function(_) {
    if (!arguments.length) return rightAlignValue;
    rightAlignValue = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  //============================================================


  return chart;
}

nv.models.stackedArea = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var margin = {top: 0, right: 0, bottom: 0, left: 0}
    , width = 960
    , height = 500
    , color = nv.utils.defaultColor() // a function that computes the color
    , id = Math.floor(Math.random() * 100000) //Create semi-unique ID incase user doesn't selet one
    , getX = function(d) { return d.x } // accessor to get the x value from a data point
    , getY = function(d) { return d.y } // accessor to get the y value from a data point
    , style = 'stack'
    , offset = 'zero'
    , order = 'default'
    , interpolate = 'linear'  // controls the line interpolation
    , clipEdge = false // if true, masks lines within x and y scale
    , x //can be accessed via chart.xScale()
    , y //can be accessed via chart.yScale()
    , scatter = nv.models.scatter()
    , dispatch =  d3.dispatch('tooltipShow', 'tooltipHide', 'areaClick', 'areaMouseover', 'areaMouseout')
    ;

  scatter
    .size(2.2) // default size
    .sizeDomain([2.2,2.2]) // all the same size by default
    ;

  /************************************
   * offset:
   *   'wiggle' (stream)
   *   'zero' (stacked)
   *   'expand' (normalize to 100%)
   *   'silhouette' (simple centered)
   *
   * order:
   *   'inside-out' (stream)
   *   'default' (input order)
   ************************************/

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var availableWidth = width - margin.left - margin.right,
          availableHeight = height - margin.top - margin.bottom,
          container = d3.select(this);

      //------------------------------------------------------------
      // Setup Scales

      x = scatter.xScale();
      y = scatter.yScale();

      //------------------------------------------------------------

      var dataRaw = data;
      // Injecting point index into each point because d3.layout.stack().out does not give index
      data.forEach(function(aseries, i) {
        aseries.seriesIndex = i;
        aseries.values = aseries.values.map(function(d, j) {
          d.index = j;
          d.seriesIndex = i;
          return d;
        });
      });

      var dataFiltered = data.filter(function(series) {
            return !series.disabled;
      });

      data = d3.layout.stack()
               .order(order)
               .offset(offset)
               .values(function(d) { return d.values })  //TODO: make values customizeable in EVERY model in this fashion
               .x(getX)
               .y(getY)
               .out(function(d, y0, y) {
                    var yHeight = (getY(d) === 0) ? 0 : y;
                    d.display = {
                      y: yHeight,
                     y0: y0
                    };
                })
              (dataFiltered);


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-stackedarea').data([data]);
      var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedarea');
      var defsEnter = wrapEnter.append('defs');
      var gEnter = wrapEnter.append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-areaWrap');
      gEnter.append('g').attr('class', 'nv-scatterWrap');

      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //------------------------------------------------------------


      scatter
        .width(availableWidth)
        .height(availableHeight)
        .x(getX)
        .y(function(d) { return d.display.y + d.display.y0 })
        .forceY([0])
        .color(data.map(function(d,i) {
          return d.color || color(d, d.seriesIndex);
        }));


      var scatterWrap = g.select('.nv-scatterWrap')
          .datum(data);

      scatterWrap.call(scatter);

      defsEnter.append('clipPath')
          .attr('id', 'nv-edge-clip-' + id)
        .append('rect');

      wrap.select('#nv-edge-clip-' + id + ' rect')
          .attr('width', availableWidth)
          .attr('height', availableHeight);

      g   .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');

      var area = d3.svg.area()
          .x(function(d,i)  { return x(getX(d,i)) })
          .y0(function(d) {
              return y(d.display.y0)
          })
          .y1(function(d) {
              return y(d.display.y + d.display.y0)
          })
          .interpolate(interpolate);

      var zeroArea = d3.svg.area()
          .x(function(d,i)  { return x(getX(d,i)) })
          .y0(function(d) { return y(d.display.y0) })
          .y1(function(d) { return y(d.display.y0) });


      var path = g.select('.nv-areaWrap').selectAll('path.nv-area')
          .data(function(d) { return d });

      path.enter().append('path').attr('class', function(d,i) { return 'nv-area nv-area-' + i })
          .attr('d', function(d,i){
            return zeroArea(d.values, d.seriesIndex);
          })
          .on('mouseover', function(d,i) {
            d3.select(this).classed('hover', true);
            dispatch.areaMouseover({
              point: d,
              series: d.key,
              pos: [d3.event.pageX, d3.event.pageY],
              seriesIndex: d.seriesIndex
            });
          })
          .on('mouseout', function(d,i) {
            d3.select(this).classed('hover', false);
            dispatch.areaMouseout({
              point: d,
              series: d.key,
              pos: [d3.event.pageX, d3.event.pageY],
              seriesIndex: d.seriesIndex
            });
          })
          .on('click', function(d,i) {
            d3.select(this).classed('hover', false);
            dispatch.areaClick({
              point: d,
              series: d.key,
              pos: [d3.event.pageX, d3.event.pageY],
              seriesIndex: d.seriesIndex
            });
          })

      path.exit().remove();

      path
          .style('fill', function(d,i){
            return d.color || color(d, d.seriesIndex)
          })
          .style('stroke', function(d,i){ return d.color || color(d, d.seriesIndex) });
      path.transition()
          .attr('d', function(d,i) {
            return area(d.values,i)
          });



      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      scatter.dispatch.on('elementMouseover.area', function(e) {
        g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', true);
      });
      scatter.dispatch.on('elementMouseout.area', function(e) {
        g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', false);
      });

      //============================================================
      //Special offset functions
      chart.d3_stackedOffset_stackPercent = function(stackData) {
          var n = stackData.length,    //How many series
          m = stackData[0].length,     //how many points per series
          k = 1 / n,
           i,
           j,
           o,
           y0 = [];

          for (j = 0; j < m; ++j) { //Looping through all points
            for (i = 0, o = 0; i < dataRaw.length; i++)  //looping through series'
                o += getY(dataRaw[i].values[j])   //total value of all points at a certian point in time.

            if (o) for (i = 0; i < n; i++)
               stackData[i][j][1] /= o;
            else
              for (i = 0; i < n; i++)
               stackData[i][j][1] = k;
          }
          for (j = 0; j < m; ++j) y0[j] = 0;
          return y0;
      };

    });


    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  scatter.dispatch.on('elementClick.area', function(e) {
    dispatch.areaClick(e);
  })
  scatter.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top],
        dispatch.tooltipShow(e);
  });
  scatter.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
  });

  //============================================================

  //============================================================
  // Global getters and setters
  //------------------------------------------------------------

  chart.dispatch = dispatch;
  chart.scatter = scatter;

  d3.rebind(chart, scatter, 'interactive', 'size', 'xScale', 'yScale', 'zScale', 'xDomain', 'yDomain', 'xRange', 'yRange',
    'sizeDomain', 'forceX', 'forceY', 'forceSize', 'clipVoronoi', 'useVoronoi','clipRadius','highlightPoint','clearHighlights');

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.x = function(_) {
    if (!arguments.length) return getX;
    getX = d3.functor(_);
    return chart;
  };

  chart.y = function(_) {
    if (!arguments.length) return getY;
    getY = d3.functor(_);
    return chart;
  }

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.clipEdge = function(_) {
    if (!arguments.length) return clipEdge;
    clipEdge = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    return chart;
  };

  chart.offset = function(_) {
    if (!arguments.length) return offset;
    offset = _;
    return chart;
  };

  chart.order = function(_) {
    if (!arguments.length) return order;
    order = _;
    return chart;
  };

  //shortcut for offset + order
  chart.style = function(_) {
    if (!arguments.length) return style;
    style = _;

    switch (style) {
      case 'stack':
        chart.offset('zero');
        chart.order('default');
        break;
      case 'stream':
        chart.offset('wiggle');
        chart.order('inside-out');
        break;
      case 'stream-center':
          chart.offset('silhouette');
          chart.order('inside-out');
          break;
      case 'expand':
        chart.offset('expand');
        chart.order('default');
        break;
      case 'stack_percent':
        chart.offset(chart.d3_stackedOffset_stackPercent);
        chart.order('default');
        break;
    }

    return chart;
  };

  chart.interpolate = function(_) {
	    if (!arguments.length) return interpolate;
	    interpolate = _;
	    return chart;
  };
  //============================================================


  return chart;
}

nv.models.stackedAreaChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var stacked = nv.models.stackedArea()
    , xAxis = nv.models.axis()
    , yAxis = nv.models.axis()
    , legend = nv.models.legend()
    , controls = nv.models.legend()
    , interactiveLayer = nv.interactiveGuideline()
    ;

  var margin = {top: 30, right: 25, bottom: 50, left: 60}
    , width = null
    , height = null
    , color = nv.utils.defaultColor() // a function that takes in d, i and returns color
    , showControls = true
    , showLegend = true
    , showXAxis = true
    , showYAxis = true
    , rightAlignYAxis = false
    , useInteractiveGuideline = false
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
        return '<h3>' + key + '</h3>' +
               '<p>' +  y + ' on ' + x + '</p>'
      }
    , x //can be accessed via chart.xScale()
    , y //can be accessed via chart.yScale()
    , yAxisTickFormat = d3.format(',.2f')
    , state = { style: stacked.style() }
    , defaultState = null
    , noData = 'No Data Available.'
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    , controlWidth = 250
    , cData = ['Stacked','Stream','Expanded']
    , controlLabels = {}
    , transitionDuration = 250
    ;

  xAxis
    .orient('bottom')
    .tickPadding(7)
    ;
  yAxis
    .orient((rightAlignYAxis) ? 'right' : 'left')
    ;

  controls.updateState(false);
  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
        top = e.pos[1] + ( offsetElement.offsetTop || 0),
        x = xAxis.tickFormat()(stacked.x()(e.point, e.pointIndex)),
        y = yAxis.tickFormat()(stacked.y()(e.point, e.pointIndex)),
        content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
  };

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
          that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
                             - margin.left - margin.right,
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;

      chart.update = function() { container.transition().duration(transitionDuration).call(chart); };
      chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });

      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }

      //------------------------------------------------------------
      // Display No Data message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x = stacked.xScale();
      y = stacked.yScale();

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-stackedAreaChart').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedAreaChart').append('g');
      var g = wrap.select('g');

      gEnter.append("rect").style("opacity",0);
      gEnter.append('g').attr('class', 'nv-x nv-axis');
      gEnter.append('g').attr('class', 'nv-y nv-axis');
      gEnter.append('g').attr('class', 'nv-stackedWrap');
      gEnter.append('g').attr('class', 'nv-legendWrap');
      gEnter.append('g').attr('class', 'nv-controlsWrap');
      gEnter.append('g').attr('class', 'nv-interactive');

      g.select("rect").attr("width",availableWidth).attr("height",availableHeight);
      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        var legendWidth = (showControls) ? availableWidth - controlWidth : availableWidth;
        legend
          .width(legendWidth);

        g.select('.nv-legendWrap')
            .datum(data)
            .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }

        g.select('.nv-legendWrap')
            .attr('transform', 'translate(' + (availableWidth-legendWidth) + ',' + (-margin.top) +')');
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Controls

      if (showControls) {
        var controlsData = [
          {
            key: controlLabels.stacked || 'Stacked',
            metaKey: 'Stacked',
            disabled: stacked.style() != 'stack',
            style: 'stack'
          },
          {
            key: controlLabels.stream || 'Stream',
            metaKey: 'Stream',
            disabled: stacked.style() != 'stream',
            style: 'stream'
          },
          {
            key: controlLabels.expanded || 'Expanded',
            metaKey: 'Expanded',
            disabled: stacked.style() != 'expand',
            style: 'expand'
          },
          {
            key: controlLabels.stack_percent || 'Stack %',
            metaKey: 'Stack_Percent',
            disabled: stacked.style() != 'stack_percent',
            style: 'stack_percent'
          }
        ];

        controlWidth = (cData.length/3) * 260;

        controlsData = controlsData.filter(function(d) {
          return cData.indexOf(d.metaKey) !== -1;
        })

        controls
          .width( controlWidth )
          .color(['#444', '#444', '#444']);

        g.select('.nv-controlsWrap')
            .datum(controlsData)
            .call(controls);


        if ( margin.top != Math.max(controls.height(), legend.height()) ) {
          margin.top = Math.max(controls.height(), legend.height());
          availableHeight = (height || parseInt(container.style('height')) || 400)
                             - margin.top - margin.bottom;
        }


        g.select('.nv-controlsWrap')
            .attr('transform', 'translate(0,' + (-margin.top) +')');
      }

      //------------------------------------------------------------


      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      if (rightAlignYAxis) {
          g.select(".nv-y.nv-axis")
              .attr("transform", "translate(" + availableWidth + ",0)");
      }

      //------------------------------------------------------------
      // Main Chart Component(s)

      //------------------------------------------------------------
      //Set up interactive layer
      if (useInteractiveGuideline) {
        interactiveLayer
           .width(availableWidth)
           .height(availableHeight)
           .margin({left: margin.left, top: margin.top})
           .svgContainer(container)
           .xScale(x);
        wrap.select(".nv-interactive").call(interactiveLayer);
      }

      stacked
        .width(availableWidth)
        .height(availableHeight)

      var stackedWrap = g.select('.nv-stackedWrap')
          .datum(data);

      stackedWrap.transition().call(stacked);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Axes

      if (showXAxis) {
        xAxis
          .scale(x)
          .ticks( availableWidth / 100 )
          .tickSize( -availableHeight, 0);

        g.select('.nv-x.nv-axis')
            .attr('transform', 'translate(0,' + availableHeight + ')');

        g.select('.nv-x.nv-axis')
          .transition().duration(0)
            .call(xAxis);
      }

      if (showYAxis) {
        yAxis
          .scale(y)
          .ticks(stacked.offset() == 'wiggle' ? 0 : availableHeight / 36)
          .tickSize(-availableWidth, 0)
          .setTickFormat( (stacked.style() == 'expand' || stacked.style() == 'stack_percent')
                ? d3.format('%') : yAxisTickFormat);

        g.select('.nv-y.nv-axis')
          .transition().duration(0)
            .call(yAxis);
      }

      //------------------------------------------------------------


      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      stacked.dispatch.on('areaClick.toggle', function(e) {
        if (data.filter(function(d) { return !d.disabled }).length === 1)
          data.forEach(function(d) {
            d.disabled = false;
          });
        else
          data.forEach(function(d,i) {
            d.disabled = (i != e.seriesIndex);
          });

        state.disabled = data.map(function(d) { return !!d.disabled });
        dispatch.stateChange(state);

        chart.update();
      });

      legend.dispatch.on('stateChange', function(newState) {
        state.disabled = newState.disabled;
        dispatch.stateChange(state);
        chart.update();
      });

      controls.dispatch.on('legendClick', function(d,i) {
        if (!d.disabled) return;

        controlsData = controlsData.map(function(s) {
          s.disabled = true;
          return s;
        });
        d.disabled = false;

        stacked.style(d.style);


        state.style = stacked.style();
        dispatch.stateChange(state);

        chart.update();
      });


      interactiveLayer.dispatch.on('elementMousemove', function(e) {
          stacked.clearHighlights();
          var singlePoint, pointIndex, pointXLocation, allData = [];
          data
          .filter(function(series, i) {
            series.seriesIndex = i;
            return !series.disabled;
          })
          .forEach(function(series,i) {
              pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
              stacked.highlightPoint(i, pointIndex, true);
              var point = series.values[pointIndex];
              if (typeof point === 'undefined') return;
              if (typeof singlePoint === 'undefined') singlePoint = point;
              if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));

              //If we are in 'expand' mode, use the stacked percent value instead of raw value.
              var tooltipValue = (stacked.style() == 'expand') ? point.display.y : chart.y()(point,pointIndex);
              allData.push({
                  key: series.key,
                  value: tooltipValue,
                  color: color(series,series.seriesIndex),
                  stackedValue: point.display
              });
          });

          allData.reverse();

          //Highlight the tooltip entry based on which stack the mouse is closest to.
          if (allData.length > 2) {
            var yValue = chart.yScale().invert(e.mouseY);
            var yDistMax = Infinity, indexToHighlight = null;
            allData.forEach(function(series,i) {

               //To handle situation where the stacked area chart is negative, we need to use absolute values
               //when checking if the mouse Y value is within the stack area.
               yValue = Math.abs(yValue);
               var stackedY0 = Math.abs(series.stackedValue.y0);
               var stackedY = Math.abs(series.stackedValue.y);
               if ( yValue >= stackedY0 && yValue <= (stackedY + stackedY0))
               {
                  indexToHighlight = i;
                  return;
               }
            });
            if (indexToHighlight != null)
               allData[indexToHighlight].highlight = true;
          }

          var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex));

          //If we are in 'expand' mode, force the format to be a percentage.
          var valueFormatter = (stacked.style() == 'expand') ?
               function(d,i) {return d3.format(".1%")(d);} :
               function(d,i) {return yAxis.tickFormat()(d); };
          interactiveLayer.tooltip
                  .position({left: pointXLocation + margin.left, top: e.mouseY + margin.top})
                  .chartContainer(that.parentNode)
                  .enabled(tooltips)
                  .valueFormatter(valueFormatter)
                  .data(
                      {
                        value: xValue,
                        series: allData
                      }
                  )();

          interactiveLayer.renderGuideLine(pointXLocation);

      });

      interactiveLayer.dispatch.on("elementMouseout",function(e) {
          dispatch.tooltipHide();
          stacked.clearHighlights();
      });


      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode);
      });

      // Update chart from a state object passed to event handler
      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }

        if (typeof e.style !== 'undefined') {
          stacked.style(e.style);
        }

        chart.update();
      });

    });


    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  stacked.dispatch.on('tooltipShow', function(e) {
    //disable tooltips when value ~= 0
    //// TODO: consider removing points from voronoi that have 0 value instead of this hack
    /*
    if (!Math.round(stacked.y()(e.point) * 100)) {  // 100 will not be good for very small numbers... will have to think about making this valu dynamic, based on data range
      setTimeout(function() { d3.selectAll('.point.hover').classed('hover', false) }, 0);
      return false;
    }
   */

    e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top],
    dispatch.tooltipShow(e);
  });

  stacked.dispatch.on('tooltipHide', function(e) {
    dispatch.tooltipHide(e);
  });

  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.stacked = stacked;
  chart.legend = legend;
  chart.controls = controls;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;
  chart.interactiveLayer = interactiveLayer;

  d3.rebind(chart, stacked, 'x', 'y', 'size', 'xScale', 'yScale', 'xDomain', 'yDomain', 'xRange', 'yRange', 'sizeDomain', 'interactive', 'useVoronoi', 'offset', 'order', 'style', 'clipEdge', 'forceX', 'forceY', 'forceSize', 'interpolate');

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    stacked.color(color);
    return chart;
  };

  chart.showControls = function(_) {
    if (!arguments.length) return showControls;
    showControls = _;
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.showXAxis = function(_) {
    if (!arguments.length) return showXAxis;
    showXAxis = _;
    return chart;
  };

  chart.showYAxis = function(_) {
    if (!arguments.length) return showYAxis;
    showYAxis = _;
    return chart;
  };

  chart.rightAlignYAxis = function(_) {
    if(!arguments.length) return rightAlignYAxis;
    rightAlignYAxis = _;
    yAxis.orient( (_) ? 'right' : 'left');
    return chart;
  };

  chart.useInteractiveGuideline = function(_) {
    if(!arguments.length) return useInteractiveGuideline;
    useInteractiveGuideline = _;
    if (_ === true) {
       chart.interactive(false);
       chart.useVoronoi(false);
    }
    return chart;
  };

  chart.tooltip = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };

  chart.controlsData = function(_) {
    if (!arguments.length) return cData;
    cData = _;
    return chart;
  };

  chart.controlLabels = function(_) {
    if (!arguments.length) return controlLabels;
    if (typeof _ !== 'object') return controlLabels;
    controlLabels = _;
    return chart;
  };

  yAxis.setTickFormat = yAxis.tickFormat;

  yAxis.tickFormat = function(_) {
    if (!arguments.length) return yAxisTickFormat;
    yAxisTickFormat = _;
    return yAxis;
  };


  //============================================================

  return chart;
}
})();
},{}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/bootstrap/dist/js/bootstrap.js":[function(require,module,exports){
/*!
 * Bootstrap v3.3.0 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
}

+function ($) {
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher')
  }
}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.0
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.3.0
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.0'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.3.0
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.0'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state = state + 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked') && this.$element.hasClass('active')) changed = false
        else $parent.find('.active').removeClass('active')
      }
      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
    }

    if (changed) this.$element.toggleClass('active')
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', e.type == 'focus')
    })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.3.0
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      =
    this.sliding     =
    this.interval    =
    this.$active     =
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.0'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var delta = direction == 'prev' ? -1 : 1
    var activeIndex = this.getItemIndex(active)
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var fallback  = type == 'next' ? 'first' : 'last'
    var that      = this

    if (!$next.length) {
      if (!this.options.wrap) return
      $next = this.$element.find('.item')[fallback]()
    }

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.3.0
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $(this.options.trigger).filter('[href="#' + element.id + '"], [data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.0'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true,
    trigger: '[data-toggle="collapse"]'
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.find('> .panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && option == 'show') options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $.extend({}, $this.data(), { trigger: this })

    Plugin.call($target, option)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.0
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.0'

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger('shown.bs.dropdown', relatedTarget)
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.divider):visible a'
    var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--                        // up
    if (e.which == 40 && index < $items.length - 1) index++                        // down
    if (!~index)                                      index = 0

    $items.eq(index).trigger('focus')
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
    })
  }

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="menu"]', Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="listbox"]', Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.0
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options        = options
    this.$body          = $(document.body)
    this.$element       = $(element)
    this.$backdrop      =
    this.isShown        = null
    this.scrollbarWidth = 0

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.0'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.$body.addClass('modal-open')

    this.setScrollbar()
    this.escape()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element
        .addClass('in')
        .attr('aria-hidden', false)

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$element.find('.modal-dialog') // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .attr('aria-hidden', true)
      .off('click.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .prependTo(this.$element)
        .on('click.dismiss.bs.modal', $.proxy(function (e) {
          if (e.target !== e.currentTarget) return
          this.options.backdrop == 'static'
            ? this.$element[0].focus.call(this.$element[0])
            : this.hide.call(this)
        }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  Modal.prototype.checkScrollbar = function () {
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    if (this.scrollbarWidth) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', '')
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    if (document.body.clientWidth >= window.innerWidth) return 0
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.0
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       =
    this.options    =
    this.enabled    =
    this.timeout    =
    this.hoverState =
    this.$element   = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.0'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (self && self.$tip && self.$tip.is(':visible')) {
      self.hoverState = 'in'
      return
    }

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()
        var containerDim = this.getPosition($container)

        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) {
    this.arrow()
      .css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isHorizontal ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = this.tip()
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && this.$tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    return (this.$tip = this.$tip || $(this.options.template))
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.tooltip')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.tooltip', (data = {}))
        if (!data[selector]) data[selector] = new Tooltip(this, options)
      } else {
        if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.0
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.0'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }

  Popover.prototype.tip = function () {
    if (!this.$tip) this.$tip = $(this.options.template)
    return this.$tip
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.popover')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.popover', (data = {}))
        if (!data[selector]) data[selector] = new Popover(this, options)
      } else {
        if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.0
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    var process  = $.proxy(this.process, this)

    this.$body          = $('body')
    this.$scrollElement = $(element).is('body') ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', process)
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.0'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var offsetMethod = 'offset'
    var offsetBase   = 0

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.offsets = []
    this.targets = []
    this.scrollHeight = this.getScrollHeight()

    var self     = this

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        self.offsets.push(this[0])
        self.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
        '[data-target="' + target + '"],' +
        this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.3.0
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    this.element = $(element)
  }

  Tab.VERSION = '3.3.0'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && (($active.length && $active.hasClass('fade')) || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu')) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback && callback()
    }

    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.0
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      =
    this.unpin        =
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.0'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && colliderTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = $('body').height()

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

},{}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/core.js":[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Core 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.4",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

})( jQuery );

},{"jquery":"jquery"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/datepicker.js":[function(require,module,exports){
var jQuery = require('jquery');
require('./core');

/*!
 * jQuery UI Datepicker 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/datepicker/
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.10.4" } });

var PROP_NAME = "datepicker",
	instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[""] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: ["January","February","March","April","May","June",
			"July","August","September","October","November","December"], // Names of months for drop-down and formatting
		monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
		dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
		dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
		dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional[""]);
	this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function(target, settings) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = (nodeName === "div" || nodeName === "span");
		if (!target.id) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {});
		if (nodeName === "input") {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName)) {
			return;
		}
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp);
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var showOn, buttonText, buttonImage,
			appendText = this._get(inst, "appendText"),
			isRTL = this._get(inst, "isRTL");

		if (inst.append) {
			inst.append.remove();
		}
		if (appendText) {
			inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
			input[isRTL ? "before" : "after"](inst.append);
		}

		input.unbind("focus", this._showDatepicker);

		if (inst.trigger) {
			inst.trigger.remove();
		}

		showOn = this._get(inst, "showOn");
		if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		}
		if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
			buttonText = this._get(inst, "buttonText");
			buttonImage = this._get(inst, "buttonImage");
			inst.trigger = $(this._get(inst, "buttonImageOnly") ?
				$("<img/>").addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$("<button type='button'></button>").addClass(this._triggerClass).
					html(!buttonImage ? buttonText : $("<img/>").attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? "before" : "after"](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
					$.datepicker._hideDatepicker();
				} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else {
					$.datepicker._showDatepicker(input[0]);
				}
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, "autoSize") && !inst.inline) {
			var findMax, max, maxI, i,
				date = new Date(2009, 12 - 1, 20), // Ensure double digits
				dateFormat = this._get(inst, "dateFormat");

			if (dateFormat.match(/[DM]/)) {
				findMax = function(names) {
					max = 0;
					maxI = 0;
					for (i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					"monthNames" : "monthNamesShort"))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
			}
			inst.input.attr("size", this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName)) {
			return;
		}
		divSpan.addClass(this.markerClassName).append(inst.dpDiv);
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if (!inst) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $("<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>");
			this._dialogInput.keydown(this._doKeyDown);
			$("body").append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI) {
			$.blockUI(this.dpDiv);
		}
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function(target) {
		var nodeName,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName === "input") {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind("focus", this._showDatepicker).
				unbind("keydown", this._doKeyDown).
				unbind("keypress", this._doKeyPress).
				unbind("keyup", this._doKeyUp);
		} else if (nodeName === "div" || nodeName === "span") {
			$target.removeClass(this.markerClassName).empty();
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = false;
			inst.trigger.filter("button").
				each(function() { this.disabled = false; }).end().
				filter("img").css({opacity: "1.0", cursor: ""});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().removeClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = true;
			inst.trigger.filter("button").
				each(function() { this.disabled = true; }).end().
				filter("img").css({opacity: "0.5", cursor: "default"});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().addClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] === target) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function(target, name, value) {
		var settings, date, minDate, maxDate,
			inst = this._getInst(target);

		if (arguments.length === 2 && typeof name === "string") {
			return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name === "all" ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}

		settings = name || {};
		if (typeof name === "string") {
			settings = {};
			settings[name] = value;
		}

		if (inst) {
			if (this._curInst === inst) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker(target, true);
			minDate = this._getMinMaxDate(inst, "min");
			maxDate = this._getMinMaxDate(inst, "max");
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
				inst.settings.minDate = this._formatDate(inst, minDate);
			}
			if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker(target);
				} else {
					this._enableDatepicker(target);
				}
			}
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline) {
			this._setDateFromField(inst, noDefault);
		}
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst(event.target),
			handled = true,
			isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing) {
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv);
						if (sel[0]) {
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
						}

						onSelect = $.datepicker._get(inst, "onSelect");
						if (onSelect) {
							dateStr = $.datepicker._formatDate(inst);

							// trigger custom callback
							onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, "stepBigMonths") :
							-$.datepicker._get(inst, "stepMonths")), "M");
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, "stepBigMonths") :
							+$.datepicker._get(inst, "stepMonths")), "M");
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) {
							$.datepicker._clearDate(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) {
							$.datepicker._gotoToday(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, -7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, +7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		} else {
			handled = false;
		}

		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var chars, chr,
			inst = $.datepicker._getInst(event.target);

		if ($.datepicker._get(inst, "constrainInput")) {
			chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
			chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var date,
			inst = $.datepicker._getInst(event.target);

		if (inst.input.val() !== inst.lastVal) {
			try {
				date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));

				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
			input = $("input", input.parentNode)[0];
		}

		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}

		beforeShow = $.datepicker._get(inst, "beforeShow");
		beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);

		if ($.datepicker._inDialog) { // hide cursor
			input.value = "";
		}
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css("position") === "fixed";
			return !isFixed;
		});

		offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			"static" : (isFixed ? "fixed" : "absolute")), display: "none",
			left: offset.left + "px", top: offset.top + "px"});

		if (!inst.inline) {
			showAnim = $.datepicker._get(inst, "showAnim");
			duration = $.datepicker._get(inst, "duration");
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
			} else {
				inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.focus();
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();

		var origyearshtml,
			numMonths = this._getNumberOfMonths(inst),
			cols = numMonths[1],
			width = 17;

		inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
		if (cols > 1) {
			inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
		}
		inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
			"Class"]("ui-datepicker-multi");
		inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
			"Class"]("ui-datepicker-rtl");

		if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.focus();
		}

		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
			viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var position,
			inst = this._getInst(obj),
			isRTL = this._get(inst, "isRTL");

		while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? "previousSibling" : "nextSibling"];
		}

		position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function(input) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
			return;
		}

		if (this._datepickerShowing) {
			showAnim = this._get(inst, "showAnim");
			duration = this._get(inst, "duration");
			postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
			} else {
				inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
					(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
			}

			if (!showAnim) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get(inst, "onClose");
			if (onClose) {
				onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
			}

			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
				if ($.blockUI) {
					$.unblockUI();
					$("body").append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst) {
			return;
		}

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
				$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var date,
			target = $(id),
			inst = this._getInst(target[0]);

		if (this._get(inst, "gotoCurrent") && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		inst["selected" + (period === "M" ? "Month" : "Year")] =
		inst["draw" + (period === "M" ? "Month" : "Year")] =
			parseInt(select.options[select.selectedIndex].value,10);

		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var inst,
			target = $(id);

		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}

		inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $("a", td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		this._selectDate(target, "");
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var onSelect,
			target = $(id),
			inst = this._getInst(target[0]);

		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input) {
			inst.input.val(dateStr);
		}
		this._updateAlternate(inst);

		onSelect = this._get(inst, "onSelect");
		if (onSelect) {
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		} else if (inst.input) {
			inst.input.trigger("change"); // fire the change event
		}

		if (inst.inline){
			this._updateDatepicker(inst);
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) !== "object") {
				inst.input.focus(); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altFormat, date, dateStr,
			altField = this._get(inst, "altField");

		if (altField) { // update alternate field too
			altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
			date = this._getDate(inst);
			dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ""];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function(date) {
		var time,
			checkDate = new Date(date.getTime());

		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

		time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function (format, value, settings) {
		if (format == null || value == null) {
			throw "Invalid arguments";
		}

		value = (typeof value === "object" ? value.toString() : value + "");
		if (value === "") {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
			shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Extract a number from the string value
			getNumber = function(match) {
				var isDoubled = lookAhead(match),
					size = (match === "@" ? 14 : (match === "!" ? 20 :
					(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
					digits = new RegExp("^\\d{1," + size + "}"),
					num = value.substring(iValue).match(digits);
				if (!num) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			},
			// Extract a name from the string value and convert to an index
			getName = function(match, shortNames, longNames) {
				var index = -1,
					names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
						return [ [k, v] ];
					}).sort(function (a, b) {
						return -(a[1].length - b[1].length);
					});

				$.each(names, function (i, pair) {
					var name = pair[1];
					if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
						index = pair[0];
						iValue += name.length;
						return false;
					}
				});
				if (index !== -1) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},
			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d":
						day = getNumber("d");
						break;
					case "D":
						getName("D", dayNamesShort, dayNames);
						break;
					case "o":
						doy = getNumber("o");
						break;
					case "m":
						month = getNumber("m");
						break;
					case "M":
						month = getName("M", monthNamesShort, monthNames);
						break;
					case "y":
						year = getNumber("y");
						break;
					case "@":
						date = new Date(getNumber("@"));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'")){
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if (iValue < value.length){
			extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if (year === -1) {
			year = new Date().getFullYear();
		} else if (year < 100) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		}

		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim) {
					break;
				}
				month++;
				day -= dim;
			} while (true);
		}

		date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function (format, date, settings) {
		if (!date) {
			return "";
		}

		var iFormat,
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Format a number, with leading zero if necessary
			formatNumber = function(match, value, len) {
				var num = "" + value;
				if (lookAhead(match)) {
					while (num.length < len) {
						num = "0" + num;
					}
				}
				return num;
			},
			// Format a name, short or long as requested
			formatName = function(match, value, shortNames, longNames) {
				return (lookAhead(match) ? longNames[value] : shortNames[value]);
			},
			output = "",
			literal = false;

		if (date) {
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						output += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							output += formatNumber("d", date.getDate(), 2);
							break;
						case "D":
							output += formatName("D", date.getDay(), dayNamesShort, dayNames);
							break;
						case "o":
							output += formatNumber("o",
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case "m":
							output += formatNumber("m", date.getMonth() + 1, 2);
							break;
						case "M":
							output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
							break;
						case "y":
							output += (lookAhead("y") ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'")) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var iFormat,
			chars = "",
			literal = false,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					chars += format.charAt(iFormat);
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if (lookAhead("'")) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt(iFormat);
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() === inst.lastVal) {
			return;
		}

		var dateFormat = this._get(inst, "dateFormat"),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate(inst),
			date = defaultDate,
			settings = this._getFormatConfig(inst);

		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			dates = (noDefault ? "" : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
				var date = new Date();
				date.setDate(date.getDate() + offset);
				return date;
			},
			offsetString = function(offset) {
				try {
					return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						offset, $.datepicker._getFormatConfig(inst));
				}
				catch (e) {
					// Ignore
				}

				var date = (offset.toLowerCase().match(/^c/) ?
					$.datepicker._getDate(inst) : null) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec(offset);

				while (matches) {
					switch (matches[2] || "d") {
						case "d" : case "D" :
							day += parseInt(matches[1],10); break;
						case "w" : case "W" :
							day += parseInt(matches[1],10) * 7; break;
						case "m" : case "M" :
							month += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
						case "y": case "Y" :
							year += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
					}
					matches = pattern.exec(offset);
				}
				return new Date(year, month, day);
			},
			newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
				(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

		newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function(date) {
		if (!date) {
			return null;
		}
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
			this._notifyChange(inst);
		}
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? "" : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, "stepMonths"),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find("[data-handler]").map(function () {
			var handler = {
				prev: function () {
					$.datepicker._adjustDate(id, -stepMonths, "M");
				},
				next: function () {
					$.datepicker._adjustDate(id, +stepMonths, "M");
				},
				hide: function () {
					$.datepicker._hideDatepicker();
				},
				today: function () {
					$.datepicker._gotoToday(id);
				},
				selectDay: function () {
					$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
					return false;
				},
				selectMonth: function () {
					$.datepicker._selectMonthYear(id, this, "M");
					return false;
				},
				selectYear: function () {
					$.datepicker._selectMonthYear(id, this, "Y");
					return false;
				}
			};
			$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
			isRTL = this._get(inst, "isRTL"),
			showButtonPanel = this._get(inst, "showButtonPanel"),
			hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
			navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
			numMonths = this._getNumberOfMonths(inst),
			showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
			stepMonths = this._get(inst, "stepMonths"),
			isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
			currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
				new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get(inst, "prevText");
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));

		prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

		nextText = this._get(inst, "nextText");
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));

		next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

		currentText = this._get(inst, "currentText");
		gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

		controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get(inst, "closeText") + "</button>" : "");

		buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
			(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

		firstDay = parseInt(this._get(inst, "firstDay"),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);

		showWeek = this._get(inst, "showWeek");
		dayNames = this._get(inst, "dayNames");
		dayNamesMin = this._get(inst, "dayNamesMin");
		monthNames = this._get(inst, "monthNames");
		monthNamesShort = this._get(inst, "monthNamesShort");
		beforeShowDay = this._get(inst, "beforeShowDay");
		showOtherMonths = this._get(inst, "showOtherMonths");
		selectOtherMonths = this._get(inst, "selectOtherMonths");
		defaultDate = this._getDefaultDate(inst);
		html = "";
		dow;
		for (row = 0; row < numMonths[0]; row++) {
			group = "";
			this.maxRows = 4;
			for (col = 0; col < numMonths[1]; col++) {
				selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				cornerClass = " ui-corner-all";
				calender = "";
				if (isMultiMonth) {
					calender += "<div class='ui-datepicker-group";
					if (numMonths[1] > 1) {
						switch (col) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
							case numMonths[1]-1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
					(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
				for (dow = 0; dow < 7; dow++) { // days of the week
					day = (dow + firstDay) % 7;
					thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
						"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				}
				leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += "<tr>";
					tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get(inst, "calculateWeek")(printDate) + "</td>");
					for (dow = 0; dow < 7; dow++) { // create date picker days
						daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
						otherMonth = (printDate.getMonth() !== drawMonth);
						unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += "<td class='" +
							((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
							(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
							((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "") + // highlight selected day
							(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
							(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
							(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
							(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
							(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
							(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
							(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
							((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get(inst, "changeMonth"),
			changeYear = this._get(inst, "changeYear"),
			showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// month selection
		if (secondary || !changeMonth) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
		} else {
			inMinYear = (minDate && minDate.getFullYear() === drawYear);
			inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
					monthHtml += "<option value='" + month + "'" +
						(month === drawMonth ? " selected='selected'" : "") +
						">" + monthNamesShort[month] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if (!showMonthAfterYear) {
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
		}

		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if (secondary || !changeYear) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {
				// determine range of years to display
				years = this._get(inst, "yearRange").split(":");
				thisYear = new Date().getFullYear();
				determineYear = function(value) {
					var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				year = determineYear(years[0]);
				endYear = Math.max(year, determineYear(years[1] || ""));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for (; year <= endYear; year++) {
					inst.yearshtml += "<option value='" + year + "'" +
						(year === drawYear ? " selected='selected'" : "") +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get(inst, "yearSuffix");
		if (showMonthAfterYear) {
			html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period === "Y" ? offset : 0),
			month = inst.drawMonth + (period === "M" ? offset : 0),
			day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
			date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period === "M" || period === "Y") {
			this._notifyChange(inst);
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			newDate = (minDate && date < minDate ? minDate : date);
		return (maxDate && newDate > maxDate ? maxDate : newDate);
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, "onChangeMonthYear");
		if (onChange) {
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, "numberOfMonths");
		return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst),
			date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

		if (offset < 0) {
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		}
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			minYear = null,
			maxYear = null,
			years = this._get(inst, "yearRange");
			if (years){
				yearSplit = years.split(":");
				currentYear = new Date().getFullYear();
				minYear = parseInt(yearSplit[0], 10);
				maxYear = parseInt(yearSplit[1], 10);
				if ( yearSplit[0].match(/[+\-].*/) ) {
					minYear += currentYear;
				}
				if ( yearSplit[1].match(/[+\-].*/) ) {
					maxYear += currentYear;
				}
			}

		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()) &&
			(!minYear || date.getFullYear() >= minYear) &&
			(!maxYear || date.getFullYear() <= maxYear));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, "shortYearCutoff");
		shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
			monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day === "object" ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.delegate(selector, "mouseout", function() {
			$(this).removeClass("ui-state-hover");
			if (this.className.indexOf("ui-datepicker-prev") !== -1) {
				$(this).removeClass("ui-datepicker-prev-hover");
			}
			if (this.className.indexOf("ui-datepicker-next") !== -1) {
				$(this).removeClass("ui-datepicker-next-hover");
			}
		})
		.delegate(selector, "mouseover", function(){
			if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
				$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
				$(this).addClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).addClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).addClass("ui-datepicker-next-hover");
				}
			}
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props) {
		if (props[name] == null) {
			target[name] = props[name];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick);
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ($("#"+$.datepicker._mainDivId).length === 0) {
		$("body").append($.datepicker.dpDiv);
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	return this.each(function() {
		typeof options === "string" ?
			$.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.10.4";

})(jQuery);

},{"./core":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/core.js","jquery":"jquery"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/draggable.js":[function(require,module,exports){
var jQuery = require('jquery');
require('./core');
require('./mouse');
require('./widget');

/*!
 * jQuery UI Draggable 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	version: "1.10.4",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
			this.element[0].style.position = "relative";
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
			.css({
				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent();
		this.offsetParent = this.helper.offsetParent();
		this.offsetParentCssPosition = this.offsetParent.css( "position" );

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		//Reset scroll cache
		this.offset.scroll = false;

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.offsetParentCssPosition === "fixed" ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		if ( this.options.helper === "original" && !$.contains( this.element[ 0 ].ownerDocument, this.element[ 0 ] ) ) {
			return false;
		}

		if((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

		if(!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		//This needs to be actually done for all browsers, since pageX/pageY includes this information
		//Ugly IE fix
		if((this.offsetParent[0] === document.body) ||
			(this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var over, c, ce,
			o = this.options;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document") {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if( !ce ) {
			return;
		}

		over = c.css( "overflow" ) !== "hidden";

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ) ,
			( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
			( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
		];
		this.relative_container = c;
	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top ) * mod )
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left ) * mod )
			)
		};

	},

	_generatePosition: function(event) {

		var containment, co, top, left,
			o = this.options,
			scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent,
			pageX = event.pageX,
			pageY = event.pageY;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( this.originalPosition ) {
			if ( this.containment ) {
				if ( this.relative_container ){
					co = this.relative_container.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				}
				else {
					containment = this.containment;
				}

				if(event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		//The absolute position has to be recalculated after plugins
		if(type === "drag") {
			this.positionAbs = this._convertPositionTo("absolute");
		}
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("ui-draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, "ui-sortable");
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("ui-draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
				if(this.shouldRevert) {
					this.instance.options.revert = this.shouldRevert;
				}

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper === "original") {
					this.instance.currentItem.css({ top: "auto", left: "auto" });
				}

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("ui-draggable"), that = this;

		$.each(inst.sortables, function() {

			var innermostIntersecting = false,
				thisSortable = this;

			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if (this !== thisSortable &&
						this.instance._intersectsWith(this.instance.containerCache) &&
						$.contains(thisSortable.instance.element[0], this.instance.element[0])
					) {
						innermostIntersecting = false;
					}
					return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) {
					this.instance._mouseDrag(event);
				}

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger("out", event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) {
						this.instance.placeholder.remove();
					}

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			}

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function() {
		var t = $("body"), o = $(this).data("ui-draggable").options;
		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function() {
		var o = $(this).data("ui-draggable").options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function() {
		var i = $(this).data("ui-draggable");
		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
			i.overflowOffset = i.scrollParent.offset();
		}
	},
	drag: function( event ) {

		var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {

			if(!o.axis || o.axis !== "x") {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
				}
			}

			if(!o.axis || o.axis !== "y") {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if(!o.axis || o.axis !== "x") {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if(!o.axis || o.axis !== "y") {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function() {

		var i = $(this).data("ui-draggable"),
			o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if(this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function(event, ui) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			inst = $(this).data("ui-draggable"),
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top;
			b = t + inst.snapElements[i].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if(inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
				}
			}

			first = (ts || bs || ls || rs);

			if(o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
				}
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function() {
		var min,
			o = this.data("ui-draggable").options,
			group = $.makeArray($(o.stack)).sort(function(a,b) {
				return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css("zIndex"), 10) || 0;
		$(group).each(function(i) {
			$(this).css("zIndex", min + i);
		});
		this.css("zIndex", (min + group.length));
	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

})(jQuery);

},{"./core":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/core.js","./mouse":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/mouse.js","./widget":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/widget.js","jquery":"jquery"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/mouse.js":[function(require,module,exports){
var jQuery = require('jquery');
require('./widget');

/*!
 * jQuery UI Mouse 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.10.4",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown."+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click."+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("."+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});

})(jQuery);

},{"./widget":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/widget.js","jquery":"jquery"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/widget.js":[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Widget 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

},{"jquery":"jquery"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/collections/all-filters-collection.js":[function(require,module,exports){
var Backbone = require('backbone');
var _ = require('underscore');
var $ = require('jquery');

var GenericFilterModel = require('../models/generic-filter-model');
var OrgRoleFilterModel = require('../models/org-role-filter-model');
var YearsFilterModel = require('../models/years-filter-model');


//TODO: move most code from filters-view here.
module.exports = Backbone.Collection.extend({
  url: '/rest/filters',
  _loaded: null,
  _allDeferreds: [],
  orgCollection: null,
  orgGroupCollection: null,
  orgTypeCollection: null,
  componentCaller: null,

  initialize: function(models,options) {
    this.on('add', this._cleanUpAfterAdd);
    this.load();
    if (options.caller) {
    	componentCaller = options.caller;
    }
  },

  load: function() {
    var self = this;

    if(!this._loaded){
      this._loaded = new $.Deferred();
      this._allDeferreds.push(this._createOrgFilters());

      this.fetch({remove: false}).then(function() {
        // when all child calls are done resolve.
        $.when.apply($, self._allDeferreds)
          .done(self._loaded.resolve)
          .fail(self._loaded.reject);
      }).fail(self._loaded.reject);
    }

    return this._loaded;
  },

  _cleanUpAfterAdd: function(model) {
    var self = this;
    // remove if ui false also catches empty dummy filters we add in 'model' function below.
    if (!model.get('ui')) {
      self.remove(model);
    }
    //remove if the endpoint returns the filter type (dashboard,tabs,reports and/or GIS) for which
    //the model should be visible and the caller is not of the same tpe
    
    if (model.get('filterType')) {
    	// CONSTANTIN: here filtering irrelevant columns for the set filter type are filtered out
    	var isOfRequiredType = _.some( model.get('filterType'), function( type ) {
    	    return type === componentCaller || type === "ALL";
    	});
    	//console.log("decided whether to show column " + model.get("name") + ": " + isOfRequiredType)
    	if (!isOfRequiredType) {
    		self.remove (model);
    	}
    }
    // Expose this field for later usage.
    this.componentCaller = componentCaller;
  },


  parse: function(data) {
    //only keep filters with ui == true;
    data = _.filter(data, function(obj) {
      return obj.ui;
    });

    //remove orgs, groups, and types, because they are not filters on their own.
    // We use them down below.
    data = _.filter(data, function(obj) {
      return (obj.endpoint !== '/rest/filters/org-groups' &&
        obj.endpoint !== '/rest/filters/org-types' &&
        obj.endpoint !== '/rest/filters/org-roles' &&
        obj.endpoint !== '/rest/filters/orgs');
    });


    return data;
  },


  model: function(attrs, options) {
    var tmpModel = null;

    // slightly unconventional, but model is special case since it's called with
    // new so 'this' wont be the collection.
    var self = options.collection;

    // switch for model polymorphism.
    switch (attrs.id) {
      case 'Programs':
      case 'Sectors':
        self._allDeferreds.push(self._goOneDeeper(self, attrs));
        //tmp hack because we need to return something.
        tmpModel = new Backbone.Model({ui:false});
        break;
        
      default:
    	  if (attrs.id == 'Dates' || (attrs.id.length > 4 && attrs.id.substring(attrs.id.length - 4) == 'Date')) {
    		  tmpModel = new YearsFilterModel(attrs);  // hacky but less hacky than enumerating them. Long term solution -> the endpoint should return a field telling the type of a field
    	  } else {
    		  tmpModel = new GenericFilterModel(attrs);
    		  self._allDeferreds.push(tmpModel.getTree());
    	  }
    }

    return tmpModel;
  },

  // get endpoint's children and load them into self...
  _goOneDeeper: function(self, attrs) {
    var url = attrs.endpoint;
    var deferred = $.Deferred();
    var tmpDeferreds = [];

    var tmpCollection = new Backbone.Collection();
    tmpCollection.url = url;
    tmpCollection.fetch().then(function(data) {
      _.each(data, function(APIFilter) {
        var tmpModel = new GenericFilterModel({
          url: url + '/' + APIFilter.id,
          name: APIFilter.name,
          ui: true,
          group: attrs.id,
          empty: false
        });
        self.add(tmpModel);
        tmpDeferreds.push(tmpModel.getTree());
      });

      if (_.isEmpty(data)) {
        console.warn('Filters API returned empty', url);
        // Create empty model so the view doesnt fail.
        var tmpModel = new GenericFilterModel({
            url: url,
            name: attrs.name,
            ui: true,
            group: attrs.id,
            empty: true
          });
          self.add(tmpModel);
          tmpDeferreds.push(tmpModel.getTree());
      }
      
      $.when.apply($, tmpDeferreds).then(function() {
          deferred.resolve();
        });

    });

    return deferred;
  },


// ---------------------
// Special org and donor specific code since it has special behaviour
// ---------------------

  _createOrgFilters:function() {
    var self = this;

    // Create 'joins' for each type add ref to groups, and for each group add refs to orgs.
    return this._fetchOrgCollections().then(function() {

      // jsonify orgs and set them as children in groups.
      self.makeTreeHelper(self.orgGroupCollection, self.orgCollection, 'orgIds', 'children');


      // For each role create a filter with collection of just orgs that match.
      self.orgRolesCollection.each(function(role) {
        var tmpJSON = role.toJSON();

        // treat donor differently...
        if (role.get('name') === 'Donor') {
          self.makeTreeHelper(self.orgTypeCollection, self.orgGroupCollection, 'groupIds', 'children');
          // Create tree rootNode and raw JSON.
          _.extend(tmpJSON,
            {
              ui: true,
              group: 'Donor',
              data: self.orgTypeCollection.toJSON()
            });

          // filter orgs...
          tmpJSON.data = self._filterDonorOrgs(tmpJSON.data, role.id);
        } else {
          // Create tree rootNode and raw JSON.
          _.extend(tmpJSON,
            {
              ui: true,
              group: 'Role', //TODO: ?should this be 'Role' or role.id or role.get('name')?
              data: self.orgGroupCollection.toJSON()
            });

          //remove all orgs that don't belong in this role
          tmpJSON.data = self._filterOrgs(tmpJSON.data, role.id);
        }

        if (tmpJSON.data.length > 0) {
          var currentFilterId = role.get('name') + " Id";
          tmpJSON.data = self._setFilterId(tmpJSON.data, currentFilterId);
          self.add(new OrgRoleFilterModel(tmpJSON));
        }
      });

      //only needed for donor if we want to do special listening....:
      // self.joinHelper(self.orgTypeCollection, self.orgGroupCollection, 'groupIds', 'groups');
      // self.joinHelper(self.orgGroupCollection, self.orgCollection, 'orgIds', 'orgs');
    });
  },

  // explicitly sets the filter id on all the orgs.
  _setFilterId: function(collection, filterId){
    var self = this;
    _.each(collection, function(org) {
      //only set filterId on orgs, not group or type, or it will cause bugs.
      if(org.rolesIds){
        org.filterId = filterId;
      }
      if(org.children){
        org.children = self._setFilterId(org.children, filterId);
      }
    });

    return collection;
  },



  // filter orgs tree to only orgs that appear as the given roleID
  _filterOrgs: function(orgGroupsJSON, roleID) {
    orgGroupsJSON = _.filter(orgGroupsJSON, function(group) {
      group.children = _.filter(group.children, function(org) {
        return (org.rolesIds.indexOf(roleID) > -1);
      });
      group.isSelectable = false; //stops tree from creating 'unkown' children.
      return (group.children.length > 0);
    });
    return orgGroupsJSON;
  },


	  // special case for donor tree, since it has type
	_filterDonorOrgs : function(orgTypesJSON, roleID) {
		var self = this;
		orgTypesJSON = _.filter(orgTypesJSON, function(type) {
			type.children = self._filterOrgs(type.children, roleID);

			// The list of "Donor" has some special rules:
			// 1) It needs to be present in the amp_funding table even if the org hasnt the role "DN" (amp_org_role
			// table).
			// Failing to enforce this rule will cause some orgs to be missing (ie: MAYORALITIES) and others to appear
			// by
			// mistake (ie: WORLD DIABETES FOUNDATION), both in Moldova db.
			// So here we filter out those orgs that dont have funding. Notice we need to do it here because the all
			// filter
			// by org share the same data collections.
			for ( var i = 0; i < type.children.length; i++) {
				type.children[i].children = _.filter(type.children[i].children, function(item) {
					return (item['hasFundings'] === true);
				});
			}

			_.each(type.children, function(group) {
				group.filterId = 'Donor Group';
			});

			type.filterId = 'Donor Type';
			type.isSelectable = false; // stops tree from creating 'unkown' children.
			return (type.children.length > 0);
		});
		return orgTypesJSON;
	},

    // 1. get all orgs, groups, types, and roles
  _fetchOrgCollections: function() {
    var filterDeferreds = [];

    this.orgCollection = new Backbone.Collection();
    this.orgCollection.url = '/rest/filters/orgs';
    filterDeferreds.push(this.orgCollection.fetch());

    this.orgGroupCollection = new Backbone.Collection();
    this.orgGroupCollection.url = '/rest/filters/org-groups';
    filterDeferreds.push(this.orgGroupCollection.fetch());

    this.orgTypeCollection = new Backbone.Collection();
    this.orgTypeCollection.url = '/rest/filters/org-types';
    filterDeferreds.push(this.orgTypeCollection.fetch());

    this.orgRolesCollection = new Backbone.Collection();
    this.orgRolesCollection.url = '/rest/filters/org-roles';
    filterDeferreds.push(this.orgRolesCollection.fetch({}));

    return $.when.apply($, filterDeferreds);
  },


  // Adds references to collectionB into collectionA joining on given foreign key
  // TODO: option to add bi-directional reference.
  joinHelper: function(collectionA, collectionB, keyForForeignID, keyForCollectionDestination) {
    collectionA.each(function(modelA) {
      var idsToJoin = modelA.get(keyForForeignID);
      var tempCollection = collectionB.filter(function(modelB) {
        return _.indexOf(idsToJoin, modelB.get('id')) >= 0;
      });

      modelA.set(keyForCollectionDestination, tempCollection);
    });
  },

	  makeTreeHelper : function(parentCollection, childCollection, keyForForeignID, keyForCollectionDestination) {
		var self = this;
		var donorRole = _.filter(self.orgRolesCollection.models, function(item) {
			return item.get('name') === 'Donor'
		})[0];
		parentCollection.each(function(parent) {
			var idsToJoin = parent.get(keyForForeignID);
			var tempCollection = [];
			_.each(idsToJoin, function(id) {
				// id == 0 check should be redundent when Julian commits update.
				if (id !== 0) {
					var leaf = childCollection.get({
						id : id
					});
					if (leaf) {
						if (leaf.get('hasFundings') === true) {
							// Because of the business logic of old filters, if an organization has been used as a funding org
							// (present in amp_funding) then we need to
							// add it to the list of 'Donors' no matter which is the 'role' of that organization, so in order to
							// make it appear in the tree we also need to
							// add the 'DN' rol to it, otherwise it will be ignored even if its in tempCollection.
							var roles = leaf.get('rolesIds');
							if (roles != undefined) {
								roles.push(donorRole.get('id'));
								leaf.set('rolesIds', roles);
							}
						}
						tempCollection.push(leaf.toJSON());
					} else {
						// console.warn('missing id', childCollection, ' does not have an id of ', id);
					}
				}
			});
			parent.set(keyForCollectionDestination, tempCollection);
		});
	}
});

},{"../models/generic-filter-model":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/generic-filter-model.js","../models/org-role-filter-model":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/org-role-filter-model.js","../models/years-filter-model":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/years-filter-model.js","backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/lib/jquery.nouislider.min.js":[function(require,module,exports){
/*

$.Link (part of noUiSlider) - WTFPL */
(function(c){function m(a,c,d){if((a[c]||a[d])&&a[c]===a[d])throw Error("(Link) '"+c+"' can't match '"+d+"'.'");}function r(a){void 0===a&&(a={});if("object"!==typeof a)throw Error("(Format) 'format' option must be an object.");var h={};c(u).each(function(c,n){if(void 0===a[n])h[n]=A[c];else if(typeof a[n]===typeof A[c]){if("decimals"===n&&(0>a[n]||7<a[n]))throw Error("(Format) 'format.decimals' option must be between 0 and 7.");h[n]=a[n]}else throw Error("(Format) 'format."+n+"' must be a "+typeof A[c]+
".");});m(h,"mark","thousand");m(h,"prefix","negative");m(h,"prefix","negativeBefore");this.r=h}function k(a,h){"object"!==typeof a&&c.error("(Link) Initialize with an object.");return new k.prototype.p(a.target||function(){},a.method,a.format||{},h)}var u="decimals mark thousand prefix postfix encoder decoder negative negativeBefore to from".split(" "),A=[2,".","","","",function(a){return a},function(a){return a},"-","",function(a){return a},function(a){return a}];r.prototype.a=function(a){return this.r[a]};
r.prototype.L=function(a){function c(a){return a.split("").reverse().join("")}a=this.a("encoder")(a);var d=this.a("decimals"),n="",k="",m="",r="";0===parseFloat(a.toFixed(d))&&(a="0");0>a&&(n=this.a("negative"),k=this.a("negativeBefore"));a=Math.abs(a).toFixed(d).toString();a=a.split(".");this.a("thousand")?(m=c(a[0]).match(/.{1,3}/g),m=c(m.join(c(this.a("thousand"))))):m=a[0];this.a("mark")&&1<a.length&&(r=this.a("mark")+a[1]);return this.a("to")(k+this.a("prefix")+n+m+r+this.a("postfix"))};r.prototype.w=
function(a){function c(a){return a.replace(/[\-\/\\\^$*+?.()|\[\]{}]/g,"\\$&")}var d;if(null===a||void 0===a)return!1;a=this.a("from")(a);a=a.toString();d=a.replace(RegExp("^"+c(this.a("negativeBefore"))),"");a!==d?(a=d,d="-"):d="";a=a.replace(RegExp("^"+c(this.a("prefix"))),"");this.a("negative")&&(d="",a=a.replace(RegExp("^"+c(this.a("negative"))),"-"));a=a.replace(RegExp(c(this.a("postfix"))+"$"),"").replace(RegExp(c(this.a("thousand")),"g"),"").replace(this.a("mark"),".");a=this.a("decoder")(parseFloat(d+
a));return isNaN(a)?!1:a};k.prototype.K=function(a,h){this.method=h||"html";this.j=c(a.replace("-tooltip-","")||"<div/>")[0]};k.prototype.H=function(a){this.method="val";this.j=document.createElement("input");this.j.name=a;this.j.type="hidden"};k.prototype.G=function(a){function h(a,c){return[c?null:a,c?a:null]}var d=this;this.method="val";this.target=a.on("change",function(a){d.B.val(h(c(a.target).val(),d.t),{link:d,set:!0})})};k.prototype.p=function(a,h,d,k){this.g=d;this.update=!k;if("string"===
typeof a&&0===a.indexOf("-tooltip-"))this.K(a,h);else if("string"===typeof a&&0!==a.indexOf("-"))this.H(a);else if("function"===typeof a)this.target=!1,this.method=a;else{if(a instanceof c||c.zepto&&c.zepto.isZ(a)){if(!h){if(a.is("input, select, textarea")){this.G(a);return}h="html"}if("function"===typeof h||"string"===typeof h&&a[h]){this.method=h;this.target=a;return}}throw new RangeError("(Link) Invalid Link.");}};k.prototype.write=function(a,c,d,k){if(!this.update||!1!==k)if(this.u=a,this.F=a=
this.format(a),"function"===typeof this.method)this.method.call(this.target[0]||d[0],a,c,d);else this.target[this.method](a,c,d)};k.prototype.q=function(a){this.g=new r(c.extend({},a,this.g instanceof r?this.g.r:this.g))};k.prototype.J=function(a){this.B=a};k.prototype.I=function(a){this.t=a};k.prototype.format=function(a){return this.g.L(a)};k.prototype.A=function(a){return this.g.w(a)};k.prototype.p.prototype=k.prototype;c.Link=k})(window.jQuery||window.Zepto);/*

$.fn.noUiSlider - WTFPL - refreshless.com/nouislider/ */
(function(c){function m(e){return"number"===typeof e&&!isNaN(e)&&isFinite(e)}function r(e){return c.isArray(e)?e:[e]}function k(e,b){e.addClass(b);setTimeout(function(){e.removeClass(b)},300)}function u(e,b){return 100*b/(e[1]-e[0])}function A(e,b){if(b>=e.d.slice(-1)[0])return 100;for(var a=1,c,f,d;b>=e.d[a];)a++;c=e.d[a-1];f=e.d[a];d=e.c[a-1];c=[c,f];return d+u(c,0>c[0]?b+Math.abs(c[0]):b-c[0])/(100/(e.c[a]-d))}function a(e,b){if(100<=b)return e.d.slice(-1)[0];for(var a=1,c,f,d;b>=e.c[a];)a++;c=
e.d[a-1];f=e.d[a];d=e.c[a-1];c=[c,f];return 100/(e.c[a]-d)*(b-d)*(c[1]-c[0])/100+c[0]}function h(a,b){for(var c=1,g;(a.dir?100-b:b)>=a.c[c];)c++;if(a.m)return g=a.c[c-1],c=a.c[c],b-g>(c-g)/2?c:g;a.h[c-1]?(g=a.h[c-1],c=a.c[c-1]+Math.round((b-a.c[c-1])/g)*g):c=b;return c}function d(a,b){if(!m(b))throw Error("noUiSlider: 'step' is not numeric.");a.h[0]=b}function n(a,b){if("object"!==typeof b||c.isArray(b))throw Error("noUiSlider: 'range' is not an object.");if(void 0===b.min||void 0===b.max)throw Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
c.each(b,function(b,g){var d;"number"===typeof g&&(g=[g]);if(!c.isArray(g))throw Error("noUiSlider: 'range' contains invalid value.");d="min"===b?0:"max"===b?100:parseFloat(b);if(!m(d)||!m(g[0]))throw Error("noUiSlider: 'range' value isn't numeric.");a.c.push(d);a.d.push(g[0]);d?a.h.push(isNaN(g[1])?!1:g[1]):isNaN(g[1])||(a.h[0]=g[1])});c.each(a.h,function(b,c){if(!c)return!0;a.h[b]=u([a.d[b],a.d[b+1]],c)/(100/(a.c[b+1]-a.c[b]))})}function E(a,b){"number"===typeof b&&(b=[b]);if(!c.isArray(b)||!b.length||
2<b.length)throw Error("noUiSlider: 'start' option is incorrect.");a.b=b.length;a.start=b}function I(a,b){a.m=b;if("boolean"!==typeof b)throw Error("noUiSlider: 'snap' option must be a boolean.");}function J(a,b){if("lower"===b&&1===a.b)a.i=1;else if("upper"===b&&1===a.b)a.i=2;else if(!0===b&&2===a.b)a.i=3;else if(!1===b)a.i=0;else throw Error("noUiSlider: 'connect' option doesn't match handle count.");}function D(a,b){switch(b){case "horizontal":a.k=0;break;case "vertical":a.k=1;break;default:throw Error("noUiSlider: 'orientation' option is invalid.");
}}function K(a,b){if(2<a.c.length)throw Error("noUiSlider: 'margin' option is only supported on linear sliders.");a.margin=u(a.d,b);if(!m(b))throw Error("noUiSlider: 'margin' option must be numeric.");}function L(a,b){switch(b){case "ltr":a.dir=0;break;case "rtl":a.dir=1;a.i=[0,2,1,3][a.i];break;default:throw Error("noUiSlider: 'direction' option was not recognized.");}}function M(a,b){if("string"!==typeof b)throw Error("noUiSlider: 'behaviour' must be a string containing options.");var c=0<=b.indexOf("snap");
a.n={s:0<=b.indexOf("tap")||c,extend:0<=b.indexOf("extend"),v:0<=b.indexOf("drag"),fixed:0<=b.indexOf("fixed"),m:c}}function N(a,b,d){a.o=[b.lower,b.upper];a.g=b.format;c.each(a.o,function(a,e){if(!c.isArray(e))throw Error("noUiSlider: 'serialization."+(a?"upper":"lower")+"' must be an array.");c.each(e,function(){if(!(this instanceof c.Link))throw Error("noUiSlider: 'serialization."+(a?"upper":"lower")+"' can only contain Link instances.");this.I(a);this.J(d);this.q(b.format)})});a.dir&&1<a.b&&a.o.reverse()}
function O(a,b){var f={c:[],d:[],h:[!1],margin:0},g;g={step:{e:!1,f:d},start:{e:!0,f:E},connect:{e:!0,f:J},direction:{e:!0,f:L},range:{e:!0,f:n},snap:{e:!1,f:I},orientation:{e:!1,f:D},margin:{e:!1,f:K},behaviour:{e:!0,f:M},serialization:{e:!0,f:N}};a=c.extend({connect:!1,direction:"ltr",behaviour:"tap",orientation:"horizontal"},a);a.serialization=c.extend({lower:[],upper:[],format:{}},a.serialization);c.each(g,function(c,d){if(void 0===a[c]){if(d.e)throw Error("noUiSlider: '"+c+"' is required.");
return!0}d.f(f,a[c],b)});f.style=f.k?"top":"left";return f}function P(a,b){var d=c("<div><div/></div>").addClass(f[2]),g=["-lower","-upper"];a.dir&&g.reverse();d.children().addClass(f[3]+" "+f[3]+g[b]);return d}function Q(a,b){b.j&&(b=new c.Link({target:c(b.j).clone().appendTo(a),method:b.method,format:b.g},!0));return b}function R(a,b){var d,f=[];for(d=0;d<a.b;d++){var k=f,h=d,m=a.o[d],n=b[d].children(),r=a.g,s=void 0,v=[],s=new c.Link({},!0);s.q(r);v.push(s);for(s=0;s<m.length;s++)v.push(Q(n,m[s]));
k[h]=v}return f}function S(a,b,c){switch(a){case 1:b.addClass(f[7]);c[0].addClass(f[6]);break;case 3:c[1].addClass(f[6]);case 2:c[0].addClass(f[7]);case 0:b.addClass(f[6])}}function T(a,b){var c,d=[];for(c=0;c<a.b;c++)d.push(P(a,c).appendTo(b));return d}function U(a,b){b.addClass([f[0],f[8+a.dir],f[4+a.k]].join(" "));return c("<div/>").appendTo(b).addClass(f[1])}function V(d,b,m){function g(){return t[["width","height"][b.k]]()}function n(a){var b,c=[q.val()];for(b=0;b<a.length;b++)q.trigger(a[b],
c)}function u(d,p,e){var g=d[0]!==l[0][0]?1:0,H=x[0]+b.margin,k=x[1]-b.margin;e&&1<l.length&&(p=g?Math.max(p,H):Math.min(p,k));100>p&&(p=h(b,p));p=Math.max(Math.min(parseFloat(p.toFixed(7)),100),0);if(p===x[g])return 1===l.length?!1:p===H||p===k?0:!1;d.css(b.style,p+"%");d.is(":first-child")&&d.toggleClass(f[17],50<p);x[g]=p;b.dir&&(p=100-p);c(y[g]).each(function(){this.write(a(b,p),d.children(),q)});return!0}function B(a,b,c){c||k(q,f[14]);u(a,b,!1);n(["slide","set","change"])}function w(a,c,d,e){a=
a.replace(/\s/g,".nui ")+".nui";c.on(a,function(a){var c=q.attr("disabled");if(q.hasClass(f[14])||void 0!==c&&null!==c)return!1;a.preventDefault();var c=0===a.type.indexOf("touch"),p=0===a.type.indexOf("mouse"),F=0===a.type.indexOf("pointer"),g,k,l=a;0===a.type.indexOf("MSPointer")&&(F=!0);a.originalEvent&&(a=a.originalEvent);c&&(g=a.changedTouches[0].pageX,k=a.changedTouches[0].pageY);if(p||F)F||void 0!==window.pageXOffset||(window.pageXOffset=document.documentElement.scrollLeft,window.pageYOffset=
document.documentElement.scrollTop),g=a.clientX+window.pageXOffset,k=a.clientY+window.pageYOffset;l.C=[g,k];l.cursor=p;a=l;a.l=a.C[b.k];d(a,e)})}function C(a,c){var b=c.b||l,d,e=!1,e=100*(a.l-c.start)/g(),f=b[0][0]!==l[0][0]?1:0;var k=c.D;d=e+k[0];e+=k[1];1<b.length?(0>d&&(e+=Math.abs(d)),100<e&&(d-=e-100),d=[Math.max(Math.min(d,100),0),Math.max(Math.min(e,100),0)]):d=[d,e];e=u(b[0],d[f],1===b.length);1<b.length&&(e=u(b[1],d[f?0:1],!1)||e);e&&n(["slide"])}function s(a){c("."+f[15]).removeClass(f[15]);
a.cursor&&c("body").css("cursor","").off(".nui");G.off(".nui");q.removeClass(f[12]);n(["set","change"])}function v(a,b){1===b.b.length&&b.b[0].children().addClass(f[15]);a.stopPropagation();w(z.move,G,C,{start:a.l,b:b.b,D:[x[0],x[l.length-1]]});w(z.end,G,s,null);a.cursor&&(c("body").css("cursor",c(a.target).css("cursor")),1<l.length&&q.addClass(f[12]),c("body").on("selectstart.nui",!1))}function D(a){var d=a.l,e=0;a.stopPropagation();c.each(l,function(){e+=this.offset()[b.style]});e=d<e/2||1===l.length?
0:1;d-=t.offset()[b.style];d=100*d/g();B(l[e],d,b.n.m);b.n.m&&v(a,{b:[l[e]]})}function E(a){var c=(a=a.l<t.offset()[b.style])?0:100;a=a?0:l.length-1;B(l[a],c,!1)}var q=c(d),x=[-1,-1],t,y,l;if(q.hasClass(f[0]))throw Error("Slider was already initialized.");t=U(b,q);l=T(b,t);y=R(b,l);S(b.i,q,l);(function(a){var b;if(!a.fixed)for(b=0;b<l.length;b++)w(z.start,l[b].children(),v,{b:[l[b]]});a.s&&w(z.start,t,D,{b:l});a.extend&&(q.addClass(f[16]),a.s&&w(z.start,q,E,{b:l}));a.v&&(b=t.find("."+f[7]).addClass(f[10]),
a.fixed&&(b=b.add(t.children().not(b).children())),w(z.start,b,v,{b:l}))})(b.n);d.vSet=function(){var a=Array.prototype.slice.call(arguments,0),d,e,g,h,m,s,t=r(a[0]);"object"===typeof a[1]?(d=a[1].set,e=a[1].link,g=a[1].update,h=a[1].animate):!0===a[1]&&(d=!0);b.dir&&1<b.b&&t.reverse();h&&k(q,f[14]);a=1<l.length?3:1;1===t.length&&(a=1);for(m=0;m<a;m++)h=e||y[m%2][0],h=h.A(t[m%2]),!1!==h&&(h=A(b,h),b.dir&&(h=100-h),!0!==u(l[m%2],h,!0)&&c(y[m%2]).each(function(a){if(!a)return s=this.u,!0;this.write(s,
l[m%2].children(),q,g)}));!0===d&&n(["set"]);return this};d.vGet=function(){var a,c=[];for(a=0;a<b.b;a++)c[a]=y[a][0].F;return 1===c.length?c[0]:b.dir?c.reverse():c};d.destroy=function(){c.each(y,function(){c.each(this,function(){this.target&&this.target.off(".nui")})});c(this).off(".nui").removeClass(f.join(" ")).empty();return m};q.val(b.start)}function W(a){if(!this.length)throw Error("noUiSlider: Can't initialize slider on empty selection.");var b=O(a,this);return this.each(function(){V(this,
b,a)})}function X(a){return this.each(function(){var b=c(this).val(),d=this.destroy(),f=c.extend({},d,a);c(this).noUiSlider(f);d.start===f.start&&c(this).val(b)})}function B(){return this[0][arguments.length?"vSet":"vGet"].apply(this[0],arguments)}var G=c(document),C=c.fn.val,z=window.navigator.pointerEnabled?{start:"pointerdown",move:"pointermove",end:"pointerup"}:window.navigator.msPointerEnabled?{start:"MSPointerDown",move:"MSPointerMove",end:"MSPointerUp"}:{start:"mousedown touchstart",move:"mousemove touchmove",
end:"mouseup touchend"},f="noUi-target noUi-base noUi-origin noUi-handle noUi-horizontal noUi-vertical noUi-background noUi-connect noUi-ltr noUi-rtl noUi-dragable  noUi-state-drag  noUi-state-tap noUi-active noUi-extended noUi-stacking".split(" ");c.fn.val=function(){var a=arguments,b=c(this[0]);return arguments.length?this.each(function(){(c(this).hasClass(f[0])?B:C).apply(c(this),a)}):(b.hasClass(f[0])?B:C).call(b)};c.noUiSlider={Link:c.Link};c.fn.noUiSlider=function(a,b){return(b?X:W).call(this,
a)}})(window.jQuery||window.Zepto);

},{}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/main.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');

// loading hacks
var jQuery = require('jquery');
window.jQuery = window.$ = Backbone.$ = jQuery;
require('jquery-ui/draggable');
require('bootstrap/dist/js/bootstrap');


var FilterView = require('./views/filters-view');

// see README.md for documentation on using widget.


function Widget() {
  this.initialize.apply(this, arguments);
}

_.extend(Widget.prototype, Backbone.Events, {

  initialize: function(options) {
    var self = this;
    options = _.defaults(options, { draggable: true });
    if (_.has(options, 'sync')) {
      Backbone.sync = options.sync;
    }
    this.view = new FilterView(options);

    // used to make all filters request faster.
    this._cachedAllFilters = null;

    // loaded deferred to allow for other code to wait for filters to finish loading.
    this.loaded = this.view._loaded.promise();

    // proxy all filter events through here
    this.listenTo(this.view, 'all', function() {
      this.trigger.apply(this, arguments);
    });
  },

  // put the filters into the DOM tree post-initialization
  setElement: function() {
    this.view.setElement(arguments);
  },

  // this will stash current filter state, so it can be restored on cancel.
  showFilters: function() {
    this.view.showFilters();
  },


  // return models of all filters, even unselected ones..
  getAllFilters: function() {
    var self = this;
    return this.loaded.then(function(){
      // cache, because won't change. avoids calling serialize everytime.
      if(!this._cachedAllFilters){
        this._cachedAllFilters = self.view.serialize({includeUnselected: true, wholeModel: true});
      }
      return this._cachedAllFilters;
    });
  },

  // return models of serialized filter state, has entire models instead of just ids.
  serializeToModels: function() {
    return this.view.serialize({wholeModel: true});
  },

  // return json blob of serialized filter state, ids only.
  serialize: function() {
    return this.view.serialize({});
  },

  // restores filter state given a json blob, ids only.
  deserialize: function(stateBlob, options) {
    return this.view.deserialize(stateBlob, options);
  },

  // reset filters to empty state
  reset: function(options) {
    this.view.resetFilters();
    if (!options || !options.silent) {
      this.view.applyFilters();
    }
  },
  
  /**
   * searches the settings array of models for the ones which hold the min/max values instructed to and, if found,
   * writes them in filtersOut.otherFilters.date.{start}{end}
   * 
   * use it as an utility function (it does not reference 'this', so 
   * it is safe to use it at any point in the lifecycle of the widget
   */
  extractDates: function(settings, filtersOut, minName, maxName) {
	  filtersOut.otherFilters = filtersOut.otherFilters || {};
	  filtersOut.otherFilters.date = filtersOut.otherFilters.date || 
	  	{
    		start: '',
    		end: ''
		}

  	var defaultMinDate = _.find(settings, function(item) {
		return item.get('id') === minName;
	});
	if (defaultMinDate !== undefined && defaultMinDate.get('name') !== '') {
		filtersOut.otherFilters.date.start = defaultMinDate.get('name');
	}
	var defaultMaxDate = _.find(settings, function(item) {
		return item.get('id') === maxName;
	});
	if (defaultMaxDate !== undefined && defaultMaxDate.get('name') !== '') {
		filtersOut.otherFilters.date.end = defaultMaxDate.get('name');
	}
  },

});



module.exports = Widget;

},{"./views/filters-view":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/filters-view.js","backbone":"backbone","bootstrap/dist/js/bootstrap":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/bootstrap/dist/js/bootstrap.js","jquery":"jquery","jquery-ui/draggable":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/draggable.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/base-filter-model.js":[function(require,module,exports){
var Backbone = require('backbone');

  // Parent model for filters.
module.exports = Backbone.Model.extend({
  defaults: {
    name: 'Filter Name',
    method: 'GET',
    totalCount: 0,
    activeCount: 0,
    _loaded: false,
    empty: false
  },

  initialize:function(options) {
    this.set('name', options.name);
    this.set('group', options.group || options.id);
    this.set('method', options.method);
    this.set('column', options.column); 
    this.set('empty', options.empty || false);
    this.url =  options.url || options.endpoint;
  }

});

},{"backbone":"backbone"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/generic-filter-model.js":[function(require,module,exports){
var _ = require('underscore');

var BaseFilterModel = require('../models/base-filter-model');
var TreeNodeModel = require('../tree/tree-node-model');


module.exports = BaseFilterModel.extend({

  initialize:function(options) {
    BaseFilterModel.prototype.initialize.apply(this, [options]);
    this.getTree(); // starts getTree calls
  },

  // load tree if needed, else return what we already have..
  getTree: function() {
    var self = this;
    var loaded = this.get('_loaded');

    if (!loaded) {
      self.set('_loaded', this._createTree().then(function() {

        // trickle up numSelected.
    	  if(self.get('tree')!= undefined){
        self.get('tree').on('change:numSelected', function(model, value) {
          self.set('numSelected', value);
          self.set('numPossible', self.get('tree').get('numPossible'));
        });
    	  }
        return self.get('tree');
      }));
      
    }

    return this.get('_loaded');
  },

  getNumSelected: function(){
    var numSelected = this.get('numSelected');
    // if none selected, or all selected, treat the same.
    if (!numSelected || this.get('numSelected') === this.get('numPossible')) {
      return 0;
    } else {
      return numSelected;
    }
  },

  serialize: function(options) {
    var tree = this.get('tree');
    if (!tree) {
      //console.warn('no tree found', this.attributes);
      return {}; //no tree, nothing to serialize.
    } else {
      var tmpAry = tree.serialize(options);
      return tmpAry;
    }
  },

  deserialize: function(listOfSelected) {
    var self = this;
    var tree = this.get('tree');
    if (listOfSelected) {
      if (!tree) {
        console.warn('deserialize no tree found', self);
        return false; //no tree, nothing to serialize.
      } else {
        tree.deserialize(listOfSelected);
      }
    }
  },

  reset: function() {
    var tree = this.get('tree');
    if (tree) {
      // TODO: add a third type for semi-filled
      // force trigger, because otherwise nodes that are 'half-filled' but false won't refresh.
      tree.set('selected', true);
      tree.set('selected', false);

    }
  },

  _createTree: function() {
    if (!this.url) {
      this.url = this.get('endpoint');
    }

    return this.fetch({
      type: this.get('method'),
      data:'{}'
    })
    .fail(function(jqXHR, textStatus, errorThrown) {
      console.error('failed to get filter ', jqXHR, textStatus, errorThrown);
    });
  },

  parse: function(data) {
    var self = this;    

    //if it's an obj, jam it into an array first, helps solve inconsistancy in API format.
    if (!_.isArray(data)) {
      data = [data];
    }

    if (_.isArray(data) && data.length > 0) {
      var rootNodeObj = null;
      // Builds tree of views from returned data
      // If data is a single element, just make it the root..
      
      /* TODO-CONSTANTIN: temporary comment until I finish learning Filters frontend
      console.log("iterating " + data.length + " elems...");
      _.each(data, function(elem) {
    	  console.log("\tname = " + elem.name + ", id = " + elem.id);
      });
      */
      if (data.length === 1) {
    	if(data[0].filterId && !data[0].name) {
          data[0].name =  data[0].filterId;
        }
        if(data[0].values){
          data[0].children =  data[0].values;
        }

        data[0].isSelectable = false;
        
        //data[0].filterName = data[0].displayName;

        rootNodeObj = data[0];

      } else {
        rootNodeObj = {
          id: -1,
          code: '-1',
          name: self.get('name'),
          children: data,
          selected: undefined,
          expanded: false,
          isSelectable: false,
          createUnkowns: true/*,
          filterName: self.get('displayName')*/
        };
      }

      var treeModel = new TreeNodeModel(rootNodeObj);
      self.set('tree', treeModel);
    }

    return;
  }

});


},{"../models/base-filter-model":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/base-filter-model.js","../tree/tree-node-model":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/tree/tree-node-model.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/org-role-filter-model.js":[function(require,module,exports){
var $ = require('jquery');

var GenericFilterModel = require('../models/generic-filter-model');
var TreeNodeModel = require('../tree/tree-node-model');


module.exports = GenericFilterModel.extend({


  initialize:function(options) {
    this.loaded = $.Deferred();
    this._createTree(options.data);
    GenericFilterModel.prototype.initialize.apply(this, [options]);
  },

  //org doesn't have async part, but still use deferred, so behaves same as generic filter model
  getTree: function() {
    return this.loaded;
  },

  _createTree:function(data) {
    var self = this;
    var rootNodeObj = {};
    if (data.length === 1) {
      rootNodeObj = data[0];
    } else {
      rootNodeObj = {
        id: -1,
        code: '-1',
        name: self.get('displayName'),
        filterId: self.get('filterId'),
        children: data,
        selected: undefined,
        expanded: false,
        isSelectable: false,
        createUnkowns: false
      };
    }

    var treeModel = new TreeNodeModel(rootNodeObj);
    this.set('tree', treeModel);

    // trickle up numSelected.
    self.get('tree').on('change:numSelected', function(model, value) {
      self.set('numSelected', value);
      self.set('numPossible', self.get('tree').get('numPossible'));
    });

    this.loaded.resolve(treeModel);
  }

});


},{"../models/generic-filter-model":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/generic-filter-model.js","../tree/tree-node-model":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/tree/tree-node-model.js","jquery":"jquery"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/years-filter-model.js":[function(require,module,exports){
var $ = require('jquery');
var BaseFilterModel = require('../models/base-filter-model');


module.exports = BaseFilterModel.extend({


  defaults: {
    selectedStart: null,
    selectedEnd: null,
    // range is provided by api, but will fallback to this if not provided, or set to -1
    startYear: '',
    endYear: ''
  },
  
  sync: function () {
	  /**
	   * hackish: the data coming off the /dates endpoint should be ignored at all moments, because
	   * 1. for tabs/saiku, it should always be empty
	   * 2. for gis/dashboards, it is coming off the /setting endpoint
	   * 
	   * All the other years-filter-model should by spec be always empty at this point. In case this would cease to be true in the future,
	   * just filter by "name"
	   */ 
	  	
	  //console.error('SYNCING YEARS MODEL: ' + this.get('name'));
	  return $.when(true);
  },

  initialize: function(options) {
    BaseFilterModel.prototype.initialize.apply(this, [options]);
    this.url = options.endpoint;
    this.set('_loaded', $.Deferred());
  },

  parse: function(data) {
	  console.log('years-filter-model.parse: data = ' + JSON.stringify(data));
    if (!data.startYear || data.startYear === -1) {
      data.startYear = this.defaults.startYear;
    } else {
      data.startYear = data.startYear + '-01-01';
    }
    if (!data.endYear || data.endYear === -1) {
      data.endYear = this.defaults.endYear;
    } else {
      data.endYear = data.endYear + '-12-31';
    }

    if (!data.selectedStart) {
    	// good ole' partial copy-paste off postprocess()
    	data.selectedStart = data.startYear;
    	data.selectedEnd = data.endYear;
    }
    this.get('_loaded').resolve();
    return data;
  },

  serialize: function() {
    if (this.get('selectedStart')) {
    	  var key = this.get('column')!='N/A' ? this.get('column'):'date';
    	  console.log('serializing years-filter-model for ' + key + ', start = ' + this.get('selectedStart') + ', end = ' + this.get('selectedEnd'));    	  
    	  var obj = {};
    	  obj[key] = {
				  //start: this._dateConvert(this.get('selectedStart')),
				  //end: this._dateConvert(this.get('selectedEnd'))
				  start: this.get('selectedStart'),
				  end: this.get('selectedEnd')
			 };
    	  return obj;
    } else {
      return null;
    }
  },

  /**
   * postprocess model after having fetched data from the server
   */
  postprocess: function() {
	  // only set if not set by deserialize
	  if (!this.get('selectedStart')) {
	  	  this.set('selectedStart', this.get('startYear'));
	   	  this.set('selectedEnd', this.get('endYear'));
	  }
  },
  
  deserialize: function(obj) {
	var key = this.get('column') != 'N/A' ? this.get('column') : 'date';
	if (obj && obj[key]) {
	  this.set('selectedStart', this._dateConvert(obj[key].start));
	  this.set('selectedEnd', this._dateConvert(obj[key].end));
      this.postprocess();
	}
  },

  reset: function() {
    this.set('selectedStart', this.get('startYear'));
    this.set('selectedEnd', this.get('endYear'));
  },

  // converts: 03/01/1961 ==> 1961-01-01 IF NEEDED.
  // DOES NOT CONVERT from the "-" format to "/" format anymore
  // 
  // amp expects with '-' and jQuery wants with '/'
  _dateConvert: function(input){
	  console.log('asked to convert input: ' + input);
    var output = null;
    if (input) {
      if (input.indexOf('/')>-1){
        input = input.split('/');
        output = input[2] + '-' + input[1] + '-' + input[0];
      } else {
    	  output = input;
      }
      /* else if(input.indexOf('-')>-1){
      }
        input = input.split('-');
        output = input[2] + '/' + input[1] + '/' + input[0];
      }*/
    }
    return output;
  }

});

},{"../models/base-filter-model":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/base-filter-model.js","jquery":"jquery"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/tree/tree-node-model.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var TreeNodeModel; // declare here to help with ref loop of collection and model
var TreeNodeCollection = Backbone.Collection.extend({  model:TreeNodeModel });

//TODO: propagation bug if mid level node is half filled and you 'deselect all' it won't propogate to children.

TreeNodeModel = Backbone.Model.extend({
  defaults:{
    selected: undefined,  // default is selected. change to string / ternary, for off, semi, and on
    expanded: true,
    visible: true,
    numSelected: 0,
    numPossible: 0,
    children: null,     // type TreeNodeCollection
    isSelectable: false  // is this node itself selectable (ie. should it have an 'unkown' child)
  },

  initialize:function(obj) {
    var self = this;
    var childrenCollection = new TreeNodeCollection();
    this.set('children', childrenCollection);
    
    /* TODO-CONSTANTIN: temporary comment until I am finished learning Filters frontend 
     console.log("building a tree node model for: " + JSON.stringify(obj));
     */
    
    //iterate over children
    if (Array.isArray(obj.children)) {
      _.each(obj.children, function(child) {
        var newChild = new TreeNodeModel(child);
        childrenCollection.add(newChild);
      });
    }

    // if we have children, then add self as a leaf node, 'unkown'
    if (!childrenCollection.isEmpty() &&  this.get('isSelectable')) {
      var unkownNode = new TreeNodeModel(self.toJSON());
      unkownNode.set('name', 'unkown: ' + this.get('name'));
      childrenCollection.add(unkownNode);
    }

    this._addListenersToChildren();

    this.on('change:selected', self._onSelectChange);

    this._updateCount();
  },


  // merge based on filterId as we serialize....
  // options.wholeModel returns whole Models instead of just ids
  // options.includeUnselected returns full tree, even if nodes are not selected.
  // Code explicitly ignores Donor Group and Donor Type.
  //   they only have FilterIds for deserialize for backwards compatibility.
  // TODO: consider pulling out options.includeUnselected into its own function getAllFilters()
  serialize: function(options) {
    var tmpSerialized = {};
    var children = this.get('children');

    /**
        
     
  +--^----------,--------,-----,--------^-,
  | |||||||||   `--------'     |          O
  `+---------------------------^----------|
    `\_,---------,---------,--------------'
      / XXXXXX /'|       /'
     / XXXXXX /  `\    /'                      TO INVESTIGATE: why is this function called for 4 times (!!!) per each item when pressing "apply"?
    / XXXXXX /`-------'
   / XXXXXX /
  / XXXXXX /
 (________(                
   
    
// 
//    if ((this.get('name')== 'Yes') || (this.get('name') == 'No') || (this.get('name') == 'All') || this.get('name') == 'Humanitarian Aid' || this.get('name') == 'Disaster Response Marker') {
//    	console.log('serializing node with name ' + this.get('name') + ", selected: " + this.get('selected'));
//
//    	debugger;
//    }
*/
    
    if (options.includeUnselected) {
      if(this.get('filterId') && this.get('filterId') !== 'Donor Group' && this.get('filterId') !== 'Donor Type'){
        tmpSerialized[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
      } else{
        tmpSerialized.unassigned = (options.wholeModel? [this]:[this.id]);
      }
      this._serializeChildren(tmpSerialized, children, options);
    } else{
      if (children.length > 0) {

        // If all children are selected, and we have our own filterId, then just use our id, don't recurse.
        if(this.get('numSelected') >= this.get('numPossible') && this.get('filterId') && this.get('filterId') !== 'Donor Group' && this.get('filterId') !== 'Donor Type'){
          tmpSerialized[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
        }
        else {
          this._serializeChildren(tmpSerialized, children, options);
        }

      } else {
        //no children so just return self.
        if (this.get('selected')) {
          if(this.get('filterId') && this.get('filterId') !== 'Donor Group' && this.get('filterId') !== 'Donor Type'){
            tmpSerialized[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
          } else{
            tmpSerialized.unassigned = (options.wholeModel? [this]:[this.id]);
          }
        }
      }
    }

    this._mergeUnassigned(tmpSerialized);
    return tmpSerialized;
  },

  _serializeChildren: function(tmpSerialized, children, options){
    children.each(function(child) {
      var serializedChild = child.serialize(options);
      _.each(serializedChild, function(v,k){
        if(v){
          //merge if key exists
          if (tmpSerialized[k]) {
            tmpSerialized[k] = tmpSerialized[k].concat(v);
          } else {
            tmpSerialized[k] = v;
          }
        }
      });
    });
  },

  _mergeUnassigned: function(tmpSerialized){
    // if current node has a filterId put all 'unassigned' elements under this.
    if(this.get('filterId')){
      var filterId = this.get('filterId');
      if(tmpSerialized[filterId] && tmpSerialized.unassigned){
        tmpSerialized[filterId] = tmpSerialized[filterId].concat(tmpSerialized.unassigned);
        delete tmpSerialized.unassigned;
      } else if (tmpSerialized.unassigned){
        tmpSerialized[filterId] = tmpSerialized.unassigned;
        delete tmpSerialized.unassigned;
      }
    }
  },

  deserialize: function(blob) {
    var self = this;
    var children = this.get('children');
    if (children.length > 0) {
      children.each(function(child) {
        if(!child.get('filterId') && self.get('filterId')){
          child.set('filterId', self.get('filterId'));
        }
        child.deserialize(blob);
      });
    }

    if(blob[this.get('filterId')]){
      if (_(blob[this.get('filterId')]).indexOf(this.id) > -1) {
        this.set('selected', true, {propagation: true});
      } else if (children.length === 0) {
        this.set('selected', false, {propagation: true});
      }
    }
  },


  _onSelectChange:function(model, argument, options) {
    var self = this;
    var children = this.get('children');

    if (this.get('selected')) {
      this.set('numSelected', this.get('numPossible'));
    } else {
      this.set('numSelected', 0);
    }

    if (!children.isEmpty()) {
      self._updateChildNodes(options.propagation);
    }

    if (options.propagation) {
      self.trigger('updateCount');
    }
  },


  _addListenersToChildren:function() {
    var self = this;
    var children = this.get('children');
    children.each(function(child) {
      child.on('change:visible', function() {
        // If no children are visible, then hide self.
        if (!children.findWhere({visible: true})) {
          self.set({visible: false});
        } else {
          self.set({visible: true});
        }
      });
      child.on('updateCount', function() {
        self._updateCount();
        self.trigger('updateCount');
      });
    });
  },

  _updateCount:function() {
    var children = this.get('children');
    var countTotal = {
      selected: 0,
      possible:0
    };

    if (!children.isEmpty()) {
      children.each(function(child) {
        countTotal.selected += child.get('numSelected');
        countTotal.possible += child.get('numPossible');
      });
    } else {
      countTotal = {
        selected: (this.get('selected') ? 1 : 0),
        possible: 1
      };
    }

    this.set('numSelected', countTotal.selected);
    this.set('numPossible', countTotal.possible);
  },

  _updateChildNodes:function(propagation) {
    var self = this;
    var children = this.get('children');

    if (!children.isEmpty()) {
      children.each(function(child) {
        child.set('selected', self.get('selected'), {propagation: propagation});
      });
    }
  },

  filterText: function(txt) {
    var children = this.get('children');

    if (!children.isEmpty()) {
      // if the node itself matches, turn it on, even if no children are visible.
      if (this.get('name') && this.get('name').toLowerCase().indexOf(txt) > -1) {
        this.set('visible', true);
      }

      // FYI: putting inside an else above keeps children visible if parent matches.
      children.each(function(child) {
        child.filterText(txt);
      });

    } else {
      if (this.get('name') && this.get('name').toLowerCase().indexOf(txt) > -1) {
        this.set('visible', true);
      } else {
        this.set('visible', false);
      }
    }
  }

});


module.exports = TreeNodeModel;

},{"backbone":"backbone","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/tree/tree-node-view.js":[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var $ = require('jquery');

var Template = "<div class=\"node small\">\n  <div class=\"selectable\"></div>\n  <div class=\"toggle-nav\">\n    <% if(name.length > 63){ %>\n      <span title=\"<%= name %>\"><%= name.substring(0,60) %>...</span>\n    <% } else { %>\n      <%= name %>\n    <% } %>\n\n\n    <span class=\"count\">(<%= numSelected %> / <%= numPossible %>)</span>\n    <span class=\"expanded\">+</span>\n  </div>\n\n  <% /*TODO: fix hardcode of 'unkown' */\n  if (obj.name && obj.name.indexOf(\"unkown\")>-1) { %>\n    &nbsp;<a href=\"#\"\n      data-toggle=\"popover\"\n      data-container=\"body\"\n      data-placement=\"right\"\n      data-trigger=\"click\"\n      data-content=\"projects that aren't tagged to a specific child.\">\n      <span class=\"glyphicon glyphicon-info-sign\"></span>\n    </a>\n  <%}%>\n</div>\n";


var TreeNodeView = Backbone.View.extend({

  tagName: 'li',
  className: 'parent_li',

  //TODO: debug after usability testing, currently setting in addUIListeners
  // won't work on second use of widget.
  // events: {
  //   'click .selectable': 'select',
  //   'click  .toggle-nav': 'clickName'
  // },

  template: _.template(Template),

  initialize:function() {
  },


  render:function(model) {
    this.model = model;
    if (model) {
      this.$el.html(this.template(model.toJSON()));
      this.renderChildren();
    }

    return this;
  },

  renderChildren:function() {
    var ul = $('<ul>');
    this.$el.append(ul);

    var children = this.model.get('children');
    if (!children.isEmpty()) {
      children.each(function(child) {
        var tmpView = new TreeNodeView();
        ul.append(tmpView.render(child).$el);
      });
    } else {
      this.$('.expanded').remove();
      this.$('> .node > .toggle-nav > .count').text('');
    }

    this._addModelListeners();
    this._addUIListeners();

    this._updateSelection();
    this._updateExpanded(ul);
  },

  _addModelListeners:function() {
    var self = this;

    //Add model listeneres
    this.model.on('change:selected', function() {
      self._updateSelection();
    });

    this.model.on('change:expanded', function() {
      self._updateExpanded();
    });

    this.model.on('change:numSelected', function() {
      self._updateCountUI();
    });

    this.model.on('change:visible', function() {
      self._updateVisibility();
    });
  },

  _addUIListeners:function() {
    var self = this;
    this.$('> .node > .selectable').on('click', function() {
      self.clickBox();

    });
    this.$('> .node > .toggle-nav').on('click', function() {
      self.clickName();
    });
  },

  _updateSelection:function() {
    this._updateCheckboxFill();
  },

  _updateCountUI:function() {
    if (!this.model.get('children').isEmpty()) {
      this.$('> .node > .toggle-nav > .count').text(
        '(' + this.model.get('numSelected') + ' / ' + this.model.get('numPossible') + ')');
      this._updateCheckboxFill();
    }
  },

  _updateVisibility: function() {
    if (this.model.get('visible')) {
      this.$el.show();
    } else {
      this.$el.hide();
    }
  },


  // For updating non-leaf nodes
  _updateCheckboxFill:function() {
    if (!this.model.get('children').isEmpty()) {
      if (this.model.get('numSelected') > 0) {
        if (this.model.get('numSelected') < this.model.get('numPossible')) {
          this.$('> .node > .selectable').addClass('half-fill');
          this.$('> .node > .selectable').removeClass('selected');
        } else {
          this.$('> .node > .selectable').removeClass('half-fill');
          this.$('> .node > .selectable').addClass('selected');
        }
      } else if (this.model.get('numSelected') === 0) {
        this.$('> .node > .selectable').removeClass('half-fill');
        this.$('> .node > .selectable').removeClass('selected');
      }
    } else { // else leaf node
      if (this.model.get('selected')) {
        this.$('> .node > .selectable').addClass('selected');
      } else {
        this.$('> .node > .selectable').removeClass('selected');
      }
    }
  },

  _updateExpanded:function(ul) {
    var iElement = this.$('> .node > .toggle-nav > .expanded');
    if (this.model.get('expanded')) {
      this.expand();
      iElement.text('-');
      iElement.addClass('open').removeClass('closed');
    } else {
      this.collapse();

      // to run on first time...need to use ul, since el is not on DOM yet
      if (ul) {
        ul.find('> li').hide();
      }

      iElement.text('+');
      iElement.addClass('closed').removeClass('open');
    }
  },


  clickBox:function() {
    this.model.set('selected', !this.model.get('selected'), {propagation: true});
  },


  clickName:function() {
    // if we have children expand
    if (!this.model.get('children').isEmpty()) {
      this.model.set('expanded', !this.model.get('expanded'));
    } else {
      // leaf node, so pretend the clicked on the box
      this.clickBox();
    }
  },


  collapse:function() {
    var children = this.$el.find(' > ul > li');
    children.hide('fast');

  },

  expand:function() {
    var children = this.$el.find(' > ul > li');
    children.show('fast');
  }

});

module.exports = TreeNodeView;

},{"backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/base-filter-view.js":[function(require,module,exports){

var _ = require('underscore');
var $ = require('jquery');

var Backbone = require('backbone');
var TitleTemplate = "<li>\n\t<a href=\"#\">\n\t\t<span data-i18n=\"amp.gis:pane-subfilters-<%= name.replace(/ /g,'') %>\">\n\t\t\t<%= name %>\n\t\t</span>   \n\t\t<span class='filter-count small pull-right'></span>\n\t</a>\n</li>";
var ContentTemplate = "<%\n  // this renders the \"big\" filter list (the tabs)\n%>\n<div class=\"panel-heading\">\n  <a type=\"button\" class=\"close cancel\"  aria-hidden=\"true\">&times;</a>\n  <h3 data-i18n=\"amp.gis:title-filters\" class=\"panel-title\">Filters</h3>\n</div>\n<div class=\"panel-body filter-body\">\n\n  <ul class=\"nav nav-tabs filter-titles\" role=\"tablist\">\n  </ul>\n\n  <div class=\"tab-content filter-options\">\n    <img src=\"img_2/loading-icon.gif\" />\n  </div>\n</div>\n<div class=\"panel-footer\">\n  &nbsp;\n  <div class=\"pull-right\" style=\"display: inline-block; margin-bottom: 5px;\">\n    <button type=\"button\" class=\"btn btn-sm btn-danger reset\"  data-i18n=\"amp.gis:button-reset\"  title=\"Turn off all filters.\">Reset</button>\n    <button type=\"button\" class=\"btn btn-sm btn-warning cancel\"  data-i18n=\"amp.gis:button-cancel\"  title=\"Revert filters to state when opened.\">Cancel</button>\n    <button type=\"button\" class=\"btn btn-sm btn-success apply\"  data-i18n=\"amp.gis:button-apply\" >Apply</button>\n  </div>\n</div>\n";

// Parent base view for filters.
module.exports = Backbone.View.extend({

  className: 'filter-type',

  titleTemplate: _.template(TitleTemplate),
  contentTemplate: _.template(ContentTemplate),

  initialize:function(options) {
    this.app = options.app;
  },

  renderFilters: function() {

  },

  renderTitle: function() {	  
    var self = this;
    this.titleEl = this.titleTemplate(this.model.toJSON());
    this.$titleEl = $(this.titleEl);
    this.$titleEl.on('click', function(evt) {
      // console.log('handling the click on low-level titleEl...'); CONSTANTIN TEMP COMMENT WHILE LEARNING FILTERS
      $(this).siblings().removeClass('active');
      $(this).addClass('active');

      self.$el.html('');
      self.renderFilters();
      return false;
    });

    return this;
  }

});

},{"backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/filters-view.js":[function(require,module,exports){
/**
 * this is the view which renders the big Filter contents (the tabs)
 */

var $ = require('jquery');
var _ = require('underscore');
var Backbone = require('backbone');

var Translator = require('amp-translate');

var TopLevelFilterView = require('../views/top-level-filter-view');
var AllFilterCollection = require('../collections/all-filters-collection');


var Template = "<%\n  // this renders the \"big\" filter list (the tabs)\n%>\n<div class=\"panel-heading\">\n  <a type=\"button\" class=\"close cancel\"  aria-hidden=\"true\">&times;</a>\n  <h3 data-i18n=\"amp.gis:title-filters\" class=\"panel-title\">Filters</h3>\n</div>\n<div class=\"panel-body filter-body\">\n\n  <ul class=\"nav nav-tabs filter-titles\" role=\"tablist\">\n  </ul>\n\n  <div class=\"tab-content filter-options\">\n    <img src=\"img_2/loading-icon.gif\" />\n  </div>\n</div>\n<div class=\"panel-footer\">\n  &nbsp;\n  <div class=\"pull-right\" style=\"display: inline-block; margin-bottom: 5px;\">\n    <button type=\"button\" class=\"btn btn-sm btn-danger reset\"  data-i18n=\"amp.gis:button-reset\"  title=\"Turn off all filters.\">Reset</button>\n    <button type=\"button\" class=\"btn btn-sm btn-warning cancel\"  data-i18n=\"amp.gis:button-cancel\"  title=\"Revert filters to state when opened.\">Cancel</button>\n    <button type=\"button\" class=\"btn btn-sm btn-success apply\"  data-i18n=\"amp.gis:button-apply\" >Apply</button>\n  </div>\n</div>\n";
var TitleTemplate = "<%\n// renders the title of a tab \n%>\n<li class=\"\"><a data-i18n=\"amp.gis:pane-filters-<%= name.replace(/ /g,'') %>\" href=\"#filter-pane-<%= name.replace(/ /g,'') %>\" role=\"tab\" data-toggle=\"tab\"><%= name %></a></li>\n";

module.exports = Backbone.View.extend({
  id: 'tool-filters',
  name: 'Filters',
  apiURL: '/rest/filters',

  events: {
    'click .apply': 'applyFilters',
    'click .cancel': 'cancel',
    'click .reset': 'resetFilters'
  },

  // collection of top-level-filter views..
  filterViewsInstances:{},

  template: _.template(Template),
  titleTemplate: _.template(TitleTemplate),

  initialize:function(options) {
    var self = this;
    this.draggable = options.draggable;
    
    if(options.translator === undefined) {
    	this.createTranslator();
    } else {
    	this.translator = options.translator;
    }

    this.firstRender = true;

    // Create top level views
    this._createTopLevelFilterViews();

    this.allFilters = new AllFilterCollection([],options);
    this._loaded =  this.allFilters._loaded;
    this._getFilterList().then(function() {
      self.allFilters.each(function(model) {
        self._createFilterViews(model);
      });
      return this;
    });

  },

  _createTopLevelFilterViews: function() {
    this.filterViewsInstances = {
      donors: new TopLevelFilterView({name:'Funding Organizations', translator: this.translator, translate: this.translate}),
      sectors: new TopLevelFilterView({name:'Sector', translator: this.translator, translate: this.translate}),
      programs: new TopLevelFilterView({name:'Programs', translator: this.translator, translate: this.translate}),
      activity: new TopLevelFilterView({name:'Activity', translator: this.translator, translate: this.translate}),
      allAgencies: new TopLevelFilterView({name:'All Agencies', translator: this.translator, translate: this.translate}),
      financials: new TopLevelFilterView({name:'Financial', translator: this.translator, translate: this.translate}),
      locations: new TopLevelFilterView({name:'Location', translator: this.translator, translate: this.translate}),
      others: new TopLevelFilterView({name:'Other', translator: this.translator, translate: this.translate})
    };
  },


  render: function() {
    var self = this;
    this.$el.addClass('panel panel-primary');
    if (this.draggable) {
      this.$el.draggable({ cancel: '.panel-body, .panel-footer', cursor: 'move'  });
    }

    if (this.firstRender) {
      this.$el.html(this.template({}));
      this.$el.show();

      this._getFilterList().done(function() {
    	  self.renderFilters();
    	  self.translate();
      });

      //debugger; // wth does thing not work in saiku?
      // handle click on a Tab's title: http://getbootstrap.com/javascript/#tabs-events
      $(document).on('shown.bs.tab click', "ul.nav.filter-titles>li>a[data-toggle='tab']", function (e) {  // <- this line makes little sense but works in Saiku/Tabs also
      //this.$el.find("ul.nav.filter-titles>li>a[data-toggle='tab']").on('shown.bs.tab', function (e) {   // <- this line works in anything except Saiku/Tabs
         /**
          * the 'click' event added because (weirdly) the shown.bs.tab event not being fired AT ALL under Saiku/Tabs. Until this is investigated
          * on GIS/Dashboard tabs this second event is superfluous
          */ 
      	
     	   //e.target // newly activated tab
     	   //e.relatedTarget // previous active tab
      	
     	   var activeTab = $(e.target.parentElement).index(); // shameful hack, but haven't been able to find a cleaner solution
     	   var oldTabNr = e.relatedTarget ? $(e.relatedTarget.parentElement).index() : -1;
     	   console.log('switching from filters tab ' + oldTabNr + ' to tab ' + activeTab);
     	   $(e.target).closest('ul.filter-titles').attr('active-tab-number', activeTab); // not used in the current implementation of the code
     	   
     	   // render the first item of the tab
     	   var tabId = $(e.target).attr('href');
     	   var tabFirstChild = $(tabId).find('ul.sub-filters-titles>li:first a');
     	   if (tabFirstChild)
     		   tabFirstChild.click();
        });

      this.firstRender = false;
    } else {
    	self.translate();
    }

    return this;
  },
  
  createTranslator: function(force) {
	  var self = this;
	  var filterTranslateKeys = JSON.parse("{\n  \"amp.gis:title-Country\": \"Country\",\n  \"amp.gis:title-Region\": \"Region\",\n  \"amp.gis:title-Zone\": \"Zone\",\n  \"amp.gis:title-District\": \"District\",\n  \"amp.gis:title-filters\": \"Filter\",\n  \"amp.gis:title-filters\": \"Filter\",\n  \"amp.gis:pane-filters-search\": \"Go\",\n  \"amp.gis:pane-filters-select\": \"select all\",\n  \"amp.gis:pane-filters-deselect\": \"deselect all\",\n  \"[placeholder]amp.gis:pane-filters-search-placeholder\": \"Search...\",\n  \"amp.gis:pane-filters-FundingOrganizations\": \"Funding Organizations\",\n  \"amp.gis:pane-filters-Sector\": \"Sector\",\n  \"amp.gis:pane-filters-Programs\": \"Programs\",\n  \"amp.gis:pane-filters-Activity\": \"Activity\",\n  \"amp.gis:pane-filters-AllAgencies\": \"All Agencies\",\n  \"amp.gis:pane-filters-Financial\": \"Financial\",\n  \"amp.gis:pane-filters-Location\": \"Location\",\n  \"amp.gis:pane-filters-Other\": \"Other\",\n  \"amp.gis:pane-subfilters-Donor\": \"Donor\",\n  \"amp.gis:pane-subfilters-Primary\": \"Primary\",\n  \"amp.gis:pane-subfilters-Secondary\": \"Secondary\",\n  \"amp.gis:pane-subfilters-NationalPlanObjective\": \"National Plan Objective\",\n  \"amp.gis:pane-subfilters-ActivityStatus\": \"Activity Status\",\n  \"amp.gis:pane-subfilters-ApprovalStatus\": \"Approval Status\",\n  \"amp.gis:pane-subfilters-ImplementingAgency\": \"Implementing Agency\",\n  \"amp.gis:pane-subfilters-ExecutingAgency\": \"Executing Agency\",\n  \"amp.gis:pane-subfilters-BeneficiaryAgency\": \"Beneficiary Agency\",\n  \"amp.gis:pane-subfilters-ContractingAgency\": \"Contracting Agency\",\n  \"amp.gis:pane-subfilters-AidModality\": \"Aid Modality\",\n  \"amp.gis:pane-subfilters-TypeOfAssistance\": \"Type Of Assistance\",\n  \"amp.gis:pane-subfilters-ResponsibleOrganization\": \"Responsible Organization\",\n  \"amp.gis:pane-subfilters-Dates\": \"Dates\",\n  \"amp.gis:pane-subfilters-RegionalGroup\": \"Regional Group\",\n  \"amp.gis:pane-subfilters-SectorGroup\": \"Sector Group\",\n  \"amp.gis:pane-filters-all\": \"all\",\n  \"amp.gis:button-reset\": \"Reset\",\n  \"amp.gis:button-cancel\": \"Cancel\",\n  \"amp.gis:button-apply\": \"Apply\",\n  \"amp.gis:pane-subfilters-startdate\": \"Start Date:\",\n  \"amp.gis:pane-subfilters-enddate\": \"End Date:\",\n  \"amp.gis:pane-subfilters-empty\": \"No data for this filter\"\n}\n");
	  // setup any popovers as needed...
	  self.popovers = self.$('[data-toggle="popover"]');
	  self.popovers.popover();
	  if (force === true || self.translator === undefined) {
		  console.log('Create translator for filters.');
		  self.translator = new Translator({defaultKeys: filterTranslateKeys});
	  }
  },
  
  translate: function(target) {
	  var element = this;
	  if (target !== undefined) {
		  element = target;
	  }
	  if (element.el !== undefined) {
		  this.translator.translateDOM(element.el);
	  } else {
		  this.translator.translateDOM(element);
	  }	  
  },

  /**
   * renders the tabs within the filters, only rendering the first item of the active tab (the others don't have their first item's contents rendered for performance reasons)
   */
  renderFilters: function() {
    this.$('.filter-options').html('');

    var renderingTitleNumber = -1;
    var activeTitleNumber = this.$('.filter-titles').attr('active-tab-number') || 0;
    
    for (var filterView in this.filterViewsInstances) {
      if (this.filterViewsInstances.hasOwnProperty(filterView)) {
        var tmpFilterView = this.filterViewsInstances[filterView];
        renderingTitleNumber = renderingTitleNumber + 1;
        // console.log('rendering top-level-filter-view ' + tmpFilterView.name); CONSTANTIN - comment to be removed once filters sanitisation is done
        this.$('.filter-titles').append(tmpFilterView.renderTitle().titleEl);
        var active = renderingTitleNumber == activeTitleNumber;
        this.$('.filter-options').append(tmpFilterView.renderFilters(active).el);
      }
    }

    // Opens the first tab in the filter
    this.$('.filter-titles a:first').tab('show');
  },


  _getFilterList: function() {
    return this.allFilters.load();
  },

  _createFilterViews: function(tmpModel) {
    // TODO: magic strings are dangerous, config somewhere...
    switch (tmpModel.get('group')) {
      case 'ActivityBudgetList':
      case 'TypeOfAssistanceList':
      case 'ModeOfPaymentList':
      case 'FinancingInstrumentsList':
        this.filterViewsInstances.financials.filterCollection.add(tmpModel);
        break;
      case 'ActivityStatusList':
      case 'ActivityApprovalStatus':
        this.filterViewsInstances.activity.filterCollection.add(tmpModel);
        break;
      case 'Programs':
        this.filterViewsInstances.programs.filterCollection.add(tmpModel);
        break;
      case 'Sectors':
        this.filterViewsInstances.sectors.filterCollection.add(tmpModel);
        break;
      case 'Donor':
        this.filterViewsInstances.donors.filterCollection.add(tmpModel);
        break;
      case 'Role':
        this.filterViewsInstances.allAgencies.filterCollection.add(tmpModel);
        break;
      case 'LocationList':
          this.filterViewsInstances.locations.filterCollection.add(tmpModel);
          break;
      default:
        this.filterViewsInstances.others.filterCollection.add(tmpModel);
    }

  },


  //TODO: move from view to all-collection
  serialize: function(options) {
    var self = this;
    var serializedFilters = {'columnFilters':{}, 'otherFilters':{} };

	this.allFilters.each(function(filter) {
		// TODO: build a util for bettermerge that concat's array if
		// duplicate keys in objects...
		if (filter.get('id') || filter.url) {
			if (filter.get('name').indexOf('Date') != -1 
					|| (filter.get('column') != undefined && filter.get('column').indexOf('Date') != -1)) {
				_.extend(serializedFilters.otherFilters, filter.serialize(options));
			} else {
				var serialized = filter.serialize(options);
				if (options.wholeModel === true) {
					var keys = [];
					for(var k in serialized) keys.push(k);					
					if (keys[0] !== undefined && serialized[keys[0]] !== undefined) {
						serialized[keys[0]].filterName = (filter.get('displayName') || filter.get('name'));
					}
			    }				
				_.extend(serializedFilters.columnFilters, serialized);
			}
		}
	});

    //remove empty / false values.
    _.each(serializedFilters, function(v, k) {
      if(!v || _.isEmpty(v)) {
        delete serializedFilters[k];
      }
    });

    return serializedFilters;
  },

  deserialize: function(blob, options) {
    if (blob) {
      var that = this;
      that.allFilters.each(function(filter) {
    	  if (filter.get('id') || filter.url) {
    		  if(filter.get('name').indexOf('Date')!=-1 || (filter.get('column') != undefined && filter.get('column').indexOf('Date') != -1)) { 
		          filter.deserialize(blob.otherFilters);
	         } else{
		          filter.deserialize(blob.columnFilters);
		        }
	    	}
      });
    } else {
      console.warn('could not deserialize blob:', blob);
    }
    if (!options || !options.silent) {
      this.applyFilters();  // triggers the "apply" event
    }
  },

  showFilters: function() {
    this.render();
    this.filterStash = null;  // in case they haven't loaded yet, don't try to .serialize()
    this._loaded.done(_.bind(function() { this.filterStash = this.serialize({}); }, this));
  },

  resetFilters: function() {
    this.allFilters.each(function(filter) {
      filter.reset();
    });
  },

  applyFilters: function() {
    this._loaded.done(_.bind(function() {
      var state = this.serialize({});
      this.trigger('apply', state);
    }, this));
  },

  cancel: function() {
    if(this.filterStash){
      this.deserialize(this.filterStash, {silent: true});
    }
    this.trigger('cancel', this.filterStash);
  }
});


},{"../collections/all-filters-collection":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/collections/all-filters-collection.js","../views/top-level-filter-view":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/top-level-filter-view.js","amp-translate":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-translate/index.js","backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/generic-filter-view.js":[function(require,module,exports){

var _ = require('underscore');

// var GenericFilterModel = require('../models/generic-filter-model');
var TreeNodeView = require('../tree/tree-node-view');
var BaseFilterView = require('../views/base-filter-view');
var Template = "<% if (!empty) { %>\n\t<div class=\"search-form\">\n\t  <div class=\"input-group form-group\">\n\t    <input type=\"text\" data-i18n=\"[placeholder]amp.gis:pane-filters-search-placeholder\" class=\"form-control search-text\" placeholder=\"Search...\">\n\t    <span class=\"input-group-btn\">\n\t      <button data-i18n=\"amp.gis:pane-filters-search\" class=\"btn btn-success\">Go</button>\n\t    </span>\n\t  </div><!-- /input-group -->\n\t</div>\n\t<div class=\"toggle-all\">\n\t  <em>\n\t    <a href=\"#\" data-i18n=\"amp.gis:pane-filters-select\" class=\"select-all\" >select all</a> /\n\t    <a href=\"#\"  data-i18n=\"amp.gis:pane-filters-deselect\" class=\"select-none\" >deselect all</a>\n\t  </em>\n\t</div>\n\t\n\t<div class=\"tree tree-container\" style=\"\"></div><!--display:none;-->\n<% } else { %>\n\t<span data-i18n='amp.gis:pane-subfilters-empty'></span>\n<% } %>\n";


// This is a generic model for filters. It assumes a tree structure.
// If you don't want a tree structure just extend base-filter
module.exports = BaseFilterView.extend({

  className: BaseFilterView.prototype.className + ' filter-generic',
  template: _.template(Template),
  _loaded: null,

  events:{
    // attach in filter render instead since these events are attached to the el object
    // and then namespaced. this means that the way we re-use
    // DOM elements will accidentally trigger multiple events.
    // 'click  .select-all': '_selectAll',
    // 'click  .select-none': '_selectNone',
    //'keyup input.search-text': 'searchKeyUp'
  },

  initialize:function(options) {
    var self = this;
    BaseFilterView.prototype.initialize.apply(this, [options]);

    this.model = options.model;
    this.translator = options.translator;
    this.translate = options.translate;
    this.treeView = new TreeNodeView();

    // Create tree view
    // TODO: make tree loading content responsibility of model, not view...
    this.model.getTree().then(function(treeModel) {
      if (treeModel) {
        self._updateCountInMenu();
        treeModel.on('change:numSelected', function() {
          self._updateCountInMenu();
        });
      } else {
        console.warn('no tree for: ', self.model);
      }
    });
  },

  searchKeyUp: function(event) {
    if (event.keyCode === 13 || // Pressed 'enter'
      this.$('.search-text').val() === '' ||
      this.$('.search-text').val().length > 1
      ) {
      this.model.get('tree').filterText(this.$('.search-text').val().toLowerCase());
    }
  },


  _updateCountInMenu:function() {
    if (this.$titleEl && this.model.get('tree')) {
      if (this.model.get('tree').get('numSelected') === this.model.get('tree').get('numPossible') ||
          this.model.get('tree').get('numSelected') === 0) {
    	  this.$titleEl.find('.filter-count').attr('data-i18n','amp.gis:pane-filters-all');
    	  this.$el.removeClass('active');    	  
    	  this.translate($(this.el).parent().find('ul .active'));
      } else {
        this.$titleEl.find('.filter-count').text(this.model.get('tree').get('numSelected') +
          '/' +
          this.model.get('tree').get('numPossible'));
        this.$el.addClass('active');
        this.$titleEl.find('.filter-count').attr('data-i18n','');
      }
    }
  },
	
  renderTitle : function() {
	  BaseFilterView.prototype.renderTitle.apply(this);
	  this._updateCountInMenu();
	  return this;
  },

  renderFilters:function() {
    var self = this;
    BaseFilterView.prototype.renderFilters.apply(this);

    this.model.getTree().then(function(treeModel) {
      self.$el.html(self.template(self.model.toJSON()));

      // add event listeners
      self.$('.select-none').on('click', function() {self._selectNone(); return false;}); //return false to stop page refresh.
      self.$('.select-all').on('click', function() {self._selectAll(); return false;}); //return false to stop page refresh.
      self.$('input.search-text').on('keyup', function(event) {self.searchKeyUp(event);});

      if (treeModel) {
        self.$('.tree-container').append(self.treeView.render(self.model.get('tree')).$el);
        treeModel.set('expanded', true);
        treeModel.filterText('');//default no filter.
      } else{
        self.$('.tree-container').append("");
      }
    })
    .done(function() {
    	self.translate(self);
    })
    .fail(function(){
      console.error('renderFilters failed :(');
    });

    return this;
  },

  _selectAll: function() {
    // force trigger even if already this state (important for half-fill ui
    this.model.get('tree').set('selected', false);
    this.model.get('tree').set('selected', true);
    //this.model.get('tree').set('selected', true, {silent: true });
    //.model.get('tree').trigger('change:selected', this.model.get('tree'), null, {propogation:false});
  },

  _selectNone: function() {
    // force trigger even if already this state (important for half-fill ui)
    this.model.get('tree').set('selected', true);
    this.model.get('tree').set('selected', false);
    // this.model.get('tree').set('selected', false, {silent: true });
    // this.model.get('tree').trigger('change:selected', this.model.get('tree'), null, {propogation:false});
  }

});


},{"../tree/tree-node-view":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/tree/tree-node-view.js","../views/base-filter-view":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/base-filter-view.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/top-level-filter-view.js":[function(require,module,exports){

var _ = require('underscore');
var $ = require('jquery');

var Backbone = require('backbone');
var TitleTemplate = "<%\n// renders the title of a tab \n%>\n<li class=\"\"><a data-i18n=\"amp.gis:pane-filters-<%= name.replace(/ /g,'') %>\" href=\"#filter-pane-<%= name.replace(/ /g,'') %>\" role=\"tab\" data-toggle=\"tab\"><%= name %></a></li>\n";
var ContentTemplate = "<%\n // renders the contents of a filter's tab (e.g. for example the \"Contracting / Implementing / Executing / Primary Beneficiary / Secondary Beneficiary Agency\" list of the \"All Agencies\" tab)\n // <h6>mde  %- Math.random() </h6>\n%>\n<ul class=\"sub-filters-titles nav nav-pills nav-stacked\">\n</ul>\n<div class=\"sub-filters-content\">\n  <img src=\"img_2/loading-icon.gif\" />\n</div>\n";

var GenericFilterView = require('../views/generic-filter-view');
var YearsFilterView = require('../views/years-filter-view');

var YearsFilterModel = require('../models/years-filter-model');


//TODO: rename to 'group' to be consistent
// Parent base view for filters.
module.exports = Backbone.View.extend({
  className:  'tab-pane',
  titleTemplate: _.template(TitleTemplate),
  contentTemplate: _.template(ContentTemplate),
  filterCollection: null,
  viewList:[],
  name: 'tbd',

  initialize:function(options) {
    var self = this;
    this.name = options.name;
    this.translator = options.translator;
    this.translate = options.translate;
    this.filterCollection = new Backbone.Collection();
    this.filterCollection.on('change:numSelected', function(){
      self._refreshTitle();
    });
  },

  /**
   * renders the items in a tab
   * the first element of the tab's contents will be rendered IFF options.renderFirstElement has been specified
   */
  renderFilters: function(renderFirstElement) {
    var self = this;
    var view = null;
    var first = true;
    this.$el.attr('id', 'filter-pane-' + this.name.replace(/ /g,''));
    this.$el.html(this.contentTemplate());
    // renders the tabs of the filter (one tab for each filterCollection element)
    this.filterCollection.each(function(filter) {
    	//console.log('\trendering filter ' + filter.get('name') + '...'); // Constantin: harmless debug message to be removed once the filters sanitisation is done
    	if (filter instanceof YearsFilterModel) {
    		view = new YearsFilterView({
    			model:filter,
    			el: self.$('.sub-filters-content'),
    			translator: self.translator,
    			translate: self.translate
    		});
    		self.viewList.push(view);
    	} else {
    		view = new GenericFilterView({
    			model:filter,
    			el: self.$('.sub-filters-content'),
    			translator: self.translator,
    			translate: self.translate
    		});
    		self.viewList.push(view);
    	}

    	var titleElem = view.renderTitle().$titleEl;
    	self.$('.sub-filters-titles').append(titleElem);

    	// hacky way to open first one for now.
    	if (first && renderFirstElement) {
    		first = false;
    		view.renderFilters();
    		self.$('.sub-filters-titles li:first').addClass('active');
    	}
    });
    
    // We need to re-translate some strings from the right panel.
	self.translate(this);

   	return this;
  },

  _refreshTitle: function(){
    var totalSelected = 0;
    var countStr ='';

    this.filterCollection.each(function(filter) {
      if(filter.getNumSelected){
        totalSelected += filter.getNumSelected();
      }
    });

    if( totalSelected !== 0) {
      countStr = totalSelected;
    }

    // TODO: should be locally scoped, not global jquery.
    $('#'+this.name.replace(/ /g,'') + ' .title-count').text(countStr);
  },

  /**
   * renders the title of a tab
   */
  renderTitle: function() {
    this.titleEl = this.titleTemplate({name: this.name});
    return this;
  }
});

},{"../models/years-filter-model":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/models/years-filter-model.js","../views/generic-filter-view":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/generic-filter-view.js","../views/years-filter-view":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/years-filter-view.js","backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/years-filter-view.js":[function(require,module,exports){

var _ = require('underscore');
var BaseFilterView = require('../views/base-filter-view');

require('../lib/jquery.nouislider.min.js');
require('jquery-ui/datepicker');

var Template = "\n  <h3 class=\"title text-center\"><span class=\"start-year\">dummy</span> <strong>-</strong> <span class=\"end-year\">dummy</span></h3>\n   <div class=\"year-slider\"></div>\n\n   <span data-i18n=\"amp.gis:pane-subfilters-startdate\">Start Date:</span>&nbsp<p><input type=\"text\" id=\"start-date\" class=\"date-picker\"></p>\n   <span data-i18n=\"amp.gis:pane-subfilters-enddate\">End Date:</span>&nbsp<p><input type=\"text\" id=\"end-date\" class=\"date-picker\"></p>\n";

module.exports = BaseFilterView.extend({

  className: BaseFilterView.prototype.className + ' filter-years',
  template: _.template(Template),
  _loaded: null,

  initialize:function(options) {
    var self = this;
    BaseFilterView.prototype.initialize.apply(this, [options]);

    this.model = options.model;
    this.translator = options.translator;
    this.translate = options.translate;
//    console.log("just built a years-filter-view for " + self.model.get('name'));
    this._loaded = this.model.fetch().then(function() {
    	//console.log("just loaded a years-filter-view for: " + JSON.stringify({name: self.model.get('name'), start: self.model.get('selectedStart'), end: self.model.get('selectedEnd')}));
    });

    this.listenTo(this.model, 'change', this._updateTitle);
  },


  renderFilters:function() {
    var self = this;
    BaseFilterView.prototype.renderFilters.apply(this);

    this.$el.html(this.template(this.model.toJSON()));

    this._loaded.then(function() {
      //self._renderSlider();
      self._renderDatePickers();
      self._updateTitle();
      
      // We need to re-translate some strings from the right panel.
      self.translate(self);
    });

    return this;
  },

  _renderDatePickers: function() {
    var self = this;

    // TODO: format based on admin setting....maybe get from year api..
    // TODO: abstract common properties from object inits below...
    // var commonObj = {};

    this.$('#start-date').datepicker({
      defaultDate: this.model.get('selectedStart'),
      //minDate: this.model.get('startYear'),
      //maxDate: this.model.get('endYear'),
      dateFormat: 'yy-mm-dd',
      changeMonth: true,
      changeYear: true,
      numberOfMonths: 1,
      yearRange: 'c-60:c+60',
      onClose: function(selectedDate) {
        self.$('#end-date').datepicker('option', 'minDate', selectedDate);
        self.model.set('selectedStart', selectedDate);
        // self._updateTitle();
      }
    });    

    this.$('#end-date').datepicker({
      defaultDate: this.model.get('selectedEnd'),
      //minDate: this.model.get('startYear'),
      //maxDate: this.model.get('endYear'),
      dateFormat: 'yy-mm-dd',
      changeMonth: true,
      changeYear: true,
      numberOfMonths: 1,
      yearRange: 'c-60:c+60',
      onClose: function(selectedDate) {
        self.$('#start-date').datepicker('option', 'maxDate', selectedDate);
        self.model.set('selectedEnd', selectedDate);
        // self._updateTitle();
      }
    });

    this.$('#start-date').val(this.model.get('selectedStart'));
    this.$('#end-date').val(this.model.get('selectedEnd'));
  },

  renderTitle:function() {
    BaseFilterView.prototype.renderTitle.apply(this);
    this._updateTitle();

    return this;
  },

  //TODO: do more in template.
  _updateTitle:function() {	
    this.$titleEl.find('.filter-count').text(this.model.get('selectedStart') +
        ' - ' +
      this.model.get('selectedEnd'));

    //console.log('updating years title for ' + this.model.get('name') + ', start-year: ' + this.model.get('selectedStart') + ', end-year: ' + this.model.get('selectedEnd'));
    this.$('.start-year').text(this.model.get('selectedStart'));
    this.$('.end-year').text(this.model.get('selectedEnd'));
  },



  _renderSlider: function() {
    var self = this;

    // uses window.jQuery because that was the only way I had luck with browserify shim...
    // uses https://github.com/leongersen/noUiSlider
    this.slider = window.jQuery(this.$('.year-slider')).noUiSlider({
      start: [self.model.get('selectedStart'), self.model.get('selectedEnd')],
      step: 1,
      connect: true,
      range: {min: self.model.get('startYear'), max:self.model.get('endYear')},
      serialization: {
        lower: [
          window.jQuery.Link({
            target: window.jQuery('.start-year')
          })
        ],
        upper: [
          window.jQuery.Link({
            target: window.jQuery('.end-year')
          })
        ],
        format: {
          decimals: 0
        }
      }
    });

    //ugly, too much data in the dom...but it's how the example goes.
    this.slider.on('change', function() {
      self.model.set('selectedStart', parseInt(self.$('.start-year').text(), 10));
    });

    //ugly, too much data in the dom...but it's how the example goes.
    this.slider.on('change', function() {
      self.model.set('selectedEnd',  parseInt(self.$('.end-year').text(), 10));
    });
  }

});

},{"../lib/jquery.nouislider.min.js":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/lib/jquery.nouislider.min.js","../views/base-filter-view":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/src/views/base-filter-view.js","jquery-ui/datepicker":"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-filter/node_modules/jquery-ui/datepicker.js","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-state/index.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


function StateLoadError(message, original) {
  if (!(this instanceof StateLoadError)) { return new SateLoadError(message, original); }
  this.message = message;
  this.original = original;

  this.toString = function() {
    return this.message;
  };

  return this;
}


function State() {
  'use strict';

  if (!(this instanceof State)) {
    throw new Error('State needs to be created with the `new` keyword.');
  }

  this.initialize.apply(this, arguments);
}


_.extend(State.prototype, Backbone.Events, {

  initialize: function(options) {
    this.saved = options.saved;
    // Anything that state must register itself. See `State.register`.
    this._stateRegistry = {};
    // When loading state, some things might not have registered yet.
    // It gets marked as unclaimed, and stored here.
    this._unclaimed = {};
    // use the url, if we have it
    if (options.url) {
      this.listenToURL(_(options).pick('url', 'prefix', 'autoinit'));
    }
  },

  listenToURL: function(options) {
    this._url = options.url;
    this._urlPrefixes = options.prefix || ['saved/'];

    // wrap prefixes in array to make backward compat:
    if (this._urlPrefixes.constructor !== Array){
      this._urlPrefixes = [this._urlPrefixes];
    }

    this.listenTo(this._url, 'change', this.urlMaybeLoad);
    if (options.autoinit && this._url.hash()) {
      this.urlMaybeLoad(this._url.hash());
    }  // initial state
  },

  urlMaybeLoad: function(hash) {
    var self = this;
    var matchFound = false;
    hash = hash || this._url.hash();

    // see if any prefixes match the hash.
    _.each(this._urlPrefixes, function(prefix){
      // load a state if we get the URL hash for one
      if (hash.indexOf(prefix) === 0) {
        var state_or_id = hash.split(prefix)[1];
        if (state_or_id) {
          matchFound = true;
          self[self.saved ? 'loadById' : 'load'](state_or_id, prefix);
        }
      }
    });
    if (!matchFound && hash === '') {
      self.reset();
    }
  },

  toHash: function(state_or_id) {
    if (!_(this).has('_url')) {
      console.error('Cannot generate URL hash without being initialized with URL instance');
    } else {
      return this._urlPrefixes[0] + state_or_id;
    }
  },

  loadById: function(id, matchedPrefix) {
    this.loadPromise = this.saved.load(id, matchedPrefix  );// TODO: drs: and pass matching prefix..
    this.loadPromise
      .done(_(function(stateModel) {
        this.load(stateModel.get('stateBlob'));
      }).bind(this))
      .fail(function() {
        throw new StateLoadError('Could not load state by id: ' + id);
      });
  },

  load: function(statesBlob) {
    var parsed = this.parse(statesBlob);

    var changed = false;
    _.each(parsed, function(stateToSet, id) {
      var current = this._stateRegistry[id];
      if (_.isUndefined(current)) {
        this._unclaimed[id] = stateToSet;
      } else if (!_.isEqual(current.get(), stateToSet)) {
        current.set(stateToSet);
        changed = true;
      }
    }, this);

    this.trigger('load');
    if (changed) {
      this.trigger('change');
    }
  },

  parse: function(statesBlob) {
    // break out the call to JSON.parse so that load can still be optimized
    var parsed;
    try {
      parsed = JSON.parse(statesBlob);
    } catch (e) {
      if (e instanceof SyntaxError) {
        throw new StateLoadError('Could not parse state', e);
      } else {
        throw e;
      }
    }
    return parsed;
  },

  reset: function() {
    // Restore all states to their defaults (specified at registration)
    var changed = false;
    _.each(this._stateRegistry, function(state) {
      var currentState = state.get();
      if (!_.isEqual(currentState, state.empty)) {
        // only call .set if resetting will actually change the state.
        state.set(state.empty);
        changed = true;
      }
    }, this);

    this.trigger('reset');
    if (changed) {
      this.trigger('change');
    }
  },

  freeze: function(options) {
    options = options || {};
    var stateSnapshot = {};
    _.each(this._stateRegistry, function(state, id) {
      var currentState = state.get();
      stateSnapshot[id] = _.clone(currentState);  // TODO: deep clone(!!)
    });
    var statesBlob = JSON.stringify(stateSnapshot);
    if (options.toURL) {
      if (!this._url) { console.error('State cannot change URL if it does have a ref to it'); }
      this._url.hash(this._urlPrefixes[0] + encodeURIComponent(statesBlob));
    }
    this.trigger('freeze', statesBlob);
    return statesBlob;
  },

  register: function(registrable, id, options) {
    if (id in this._stateRegistry) {
      throw new Error('Attempted registration of duplicate state id ' + id);
    }

    // register the state
    this._stateRegistry[id] = {
      get: _.bind(options.get, registrable),
      set: _.bind(options.set, registrable),
      empty: options.empty
    };

    // set to the currently loaded state, or its default empty state
    if (id in this._unclaimed) {
      this._stateRegistry[id].set(this._unclaimed[id]);
      delete this._unclaimed[id];
    } else {
      this._stateRegistry[id].set(options.empty);
    }

    this.trigger('register');
  }
});


State.StateLoadError = StateLoadError;
module.exports = State;

},{"backbone":"backbone","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-translate/index.js":[function(require,module,exports){
// TODO: move this up a dir, and instantiate and attach to the app


var _ = require('underscore');
var $ = require('jquery');
var Backbone = require('backbone');

function Translator(options) {
  'use strict';

  if (!(this instanceof Translator)) {
    throw new Error('Translator needs to be created with the `new` keyword.');
  }

  // this is the object that has all  the key value pairs for the widget.
  var translatorDefaults = {
    defaultKeys: {},
    availableLanguages: null,// backbone collection
    translations: {
      locales: {
        en:null
      }
    },
    ajax: $.ajax
  };

  /* Gather options */
  if (options) {
    /* Especially useful for overwriting defaultKeys, availableLanguages and translations */
    _.defaults(this, options, translatorDefaults);
  }

  this._promise = null;
  this._currentLng = 'tmp';
  this._firstGet = null;

  // TODO: add support for local storage with timestamp
  this.initTranslations = function get() {
    var self = this;


    // try web
    this._promise = this._getTranslationsFromAPI(self.defaultKeys)
      .fail(function(jqXHR, textStatus, errorThrown) {
        console.error('failed ', jqXHR, textStatus, errorThrown);
      });
    this.promise = this._promise.promise();
  };

  /* Use this for adding more defaultKeys or translations by module
   * if translator has already been instantiated
   */
  this.addTranslatorOptions = function(options) {
    /* force a request from API next time */
    _.defaults(this.defaultKeys, options.defaultKeys);
    this._firstGet = null;
  };


  this.getAvailableLanguages = function() {
    var deferred = $.Deferred();

    if (this.availableLanguages) {
      deferred.resolve(this.availableLanguages);
    } else {
      this._initAvailableLanguages().then(function() {
        deferred.resolve(this.availableLanguages);
      });
    }

    return deferred;
  };

  this._initAvailableLanguages = function() {
    this.availableLanguages = new Backbone.Collection([]);
    this.availableLanguages.url = '/rest/translations/languages';
    return this.availableLanguages.fetch();
  };


  // important to let the api know, so all responses are translated.
  this.setLanguage = function(lng) {
    this._currentLng = lng;
    return this._apiCall('/rest/translations/languages/' + lng, null, 'GET');
  };


  this.translateDOM = function(el) {

    var $newEl = $(el);

    /* TODO handle [title]gis.app:menu-item-tooltip */

    /* TODO(tdk): We identified a major bug here where root immediate child
     *  template elements with translations are not being caught by this
     *  selector.
     *
     *  To workaround, we should clone, wrap, run the selector and unwrap the DOM.
     *
     *  Remember this has to work for el's around the app that are bound
     *  and not bound.
     */

    return this.getTranslations().then(function(data) {
      $.each(data, function(key, value) {
        /*if ($('[data-i18n="' + key + '"]', $newEl).length > 0) {
          console.log(key, '->', value,' $ found->', $newEl.find('[data-i18n="' + key + '"]').text());
        }*/
    	
    	// We need a way to identify controls where the placeholder needs to be translated instead of the text.
	 	if (key.indexOf('[placeholder]') > -1) {
	 		$('[data-i18n="' + key + '"]', $newEl).attr('placeholder', value);
		} else {
			$('[data-i18n="' + key + '"]', $newEl).text(value);
		}
      });
      return $newEl;
    });
  };


  /*
   * Pass in a {"amp.gis:data-i18n-code": "base lang words", ...} object for
   * translation e.g. page title
   * */
   // TODO: don't call it a list if it's an object ?!
  this.translateList = function(list) {

    // update translateable elements in this key-value set
    var _updateList = function(list, i18nData) {
      _.each(list, function(value, key, list) {
        if (i18nData[key]) {
          list[key] = i18nData[key];
        } else {
          list[key] = key[value];
        }
      });
      return list;
    };

    return this.getTranslations().then(function(i18nData) {
      var outList = _updateList(list, i18nData);
      return outList;
    });
  };


  /*
   * Synchronously get a (already-loaded) translation
   */
  this.translateSync = function(key, alt) {
    if (this.getTranslations().state() !== 'resolved') {
      console.error('translateSync was called when getTranslations is not successfully resolved');
    }
    var translated = this.translations.locales[this._currentLng][key];
    if (translated === undefined) {
      console.warn('No translation has been loaded for', key);
      translated = alt || key;
    }
    return translated;
  };


  // Only do single request on launch.
  this.getTranslations = function() {
    // this way won't work with change languages mid way though.
    if (!this._firstGet) {
      this._firstGet = this._getTranslationsFromAPI(this.defaultKeys, this._currentLng);
    }
    return this._firstGet;
  };


  this._getTranslationsFromAPI = function(translateables, lng) {
    var self = this;
    var url = '/rest/translations/label-translations';

    return this._apiCall(url, translateables, 'POST').then(function(data) {
      //cache if we know the lng. TODO: get api to always return the lng.
      if (lng) {
        self.translations.locales[lng] = data;
      } else {
        // temp hack to do caching if API doesn't return current lng
        lng = this._currentLng;
        self.translations.locales[lng] = data;
      }

      return data;
    });
  };


  // helper to wrap api call
  this._apiCall = function(url, data, type) {
    var ajaxOptions = {
      headers: {
        // jscs:disable disallowQuotedKeysInObjects
        'Accept': 'application/json',
        'Content-Type': 'application/json'
        // jscs:enable disallowQuotedKeysInObjects
      },
      type: type,
      url: url,
      dataType: 'json'
    };
    if (data) {
      ajaxOptions.data = JSON.stringify(data);
    }

    return this.ajax(ajaxOptions);
  };

  this.initTranslations();
}

module.exports = Translator;

},{"backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"/fastdata/dg-workspace/amp-2.10-release/TEMPLATE/ampTemplate/node_modules/amp-url/index.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


function URL() {
  'use strict';
  if (!(this instanceof URL)) {
    throw new Error('URL needs to be created with the `new` keyword.');
  }
  if (window._ampUrler) {
    throw new Error('Another instance of URL is already managing window.location');
  } else {
    window._ampUrler = true;
  }
  this.initialize.apply(this, arguments);
}


_.extend(URL.prototype, Backbone.Events, {

  initialize: function(options) {
    options = options || {};
    this.root = options.root || window.location.host + window.location.pathname;
    _.bindAll(this, 'change');
    window.addEventListener('hashchange', this.change);  // IE 8+
  },

  hash: function(newHash, options) {
    if (!arguments.length) {
      return window.location.hash.slice(1);  // remove '#'
    } else {
      if (options.silent) { window.removeEventListener('hashchange', this.change); }  // IE 9+
      window.location.hash = newHash;
      if (options.silent) { window.addEventListener('hashchange', this.change); }
    }
  },

  full: function() {
    return '' + window.location;
  },

  change: function() {
    this.trigger('change', this.hash());
  }

});


module.exports = URL;

},{"backbone":"backbone","underscore":"underscore"}]},{},["./app/js/app.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuL2FwcC9qcy9hcHAuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2FwcC1jbGFzcy5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvYmFja2JvbmUtZGFzaC5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvY2hhcnRzL19iYXIuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2NoYXJ0cy9fbXVsdGliYXIuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2NoYXJ0cy9fcGllLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9jaGFydHMvX3RhYmxlLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9jaGFydHMvY2hhcnQuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2NoYXJ0cy9jb21tb24uanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2NoYXJ0cy9jdXN0b21pemVkL211bHRpQmFyQ2hhcnQuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2NoZWNrLXN1cHBvcnQuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL21vZGVscy9jaGFydC1haWQtcHJlZGljdGFiaWxpdHkuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL21vZGVscy9jaGFydC1mdW5kaW5nLXR5cGUuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL21vZGVscy9jaGFydC1tb2RlbC1iYXNlLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9tb2RlbHMvY2hhcnQtdG9wcy5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvbW9kZWxzL2NoYXJ0cy1jb2xsZWN0aW9uLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9tb2RlbHMvZW5hYmxlZC1jaGFydHMtY29sbGVjdGlvbi5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvbW9kZWxzL3NhdmVkLWRhc2guanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL21vZGVscy9zYXZlZC1kYXNoZXMtY29sbGVjdGlvbi5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvbW9kZWxzL3NldHRpbmcuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL21vZGVscy9zZXR0aW5ncy1jb2xsZWN0aW9uLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9jaGFydC1haWQtcHJlZGljdGFiaWxpdHkuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL2NoYXJ0LWZ1bmRpbmctdHlwZS5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3MvY2hhcnQtdG9wcy1pbmZvLW1vZGFsLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9jaGFydC10b3BzLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9jaGFydC12aWV3LWJhc2UuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL2NoYXJ0cy5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3MvY29udHJvbHMuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL2Rvd25sb2FkLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9mYWlsLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9maWx0ZXJzLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9mb290ZXIuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL2hlYWRlci5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3MvbWFpbi5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3Mvc2V0dGluZ3MtbW9kYWwuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL3NldHRpbmdzLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9zaGFyZS5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy91Z2x5L2xpYi1sb2FkLWhhY2tzLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL3VnbHkvbGliLXNyYy9jYW52Zy5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy91Z2x5L2xpYi1zcmMvcmdiY29sb3IuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvdWdseS91bmRlcnNjb3JlLXRyYW5zcG9zZS5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy91Z2x5L3V0aWwuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9ub2RlX21vZHVsZXMvYmFieXBhcnNlL2JhYnlwYXJzZS5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L25vZGVfbW9kdWxlcy9udW1lcmFsL251bWVyYWwuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9ub2RlX21vZHVsZXMvbnZkMy9udi5kMy5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvY29yZS5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL2RhdGVwaWNrZXIuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvbm9kZV9tb2R1bGVzL2pxdWVyeS11aS9kcmFnZ2FibGUuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvbm9kZV9tb2R1bGVzL2pxdWVyeS11aS9tb3VzZS5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL3dpZGdldC5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9zcmMvY29sbGVjdGlvbnMvYWxsLWZpbHRlcnMtY29sbGVjdGlvbi5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9zcmMvbGliL2pxdWVyeS5ub3Vpc2xpZGVyLm1pbi5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9zcmMvbWFpbi5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9zcmMvbW9kZWxzL2Jhc2UtZmlsdGVyLW1vZGVsLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy9tb2RlbHMvZ2VuZXJpYy1maWx0ZXItbW9kZWwuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL21vZGVscy9vcmctcm9sZS1maWx0ZXItbW9kZWwuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL21vZGVscy95ZWFycy1maWx0ZXItbW9kZWwuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL3RyZWUvdHJlZS1ub2RlLW1vZGVsLmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy90cmVlL3RyZWUtbm9kZS12aWV3LmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy92aWV3cy9iYXNlLWZpbHRlci12aWV3LmpzIiwiL2Zhc3RkYXRhL2RnLXdvcmtzcGFjZS9hbXAtMi4xMC1yZWxlYXNlL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy92aWV3cy9maWx0ZXJzLXZpZXcuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL3ZpZXdzL2dlbmVyaWMtZmlsdGVyLXZpZXcuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL3ZpZXdzL3RvcC1sZXZlbC1maWx0ZXItdmlldy5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9zcmMvdmlld3MveWVhcnMtZmlsdGVyLXZpZXcuanMiLCIvZmFzdGRhdGEvZGctd29ya3NwYWNlL2FtcC0yLjEwLXJlbGVhc2UvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1zdGF0ZS9pbmRleC5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLXRyYW5zbGF0ZS9pbmRleC5qcyIsIi9mYXN0ZGF0YS9kZy13b3Jrc3BhY2UvYW1wLTIuMTAtcmVsZWFzZS9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLXVybC9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVoY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3B1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6L0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ244QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJyZXF1aXJlKCcuL3VnbHkvbGliLWxvYWQtaGFja3MnKTtcbnZhciBBcHAgPSByZXF1aXJlKCcuL2FwcC9hcHAtY2xhc3MnKTtcblxudmFyIGFwcCA9IG5ldyBBcHAoeyBlbDogJyNhbXAtZGFzaGJvYXJkJyB9KTtcbndpbmRvdy5hcHAgPSBhcHA7ICAvLyBmb3IgZGVidWdnaW5nIGNvbnZlbmllbmNlXG5cbi8vRm9yY2UgY2FsbCB0byB0aGUgRVAgdGhhdCBzZW5kcyB0aGUgc2F2ZWQgZmlsdGVycyBpZiBhbnkuXG5hcHAuc3RhdGUuc2F2ZWQubG9hZCgpO1xuLy9hcHAucmVuZGVyKCk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBEZWZlcnJlZCA9IHJlcXVpcmUoJ2pxdWVyeScpLkRlZmVycmVkO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4vYmFja2JvbmUtZGFzaCcpO1xudmFyIHN1cHBvcnRDaGVjayA9IHJlcXVpcmUoJy4vY2hlY2stc3VwcG9ydCcpO1xuXG52YXIgVVJMU2VydmljZSA9IHJlcXVpcmUoJ2FtcC11cmwvaW5kZXgnKTtcbnZhciBTdGF0ZSA9IHJlcXVpcmUoJ2FtcC1zdGF0ZS9pbmRleCcpO1xudmFyIFN0YXRlTG9hZEVycm9yID0gcmVxdWlyZSgnYW1wLXN0YXRlL2luZGV4JykuU3RhdGVMb2FkRXJyb3I7XG5cbnZhciBUcmFuc2xhdG9yID0gcmVxdWlyZSgnYW1wLXRyYW5zbGF0ZScpO1xudmFyIEZpbHRlciA9IHJlcXVpcmUoJ2FtcC1maWx0ZXIvc3JjL21haW4nKTtcbnZhciBTZXR0aW5ncyA9IHJlcXVpcmUoJy4vbW9kZWxzL3NldHRpbmdzLWNvbGxlY3Rpb24nKTtcbnZhciBTYXZlZERhc2hlcyA9IHJlcXVpcmUoJy4vbW9kZWxzL3NhdmVkLWRhc2hlcy1jb2xsZWN0aW9uLmpzJyk7XG5cbnZhciBNYWluVmlldyA9IHJlcXVpcmUoJy4vdmlld3MvbWFpbicpO1xudmFyIEZhaWxWaWV3ID0gcmVxdWlyZSgnLi92aWV3cy9mYWlsJyk7XG5cblxuZnVuY3Rpb24gQXBwKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQXBwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXBwIG5lZWRzIHRvIGJlIGluc3RhbnRpYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLicpO1xuICB9XG4gIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5cbl8uZXh0ZW5kKEFwcC5wcm90b3R5cGUsIEJhY2tib25lRGFzaC5FdmVudHMsIHtcblx0XG4gIHJlbmRlcmVkOiBmYWxzZSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIF9pbml0RGVmZXIgPSBuZXcgRGVmZXJyZWQoKSxcbiAgICAgICAgbWlzc2luZ0ZlYXR1cmVzO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBfaW5pdERlZmVyLnByb21pc2UoKTtcblxuICAgIHRyeSB7ICAgIFx0XG4gICAgICB0aGlzLnNldHRpbmdzID0gbmV3IFNldHRpbmdzKFtdLCB7IGFwcDogdGhpcyB9KTtcblxuICAgICAgLy8gY2hlY2sgb3VyIHN1cHBvcnQgbGV2ZWxcbiAgICAgIHRoaXMuYnJvd3Nlcklzc3VlcyA9IHN1cHBvcnRDaGVjaygpO1xuICAgICAgXyh0aGlzLmJyb3dzZXJJc3N1ZXMpLmNoYWluKClcbiAgICAgICAgLmdyb3VwQnkoJ3NldmVyaXR5JylcbiAgICAgICAgLmVhY2goZnVuY3Rpb24oc2V2ZXJpdHlHcm91cCwgc2V2ZXJpdHkpIHtcbiAgICAgICAgICBtaXNzaW5nRmVhdHVyZXMgPSBfKHNldmVyaXR5R3JvdXApLnBsdWNrKCdmZWF0dXJlJykuam9pbignLCAnKTtcbiAgICAgICAgICBpZiAoc2V2ZXJpdHkgPT09ICdjcml0aWNhbCcpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgbmFtZTogJ0luY29tcGF0aWJsZSBXZWIgQnJvd3NlcicsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdEYXNoYm9hcmRzIGNhbm5vdCB3b3JrIHdpdGhvdXQgdGhlc2UgZmVhdHVyZXMsIHdoaWNoIGFyZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBzdXBwb3J0ZWQgYnkgeW91ciB3ZWIgYnJvd3NlcjogJyArIG1pc3NpbmdGZWF0dXJlcyArICcuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAnQW55IDxhIGhyZWY9XCJodHRwOi8vYnJvd3NlaGFwcHkuY29tL1wiPm1vZGVybiBicm93c2VyPC9hPiB3aWxsIHdvcmsuJyxcbiAgICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIHRoaXMubWVzc2FnZTsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNldmVyaXR5ID09PSAnbWFqb3InKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydCgnTGltaXRlZCBzdXBwb3J0IGZvciBvbGQgd2ViIGJyb3dzZXJzJywgW1xuICAgICAgICAgICAgICAnWW91ciBicm93c2VyIGRvZXMgbm90IHByb3ZpZGUgc29tZSBmZWF0dXJlcyB1c2VkIGJ5IERhc2hib2FyZHM6ICcgK1xuICAgICAgICAgICAgICBtaXNzaW5nRmVhdHVyZXMgKyAnLicsXG4gICAgICAgICAgICAgICdTb21lIGZlYXR1cmVzIG1heSBub3Qgd29yayBjb3JyZWN0bHksIGhvd2V2ZXIgYW55ICcgK1xuICAgICAgICAgICAgICAnPGEgaHJlZj1cImh0dHA6Ly9icm93c2VoYXBweS5jb20vXCI+bW9kZXJuIGJyb3dzZXI8L2E+IHdpbGwgcHJvdmlkZSAnICtcbiAgICAgICAgICAgICAgJ2EgYmV0dGVyIGV4cGVyaWVuY2UuJ10pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2V2ZXJpdHkgPT09ICdtaW5vcicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhpcyBicm93c2VyIGlzIG1pc3Npbmcgc3VwcG9ydCBmb3InLCBtaXNzaW5nRmVhdHVyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIC8vIGluamVjdCBkb3dubG9hZGlmeSBpZiB3ZSBoYXZlIG5vIGRvd25sb2FkIGJ1dCBoYXZlIGZsYXNoIChJRSlcbiAgICAgIGlmICh0aGlzLmhhc0lzc3VlKCdkb3dubG9hZCcpICYmICF0aGlzLmhhc0lzc3VlKCdmbGFzaCcpKSB7XG4gICAgICAgIHZhciBzd2ZPYmogPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcbiAgICAgICAgICAgIGRvd25sb2FkaWZ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHN3Zk9iai5zcmMgPSAnL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2NvbW1vbkpzL3N3Zm9iamVjdC0yLjIuanMnO1xuICAgICAgICBkb3dubG9hZGlmeS5zcmMgPSAnL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2NvbW1vbkpzL2Rvd25sb2FkaWZ5LTAuMi5qcyc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3dmT2JqKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb3dubG9hZGlmeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGluaXRpYWxpemUgYXBwIHNlcnZpY2VzXG4gICAgICB0aGlzLnVybCA9IG5ldyBVUkxTZXJ2aWNlKCk7ICAgICAgXG4gICAgICB0aGlzLnNhdmVkRGFzaGVzID0gbmV3IFNhdmVkRGFzaGVzKFtdLCB7IGFwcDogdGhpcyB9KTtcbiAgICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGUoe1xuICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICBzYXZlZDogdGhpcy5zYXZlZERhc2hlc1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIHRyeSB0byBsb2FkIGFuIGluaXRpYWwgc3RhdGUgZnJvbSB0aGUgdXJsXG4gICAgICB0cnkge1xuICAgIFx0ICB0aGlzLnN0YXRlLnVybE1heWJlTG9hZCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU3RhdGVMb2FkRXJyb3IpIHtcbiAgICAgICAgXHQgIHRoaXMucmVwb3J0KCdDb3VsZCBub3QgbG9hZCBzYXZlZCBkYXNoYm9hcmQnLCBbJ0lmIHlvdSBhcmUgdHJ5aW5nIHRvIGxvYWQgYSBzaGFyZWQgbGluaywgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgZW50aXJlIFVSTCB3YXMgY29waWVkJ10pO1xuICAgICAgICBcdCAgdGhpcy51cmwuaGFzaCgnJyk7ICAvLyBjbGVhciB0aGUgYmFkIHNhdmVkLXN0YXRlIGhhc2hcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICBcdCAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXNoYm9hcmRUcmFuc2xhdGVLZXlzID0gSlNPTi5wYXJzZShcIntcXG5cXFwiYW1wLmNvbW1vbjpmb290ZXJcXFwiOiBcXFwiRGV2ZWxvcGVkIGluIHBhcnRuZXJzaGlwIHdpdGggT0VDRCwgVU5EUCwgV0IsIEdvdmVybm1lbnQgb2YgRXRoaW9waWEgYW5kIERHRlxcXCIsXFxuXFxuXFxcImFtcC5jb21tb246dGl0bGVcXFwiOiBcXFwiQU1QXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZS1kZXNrdG9wXFxcIjogXFxcIkRlc2t0b3BcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLW15LWRlc2t0b3BcXFwiOiBcXFwiTXkgRGVza3RvcFxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtYWRkLXRhYlxcXCI6IFxcXCJBZGQgVGFiXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS10YWItbWFuYWdlclxcXCI6IFxcXCJUYWIgTWFuYWdlclxcXCIsXFxuXFxcImFtcC5jb21tb246dGl0bGUtcmVwb3J0c1xcXCI6IFxcXCJSZXBvcnRzXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1hbGwtcmVwb3J0c1xcXCI6IFxcXCJBbGwgUmVwb3J0c1xcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtZmF2LXJlcG9ydHNcXFwiOiBcXFwiRmF2b3VyaXRlIFJlcG9ydHNcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLXJlcG9ydC1nZW5lcmF0b3JcXFwiOiBcXFwiUmVwb3J0IEdlbmVyYXRvclxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtc2Fpa3VcXFwiOiBcXFwiU2Fpa3VcXFwiLFxcblxcXCJhbXAuY29tbW9uOnRpdGxlLWRvY3VtZW50c1xcXCI6IFxcXCJEb2N1bWVudHNcXFwiLFxcblxcXCJhbXAuY29tbW9uOnRpdGxlLWRhc2hib2FyZHNcXFwiOiBcXFwiRGFzaGJvYXJkc1xcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtZ2lzXFxcIjogXFxcIk5ldyBHSVMgKEJFVEEpXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1kYXNoYm9hcmRzXFxcIjogXFxcIk5ldyBEYXNoYm9hcmQgKEJFVEEpXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1kYXNoYm9hcmQtZ2VuZXJhdG9yXFxcIjogXFxcIkRhc2hib2FyZCBHZW5lcmF0b3JcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWRvbm9yLXByb2ZpbGVcXFwiOiBcXFwiRG9ub3IgUHJvZmlsZVxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtcmVnaW9uLXByb2ZpbGVcXFwiOiBcXFwiUmVnaW9uIFByb2ZpbGVcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLXNlY3Rvci1wcm9maWxlXFxcIjogXFxcIlNlY3RvciBQcm9maWxlXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1leGVjdXRpbmctcHJvZmlsZVxcXCI6IFxcXCJFeGVjdXRpbmcgQWdlbmN5IFByb2ZpbGVcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWJlbmVmaWNpYXJ5LXByb2ZpbGVcXFwiOiBcXFwiQmVuZWZpY2lhcnkgTWluaXN0cnkgUHJvZmlsZVxcXCIsXFxuXFxcImFtcC5jb21tb246dGl0bGUtdG9vbHNcXFwiOiBcXFwiVG9vbHNcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLXdvcmtzcGFjZS1zZXR1cFxcXCI6IFxcXCJXb3Jrc3BhY2UgU2V0dXBcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWFkdmFuY2VkLW1vZGVcXFwiOiBcXFwiQWR2YW5jZWQgTW9kZVxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtc2VhcmNoXFxcIjogXFxcIlNlYXJjaFxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtYWRkcmVzc2Jvb2tcXFwiOiBcXFwiQWRkcmVzcyBCb29rXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZS1oZWxwXFxcIjogXFxcIkhlbHBcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWFtcC1oZWxwXFxcIjogXFxcIkFNUCBIZWxwXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1nbG9zc2FyeVxcXCI6IFxcXCJHbG9zc2FyeVxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtZW1haWwtc3VwcG9ydC10ZWFtXFxcIjogXFxcIkVtYWlsIFN1cHBvcnQgVGVhbVxcXCIsXFxuXFxcImFtcC5jb21tb246dGl0bGUtbG9nb3V0XFxcIjogXFxcIkxvZ291dFxcXCIsXFxuXFxcImFtcC5jb21tb246ZmlsdGVycy1sb2FkaW5nXFxcIjogXFxcIkxvYWRpbmcuLi5cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnBhZ2UtdGl0bGVcXFwiOlxcXCJBTVAgRGFzaGJvYXJkc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6bG9hZGluZ1xcXCI6IFxcXCJMb2FkaW5nLi4uXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDp0aXRsZS1wcm9qZWN0ZGF0YVxcXCI6IFxcXCJQcm9qZWN0IERhdGFcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnN1Yi10aXRsZS1wcm9qZWN0ZGF0YVxcXCI6IFxcXCJWaWV3IHdoZXJlIHByb2plY3RzIGFyZSBiZWluZyBpbXBsZW1lbnRlZCB0aHJvdWdob3V0IHRoZSBjb3VudHJ5LlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6dGl0bGUtQ291bnRyeVxcXCI6IFxcXCJDb3VudHJ5XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDp0aXRsZS1SZWdpb25cXFwiOiBcXFwiUmVnaW9uXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDp0aXRsZS1ab25lXFxcIjogXFxcIlpvbmVcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnRpdGxlLURpc3RyaWN0XFxcIjogXFxcIkRpc3RyaWN0XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1yZXNldFxcXCI6IFxcXCJyZXNldCBvdGhlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LXJhZGlvdWktY29tbWl0bWVudHNcXFwiOiBcXFwiQ29tbWl0bWVudHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LXJhZGlvdWktZGlzYnVyc2VtZW50c1xcXCI6IFxcXCJEaXNidXJzZW1lbnRzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLW5vbmUtYXBwbGllZFxcXCI6IFxcXCJObyBmaWx0ZXJzIGFwcGxpZWRcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNsb3NlXFxcIjogXFxcIkNsb3NlXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDptb2RhbC1zb3JyeVxcXCI6IFxcXCJTb3JyeSBmb3IgYW55IGluY29udmVuaWVuY2VcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnNoYXJlLWRhc2hib2FyZC10b3BcXFwiOiBcXFwiU2hhcmUgZGFzaGJvYXJkXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpzaGFyZS1kYXNoYm9hcmRcXFwiOiBcXFwiU2hhcmUgdGhpcyBkYXNoYm9hcmQgdmlld1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6c2hhcmUtbGlua1xcXCI6IFxcXCJMaW5rXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpvZlxcXCI6IFxcXCJvZlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6dG9vbHRpcC1wcmVkaWN0LW90aGVyc2VyaWVzXFxcIjogXFxcIlRSQU5TTEFURU1FXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDp0b3RhbFxcXCI6IFxcXCJ0b3RhbFxcXCIsXFxuXFxcImFtcC5jb21tb246dGl0bGVcXFwiOiBcXFwiQU1QIFRvb2xiYXJcXFwiLFxcblxcXCJhbXAuY29tbW9uOnRpdGxlLWZpbHRlcnNcXFwiOiBcXFwiRmlsdGVyc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtVG9wRG9ub3JBZ2VuY2llc1xcXCI6IFxcXCJUb3AgRG9ub3IgQWdlbmNpZXNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LVRvcERvbm9yR3JvdXBzXFxcIjogXFxcIlRvcCBEb25vciBHcm91cHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LVRvcFJlZ2lvbnNcXFwiOiBcXFwiVG9wIFJlZ2lvbnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LVRvcFNlY3RvcnNcXFwiOiBcXFwiVG9wIFNlY3RvcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LUFpZFByZWRpY3RhYmlsaXR5XFxcIjogXFxcIkFpZCBQcmVkaWN0YWJpbGl0eVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtRnVuZGluZ1R5cGVcXFwiOiBcXFwiRnVuZGluZyBUeXBlXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1SZXNwb25zaWJsZU9yZ2FuaXphdGlvbnNcXFwiOiBcXFwiVG9wIFJlc3BvbnNpYmxlIE9yZ2FuaXphdGlvbnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LUJlbmVmaWNpYXJ5QWdlbmNpZXNcXFwiOiBcXFwiVG9wIEJlbmVmaWNpYXJ5IEFnZW5jaWVzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1FeGVjdXRpbmdBZ2VuY2llc1xcXCI6IFxcXCJUb3AgRXhlY3V0aW5nIEFnZW5jaWVzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1JbXBsZW1lbnRpbmdBZ2VuY2llc1xcXCI6IFxcXCJUb3AgSW1wbGVtZW50aW5nIEFnZW5jaWVzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1QZWFjZS1idWlsZGluZ2FuZFN0YXRlLWJ1aWxkaW5nR29hbHNcXFwiOiBcXFwiUGVhY2UtYnVpbGRpbmcgYW5kIFN0YXRlLWJ1aWxkaW5nIEdvYWxzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpwcmVkaWN0YWJpbGl0eS1wbGFubmVkXFxcIjogXFxcIlBsYW5uZWRcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnByZWRpY3RhYmlsaXR5LWFjdHVhbFxcXCI6IFxcXCJBY3R1YWxcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LUZ1bmRpbmdUeXBlLUdyYW50XFxcIjogXFxcIkdyYW50XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1GdW5kaW5nVHlwZS1Mb2FuXFxcIjogXFxcIkxvYW5cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LUZ1bmRpbmdUeXBlLW90aGVyc1xcXCI6IFxcXCJPdGhlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LVRvcFJlZ2lvbnMtRGlzdHJpY3RVbmRlZmluZWRcXFwiOiBcXFwiRGlzdHJpY3Q6IFVcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LVRvcFJlZ2lvbnMtb3RoZXJzXFxcIjogXFxcIk90aGVyc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtVG9wU2VjdG9ycy1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1Ub3BEb25vckFnZW5jaWVzLW90aGVyc1xcXCI6IFxcXCJPdGhlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LVRvcERvbm9yR3JvdXBzLW90aGVyc1xcXCI6IFxcXCJPdGhlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LVJlc3BvbnNpYmxlT3JnYW5pemF0aW9ucy1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1CZW5lZmljaWFyeUFnZW5jaWVzLW90aGVyc1xcXCI6IFxcXCJPdGhlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LUV4ZWN1dGluZ0FnZW5jaWVzLW90aGVyc1xcXCI6IFxcXCJPdGhlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LUltcGxlbWVudGluZ0FnZW5jaWVzLW90aGVyc1xcXCI6IFxcXCJPdGhlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LVBlYWNlLWJ1aWxkaW5nYW5kU3RhdGUtYnVpbGRpbmdHb2Fscy1vdGhlcnNcXFwiOlxcXCJPdGhlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtZWRpdFxcXCI6XFxcImVkaXQgZmlsdGVyc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZGFzaGJvYXJkLXNldHRpbmdzXFxcIjpcXFwiU2V0dGluZ3NcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnNldHRpbmdzLWVkaXRcXFwiOlxcXCJlZGl0IHNldHRpbmdzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpkb3dubG9hZC1hbW91bnRcXFwiOlxcXCJBbW91bnRcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmRvd25sb2FkLXByZXZpZXdcXFwiOlxcXCJQcmV2aWV3OlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtcmVuZGVyaW5nXFxcIjpcXFwiUmVuZGVyaW5nLi4uXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpkb3dubG9hZC1kb3dubG9hZC1jaGFydFxcXCI6XFxcIkRvd25sb2FkIGNoYXJ0XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpkb3dubG9hZC1kb3dubG9hZC1kYXRhXFxcIjpcXFwiRG93bmxvYWQgZGF0YVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtbm8tZGF0YS1hdmFpbGFibGVcXFwiOlxcXCJObyBEYXRhIEF2YWlsYWJsZVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtbG9hZGluZy1zYXZlZC1zZXR0aW5nc1xcXCI6XFxcIkxvYWRpbmcgc2F2ZWQgc2V0dGluZ3MuLi5cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtc2hvdy1zZXR0aW5nc1xcXCI6XFxcIlNob3cgZmlsdGVyIHNldHRpbmdzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLWNoYXJ0LWxlZ2VuZHMtR3JvdXBlZFxcXCI6XFxcIkdyb3VwZWRcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtY2hhcnQtbGVnZW5kcy1TdGFja2VkXFxcIjpcXFwiU3RhY2tlZFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6b2YtdG90YWxcXFwiOiBcXFwib2YgdG90YWxcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmFpZC1wcmVkaWN0YWJpbGl0eS1hY3R1YWwtZGlzYnVyc2VtZW50c1xcXCI6IFxcXCJBY3R1YWwgRGlzYnVyc2VtZW50c1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6YWlkLXByZWRpY3RhYmlsaXR5LXBsYW5uZWQtZGlzYnVyc2VtZW50c1xcXCI6IFxcXCJQbGFubmVkIERpc2J1cnNlbWVudHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtaGlkZS1kZXRhaWxzXFxcIjogXFxcIkhpZGUgZmlsdGVyIGRldGFpbHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnNhdmluZy1zdGF0ZVxcXCI6IFxcXCJTYXZpbmcgZGFzaGJvYXJkIHN0YXRlLCBwbGVhc2Ugd2FpdC4uLlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZGF0ZS1yYW5nZVxcXCI6IFxcXCJEYXRlIFJhbmdlXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjdXJyZW5jeVxcXCIgOiBcXFwiQ3VycmVuY3lcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnR5cGVcXFwiIDogXFxcIlR5cGVcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnllYXJcXFwiIDogXFxcIlllYXJcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZ0eXBlLWFjdHVhbC1jb21taXRtZW50XFxcIjogXFxcIkFjdHVhbCBDb21taXRtZW50c1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZnR5cGUtYWN0dWFsLWRpc2J1cnNlbWVudFxcXCI6IFxcXCJBY3R1YWwgRGlzYnVyc2VtZW50c1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZnR5cGUtYWN0dWFsLWV4cGVuZGl0dXJlXFxcIjogXFxcIkFjdHVhbCBFeHBlbmRpdHVyZXNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZ0eXBlLXBsYW5uZWQtY29tbWl0bWVudFxcXCI6IFxcXCJQbGFubmVkIENvbW1pdG1lbnRzXFxcIiAsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZnR5cGUtcGxhbm5lZC1kaXNidXJzZW1lbnRcXFwiOlxcdFxcXCJQbGFubmVkIERpc2J1cnNlbWVudHNcXFwiICxcXG5cXFwiYW1wLmRhc2hib2FyZDpmdHlwZS1wbGFubmVkLWV4cGVuZGl0dXJlc1xcXCI6XFx0XFxcIlBsYW5uZWQgRXhwZW5kaXR1cmVzXFxcIiwgIFxcdFxcdFxcdFxcblxcXCJhbXAuZGFzaGJvYXJkOmRhc2hib2FyZC1jaGFydC10b3BzLWluZm8tbW9kYWxcXFwiOiBcXFwiQ2F0ZWdvcnkgRGV0YWlsXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b3BzLXRhYmxlLXByb2plY3R0aXRsZVxcXCI6IFxcXCJQcm9qZWN0IFRpdGxlXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b3BzLWludW5pdHNcXFwiOiBcXFwiSW4gdW5pdHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LXRvcHMtaW50aG91c2FuZHNcXFwiOiBcXFwiSW4gdGhvdXNhbmRzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b3BzLWlubWlsbGlvbnNcXFwiOiBcXFwiSW4gbWlsbGlvbnNcXFwiXFxufVxcblxcblwiKTtcbiAgICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKHtcbiAgICAgICAgZGVmYXVsdEtleXM6IGRhc2hib2FyZFRyYW5zbGF0ZUtleXMsXG4gICAgICAgIGFqYXg6IEJhY2tib25lRGFzaC53cmFwcGVkQWpheFxuICAgICAgfSk7XG4gICAgICAvLyBUT0RPOiBoYW5kbGUgdHJhbnNsYXRpb25zIGxvYWQgZmFpbHVyZVxuXG4gICAgICB0aGlzLmZpbHRlciA9IG5ldyBGaWx0ZXIoe1xuICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIHN5bmM6IG9wdGlvbnMuc3luYyB8fCBCYWNrYm9uZURhc2guc3luYyxcbiAgICAgICAgY2FsbGVyOiAnREFTSEJPQVJEJ1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGluaXRpYWxpemUgYXBwIGNvbXBvbmVudHNcbiAgICAgIHRoaXMudmlldyA9IG5ldyBNYWluVmlldyh7IGFwcDogdGhpcywgZWw6IG9wdGlvbnMuZWwgfSk7XG5cbiAgICAgIF9pbml0RGVmZXIucmVzb2x2ZSh0aGlzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfLmRlZmVyKGZ1bmN0aW9uKCkgeyB0aHJvdyBlOyB9KTtcbiAgICAgIHRoaXMudmlldyA9IG5ldyBGYWlsVmlldyh7IGFwcDogdGhpcywgZWw6IG9wdGlvbnMuZWwsIGVycjogZX0pO1xuICAgICAgdGhpcy5lcnIgPSBlO1xuICAgICAgX2luaXREZWZlci5yZWplY3QodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETzogZml4IHNvbWUgcGFydHMgb2YgdGhlIGFwcCBzbyB3ZSBjYW4gbG9hZCB0cmFuc2xhdGlvbnMgYXN5bmNcbiAgICB0aGlzLnRyeUFmdGVyKHRoaXMudHJhbnNsYXRvci5wcm9taXNlLCB0aGlzLnZpZXcucmVuZGVyLCB0aGlzLnZpZXcpO1xuICAgIC8vIHRoaXMudHJ5VG8odGhpcy52aWV3LnJlbmRlciwgdGhpcy52aWV3KTtcblxuICAgIC8qIGVuc3VyZSBlbnRpcmUgcGFnZS0taGVhZGVyIGFuZCBmb290ZXIsIG5vdCBqdXN0IHRoaXMgdmlldyBpcyB0cmFuc2xhdGVkICovXG4gICAgLy8gVE9ETzogaWYgcG9zc2libGUsIG1vdmUgdGhpcyBvdXQgb2YgYXBwLWNsYXNzXG4gICAgLy8gb3IgYXQgbGVhc3QgbWFrZSBpdCBtb3JlIHRhcmdldGVkIHRoYW4gZG9jdW1lbnRcbiAgICB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKGRvY3VtZW50KTtcbiAgfSxcblxuICBoYXNJc3N1ZTogZnVuY3Rpb24oZmVhdHVyZU5hbWUpIHtcbiAgICByZXR1cm4gISFfKHRoaXMuYnJvd3Nlcklzc3VlcykuZmluZFdoZXJlKHtmZWF0dXJlOiBmZWF0dXJlTmFtZX0pO1xuICB9LFxuXG4gIHZpZXdGYWlsOiBmdW5jdGlvbih2aWV3LCBlcnIpIHtcbiAgICB2aWV3LiRlbC5odG1sKG5ldyBGYWlsVmlldyh7IGFwcDogdGhpcywgZXJyOiBlcnIgfSkucmVuZGVyKCkuZWwpO1xuICB9LFxuXG4gIHRyeVRvOiBmdW5jdGlvbihmbiwgdmlldykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh2aWV3KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfLmRlZmVyKGZ1bmN0aW9uKCkgeyB0aHJvdyBlOyB9KTtcbiAgICAgIHRoaXMudmlld0ZhaWwodmlldywgZSk7XG4gICAgfVxuICB9LFxuXG4gIHRyeUFmdGVyOiBmdW5jdGlvbihwcm9taXNlLCBmbiwgdmlldykge1xuICAgIHByb21pc2VcbiAgICAgIC5kb25lKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudHJ5VG8oZm4sIHZpZXcpO1xuICAgICAgfSkuYmluZCh0aGlzKSlcbiAgICAgIC5mYWlsKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlld0ZhaWwodmlldywgJ2ZhaWxlZCB0byBsb2FkJyk7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICByZXBvcnQ6IGZ1bmN0aW9uKHRpdGxlLCBtZXNzYWdlcykge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWRcbiAgICAgIC5kb25lKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICBhcHAubW9kYWwodGl0bGUsIHttZXNzYWdlczogbWVzc2FnZXMsIHRvbmU6ICd3YXJuaW5nJ30pO1xuICAgICAgfSlcbiAgICAgIC5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1JFUE9SVDonLCB0aXRsZSwgbWVzc2FnZXMpO1xuICAgICAgfSk7XG4gIH0sXG5cbiAgbW9kYWw6IGZ1bmN0aW9uKHRpdGxlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8oe30pLmV4dGVuZChvcHRpb25zLCB7dG9uZTogJ3ByaW1hcnknfSk7XG4gICAgdmFyIG1vZGFsUmVhZHkgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICB0aGlzLmluaXRpYWxpemVkXG4gICAgICAuZG9uZShmdW5jdGlvbihhcHApIHtcbiAgICAgICAgdmFyIG1vZGFsRWwgPSBhcHAudmlldy5tb2RhbCh0aXRsZSwgb3B0aW9ucyk7XG4gICAgICAgIG1vZGFsUmVhZHkucmVzb2x2ZShtb2RhbEVsKTtcbiAgICAgIH0pXG4gICAgICAuZmFpbChmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdmYWlsZWQgdG8gc2hvdyBtb2RhbCBiZWNhdXNlIHRoZSBhcHAgdmlld3MgZGlkIG5vdCBpbml0aWFsaXplJywgdGl0bGUpO1xuICAgICAgICBtb2RhbFJlYWR5LnJlamVjdCgnYXBwIHZpZXdzIGRpZCBub3QgaW5pdCcpO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIG1vZGFsUmVhZHkucHJvbWlzZSgpO1xuICB9XG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQXBwO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG5cbi8vIFRPRE86IC4uLiAuLi4gLi4uXG52YXIgSVNfUEhJTFNfQ09SUyA9IHdpbmRvdyAmJiAod2luZG93LmxvY2F0aW9uLmhvc3QgPT09ICdsb2NhbGhvc3Q6MzAwMCcpO1xuXG5cbnZhciBDQUNIRSA9IFsnL3Jlc3QvZGFzaGJvYXJkJ107XG5cblxuZnVuY3Rpb24gSW5pdEVycm9yKGluc3RhbmNlKSB7XG4gIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ01vZHVsZSBpbml0aWFsaXphdGlvbiBlcnJvcic7IH07XG59XG5cblxudmFyIGFqYXhPcHRpb25XcmFwID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gXyh7fSkuZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAvLyBtYXliZSB1c2UgcGhpbCdzIERSQyBDT1JTIGRldiBzZXJ2ZXJcbiAgICB1cmw6IChJU19QSElMU19DT1JTID8gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MCcgOiAnJykgKyBvcHRpb25zLnVybCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAvLyBqc2NzOmRpc2FibGUgZGlzYWxsb3dRdW90ZWRLZXlzSW5PYmplY3RzXG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgLy8ganNjczplbmFibGUgZGlzYWxsb3dRdW90ZWRLZXlzSW5PYmplY3RzXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5cbnZhciBzeW5jT3ZlcnJpZGUgPSAoZnVuY3Rpb24oYnMpIHtcbiAgdmFyIGNhY2hlID0ge307XG5cbiAgZnVuY3Rpb24gX2RvU3luYyh1cmwsIG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXyh7fSkuZXh0ZW5kKG9wdGlvbnMsIHsgdXJsOiB1cmwgfSk7XG4gICAgb3B0aW9ucyA9IGFqYXhPcHRpb25XcmFwKG9wdGlvbnMpO1xuICAgIHJldHVybiBicy5jYWxsKHRoaXMsIG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NhY2hlU3luYyh1cmwsIG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIga2V5ID0gdXJsICsgJytQT1NUOicgKyBvcHRpb25zLmRhdGE7XG4gICAgaWYgKGNhY2hlW2tleV0pIHsgcmV0dXJuIGNhY2hlW2tleV0oKTsgfVxuXG4gICAgdmFyIHhociA9IF9kb1N5bmModXJsLCBtZXRob2QsIG1vZGVsLCBvcHRpb25zKTtcblxuICAgIGNhY2hlW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aWxsIG1ha2UgdGhlIHhociByZS1jYWxsIGl0cyBjYWxsYmFja3NcbiAgICAgIHJldHVybiB4aHJcbiAgICAgICAgLmRvbmUob3B0aW9ucy5zdWNjZXNzKVxuICAgICAgICAuYWx3YXlzKG9wdGlvbnMuY29tcGxldGUpO1xuICAgIH07XG5cbiAgICAvLyBkbyBub3QgY2FjaGUgZmFpbGVkIHJlcXVlc3RzXG4gICAgeGhyLmZhaWwoZnVuY3Rpb24oKSB7IGRlbGV0ZSBjYWNoZVtrZXldOyB9KTtcblxuICAgIHJldHVybiB4aHI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24obWV0aG9kLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciB1cmwgPSBvcHRpb25zLnVybCB8fCBfKG1vZGVsKS5yZXN1bHQoJ3VybCcpIHx8IEJhY2tib25lLk1vZGVsLnByb3RvdHlwZS51cmwuY2FsbChtb2RlbCksXG4gICAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdQT1NUJyAmJlxuICAgICAgXy5zb21lKENBQ0hFLCBmdW5jdGlvbihpKSB7IHJldHVybiB1cmwuaW5kZXhPZihpKSA9PT0gMDsgfSkpIHtcbiAgICAgIGNhY2hlYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiAoY2FjaGVhYmxlID8gX2NhY2hlU3luYyA6IF9kb1N5bmMpKHVybCwgbWV0aG9kLCBtb2RlbCwgb3B0aW9ucyk7XG4gIH07XG59KShCYWNrYm9uZS5zeW5jKTtcblxuXG4vLyBtaXhlZCBpbnRvIGFsbCBtb2RlbHMsIGNvbGxlY3Rpb25zIGFuZCB2aWV3cyB0byBlbnN1cmUgd2UgaGF2ZSBhIGNvbnZlbmllbnRcbi8vIHJlZmVyZW5jZSB0byB0aGUgYXBwIGluc3RhbmNlIGV2ZXJ5d2hlcmUuXG5mdW5jdGlvbiBtaXhEYXNoKENsYXNzKSB7XG4gIHJldHVybiBDbGFzcy5leHRlbmQoe1xuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbnN0cnVjdGVkID0gQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICghdGhpcy5hcHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEluaXRFcnJvcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25zdHJ1Y3RlZDtcbiAgICB9LFxuXG4gICAgc3luYzogc3luY092ZXJyaWRlXG5cbiAgfSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBfKHt9KS5leHRlbmQoQmFja2JvbmUsIHtcbiAgLy8gZXJyb3JzXG4gIEluaXRFcnJvcjogSW5pdEVycm9yLFxuXG4gIE1vZGVsOiBtaXhEYXNoKEJhY2tib25lLk1vZGVsKSxcbiAgQ29sbGVjdGlvbjogbWl4RGFzaChCYWNrYm9uZS5Db2xsZWN0aW9uKSxcbiAgVmlldzogbWl4RGFzaChCYWNrYm9uZS5WaWV3KSxcblxuICBzeW5jOiBzeW5jT3ZlcnJpZGUsXG4gIHdyYXBwZWRBamF4OiBmdW5jdGlvbihvKSB7IHJldHVybiBCYWNrYm9uZS5hamF4KGFqYXhPcHRpb25XcmFwKG8pKTsgfVxufSk7XG4iLCIvKlxuICogRHJhd2luZyBhIGJhciBjaGFydCBpbiBBTVA/IFBsZWFzZSB1c2UgLi9jaGFydC5qcyBpbnN0ZWFkLlxuICovXG5cbnZhciBudiA9IHdpbmRvdy5udjsgIC8vIG52ZDMgaXMgYSBwYWluXG52YXIgZDMgPSByZXF1aXJlKCdkMy1icm93c2VyaWZ5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3VnbHkvdXRpbCcpO1xuXG5cbmZ1bmN0aW9uIGRhdGFUb052KGRhdGEpIHtcbiAgcmV0dXJuIGRhdGE7XG59XG5cblxuZnVuY3Rpb24gY291bnRDYXRlZ29yaWVzKGRhdGEpIHtcbiAgLy8gbm90ZTogdGhpcyB0YWtlcyByZWd1bGFyIGRhdGEsIG5vdCBkYXRhVG9OdiBkYXRhLlxuICByZXR1cm4gZGF0YVswXS52YWx1ZXMubGVuZ3RoIC0gMTsgIC8vIDEgZm9yIG90aGVycy4uLj9cbn1cblxuXG5mdW5jdGlvbiBjaGFydChvcHRpb25zKSB7XG4gIHZhciBfY2hhcnQgPSBudi5tb2RlbHMuZGlzY3JldGVCYXJDaGFydCgpXG4gICAgLnZhbHVlRm9ybWF0KG9wdGlvbnMuc2hvcnRGb3JtYXR0ZXIpXG4gICAgLnNob3dWYWx1ZXModHJ1ZSlcbiAgICAuc2hvd1lBeGlzKGZhbHNlKVxuICAgIC5zaG93WEF4aXMoZmFsc2UpXG4gICAgLm1hcmdpbih7IHRvcDogNSwgcmlnaHQ6IDEwLCBib3R0b206IDEwLCBsZWZ0OiAxMCB9KTtcbiAgcmV0dXJuIF9jaGFydDtcbn1cblxuXG5mdW5jdGlvbiBhZGRMZWdlbmQoc3ZnLCBjaGFydCwgbnZEYXRhLCB0cmltTGFiZWxzLCB3aWR0aCkge1xuICB2YXIgbGVnZW5kSGVpZ2h0O1xuXG4gIHZhciBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAud2lkdGgod2lkdGggfHwgc3ZnLmNsaWVudFdpZHRoKVxuICAgIC5tYXJnaW4oe2xlZnQ6IDIwLCByaWdodDogMjB9KVxuICAgIC5yaWdodEFsaWduKGZhbHNlKVxuICAgIC5jb2xvcih1dGlsLmNhdGVnb3J5Q29sb3VycyhudkRhdGFbMF0udmFsdWVzLmxlbmd0aCkpXG4gICAgLmtleShmdW5jdGlvbihkKSB7IHJldHVybiB0cmltTGFiZWxzID8gdXRpbC5mb3JtYXRTaG9ydFRleHQoMTIpKGQueCkgOiBkLng7IH0pO1xuXG4gIGQzLnNlbGVjdChzdmcpXG4gICAgLmRhdHVtKG52RGF0YSlcbiAgICAuYXBwZW5kKCdnJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdsZWdlbmQnKVxuICAgICAgLmRhdHVtKG52RGF0YVswXS52YWx1ZXMpXG4gICAgICAuY2FsbChsZWdlbmQpO1xuXG4gIGxlZ2VuZEhlaWdodCA9IHN2Zy5xdWVyeVNlbGVjdG9yKCcubGVnZW5kJykuZ2V0QkJveCgpLmhlaWdodDtcbiAgY2hhcnQubWFyZ2luKHt0b3A6IGxlZ2VuZEhlaWdodCArIDE1fSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRpc3BhdGNoTmFtZTogJ2Rpc2NyZXRlYmFyJyxcbiAgY291bnRDYXRlZ29yaWVzOiBjb3VudENhdGVnb3JpZXMsXG4gIGFkZExlZ2VuZDogYWRkTGVnZW5kLFxuICBkYXRhVG9OdjogZGF0YVRvTnYsXG4gIGNoYXJ0OiBjaGFydFxufTtcbiIsIi8qXG4gKiBEcmF3aW5nIGEgbXVsdGliYXIgY2hhcnQgaW4gQU1QPyBQbGVhc2UgdXNlIC4vY2hhcnQuanMgaW5zdGVhZC5cbiAqL1xuXG52YXIgbnYgPSB3aW5kb3cubnY7ICAvLyBudmQzIGlzIGEgcGFpblxudmFyIGN1c3RvbWl6ZWRNdWx0aUJhckNoYXJ0ID0gcmVxdWlyZSgnLi9jdXN0b21pemVkL211bHRpQmFyQ2hhcnQuanMnKTtcbi8vIHZhciBkMyA9IHJlcXVpcmUoJ2QzLWJyb3dzZXJpZnknKTtcblxuXG5mdW5jdGlvbiBkYXRhVG9OdihkYXRhKSB7XG4gIHJldHVybiBkYXRhO1xufVxuXG5cbmZ1bmN0aW9uIGNvdW50Q2F0ZWdvcmllcyhkYXRhKSB7XG4gIC8vIG5vdGU6IHRoaXMgdGFrZXMgcmVndWxhciBkYXRhLCBub3QgZGF0YVRvTnYgZGF0YS5cbiAgcmV0dXJuIGRhdGEubGVuZ3RoO1xufVxuXG5cbmZ1bmN0aW9uIHN0YWdnZXJYKGNoYXJ0LCBudkRhdGEpIHtcbiAgaWYgKCFudkRhdGFbMF0pIHsgcmV0dXJuOyB9XG4gIGlmIChudkRhdGFbMF0udmFsdWVzLmxlbmd0aCA8IDUpIHsgcmV0dXJuOyB9XG4gIGNoYXJ0XG4gICAgLnN0YWdnZXJMYWJlbHModHJ1ZSlcbiAgICAubWFyZ2luKHtib3R0b206IDQwfSk7XG59XG5cblxuZnVuY3Rpb24gY2hhcnQob3B0aW9ucykge1xuICB2YXIgbWF4VmFsdWUgPSAxMDtcbiAgdmFyIF9jaGFydCA9IG52Lm1vZGVscy5jdXN0b21pemVkTXVsdGlCYXJDaGFydCgpICBcbiAgICAuZm9yY2VZKFswLCBtYXhWYWx1ZV0pICAvLyBlbnN1cmVzIHlBeGlzIGlzIHNob3dpbmcgYXQgbGVhc3QgMCBhbmQgMTAsIGJ1dCB3b24ndCByZXN0cmljdCB0aGUgZG9tYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKG1lYW5pbmcgaWYgdGhlIGFyZSB2YWx1ZXMgZmFsbGluZyBvdXRzaWRlIHRoZSByYW5nZSBpdCB3aWxsIHNob3cgdGhlbikuXG4gICAgLnJlZHVjZVhUaWNrcyhmYWxzZSlcbiAgICAubWFyZ2luKHsgdG9wOiA1LCByaWdodDogMTAsIGJvdHRvbTogMjAsIGxlZnQ6IDUwIH0pO1xuXG4gIGlmICghb3B0aW9ucy5udkNvbnRyb2xzKSB7XG4gICAgX2NoYXJ0LnNob3dDb250cm9scyhmYWxzZSk7XG4gIH1cblxuICBfY2hhcnQueUF4aXNcbiAgICAudGlja0Zvcm1hdChvcHRpb25zLnNob3J0Rm9ybWF0dGVyKVxuICAgIC5zaG93TWF4TWluKGZhbHNlKTtcblxuICByZXR1cm4gX2NoYXJ0O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkaXNwYXRjaE5hbWU6ICdtdWx0aWJhcicsXG4gIGNvdW50Q2F0ZWdvcmllczogY291bnRDYXRlZ29yaWVzLFxuICBkYXRhVG9OdjogZGF0YVRvTnYsXG4gIHN0YWdnZXJYOiBzdGFnZ2VyWCxcbiAgY2hhcnQ6IGNoYXJ0XG59O1xuIiwiLypcbiAqIERyYXdpbmcgYSBwaWUgY2hhcnQgaW4gQU1QPyBQbGVhc2UgdXNlIC4vY2hhcnQuanMgaW5zdGVhZC5cbiAqL1xuXG52YXIgbnYgPSB3aW5kb3cubnY7ICAvLyBudmQzIGlzIGEgcGFpblxuLy8gdmFyIGQzID0gcmVxdWlyZSgnZDMtYnJvd3NlcmlmeScpO1xuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91Z2x5L3V0aWwnKTtcblxuXG5mdW5jdGlvbiBkYXRhVG9OdihkYXRhKSB7XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gMSkge1xuICAgIGNvbW1vbi5mYWlsKCdQaWUgY2hhcnRzIGNhbiBvbmx5IHNob3cgb25lIHNlcmllcyBvZiBkYXRhLiBnb3QnLCBkYXRhLmxlbmd0aCk7XG4gIH1cbiAgaWYgKCFfLmlzQXJyYXkoZGF0YVswXS52YWx1ZXMpKSB7XG4gICAgY29tbW9uLmZhaWwoJ0RhdGEgc2VyaWVzIGRpZCBub3QgaGF2ZSBhIFwidmFsdWVzXCIgYXJyYXkuIEluc3RlYWQnLCBkYXRhWzBdLnZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIGRhdGFbMF0udmFsdWVzO1xufVxuXG5cbmZ1bmN0aW9uIGNvdW50Q2F0ZWdvcmllcyhkYXRhKSB7XG4gIC8vIG5vdGU6IHRoaXMgdGFrZXMgcmVndWxhciBkYXRhLCBub3QgZGF0YVRvTnYgZGF0YS5cbiAgcmV0dXJuIGRhdGFbMF0udmFsdWVzLmxlbmd0aDtcbn1cblxuXG5mdW5jdGlvbiBjaGFydChvcHRpb25zKSB7XG4gIHZhciBfY2hhcnQgPSBudi5tb2RlbHMucGllQ2hhcnQoKVxuICAgIC52YWx1ZUZvcm1hdChvcHRpb25zLnNob3J0Rm9ybWF0dGVyKVxuICAgIC5sYWJlbFR5cGUoJ3BlcmNlbnQnKVxuICAgIC5kb251dCh0cnVlKVxuICAgIC5kb251dFJhdGlvKDAuMzUpXG4gICAgLnNob3dMZWdlbmQoZmFsc2UpO1xuICByZXR1cm4gX2NoYXJ0O1xufVxuXG5cbmZ1bmN0aW9uIHJlbW92ZUxlZ2VuZChjaGFydCkge1xuICBjaGFydC5zaG93TGVnZW5kKGZhbHNlKTtcbn1cblxuXG5mdW5jdGlvbiBub3JtYWxpemVOdlRUQXJncyhmbXRYLCBmbXRZLCByYXcpIHtcbiAgLy8gbnYgcGllIGNoYXJ0cyBkcm9wIHRoZSBzZXJpZXNOYW1lIGFzIGZpcnN0IGFyZ1xuICByZXR1cm4gW3ZvaWQgMCwgZm10WCwgZm10WSwgcmF3XTtcbn1cblxuZnVuY3Rpb24gYWRkTGVnZW5kKHN2ZywgY2hhcnQsIG52RGF0YSwgdHJpbUxhYmVscywgd2lkdGgpIHtcbiAgdmFyIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgIC53aWR0aCh3aWR0aCB8fCBzdmcuY2xpZW50V2lkdGgpXG4gICAgLm1hcmdpbih7bGVmdDogMjAsIHJpZ2h0OiAyMH0pXG4gICAgLnJpZ2h0QWxpZ24oZmFsc2UpXG4gICAgLmNvbG9yKHV0aWwuY2F0ZWdvcnlDb2xvdXJzKG52RGF0YS5sZW5ndGgpKVxuICAgIC5rZXkoZnVuY3Rpb24oZCkgeyByZXR1cm4gdHJpbUxhYmVscyA/IHV0aWwuZm9ybWF0U2hvcnRUZXh0KDEyKShkLngpIDogZC54OyB9KTtcblxuICBkMy5zZWxlY3Qoc3ZnKVxuICAgIC5kYXR1bShudkRhdGEpXG4gICAgLmNhbGwobGVnZW5kKTtcblxuICB2YXIgbGVnZW5kSGVpZ2h0ID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoJy5udi1sZWdlbmQnKS5nZXRCQm94KCkuaGVpZ2h0O1xuICBjaGFydC5tYXJnaW4oe3RvcDogbGVnZW5kSGVpZ2h0ICsgMTV9KTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGlzcGF0Y2hOYW1lOiAncGllJyxcbiAgbm9ybWFsaXplTnZUVEFyZ3M6IG5vcm1hbGl6ZU52VFRBcmdzLFxuICBjb3VudENhdGVnb3JpZXM6IGNvdW50Q2F0ZWdvcmllcyxcbiAgYWRkTGVnZW5kOiBhZGRMZWdlbmQsXG4gIHJlbW92ZUxlZ2VuZDogcmVtb3ZlTGVnZW5kLFxuICBkYXRhVG9OdjogZGF0YVRvTnYsXG4gIGNoYXJ0OiBjaGFydFxufTtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3VnbHkvdXRpbCcpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgdGFibGVUZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8ZGl2IGNsYXNzPVxcXCJ0YWJsZS1yZXNwb25zaXZlXFxcIj5cXG4gIDx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWRcXFwiPlxcblxcbiAgICA8JSBpZiAoXyhrZXlzKS5zb21lKCkpIHsgJT5cXG4gICAgICA8dGhlYWQ+XFxuICAgICAgICA8dHI+XFxuICAgICAgICAgIDx0ZD48L3RkPlxcbiAgICAgICAgICA8JSBfKGtleXMpLmVhY2goZnVuY3Rpb24oa2V5LCBjb2xJbmRleCkgeyAlPlxcbiAgICAgICAgICAgIDx0aCBkYXRhLXNlcmllcy1pbmRleD1cXFwiPCU9IGNvbEluZGV4ICU+XFxcIj5cXG4gICAgICAgICAgICAgIDwlPSBrZXkgJT5cXG4gICAgICAgICAgICA8L3RoPlxcbiAgICAgICAgICA8JSB9KTsgJT5cXG4gICAgICAgIDwvdHI+XFxuICAgICAgPC90aGVhZD5cXG4gICAgPCUgfSAlPlxcblxcbiAgICA8dGJvZHk+XFxuICAgICAgPCUgXyh2YWx1ZXMpLmVhY2goZnVuY3Rpb24ocm93LCByb3dJbmRleCkgeyAlPlxcbiAgICAgICAgPHRyPlxcbiAgICAgICAgICA8dGggZGF0YS14LWluZGV4PVxcXCI8JT0gcm93SW5kZXggJT5cXFwiPlxcbiAgICAgICAgICAgIDwlPSByb3dbMF0ueCAlPlxcbiAgICAgICAgICA8L3RoPlxcbiAgICAgICAgICA8JSBfKHJvdykuZWFjaChmdW5jdGlvbihkYXR1bSwgY29sSW5kZXgpIHsgJT5cXG4gICAgICAgICAgICA8dGQgZGF0YS14LWluZGV4PVxcXCI8JT0gcm93SW5kZXggJT5cXFwiIGRhdGEtc2VyaWVzLWluZGV4PVxcXCI8JT0gY29sSW5kZXggJT5cXFwiPlxcbiAgICAgICAgICAgICAgPCU9IG1vbmV5Rm9ybWF0KGRhdHVtLnkpICU+XFxuICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgPCUgfSkgJT5cXG4gICAgICAgIDwvdHI+XFxuICAgICAgPCUgfSkgJT5cXG4gICAgPC90Ym9keT5cXG5cXG4gIDwvdGFibGU+XFxuPC9kaXY+XFxuXCIpO1xuXG5cbmZ1bmN0aW9uIGZha2VSYXdDb250ZXh0KGUsIGRhdGEpIHtcbiAgLy8gdHJhbnNmb3JtIGEgdGFibGUtY2xpY2sgZXZlbnQgaW50byBzb21ldGhpbmcgdGhhdCBsb29rcyBsaWtlIGl0IGNhbWUgZnJvbVxuICAvLyBhbiBudmQzIGhhbmRsZXJcbiAgdmFyIHQgPSBlLnRhcmdldCxcbiAgICAgIHNlcmllc0luZGV4ID0gcGFyc2VJbnQodXRpbC5kYXRhKHQsICdzZXJpZXNJbmRleCcpLCAxMCkgfHwgMCxcbiAgICAgIHhJbmRleCA9IHBhcnNlSW50KHV0aWwuZGF0YSh0LCAneEluZGV4JyksIDEwKTtcbiAgcmV0dXJuIHtcbiAgICBsYWJlbDogZGF0YVtzZXJpZXNJbmRleF0udmFsdWVzW3hJbmRleF0ueCB8fCB4SW5kZXgsXG4gICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgIHBvaW50SW5kZXg6IHhJbmRleCxcbiAgICBwb2ludDogZGF0YVtzZXJpZXNJbmRleF0udmFsdWVzW3hJbmRleF0gfHwgeEluZGV4XG4gIH07XG59XG5cblxuZnVuY3Rpb24gYmluZENsaWNrSGFuZGxlcihlbCwgZGF0YSwgb3B0aW9ucykge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZmFrZVJhdyA9IGZha2VSYXdDb250ZXh0KGUsIGRhdGEpLCAgLy8gc28gd2UgY2FuIHVzZSB0aGUgc2hhcmVkIGNvbnRleHQgdHJhbnNmb3JtZXJcbiAgICAgICAgY29udGV4dCA9IGNvbW1vbi5nZXROaWNlQ29udGV4dChmYWtlUmF3LCBkYXRhLCBlLnRhcmdldC5pbm5lclRleHQpO1xuICAgIG9wdGlvbnMuY2xpY2tIYW5kbGVyKGNvbnRleHQpO1xuICB9KTtcbn1cblxuXG5mdW5jdGlvbiBjaGFydGVyKGRhdGEsIG9wdGlvbnMpIHtcblxuICB2YXIga2V5cyA9IF8oZGF0YSkucGx1Y2soJ2tleScpO1xuXG4gIHZhciB2YWx1ZXMgPSBfKGRhdGEpXG4gICAgLmNoYWluKClcbiAgICAubWFwKGZ1bmN0aW9uKGRhdHVtKSB7IHJldHVybiBkYXR1bS52YWx1ZXM7IH0pXG4gICAgLnRyYW5zcG9zZSgpXG4gICAgLnZhbHVlKCk7XG5cbiAgdmFyIGh0bWwgPSB0YWJsZVRlbXBsYXRlKHtcbiAgICBrZXlzOiBrZXlzLFxuICAgIHZhbHVlczogdmFsdWVzLFxuICAgIG1vbmV5Rm9ybWF0OiBvcHRpb25zLnNob3J0Rm9ybWF0dGVyXG4gIH0pO1xuXG4gIHZhciBjaGFydEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNoYXJ0RWwuaW5uZXJIVE1MID0gaHRtbDtcblxuICBiaW5kQ2xpY2tIYW5kbGVyKGNoYXJ0RWwsIGRhdGEsIG9wdGlvbnMpO1xuXG4gIHJldHVybiBjaGFydEVsO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjaGFydGVyOiBjaGFydGVyXG59O1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBkMyA9IHJlcXVpcmUoJ2QzLWJyb3dzZXJpZnknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdWdseS91dGlsJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBiYXJTcGVjaWZpYyA9IHJlcXVpcmUoJy4vX2JhcicpO1xudmFyIG11bHRpYmFyU3BlY2lmaWMgPSByZXF1aXJlKCcuL19tdWx0aWJhcicpO1xudmFyIHBpZVNwZWNpZmljID0gcmVxdWlyZSgnLi9fcGllJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuL190YWJsZScpO1xudmFyIGRlZmF1bHRUVFRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLXByaW1hcnkgcGFuZWwtcG9wb3ZlclxcXCI+XFxuICA8JSBpZiAodHQuaGVhZGluZykgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj48JT0gdHQuaGVhZGluZyAlPjwvZGl2PlxcbiAgPCUgfSAlPlxcbiAgPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJkb2xsYXpcXFwiPlxcbiAgICAgIDwlIGlmICh0dC5ib2R5VGV4dCkgeyAlPlxcbiAgICAgICAgPCU9IHR0LmJvZHlUZXh0ICU+XFxuICAgICAgPCUgfSAlPlxcbiAgICAgIDwlIGlmICh0dC5ib2R5TGlzdCkgeyAlPlxcbiAgICAgICAgPHVsIGNsYXNzPVxcXCJsaXN0LXVuc3R5bGVkXFxcIj5cXG4gICAgICAgICAgPCUgXyh0dC5ib2R5TGlzdCkuZWFjaChmdW5jdGlvbihpdGVtKSB7ICU+XFxuICAgICAgICAgICAgPGxpPjxiPjwlPSBpdGVtLmsgJT48L2I+IDwlPSBpdGVtLnYgJT48L2xpPlxcbiAgICAgICAgICA8JSB9KSAlPlxcbiAgICAgICAgPC91bD5cXG4gICAgICA8JSB9ICU+XFxuICAgIDwvc3Bhbj5cXG4gIDwvZGl2PlxcbiAgPCUgaWYgKHR0LmZvb3RlclRleHQpIHsgJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtZm9vdGVyXFxcIj5cXG4gICAgICA8JT0gdHQuZm9vdGVyVGV4dCAlPlxcbiAgICA8L2Rpdj5cXG4gIDwlIH0gJT5cXG48L2Rpdj5cXG5cIik7XG5cblxudmFyIGNoYXJ0ZXJzID0ge1xuICBiYXI6IGNvbW1vbi5udkNoYXJ0ZXIoYmFyU3BlY2lmaWMpLFxuICBwaWU6IGNvbW1vbi5udkNoYXJ0ZXIocGllU3BlY2lmaWMpLFxuICBtdWx0aWJhcjogY29tbW9uLm52Q2hhcnRlcihtdWx0aWJhclNwZWNpZmljKSxcbiAgdGFibGU6IHRhYmxlLmNoYXJ0ZXJcbn07XG5cblxuZnVuY3Rpb24gY2hhcnQodHlwZSwgZGF0YSwgb3B0aW9ucykge1xuICAvKlxuICAgKiBAcGFyYW0gdHlwZTogJ2JhcicgKGRlZmF1bHQpLCAncGllJywgb3IgJ211bHRpYmFyJ1xuICAgKiBAcGFyYW0gZGF0YTogW3trZXk6ICdzZXJpc05hbWUnLCB2YWx1ZXM6IFt7eDpOTiwgeTpOTn1dfV1cbiAgICogQHBhcmFtIG9wdGlvbnM6IG9wdGlvbmFsIGV4dHJhIHN0dWZmXG4gICAqL1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHNldHRpbmdzIGRlZmF1bHRzXG4gIG9wdGlvbnMgPSBfKF8ob3B0aW9ucykuY2xvbmUoKSkuZGVmYXVsdHMoe1xuICAgIGhlaWdodDogdm9pZCAwLCAgLy8gc2hvdWxkIGZpbGwgY29udGFpbmVyIGluIG1vc3QgY2FzZXMgYnkgZGVmYXVsdFxuICAgIHdpZHRoOiB2b2lkIDAsXG4gICAgbnVtYmVyRm9ybWF0dGVyOiBkMy5mb3JtYXQoJywnKSxcbiAgICBzaG9ydEZvcm1hdHRlcjogb3B0aW9ucy5udW1iZXJGb3JtYXR0ZXIgfHwgdXRpbC5mb3JtYXRLTUIoMywgYXBwLnNldHRpbmdzLm51bWJlckZvcm1hdFNldHRpbmdzLmRlY2ltYWxTZXBhcmF0b3IpLFxuICAgIGFkZExlZ2VuZDogdHJ1ZSxcbiAgICB0cmltTGFiZWxzOiB0cnVlLFxuICAgIGdldFRUQ29udGVudDogY29tbW9uLmRlZmF1bHRHZXRUVENvbnRlbnQsXG4gICAgdHRUZW1wbGF0ZTogZGVmYXVsdFRUVGVtcGxhdGUsXG4gICAgY2xpY2tIYW5kbGVyOiBjb21tb24uZGVmYXVsdENsaWNrSGFuZGxlcixcbiAgICBudkNvbnRyb2xzOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBjaGFydGVyID0gY2hhcnRlcnNbdHlwZV0gfHwgY29tbW9uLmZhaWwoJ3VucmVjb2duaXplZCBjaGFydCB0eXBlJywgdHlwZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBlbDogY2hhcnRlcihkYXRhLCBvcHRpb25zKVxuICB9O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY2hhcnQ7XG4iLCJ2YXIgbnYgPSB3aW5kb3cubnY7ICAvLyBudmQzIGlzIGEgcGFpblxudmFyIGQzID0gcmVxdWlyZSgnZDMtYnJvd3NlcmlmeScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91Z2x5L3V0aWwnKTtcbnZhciBOdW1lcmFsID0gcmVxdWlyZSgnbnVtZXJhbCcpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cblxuLy8gaGFjayBudmQzJ3MgY2FsY0FwcHJveFRleHRXaWR0aCBiZWNhdXNlIGl0IGlzIHRlcnJycnJycnJycmlibGVcbi8vIHRoaXMgc29sdXRpb24gaXMganVzdCBhcyBiYWQgOihcbi8vIG52ZDMgbWFrZXMgbWUgc28gc2FkIDooXG4oZnVuY3Rpb24odW5mb3J0dW5hdGVMaWIpIHtcbiAgdmFyIHNhZFdheU9mQ2FsY3VsYXRpbmdUZXh0V2lkdGggPSB1bmZvcnR1bmF0ZUxpYi51dGlscy5jYWxjQXBwcm94VGV4dFdpZHRoO1xuICB1bmZvcnR1bmF0ZUxpYi51dGlscy5jYWxjQXBwcm94VGV4dFdpZHRoID0gZnVuY3Rpb24oc3ZnVGV4dEVsKSB7XG4gICAgdmFyIG9yaWdpbmFsVGV4dCA9IHN2Z1RleHRFbC50ZXh0KCksXG4gICAgICAgIHNwYWNlUGFkZGVkVGV4dCA9IG9yaWdpbmFsVGV4dCxcbiAgICAgICAgbnVtYmVyT2ZEb3RzID0gKG9yaWdpbmFsVGV4dC5tYXRjaCgvXFwuL2cpIHx8IFtdKS5sZW5ndGgsXG4gICAgICAgIHBvb3JseUNhbGN1bGF0ZWRXaWR0aDtcblxuICAgIGlmIChvcmlnaW5hbFRleHQudG9VcHBlckNhc2UoKSA9PT0gb3JpZ2luYWxUZXh0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yaWdpbmFsVGV4dC5sZW5ndGggLyA1OyBpKyspIHsgc3BhY2VQYWRkZWRUZXh0ICs9ICcgJzsgfVxuICAgICAgc3ZnVGV4dEVsLnRleHQoc3BhY2VQYWRkZWRUZXh0KTtcbiAgICAgIHBvb3JseUNhbGN1bGF0ZWRXaWR0aCA9IHNhZFdheU9mQ2FsY3VsYXRpbmdUZXh0V2lkdGgoc3ZnVGV4dEVsKTtcbiAgICAgIHN2Z1RleHRFbC50ZXh0KG9yaWdpbmFsVGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvb3JseUNhbGN1bGF0ZWRXaWR0aCA9IHNhZFdheU9mQ2FsY3VsYXRpbmdUZXh0V2lkdGgoc3ZnVGV4dEVsKTtcbiAgICB9XG5cbiAgICAvLyDimaogZG8geW91IGJlbGlldmUgaW4gbWFhYWFnaWMg4pmrXG4gICAgcG9vcmx5Q2FsY3VsYXRlZFdpZHRoIC09XG4gICAgICAocG9vcmx5Q2FsY3VsYXRlZFdpZHRoIC8gc3BhY2VQYWRkZWRUZXh0Lmxlbmd0aCkgKiAobnVtYmVyT2ZEb3RzIC8gMyk7XG4gICAgLy8g4pmqIG1hZ2ljIG1hZ2ljIG1hZ2ljIOKZq1xuICAgIHBvb3JseUNhbGN1bGF0ZWRXaWR0aCArPSA2O1xuXG4gICAgcmV0dXJuIHBvb3JseUNhbGN1bGF0ZWRXaWR0aDtcbiAgfTtcbn0pKG52KTtcblxuXG5mdW5jdGlvbiBmYWlsKC8qIGFyZ3VtZW50cyAqLykge1xuICB0aHJvdyB7XG4gICAgbmFtZTogJ0NoYXJ0IEVycm9yJyxcbiAgICBtZXNzYWdlOiBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKGFyZ3VtZW50cywgJywgJyksXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIHRoaXMubWVzc2FnZTsgfVxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIG52Q2hhcnRDb21tb24obnZDaGFydCwgbWF4Q2F0ZWdvcmllcykge1xuICByZXR1cm4gbnZDaGFydFxuICAgIC54KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHV0aWwuZm9ybWF0U2hvcnRUZXh0KDE5KShkLngpOyB9KSAgLy8gZml4IG92ZXJmbG93cyBpbiBsZWdlbmRzXG4gICAgLmNvbG9yKHV0aWwuY2F0ZWdvcnlDb2xvdXJzKG1heENhdGVnb3JpZXMpKTtcbn1cblxuXG5mdW5jdGlvbiBnZXRTZWNyZXRSZW5kZXJBcmVhKGhlaWdodCwgd2lkdGgpIHtcbiAgdmFyIHNlY3JldEFyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3VwZXItc2VjcmV0LXJlbmRlci1hcmVhLXNoaCcpO1xuICBpZiAoIXNlY3JldEFyZWEpIHtcbiAgICBzZWNyZXRBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2VjcmV0QXJlYS5pZCA9ICdzdXBlci1zZWNyZXQtcmVuZGVyLWFyZWEtc2hoJztcbiAgICBzZWNyZXRBcmVhLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBzZWNyZXRBcmVhLnN0eWxlLmxlZnQgPSAnLTk5OTllbSc7XG4gICAgc2VjcmV0QXJlYS5zdHlsZS50b3AgPSAnLTk5OTllbSc7ICAvLyBmb3IgSUUgOihcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNlY3JldEFyZWEpO1xuICB9XG4gIGlmIChoZWlnaHQpIHsgc2VjcmV0QXJlYS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnOyB9XG4gIGlmICh3aWR0aCkgeyBzZWNyZXRBcmVhLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnOyB9XG4gIHJldHVybiBzZWNyZXRBcmVhO1xufVxuXG5cbmZ1bmN0aW9uIG1rQ2hhcnRTVkcoaGVpZ2h0LCB3aWR0aCkge1xuICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGFzaC1jaGFydCcpO1xuICAvLyBwdXQgaXQgaW4gdGhlIGRvbSBidXQgb3V0IG9mIHRoZSB3YXksIHNvIHdlIGNhbiBjb21wdXRlIHN0eWxlcyBuIHN0dWZmXG4gIGdldFNlY3JldFJlbmRlckFyZWEoaGVpZ2h0LCB3aWR0aCkuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgcmV0dXJuIHN2Zztcbn1cblxuXG5mdW5jdGlvbiBudkJvaWxlcihudkRhdGEsIGNoYXJ0LCBzdmcsIHNwZWNpZmljLCB0cmltTGFiZWxzLCBhZGRMZWdlbmQsIHdpZHRoKSB7XG4gIGlmICh0cmltTGFiZWxzKSB7XG5cdCAgY2hhcnQueChmdW5jdGlvbihkKSB7IHJldHVybiB1dGlsLmZvcm1hdFNob3J0VGV4dCg1MCkoZC54KTsgfSk7XG4gIH1cbiAgaWYgKGFkZExlZ2VuZCAmJiBzcGVjaWZpYy5hZGRMZWdlbmQpIHtcbiAgICBzcGVjaWZpYy5hZGRMZWdlbmQoc3ZnLCBjaGFydCwgbnZEYXRhLCB0cmltTGFiZWxzLCB3aWR0aCk7XG4gIH0gZWxzZSBpZiAoIWFkZExlZ2VuZCAmJiBzcGVjaWZpYy5yZW1vdmVMZWdlbmQpIHtcbiAgICBzcGVjaWZpYy5yZW1vdmVMZWdlbmQoY2hhcnQpO1xuICB9XG4gIGlmIChzcGVjaWZpYy5zdGFnZ2VyWCkge1xuICAgIHNwZWNpZmljLnN0YWdnZXJYKGNoYXJ0LCBudkRhdGEpO1xuICB9XG4gIGQzLnNlbGVjdChzdmcpXG4gICAgLmRhdHVtKG52RGF0YSlcbiAgICAuY2FsbChjaGFydCk7XG4gIG52LnV0aWxzLndpbmRvd1Jlc2l6ZShjaGFydC51cGRhdGUpOyAgLy8gdXV1dXVndWdnZ2doXG4gIHdpbmRvdy5zZXRUaW1lb3V0KGNoYXJ0LnVwZGF0ZSwgMCk7ICAvLyBmaXhlcyB3aWVyZCBzbGlnaHRseS1vZmYgYnVnc1xuICBudi5hZGRHcmFwaChmdW5jdGlvbigpIHsgcmV0dXJuIGNoYXJ0OyB9KTsgIC8vIHV1dXV1Z2x5IGlzIG52ZDNcbiAgcmV0dXJuIHN2Zztcbn1cblxuXG5mdW5jdGlvbiBudkNvbG9yaWZ5Q2F0ZWdvcmllcyhjaGFydCwgZGF0YSwgc3BlY2lmaWMpIHtcbiAgdmFyIG51bWJlck9mQ2F0ZWdvcmllcyA9IHNwZWNpZmljLmNvdW50Q2F0ZWdvcmllcyhkYXRhKTtcbiAgY2hhcnQuY29sb3IodXRpbC5jYXRlZ29yeUNvbG91cnMobnVtYmVyT2ZDYXRlZ29yaWVzKSk7XG4gIHJldHVybiBjaGFydDtcbn1cblxuXG5mdW5jdGlvbiBkZWZhdWx0R2V0VFRDb250ZW50KGNvbnRleHQpIHtcbiAgcmV0dXJuIHt0dDoge1xuICAgIGhlYWRpbmc6IGNvbnRleHQueC5yYXcsXG4gICAgYm9keVRleHQ6IGNvbnRleHQueS5yYXcsXG4gICAgZm9ybWF0dGVkQW1vdW50OiBjb250ZXh0LnoucmF3XG4gIH19O1xufVxuXG5cbmZ1bmN0aW9uIGdldE5pY2VDb250ZXh0KHJhdywgZGF0YSwgZm10WSkge1xuICB2YXIgc2VyaWVzSW5kZXggPSByYXcuc2VyaWVzSW5kZXggfHwgMDtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIHNlcmllczoge1xuICAgICAga2V5OiBkYXRhW3Nlcmllc0luZGV4XS5rZXksXG4gICAgICBpbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICB2YWx1ZXM6IGRhdGFbc2VyaWVzSW5kZXhdLnZhbHVlc1xuICAgIH0sXG4gICAgeDoge1xuICAgICAgcmF3OiByYXcucG9pbnQueCxcbiAgICAgIGZtdDogcmF3LmxhYmVsLFxuICAgICAgaW5kZXg6IHJhdy5wb2ludEluZGV4IHx8IHJhdy5pbmRleCB8fCAwXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICByYXc6IHJhdy5wb2ludC55LFxuICAgICAgZm10OiByYXcucG9pbnQueiB8fCBmbXRZXG4gICAgfVxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIG52QmluZFRvb2x0aXAoY2hhcnQsIGRhdGEsIHNwZWNpZmljLCB0ZW1wbGF0ZSwgZ2V0VFRDb250ZW50KSB7XG4gIHZhciBudlRUSGFuZGxlciA9IGZ1bmN0aW9uKHNlcmllc05hbWUsIGZtdFgsIGZtdFksIHJhdykge1xuICAgIHJldHVybiB0ZW1wbGF0ZShnZXRUVENvbnRlbnQoZ2V0TmljZUNvbnRleHQocmF3LCBkYXRhLCBmbXRZKSkpO1xuICB9O1xuXG4gIGlmIChzcGVjaWZpYy5ub3JtYWxpemVOdlRUQXJncykgeyAvLyB3ZSBtaWdodCBoYXZlIHRvIGZpeCBudidzIGluY29uc2lzdGVudCBUVCBhcmdzXG4gICAgbnZUVEhhbmRsZXIgPSB1dGlsLnRyYW5zZm9ybUFyZ3Moc3BlY2lmaWMubm9ybWFsaXplTnZUVEFyZ3MsIG52VFRIYW5kbGVyKTtcbiAgfVxuICBjaGFydC50b29sdGlwQ29udGVudChudlRUSGFuZGxlcik7XG59XG5cblxuZnVuY3Rpb24gZGVmYXVsdENsaWNrSGFuZGxlcigvKiBjb250ZXh0ICovKSB7XG4gIC8vIGRvZXMgbm90aGluZ1xufVxuXG5cbmZ1bmN0aW9uIG52QmluZE90aGVyc0NiKGNoYXJ0LCBkYXRhLCBzcGVjaWZpYywgY2xpY2tIYW5kbGVyKSB7XG4gIGNoYXJ0W3NwZWNpZmljLmRpc3BhdGNoTmFtZV0uZGlzcGF0Y2gub24oJ2VsZW1lbnRDbGljaycsIGZ1bmN0aW9uKHJhdykge1xuICAgIGNsaWNrSGFuZGxlcihnZXROaWNlQ29udGV4dChyYXcsIGRhdGEpKTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gbnZDaGFydGVyKHNwZWNpZmljKSB7XG4gIHJldHVybiBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIHN2ZyA9IG1rQ2hhcnRTVkcob3B0aW9ucy5oZWlnaHQsIG9wdGlvbnMud2lkdGgpLFxuICAgICAgICBudkNoYXJ0ID0gc3BlY2lmaWMuY2hhcnQob3B0aW9ucyksXG4gICAgICAgIG52RGF0YSA9IHNwZWNpZmljLmRhdGFUb052KGRhdGEpO1xuICAgIG52Q29sb3JpZnlDYXRlZ29yaWVzKG52Q2hhcnQsIGRhdGEsIHNwZWNpZmljKTtcbiAgICBudkJpbmRUb29sdGlwKG52Q2hhcnQsIGRhdGEsIHNwZWNpZmljLCBvcHRpb25zLnR0VGVtcGxhdGUsIG9wdGlvbnMuZ2V0VFRDb250ZW50KTtcbiAgICBudkJvaWxlcihudkRhdGEsIG52Q2hhcnQsIHN2Zywgc3BlY2lmaWMsIG9wdGlvbnMudHJpbUxhYmVscywgb3B0aW9ucy5hZGRMZWdlbmQsIG9wdGlvbnMud2lkdGgpO1xuICAgIG52QmluZE90aGVyc0NiKG52Q2hhcnQsIGRhdGEsIHNwZWNpZmljLCBvcHRpb25zLmNsaWNrSGFuZGxlcik7XG4gICAgcmV0dXJuIHN2ZztcbiAgfTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bWJlcikge1xuXHR2YXIgZm9ybWF0ID0gXCJcIjtcblx0aWYgKGFwcC5zZXR0aW5ncy5udW1iZXJGb3JtYXRTZXR0aW5ncy5ncm91cFNlcGFyYXRvci5sZW5ndGggPiAwKSB7XG5cdFx0Zm9ybWF0ID0gXCIwLDBcIjtcblx0fSBlbHNlIHtcblx0XHRmb3JtYXQgPSBcIjBcIjtcblx0fVxuXHRpZiAoYXBwLnNldHRpbmdzLm51bWJlckZvcm1hdFNldHRpbmdzLm51bWJlckZvcm1hdC5pbmRleE9mKCcuJykgPiAwKSB7XG5cdFx0dmFyIGRlY2ltYWxEaWdpdHMgPSBhcHAuc2V0dGluZ3MubnVtYmVyRm9ybWF0U2V0dGluZ3MubnVtYmVyRm9ybWF0Lmxlbmd0aCBcblx0XHRcdC0gYXBwLnNldHRpbmdzLm51bWJlckZvcm1hdFNldHRpbmdzLm51bWJlckZvcm1hdC5pbmRleE9mKCcuJyk7XG5cdFx0Zm9ybWF0ID0gZm9ybWF0ICsgXCIuXCIgKyBuZXcgQXJyYXkoZGVjaW1hbERpZ2l0cykuam9pbihcIjBcIik7XG5cdH1cblx0XG5cdC8vIERlZmluZSBhIG5ldyBcImxhbmd1YWdlXCIgZm9yIE51bWVyYWwgd2hlcmUgd2UgY2FuIGNoYW5nZSB0aGUgZGVmYXVsdFxuXHQvLyBkZWxpbWl0ZXJzLlxuXHR2YXIgYW1wTGFuZyA9IHtcblx0XHRkZWxpbWl0ZXJzIDoge1xuXHRcdFx0dGhvdXNhbmRzIDogYXBwLnNldHRpbmdzLm51bWJlckZvcm1hdFNldHRpbmdzLmdyb3VwU2VwYXJhdG9yLFxuXHRcdFx0ZGVjaW1hbCA6IGFwcC5zZXR0aW5ncy5udW1iZXJGb3JtYXRTZXR0aW5ncy5kZWNpbWFsU2VwYXJhdG9yXG5cdFx0fSxcblx0XHRhYmJyZXZpYXRpb25zIDoge1xuXHRcdFx0dGhvdXNhbmQgOiAnSycsXG5cdFx0XHRtaWxsaW9uIDogJ00nLFxuXHRcdFx0YmlsbGlvbiA6ICdCJyxcblx0XHRcdHRyaWxsaW9uIDogJ1QnXG5cdFx0fSxcblx0XHRvcmRpbmFsIDogZnVuY3Rpb24obnVtYmVyKSB7XG5cdFx0XHRyZXR1cm4gbnVtYmVyID09PSAxID8gJ3N0JyA6ICdyZHMnO1xuXHRcdH0sXG5cdFx0Y3VycmVuY3kgOiB7XG5cdFx0XHRzeW1ib2wgOiAnJCdcblx0XHR9XG5cdH07XG5cdE51bWVyYWwubGFuZ3VhZ2UoJ2FtcCcsIGFtcExhbmcpO1xuXHQvLyBBcHBseSBuZXcgbGFuZ3VhZ2UuXG5cdE51bWVyYWwubGFuZ3VhZ2UoJ2FtcCcpO1xuXHQvLyBBcHBseSB0aGUgZm9ybWF0LlxuXHR2YXIgc3RyaW5nTnVtYmVyID0gbmV3IE51bWVyYWwobnVtYmVyKS5mb3JtYXQoZm9ybWF0KTtcblx0cmV0dXJuIHN0cmluZ051bWJlcjtcbn1cblxudmFyIGFtcExhbmcgPSBcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmFpbDogZmFpbCxcbiAgbnZDaGFydENvbW1vbjogbnZDaGFydENvbW1vbixcbiAgZ2V0TmljZUNvbnRleHQ6IGdldE5pY2VDb250ZXh0LFxuICBkZWZhdWx0R2V0VFRDb250ZW50OiBkZWZhdWx0R2V0VFRDb250ZW50LFxuICBkZWZhdWx0Q2xpY2tIYW5kbGVyOiBkZWZhdWx0Q2xpY2tIYW5kbGVyLFxuICBta0NoYXJ0U1ZHOiBta0NoYXJ0U1ZHLFxuICBudkJvaWxlcjogbnZCb2lsZXIsXG4gIG52Q2hhcnRlcjogbnZDaGFydGVyLFxuICBmb3JtYXROdW1iZXI6IGZvcm1hdE51bWJlclxufTtcbiIsIlxyXG5udi5tb2RlbHMuY3VzdG9taXplZE11bHRpQmFyQ2hhcnQgPSBmdW5jdGlvbigpIHtcclxuICBcInVzZSBzdHJpY3RcIjtcclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgdmFyIG11bHRpYmFyID0gbnYubW9kZWxzLm11bHRpQmFyKClcclxuICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXHJcbiAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxyXG4gICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcclxuICAgICwgY29udHJvbHMgPSBudi5tb2RlbHMubGVnZW5kKCkgLy90aGlzIGlzbid0IGV4cG9zZWQgYnkgZGVmYXVsdCA6KFxyXG4gICAgO1xyXG5cclxuICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9XHJcbiAgICAsIHdpZHRoID0gbnVsbFxyXG4gICAgLCBoZWlnaHQgPSBudWxsXHJcbiAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcclxuICAgICwgc2hvd0NvbnRyb2xzID0gdHJ1ZVxyXG4gICAgLCBzaG93TGVnZW5kID0gdHJ1ZVxyXG4gICAgLCBzaG93WEF4aXMgPSB0cnVlXHJcbiAgICAsIHNob3dZQXhpcyA9IHRydWVcclxuICAgICwgcmlnaHRBbGlnbllBeGlzID0gZmFsc2VcclxuICAgICwgcmVkdWNlWFRpY2tzID0gdHJ1ZSAvLyBpZiBmYWxzZSBhIHRpY2sgd2lsbCBzaG93IGZvciBldmVyeSBkYXRhIHBvaW50XHJcbiAgICAsIHN0YWdnZXJMYWJlbHMgPSBmYWxzZVxyXG4gICAgLCByb3RhdGVMYWJlbHMgPSAwXHJcbiAgICAsIHRvb2x0aXBzID0gdHJ1ZVxyXG4gICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xyXG4gICAgICAgIHJldHVybiAnPGgzPicgKyBrZXkgKyAnPC9oMz4nICtcclxuICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICcgb24gJyArIHggKyAnPC9wPidcclxuICAgICAgfVxyXG4gICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxyXG4gICAgLCB5IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC55U2NhbGUoKVxyXG4gICAgLCBzdGF0ZSA9IHsgc3RhY2tlZDogZmFsc2UgfVxyXG4gICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXHJcbiAgICAsIG5vRGF0YSA9IFwiTm8gRGF0YSBBdmFpbGFibGUuXCJcclxuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnKVxyXG4gICAgLCBjb250cm9sV2lkdGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNob3dDb250cm9scyA/IDMwMCA6IDAgfSAvKkluY3JlYXNlZCBmcm9tIDE4MCBpbiBvcmlnaW5hbCBmaWxlLiovXHJcbiAgICAsIHRyYW5zaXRpb25EdXJhdGlvbiA9IDI1MFxyXG4gICAgO1xyXG5cclxuICBtdWx0aWJhclxyXG4gICAgLnN0YWNrZWQoZmFsc2UpXHJcbiAgICA7XHJcbiAgeEF4aXNcclxuICAgIC5vcmllbnQoJ2JvdHRvbScpXHJcbiAgICAudGlja1BhZGRpbmcoNylcclxuICAgIC5oaWdobGlnaHRaZXJvKHRydWUpXHJcbiAgICAuc2hvd01heE1pbihmYWxzZSlcclxuICAgIC50aWNrRm9ybWF0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSlcclxuICAgIDtcclxuICB5QXhpc1xyXG4gICAgLm9yaWVudCgocmlnaHRBbGlnbllBeGlzKSA/ICdyaWdodCcgOiAnbGVmdCcpXHJcbiAgICAudGlja0Zvcm1hdChkMy5mb3JtYXQoJywuMWYnKSlcclxuICAgIDtcclxuXHJcbiAgY29udHJvbHMudXBkYXRlU3RhdGUoZmFsc2UpO1xyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5cclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIFByaXZhdGUgVmFyaWFibGVzXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xyXG4gICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcclxuICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXHJcbiAgICAgICAgeCA9IHhBeGlzLnRpY2tGb3JtYXQoKShtdWx0aWJhci54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXHJcbiAgICAgICAgeSA9IHlBeGlzLnRpY2tGb3JtYXQoKShtdWx0aWJhci55KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXHJcbiAgICAgICAgY29udGVudCA9IHRvb2x0aXAoZS5zZXJpZXMua2V5LCB4LCB5LCBlLCBjaGFydCk7XHJcblxyXG4gICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBlLnZhbHVlIDwgMCA/ICduJyA6ICdzJywgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XHJcbiAgfTtcclxuXHJcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xyXG4gICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxyXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXHJcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xyXG5cclxuICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGNoYXJ0KSB9O1xyXG4gICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xyXG5cclxuICAgICAgLy9zZXQgc3RhdGUuZGlzYWJsZWRcclxuICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XHJcblxyXG4gICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xyXG4gICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XHJcbiAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcclxuICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXHJcbiAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XS5zbGljZSgwKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAvLyBEaXNwbGF5IG5vRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxyXG5cclxuICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xyXG5cclxuICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXHJcbiAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxyXG4gICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcclxuXHJcbiAgICAgICAgbm9EYXRhVGV4dFxyXG4gICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcclxuICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXHJcbiAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gY2hhcnQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIC8vIFNldHVwIFNjYWxlc1xyXG5cclxuICAgICAgeCA9IG11bHRpYmFyLnhTY2FsZSgpO1xyXG4gICAgICB5ID0gbXVsdGliYXIueVNjYWxlKCk7XHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XHJcblxyXG4gICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1tdWx0aUJhcldpdGhMZWdlbmQnKS5kYXRhKFtkYXRhXSk7XHJcbiAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LW11bHRpQmFyV2l0aExlZ2VuZCcpLmFwcGVuZCgnZycpO1xyXG4gICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XHJcblxyXG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XHJcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcclxuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XHJcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XHJcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1jb250cm9sc1dyYXAnKTtcclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgLy8gTGVnZW5kXHJcblxyXG4gICAgICBpZiAoc2hvd0xlZ2VuZCkge1xyXG4gICAgICAgIGxlZ2VuZC53aWR0aChhdmFpbGFibGVXaWR0aCAtIGNvbnRyb2xXaWR0aCgpKTtcclxuXHJcbiAgICAgICAgaWYgKG11bHRpYmFyLmJhckNvbG9yKCkpXHJcbiAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcclxuICAgICAgICAgICAgc2VyaWVzLmNvbG9yID0gZDMucmdiKCcjY2NjJykuZGFya2VyKGkgKiAxLjUpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxyXG4gICAgICAgICAgICAuZGF0dW0oZGF0YSlcclxuICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcclxuXHJcbiAgICAgICAgaWYgKCBtYXJnaW4udG9wICE9IGxlZ2VuZC5oZWlnaHQoKSkge1xyXG4gICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcclxuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgY29udHJvbFdpZHRoKCkgKyAnLCcgKyAoLW1hcmdpbi50b3ApICsnKScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIC8vIENvbnRyb2xzXHJcblxyXG4gICAgICB2YXIgZ3JvdXBlZExlZ2VuZFRybiA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtY2hhcnQtbGVnZW5kcy1Hcm91cGVkXCIsXCJHcm91cGVkXCIpO1xyXG4gICAgICB2YXIgc3RhY2tlZExlZ2VuZFRybiA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtY2hhcnQtbGVnZW5kcy1TdGFja2VkXCIsXCJTdGFja2VkXCIpO1xyXG4gICAgICBpZiAoc2hvd0NvbnRyb2xzKSB7XHJcbiAgICAgICAgdmFyIGNvbnRyb2xzRGF0YSA9IFtcclxuICAgICAgICAgIHsga2V5OiBncm91cGVkTGVnZW5kVHJuLCBkaXNhYmxlZDogbXVsdGliYXIuc3RhY2tlZCgpIH0sXHJcbiAgICAgICAgICB7IGtleTogc3RhY2tlZExlZ2VuZFRybiwgZGlzYWJsZWQ6ICFtdWx0aWJhci5zdGFja2VkKCkgfVxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGNvbnRyb2xzLndpZHRoKGNvbnRyb2xXaWR0aCgpKS5jb2xvcihbJyM0NDQnLCAnIzQ0NCcsICcjNDQ0J10pO1xyXG4gICAgICAgIGcuc2VsZWN0KCcubnYtY29udHJvbHNXcmFwJylcclxuICAgICAgICAgICAgLmRhdHVtKGNvbnRyb2xzRGF0YSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKVxyXG4gICAgICAgICAgICAuY2FsbChjb250cm9scyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xyXG5cclxuICAgICAgaWYgKHJpZ2h0QWxpZ25ZQXhpcykge1xyXG4gICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXHJcbiAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBhdmFpbGFibGVXaWR0aCArIFwiLDApXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxyXG5cclxuICAgICAgbXVsdGliYXJcclxuICAgICAgICAuZGlzYWJsZWQoZGF0YS5tYXAoZnVuY3Rpb24oc2VyaWVzKSB7IHJldHVybiBzZXJpZXMuZGlzYWJsZWQgfSkpXHJcbiAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxyXG4gICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxyXG4gICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcclxuICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xyXG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkIH0pKVxyXG5cclxuXHJcbiAgICAgIHZhciBiYXJzV3JhcCA9IGcuc2VsZWN0KCcubnYtYmFyc1dyYXAnKVxyXG4gICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxyXG5cclxuICAgICAgYmFyc1dyYXAudHJhbnNpdGlvbigpLmNhbGwobXVsdGliYXIpO1xyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAvLyBTZXR1cCBBeGVzXHJcblxyXG4gICAgICBpZiAoc2hvd1hBeGlzKSB7XHJcbiAgICAgICAgICB4QXhpc1xyXG4gICAgICAgICAgICAuc2NhbGUoeClcclxuICAgICAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVXaWR0aCAvIDEwMCApXHJcbiAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcclxuXHJcbiAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXHJcbiAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKTtcclxuICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJykudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xyXG5cclxuICAgICAgICAgIHZhciB4VGlja3MgPSBnLnNlbGVjdCgnLm52LXgubnYtYXhpcyA+IGcnKS5zZWxlY3RBbGwoJ2cnKTtcclxuXHJcbiAgICAgICAgICB4VGlja3NcclxuICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdsaW5lLCB0ZXh0JylcclxuICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKVxyXG5cclxuICAgICAgICAgIGlmIChzdGFnZ2VyTGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGdldFRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCI7XHJcbiAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgdmFyIHN0YWdnZXJVcCA9IDUsIHN0YWdnZXJEb3duID0gMTc7ICAvL3BpeGVscyB0byBzdGFnZ2VyIGJ5XHJcbiAgICAgICAgICAgICAgLy8gSXNzdWUgIzE0MFxyXG4gICAgICAgICAgICAgIHhUaWNrc1xyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInRleHRcIilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGksaikgeyBcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIGdldFRyYW5zbGF0ZSgwLCAoaiAlIDIgPT0gMCA/IHN0YWdnZXJVcCA6IHN0YWdnZXJEb3duKSk7XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICB2YXIgdG90YWxJbkJldHdlZW5UaWNrcyA9IGQzLnNlbGVjdEFsbChcIi5udi14Lm52LWF4aXMgLm52LXdyYXAgZyBnIHRleHRcIilbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIGcuc2VsZWN0QWxsKFwiLm52LXgubnYtYXhpcyAubnYtYXhpc01heE1pbiB0ZXh0XCIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHJhbnNsYXRlKDAsIChpID09PSAwIHx8IHRvdGFsSW5CZXR3ZWVuVGlja3MgJSAyICE9PSAwKSA/IHN0YWdnZXJEb3duIDogc3RhZ2dlclVwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChyZWR1Y2VYVGlja3MpXHJcbiAgICAgICAgICAgIHhUaWNrc1xyXG4gICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpICUgTWF0aC5jZWlsKGRhdGFbMF0udmFsdWVzLmxlbmd0aCAvIChhdmFpbGFibGVXaWR0aCAvIDEwMCkpICE9PSAwO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0LCBsaW5lJylcclxuICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKTtcclxuXHJcbiAgICAgICAgICBpZihyb3RhdGVMYWJlbHMpXHJcbiAgICAgICAgICAgIHhUaWNrc1xyXG4gICAgICAgICAgICAgIC5zZWxlY3RBbGwoJy50aWNrIHRleHQnKVxyXG4gICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAncm90YXRlKCcgKyByb3RhdGVMYWJlbHMgKyAnIDAsMCknKVxyXG4gICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByb3RhdGVMYWJlbHMgPiAwID8gJ3N0YXJ0JyA6ICdlbmQnKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKS5zZWxlY3RBbGwoJ2cubnYtYXhpc01heE1pbiB0ZXh0JylcclxuICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIGlmIChzaG93WUF4aXMpIHsgICAgICBcclxuICAgICAgICAgIHlBeGlzXHJcbiAgICAgICAgICAgIC5zY2FsZSh5KVxyXG4gICAgICAgICAgICAudGlja3MoIGF2YWlsYWJsZUhlaWdodCAvIDM2IClcclxuICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xyXG5cclxuICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJykudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgLmNhbGwoeUF4aXMpO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG5cclxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHsgXHJcbiAgICAgICAgc3RhdGUgPSBuZXdTdGF0ZTtcclxuICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XHJcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29udHJvbHMuZGlzcGF0Y2gub24oJ2xlZ2VuZENsaWNrJywgZnVuY3Rpb24oZCxpKSB7XHJcbiAgICAgICAgaWYgKCFkLmRpc2FibGVkKSByZXR1cm47XHJcbiAgICAgICAgY29udHJvbHNEYXRhID0gY29udHJvbHNEYXRhLm1hcChmdW5jdGlvbihzKSB7XHJcbiAgICAgICAgICBzLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChkLmtleSkge1xyXG4gICAgICAgICAgY2FzZSBncm91cGVkTGVnZW5kVHJuOlxyXG4gICAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKGZhbHNlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIHN0YWNrZWRMZWdlbmRUcm46XHJcbiAgICAgICAgICAgIG11bHRpYmFyLnN0YWNrZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGUuc3RhY2tlZCA9IG11bHRpYmFyLnN0YWNrZWQoKTtcclxuICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XHJcblxyXG4gICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSlcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxyXG4gICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xyXG4gICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBlLnN0YWNrZWQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKGUuc3RhY2tlZCk7XHJcbiAgICAgICAgICBzdGF0ZS5zdGFja2VkID0gZS5zdGFja2VkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH1cclxuXHJcblxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIG11bHRpYmFyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XHJcbiAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcclxuICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xyXG4gIH0pO1xyXG5cclxuICBtdWx0aWJhci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XHJcbiAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcclxuICB9KTtcclxuICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5cclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcclxuICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xyXG4gIGNoYXJ0Lm11bHRpYmFyID0gbXVsdGliYXI7XHJcbiAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xyXG4gIGNoYXJ0LmNvbnRyb2xzID0gY29udHJvbHM7XHJcbiAgY2hhcnQueEF4aXMgPSB4QXhpcztcclxuICBjaGFydC55QXhpcyA9IHlBeGlzO1xyXG5cclxuICBkMy5yZWJpbmQoY2hhcnQsIG11bHRpYmFyLCAneCcsICd5JywgJ3hEb21haW4nLCAneURvbWFpbicsICd4UmFuZ2UnLCAneVJhbmdlJywgJ2ZvcmNlWCcsICdmb3JjZVknLCAnY2xpcEVkZ2UnLFxyXG4gICAnaWQnLCAnc3RhY2tlZCcsICdzdGFja09mZnNldCcsICdkZWxheScsICdiYXJDb2xvcicsJ2dyb3VwU3BhY2luZycpO1xyXG5cclxuICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XHJcbiAgXHJcbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFyZ2luO1xyXG4gICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcclxuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcclxuICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XHJcbiAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xyXG4gICAgd2lkdGggPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcclxuICAgIGhlaWdodCA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQuY29sb3IgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2xvcjtcclxuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XHJcbiAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LnNob3dDb250cm9scyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dDb250cm9scztcclxuICAgIHNob3dDb250cm9scyA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQuc2hvd0xlZ2VuZCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dMZWdlbmQ7XHJcbiAgICBzaG93TGVnZW5kID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC5zaG93WEF4aXMgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93WEF4aXM7XHJcbiAgICBzaG93WEF4aXMgPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LnNob3dZQXhpcyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dZQXhpcztcclxuICAgIHNob3dZQXhpcyA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQucmlnaHRBbGlnbllBeGlzID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByaWdodEFsaWduWUF4aXM7XHJcbiAgICByaWdodEFsaWduWUF4aXMgPSBfO1xyXG4gICAgeUF4aXMub3JpZW50KCAoXykgPyAncmlnaHQnIDogJ2xlZnQnKTtcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC5yZWR1Y2VYVGlja3M9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJlZHVjZVhUaWNrcztcclxuICAgIHJlZHVjZVhUaWNrcyA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQucm90YXRlTGFiZWxzID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcm90YXRlTGFiZWxzO1xyXG4gICAgcm90YXRlTGFiZWxzID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9XHJcblxyXG4gIGNoYXJ0LnN0YWdnZXJMYWJlbHMgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGFnZ2VyTGFiZWxzO1xyXG4gICAgc3RhZ2dlckxhYmVscyA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQudG9vbHRpcCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXA7XHJcbiAgICB0b29sdGlwID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC50b29sdGlwcyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXBzO1xyXG4gICAgdG9vbHRpcHMgPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LnRvb2x0aXBDb250ZW50ID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcDtcclxuICAgIHRvb2x0aXAgPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LnN0YXRlID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhdGU7XHJcbiAgICBzdGF0ZSA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQuZGVmYXVsdFN0YXRlID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGVmYXVsdFN0YXRlO1xyXG4gICAgZGVmYXVsdFN0YXRlID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG4gIFxyXG4gIGNoYXJ0Lm5vRGF0YSA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vRGF0YTtcclxuICAgIG5vRGF0YSA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuXHJcbiAgcmV0dXJuIGNoYXJ0O1xyXG59IiwiZnVuY3Rpb24gcXVlcnlzZWxlY3RvcigpIHtcbiAgcmV0dXJuICEhZG9jdW1lbnQucXVlcnlTZWxlY3RvcjsgIC8vIGZhaWxzIG9uIG9vb29vb29vb29sZCBJRVxufVxuXG5cbmZ1bmN0aW9uIHN2ZygpIHtcbiAgdHJ5IHtcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuXG5mdW5jdGlvbiBjYW52YXMoKSB7XG4gIHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XG59XG5cblxuZnVuY3Rpb24gY2FudmFzVGV4dCgpIHtcbiAgaWYgKCFjYW52YXMoKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgdmFyIHRleHRGbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJykuZmlsbFRleHQ7XG4gIHJldHVybiAodHlwZW9mIHRleHRGbiA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cblxudmFyIGlzSUUgPSAoZnVuY3Rpb24oKSB7XG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI0MDE4NjEvMTI5OTY5NVxuICAvLyBNYWdpYy4gRG8gbm90IHRvdWNoLlxuICB2YXIgeWVzSXRJcyA9ICEhKGZ1bmN0aW9uKCkge1xuICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsIHRlbSxcbiAgICBNID0gdWEubWF0Y2goLyhvcGVyYXxjaHJvbWV8c2FmYXJpfGZpcmVmb3h8bXNpZXx0cmlkZW50KD89XFwvKSlcXC8/XFxzKihcXGQrKS9pKSB8fCBbXTtcbiAgICBpZiAoL3RyaWRlbnQvaS50ZXN0KE1bMV0pKSB7XG4gICAgICB0ZW0gPSAgL1xcYnJ2WyA6XSsoXFxkKykvZy5leGVjKHVhKSB8fCBbXTtcbiAgICAgIHJldHVybiAnTVNJRSAnICsgKHRlbVsxXSB8fCAnJyk7XG4gICAgfVxuICAgIGlmIChNWzFdID09PSAnQ2hyb21lJykge1xuICAgICAgdGVtID0gdWEubWF0Y2goL1xcYk9QUlxcLyhcXGQrKS8pO1xuICAgICAgaWYgKCEhdGVtKSB7IHJldHVybiAnT3BlcmEgJyArIHRlbVsxXTsgfVxuICAgIH1cbiAgICBNID0gTVsyXSA/IFtNWzFdLCBNWzJdXSA6IFtuYXZpZ2F0b3IuYXBwTmFtZSwgbmF2aWdhdG9yLmFwcFZlcnNpb24sICctPyddO1xuICAgIGlmICgodGVtID0gISF1YS5tYXRjaCgvdmVyc2lvblxcLyhcXGQrKS9pKSkpIHsgTS5zcGxpY2UoMSwgMSwgdGVtWzFdKTsgfVxuICAgIHJldHVybiBNLmpvaW4oJyAnKTtcbiAgfSkoKS5tYXRjaCgvXk1TSUUvKTtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiB5ZXNJdElzOyB9O1xufSkoKTtcblxuXG5mdW5jdGlvbiBkYXRhVVJMSHJlZigpIHtcbiAgLy8gSSBkb24ndCBrbm93IGhvdyB0byBmZWF0dXJlLWRldGVjdCB0aGlzIDooXG4gIC8vIHdlIHdpbGwgYmUgb3B0aW1pc2l0aWMgYW4gb25seSBzYXkgXCJub1wiIGlmIHdlIHNlZSBJRS5cbiAgcmV0dXJuICFpc0lFKCk7XG59XG5cblxuZnVuY3Rpb24gZmxhc2goKSB7XG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMDk1NDY3LzEyOTk2OTVcbiAgLy8gZ3Jvc3MuLi5cbiAgdHJ5IHtcbiAgICByZXR1cm4gISEobmV3IEFjdGl2ZVhPYmplY3QoJ1Nob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoJykpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IubWltZVR5cGVzICYmXG4gICAgICBuYXZpZ2F0b3IubWltZVR5cGVzWydhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCddICE9PSB2b2lkIDAgJiZcbiAgICAgIG5hdmlnYXRvci5taW1lVHlwZXNbJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJ10uZW5hYmxlZFBsdWdpbjtcbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtaXNzaW5nRmVhdHVyZXMgPSBbXTsgIC8vIGFuIGVtcHR5IGFycmF5IHdpbGwgY2FzdCB0byBib29sIGZhbHNlLiBoYW5keSFcblxuICBpZiAoIXF1ZXJ5c2VsZWN0b3IoKSkge1xuICAgIG1pc3NpbmdGZWF0dXJlcy5wdXNoKHtcbiAgICAgIGZlYXR1cmU6ICdxdWVyeVNlbGVjdG9yJyxcbiAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnXG4gICAgfSk7XG4gIH1cblxuICBpZiAoIXN2ZygpKSB7XG4gICAgbWlzc2luZ0ZlYXR1cmVzLnB1c2goe1xuICAgICAgZmVhdHVyZTogJ1NWRycsXG4gICAgICBzZXZlcml0eTogJ2NyaXRpY2FsJ1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFjYW52YXNUZXh0KCkpIHtcbiAgICBtaXNzaW5nRmVhdHVyZXMucHVzaCh7XG4gICAgICBmZWF0dXJlOiAnY2FudmFzJyxcbiAgICAgIHNldmVyaXR5OiAnbWFqb3InXG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWRhdGFVUkxIcmVmKCkpIHtcbiAgICBtaXNzaW5nRmVhdHVyZXMucHVzaCh7XG4gICAgICBmZWF0dXJlOiAnZG93bmxvYWQnLFxuICAgICAgc2V2ZXJpdHk6IGZsYXNoKCkgPyAnbWlub3InIDogJ21ham9yJ1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFmbGFzaCgpKSB7XG4gICAgbWlzc2luZ0ZlYXR1cmVzLnB1c2goe1xuICAgICAgZmVhdHVyZTogJ2ZsYXNoJyxcbiAgICAgIHNldmVyaXR5OiBpc0lFKCkgPyAnbWFqb3InIDogJ21pbm9yJ1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG1pc3NpbmdGZWF0dXJlcztcbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBDaGFydE1vZGVsID0gcmVxdWlyZSgnLi9jaGFydC1tb2RlbC1iYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDaGFydE1vZGVsLmV4dGVuZCh7XG5cdFxuXG5cdGRlZmF1bHRzIDoge1xuXHRcdHRpdGxlIDogJydcblx0fSxcblxuICBfcHJlcGFyZVRyYW5zbGF0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcmVkaWN0YWJpbGl0eUJhc2VMYW5ndWFnZSA9IHt9O1xuXG4gICAgLyogUHJlcGFyZSB0aGUgdHJhbnNsYXRpb25zIGZvciB0aGUgY2hhcnQgKi9cbiAgICBwcmVkaWN0YWJpbGl0eUJhc2VMYW5ndWFnZVsnYW1wLmRhc2hib2FyZDphaWQtcHJlZGljdGFiaWxpdHktcGxhbm5lZC1kaXNidXJzZW1lbnRzJ10gPSAnUGxhbm5lZCBEaXNidXJzZW1lbnRzJztcbiAgICBwcmVkaWN0YWJpbGl0eUJhc2VMYW5ndWFnZVsnYW1wLmRhc2hib2FyZDphaWQtcHJlZGljdGFiaWxpdHktYWN0dWFsLWRpc2J1cnNlbWVudHMnXSA9ICdBY3R1YWwgRGlzYnVyc2VtZW50cyc7XG5cbiAgICB0aGlzLmxvY2FsaXplZFByZWRpY3RhYmlsaXR5ID0gdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVMaXN0KHByZWRpY3RhYmlsaXR5QmFzZUxhbmd1YWdlKS50aGVuKFxuICAgICAgZnVuY3Rpb24obG9jYWxpemVkUHJlZGljdGFiaWxpdHlMaXN0KSB7XG4gICAgICAgIHNlbGYubG9jYWxpemVkUHJlZGljdGFiaWxpdHlMaXN0ID0gbG9jYWxpemVkUHJlZGljdGFiaWxpdHlMaXN0O1xuICAgICAgfSk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5zZXQoJ3RpdGxlJywgZGF0YS50aXRsZSk7XG5cdFxuICAgIGZ1bmN0aW9uIHBpY2sod2hpY2gpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogZC55ZWFyLFxuICAgICAgICAgIHk6IGRbd2hpY2hdWydhbW91bnQnXSxcbiAgICAgICAgICB6OiBkW3doaWNoXVsnZm9ybWF0dGVkQW1vdW50J11cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8qIHJldHVybnMgZnJvbSBtYXAoKSBsaWtlIFt7YW1wLmdpczp0aXRsZS1SZWdpb246ICdSZWdpb24nfSwgLi4uIF0qL1xuXG4gICAgZGF0YS5wcm9jZXNzZWQgPSBbXG4gICAgICB7XG4gICAgICAgIGtleTogdGhpcy5sb2NhbGl6ZWRQcmVkaWN0YWJpbGl0eUxpc3RbJ2FtcC5kYXNoYm9hcmQ6YWlkLXByZWRpY3RhYmlsaXR5LXBsYW5uZWQtZGlzYnVyc2VtZW50cyddLFxuICAgICAgICBvcmlnaW5hbEtleTogJ3BsYW5uZWQnLFxuICAgICAgICB2YWx1ZXM6IF8oZGF0YS55ZWFycykubWFwKHBpY2soJ3BsYW5uZWQgZGlzYnVyc2VtZW50cycpKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiB0aGlzLmxvY2FsaXplZFByZWRpY3RhYmlsaXR5TGlzdFsnYW1wLmRhc2hib2FyZDphaWQtcHJlZGljdGFiaWxpdHktYWN0dWFsLWRpc2J1cnNlbWVudHMnXSxcbiAgICAgICAgb3JpZ2luYWxLZXk6ICdhY3R1YWwnLFxuICAgICAgICB2YWx1ZXM6IF8oZGF0YS55ZWFycykubWFwKHBpY2soJ2FjdHVhbCBkaXNidXJzZW1lbnRzJykpXG4gICAgICB9XG4gICAgXTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIENoYXJ0TW9kZWwgPSByZXF1aXJlKCcuL2NoYXJ0LW1vZGVsLWJhc2UnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jaGFydHMvY29tbW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhcnRNb2RlbC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7XG4gICAgdHlwZWQ6IHRydWUsXG4gICAgbGltaXQ6IDMsXG4gICAgdGl0bGU6ICcnXG4gIH0sXG5cbiAgX3ByZXBhcmVUcmFuc2xhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZnR5cGVCYXNlTGFuZ3VhZ2UgPSB7fTtcblxuICAgIC8qIFByZXBhcmUgdGhlIHRyYW5zbGF0aW9ucyBmb3IgdGhlIGNoYXJ0ICovXG4gICAgdmFyIGNoYXJ0TmFtZSA9IFsnYW1wLmRhc2hib2FyZDpjaGFydC0nLCB0aGlzLmdldCgnbmFtZScpLnJlcGxhY2UoLyAvZywgJycpLCAnLSddLmpvaW4oJycpO1xuXG4gICAgLypcbiAgICAgKiBUT0RPOiBsb2FkIGFsbCB0aGUgbG9jYWxpemF0aW9ucyBpbiB0aGlzIGNoYXJ0J3MgbmFtZXNwYWNlIHRvIHRoaXMgYXJyYXlcbiAgICAgKiBmcm9tIGluaXRpYWwtdHJhbnNsYXRpb24tcmVxdWVzdC5qc29uIC0tIEZvciBub3cganVzdCBoYXJkY29kZSB0aGUgdHdvIHNvcnRzLlxuICAgICAqL1xuICAgIGlmICh0aGlzLmdldCgnbmFtZScpID09PSAnRnVuZGluZyBUeXBlJykge1xuICAgICAgZnR5cGVCYXNlTGFuZ3VhZ2VbY2hhcnROYW1lICsgJ0dyYW50J10gPSAnR3JhbnQnO1xuICAgICAgZnR5cGVCYXNlTGFuZ3VhZ2VbY2hhcnROYW1lICsgJ0xvYW4nXSA9ICdMb2FuJztcbiAgICAgIGZ0eXBlQmFzZUxhbmd1YWdlW2NoYXJ0TmFtZSArICdvdGhlcnMnXSA9ICdPdGhlcnMnO1xuICAgIH1cblxuICAgIHRoaXMubG9jYWxpemVkRlR5cGUgPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZUxpc3QoZnR5cGVCYXNlTGFuZ3VhZ2UpLnRoZW4oXG4gICAgICBmdW5jdGlvbihsb2NhbGl6ZWRLZXlWYWwpIHtcbiAgICAgICAgc2VsZi5sb2NhbGl6ZWRMb29rdXAgPSBsb2NhbGl6ZWRLZXlWYWw7XG4gICAgICB9KTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnNldCgndGl0bGUnLCBkYXRhLnRpdGxlKTtcblx0XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB5ZWFycztcbiAgICBpZiAoZGF0YS52YWx1ZXMubGVuZ3RoID4gMCAmJiAhaXNOYU4ocGFyc2VJbnQoKGRhdGEudmFsdWVzKVswXS5ZZWFyLCAxMCkpKSB7XG4gICAgICB5ZWFycyA9IF8uc29ydEJ5KGRhdGEudmFsdWVzLCBmdW5jdGlvbihvYmopIHsgcmV0dXJuIHBhcnNlSW50KG9iai5ZZWFyLCAxMCk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ZWFycyA9IF8oZGF0YS52YWx1ZXMpLnNvcnRCeSgnWWVhcicpO1xuICAgIH1cblxuICAgIHZhciBjaGFydE5hbWUgPSBbJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtJywgdGhpcy5nZXQoJ25hbWUnKS5yZXBsYWNlKC8gL2csICcnKSwgJy0nXS5qb2luKCcnKTtcbiAgICB2YXIgbG9jYWxpemVkT3RoZXJzID0gc2VsZi5sb2NhbGl6ZWRMb29rdXBbY2hhcnROYW1lICsgJ290aGVycyddO1xuXG4gICAgLy8gcmVmb3JtYXQgdGhlIGRhdGEgZm9yIG52ZDNcbiAgICBkYXRhLnByb2Nlc3NlZCA9IF8oeWVhcnMpXG4gICAgICAuY2hhaW4oKVxuICAgICAgLnJlZHVjZShmdW5jdGlvbihzZXJpZXMsIHllYXIpIHtcbiAgICAgICAgc2VyaWVzLnB1c2guYXBwbHkoc2VyaWVzLCBfKHllYXIudmFsdWVzKS5wbHVjaygndHlwZScpKTtcbiAgICAgICAgcmV0dXJuIHNlcmllcztcbiAgICAgIH0sIFtdKVxuICAgICAgLnVuaXEoKVxuICAgICAgLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciBjbGVhbk5hbWUgPSBzLnJlcGxhY2UoL1sgOi5dL2csICcnKTtcbiAgICAgICAgdmFyIGxvY2FsaXplZE5hbWUgPSBzO1xuICAgICAgICBpZiAoc2VsZi5sb2NhbGl6ZWRMb29rdXBbY2hhcnROYW1lICsgY2xlYW5OYW1lXSkge1xuICAgICAgICAgIGxvY2FsaXplZE5hbWUgPSBzZWxmLmxvY2FsaXplZExvb2t1cFtjaGFydE5hbWUgKyBjbGVhbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5OiBsb2NhbGl6ZWROYW1lLFxuICAgICAgICAgIHZhbHVlczogXyh5ZWFycykubWFwKGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyVmFsdWUgPSBfKHkudmFsdWVzKS5maW5kV2hlcmUoe3R5cGU6IHN9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6IHkuWWVhcixcbiAgICAgICAgICAgICAgeTogeWVhclZhbHVlICYmIHllYXJWYWx1ZS5hbW91bnQgfHwgMCxcbiAgICAgICAgICAgICAgejogeWVhclZhbHVlICYmIHllYXJWYWx1ZS5mb3JtYXR0ZWRBbW91bnQgfHwgMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgICAudmFsdWUoKTtcblxuICAgIC8vIGdyb3VwIHNtYWxsZXN0IGNvbnRyaWJ1dG9ycyBhcyBcIm90aGVyXCJzXG4gICAgaWYgKHRoaXMuZ2V0KCdsaW1pdCcpIDwgZGF0YS5wcm9jZXNzZWQubGVuZ3RoKSB7XG4gICAgICB2YXIgb3RoZXJzTmFtZXMgPSBfKGRhdGEucHJvY2Vzc2VkKVxuICAgICAgICAuY2hhaW4oKVxuICAgICAgICAubWFwKGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICB0b3RhbDogXyhzZXJpZXMudmFsdWVzKS5yZWR1Y2UoZnVuY3Rpb24odCwgdikgeyByZXR1cm4gdCArIHYueTsgfSwgMClcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAuc29ydEJ5KCd0b3RhbCcpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLnJlc3QodGhpcy5nZXQoJ2xpbWl0JykgLSAyKSAgLy8gMSBmb3IgLmxlbmd0aCBvZmZzZXQsIDEgZm9yIC5yZXN0IG9mZnNldFxuICAgICAgICAucGx1Y2soJ2tleScpXG4gICAgICAgIC52YWx1ZSgpO1xuXG4gICAgICB2YXIgb3RoZXJzU2VyaWVzID0ge1xuICAgICAgICBrZXk6IGxvY2FsaXplZE90aGVycyxcbiAgICAgICAgY29sb3I6ICcjNzc3JyxcbiAgICAgICAgc3BlY2lhbDogJ290aGVycycsXG4gICAgICAgIHZhbHVlczogXyhkYXRhLnByb2Nlc3NlZClcbiAgICAgICAgICAuY2hhaW4oKVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oc2VyaWVzKSB7IHJldHVybiBfKG90aGVyc05hbWVzKS5jb250YWlucyhzZXJpZXMua2V5KTsgfSlcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uKHNlcmllcykgeyByZXR1cm4gc2VyaWVzLnZhbHVlczsgfSlcbiAgICAgICAgICAudHJhbnNwb3NlKClcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uKG90aGVyc1llYXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6IG90aGVyc1llYXJbMF0ueCxcbiAgICAgICAgICAgICAgeTogXyhvdGhlcnNZZWFyKS5yZWR1Y2UoZnVuY3Rpb24odCwgcykgeyByZXR1cm4gdCArIHMueTsgfSwgMCksXG4gICAgICAgICAgICAgIHo6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIFx0ICByZXR1cm4ge1xuICAgICAgICBcdFx0ICB4OiBpdGVtLngsXG4gICAgICAgIFx0XHQgIHk6IGl0ZW0ueSxcbiAgICAgICAgXHRcdCAgejogY29tbW9uLmZvcm1hdE51bWJlcihpdGVtLnkgLyoqIHBhcnNlRmxvYXQoYXBwLnNldHRpbmdzLm51bWJlck11bHRpcGxpZXIubmFtZSkqLylcbiAgICAgICAgXHQgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudmFsdWUoKVxuICAgICAgfTtcbiAgICAgIGRhdGEucHJvY2Vzc2VkID0gZGF0YS5wcm9jZXNzZWQuc2xpY2UoMCwgdGhpcy5nZXQoJ2xpbWl0JykpO1xuICAgICAgZGF0YS5wcm9jZXNzZWQucHVzaChvdGhlcnNTZXJpZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLk1vZGVsLmV4dGVuZCh7XG5cbiAgZGVmYXVsdHM6IHt9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsO1xuICAgIHRoaXMuX3ByZXBhcmVUcmFuc2xhdGlvbnMoKTsgIC8vIFRPRE86IHJlZmFjdG9yIHRoaXMgaW1wbGVtZW50YXRpb24gaW50byBoZXJlXG4gIH0sXG5cbiAgaGFzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8odGhpcy5nZXQoJ3Byb2Nlc3NlZCcpKVxuICAgICAgLmNoYWluKClcbiAgICAgIC5wbHVjaygndmFsdWVzJylcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggJiYgdHJ1ZSB8fCByZXN1bHQ7XG4gICAgICB9LCBmYWxzZSlcbiAgICAgIC52YWx1ZSgpO1xuICB9LFxuXG4gIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKG9wdGlvbnMuZGF0YSk7XG4gICAgZGF0YS5zZXR0aW5ncyA9IHRoaXMuYXBwLnNldHRpbmdzLnRvQVBJKCk7XG5cbiAgICBpZiAodGhpcy5nZXQoJ2FkanR5cGUnKSkge1xuICAgICAgLy8gVE9ETyBhZGp0eXBlIGhhcmQtY29kaW5nIGtleSBmb3Igbm93LCBzaG91bGQgZ2V0IGZyb20gc2V0dGluZ3MuLi5cbiAgICAgIGRhdGEuc2V0dGluZ3MgPSBfKHt9KS5leHRlbmQoZGF0YS5zZXR0aW5ncywgezA6IHRoaXMuZ2V0KCdhZGp0eXBlJyl9KTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmRhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICByZXR1cm4gQmFja2JvbmVEYXNoLk1vZGVsLnByb3RvdHlwZS5mZXRjaC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbn0pO1xuIiwidmFyIHBhcmFtID0gcmVxdWlyZSgnanF1ZXJ5JykucGFyYW07XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBDaGFydE1vZGVsID0gcmVxdWlyZSgnLi9jaGFydC1tb2RlbC1iYXNlJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY2hhcnRzL2NvbW1vbicpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhcnRNb2RlbC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7XG4gICAgbGltaXQ6IDUsXG4gICAgdGl0bGU6ICcnXG4gIH0sXG5cbiAgX3ByZXBhcmVUcmFuc2xhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b3BCYXNlTGFuZ3VhZ2UgPSB7fTtcblxuICAgIHRoaXMuY2hhcnROYW1lID0gJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtJyArIHRoaXMuZ2V0KCduYW1lJykucmVwbGFjZSgvIC9nLCAnJyk7XG5cbiAgICAvKlxuICAgICAqIFRPRE86IGxvYWQgYWxsIHRoZSBsb2NhbGl6YXRpb25zIGluIHRoaXMgY2hhcnQncyBuYW1lc3BhY2UgdG8gdGhpcyBhcnJheVxuICAgICAqIGZyb20gaW5pdGlhbC10cmFuc2xhdGlvbi1yZXF1ZXN0Lmpzb24gLS0gRm9yIG5vdyBqdXN0IGhhcmRjb2RlIHRoZSB0d28gc29ydHMuXG4gICAgICovXG4gICAgaWYgKHRoaXMuZ2V0KCduYW1lJykgPT09ICdUb3AgUmVnaW9ucycpIHtcbiAgICAgIHRvcEJhc2VMYW5ndWFnZVt0aGlzLmNoYXJ0TmFtZSArICctRGlzdHJpY3RVbmRlZmluZWQnXSA9ICdEaXN0cmljdHM6IFVuZGVmaW5lZCc7XG4gICAgfVxuICAgIHRvcEJhc2VMYW5ndWFnZVt0aGlzLmNoYXJ0TmFtZSArICctb3RoZXJzJ10gPSAnT3RoZXJzJztcblxuICAgIHRoaXMubG9jYWxpemVkVG9wQ2hhcnQgPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZUxpc3QodG9wQmFzZUxhbmd1YWdlKVxuICAgICAgLmRvbmUoXyhmdW5jdGlvbihsb2NhbGl6ZWRUb3BDaGFydEtleVZhbCkge1xuICAgICAgICB0aGlzLmxvY2FsaXplZExvb2t1cCA9IGxvY2FsaXplZFRvcENoYXJ0S2V5VmFsO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5zZXQoJ3RpdGxlJywgZGF0YS50aXRsZSk7XG5cdCAgXG4gICAgaWYgKCF0aGlzLmxvY2FsaXplZExvb2t1cCkge1xuICAgICAgLy8gd2UgY2FuJ3QgcHJvY2VkZSBpZiB3ZSBkb24ndCBoYXZlIHRyYW5zbGF0aW9ucyB5ZXQgOihcbiAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgbm93IGJlIHVucmVhY2hhYmxlLCBidXQgeSduZXZlciBrbm93Li4uXG4gICAgICB0aGlzLmFwcC5yZXBvcnQoJ0xvYWRpbmcgZXJyb3InLCBbXG4gICAgICAnVHJhbnNsYXRpb25zIGZvciB0aGUgYXBwbGljYXRpb24gd2VyZSBub3QgbG9hZGVkIGJlZm9yZSByZW5kZXJpbmcnXSk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2NhbGl6ZWRPdGhlcnMgPSB0aGlzLmxvY2FsaXplZExvb2t1cFt0aGlzLmNoYXJ0TmFtZSArICctb3RoZXJzJ107XG4gICAgaWYgKHRoaXMubG9jYWxpemVkT3RoZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICBcdGNvbnNvbGUuZXJyb3IoJ21pc3NpbmcgdHJhbnNsYXRpb24gaW4gLmpzb24gZmlsZTogJyArIHRoaXMuY2hhcnROYW1lICsgJy1vdGhlcnMnKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gXyhkYXRhLnZhbHVlcy5zbGljZSgpKS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgdmFyIGNsZWFuTmFtZSA9IHYubmFtZS5yZXBsYWNlKC9bIDouXS9nLCAnJyk7XG4gICAgICB2YXIgbG9jYWxpemVkTmFtZSA9IHRoaXMubG9jYWxpemVkTG9va3VwW3RoaXMuY2hhcnROYW1lICsgJy0nICsgY2xlYW5OYW1lXSB8fCB2Lm5hbWU7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxvY2FsaXplZE5hbWUsXG4gICAgICAgIHk6IHYuYW1vdW50LFxuICAgICAgICB6OiB2LmZvcm1hdHRlZEFtb3VudCxcbiAgICAgICAgaWQ6IHYuaWRcbiAgICAgIH07XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoZGF0YS5tYXhMaW1pdCA+IHZhbHVlcy5sZW5ndGgpIHtcbiAgICBcdHZhciBvdGhlciA9IHtcbiAgICBcdFx0eDogdGhpcy5sb2NhbGl6ZWRPdGhlcnMsXG4gICAgXHQgICAgeTogZGF0YS50b3RhbCAtICAvLyB0b3RhbCBtaW51cyB0aGUgc3VtIG9mIHdoYXQgd2UgaGF2ZVxuICAgIFx0ICAgIFx0Xy5jaGFpbih2YWx1ZXMpLnBsdWNrKCd5JykucmVkdWNlKGZ1bmN0aW9uKGwsIHIpIHsgcmV0dXJuIGwgKyByOyB9LCAwKS52YWx1ZSgpLFxuICAgIFx0ICAgIGNvbG9yOiAnIzc3NycsXG4gICAgXHQgICAgc3BlY2lhbDogJ290aGVycydcbiAgICBcdH07XG4gICAgXHQvL0FNUC0xODc0MDogV2UgY2hhbmdlZCB0aGUgRVAgdG8gc2VuZCByYXcgbnVtYmVycyBleHByZXNzZWQgaW4gdW5pdHMgc28gd2UgbmVlZCB0byBhcHBseSB0aGUgR1MgaGVyZS5cbiAgICBcdG90aGVyLnogPSBjb21tb24uZm9ybWF0TnVtYmVyKG90aGVyLnkgKiBwYXJzZUZsb2F0KGFwcC5zZXR0aW5ncy5udW1iZXJNdWx0aXBsaWVyLm5hbWUpKTtcbiAgICBcdHZhbHVlcy5wdXNoKG90aGVyKTtcbiAgICB9XG5cbiAgICBkYXRhLnByb2Nlc3NlZCA9IFt7dmFsdWVzOiB2YWx1ZXN9XTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcblxuICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKFxuICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgIHsgdXJsOiB0aGlzLnVybCArICc/JyArIHBhcmFtKHRoaXMucGljaygnbGltaXQnKSkgfSk7XG4gICAgcmV0dXJuIENoYXJ0TW9kZWwucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgfVxufSk7XG4iLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxuXHJcbnZhciBFbmFibGVkQ2hhcnRNb2RlbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XHJcblxyXG59KTtcclxuXHJcbnZhciBFbmFibGVkQ2hhcnRzQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcclxuXHRtb2RlbCA6IEVuYWJsZWRDaGFydE1vZGVsLFxyXG5cdHVybCA6ICcvcmVzdC9jb21tb24vZm0nLFxyXG5cdGZldGNoRGF0YSA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHBhcmFtcyA9IHtcclxuXHRcdFx0XCJkZXRhaWwtbW9kdWxlc1wiIDogWyBcIkRBU0hCT0FSRFNcIiBdXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5mZXRjaCh7XHJcblx0XHRcdHR5cGUgOiAnUE9TVCcsXHJcblx0XHRcdGFzeW5jIDogZmFsc2UsXHJcblx0XHRcdHByb2Nlc3NEYXRhIDogZmFsc2UsXHJcblx0XHRcdG1pbWVUeXBlIDogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG5cdFx0XHR0cmFkaXRpb25hbCA6IHRydWUsXHJcblx0XHRcdGhlYWRlcnMgOiB7XHJcblx0XHRcdFx0J0NvbnRlbnQtVHlwZScgOiAnYXBwbGljYXRpb24vanNvbicsXHJcblx0XHRcdFx0J0NhY2hlLUNvbnRyb2wnIDogJ25vLWNhY2hlJ1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRkYXRhIDogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSwgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZHVlIHRvXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBpbmNvbXBhdGliaWxpdGllcyB3aXRoIEplcnNleVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gd2hlbiByZWNlaXZpbmcgdGhlIHBhcmFtcy5cclxuXHRcdFx0ZXJyb3IgOiBmdW5jdGlvbihjb2xsZWN0aW9uLCByZXNwb25zZSkge1xyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ2Vycm9yIGxvYWRpbmcgY2hhcnRzLicpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRzdWNjZXNzIDogZnVuY3Rpb24oY29sbGVjdGlvbiwgcmVzcG9uc2UpIHtcclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVuYWJsZWRDaGFydHNDb2xsZWN0aW9uOyIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcblxuXG52YXIgQVBJX0lEX0tFWSA9ICdtYXBJZCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZURhc2guTW9kZWwuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICBkZXNjcmlwdGlvbjogdW5kZWZpbmVkLFxuICAgIHN0YXRlQmxvYjogdW5kZWZpbmVkXG4gIH0sXG5cbiAgLy8gcGFyc2UgYW5kIHRvSlNPTiBtYXAgdGhlIGlkIGZpZWxkIHRvIG1hcElkIGZvciB0aGUgQVBJLlxuICBwYXJzZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKF8ob2JqKS5oYXMoQVBJX0lEX0tFWSkpIHtcbiAgICAgIG9iai5pZCA9IG9ialtBUElfSURfS0VZXTtcbiAgICAgIGRlbGV0ZSBvYmpbQVBJX0lEX0tFWV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmw7XG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29weSA9IEJhY2tib25lRGFzaC5Nb2RlbC5wcm90b3R5cGUudG9KU09OLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKF8oY29weSkuaGFzKCdpZCcpKSB7XG4gICAgICBjb3B5W0FQSV9JRF9LRVldID0gY29weS5pZDtcbiAgICAgIGRlbGV0ZSBjb3B5LmlkO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfVxuXG59LCB7XG4gIGZyb21JZDogZnVuY3Rpb24oaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoeyBpZDogaWQgfSwgb3B0aW9ucyk7XG4gIH1cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgRGVmZXJyZWQgPSByZXF1aXJlKCdqcXVlcnknKS5EZWZlcnJlZDtcbnZhciBCYWNrYm9uZURhc2ggPSByZXF1aXJlKCcuLi9iYWNrYm9uZS1kYXNoJyk7XG52YXIgU2F2ZWRDaGFydCA9IHJlcXVpcmUoJy4vc2F2ZWQtZGFzaCcpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLkNvbGxlY3Rpb24uZXh0ZW5kKHtcblxuICB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvc2F2ZWQtY2hhcnRzJyxcblxuICBtb2RlbDogU2F2ZWRDaGFydCxcbiAgdGltZXI6IHVuZGVmaW5lZCxcbiAgaW5pdGlhbGl6ZWRPbmNlOiBmYWxzZSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICB9LFxuXG4gIGxvYWQ6IGZ1bmN0aW9uKHN0YXRlSWQpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRpZiAoc2VsZi5pbml0aWFsaXplZE9uY2UgIT09IGZhbHNlKSB7IHJldHVybjsgfVxuXHRzZWxmLmluaXRpYWxpemVkT25jZSA9IHRydWU7XG5cdCBcblx0Ly9jb25zb2xlLmxvZygnbG9hZCBzYXZlZCBkYXNoYm9hcmQ6ICcgKyBzdGF0ZUlkKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICB2YXIgbG9hZGVkID0gdGhpcy5nZXQoc3RhdGVJZCk7XG4gICAgaWYgKGxvYWRlZCkge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZShsb2FkZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsLmZyb21JZChzdGF0ZUlkLCB7IGFwcDogdGhpcy5hcHAgfSk7XG4gICAgICB0aGlzLmFkZChtb2RlbCk7ICAvLyBzZXRzIHVwIGNvbGxlY3Rpb24gc28gdGhlIG1vZGVsIGNhbiBmaW5kIGEgVVJMXG4gICAgICBtb2RlbC5mZXRjaCgpLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShtb2RlbCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQU1QLTE5ODAzIGFuZCBBTVAtMjAyMDY6IEhlcmUgd2Ugd2FpdCB1bnRpbCB0aGUgZmlsdGVyIHdpZGdldCBoYXMgYmVlbiBsb2FkZWQgdG8gdHJpZ2dlciB0aGUgJ2FwcGx5JyBldmVudCBhbmQgZm9yY2UgZWFjaCBjaGFydCB0byByZWRyYXcgd2l0aCB0aGUgc2F2ZWQgZmlsdGVycy5cblx0ICAgICAgLy8gVHJpZWQgdG8gZG8gc29tZXRoaW5nIHNpbWlsYXIgYmVmb3JlIHdlIHJlYWNoIHRoaXMgc3RhZ2UgKGllOiBpbiBhcHAtY2xhc3MuanMsIGNoYXJ0LXZpZXctYmFzZS5qcywgY2hhcnRzLmpzLCBldGMpIGJ1dCB3aXRob3V0IGx1Y2sgYmVjYXVzZSB0aGUgcmVuZGVyIGlzIHRyaWdnZXJlZCBhdXRvbWF0aWNhbGx5LlxuXHQgICAgICAvLyBUT0RPOiBXZSBuZWVkIG1vcmUgdGltZSB0byBldmFsdWF0ZSBhIHNvbHV0aW9uIHVzaW5nIHRoaXMuYXBwLmZpbHRlci5sb2FkZWQgcHJvbWlzZSBidXQgdGhhdCBkaWRudCB3b3JrIGNvbnNpc3RlbnRseSBvbiBJRS4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHNlbGYudGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBcdCAgc2VsZi50aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuXHRcdCAgICBcdCAgaWYgKHRoaXMuYXBwICE9PSB1bmRlZmluZWQgJiYgdGhpcy5hcHAuZmlsdGVyICE9PSB1bmRlZmluZWQgJiYgdGhpcy5hcHAuZmlsdGVyLmZpbmlzaGVkRmlyc3RMb2FkID09PSB0cnVlKSB7XG5cdFx0ICAgIFx0XHQgIGNsZWFySW50ZXJ2YWwoc2VsZi50aW1lcik7XG5cdFx0ICAgIFx0XHQgIHRoaXMuYXBwLmZpbHRlci50cmlnZ2VyKCdhcHBseScpO1x0XHRcdCAgICBcdFx0ICBcblx0XHQgICAgXHRcdCAgLy8gT25seSBtYWtlIDEgcmVuZGVyIGNhbGwgdG8gdGhlIG1haW4gYXBwIHZpZXcsIHRoaXMgd2lsbCBwcmV2ZW50IG90aGVyIGJ1Z3MgKGllOiB0aGUgZG91YmxlIGFuZCB0cmlwbGUgY2hhcnQgcmVuZGVyaW5nKS5cblx0XHQgICAgXHRcdCAgaWYgKHRoaXMuYXBwLnJlbmRlcmVkID09PSBmYWxzZSkge1xuXHRcdCAgICBcdFx0XHQgIHRoaXMuYXBwLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHQgICAgXHRcdFx0ICBhcHAucmVuZGVyKCk7XG5cdFx0ICAgIFx0XHQgIH1cblx0XHQgICAgXHQgIH1cblx0XHQgICAgICB9LCAxMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuZmFpbChfKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuYXBwLnJlcG9ydCgnRmFpbGVkIHRvIGxvYWQgc2F2ZWQgZGFzaGJvYXJkJywgWydDb3VsZCBub3QgcmV0cmlldmUgdGhlIHNhdmVkIHN0YXRlLiddKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgIH1cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLk1vZGVsLmV4dGVuZCh7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmw7XG4gIH0sXG5cbiAgc2VsZWN0OiBmdW5jdGlvbihvcHRpb25JZCkge1xuICAgIC8vIHVuc2VsZWN0IG9sZFxuICAgIHZhciBvbGQgPSBfKHRoaXMuYXR0cmlidXRlcy5vcHRpb25zKS5maW5kV2hlcmUoe3NlbGVjdGVkOiB0cnVlfSk7XG4gICAgZGVsZXRlIG9sZC5zZWxlY3RlZDtcbiAgICAvLyBzZWxlY3QgbmV3XG4gICAgdmFyIG5ld09wdCA9IF8odGhpcy5hdHRyaWJ1dGVzLm9wdGlvbnMpLmZpbmRXaGVyZSh7aWQ6IG9wdGlvbklkfSk7XG4gICAgbmV3T3B0LnNlbGVjdGVkID0gdHJ1ZTtcblxuICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7ICAvLyBzb3J0IG9mIGEgaGFjayB0byBkbyB0aGlzIG1hbnVhbGx5Li4uXG4gIH1cblxufSk7XG4iLCJ2YXIgRGVmZXJyZWQgPSByZXF1aXJlKCdqcXVlcnknKS5EZWZlcnJlZDtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcbnZhciBTZXR0aW5nID0gcmVxdWlyZSgnLi9zZXR0aW5nJyk7XG5cblxuZnVuY3Rpb24gaXNJbnRTdHIobikge1xuICAvLyB0ZXN0IHdoZXRoZXIgYSBzdHJpbmcgc3RhcnRzIHdpdGggaXMgYSBiYXNlLTEwIGludFxuICByZXR1cm4gIWlzTmFOKHBhcnNlSW50KG4sIDEwKSk7XG59XG5cblxuZnVuY3Rpb24gdGFnSWYodGVzdCwgdGFnKSB7XG4gIHJldHVybiBmdW5jdGlvbihzZXR0aW5nKSB7XG4gICAgaWYgKHRlc3Qoc2V0dGluZykpIHtcbiAgICAgIHNldHRpbmdbdGFnXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzZXR0aW5nO1xuICB9O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLkNvbGxlY3Rpb24uZXh0ZW5kKHtcblxuICB1cmw6ICcvcmVzdC9hbXAvc2V0dGluZ3MnLFxuXG4gIG1vZGVsOiBTZXR0aW5nLFxuXG4gIGNvbXBhcmF0b3I6ICdpZCcsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgICB0aGlzLl9sb2FkZWQgPSBudWxsO1xuICAgIF8uYmluZEFsbCh0aGlzLCAndG9BUEknLCAnZnJvbVN0YXRlJyk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKHNldHRpbmdzKSB7XG5cdHRoaXMuZXh0cmFjdE51bWJlckZvcm1hdFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICByZXR1cm4gXyhzZXR0aW5ncykuY2hhaW4oKVxuICAgICAgLy8gbWFyayB3ZWlyZCBvcHRpb25zIHdpdGggbm9uLWludCBrZXlzIGhpZGRlblxuICAgICAgLm1hcCh0YWdJZihmdW5jdGlvbihzZXR0aW5nKSB7IHJldHVybiAhaXNJbnRTdHIoc2V0dGluZy5pZCk7IH0sICdpZ25vcmUnKSlcbiAgICAgIC8vIG1hcmsgZnVuZGluZyB0eXBlIHNldHRpbmcgaGlkZGVuLCBzaW5jZSBpdCdzIHNldCBwZXItY2hhcnQuLi5cbiAgICAgIC5tYXAodGFnSWYoZnVuY3Rpb24oc2V0dGluZykgeyByZXR1cm4gc2V0dGluZy5pZCA9PT0gJzAnOyB9LCAnaWdub3JlJykpXG4gICAgICAvLyAuLi5idXQgYWxzbyBmbGFnIGl0IHNvIHRoZSBjaGFydHMgY2FuIHNlZSB0aGUgdGhlIGZ1bmRpbmcgdHlwZSBvcHRpb25zXG4gICAgICAubWFwKHRhZ0lmKGZ1bmN0aW9uKHNldHRpbmcpIHsgcmV0dXJuIHNldHRpbmcuaWQgPT09ICcwJzsgfSwgJ2Z0eXBlJykpXG4gICAgICAvLyBtYXJrIGFsbCBvcHRpb25zIGFzIHNlbGVjdGVkIHBlciB0aGUgZGVmYXVsdHMgcHJvdmlkZWRcbiAgICAgIC5tYXAoZnVuY3Rpb24oc2V0dGluZykge1xuICAgICAgICByZXR1cm4gXyhzZXR0aW5nKS5leHRlbmQoe1xuICAgICAgICAgIG9wdGlvbnM6IF8oc2V0dGluZy5vcHRpb25zKS5tYXAodGFnSWYoZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLmlkID09PSBzZXR0aW5nLmRlZmF1bHRJZDtcbiAgICAgICAgICB9LCAnc2VsZWN0ZWQnKSlcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLnZhbHVlKCk7XG4gIH0sXG5cbiAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xvYWRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZC5wcm9taXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvYWRlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIH1cblxuICAgIHRoaXMuZmV0Y2goe2FwcDogdGhpcy5hcHAgfSlcbiAgICAgIC50aGVuKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2xvYWRlZC5yZXNvbHZlKCk7XG4gICAgICB9KS5iaW5kKHRoaXMpKVxuICAgICAgLmZhaWwoXyhmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5hcHAucmVwb3J0KCdGYWlsZWQgdG8gbG9hZCBkYXNoYm9hcmQgc2V0dGluZ3MnLFxuICAgICAgICAgIFsnQ291bGQgbm90IGNvbm5lY3QgdG8gdGhlIHNlcnZlci4nXSk7XG4gICAgICAgIHRoaXMuX2xvYWRlZC5yZWplY3QoKTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlZC5wcm9taXNlKCk7XG4gIH0sXG5cbiAgdG9BUEk6IGZ1bmN0aW9uKG92ZXJyaWRlcykge1xuICAgIC8vIGZvcm1hdCBzZWxlY3RlZCBmaWx0ZXIgb3B0aW9ucyB0aGUgd2F5IHRoZSBhcGkgd2FudHNcbiAgICAvLyBpZ25vcmVkIGZpbHRlcnMgYXJlIHNraXBwZWQgKG92ZXJyaWRlcyBhcmUgbmV2ZXIgcmVtb3ZlZCB0aG91Z2gpXG4gICAgLy8gb3ZlcnJpZGVzIHNob3VsZCBiZSBpbiB0aGUge3NldHRpbmdJZDogc2V0dGluZ09wdGlvbklkfSBmb3JtYXQgdGhlIGFwaSBleHBlY3RzXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7IHJldHVybiB7fTsgfSAgLy8gY29wIG91dCBlYXJseSBpZiB3ZSBkb24ndCBoYXZlIHNldHRpbmdzIHlldFxuICAgIHJldHVybiB0aGlzLmNoYWluKClcbiAgICAgIC5tYXAoZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLnRvSlNPTigpOyB9KVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihzZXR0aW5nKSB7IHJldHVybiAhc2V0dGluZy5pZ25vcmU7IH0pXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uKGFwaUZvcm1hdHRlZCwgc2V0dGluZykge1xuICAgICAgICBhcGlGb3JtYXR0ZWRbc2V0dGluZy5pZF0gPSBfKHNldHRpbmcub3B0aW9ucylcbiAgICAgICAgICAuZmluZFdoZXJlKHtzZWxlY3RlZDogdHJ1ZX0pLmlkO1xuICAgICAgICByZXR1cm4gYXBpRm9ybWF0dGVkO1xuICAgICAgfSwge30pXG4gICAgICAuZXh0ZW5kKG92ZXJyaWRlcyB8fCB7fSlcbiAgICAgIC52YWx1ZSgpO1xuICB9LFxuXG4gIGZyb21TdGF0ZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAvLyBzZWxlY3Qgb3B0aW9ucyBmcm9tIGFuIGFycmF5IHdpdGggdGhlIHNhbWUgZm9ybWF0IHdlIHNlbmQgdG8gdGhlIGFwaVxuICAgIF8oc3RhdGUpLmVhY2goZnVuY3Rpb24ob3B0SWQsIHNldHRpbmdJZCkge1xuICAgICAgdGhpcy5nZXQoc2V0dGluZ0lkKS5zZWxlY3Qob3B0SWQpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIGdldFZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihzZXR0aW5nKSB7IHJldHVybiAhc2V0dGluZy5nZXQoJ2lnbm9yZScpOyB9KTtcbiAgfSxcbiAgXG4gIGV4dHJhY3ROdW1iZXJGb3JtYXRTZXR0aW5nczogZnVuY3Rpb24oc2V0dGluZ3MpIHtcblx0ICB2YXIgbnVtYmVyRm9ybWF0ID0ge307IFxuXHQgIHZhciBmb3VuZE5GID1fLmZpbmQoc2V0dGluZ3MsIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbS5pZCA9PT0gJ251bWJlci1mb3JtYXQnfSk7XG5cdCAgbnVtYmVyRm9ybWF0Lm51bWJlckZvcm1hdCA9IF8uZmluZChmb3VuZE5GLm9wdGlvbnMsIGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uaWQgPT09IGZvdW5kTkYuZGVmYXVsdElkfSkubmFtZSB8fCAnIywjLiMnO1xuXG5cdCAgLy8gSWYgdGhlIGZvcm1hdCBwYXR0ZXJuIGRvZXNudCBoYXZlIHRob3VzYW5kcyBncm91cGluZyB0aGVuIGlnbm9yZSAnbnVtYmVyLWdyb3VwLXNlcGFyYXRvcicgcGFyYW0gb3IgaXQgd2lsbCBcblx0ICAvLyBiZSB1c2VkIGJ5IEpTIHRvIGdyb3VwIGJ5IHRob3VzYW5kcyAoaWU6IGluIHRoZSAnT3RoZXJzJyBjb2x1bW5zKS5cblx0ICBpZihudW1iZXJGb3JtYXQubnVtYmVyRm9ybWF0LmluZGV4T2YoJywnKSAhPT0gLTEpIHtcblx0XHQgIHZhciBmb3VuZE5HUyA9Xy5maW5kKHNldHRpbmdzLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0uaWQgPT09ICdudW1iZXItZ3JvdXAtc2VwYXJhdG9yJ30pO1xuXHRcdCAgbnVtYmVyRm9ybWF0Lmdyb3VwU2VwYXJhdG9yID0gXy5maW5kKGZvdW5kTkdTLm9wdGlvbnMsIGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uaWQgPT09IGZvdW5kTkdTLmRlZmF1bHRJZH0pLm5hbWUgfHwgJywnO1xuXHQgIH0gZWxzZSB7XG5cdFx0ICBudW1iZXJGb3JtYXQuZ3JvdXBTZXBhcmF0b3IgPSAnJztcblx0ICB9XG5cdCAgdmFyIGZvdW5kRFMgPV8uZmluZChzZXR0aW5ncywgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLmlkID09PSAnbnVtYmVyLWRlY2ltYWwtc2VwYXJhdG9yJ30pO1xuXHQgIG51bWJlckZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yID0gXy5maW5kKGZvdW5kRFMub3B0aW9ucywgZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS5pZCA9PT0gZm91bmREUy5kZWZhdWx0SWR9KS5uYW1lIHx8ICcuJztcblx0ICB0aGlzLmFwcC5zZXR0aW5ncy5udW1iZXJGb3JtYXRTZXR0aW5ncyA9IG51bWJlckZvcm1hdDtcblx0ICBcblx0ICB2YXIgZm91bmROTSA9Xy5maW5kKHNldHRpbmdzLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0uaWQgPT09ICdudW1iZXItbXVsdGlwbGllcid9KTtcblx0ICB0aGlzLmFwcC5zZXR0aW5ncy5udW1iZXJNdWx0aXBsaWVyID0gXy5maW5kKGZvdW5kTk0ub3B0aW9ucywgZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS5pZCA9PT0gZm91bmROTS5kZWZhdWx0SWR9KTtcblx0ICBpZiAodGhpcy5hcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllci5uYW1lID09PSAnMS4wJykge1xuXHRcdCAgdGhpcy5hcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllckRlc2NyaXB0aW9uID0gJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy1pbnVuaXRzJztcblx0ICB9IGVsc2UgaWYodGhpcy5hcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllci5uYW1lID09PSAnMC4wMDEnKSB7XG5cdFx0ICB0aGlzLmFwcC5zZXR0aW5ncy5udW1iZXJNdWx0aXBsaWVyRGVzY3JpcHRpb24gPSAnYW1wLmRhc2hib2FyZDpjaGFydC10b3BzLWludGhvdXNhbmRzJztcblx0ICB9IGVsc2Uge1xuXHRcdCAgdGhpcy5hcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllckRlc2NyaXB0aW9uID0gJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy1pbm1pbGxpb25zJztcblx0ICB9XG4gIH1cblxufSk7IiwidmFyIGQzID0gcmVxdWlyZSgnZDMtYnJvd3NlcmlmeScpO1xudmFyIENoYXJ0Vmlld0Jhc2UgPSByZXF1aXJlKCcuL2NoYXJ0LXZpZXctYmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhcnRWaWV3QmFzZS5leHRlbmQoe1xuXG4gIHVpRGVmYXVsdHM6IHtcbiAgICBiaWc6IGZhbHNlLFxuICAgIHZpZXc6ICdtdWx0aWJhcidcbiAgfSxcblxuICBjaGFydFZpZXdzOiBbXG4gICAgJ211bHRpYmFyJyxcbiAgICAndGFibGUnXG4gIF0sXG5cbiAgY2hhcnRPcHRpb25zOiB7XG4gICAgbnZDb250cm9sczogZmFsc2VcbiAgfSxcblxuICBkb3dubG9hZENoYXJ0T3B0aW9uczoge1xuICAgIG52Q29udHJvbHM6IGZhbHNlLFxuICAgIHRyaW1MYWJlbHM6IGZhbHNlXG4gIH0sXG5cbiAgZ2V0VFRDb250ZW50OiBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBvZiA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOm9mXCIsXCJvZlwiKTtcbiAgdmFyIHRvdGFsID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6dG90YWxcIixcInRvdGFsXCIpO1xuICB2YXIgdW5pdHMgPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKGFwcC5zZXR0aW5ncy5udW1iZXJNdWx0aXBsaWVyRGVzY3JpcHRpb24pO1xuXG4gIC8vIElNUE9SVEFOVDogV2UgYXNzdW1lIHRoaXMgY2hhcnQgd2lsbCBBTFdBWVMgc2hvdyAyIGRhdGEgc2VyaWVzLlxuICB2YXIgaW5kZXggPSAtMTtcbiAgaWYgKGNvbnRleHQuZGF0YVswXS5kaXNhYmxlZCA9PT0gdHJ1ZSkge1xuICAgIGluZGV4ID0gMTtcbiAgfSBlbHNlIHtcbiAgICBpbmRleCA9IGNvbnRleHQuc2VyaWVzLmluZGV4O1xuICB9XG4gIHZhciBoZWFkZXIgPSBjb250ZXh0LngucmF3ICsgXCIgXCIgK1xuICAgICAgICBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDphaWQtcHJlZGljdGFiaWxpdHktXCIgK1xuICAgICAgICBjb250ZXh0LmRhdGFbaW5kZXhdLm9yaWdpbmFsS2V5ICsgXCItXCIgKyB0aGlzLm1vZGVsLmdldCgnbWVhc3VyZScpLCBcIlwiKTtcblxuICB2YXIgb3RoZXJTZXJpZXMgPSBjb250ZXh0LmRhdGFbMSAtIGluZGV4XTsgIC8vIFdBUk5JTkc6IGFzc3VtZXMgb25seSAyIHNlcmllc1xuICB2YXIgb3RoZXJIZXJlID0gb3RoZXJTZXJpZXMudmFsdWVzW2NvbnRleHQueC5pbmRleF07XG4gIHZhciBsaW5lMkFtb3VudCA9IDA7XG4gIGlmKG90aGVySGVyZS55ID4gMCkge1xuXHQgIGxpbmUyQW1vdW50ID0gY29udGV4dC55LnJhdyAvIG90aGVySGVyZS55O1xuICB9XG4gIHZhciBsaW5lMiA9ICc8Yj4nICsgZDMuZm9ybWF0KCclJykobGluZTJBbW91bnQpICtcbiAgICAgICAgJzwvYj4mbmJzcDxzcGFuPicgKyBvZiArICc8L3NwYW4+Jm5ic3AnICsgY29udGV4dC54LnJhdyArXG4gICAgICAgICcmbmJzcDxzcGFuPicgKyB0b3RhbCArICc8L3NwYW4+JztcblxuICByZXR1cm4ge3R0OiB7XG4gICAgICBoZWFkaW5nOiBoZWFkZXIsXG4gICAgICBib2R5VGV4dDogJzxiPicgKyBjb250ZXh0LnkuZm10ICsgJzwvYj4gJyArIHRoaXMubW9kZWwuZ2V0KCdjdXJyZW5jeScpICsgJyAoJyArIHVuaXRzICsgJyknLFxuICAgICAgZm9vdGVyVGV4dDogbGluZTJcbiAgICB9fTtcbiAgfVxuXG59KTtcbiIsInZhciBkMyA9IHJlcXVpcmUoJ2QzLWJyb3dzZXJpZnknKTtcbnZhciBDaGFydFZpZXdCYXNlID0gcmVxdWlyZSgnLi9jaGFydC12aWV3LWJhc2UnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXJ0Vmlld0Jhc2UuZXh0ZW5kKHtcblxuICB1aURlZmF1bHRzOiB7XG4gICAgYmlnOiB0cnVlLFxuICAgIGFkanR5cGU6ICdGQUtFJyxcbiAgICB2aWV3OiAnbXVsdGliYXInXG4gIH0sXG5cbiAgY2hhcnRWaWV3czogW1xuICAgICdtdWx0aWJhcicsXG4gICAgJ3RhYmxlJ1xuICBdLFxuXG4gIGRvd25sb2FkQ2hhcnRPcHRpb25zOiB7XG4gICAgdHJpbUxhYmVsczogZmFsc2VcbiAgfSxcblxuICBnZXRUVENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0dmFyIG9mID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6b2ZcIixcIm9mXCIpO1xuXHR2YXIgdG90YWwgPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDp0b3RhbFwiLFwidG90YWxcIik7XG5cdHZhciB1bml0cyA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoYXBwLnNldHRpbmdzLm51bWJlck11bHRpcGxpZXJEZXNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHt0dDoge1xuICAgICAgaGVhZGluZzogY29udGV4dC54LnJhdyArICcgJyArIGNvbnRleHQuc2VyaWVzLmtleSxcbiAgICAgIGJvZHlUZXh0OiAnPGI+JyArIGNvbnRleHQueS5mbXQgKyAnPC9iPiAnICsgdGhpcy5tb2RlbC5nZXQoJ2N1cnJlbmN5JykgKyAnICgnICsgdW5pdHMgKyAnKScsXG4gICAgICBmb290ZXJUZXh0OiAnPGI+JyArIGQzLmZvcm1hdCgnJScpKGNvbnRleHQueS5yYXcgLyB0aGlzLm1vZGVsLmdldCgndG90YWwnKSkgKyAnPC9iPiZuYnNwPHNwYW4+JyArIG9mICsgJzwvc3Bhbj4mbmJzcCcgKyBjb250ZXh0LngucmF3ICsgJyZuYnNwPHNwYW4+JyArIHRvdGFsICsgJzwvc3Bhbj4nXG4gICAgfX07XG4gIH0sXG5cbiAgY2hhcnRDbGlja0hhbmRsZXI6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAvLyBjbGlja2luZyBvbiB0aGUgXCJvdGhlcnNcIiBiYXIgbG9hZHMgZml2ZSBtb3JlLlxuICAgIGlmIChjb250ZXh0LmRhdGFbY29udGV4dC5zZXJpZXMuaW5kZXhdLnNwZWNpYWwgPT09ICdvdGhlcnMnKSB7XG4gICAgICB0aGlzLm1vZGVsLnNldCgnbGltaXQnLCB0aGlzLm1vZGVsLmdldCgnbGltaXQnKSArIDEpO1xuICAgIH1cbiAgfVxuXG59KTtcbiIsIlxyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcclxudmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxzY3JpcHQgdHlwZT1cXFwidGV4dC9qYXZhc2NyaXB0XFxcIj5cXG5cXHRmdW5jdGlvbiBvcGVuUHJldmlld0FjdGl2aXR5KGlkKSB7XFxuXFx0XFx0d2luZG93Lm9wZW4oJy9haW0vdmlld0FjdGl2aXR5UHJldmlldy5kb35wdWJsaWM9dHJ1ZX5wYWdlSWQ9Mn5hY3Rpdml0eUlkPScgKyBpZCwgJ19ibGFuaycpO1xcblxcdH1cXG48L3NjcmlwdD5cXG5cXG48ZGl2IGNsYXNzPSdjaGFydC10b3BzLWluZm8tY2F0ZWdvcnknPlxcblxcdDxzcGFuPlxcblxcdFxcdDxiPjwlPSAoY29udGV4dC54LmZtdCB8fCBjb250ZXh0LngucmF3KSAlPjwvYj4gLSA8JT0gbW9kZWwuZ2V0KCdhZGp0eXBlJyklPiAtICBcXHRcXHRcXG5cXHRcXHQ8c3BhbiBkYXRhLWkxOG49XFxcIjwlPSBhcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllckRlc2NyaXB0aW9uICU+XFxcIj48L3NwYW4+XFxuXFx0XFx0PCU9IG1vZGVsLmdldCgnY3VycmVuY3knKSAlPlxcblxcdDwvc3Bhbj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJjaGFydC10b3BzLWluZm8tY29udGFpbmVyXFxcIj5cXG5cXHQ8ZGl2IGNsYXNzPVxcXCJjaGFydC10b3BzLWluZm8tY29udGVudFxcXCI+XFxuXFx0XFx0PCUgaWYodmFsdWVzID09PSB1bmRlZmluZWQpIHsgJT5cXG5cXHRcXHRcXHQ8aW1nIGFsdD1cXFwiXFxcIiBzcmM9XFxcIi9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvYnVpbGQvaW1nL2xvYWRpbmctaWNvbi5naWZcXFwiPlxcblxcdFxcdFxcdDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpkb3dubG9hZC1yZW5kZXJpbmdcXFwiPlJlbmRlcmluZy4uLjwvc3Bhbj5cXG5cXHRcXHQ8JSB9IGVsc2UgeyAlPlxcblxcdFxcdFxcdDwlIHZhciByb3dDbGFzcyA9ICcnOyAlPlxcblxcdFxcdFxcdDx0YWJsZT5cXG5cXHRcXHRcXHRcXHQ8dHI+XFxuXFx0XFx0XFx0XFx0XFx0PHRoPjxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b3BzLXRhYmxlLXByb2plY3R0aXRsZVxcXCI+UHJvamVjdCBUaXRsZTwvc3Bhbj48L3RoPlxcblxcdFxcdFxcdFxcdFxcdDx0aD48c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy10YWJsZS1hbW91bnRcXFwiPkFtb3VudDwvc3Bhbj48L3RoPlxcblxcdFxcdFxcdFxcdDwvdHI+XFx0XFx0XFx0XFxuXFx0XFx0XFx0PCUgXyh2YWx1ZXMpLmVhY2goZnVuY3Rpb24ocm93LCBpKSB7ICU+XFxuICAgICAgICAgIFxcdFxcdDwlIFxcdGlmIChpICUgMiA9PT0gMCkgcm93Q2xhc3MgPSAnb2RkX3Jvdyc7XFxuICAgIFxcdFxcdFxcdFxcdGVsc2Ugcm93Q2xhc3MgPSAnJzsgJT5cXG4gICAgXFx0XFx0XFx0PHRyIGNsYXNzPVxcXCI8JT1yb3dDbGFzcyU+XFxcIj5cXG4gICAgXFx0XFx0XFx0XFx0PHRkPlxcbiAgICBcXHRcXHRcXHRcXHRcXHQ8c3BhbiBjbGFzcz0ncG9pbnRlcicgb25jbGljaz0nb3BlblByZXZpZXdBY3Rpdml0eSg8JT1yb3cuaWQlPiknPjwlPXJvdy5uYW1lJT48L3NwYW4+XFxuICAgIFxcdFxcdFxcdFxcdDwvdGQ+XFxuICAgIFxcdFxcdFxcdFxcdDx0ZD48JT1yb3cuZm9ybWF0dGVkQW1vdW50JT48L3RkPlxcbiAgICBcXHRcXHRcXHQ8L3RyPlxcbiAgICAgICAgXFx0PCUgfSkgJT5cXG4gICAgICAgIFxcdDwvdGFibGU+XFxuXFx0XFx0PCUgfSAlPlxcblxcdDwvZGl2PlxcbjwvZGl2PlwiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdFx0dGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcclxuXHRcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcclxuXHRcdHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xyXG5cdFx0dGhpcy5udW1iZXJNdWx0aXBsaWVyID0gYXBwLnNldHRpbmdzLmZpbmQoZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLmlkID09PSAnbnVtYmVyLW11bHRpcGxpZXInfSk7XHJcblx0fSxcclxuXHJcblx0cmVuZGVyOiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoe1xyXG5cdFx0XHRtb2RlbDogdGhpcy5tb2RlbCxcclxuXHRcdFx0Y29udGV4dDogdGhpcy5jb250ZXh0LFxyXG5cdFx0XHR2YWx1ZXM6IHVuZGVmaW5lZCxcclxuXHRcdFx0bnVtYmVyTXVsdGlwbGllcjogdGhpcy5udW1iZXJNdWx0aXBsaWVyXHJcblx0XHR9KSk7XHJcblx0XHRhcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00oJChcIi5kYXNoLXNldHRpbmdzLW1vZGFsXCIpKTtcclxuXHRcdFxyXG5cdFx0Ly9UT0RPOiBtb3ZlIHRoaXMgY29kZSB0byBhIG5ldyBtb2RlbCBzbyB0aGUgQVBJIGNhbGwgaXMgbWFkZSBhdXRvbWF0aWNhbGx5LlxyXG4gICAgXHR2YXIgY29uZmlnID0gdGhpcy5hcHAuZmlsdGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgXHRjb25maWcuc2V0dGluZ3MgPSB0aGlzLmFwcC5zZXR0aW5ncy50b0FQSSgpO1xyXG4gICAgXHRjb25maWcuc2V0dGluZ3NbJzAnXSA9IHRoaXMubW9kZWwuZ2V0KCdhZGp0eXBlJyk7XHJcbiAgICBcdCQuYWpheCh7XHJcbiAgICBcdFx0bWV0aG9kOiAnUE9TVCcsXHJcbiAgICBcdFx0dXJsOiBzZWxmLm1vZGVsLnVybCArICcvJyArIHRoaXMuY29udGV4dC5kYXRhWzBdLnZhbHVlc1t0aGlzLmNvbnRleHQueC5pbmRleF0uaWQsXHJcbiAgICBcdFx0ZGF0YVR5cGU6ICdqc29uJyxcclxuICAgIFx0XHRjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgXHRcdHByb2Nlc3NEYXRhOiBmYWxzZSxcclxuICAgIFx0XHRkYXRhOiBKU09OLnN0cmluZ2lmeShjb25maWcpXHJcbiAgICBcdH0pXHJcbiAgICBcdC5kb25lKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIFx0XHQvL1RPRE86IENhbiB3ZSBhdm9pZCByZS1jYWxsaW5nIHRoZSB0ZW1wbGF0ZSBieSBiaW5kaW5nIHRoZSBjaGFuZ2VzIGluIHRoZSAndmFsdWVzJyBmaWVsZD8gXHJcbiAgICBcdFx0c2VsZi4kZWwuaHRtbCh0ZW1wbGF0ZSh7XHJcbiAgICBcdFx0XHRtb2RlbDogc2VsZi5tb2RlbCxcclxuICAgIFx0XHRcdGNvbnRleHQ6IHNlbGYuY29udGV4dCxcclxuICAgIFx0XHRcdHZhbHVlczogZGF0YS52YWx1ZXMsXHJcbiAgICBcdFx0XHRudW1iZXJNdWx0aXBsaWVyOiBzZWxmLm51bWJlck11bHRpcGxpZXJcclxuICAgIFx0XHR9KSk7XHJcbiAgICBcdFx0YXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKCQoXCIuZGFzaC1zZXR0aW5ncy1tb2RhbFwiKSk7XHJcbiAgICBcdH0pO1xyXG4gICAgXHRcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG59KTsiLCJ2YXIgZDMgPSByZXF1aXJlKCdkMy1icm93c2VyaWZ5Jyk7XG52YXIgQ2hhcnRWaWV3QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnQtdmlldy1iYXNlJyk7XG52YXIgTW9kYWxWaWV3ID0gcmVxdWlyZSgnLi9jaGFydC10b3BzLWluZm8tbW9kYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFydFZpZXdCYXNlLmV4dGVuZCh7XG5cbiAgdWlEZWZhdWx0czoge1xuICAgIGFkanR5cGU6ICdGQUtFJyAgICBcbiAgfSxcbiAgXG4gIG1vZGFsVmlldzogdW5kZWZpbmVkLFxuICBcbiAgLy9Eb250IHRyeSB0byBjYWxsIGluaXRpYWxpemUgaGVyZSBiZWNhdXNlIGl0IHRocm93cyBhICdNb2R1bGUgaW5pdGlhbGl6YXRpb24gZXJyb3InIDooKFxuICAvKmluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICB0aGlzLm1vZGFsVmlldyA9IG5ldyBNb2RhbFZpZXcoeyBhcHA6IG9wdGlvbnMuYXBwLCBjb2xsZWN0aW9uOiB0aGlzLm1vZGVsLmNvbGxlY3Rpb24gfSk7XG4gIH0sKi9cblxuICBkb3dubG9hZENoYXJ0T3B0aW9uczoge1xuICAgIHRyaW1MYWJlbHM6IGZhbHNlXG4gIH0sXG5cbiAgZ2V0VFRDb250ZW50OiBmdW5jdGlvbihjb250ZXh0KSB7XG5cdHZhciBvZlRvdGFsID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6b2YtdG90YWxcIixcIm9mIHRvdGFsXCIpO1xuXHR2YXIgdW5pdHMgPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKGFwcC5zZXR0aW5ncy5udW1iZXJNdWx0aXBsaWVyRGVzY3JpcHRpb24pO1xuICAgIHJldHVybiB7dHQ6IHtcbiAgICAgIGhlYWRpbmc6IGNvbnRleHQueC5yYXcsXG4gICAgICBib2R5VGV4dDogJzxiPicgKyBjb250ZXh0LnkuZm10ICsgJzwvYj4gJyArIHRoaXMubW9kZWwuZ2V0KCdjdXJyZW5jeScpICsgJyAoJyArIHVuaXRzICsgJyknLFxuICAgICAgZm9vdGVyVGV4dDogJzxiPicgKyBkMy5mb3JtYXQoJyUnKShjb250ZXh0LnkucmF3IC8gdGhpcy5tb2RlbC5nZXQoJ3RvdGFsJykpICsgJzwvYj4mbmJzcDxzcGFuPicgKyBvZlRvdGFsICsgJzwvc3Bhbj4nXG4gICAgfX07XG4gIH0sXG5cbiAgY2hhcnRDbGlja0hhbmRsZXI6IGZ1bmN0aW9uKGNvbnRleHQpIHtcdCAgXG4gICAgLy8gY2xpY2tpbmcgb24gdGhlIFwib3RoZXJzXCIgYmFyIGxvYWRzIGZpdmUgbW9yZS5cbiAgICBpZiAoY29udGV4dC5kYXRhW2NvbnRleHQuc2VyaWVzLmluZGV4XVxuICAgICAgICAgICAgICAgLnZhbHVlc1tjb250ZXh0LnguaW5kZXhdLnNwZWNpYWwgPT09ICdvdGhlcnMnKSB7XG4gICAgICB0aGlzLm1vZGVsLnNldCgnbGltaXQnLCB0aGlzLm1vZGVsLmdldCgnbGltaXQnKSArIDUpO1xuICAgICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdsaW1pdCcpID4gMTApIHsgIC8vIGFsc28gbWFrZSB0aGUgY2hhcnQgYmlnZ2VyIGlmIGxvdHMgb2YgYmFycyBhcmUgc2hvd25cbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ2JpZycsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlbC5nZXQoJ3Nob3dDYXRlZ29yaWVzSW5mbycpID09PSB0cnVlKSB7ICAgIFx0XG4gICAgXHR0aGlzLm1vZGFsVmlldyA9IG5ldyBNb2RhbFZpZXcoeyBhcHA6IGFwcCwgY29udGV4dDogY29udGV4dCwgbW9kZWw6IHRoaXMubW9kZWwgfSk7XG4gICAgXHR0aGlzLm9wZW5JbmZvV2luZG93KCk7ICAgIFx0ICAgIFx0XG4gICAgfVxuICB9LFxuICBcbiAgb3BlbkluZm9XaW5kb3c6IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBzcGVjaWFsQ2xhc3MgPSAnZGFzaC1zZXR0aW5ncy1tb2RhbCc7XG5cdCAgdGhpcy5hcHAubW9kYWwoJ0NhdGVnb3J5IERldGFpbCcsIHtcblx0XHQgIHNwZWNpYWxDbGFzczogc3BlY2lhbENsYXNzLFxuXHQgICAgICBib2R5RWw6IHRoaXMubW9kYWxWaWV3LnJlbmRlcigpLmVsLFxuXHQgICAgICBpMThuVGl0bGU6ICdhbXAuZGFzaGJvYXJkOmRhc2hib2FyZC1jaGFydC10b3BzLWluZm8tbW9kYWwnXG5cdCAgfSk7XHQgICAgXG5cdCAgLy8gVHJhbnNsYXRlIG1vZGFsIHBvcHVwLlxuXHQgIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTSgkKFwiLlwiICsgc3BlY2lhbENsYXNzKSk7XG4gIH1cblxufSk7XG4iLCJcbnZhciBEZWZlcnJlZCA9IHJlcXVpcmUoJ2pxdWVyeScpLkRlZmVycmVkO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xudmFyIGdldENoYXJ0ID0gcmVxdWlyZSgnLi4vY2hhcnRzL2NoYXJ0Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3VnbHkvdXRpbCcpO1xudmFyIERvd25sb2FkVmlldyA9IHJlcXVpcmUoJy4vZG93bmxvYWQnKTtcbnZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMTIgPCUgaWYgKCFtb2RlbC5nZXQoJ2JpZycpKSB7ICU+Y29sLW1kLTY8JSB9IGVsc2UgeyAlPiBiaWctY2hhcnQ8JSB9ICU+XFxcIj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLWNoYXJ0XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZyBmaXgtdGl0bGUtaGVpZ2h0XFxcIj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwicHVsbC1yaWdodCBiaWctbnVtYmVyXFxcIj5cXG4gICAgICAgIDxiIGNsYXNzPVxcXCJjaGFydC10b3RhbFxcXCI+PC9iPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImNoYXJ0LWN1cnJlbmN5XFxcIj48L3NwYW4+XFxuICAgICAgPC9zcGFuPlxcbiAgICAgIDxoMiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtPCU9IG1vZGVsLmdldCgnbmFtZScpLnJlcGxhY2UoLyAvZywnJykgJT5cXFwiPjwlPSBtb2RlbC5nZXQoJ3RpdGxlJykgJT48L2gyPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY2hhcnQtY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDxoMyBjbGFzcz1cXFwiZGFzaC1jaGFydC1kaWFnbm9zdGljIHRleHQtY2VudGVyXFxcIj48L2gzPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZGFzaC1jaGFydC13cmFwXFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmsgYnRuLXhzIHB1bGwtcmlnaHQgcmVzZXRcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmVcXFwiIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1yZXNldFxcXCI+cmVzZXQgb3RoZXJzPC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1mb290ZXIgY2xlYXJmaXhcXFwiPlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwXFxcIj5cXG4gICAgICAgICAgPCUgXyh2aWV3cykuZWFjaChmdW5jdGlvbih2aWV3KSB7ICU+XFxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGRhdGEtdmlldz1cXFwiPCU9IHZpZXcgJT5cXFwiXFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJjaGFydC12aWV3IGJ0biBidG4tc20gYnRuLTwlPSAodmlldyA9PT0gbW9kZWwuZ2V0KCd2aWV3JykpID8gJ3ByaW1hcnknIDogJ2RlZmF1bHQnICU+XFxcIj5cXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLTwlPSB7XFxuICAgICAgICAgICAgICAgIGJhcjogJ3NpZ25hbCcsXFxuICAgICAgICAgICAgICAgIG11bHRpYmFyOiAnc2lnbmFsJyxcXG4gICAgICAgICAgICAgICAgcGllOiAnYWRqdXN0JyxcXG4gICAgICAgICAgICAgICAgdGFibGU6ICd0aC1saXN0J1xcbiAgICAgICAgICAgICAgfVt2aWV3XSAlPlxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8JSB9KSAlPlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXBcXFwiPlxcbiAgICAgICAgICA8YVxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0IGRvd25sb2FkXFxcIlxcbiAgICAgICAgICAgIGRvd25sb2FkPVxcXCJBTVAgPCU9IG1vZGVsLmdldCgndGl0bGUnKSAlPiAtIDwlPSAobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdICU+LnBuZ1xcXCJcXG4gICAgICAgICAgICB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2xvdWQtZG93bmxvYWRcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgPC9hPlxcbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLTwlPSBtb2RlbC5nZXQoJ2JpZycpID8gJ3ByaW1hcnknIDogJ2RlZmF1bHQnICU+IGV4cGFuZCBoaWRkZW4teHMgaGlkZGVuLXNtXFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1mdWxsc2NyZWVuXFxcIj48L3NwYW4+XFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgPC9kaXY+PCEtLSBidXR0b25zIGluIC5wdWxsLXJpZ2h0IC0tPlxcblxcbiAgICAgIDwlIGlmIChtb2RlbC5nZXQoJ2FkanR5cGUnKSkgeyAlPlxcbiAgICAgICAgPGZvcm0gY2xhc3M9XFxcImZvcm0taW5saW5lIGRhc2gtZm9ybSBkYXNoLWFkai10eXBlXFxcIiByb2xlPVxcXCJmb3JtXFxcIj5cXG4gICAgICAgICAgPHNlbGVjdCBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGxpa2UtYnRuLXNtIGZ0eXBlLW9wdGlvbnNcXFwiPlxcbiAgICAgICAgICAgIDxvcHRpb24+Li4uPC9vcHRpb24+XFxuICAgICAgICAgICAgPCEtLSBnZXRzIHBvcHVsYXRlZCBhZnRlciBzZXR0aW5ncyBsb2FkIC0tPlxcbiAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImNoZWF0LWxpbmVoZWlnaHRcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvZm9ybT5cXG4gICAgICA8JSB9ICU+XFxuXFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJleHBvcnQtbW9kYWxcXFwiPjwvZGl2PlxcbjwvZGl2PlxcblxcblwiKTtcblxuXG52YXIgYWRqT3B0VGVtcGxhdGUgPSBfLnRlbXBsYXRlKCc8b3B0aW9uIHZhbHVlPVwiPCU9b3B0LmlkJT5cIiAnICtcbiAgJzwlPSBjdXJyZW50ID8gc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiIDogXFwnXFwnICU+PjwlPW9wdC5uYW1lJT48L29wdGlvbj4nKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5WaWV3LmV4dGVuZCh7XG5cbiAgdWlEZWZhdWx0czoge1xuICAgIGJpZzogZmFsc2UsXG4gICAgdmlldzogJ2JhcidcbiAgfSxcblxuICBldmVudHM6IHtcbiAgICAnY2hhbmdlIC5kYXNoLWFkai10eXBlIHNlbGVjdCc6ICdjaGFuZ2VBZGpUeXBlJyxcbiAgICAnY2xpY2sgLnJlc2V0JzogJ3Jlc2V0TGltaXQnLFxuICAgICdjbGljayAuY2hhcnQtdmlldyc6ICdjaGFuZ2VDaGFydFZpZXcnLFxuICAgICdjbGljayAuZG93bmxvYWQnOiAnZG93bmxvYWQnLFxuICAgICdjbGljayAuZXhwYW5kJzogJ2JpZycsXG4gICAgJ2NsaWNrIC5yZXRyeSc6ICdyZW5kZXInXG4gIH0sXG5cbiAgY2hhcnRWaWV3czogW1xuICAgICdiYXInLFxuICAgICdwaWUnLFxuICAgICd0YWJsZSdcbiAgXSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgICB0aGlzLm1vZGVsLnNldCh0aGlzLnVpRGVmYXVsdHMpO1xuICAgIHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZVdhaXQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuYXBwLnNhdmVkRGFzaGVzLmxlbmd0aCkge1xuICAgICAgLy8gYSBiaXQgc2tldGNoLi4uLlxuICAgICAgdGhpcy5hcHAuc3RhdGUubG9hZFByb21pc2UuYWx3YXlzKHRoaXMuX3N0YXRlV2FpdC5yZXNvbHZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhdGVXYWl0LnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuYXBwLmZpbHRlciwgJ2FwcGx5JywgdGhpcy51cGRhdGVEYXRhKTtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuYXBwLnNldHRpbmdzLCAnY2hhbmdlJywgdGhpcy51cGRhdGVEYXRhKTtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2U6YWRqdHlwZScsIHRoaXMucmVuZGVyKTtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2U6bGltaXQnLCB0aGlzLnVwZGF0ZURhdGEpO1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZTp2aWV3JywgdGhpcy5yZW5kZXIpO1xuXG4gICAgdGhpcy5hcHAuc3RhdGUucmVnaXN0ZXIodGhpcywgJ2NoYXJ0OicgKyB0aGlzLm1vZGVsLnVybCwge1xuICAgICAgZ2V0OiBfLnBhcnRpYWwoXyh0aGlzLm1vZGVsLnBpY2spLmJpbmQodGhpcy5tb2RlbCksICdsaW1pdCcsICdhZGp0eXBlJywgJ3ZpZXcnLCAnYmlnJyksXG4gICAgICBzZXQ6IF8odGhpcy5tb2RlbC5zZXQpLmJpbmQodGhpcy5tb2RlbCksXG4gICAgICBlbXB0eTogbnVsbFxuICAgIH0pO1xuXG4gICAgXy5iaW5kQWxsKHRoaXMsICdzaG93Q2hhcnQnLCAnZmFpbExvYWRpbmcnKTtcbiAgICBpZiAodGhpcy5nZXRUVENvbnRlbnQpIHsgXy5iaW5kQWxsKHRoaXMsICdnZXRUVENvbnRlbnQnKTsgfVxuICAgIGlmICh0aGlzLmNoYXJ0Q2xpY2tIYW5kbGVyKSB7IF8uYmluZEFsbCh0aGlzLCAnY2hhcnRDbGlja0hhbmRsZXInKTsgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7ICAgIFxuICAgIHZhciByZW5kZXJPcHRpb25zID0ge1xuICAgICAgdmlld3M6IHRoaXMuY2hhcnRWaWV3cyxcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgY2hhcnQ6IHRoaXMuY2hhcnRFbCxcbiAgICAgIHV0aWw6IHV0aWxcbiAgICB9O1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUocmVuZGVyT3B0aW9ucykpO1xuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuJCgnLmRhc2gtY2hhcnQtZGlhZ25vc3RpYycpO1xuICAgIHRoaXMuY2hhcnRDb250YWluZXIgPSB0aGlzLiQoJy5kYXNoLWNoYXJ0LXdyYXAnKTtcblxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnYWRqdHlwZScpICE9PSB2b2lkIDApIHsgIC8vIHRoaXMgY2hhcnQgaGFzIGFkaiBzZXR0aW5nc1xuICAgIFx0dGhpcy5hcHAuc2V0dGluZ3MubG9hZCgpLmRvbmUoXyhmdW5jdGlvbigpIHtcbiAgICBcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgIHZhciBhZGpTZXR0aW5ncyA9IHRoaXMuYXBwLnNldHRpbmdzLmdldCgnMCcpOyAgLy8gaWQgZm9yIEZ1bmRpbmcgVHlwZVxuICAgICAgICBpZiAoIWFkalNldHRpbmdzKSB7IFxuICAgICAgICBcdHRoaXMuYXBwLnJlcG9ydCgnQ291bGQgbm90IGZpbmQgRnVuZGluZyBUeXBlIHNldHRpbmdzJyk7IFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICBcdGlmICh0aGlzLm1vZGVsLmdldCgnYWRqdHlwZScpID09PSAnRkFLRScpIHtcbiAgICAgICAgXHRcdHRoaXMubW9kZWwuc2V0KCdhZGp0eXBlJywgYWRqU2V0dGluZ3MuZ2V0KCdkZWZhdWx0SWQnKSk7XG4gICAgICAgIFx0fVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuJCgnLmZ0eXBlLW9wdGlvbnMnKS5odG1sKFxuICAgICAgICAgIF8oYWRqU2V0dGluZ3MuZ2V0KCdvcHRpb25zJykpLm1hcChmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGpPcHRUZW1wbGF0ZSh7XG4gICAgICAgICAgICAgIG9wdDogb3B0LFxuICAgICAgICAgICAgICBjdXJyZW50OiAob3B0LmlkID09PSB0aGlzLm1vZGVsLmdldCgnYWRqdHlwZScpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgKTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGVXYWl0LnN0YXRlKCkgIT09ICdwZW5kaW5nJykge1xuICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00odGhpcy5lbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdXBkYXRlRGF0YTogZnVuY3Rpb24oKSB7XG5cdGlmKHRoaXMuYXBwLnJlbmRlcmVkICE9PSB0cnVlKSB7IHJldHVybjsgfVxuICAgIGlmICghdGhpcy5yZW5kZXJlZCkgeyByZXR1cm47IH0gIC8vIHNob3J0LWNpcmN1aXQgb24gZWFybHkgZmlsdGVycyBhcHBseSBldmVudFxuICAgIGlmICh0aGlzLl9zdGF0ZVdhaXQuc3RhdGUoKSA9PT0gJ3BlbmRpbmcnIHx8ICAvLyBzaG9ydC1jaXJjdWl0IHVudGlsIHdlIGhhdmUgc3RhdGVcbiAgICAgICAgdGhpcy5hcHAuc2V0dGluZ3MubG9hZCgpLnN0YXRlKCkgPT09ICdwZW5kaW5nJykgeyAgLy8gc2hvcnQtY2lyY3VpdCB1bnRpbCB3ZSBoYXZlIHNldHRpbmdzXG4gICAgICB0aGlzLm1lc3NhZ2UuaHRtbCgnTG9hZGluZyBzYXZlZCBzZXR0aW5ncy4uLicpLmF0dHIoJ2RhdGEtaTE4bicsICdhbXAuZGFzaGJvYXJkOmNoYXJ0LWxvYWRpbmctc2F2ZWQtc2V0dGluZ3MnKTtcbiAgICAgIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTSgkKCcuY2hhcnQtY29udGFpbmVyJykpO1xuICAgICAgLy90aGlzLm1lc3NhZ2UuZmFkZUluKDEwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jaGFydENvbnRhaW5lci5lbXB0eSgpO1xuICAgIHRoaXMubWVzc2FnZS5odG1sKCc8c3BhbiBkYXRhLWkxOG49XCJhbXAuZGFzaGJvYXJkOmxvYWRpbmdcIj4uLi48L3NwYW4+JykuZmFkZUluKDEwMCk7XG5cbiAgICB0aGlzLmFwcC50cmFuc2xhdG9yLmdldFRyYW5zbGF0aW9ucygpXG4gICAgICAuZG9uZShfKGZ1bmN0aW9uKCkgeyAgLy8gZGVmZXIgaGVyZSB0byBwcmV2ZW50IGEgcmFjZSB3aXRoIHRyYW5zbGF0aW9ucyBsb2FkaW5nXG5cbiAgICAgICAgLyogVE9ETzogRG8gd2UgcmVhbGx5IHdhbnQgdG8gbG9jYWxpemUgdGhpcyBhbmQgc2xvdyB0aGluZ3M/Ki9cbiAgICAgICAgLy90aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTSh0aGlzLmVsKTtcblxuICAgICAgICB0aGlzLm1vZGVsLmZldGNoKHtcbiAgICAgICAgICB0eXBlOiAnUE9TVCcsICAvLyBUT0RPOiBtb3ZlIGZldGNoIG9wdGlvbnMgdG8gbW9kZWw/XG4gICAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkodGhpcy5hcHAuZmlsdGVyLnNlcmlhbGl6ZSgpKVxuICAgICAgICB9KVxuICAgICAgICAuYWx3YXlzKF8oZnVuY3Rpb24oKSB7ICB9KS5iaW5kKHRoaXMpKVxuICAgICAgICAuZG9uZSh0aGlzLnNob3dDaGFydClcbiAgICAgICAgLmZhaWwodGhpcy5mYWlsTG9hZGluZyk7XG4gICAgICB9KS5iaW5kKHRoaXMpKVxuICAgICAgLmZhaWwoXyhmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5hcHAucmVwb3J0KCdDb3VsZCBub3QgbG9hZCB0cmFuc2xhdGlvbnMnLCBbXG4gICAgICAgICAgJ1JlZnJlc2hpbmcgdGhlIHBhZ2UgbWF5IGZpeCB0aGUgaXNzdWUuJ10pO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG5cbiAgfSxcblxuICBzaG93Q2hhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRPRE86IHdoeSBhcmUgd2UgdHJpZ2dlcmluZyB0d2ljZSBvbiBsb2FkPz8/XG4gICAgaWYgKCF0aGlzLm1vZGVsLmhhc0RhdGEoKSkge1xuICAgICAgdGhpcy5tZXNzYWdlLmh0bWwoJ05vIERhdGEgQXZhaWxhYmxlJykuYXR0cignZGF0YS1pMThuJywnYW1wLmRhc2hib2FyZDpjaGFydC1uby1kYXRhLWF2YWlsYWJsZScpO1xuICAgICAgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKCQoJy5jaGFydC1jb250YWluZXInKSk7XG4gICAgICB0aGlzLnJlc2V0TnVtYmVycygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2hhcnQgPSBnZXRDaGFydCh0aGlzLm1vZGVsLmdldCgndmlldycpLCB0aGlzLm1vZGVsLmdldCgncHJvY2Vzc2VkJyksIHRoaXMuZ2V0Q2hhcnRPcHRpb25zKCkpO1xuICAgIHRoaXMuY2hhcnRDb250YWluZXIuaHRtbChjaGFydC5lbCk7XG5cbiAgICB0aGlzLnJlbmRlck51bWJlcnMoKTtcbiAgICB2YXIgbGltaXQgPSB0aGlzLm1vZGVsLmdldCgnbGltaXQnKTtcbiAgICBpZiAobGltaXQpIHtcbiAgICAgIHRoaXMuJCgnLnJlc2V0JylbbGltaXQgPT09IHRoaXMubW9kZWwuZGVmYXVsdHMubGltaXQgPyAnaGlkZScgOiAnc2hvdyddKCk7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZS5zdG9wKCkuZmFkZU91dCgyMDApO1xuICAgIFxuICAgIHRoaXMuYmVhdXRpZnlMZWdlbmRzKHRoaXMpO1xuICB9LFxuXG4gIGdldENoYXJ0T3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvID0gXyhfKHRoaXMuY2hhcnRPcHRpb25zKS5jbG9uZSgpIHx8IHt9KS5kZWZhdWx0cyh7XG4gICAgICB0cmltTGFiZWxzOiAhdGhpcy5tb2RlbC5nZXQoJ2JpZycpLFxuICAgICAgZ2V0VFRDb250ZW50OiB0aGlzLmdldFRUQ29udGVudCxcbiAgICAgIGNsaWNrSGFuZGxlcjogdGhpcy5jaGFydENsaWNrSGFuZGxlcixcbiAgICAgIHdpZHRoOiB0aGlzLiQoJy5wYW5lbC1ib2R5Jykud2lkdGgoKSxcbiAgICAgIGhlaWdodDogdGhpcy4kKCcucGFuZWwtYm9keScpLmhlaWdodCgpXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvO1xuICB9LFxuXG4gIGZhaWxMb2FkaW5nOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1lc3NhZ2UuaHRtbCgnRmFpbGVkIHRvIGxvYWQgZGF0YSA8c21hbGw+JyArIGFyZ3VtZW50c1syXSArXG4gICAgICAnIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicmV0cnkgYnRuIGJ0bi13YXJuaW5nIGJ0bi1zbVwiPicgK1xuICAgICAgJzxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZWZyZXNoXCI+PC9zcGFuPiBSZXRyeTwvYnV0dG9uPjwvc21hbGw+Jykuc2hvdygpO1xuICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCBsb2FkaW5nIGNoYXJ0IDooJywgYXJndW1lbnRzKTtcbiAgfSxcblxuICByZW5kZXJOdW1iZXJzOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3RvdGFsJykpIHtcbiAgICAgIC8vdGhpcy4kKCcuY2hhcnQtdG90YWwnKS5odG1sKHV0aWwuZm9ybWF0S01CKDMsIGFwcC5zZXR0aW5ncy5udW1iZXJGb3JtYXRTZXR0aW5ncy5kZWNpbWFsU2VwYXJhdG9yKSh0aGlzLm1vZGVsLmdldCgndG90YWwnKSkpO1xuICAgIFx0dGhpcy4kKCcuY2hhcnQtdG90YWwnKS5odG1sKHRoaXMubW9kZWwuZ2V0KCdzdW1hcml6ZWRUb3RhbCcpKTtcbiAgICB9XG4gICAgdGhpcy4kKCcuY2hhcnQtY3VycmVuY3knKS5odG1sKHRoaXMubW9kZWwuZ2V0KCdjdXJyZW5jeScpKTtcbiAgfSxcblxuICByZXNldE51bWJlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJCgnLmNoYXJ0LXRvdGFsJykuaHRtbCgnJyk7XG4gICAgdGhpcy4kKCcuY2hhcnQtY3VycmVuY3knKS5odG1sKCcnKTtcbiAgfSxcblxuICByZXNldExpbWl0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnNldCgnbGltaXQnLCB0aGlzLm1vZGVsLmRlZmF1bHRzLmxpbWl0KTtcbiAgfSxcblxuICBjaGFuZ2VBZGpUeXBlOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG5ld1R5cGUgPSBlLmN1cnJlbnRUYXJnZXQudmFsdWU7XG4gICAgdGhpcy5tb2RlbC5zZXQoJ2FkanR5cGUnLCBuZXdUeXBlKTtcbiAgfSxcblxuICBjaGFuZ2VDaGFydFZpZXc6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdmlldyA9IHV0aWwuZGF0YShlLmN1cnJlbnRUYXJnZXQsICd2aWV3Jyk7XG4gICAgdGhpcy5tb2RlbC5zZXQoJ3ZpZXcnLCB2aWV3KTtcbiAgfSxcblxuICBiaWc6IGZ1bmN0aW9uKCkge1xuICAgIC8vIHRvZ2dsZSBiaWcvc21hbGwgY2hhcnRzIG9uIGxhcmdlIHNjcmVlbnNcbiAgICB0aGlzLm1vZGVsLnNldCgnYmlnJywgIXRoaXMubW9kZWwuZ2V0KCdiaWcnKSk7XG4gIH0sXG5cbiAgc2V0Q2xlYXI6IGZ1bmN0aW9uKHNob3VsZEJyZWFrKSB7XG4gICAgLy8gbGF5b3V0IGhpbnRzLCBzaG91bGQgb25seSBiZSBjYWxsZWQgYnkgLi9jaGFydHMuanNcbiAgICB0aGlzLiRlbFtzaG91bGRCcmVhayA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgnY2xlYXJmaXgnKTtcbiAgfSxcblxuICBkb3dubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRvd25sb2FkVmlldyA9IG5ldyBEb3dubG9hZFZpZXcoe1xuICAgICAgYXBwOiB0aGlzLmFwcCxcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgY2hhcnRPcHRpb25zOiBfKHRoaXMuZ2V0Q2hhcnRPcHRpb25zKCkpLm9taXQoJ2hlaWdodCcsICd3aWR0aCcpXG4gICAgfSk7XG4gICAgdmFyIHNwZWNpYWxDbGFzcyA9ICdkYXNoLWRvd25sb2FkLW1vZGFsJztcbiAgICB0aGlzLmFwcC5tb2RhbCgnRG93bmxvYWQgY2hhcnQnLCB7XG4gICAgICBib2R5RWw6IGRvd25sb2FkVmlldy5yZW5kZXIoKS5lbCxcbiAgICAgIHNwZWNpYWxDbGFzczogc3BlY2lhbENsYXNzLFxuICAgICAgaTE4blRpdGxlOiAnYW1wLmRhc2hib2FyZDpkb3dubG9hZC1kb3dubG9hZC1jaGFydCdcbiAgICB9KTtcbiAgICBcbiAgICAvLyBUcmFuc2xhdGUgbW9kYWwgcG9wdXAuXHRcbiAgIFx0YXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKCQoXCIuXCIgKyBzcGVjaWFsQ2xhc3MpKTtcbiAgfSxcbiAgXG4gIC8vQU1QLTE4NjMwOiBIZXJlIHdlIHNldHVwIGEgc2ltcGxlIHRvb2x0aXAgZm9yIGVhY2ggbGVnZW5kIGVsZW1lbnQuXG4gIGJlYXV0aWZ5TGVnZW5kcyA6IGZ1bmN0aW9uKHNlbGYpIHtcdCAgXG5cdCAgdmFyIGhhc1ZhbHVlcyA9IGZhbHNlO1xuXHQgIHZhciBoYXNQcm9jZXNzZWQgPSBmYWxzZTtcblx0ICBpZihzZWxmLm1vZGVsICE9IHVuZGVmaW5lZCAmJiBzZWxmLm1vZGVsLmdldCgndmFsdWVzJykgIT0gdW5kZWZpbmVkICYmIHNlbGYubW9kZWwuZ2V0KCd2YWx1ZXMnKS5sZW5ndGggPiAwKSB7XG5cdFx0ICBoYXNWYWx1ZXMgPSB0cnVlO1xuXHQgIH1cblx0ICBpZihzZWxmLm1vZGVsICE9IHVuZGVmaW5lZCAmJiBzZWxmLm1vZGVsLmdldCgncHJvY2Vzc2VkJykgIT0gdW5kZWZpbmVkICYmIHNlbGYubW9kZWwuZ2V0KCdwcm9jZXNzZWQnKS5sZW5ndGggPiAxKSB7XG5cdFx0ICBoYXNQcm9jZXNzZWQgPSB0cnVlO1xuXHQgIH1cblx0ICBcblx0ICAvLyBJdGVyYXRlIHRoZSBsaXN0IG9mIGxlZ2VuZCBlbGVtZW50cyBpbiBET00gKG9ubHkgZm9yIHRoaXMgY2hhcnQpIGFuZCBzZXQgYSBkYXRhIGVsZW1lbnQgY2FsbGVkICdkYXRhLXRpdGxlJyB0aGF0XG5cdCAgLy8gd2lsbCBiZSB0aGVuIHVzZWQgd2hlbiBhIGhvdmVyIGV2ZW50IGlzIGZpcmVkLlxuXHQgICQodGhpcy4kZWwpLmZpbmQoXCIubnYtc2VyaWVzXCIpLmVhY2goZnVuY3Rpb24oaSwgZWxlbSkge1xuXHRcdCAgaWYoaGFzVmFsdWVzICYmICFoYXNQcm9jZXNzZWQpIHtcblx0XHRcdCAgLy8gVG9wIGNoYXJ0cy5cblx0XHRcdCAgaWYoc2VsZi5tb2RlbC5nZXQoJ3ZhbHVlcycpW2ldICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQgICQoZWxlbSkuZGF0YSgnZGF0YS10aXRsZScsIHNlbGYubW9kZWwuZ2V0KCd2YWx1ZXMnKVtpXS5uYW1lKTtcblx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0Ly8gVGhpcyB0aGUgbGFzdCBsZWdlbmQgXCJPdGhlcnNcIiAoZG9lc250IGNvbWUgaW4gdGhlIGRhdGEpLlxuXHRcdCAgICBcdCQoZWxlbSkuZGF0YSgnZGF0YS10aXRsZScsIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LUZ1bmRpbmdUeXBlLW90aGVyc1wiLCBcIk90aGVyc1wiKSk7XG5cdFx0XHQgIH1cblx0XHQgIH0gZWxzZSBpZihoYXNQcm9jZXNzZWQpIHtcblx0XHRcdCAgLy8gQWlkIFByZWRpY3RhYmlsaXR5IGNoYXJ0cyBhbmQgRnVuZGluZyBUeXBlIGNoYXJ0cy5cblx0XHRcdCAgaWYoc2VsZi5tb2RlbC5nZXQoJ3Byb2Nlc3NlZCcpW2ldICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQgIC8vIFRoZSBleHRyYSBjaGVjayBpcyBmb3IgRlQgY2hhcnRzIHRoYXQgaGF2ZSBtb3JlIGxlZ2VuZHMgKGdyb3VwZWQsIHN0YWNrZWQsIGV0YykuXG5cdFx0XHRcdCAgJChlbGVtKS5kYXRhKCdkYXRhLXRpdGxlJywgc2VsZi5tb2RlbC5nZXQoJ3Byb2Nlc3NlZCcpW2ldLmtleSk7XG5cdFx0XHQgIH1cblx0XHQgIH1cblx0ICAgIFxuXHRcdCAgLy8gTm93IGJpbmQgTlYgdG9vbHRpcCBtZWNoYW5pc20gdG8gaG92ZXIgZXZlbnQgZm9yIGVhY2ggbGVnZW5kLlxuXHRcdCAgaWYoJChlbGVtKS5kYXRhKCdkYXRhLXRpdGxlJykpIHtcblx0XHRcdCAgJChlbGVtKS5ob3ZlcihmdW5jdGlvbigpIHtcblx0ICAgIFx0XHR2YXIgb2Zmc2V0ID0gJCh0aGlzKS5vZmZzZXQoKTtcblx0ICAgIFx0XHQvL1RPRE86IFJlbW92ZSBoYXJkY29kZWQgaHRtbCBhbmQgdXNlIGEgdGVtcGxhdGUuXG5cdCAgICBcdCAgICBudi50b29sdGlwLnNob3coW29mZnNldC5sZWZ0LCBvZmZzZXQudG9wXSwgXCI8ZGl2IGNsYXNzPSdwYW5lbCBwYW5lbC1wcmltYXJ5IHBhbmVsLXBvcG92ZXInPjxkaXYgY2xhc3M9J3BhbmVsLWhlYWRpbmcnPlwiICsgJChlbGVtKS5kYXRhKCdkYXRhLXRpdGxlJykgKyBcIjwvZGl2PjwvZGl2PlwiKTtcblx0ICAgIFx0ICAgICAgICBcblx0ICAgIFx0ICAgIC8vIFRPRE86IEZpbmQgYSB3YXkgdG8gdHJpZ2dlciB0aGUgbW91c2VvdmVyIG9uIHRoZSBiYXIuXG5cdCAgICBcdCAgICAvLyAkKCQodGhpcykuY2xvc2VzdCgnc3ZnJykuZmluZChcIi5udi1ncm91cHNcIikuZmluZChcIi5udi1iYXJcIilbaV0pLnRyaWdnZXIoJ2hvdmVyJyk7XG5cdCAgICBcdCAgIH0sIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdCAgIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuXHQgICAgXHQgICB9KTtcblx0XHQgIH1cblx0ICB9KTtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcblxudmFyIFRvcHMgPSByZXF1aXJlKCcuLi9tb2RlbHMvY2hhcnQtdG9wcycpO1xudmFyIFByZWRpY3RhYmlsaXR5ID0gcmVxdWlyZSgnLi4vbW9kZWxzL2NoYXJ0LWFpZC1wcmVkaWN0YWJpbGl0eScpO1xudmFyIEZ1bmRpbmdUeXBlID0gcmVxdWlyZSgnLi4vbW9kZWxzL2NoYXJ0LWZ1bmRpbmctdHlwZScpO1xuXG52YXIgVG9wc0NoYXJ0VmlldyA9IHJlcXVpcmUoJy4vY2hhcnQtdG9wcycpO1xudmFyIFByZWRpY3RhYmlsaXR5Q2hhcnRWaWV3ID0gcmVxdWlyZSgnLi9jaGFydC1haWQtcHJlZGljdGFiaWxpdHknKTtcbnZhciBGdW5kaW5nVHlwZUNoYXJ0VmlldyA9IHJlcXVpcmUoJy4vY2hhcnQtZnVuZGluZy10eXBlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZURhc2guVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ3JvdycsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XG4gICAgdGhpcy5jaGFydFZpZXdzID0gdGhpcy5jb2xsZWN0aW9uLm1hcChmdW5jdGlvbihjaGFydCkge1xuICAgICAgdmFyIENoYXJ0VmlldyA9IGNoYXJ0IGluc3RhbmNlb2YgVG9wcyA/IFRvcHNDaGFydFZpZXdcbiAgICAgICAgICAgICAgICAgICAgOiBjaGFydCBpbnN0YW5jZW9mIFByZWRpY3RhYmlsaXR5ID8gUHJlZGljdGFiaWxpdHlDaGFydFZpZXdcbiAgICAgICAgICAgICAgICAgICAgOiBjaGFydCBpbnN0YW5jZW9mIEZ1bmRpbmdUeXBlID8gRnVuZGluZ1R5cGVDaGFydFZpZXdcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBDaGFydFZpZXcoeyBtb2RlbDogY2hhcnQsIGFwcDogdGhpcy5hcHAgfSk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5saXN0ZW5Ub09uY2UodGhpcy5hcHAuZmlsdGVyLCAnYXBwbHknLCB0aGlzLmFwcGx5RmlsdGVyKTtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ2NoYW5nZTpiaWcnLCB0aGlzLmluamVjdEJyZWFrcyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKF8odGhpcy5jaGFydFZpZXdzKS5tYXAoZnVuY3Rpb24odmlldykge1xuICAgICAgcmV0dXJuIHZpZXcucmVuZGVyKCkuZWw7XG4gICAgfSkpO1xuICAgIHRoaXMuaW5qZWN0QnJlYWtzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW5qZWN0QnJlYWtzOiBmdW5jdGlvbihjaGFydE1vZGVsKSB7XG4gICAgXyh0aGlzLmNoYXJ0Vmlld3MpLnJlZHVjZShmdW5jdGlvbihicmVha0FmdGVyLCB0aGlzVmlldykge1xuICAgICAgdGhpc1ZpZXcuc2V0Q2xlYXIoYnJlYWtBZnRlcik7XG4gICAgICBpZiAoIWJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNWaWV3Lm1vZGVsLmdldCgnYmlnJykgPyBmYWxzZSA6IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgaWYgKGNoYXJ0TW9kZWwpIHtcbiAgICAgIHZhciBjaGFydFZpZXcgPSBfKHRoaXMuY2hhcnRWaWV3cykuZmluZChmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2Lm1vZGVsID09PSBjaGFydE1vZGVsO1xuICAgICAgfSk7XG4gICAgICBpZiAoY2hhcnRWaWV3KSB7IGNoYXJ0Vmlldy5yZW5kZXIoKTsgfVxuICAgIH1cbiAgfVxuXG59KTtcbiIsInZhciBCYWNrYm9uZURhc2ggPSByZXF1aXJlKCcuLi9iYWNrYm9uZS1kYXNoJyk7XG52YXIgRmlsdGVycyA9IHJlcXVpcmUoJy4vZmlsdGVycycpO1xudmFyIFNldHRpbmdzID0gcmVxdWlyZSgnLi9zZXR0aW5ncycpO1xudmFyIFNoYXJlID0gcmVxdWlyZSgnLi9zaGFyZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdyb3cnLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwOyAgICBcbiAgICB0aGlzLnNldHRpbmdzID0gbmV3IFNldHRpbmdzKHsgYXBwOiB0aGlzLmFwcCB9KTtcbiAgICB0aGlzLmZpbHRlcnMgPSBuZXcgRmlsdGVycyh7IGFwcDogdGhpcy5hcHAgfSk7XG4gICAgdGhpcy5zaGFyZSA9IG5ldyBTaGFyZSh7IGFwcDogdGhpcy5hcHAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKFtcbiAgICAgIHRoaXMuZmlsdGVycy5yZW5kZXIoKS5lbCxcbiAgICAgIHRoaXMuc2V0dGluZ3MucmVuZGVyKCkuZWwsXG4gICAgICB0aGlzLnNoYXJlLnJlbmRlcigpLmVsXG4gICAgXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBiYWJ5ID0gcmVxdWlyZSgnYmFieXBhcnNlJyk7XG52YXIgY2FudmcgPSByZXF1aXJlKCcuLi8uLi91Z2x5L2xpYi1sb2FkLWhhY2tzJykuY2Fudmc7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3VnbHkvdXRpbCcpO1xuXG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcbnZhciBnZXRDaGFydCA9IHJlcXVpcmUoJy4uL2NoYXJ0cy9jaGFydCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91Z2x5L3V0aWwnKTtcbnZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8aDQgZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmRvd25sb2FkLXByZXZpZXdcXFwiPlByZXZpZXc6PC9oND5cXG5cXG48IS0tIFRoaXMgJ21vZGFsJyBkaXYgZml4ZXMgQU1QLTE5NTI1OiBJbiBGRiB3aGVuIHRoZSBjaGFydCBpcyBkcmF3biAoZm9yIGxlc3MgdGhhbiBhIHNlY29uZCkgaW4gJ3N2Zy13cmFwJywgc29tZXRpbWVzIHRoZSBtb3VzZSBjdXJzb3IgaXMgb3ZlciBvbmUgb2YgdGhlIGJhcnMgYW5kIHRyaWdnZXJzIHRoZSB0b29sdGlwLFxcbnRoYXQgcHJvY2VzcyBpcyBub3QgZnVsbHkgcGVyZm9ybWVkIHRodXMgcmVzdWx0aW5nIGluIGluY29tcGxldGUgaHRtbCB3aGljaCBpcyByZWplY3RlZCBieSB0aGUgYnJvd3NlciA6KCAgLS0+XFxuPGRpdiBjbGFzcz1cXFwibW9kYWwtcHJldmlldy1hcmVhXFxcIj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJwcmV2aWV3LWFyZWFcXFwiPlxcblxcdDxkaXYgY2xhc3M9XFxcInN2Zy13cmFwIGhpZGRlblxcXCI+XFxuICBcXHQ8L2Rpdj5cXG4gIFxcdDxkaXYgY2xhc3M9XFxcImNhbnZhcy13cmFwIGhpZGRlblxcXCI+XFxuICBcXHQ8L2Rpdj5cXG4gIFxcdDxkaXYgY2xhc3M9XFxcInRhYmxlLXdyYXAgaGlkZGVuXFxcIj5cXG4gIFxcdDwvZGl2PlxcbjwvZGl2PlxcblxcbjxkaXYgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj5cXG4gIDxhIGNsYXNzPVxcXCJidG4gYnRuLXN1Y2Nlc3MgZG93bmxvYWQtY2hhcnQgZGlzYWJsZWRcXFwiPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1kb3dubG9hZFxcXCI+PC9zcGFuPlxcbiAgICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtcmVuZGVyaW5nXFxcIiBjbGFzcz1cXFwid29yZFxcXCI+UmVuZGVyaW5nLi4uPC9zcGFuPlxcbiAgPC9hPlxcbjwvZGl2PlxcblwiKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5WaWV3LmV4dGVuZCh7XG4gXG4gIC8vVE9ETzogVGhpcyBpcyB3cm9uZyBiZWNhdXNlIGRpZmZlcmVudCBjb3VudHJpZXMgaGF2ZSBvdGhlciBtZWFzdXJlcyAoaWU6IHNzYykuXHRcbiAgYWRqVHlwZVRyYW5zbGF0aW9uIDoge1wiQWN0dWFsIENvbW1pdG1lbnRzXCI6XCJhbXAuZGFzaGJvYXJkOmZ0eXBlLWFjdHVhbC1jb21taXRtZW50XCIsXG5cdFx0XHRcIkFjdHVhbCBEaXNidXJzZW1lbnRzXCI6XCJhbXAuZGFzaGJvYXJkOmZ0eXBlLWFjdHVhbC1kaXNidXJzZW1lbnRcIixcblx0XHRcdFx0XCJBY3R1YWwgRXhwZW5kaXR1cmVzXCI6XCJhbXAuZGFzaGJvYXJkOmZ0eXBlLWFjdHVhbC1leHBlbmRpdHVyZVwiLFxuXHRcdFx0XHRcIlBsYW5uZWQgQ29tbWl0bWVudHNcIjogXCJhbXAuZGFzaGJvYXJkOmZ0eXBlLXBsYW5uZWQtY29tbWl0bWVudFwiLFxuXHRcdFx0XHRcIlBsYW5uZWQgRGlzYnVyc2VtZW50c1wiOiBcImFtcC5kYXNoYm9hcmQ6ZnR5cGUtcGxhbm5lZC1kaXNidXJzZW1lbnRcIixcblx0XHRcdFx0XCJQbGFubmVkIEV4cGVuZGl0dXJlc1wiOiBcImFtcC5kYXNoYm9hcmQ6ZnR5cGUtcGxhbm5lZC1leHBlbmRpdHVyZXNcIlxuXHRcdFx0ICAgIH0sXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICAgIHRoaXMuZGFzaENoYXJ0T3B0aW9ucyA9IF8oe30pLmV4dGVuZChvcHRpb25zLmNoYXJ0T3B0aW9ucywge1xuICAgICAgaGVpZ2h0OiA0NTAsICAvLyBzeW5jIHdpdGggY3NzISEhXG4gICAgICB3aWR0aDogOTcwLFx0Ly8gc3luYyB3aXRoIGNzcyEhIVxuICAgICAgdHJpbUxhYmVsczogZmFsc2VcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoKSk7XG5cbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3ZpZXcnKSA9PT0gJ3RhYmxlJykge1xuICAgICAgdGhpcy5yZW5kZXJDU1YodGhpcy4kKCcucHJldmlldy1hcmVhIC50YWJsZS13cmFwJykucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpKTtcbiAgICB9IGVsc2Uge1xuICAgIFx0Ly8gSGVyZSB3ZSB3aWxsIGRlZmluZSBhbiBpbnRlcnZhbCB0aGF0IHdpbGwgY2hlY2sgcGVyaW9kaWNhbGx5IGlmIHRoZSBib290c3RyYXAgbW9kYWwgaXMgZnVsbHkgcmVuZGVyZWQuXG4gICAgXHQvLyBJbiB0aGF0IG1vbWVudCB0aGUgaW50ZXJ2YWwgaXMgZmluaXNoZWQgYW5kIHRoZSBjaGFydCBpcyByZW5kZXJlZC5cbiAgICBcdHZhciBzZWxmID0gdGhpcztcbiAgICBcdHZhciByZW5kZXJlZCA9IGZhbHNlOyAvLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBhdm9pZCB0cmlnZ2VyaW5nIHRoZSByZW5kZXIgcHJvY2VzcyB0d2ljZSBpbiBjYXNlIHRoZSBicm93c2VyIG1lc3MgdXAgdGhlIGludGVydmFsLlxuICAgIFx0dmFyIGludGVydmFsID0gd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgIFx0XHRpZiAoJCgnLmRhc2gtZG93bmxvYWQtbW9kYWwnKS5jbG9zZXN0KCcuaW4nKS5sZW5ndGggPiAwKSB7XG4gICAgXHRcdFx0d2luZG93LmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpOyAgICBcdFx0XHQgICBcdFx0XHRcbiAgICBcdFx0XHRudi50b29sdGlwLmNsZWFudXAoKTtcbiAgICBcdFx0XHRpZiAocmVuZGVyZWQgPT09IGZhbHNlKSB7XG4gICAgXHRcdFx0XHRyZW5kZXJlZCA9IHRydWU7XG4gICAgXHRcdFx0XHRzZWxmLnJlbmRlckNoYXJ0KHNlbGYuJCgnLnByZXZpZXctYXJlYSAuc3ZnLXdyYXAnKS5yZW1vdmVDbGFzcygnaGlkZGVuJyksIFxuICAgIFx0XHRcdFx0XHRcdHNlbGYuJCgnLnByZXZpZXctYXJlYSAuY2FudmFzLXdyYXAnKSk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG4gICAgXHR9LCAxMDApOyAgICAgIFxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW5kZXJDaGFydDogZnVuY3Rpb24oc3ZnQ29udGFpbmVyLCBjYW52YXNDb250YWluZXIpIHtcbiAgICBpZiAoXyh0aGlzLmFwcC5icm93c2VySXNzdWVzKS5maW5kV2hlcmUoe2ZlYXR1cmU6ICdjYW52YXMnfSkpIHtcbiAgICAgIHRoaXMuYXBwLnZpZXdGYWlsKHRoaXMsICdDaGFydCBleHBvcnQgcmVxdWlyZXMgYSBtb2Rlcm4gd2ViIGJyb3dzZXInKTtcbiAgICB9XG4gICAgdmFyIHZpZXcgPSB0aGlzLm1vZGVsLmdldCgndmlldycpLFxuICAgICAgICBkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ3Byb2Nlc3NlZCcpLFxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgY2hhcnRFbCA9IGdldENoYXJ0KHZpZXcsIGRhdGEsXG4gICAgICAgICAgXyh7fSkuZXh0ZW5kKHRoaXMuZGFzaENoYXJ0T3B0aW9ucywgeyBoZWlnaHQ6IHRoaXMuZGFzaENoYXJ0T3B0aW9ucy5oZWlnaHQgLSA0MiB9KSkuZWw7XG5cbiAgICBzdmdDb250YWluZXIuaHRtbChjaGFydEVsKTtcblxuICAgIHRoaXMucHJlcGFyZUNhbnZhcyhjYW52YXMsIHRoaXMuZGFzaENoYXJ0T3B0aW9ucy5oZWlnaHQsIHRoaXMuZGFzaENoYXJ0T3B0aW9ucy53aWR0aCk7XG5cbiAgICB0aGlzLmNoYXJ0VG9DYW52YXMoY2hhcnRFbCwgY2FudmFzLCBmdW5jdGlvbigpIHtcbiAgICAgIHN2Z0NvbnRhaW5lci5oaWRlKCk7XG4gICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICBjYW52YXNDb250YWluZXIuaHRtbChpbWcpO1xuICAgICAgJChjYW52YXNDb250YWluZXIpLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICAgICQoJy5tb2RhbC1wcmV2aWV3LWFyZWEnKS5yZW1vdmUoKTtcbiAgICAgIHRoaXMubWFrZURvd25sb2FkYWJsZShpbWcuc3JjLCAnY2hhcnQnLCAnLnBuZycpOyAgICAgIFxuICAgIH0pO1xuXG4gIH0sXG5cbiAgcHJlcGFyZUNhbnZhczogZnVuY3Rpb24oY2FudmFzLCBoLCB3KSB7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICBtb25leUNvbnRleHQgPSAodGhpcy5tb2RlbC5nZXQoJ3N1bWFyaXplZFRvdGFsJykgIT09IHVuZGVmaW5lZCA/ICc6ICcgKyB0aGlzLm1vZGVsLmdldCgnc3VtYXJpemVkVG90YWwnKSArICcgJzogJyAnKSArIHRoaXMubW9kZWwuZ2V0KCdjdXJyZW5jeScpLCAgICAgICAgXG4gICAgICAgIGFkalR5cGUgPSB0aGlzLm1vZGVsLmdldCgnYWRqdHlwZScpO1xuXG4gICAgaWYgKGFkalR5cGUpIHtcbiAgICAgIHZhciBhZGpTZXR0aW5ncyA9IHRoaXMuYXBwLnNldHRpbmdzLmdldCgnMCcpOyAgLy8gaWQgZm9yIEZ1bmRpbmcgVHlwZVxuICAgICAgaWYgKCFhZGpTZXR0aW5ncykgeyB0aGlzLmFwcC5yZXBvcnQoJ0NvdWxkIG5vdCBmaW5kIEZ1bmRpbmcgVHlwZSBzZXR0aW5ncycpOyB9XG4gICAgICB2YXIgYWRqTmFtZSA9IF8oYWRqU2V0dGluZ3MuZ2V0KCdvcHRpb25zJykpLmZpbmQoZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gcy5pZCA9PT0gYWRqVHlwZTtcbiAgICAgIH0pLm5hbWU7XG5cbiAgICAgIC8vIHZhciBsb2NhbEFkaiA9IHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygpXG4gICAgICAvLyBUT0RPOiBsb2NhbGl6ZSBhZGp0eXBlPyBpcyB0aGF0IG5lY2Vzc2FyeT9cbiAgICAgIG1vbmV5Q29udGV4dCA9IGFkak5hbWUgKyBtb25leUNvbnRleHQ7XG4gICAgfVxuXG4gICAgLy8gc2l6ZSB0aGUgY2FudmFzXG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3KTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoKTtcblxuICAgIC8vIG1ha2UgdGhlIGJhY2tncm91bmQgb3BhcXVlIHdoaXRlXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KDAsIDAsIHcsIGgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmZic7XG4gICAgY3R4LmZpbGwoKTtcblxuICAgIC8vIEFkZCB0aGUgY2hhcnQgdGl0bGVcbiAgICBjdHguZmlsbFN0eWxlID0gJyMxNjNmNjYnO1xuICAgIGN0eC5mb250ID0gJ2JvbGQgMjJweCBcIk9wZW4gU2Fuc1wiJztcbiAgICB2YXIgbG9jYWxOYW1lID0gdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmNoYXJ0LScgK1xuICAgICAgdGhpcy5tb2RlbC5nZXQoJ25hbWUnKS5yZXBsYWNlKC8gL2csICcnKSwgdGhpcy5tb2RlbC5nZXQoJ25hbWUnKSk7XG4gICAgY3R4LmZpbGxUZXh0KGxvY2FsTmFtZS50b1VwcGVyQ2FzZSgpLCAxMCwgMTAgKyAyMik7XG4gICAgLy8gd2hhdCBtb25leSBhcmUgd2UgdGFsa2luZyBhYm91dD9cbiAgICBjdHguZmlsbFN0eWxlID0gJyMzMzMnO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgIGN0eC5maWxsVGV4dChtb25leUNvbnRleHQsIHcgLSAxMCwgMTAgKyAyMik7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JzsgIC8vIHJlc2V0IGl0XG5cbiAgICAvLyByZXNldCBmb250IHRvIHNvbWV0aGluZyBub3JtYWwgKG52ZDMgdXNlcyBjc3MgdWdoLi4uKVxuICAgIGN0eC5mb250ID0gJ25vcm1hbCAxMnB4IFwic2Fucy1zZXJpZlwiJztcbiAgfSxcblxuICBjaGFydFRvQ2FudmFzOiBmdW5jdGlvbihzdmcsIGNhbnZhcywgY2IpIHtcbiAgICB2YXIgYm91bmRDQiA9IF8oY2IpLmJpbmQodGhpcyk7XG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFwcC50cnlUbyhmdW5jdGlvbigpIHtcbiAgICAgICAgY2FudmcoY2FudmFzLCBzdmcucGFyZW50Tm9kZS5pbm5lckhUTUwsIHsgLy8gbm90ZTogc3ZnLm91dGVySFRNTCBicmVha3MgSUVcbiAgICAgICAgICBvZmZzZXRZOiA0MixcbiAgICAgICAgICBpZ25vcmVEaW1lbnNpb25zOiB0cnVlLFxuICAgICAgICAgIGlnbm9yZUNsZWFyOiB0cnVlLFxuICAgICAgICAgIGlnbm9yZU1vdXNlOiB0cnVlLFxuICAgICAgICAgIHJlbmRlckNhbGxiYWNrOiBib3VuZENCXG4gICAgICAgIH0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfS5iaW5kKHRoaXMpLCAxNTAwKTsgIC8vIHdlIGhhdmUgdG8gd2FpdCBmb3Igc3R1cGlkIG52ZDMuLi5cbiAgfSxcblxuICByZW5kZXJDU1Y6IGZ1bmN0aW9uKGNzdkNvbnRhaW5lcikge1xuICAgIHZhciBkYXRhID0gdGhpcy5tb2RlbC5nZXQoJ3Byb2Nlc3NlZCcpLFxuICAgICAgICBjdXJyZW5jeSA9IHRoaXMubW9kZWwuZ2V0KCdjdXJyZW5jeScpLFxuICAgICAgICBhZGp0eXBlID0gdGhpcy5tb2RlbC5nZXQoJ2FkanR5cGUnKSB8fCBmYWxzZSxcbiAgICAgICAgY3N2VHJhbnNmb3JtZWQsXG4gICAgICAgIGhlYWRlclJvdyxcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHByZXZpZXc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleXMgPSBfKGRhdGEpLnBsdWNrKCdrZXknKTtcbiAgICAvLyB0YWJsZSBvZiBhbGwgdGhlIGRhdGFcbiAgICBjc3ZUcmFuc2Zvcm1lZCA9IF8oZGF0YSlcbiAgICAgIC5jaGFpbigpXG4gICAgICAucGx1Y2soJ3ZhbHVlcycpXG4gICAgICAudHJhbnNwb3NlKClcbiAgICAgIC5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHJldHVybiBfKHJvdykucmVkdWNlKGZ1bmN0aW9uKGNzdlJvdywgY2VsbCkge1xuICAgICAgICAgIGNzdlJvdy5wdXNoKGNlbGwueSk7XG4gICAgICAgICAgcmV0dXJuIGNzdlJvdztcbiAgICAgICAgfSwgW3Jvd1swXS54XSk7XG4gICAgICB9KVxuICAgICAgLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgcm93LnB1c2goY3VycmVuY3kgfHwgJycpO1xuICAgICAgICBpZiAoYWRqdHlwZSkge1xuICAgICAgICBcdHZhciBrZXkgPSBzZWxmLmFkalR5cGVUcmFuc2xhdGlvbiBbYWRqdHlwZV07XG4gICAgICAgICAgICB2YXIgdHJuQWRqVHlwZSA9IHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhrZXksIGFkanR5cGUpO1xuICAgICAgICAgICAgcm93LnB1c2godHJuQWRqVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH0pXG4gICAgICAudmFsdWUoKTsgIFxuICAgIFxuICAgIC8vIHByZXBlbmQgYSBoZWFkZXIgcm93XG4gICAgaGVhZGVyUm93ID0gW107XG4gICAgdmFyIGFtb3VudFRybiA9IHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpkb3dubG9hZC1hbW91bnQnLCAnQW1vdW50Jyk7XG4gICAgdmFyIGN1cnJlbmN5VHJuID0gdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmN1cnJlbmN5JywgJ0N1cnJlbmN5Jyk7XG4gICAgdmFyIHR5cGVUcm4gPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6dHlwZScsICdUeXBlJyk7XG4gICAgdmFyIHllYXJUcm4gPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6eWVhcicsICdZZWFyJyk7XG4gICAgXG5cdGlmICh0aGlzLm1vZGVsLnVybC5pbmRleE9mKCcvdG9wcycpID4gLTEpIHtcblx0ICAgIGhlYWRlclJvdy5wdXNoKHRoaXMubW9kZWwuZ2V0KCd0aXRsZScpKTtcblx0ICAgIGhlYWRlclJvdy5wdXNoKGFtb3VudFRybik7XG5cdCAgICBoZWFkZXJSb3cucHVzaChjdXJyZW5jeVRybik7XG5cdCAgICBoZWFkZXJSb3cucHVzaCh0eXBlVHJuKTtcblx0fSBlbHNlIGlmICh0aGlzLm1vZGVsLnVybC5pbmRleE9mKCcvYWlkLXByZWRpY3RhYmlsaXR5JykgPiAtMSkge1xuXHQgICAgaGVhZGVyUm93LnB1c2goeWVhclRybik7XG5cdCAgICBfLmVhY2goa2V5cywgZnVuY3Rpb24oaXRlbSkge1xuXHQgICAgXHRoZWFkZXJSb3cucHVzaChpdGVtKTtcblx0ICAgIH0pO1xuXHQgICAgaGVhZGVyUm93LnB1c2goY3VycmVuY3lUcm4pO1xuXHR9IGVsc2UgaWYgKHRoaXMubW9kZWwudXJsLmluZGV4T2YoJy9mdHlwZScpID4gLTEpIHtcblx0XHRoZWFkZXJSb3cucHVzaCh5ZWFyVHJuKTtcblx0ICAgIF8uZWFjaChrZXlzLCBmdW5jdGlvbihpdGVtKSB7XG5cdCAgICBcdGhlYWRlclJvdy5wdXNoKGl0ZW0pO1xuXHQgICAgfSk7XG5cdCAgICBoZWFkZXJSb3cucHVzaChjdXJyZW5jeVRybik7XG5cdCAgICBoZWFkZXJSb3cucHVzaCh0eXBlVHJuKTtcblx0fSAgICBcblxuICAgIGNzdlRyYW5zZm9ybWVkLnVuc2hpZnQoaGVhZGVyUm93KTtcblxuICAgIHRleHRDb250ZW50ID0gYmFieS51bnBhcnNlKGNzdlRyYW5zZm9ybWVkLCB7XG4gICAgXHRxdW90ZXM6IHRydWVcbiAgICB9KTtcblxuICAgIHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHByZXZpZXcuc2V0QXR0cmlidXRlKCdjbGFzcycsICdjc3YtcHJldmlldycpO1xuICAgIHByZXZpZXcudmFsdWUgPSB0ZXh0Q29udGVudDtcbiAgICBjc3ZDb250YWluZXIuaHRtbChwcmV2aWV3KTtcblxuICAgIGlmICghdGhpcy5hcHAuaGFzSXNzdWUoJ2Rvd25sb2FkJykpIHtcbiAgICAgIHRleHRDb250ZW50ID0gdXRpbC50ZXh0QXNEYXRhVVJMKHRleHRDb250ZW50KTtcbiAgICB9XG5cbiAgICB3aW5kb3cuc2V0VGltZW91dChfKGZ1bmN0aW9uKCkgeyAgLy8gc3R1cGlkIGJvb3RzdHJhcCBtb2RhbHMuLi5cbiAgICAgIC8vIHRoaXMgc2V0VGltZW91dCBpcyBuZWVkZWQgZm9yIHRoZSBmbGFzaCBmYWxsYmFjayA6KFxuICAgICAgdGhpcy5tYWtlRG93bmxvYWRhYmxlKHRleHRDb250ZW50LCAnZGF0YScsICcuY3N2Jyk7XG4gICAgfSkuYmluZCh0aGlzKSwgMTAwKTtcbiAgfSxcblxuICBtYWtlRG93bmxvYWRhYmxlOiBmdW5jdGlvbihzdHVmZiwgd2hhdCwgZXh0KSB7XG4gICAgdmFyIGZpbGVOYW1lID0gdGhpcy5tb2RlbC5nZXQoJ25hbWUnKSArIGV4dCxcbiAgICAgICAgZGxCdXR0b24gPSB0aGlzLiQoJy5kb3dubG9hZC1jaGFydCcpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuICAgIGRsQnV0dG9uLmZpbmQoJy53b3JkJykudGV4dCgnRG93bmxvYWQgJyArIHdoYXQpLmF0dHIoJ2RhdGEtaTE4bicsICdhbXAuZGFzaGJvYXJkOmRvd25sb2FkLWRvd25sb2FkLScgKyB3aGF0KTtcbiAgICBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00oZGxCdXR0b24pO1xuXG4gICAgaWYgKHRoaXMuYXBwLmhhc0lzc3VlKCdkb3dubG9hZCcpKSB7XG4gICAgICBpZiAodGhpcy5hcHAuaGFzSXNzdWUoJ2ZsYXNoJykpIHtcbiAgICAgICAgdGhpcy5hcHAucmVwb3J0KCdZb3VyIGJyb3dzZXIgaXMgbWlzc2luZyBmZWF0dXJlcyB0byBpbml0aWF0ZSB0aGUgZG93bmxvYWQnLCBbXG4gICAgICAgICAgJ1lvdSBtaWdodCBiZSBhYmxlIHRvIHNhdmUgdGhpcyBjaGFydCBtYW51YWxseSBieSByaWdodC1jbGlja2luZyB0aGUgJyArXG4gICAgICAgICAgJ3ByZXZpZXcgYW5kIHNlbGVjdGluZyBcIlNhdmUgUGljdHVyZSBBcy4uLiddKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGJhZCBicm93c2VyLCBidXQgaGFzIGZsYXNoISBmYWxsYmFjayB0byBkb3dubG9hZGlmeVxuICAgICAgICB0aGlzLmFwcC50cnlUbyhmdW5jdGlvbigpIHtcbiAgICAgICAgICB3aW5kb3cuRG93bmxvYWRpZnkuY3JlYXRlKGRsQnV0dG9uWzBdLCB7XG4gICAgICAgICAgICBzd2Y6ICcvVEVNUExBVEUvYW1wVGVtcGxhdGUvY29tbW9uTWVkaWEvZG93bmxvYWRpZnkuc3dmJyxcbiAgICAgICAgICAgIGRvd25sb2FkSW1hZ2U6ICcvVEVNUExBVEUvYW1wVGVtcGxhdGUvY29tbW9uTWVkaWEvZG93bmxvYWQtYnV0dG9uLXN0YXRlcy5wbmc/cmV2PTQnLFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICB3aWR0aDogMTc2LFxuICAgICAgICAgICAgaGVpZ2h0OiAzNCxcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgIGRhdGE6IHN0dWZmXG4gICAgICAgICAgICAgIC5yZXBsYWNlKCdkYXRhOnRleHQvcGxhaW47YmFzZTY0LC8vJywgJycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsJywgJycpLFxuICAgICAgICAgICAgZGF0YVR5cGU6IGV4dCA9PT0gJy5jc3YnID8gJ3N0cmluZycgOiAnYmFzZTY0JyxcbiAgICAgICAgICAgIGFwcGVuZDogdHJ1ZSxcbiAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aGlzLmFwcC5yZXBvcnQoJ0NvdWxkIG5vdCBkb3dubG9hZCB0aGUgZmlsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJCgnLmRvd25sb2FkLWNoYXJ0JylcbiAgICAgICAgLmF0dHIoJ2hyZWYnLCBzdHVmZilcbiAgICAgICAgLmF0dHIoJ2Rvd25sb2FkJywgZmlsZU5hbWUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBTVAtMTk4MTNcbiAgICBpZiAoZXh0LmluZGV4T2YoJ2NzdicpICE9PSAtMSkge1xuICAgIFx0JCgnLm1vZGFsLXByZXZpZXctYXJlYScpLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuXG59KTtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xudmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuICA8aGVhZGVyIGNsYXNzPVxcXCJzcGFjZWQgdGV4dC1jZW50ZXJcXFwiPlxcbiAgICA8aDI+XFxuICAgICAgVGhlIGFwcGxpY2F0aW9uIGVuY291bnRlcmVkIGFuXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRleHQtZGFuZ2VyXFxcIj5lcnJvcjwvc3Bhbj5cXG4gICAgICA8c21hbGw+Oig8L3NtYWxsPlxcbiAgICA8L2gyPlxcbiAgICA8cD48JT0gZXJyICU+PC9wPlxcbiAgPC9oZWFkZXI+XFxuPC9kaXY+XFxuXCIpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgICB0aGlzLmVyciA9IG9wdGlvbnMuZXJyO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSh7IGVycjogdGhpcy5lcnIgfSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn0pO1xuXG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcbnZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMTIgY29sLW1kLTVcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicGFuZWxcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG4gICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRlZmF1bHQgcHVsbC1yaWdodCBzaG93LWZpbHRlcnNcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tZWRpdFxcXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtZWRpdFxcXCI+RWRpdCBmaWx0ZXJzPC9zcGFuPlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDxoMyBjbGFzcz1cXFwiaW5saW5lLWhlYWRpbmdcXFwiIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjp0aXRsZS1maWx0ZXJzXFxcIj5GaWx0ZXJzPC9oMz5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJhcHBsaWVkLWZpbHRlcnNcXFwiPlxcbiAgICAgICAgPGVtIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjpmaWx0ZXJzLWxvYWRpbmdcXFwiPkxvYWRpbmcuLi48L2VtPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgaWQ9XFxcImZpbHRlci1wb3B1cFxcXCI+PC9kaXY+XFxuXCIpO1xudmFyIHN1bW1hcnlUZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8JSBpZiAoIWNvdW50QXBwbGllZCkgeyAlPlxcbiAgPGVtIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLW5vbmUtYXBwbGllZFxcXCI+Tm8gZmlsdGVycyBhcHBsaWVkPC9lbT5cXG48JSB9IGVsc2UgeyAlPlxcbiAgPHNwYW4+XFxuICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gc2hvdy1maWx0ZXItZGV0YWlsc1xcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tZXllLW9wZW5cXFwiPjwvc3Bhbj5cXG4gICAgICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6ZmlsdGVycy1zaG93LXNldHRpbmdzXFxcIj5TaG93IGZpbHRlciBzZXR0aW5nczwvc3Bhbj5cXG4gICAgICAoPGI+PCU9IGNvdW50QXBwbGllZCAlPjwvYj4pXFxuICAgIDwvYnV0dG9uPlxcbiAgPC9zcGFuPlxcbjwlIH0gJT5cXG5cIik7XG52YXIgZGV0YWlsc1RlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjwlIF8oYXBwbGllZCkuZWFjaChmdW5jdGlvbihmaWx0ZXIpIHsgJT5cXG4gIDxoNT5cXG4gICAgPGEgaHJlZj1cXFwiI2ZpbHRlci1kZXRhaWwtPCU9IGZpbHRlci5pZCAlPlxcXCIgZGF0YS10b2dnbGU9XFxcImNvbGxhcHNlXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCI+PCU9IGZpbHRlci5uYW1lICU+PC9hPlxcbiAgICAoPCU9IGZpbHRlci5kZXRhaWwubGVuZ3RoICU+KVxcbiAgPC9oNT5cXG4gIDx1bCBpZD1cXFwiZmlsdGVyLWRldGFpbC08JT0gZmlsdGVyLmlkICU+XFxcIiBjbGFzcz1cXFwiY29sbGFwc2VcXFwiPlxcbiAgICA8JSBfKGZpbHRlci5kZXRhaWwpLmVhY2goZnVuY3Rpb24oZGV0YWlsKSB7ICU+XFxuICAgICAgPGxpPjwlPSBkZXRhaWwgJT48L2xpPlxcbiAgICA8JSB9KSAlPlxcbiAgPC91bD5cXG48JSB9KSAlPlxcblxcbjxkaXY+XFxuICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRlZmF1bHQgaGlkZS1maWx0ZXItZGV0YWlsc1xcXCI+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWV5ZS1jbG9zZVxcXCI+PC9zcGFuPlxcbiAgICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6ZmlsdGVycy1oaWRlLWRldGFpbHNcXFwiPkhpZGUgZmlsdGVyIGRldGFpbHM8L3NwYW4+XFxuICA8L2J1dHRvbj5cXG48L2Rpdj5cXG5cIik7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZURhc2guVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuc2hvdy1maWx0ZXJzJzogJ3Nob3dGaWx0ZXInLFxuICAgICdjbGljayAuc2hvdy1maWx0ZXItZGV0YWlscyc6ICdzaG93RmlsdGVyRGV0YWlscycsXG4gICAgJ2NsaWNrIC5oaWRlLWZpbHRlci1kZXRhaWxzJzogJ2hpZGVGaWx0ZXJEZXRhaWxzJ1xuICB9LFxuICBcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuZmluaXNoZWRGaXJzdExvYWQgPSBmYWxzZTtcblx0dGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuYXBwLmZpbHRlciwgJ2NhbmNlbCcsIHRoaXMuaGlkZUZpbHRlcik7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmFwcC5maWx0ZXIsICdhcHBseScsIHRoaXMuYXBwbHlGaWx0ZXIpO1xuICAgIHRoaXMuYXBwLnNldHRpbmdzLmxvYWQoKS5kb25lKF8oZnVuY3Rpb24oKSB7XG4gICAgXHQvLyBFeHRyYWN0IGRlZmF1bHQgZGF0ZXMgZnJvbSBHbG9iYWwgU2V0dGluZ3MuXG4gICAgXHR2YXIgYmxvYiA9IHt9O1xuICAgIFx0Ly8gQU1QLTE5MjU0LCBBTVAtMjA1Mzc6IG92ZXJyaWRlIHRoZSBcImRhdGVcIiByYW5nZSB3aXRoIHRoZSBEYXNoYm9hcmRzLXNwZWNpZmljIG9uZSBmcm9tIHRoZSBzZXR0aW5ncyBibG9iIChhIGhhY2suLi4pIFxuICAgIFx0dGhpcy5hcHAuZmlsdGVyLmV4dHJhY3REYXRlcyh0aGlzLmFwcC5zZXR0aW5ncy5tb2RlbHMsIGJsb2IsICdkYXNoYm9hcmQtZGVmYXVsdC1taW4tZGF0ZScsICdkYXNoYm9hcmQtZGVmYXVsdC1tYXgtZGF0ZScpO1xuICAgIFx0XG5cdCAgICB0aGlzLmFwcC5maWx0ZXIubG9hZGVkLmRvbmUoXyhmdW5jdGlvbigpIHtcblx0ICAgIFx0Y29uc29sZS5lcnJvcignZmlsdGVycyBsb2FkZWQnKTtcblx0ICAgICAgdGhpcy5hcHAuc3RhdGUucmVnaXN0ZXIodGhpcywgJ2ZpbHRlcnMnLCB7XG5cdCAgICAgICAgLy8gbmFtZXNwYWNlIHNlcmlhbGl6ZWQgZmlsdGVycyBzbyB3ZSBjYW4gaG9vayBpbiBleHRyYSBzdGF0ZSB0byBzdG9yZVxuXHQgICAgICAgIC8vIGxhdGVyIGlmIGRlc2lyZWQgKGFueXRoaW5nIGRhc2hib2FyZHMtdWkgcmVsYXRlZCwgZm9yIGV4YW1wbGUpXG5cdCAgICAgICAgZ2V0OiBfKGZ1bmN0aW9uKCkgeyBcblx0ICAgICAgICBcdHJldHVybiB7ZmlsdGVyOiB0aGlzLmFwcC5maWx0ZXIuc2VyaWFsaXplKCkgfTsgXG5cdCAgICAgICAgfSkuYmluZCh0aGlzKSxcblx0ICAgICAgICBzZXQ6IF8oZnVuY3Rpb24oc3RhdGUpIHtcblx0ICAgICAgICBcdGlmIChzdGF0ZS5maWx0ZXIub3RoZXJGaWx0ZXJzICE9PSB1bmRlZmluZWQgJiYgc3RhdGUuZmlsdGVyLm90aGVyRmlsdGVycy5kYXRlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBcdFx0Y29uc29sZS5sb2coJ1VzaW5nIHNhdmVkIGZpbHRlcnMuJyk7XHQgICAgICAgIFx0XHRcblx0ICAgICAgICBcdH0gZWxzZSB7XG5cdCAgICAgICAgXHRcdGNvbnNvbGUubG9nKCdVc2luZyBkZWZhdWx0IGZpbHRlciBkYXRlcy4nKTtcblx0ICAgICAgICBcdFx0c3RhdGUuZmlsdGVyID0gYmxvYjtcblx0ICAgICAgICBcdH1cblx0ICAgICAgICBcdHRoaXMuYXBwLmZpbHRlci5kZXNlcmlhbGl6ZShzdGF0ZS5maWx0ZXIpO1xuXHQgICAgICAgIFx0dGhpcy5hcHAuZmlsdGVyLmZpbmlzaGVkRmlyc3RMb2FkID0gdHJ1ZTtcblx0ICAgICAgICB9KS5iaW5kKHRoaXMpLFxuXHQgICAgICAgIGVtcHR5OiB7ZmlsdGVyOiB7fX1cblx0ICAgICAgfSk7XG5cdCAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICB9KS5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoKSk7XG4gICAgdGhpcy5hcHAuZmlsdGVyLnNldEVsZW1lbnQodGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcjZmlsdGVyLXBvcHVwJykpO1xuICAgIHRoaXMuaGlkZUZpbHRlcigpO1xuICAgIHRoaXMuYXBwLmZpbHRlci5sb2FkZWRcbiAgICAgIC5kb25lKF8odGhpcy5yZW5kZXJBcHBsaWVkKS5iaW5kKHRoaXMpKVxuICAgICAgLmZhaWwoXyhmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kKCcuYXBwbGllZC1maWx0ZXJzJykuaHRtbCgnPHN0cm9uZyBjbGFzcz1cInRleHQtZGFuZ2VyIGZpbHRlcnMtZXJyXCI+JyArXG4gICAgICAgICAgJ0ZhaWxlZCB0byBsb2FkIGZpbHRlcnM8L3N0cm9uZz4gPGEgaHJlZj1cIlwiIGNsYXNzPVwiYnRuIGJ0bi13YXJuaW5nIGJ0bi1zbVwiPicgK1xuICAgICAgICAgICc8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tcmVmcmVzaFwiPjwvc3Bhbj4gUmVmcmVzaCBwYWdlPC9hPicpO1xuICAgICAgICB0aGlzLiQoJ2J1dHRvbicpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVuZGVyQXBwbGllZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlcnMgPSB0aGlzLmFwcC5maWx0ZXIuc2VyaWFsaXplVG9Nb2RlbHMoKTtcbiAgICB2YXIgY291bnRBcHBsaWVkID0gXyhmaWx0ZXJzLmNvbHVtbkZpbHRlcnMpLmtleXMoKS5sZW5ndGg7XG4gICAgY291bnRBcHBsaWVkICs9ICEhZmlsdGVycy5vdGhlckZpbHRlcnM7XG4gICAgdGhpcy4kKCcuYXBwbGllZC1maWx0ZXJzJykuaHRtbChzdW1tYXJ5VGVtcGxhdGUoeyBjb3VudEFwcGxpZWQ6IGNvdW50QXBwbGllZCB9KSk7XG4gICAgdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00odGhpcy5lbCk7XG4gIH0sXG5cbiAgc2hvd0ZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hcHAuZmlsdGVyLnNob3dGaWx0ZXJzKCk7XG4gICAgdGhpcy4kKCcjZmlsdGVyLXBvcHVwJykuc2hvdygpO1xuICB9LFxuXG4gIGhpZGVGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJCgnI2ZpbHRlci1wb3B1cCcpLmhpZGUoKTtcbiAgfSxcblxuICBhcHBseUZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gdG9kbzogYWN0dWFsbHkgZG8gYW4gZWZmZWN0IGZvciBjaGFuZ2VkIGZpbHRlcnMuLi5cbiAgICB0aGlzLmhpZGVGaWx0ZXIoKTtcbiAgICB0aGlzLnJlbmRlckFwcGxpZWQoKTtcbiAgfSxcblxuICBzaG93RmlsdGVyRGV0YWlsczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlcnMgPSB0aGlzLmFwcC5maWx0ZXIuc2VyaWFsaXplVG9Nb2RlbHMoKTtcbiAgICB2YXIgYXBwbGllZCA9IF8oZmlsdGVycy5jb2x1bW5GaWx0ZXJzKS5tYXAoZnVuY3Rpb24oZmlsdGVyLCBrZXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGZpbHRlci5maWx0ZXJOYW1lIHx8IGtleSxcbiAgICAgICAgaWQ6IGtleS5yZXBsYWNlKC9bXlxcd10vZywgJycpLCAgLy8gcmVtb3ZlIGFueXRoaW5nIG5vbi1hbHBoYW51bVxuICAgICAgICBkZXRhaWw6IF8oZmlsdGVyKS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgXHRpZiAodmFsdWUuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFx0XHRyZXR1cm4gdmFsdWUuZ2V0KCduYW1lJyk7XG4gICAgICAgIFx0fSBlbHNlIHsgICAgICAgXHRcdFxuICAgICAgICBcdFx0Ly8gVG8gZml4IHByb2JsZW0gd2l0aCBkYXRlcy5cbiAgICAgICAgXHRcdGlmICh2YWx1ZSAhPT0ga2V5ICYmIHZhbHVlICE9PSBmaWx0ZXIuZmlsdGVyTmFtZSkge1xuICAgICAgICBcdFx0XHRyZXR1cm4gdmFsdWU7XG4gICAgICAgIFx0XHR9XG4gICAgICAgIFx0fVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBpZiAoZmlsdGVycy5vdGhlckZpbHRlcnMpIHtcbiAgICAgIC8vIEN1cnJlbnRseSBhc3N1bWVzIHRoYXQgYW55IG90aGVyRmlsdGVycyBqdXN0IGltcGxpZXMgRGF0ZSBSYW5nZVxuICAgICAgLy8gLi4uIHRoZXJlIGlzIG5vIG9idmlvdXMgd2F5IHRvIGdldCBuaWNlIHN0cmluZ3Mgb3V0LlxuICAgICAgdmFyIGRhdGVSYW5nZSA9IGZpbHRlcnMub3RoZXJGaWx0ZXJzLmRhdGU7XG4gICAgICB2YXIgZGF0ZVJhbmdlVGV4dCA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmRhdGUtcmFuZ2VcIixcIkRhdGUgUmFuZ2VcIik7XG5cdCAgYXBwbGllZC5wdXNoKHtcbiAgICAgICAgbmFtZTogZGF0ZVJhbmdlVGV4dCxcbiAgICAgICAgZGV0YWlsOiBbZGF0ZVJhbmdlLnN0YXJ0ICsgJyZtZGFzaDsnICsgZGF0ZVJhbmdlLmVuZF1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLiQoJy5hcHBsaWVkLWZpbHRlcnMnKS5odG1sKGRldGFpbHNUZW1wbGF0ZSh7IGFwcGxpZWQ6IGFwcGxpZWQgfSkpO1xuICAgIHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKHRoaXMuZWwpO1xuICB9LFxuXG4gIGhpZGVGaWx0ZXJEZXRhaWxzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbmRlckFwcGxpZWQoKTtcbiAgfVxuXG59KTtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xudmFyIGZvb3RlclRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxzdHlsZT5cXG4uZm9vdGVyVGV4dCB7XFxuICBwYWRkaW5nOiAwO1xcbiAgZm9udC1mYW1pbHk6IGFyaWFsO1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiKDIyMSwgMjIxLCAyMjEpO1xcbiAgYm94LXNoYWRvdzogMCAxcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxufVxcbi5mb290ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzhCOEI4QjtcXG4gIGNvbG9yOiAjRkZGO1xcbiAgbWFyZ2luLXRvcDogMDtcXG4gIHBhZGRpbmctYm90dG9tOiAxMHB4O1xcbiAgcGFkZGluZy10b3A6IDEwcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbi5kZ2ZfZm9vdGVyIHtcXG4gIGNvbG9yOiAjOEI4QjhCO1xcbiAgbGluZS1oZWlnaHQ6IDE4cHg7XFxuICBtYXJnaW46IDE1cHggMDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuLmRnZl9mb290ZXIgaW1nIHtcXG4gIGxpbmUtaGVpZ2h0OiAxOHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogNXB4O1xcbn1cXG48L3N0eWxlPlxcblxcbjxkaXYgY2xhc3M9XFxcImNvbC14cy0xMlxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJwYW5lbCBkYXNoLXJvdyBmb290ZXJUZXh0XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZGdmX2Zvb3RlclxcXCI+XFxuICAgICAgPGltZyBzcmM9XFxcIi9URU1QTEFURS9hbXBUZW1wbGF0ZS9pbWdfMi9kZ2ZfbG9nb19ib3R0b20uZ2lmXFxcIiBjbGFzcz1cXFwiZGdmX2xvZ29fZm9vdGVyXFxcIj48YnI+XFxuICAgICAgMTExMCBWZXJtb250IEF2ZSBOVywgV2FzaGluZ3RvbiwgRC5DLiAyMDAwNSwgVVNBPGJyPlxcbiAgICAgIGluZm9AZGV2ZWxvcG1lbnRnYXRld2F5Lm9yZywgVGVsOiArMS4yMDIuNTcyLjkyMDAsIEZheDogKzEgMjAyLjU3Mi45MjkwXFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCIpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdyb3cnLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbChmb290ZXJUZW1wbGF0ZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59KTtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xudmFyIGhlYWRlclRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcImNvbC14cy0xMlxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJwYW5lbCBkYXNoLXJvdyBmb290ZXJUZXh0XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keSBkYXNoLWhlYWRlclxcXCI+XFxuICAgICAgPGgxIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjp0aXRsZVxcXCIgY2xhc3M9XFxcImlubGluZS1oZWFkaW5nXFxcIj5cXG4gICAgICAgIEFNUFxcbiAgICAgICAgPHNtYWxsIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjp0aXRsZS1kYXNoYm9hcmRzXFxcIj5EYXNoYm9hcmRzPC9zbWFsbD5cXG4gICAgICA8L2gxPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5WaWV3LmV4dGVuZCh7XG5cbiAgY2xhc3NOYW1lOiAncm93JyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmh0bWwoaGVhZGVyVGVtcGxhdGUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufSk7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcblxudmFyIFN0YXRlTG9hZEVycm9yID0gcmVxdWlyZSgnYW1wLXN0YXRlL2luZGV4JykuU3RhdGVMb2FkRXJyb3I7XG5cbnZhciBIZWFkZXIgPSByZXF1aXJlKCcuL2hlYWRlcicpO1xudmFyIENvbnRyb2xzID0gcmVxdWlyZSgnLi9jb250cm9scycpO1xudmFyIENoYXJ0c1ZpZXcgPSByZXF1aXJlKCcuL2NoYXJ0cycpO1xudmFyIENoYXJ0cyA9IHJlcXVpcmUoJy4uL21vZGVscy9jaGFydHMtY29sbGVjdGlvbicpO1xudmFyIEZvb3RlciA9IHJlcXVpcmUoJy4vZm9vdGVyJyk7XG5cbnZhciBUb3BzQ2hhcnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvY2hhcnQtdG9wcycpO1xudmFyIFByZWRpY3RhYmlsaXR5Q2hhcnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvY2hhcnQtYWlkLXByZWRpY3RhYmlsaXR5Jyk7XG52YXIgRnVuZGluZ1R5cGVDaGFydCA9IHJlcXVpcmUoJy4uL21vZGVscy9jaGFydC1mdW5kaW5nLXR5cGUnKTtcblxudmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuPC9kaXY+XFxuXCIpO1xudmFyIG1vZGFsVGVtcGxhdGUgPSBfLnRlbXBsYXRlKFwiPGRpdiBjbGFzcz1cXFwibW9kYWwgZmFkZVxcXCIgaWQ9XFxcIjwlPSBtLmlkICU+XFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcImRpYWxvZ1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJteU1vZGFsTGFiZWxcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZyA8JT0gbS5zcGVjaWFsQ2xhc3MgJT5cXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1jb250ZW50XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1oZWFkZXJcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+PHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPiZ0aW1lczs8L3NwYW4+PHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmNsb3NlXFxcIiBjbGFzcz1cXFwic3Itb25seVxcXCI+Q2xvc2U8L3NwYW4+PC9idXR0b24+XFxuICAgICAgICA8aDQgY2xhc3M9XFxcIm1vZGFsLXRpdGxlIHRleHQtPCU9IG0udG9uZSAlPlxcXCIgZGF0YS1pMThuPVxcXCI8JT0gbS5pMThuVGl0bGUgJT5cXFwiPjwlPSBtLnRpdGxlICU+PC9oND5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5XFxcIj5cXG4gICAgICAgIDwlIGlmIChtLmNvbnRlbnQpIHsgJT5cXG4gICAgICAgICAgPCU9IG0uY29udGVudCAlPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgPCUgaWYgKG0ubWVzc2FnZXMpIHsgJT5cXG4gICAgICAgICAgPCUgXyhtLm1lc3NhZ2VzKS5lYWNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHsgJT5cXG4gICAgICAgICAgICA8cD48JT0gbWVzc2FnZSAlPjwvcD5cXG4gICAgICAgICAgPCUgfSkgJT5cXG4gICAgICAgIDwlIH0gJT5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXJcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLTwlPSBtLnRvbmUgJT5cXFwiIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCI+Q2xvc2U8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIik7XG5cbnZhciBFbmFibGVkQ2hhcnRzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL21vZGVscy9lbmFibGVkLWNoYXJ0cy1jb2xsZWN0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDsgICAgXG5cbiAgICB0aGlzLmhlYWRlciA9IG5ldyBIZWFkZXIoeyBhcHA6IHRoaXMuYXBwIH0pOyAgICBcbiAgICB0aGlzLmFwcC5zZXR0aW5ncy5sb2FkKCk7ICAvLyBtYXliZSBzaG91bGQgZ28gaW4gcmVuZGVyIG9yIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBhbHJlYWR5IGRvIG90aGVyIGZldGNoZXMgb24gaW5pdCBzby4uLlxuICAgIHRoaXMuY29udHJvbHMgPSBuZXcgQ29udHJvbHMoeyBhcHA6IHRoaXMuYXBwIH0pO1xuXG4gICAgLy8gQU1QLTE5NTQ1OiBXZSBpbnN0YW50aWF0ZSB0aGUgY29sbGVjdGlvbiBvZiBlbmFibGVkIGNoYXJ0cyAoZnJvbSBGTSkgYW5kIHVzZSBpdCB0byBlbmFibGUgb3Igbm90IGVhY2ggY2hhcnQuXG4gICAgdmFyIGVuYWJsZWRDaGFydHNGTSA9IG5ldyBFbmFibGVkQ2hhcnRzQ29sbGVjdGlvbigpO1xuICAgIGVuYWJsZWRDaGFydHNGTS5mZXRjaERhdGEoKTtcbiAgICBpZihlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnZXJyb3InKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgXHQvLyBUaGUgc2FtZSBlbmRwb2ludCB3aWxsIHNlbmQgYW4gZXJyb3IgaWYgJ0RBU0hCT0FSRFMnIGlzIG5vdCBhY3RpdmUgaW4gdGhlIEZlYXR1cmUgTWFuYWdlci5cbiAgICBcdHdpbmRvdy5sb2NhdGlvbiA9ICcvJztcbiAgICB9XG4gICAgdmFyIGNvbCA9IFtdO1xuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnVG9wIERvbm9ycyd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnVG9wIERvbm9yIEFnZW5jaWVzJywgYmlnOiBmYWxzZSwgdmlldzogJ2JhcicgfSxcbiAgXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvdG9wcy9kbycgfSkpO1xuICAgIH1cbiAgICBpZihfLmZpbmQoZW5hYmxlZENoYXJ0c0ZNLm1vZGVsc1swXS5nZXQoJ0RBU0hCT0FSRFMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtID09PSAgJ1RvcCBEb25vciBHcm91cCd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnVG9wIERvbm9yIEdyb3VwcycsIGJpZzogZmFsc2UsIHZpZXc6ICdiYXInIH0sXG4gIFx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL3RvcHMvZGcnIH0pKTtcbiAgICB9XG4gICAgaWYoXy5maW5kKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdEQVNIQk9BUkRTJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSA9PT0gICdUb3AgUmVnaW9ucyd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnVG9wIFJlZ2lvbnMnLCBiaWc6IGZhbHNlLCB2aWV3OiAnYmFyJyB9LFxuXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvdG9wcy9yZScgfSkpO1xuICAgIH1cbiAgICBpZihfLmZpbmQoZW5hYmxlZENoYXJ0c0ZNLm1vZGVsc1swXS5nZXQoJ0RBU0hCT0FSRFMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtID09PSAgJ1RvcCBTZWN0b3JzJ30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgVG9wc0NoYXJ0KFxuICBcdCAgICAgICAgICB7IG5hbWU6ICdUb3AgU2VjdG9ycycsIGJpZzogZmFsc2UsIHZpZXc6ICdiYXInIH0sXG5cdCAgICAgICAgICB7IGFwcDogdGhpcy5hcHAsIHVybDogJy9yZXN0L2Rhc2hib2FyZC90b3BzL3BzJyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnQWlkIFByZWRpY3RhYmlsaXR5J30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgUHJlZGljdGFiaWxpdHlDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnQWlkIFByZWRpY3RhYmlsaXR5JyB9LFxuXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvYWlkLXByZWRpY3RhYmlsaXR5JyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnRnVuZGluZyBUeXBlJ30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgRnVuZGluZ1R5cGVDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnRnVuZGluZyBUeXBlJyB9LFxuXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvZnR5cGUnIH0pKTtcbiAgICB9XG4gICAgaWYoXy5maW5kKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdEQVNIQk9BUkRTJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSA9PT0gICdSZXNwb25zaWJsZSBPcmdhbml6YXRpb25zJ30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgVG9wc0NoYXJ0KFxuICBcdCAgICAgICAgICB7IG5hbWU6ICdSZXNwb25zaWJsZSBPcmdhbml6YXRpb25zJywgYmlnOiBmYWxzZSwgdmlldzogJ2JhcicgfSxcblx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL3RvcHMvcm8nIH0pKTtcbiAgICB9XG4gICAgaWYoXy5maW5kKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdEQVNIQk9BUkRTJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSA9PT0gICdCZW5lZmljaWFyeSBBZ2VuY2llcyd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnQmVuZWZpY2lhcnkgQWdlbmNpZXMnLCBiaWc6IGZhbHNlLCB2aWV3OiAnYmFyJyB9LFxuXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvdG9wcy9iYScgfSkpO1xuICAgIH1cbiAgICBpZihfLmZpbmQoZW5hYmxlZENoYXJ0c0ZNLm1vZGVsc1swXS5nZXQoJ0RBU0hCT0FSRFMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtID09PSAgJ0V4ZWN1dGluZyBBZ2VuY2llcyd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnRXhlY3V0aW5nIEFnZW5jaWVzJywgYmlnOiBmYWxzZSwgdmlldzogJ2JhcicgfSxcblx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL3RvcHMvZWEnIH0pKTtcbiAgICB9XG4gICAgaWYoXy5maW5kKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdEQVNIQk9BUkRTJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSA9PT0gICdJbXBsZW1lbnRpbmcgQWdlbmNpZXMnfSkpIHtcbiAgICBcdGNvbC5wdXNoKG5ldyBUb3BzQ2hhcnQoXG4gIFx0ICAgICAgICAgIHsgbmFtZTogJ0ltcGxlbWVudGluZyBBZ2VuY2llcycsIGJpZzogZmFsc2UsIHZpZXc6ICdiYXInIH0sXG5cdCAgICAgICAgICB7IGFwcDogdGhpcy5hcHAsIHVybDogJy9yZXN0L2Rhc2hib2FyZC90b3BzL2lhJyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnUGVhY2UtYnVpbGRpbmcgYW5kIFN0YXRlLWJ1aWxkaW5nIEdvYWxzJ30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgVG9wc0NoYXJ0KFxuICAgIFx0XHRcdHsgbmFtZTogJ1BlYWNlLWJ1aWxkaW5nIGFuZCBTdGF0ZS1idWlsZGluZyBHb2FscycsIGJpZzogdHJ1ZSwgc2hvd0NhdGVnb3JpZXNJbmZvOiB0cnVlLCB2aWV3OiAncGllJyB9LFxuICAgIFx0XHRcdHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL3RvcHMvbmRkJyB9KSk7XG4gICAgfVxuICAgICAgIFxuICAgIHZhciBjaGFydHNDb2xsZWN0aW9uID0gbmV3IENoYXJ0cyhjb2wsIHsgYXBwOiB0aGlzLmFwcCB9KTtcbiAgICB0aGlzLmNoYXJ0cyA9IG5ldyBDaGFydHNWaWV3KHtcbiAgICAgIGFwcDogdGhpcy5hcHAsXG4gICAgICBjb2xsZWN0aW9uOiBjaGFydHNDb2xsZWN0aW9uXG4gICAgfSk7XG5cbiAgICB0aGlzLmZvb3RlciA9IG5ldyBGb290ZXIoeyBhcHA6IHRoaXMuYXBwIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTtcbiAgICB0aGlzLiQoJy5jb250YWluZXInKS5odG1sKFtcbiAgICAgIHRoaXMuaGVhZGVyLnJlbmRlcigpLmVsLFxuICAgICAgdGhpcy5jb250cm9scy5yZW5kZXIoKS5lbCxcbiAgICAgIHRoaXMuY2hhcnRzLnJlbmRlcigpLmVsLFxuICAgICAgdGhpcy5mb290ZXIucmVuZGVyKCkuZWxcbiAgICBdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBtb2RhbDogZnVuY3Rpb24odGl0bGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXyh7XG4gICAgICB0aXRsZTogdGl0bGUsXG4gICAgICBpZDogXy51bmlxdWVJZCgnbW9kYWwnKVxuICAgIH0pLmV4dGVuZChvcHRpb25zKTtcbiAgICB0aGlzLiRlbC5wYXJlbnQoKS5hcHBlbmQobW9kYWxUZW1wbGF0ZSh7bTogb3B0aW9uc30pKTtcbiAgICB2YXIgdGhpc01vZGFsID0gdGhpcy4kZWwucGFyZW50KCkuZmluZCgnIycgKyBvcHRpb25zLmlkKTtcbiAgICBpZiAob3B0aW9ucy5ib2R5RWwpIHsgdGhpc01vZGFsLmZpbmQoJy5tb2RhbC1ib2R5JykuaHRtbChvcHRpb25zLmJvZHlFbCk7IH1cbiAgICB0aGlzTW9kYWwubW9kYWwoKTtcbiAgICByZXR1cm4gdGhpc01vZGFsWzBdOyAgLy8gdGhlIGFjdHVhbCBET00gZWxlbWVudFxuICB9XG5cbn0pO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZURhc2ggPSByZXF1aXJlKCcuLi9iYWNrYm9uZS1kYXNoJyk7XG52YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKFwiPGRpdiBjbGFzcz1cXFwidGFiLWNvbnRlbnQgZmlsdGVyLW9wdGlvbnNcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwidGFiLXBhbmUgYWN0aXZlXFxcIj5cXG4gICAgPHVsIGNsYXNzPVxcXCJzdWItZmlsdGVycy10aXRsZXMgbmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZFxcXCI+XFxuICAgICAgPCUgXyhzZXR0aW5ncy5nZXRWaXNpYmxlKCkpLmVhY2goZnVuY3Rpb24oc2V0dGluZykgeyAlPlxcbiAgICAgICAgPGxpIDwlPSBzZXR0aW5nLmlkID09PSBjdXJyZW50LmlkID8gJ2NsYXNzPVxcXCJhY3RpdmVcXFwiJyA6ICcnICU+PlxcbiAgICAgICAgICA8YSBjbGFzcz1cXFwic2V0dGluZy1zZWxlY3RcXFwiIGhyZWY9XFxcIiM8JT0gc2V0dGluZy5pZCAlPlxcXCI+PHNwYW4+PCU9IHNldHRpbmcuZ2V0KCduYW1lJykgJT48L3NwYW4+PC9hPlxcbiAgICAgICAgPC9saT5cXG4gICAgICA8JSB9KSAlPlxcbiAgICA8L3VsPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJzdWItZmlsdGVycy1jb250ZW50XFxcIj5cXG4gICAgICA8c2VsZWN0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgc2V0dGluZy12YWx1ZVxcXCI+XFxuICAgICAgICA8JSBfKGN1cnJlbnQuZ2V0KCdvcHRpb25zJykpLmVhY2goZnVuY3Rpb24ob3B0aW9uKSB7ICU+XFxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjwlPSBvcHRpb24udmFsdWUgJT5cXFwiIDwlPSBvcHRpb24uc2VsZWN0ZWQgPyAnc2VsZWN0ZWQ9XFxcInNlbGVjdGVkXFxcIicgOiAnJyAlPj48JT0gb3B0aW9uLm5hbWUgJT48L29wdGlvbj5cXG4gICAgICAgIDwlIH0pICU+XFxuICAgICAgPC9zZWxlY3Q+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCIpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLnNldHRpbmctc2VsZWN0JzogJ3NlbGVjdFNldHRpbmcnLFxuICAgICdjaGFuZ2UgLnNldHRpbmctdmFsdWUnOiAnY2hhbmdlU2V0dGluZydcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50KSB7IHRoaXMuY3VycmVudCA9IHRoaXMuYXBwLnNldHRpbmdzLmdldFZpc2libGUoKVswXTsgfVxuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoe1xuICAgICAgc2V0dGluZ3M6IHRoaXMuYXBwLnNldHRpbmdzLFxuICAgICAgY3VycmVudDogdGhpcy5jdXJyZW50XG4gICAgfSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNlbGVjdFNldHRpbmc6IGZ1bmN0aW9uKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7ICAvLyBkb24ndCBjaGFuZ2UgVVJMXG4gICAgdmFyIHNldHRpbmdJZCA9IGUuY3VycmVudFRhcmdldC5oYXNoLnNsaWNlKDEpOyAgLy8gcmVtb3ZlcyAnIydcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmFwcC5zZXR0aW5ncy5nZXQoc2V0dGluZ0lkKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9LFxuXG4gIGNoYW5nZVNldHRpbmc6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgb3B0aW9uSWQgPSBlLmN1cnJlbnRUYXJnZXQudmFsdWU7XG4gICAgdGhpcy5jdXJyZW50LnNlbGVjdChvcHRpb25JZCk7XG4gIH1cblxufSk7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcbnZhciBNb2RhbFZpZXcgPSByZXF1aXJlKCcuL3NldHRpbmdzLW1vZGFsJyk7XG52YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKFwiPGRpdiBjbGFzcz1cXFwiY29sLXhzLTEyIGNvbC1zbS02IGNvbC1tZC0zXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcInBhbmVsXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuICAgICAgPGgzIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpkYXNoYm9hcmQtc2V0dGluZ3NcXFwiIGNsYXNzPVxcXCJpbmxpbmUtaGVhZGluZ1xcXCI+U2V0dGluZ3M8L2gzPlxcbiAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tZGVmYXVsdCBwdWxsLXJpZ2h0IGRhc2gtc2V0dGluZ3MtYnV0dG9uXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWVkaXRcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpzZXR0aW5ncy1lZGl0XFxcIj5lZGl0IHNldHRpbmdzPC9zcGFuPlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5kYXNoLXNldHRpbmdzLWJ1dHRvbic6ICdlZGl0U2V0dGluZ3MnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XG4gICAgdGhpcy5tb2RhbFZpZXcgPSBuZXcgTW9kYWxWaWV3KHsgYXBwOiB0aGlzLmFwcCwgY29sbGVjdGlvbjogdGhpcy5jb2xsZWN0aW9uIH0pO1xuXG4gICAgdGhpcy5hcHAuc2V0dGluZ3MubG9hZCgpLmRvbmUoXyhmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYXBwLnN0YXRlLnJlZ2lzdGVyKHRoaXMsICdzZXR0aW5ncycsIHtcbiAgICAgICAgZ2V0OiB0aGlzLmFwcC5zZXR0aW5ncy50b0FQSSxcbiAgICAgICAgc2V0OiB0aGlzLmFwcC5zZXR0aW5ncy5mcm9tU3RhdGVcbiAgICAgIH0pO1xuICAgIH0pLmJpbmQodGhpcykpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTsgIFxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGVkaXRTZXR0aW5nczogZnVuY3Rpb24oKSB7XG5cdHZhciBzcGVjaWFsQ2xhc3MgPSAnZGFzaC1zZXR0aW5ncy1tb2RhbCc7XG4gICAgdGhpcy5hcHAubW9kYWwoJ1NldHRpbmdzJywge1xuICAgICAgc3BlY2lhbENsYXNzOiBzcGVjaWFsQ2xhc3MsXG4gICAgICBib2R5RWw6IHRoaXMubW9kYWxWaWV3LnJlbmRlcigpLmVsLFxuICAgICAgaTE4blRpdGxlOiAnYW1wLmRhc2hib2FyZDpkYXNoYm9hcmQtc2V0dGluZ3MnXG4gICAgfSk7XG4gICAgXG4gICAgLy8gVHJhbnNsYXRlIG1vZGFsIHBvcHVwLlxuICAgIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTSgkKFwiLlwiICsgc3BlY2lhbENsYXNzKSk7XG4gIH1cblxufSk7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcbnZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMTIgY29sLXNtLTYgY29sLW1kLTRcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicGFuZWxcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG4gICAgICA8aDMgZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOnNoYXJlLWRhc2hib2FyZC10b3BcXFwiIGNsYXNzPVxcXCJpbmxpbmUtaGVhZGluZ1xcXCI+U2hhcmU8L2gzPlxcbiAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tZGVmYXVsdCBwdWxsLXJpZ2h0IGRhc2gtc2hhcmUtYnV0dG9uXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWxpbmtcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpzaGFyZS1saW5rXFxcIj5saW5rPC9zcGFuPlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblxcbjxkaXYgY2xhc3M9XFxcImRhc2gtc2hhcmUtbW9kYWwgbW9kYWwgZmFkZVxcXCIgaWQ9XFxcIjwlPSBkZXRhaWxzLmlkICU+XFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcImRpYWxvZ1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJteU1vZGFsTGFiZWxcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZ1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLXByaW1hcnlcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmcgZml4LXRpdGxlLWhlaWdodFxcXCI+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIj48c3BhbiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvc3Bhbj48c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6Y2xvc2VcXFwiIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5DbG9zZTwvc3Bhbj48L2J1dHRvbj5cXG4gICAgICAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpzaGFyZS1kYXNoYm9hcmRcXFwiPlNoYXJlIHRoaXMgZGFzaGJvYXJkIHZpZXc8L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuICAgICAgICA8Zm9ybSByb2xlPVxcXCJmb3JtXFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpzaGFyZS1saW5rXFxcIiBmb3I9XFxcImRhc2gtc2hhcmUtdXJsXFxcIj5MaW5rPC9sYWJlbD5cXG4gICAgICAgICAgPGlucHV0IHR5cGU9XFxcInVybFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgaWQ9XFxcImRhc2gtc2hhcmUtdXJsXFxcIiAvPlxcbiAgICAgICAgPC9mb3JtPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWZvb3RlclxcXCI+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCIgZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmNsb3NlXFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIj5DbG9zZTwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5kYXNoLXNoYXJlLWJ1dHRvbic6ICdzaGFyZSdcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmh0bWwodGVtcGxhdGUoeyBkZXRhaWxzOiB7fSB9KSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2hhcmU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzYXZpbmcgPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpzYXZpbmctc3RhdGVcIixcIlNhdmluZyBkYXNoYm9hcmQgc3RhdGUsIHBsZWFzZSB3YWl0Li4uXCIpO1xuXHQgIFxuICAgIHRoaXMuJCgnI2Rhc2gtc2hhcmUtdXJsJylcbiAgICAgIC5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpXG4gICAgICAudmFsKHNhdmluZyk7XG5cbiAgICB2YXIgc3RhdGVCbG9iID0gdGhpcy5hcHAuc3RhdGUuZnJlZXplKCk7XG5cbiAgICB0aGlzLmxpc3RlblRvT25jZSh0aGlzLmFwcC5zYXZlZERhc2hlcywgJ3JlcXVlc3QnLCBmdW5jdGlvbihtb2RlbCwgeGhyKSB7XG4gICAgICAvLyB0aGlzIGhhcyB0byBiZSBzZXQgdXAgYmVmb3JlIC5jcmVhdGUsIHNvIHdlIGRvbid0IG1pc3MgaXRcbiAgICAgIHhoclxuICAgICAgICAuZG9uZShfKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpZCA9IG1vZGVsLmdldCgnaWQnKTtcbiAgICAgICAgICB0aGlzLmFwcC51cmwuaGFzaCh0aGlzLmFwcC5zdGF0ZS50b0hhc2goaWQpLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICAgICAgICB0aGlzLiQoJyNkYXNoLXNoYXJlLXVybCcpXG4gICAgICAgICAgICAucmVtb3ZlQXR0cignZGlzYWJsZWQnKVxuICAgICAgICAgICAgLnZhbCh0aGlzLmFwcC51cmwuZnVsbCgpKTtcbiAgICAgICAgfSkuYmluZCh0aGlzKSlcbiAgICAgICAgLmZhaWwoXyhmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLiQoJyNkYXNoLXNoYXJlLXVybCcpLnZhbCgnRXJyb3I6IGNvdWxkIG5vdCBzYXZlIGRhc2hib2FyZCBmb3Igc2hhcmluZy4nKTtcbiAgICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmFwcC5zYXZlZERhc2hlcy5jcmVhdGUoeyAgLy8gY3JlYXRlIGRvZXMgUE9TVFxuICAgICAgdGl0bGU6ICdEYXNoYm9hcmQnLFxuICAgICAgZGVzY3JpcHRpb246ICdTYXZlZCBkYXNoYm9hcmQnLFxuICAgICAgc3RhdGVCbG9iOiBzdGF0ZUJsb2JcbiAgICB9LCB7IGFwcDogdGhpcy5hcHAgfSk7XG5cbiAgICB0aGlzLiQoJy5kYXNoLXNoYXJlLW1vZGFsJykubW9kYWwoKTtcbiAgfVxuXG59KTtcbiIsIi8vIG52ZDMgZ29lcyBnbG9iYWwgc2lnaC4uLiBtYWtlIHN1cmUgZDMgaXMgYWxyZWFkeSBnbG9iYWxcbnJlcXVpcmUoJ252ZDMnKTtcblxuLy8gbWFrZSBzdHVwaWQgbnZkMyBkZXYgbG9ncyBnbyBhd2F5ID46KFxud2luZG93Lm52LmRldiA9IGZhbHNlO1xuXG4vLyBsb2FkIHVuZGVyc2NvcmUgbWl4aW5zXG5yZXF1aXJlKCcuL3VuZGVyc2NvcmUtdHJhbnNwb3NlJyk7XG5cbi8vIGxvYWQgY2Fudmcgc3R1ZmZcbndpbmRvdy5SR0JDb2xvciA9IHJlcXVpcmUoJy4vbGliLXNyYy9yZ2Jjb2xvcicpO1xucmVxdWlyZSgnLi9saWItc3JjL2NhbnZnJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNhbnZnOiB3aW5kb3cuY2Fudmdcbn07XG4iLCIvKlxuICogY2FudmcuanMgLSBKYXZhc2NyaXB0IFNWRyBwYXJzZXIgYW5kIHJlbmRlcmVyIG9uIENhbnZhc1xuICogTUlUIExpY2Vuc2VkIFxuICogR2FiZSBMZXJuZXIgKGdhYmVsZXJuZXJAZ21haWwuY29tKVxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2NhbnZnL1xuICpcbiAqIFJlcXVpcmVzOiByZ2Jjb2xvci5qcyAtIGh0dHA6Ly93d3cucGhwaWVkLmNvbS9yZ2ItY29sb3ItcGFyc2VyLWluLWphdmFzY3JpcHQvXG4gKi9cbihmdW5jdGlvbigpe1xuICAgIC8vIGNhbnZnKHRhcmdldCwgcylcbiAgICAvLyBlbXB0eSBwYXJhbWV0ZXJzOiByZXBsYWNlIGFsbCAnc3ZnJyBlbGVtZW50cyBvbiBwYWdlIHdpdGggJ2NhbnZhcycgZWxlbWVudHNcbiAgICAvLyB0YXJnZXQ6IGNhbnZhcyBlbGVtZW50IG9yIHRoZSBpZCBvZiBhIGNhbnZhcyBlbGVtZW50XG4gICAgLy8gczogc3ZnIHN0cmluZywgdXJsIHRvIHN2ZyBmaWxlLCBvciB4bWwgZG9jdW1lbnRcbiAgICAvLyBvcHRzOiBvcHRpb25hbCBoYXNoIG9mIG9wdGlvbnNcbiAgICAvLyAgICAgICBpZ25vcmVNb3VzZTogdHJ1ZSA9PiBpZ25vcmUgbW91c2UgZXZlbnRzXG4gICAgLy8gICAgICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlID0+IGlnbm9yZSBhbmltYXRpb25zXG4gICAgLy8gICAgICAgaWdub3JlRGltZW5zaW9uczogdHJ1ZSA9PiBkb2VzIG5vdCB0cnkgdG8gcmVzaXplIGNhbnZhc1xuICAgIC8vICAgICAgIGlnbm9yZUNsZWFyOiB0cnVlID0+IGRvZXMgbm90IGNsZWFyIGNhbnZhc1xuICAgIC8vICAgICAgIG9mZnNldFg6IGludCA9PiBkcmF3cyBhdCBhIHggb2Zmc2V0XG4gICAgLy8gICAgICAgb2Zmc2V0WTogaW50ID0+IGRyYXdzIGF0IGEgeSBvZmZzZXRcbiAgICAvLyAgICAgICBzY2FsZVdpZHRoOiBpbnQgPT4gc2NhbGVzIGhvcml6b250YWxseSB0byB3aWR0aFxuICAgIC8vICAgICAgIHNjYWxlSGVpZ2h0OiBpbnQgPT4gc2NhbGVzIHZlcnRpY2FsbHkgdG8gaGVpZ2h0XG4gICAgLy8gICAgICAgcmVuZGVyQ2FsbGJhY2s6IGZ1bmN0aW9uID0+IHdpbGwgY2FsbCB0aGUgZnVuY3Rpb24gYWZ0ZXIgdGhlIGZpcnN0IHJlbmRlciBpcyBjb21wbGV0ZWRcbiAgICAvLyAgICAgICBmb3JjZVJlZHJhdzogZnVuY3Rpb24gPT4gd2lsbCBjYWxsIHRoZSBmdW5jdGlvbiBvbiBldmVyeSBmcmFtZSwgaWYgaXQgcmV0dXJucyB0cnVlLCB3aWxsIHJlZHJhd1xuICAgIHRoaXMuY2FudmcgPSBmdW5jdGlvbiAodGFyZ2V0LCBzLCBvcHRzKSB7XG4gICAgICAgIC8vIG5vIHBhcmFtZXRlcnNcbiAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsICYmIHMgPT0gbnVsbCAmJiBvcHRzID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzdmdUYWdzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3ZnJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c3ZnVGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdmdUYWcgPSBzdmdUYWdzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgYy53aWR0aCA9IHN2Z1RhZy5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBjLmhlaWdodCA9IHN2Z1RhZy5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgc3ZnVGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGMsIHN2Z1RhZyk7XG4gICAgICAgICAgICAgICAgc3ZnVGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3ZnVGFnKTtcbiAgICAgICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHN2Z1RhZyk7XG4gICAgICAgICAgICAgICAgY2FudmcoYywgZGl2LmlubmVySFRNTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHN0b3JlIGNsYXNzIG9uIGNhbnZhc1xuICAgICAgICBpZiAodGFyZ2V0LnN2ZyAhPSBudWxsKSB0YXJnZXQuc3ZnLnN0b3AoKTtcbiAgICAgICAgdmFyIHN2ZyA9IGJ1aWxkKG9wdHMgfHwge30pO1xuICAgICAgICAvLyBvbiBpLmUuIDggZm9yIGZsYXNoIGNhbnZhcywgd2UgY2FuJ3QgYXNzaWduIHRoZSBwcm9wZXJ0eSBzbyBjaGVjayBmb3IgaXRcbiAgICAgICAgaWYgKCEodGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgdGFyZ2V0LmNoaWxkTm9kZXNbMF0ubm9kZU5hbWUgPT0gJ09CSkVDVCcpKSB0YXJnZXQuc3ZnID0gc3ZnO1xuICAgICAgICBcbiAgICAgICAgdmFyIGN0eCA9IHRhcmdldC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAodHlwZW9mKHMuZG9jdW1lbnRFbGVtZW50KSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gbG9hZCBmcm9tIHhtbCBkb2NcbiAgICAgICAgICAgIHN2Zy5sb2FkWG1sRG9jKGN0eCwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocy5zdWJzdHIoMCwxKSA9PSAnPCcpIHtcbiAgICAgICAgICAgIC8vIGxvYWQgZnJvbSB4bWwgc3RyaW5nXG4gICAgICAgICAgICBzdmcubG9hZFhtbChjdHgsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbG9hZCBmcm9tIHVybFxuICAgICAgICAgICAgc3ZnLmxvYWQoY3R4LCBzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkKG9wdHMpIHtcbiAgICAgICAgdmFyIHN2ZyA9IHsgb3B0czogb3B0cyB9O1xuICAgICAgICBcbiAgICAgICAgc3ZnLkZSQU1FUkFURSA9IDMwO1xuICAgICAgICBzdmcuTUFYX1ZJUlRVQUxfUElYRUxTID0gMzAwMDA7XG4gICAgICAgIFxuICAgICAgICBzdmcubG9nID0gZnVuY3Rpb24obXNnKSB7fTtcbiAgICAgICAgaWYgKHN2Zy5vcHRzWydsb2cnXSA9PSB0cnVlICYmIHR5cGVvZihjb25zb2xlKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc3ZnLmxvZyA9IGZ1bmN0aW9uKG1zZykgeyBjb25zb2xlLmxvZyhtc2cpOyB9O1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gZ2xvYmFsc1xuICAgICAgICBzdmcuaW5pdCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgdmFyIHVuaXF1ZUlkID0gMDtcbiAgICAgICAgICAgIHN2Zy5VbmlxdWVJZCA9IGZ1bmN0aW9uICgpIHsgdW5pcXVlSWQrKzsgcmV0dXJuICdjYW52ZycgKyB1bmlxdWVJZDsgfTtcbiAgICAgICAgICAgIHN2Zy5EZWZpbml0aW9ucyA9IHt9O1xuICAgICAgICAgICAgc3ZnLlN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgc3ZnLkFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHN2Zy5JbWFnZXMgPSBbXTtcbiAgICAgICAgICAgIHN2Zy5jdHggPSBjdHg7XG4gICAgICAgICAgICBzdmcuVmlld1BvcnQgPSBuZXcgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdQb3J0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuQ2xlYXIgPSBmdW5jdGlvbigpIHsgdGhpcy52aWV3UG9ydHMgPSBbXTsgfVxuICAgICAgICAgICAgICAgIHRoaXMuU2V0Q3VycmVudCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHsgdGhpcy52aWV3UG9ydHMucHVzaCh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7IH1cbiAgICAgICAgICAgICAgICB0aGlzLlJlbW92ZUN1cnJlbnQgPSBmdW5jdGlvbigpIHsgdGhpcy52aWV3UG9ydHMucG9wKCk7IH1cbiAgICAgICAgICAgICAgICB0aGlzLkN1cnJlbnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmlld1BvcnRzW3RoaXMudmlld1BvcnRzLmxlbmd0aCAtIDFdOyB9XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5DdXJyZW50KCkud2lkdGg7IH1cbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5DdXJyZW50KCkuaGVpZ2h0OyB9XG4gICAgICAgICAgICAgICAgdGhpcy5Db21wdXRlU2l6ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgIT0gbnVsbCAmJiB0eXBlb2YoZCkgPT0gJ251bWJlcicpIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCA9PSAneCcpIHJldHVybiB0aGlzLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkID09ICd5JykgcmV0dXJuIHRoaXMuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53aWR0aCgpLCAyKSArIE1hdGgucG93KHRoaXMuaGVpZ2h0KCksIDIpKSAvIE1hdGguc3FydCgyKTsgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuaW5pdCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gaW1hZ2VzIGxvYWRlZFxuICAgICAgICBzdmcuSW1hZ2VzTG9hZGVkID0gZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHN2Zy5JbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN2Zy5JbWFnZXNbaV0ubG9hZGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaW1cbiAgICAgICAgc3ZnLnRyaW0gPSBmdW5jdGlvbihzKSB7IHJldHVybiBzLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTsgfVxuICAgICAgICBcbiAgICAgICAgLy8gY29tcHJlc3Mgc3BhY2VzXG4gICAgICAgIHN2Zy5jb21wcmVzc1NwYWNlcyA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvW1xcc1xcclxcdFxcbl0rL2dtLCcgJyk7IH1cbiAgICAgICAgXG4gICAgICAgIC8vIGFqYXhcbiAgICAgICAgc3ZnLmFqYXggPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgIHZhciBBSkFYO1xuICAgICAgICAgICAgaWYod2luZG93LlhNTEh0dHBSZXF1ZXN0KXtBSkFYPW5ldyBYTUxIdHRwUmVxdWVzdCgpO31cbiAgICAgICAgICAgIGVsc2V7QUpBWD1uZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTt9XG4gICAgICAgICAgICBpZihBSkFYKXtcbiAgICAgICAgICAgICAgIEFKQVgub3BlbignR0VUJyx1cmwsZmFsc2UpO1xuICAgICAgICAgICAgICAgQUpBWC5zZW5kKG51bGwpO1xuICAgICAgICAgICAgICAgcmV0dXJuIEFKQVgucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gXG4gICAgICAgIFxuICAgICAgICAvLyBwYXJzZSB4bWxcbiAgICAgICAgc3ZnLnBhcnNlWG1sID0gZnVuY3Rpb24oeG1sKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKFdpbmRvd3MpICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZihXaW5kb3dzLkRhdGEpICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZihXaW5kb3dzLkRhdGEuWG1sKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZhciB4bWxEb2MgPSBuZXcgV2luZG93cy5EYXRhLlhtbC5Eb20uWG1sRG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBuZXcgV2luZG93cy5EYXRhLlhtbC5Eb20uWG1sTG9hZFNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucHJvaGliaXREdGQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB4bWxEb2MubG9hZFhtbCh4bWwsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geG1sRG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod2luZG93LkRPTVBhcnNlcilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHhtbCA9IHhtbC5yZXBsYWNlKC88IURPQ1RZUEUgc3ZnW14+XSo+LywgJycpO1xuICAgICAgICAgICAgICAgIHZhciB4bWxEb2MgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xuICAgICAgICAgICAgICAgIHhtbERvYy5hc3luYyA9ICdmYWxzZSc7XG4gICAgICAgICAgICAgICAgeG1sRG9jLmxvYWRYTUwoeG1sKTsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHhtbERvYztcbiAgICAgICAgICAgIH0gICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN2Zy5Qcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9ICAgXG4gICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAhPSBudWxsICYmIHRoaXMudmFsdWUgIT09ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgbnVtZXJpY2FsIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS5udW1WYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHBhcnNlRmxvYXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnZhbHVlICsgJycpLm1hdGNoKC8lJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBuIC8gMTAwLjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLnZhbHVlT3JEZWZhdWx0ID0gZnVuY3Rpb24oZGVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS5udW1WYWx1ZU9yRGVmYXVsdCA9IGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiB0aGlzLm51bVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gY29sb3IgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgIC8vIGF1Z21lbnQgdGhlIGN1cnJlbnQgY29sb3IgdmFsdWUgd2l0aCB0aGUgb3BhY2l0eVxuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuYWRkT3BhY2l0eSA9IGZ1bmN0aW9uKG9wYWNpdHlQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGFjaXR5UHJvcC52YWx1ZSAhPSBudWxsICYmIG9wYWNpdHlQcm9wLnZhbHVlICE9ICcnICYmIHR5cGVvZih0aGlzLnZhbHVlKT09J3N0cmluZycpIHsgLy8gY2FuIG9ubHkgYWRkIG9wYWNpdHkgdG8gY29sb3JzLCBub3QgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IG5ldyBSR0JDb2xvcih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvci5vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gJ3JnYmEoJyArIGNvbG9yLnIgKyAnLCAnICsgY29sb3IuZyArICcsICcgKyBjb2xvci5iICsgJywgJyArIG9wYWNpdHlQcm9wLm51bVZhbHVlKCkgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdmcuUHJvcGVydHkodGhpcy5uYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBkZWZpbml0aW9uIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGRlZmluaXRpb24gZnJvbSB0aGUgZGVmaW5pdGlvbnMgdGFibGVcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLmdldERlZmluaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnZhbHVlLm1hdGNoKC8jKFteXFwpJ1wiXSspLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7IG5hbWUgPSBuYW1lWzFdOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkgeyBuYW1lID0gdGhpcy52YWx1ZTsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ZnLkRlZmluaXRpb25zW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLmlzVXJsRGVmaW5pdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5pbmRleE9mKCd1cmwoJykgPT0gMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLmdldEZpbGxTdHlsZURlZmluaXRpb24gPSBmdW5jdGlvbihlLCBvcGFjaXR5UHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBncmFkaWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmICE9IG51bGwgJiYgZGVmLmNyZWF0ZUdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmLmNyZWF0ZUdyYWRpZW50KHN2Zy5jdHgsIGUsIG9wYWNpdHlQcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmICE9IG51bGwgJiYgZGVmLmNyZWF0ZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHQgPSBkZWYuYXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmID0gZGVmLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHB0Lmhhc1ZhbHVlKCkpIHsgZGVmLmF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScsIHRydWUpLnZhbHVlID0gcHQudmFsdWU7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWYuY3JlYXRlUGF0dGVybihzdmcuY3R4LCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBsZW5ndGggZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0RFBJID0gZnVuY3Rpb24odmlld1BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDk2LjA7IC8vIFRPRE86IGNvbXB1dGU/XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0RU0gPSBmdW5jdGlvbih2aWV3UG9ydCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW0gPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IG5ldyBzdmcuUHJvcGVydHkoJ2ZvbnRTaXplJywgc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb250U2l6ZS5oYXNWYWx1ZSgpKSBlbSA9IGZvbnRTaXplLnRvUGl4ZWxzKHZpZXdQb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS5nZXRVbml0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMudmFsdWUrJyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1swLTlcXC5cXC1dL2csJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgbGVuZ3RoIGFzIHBpeGVsc1xuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUudG9QaXhlbHMgPSBmdW5jdGlvbih2aWV3UG9ydCwgcHJvY2Vzc1BlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMudmFsdWUrJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC9lbSQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIHRoaXMuZ2V0RU0odmlld1BvcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvZXgkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldEVNKHZpZXdQb3J0KSAvIDIuMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubWF0Y2goL3B4JC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvcHQkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldERQSSh2aWV3UG9ydCkgKiAoMS4wIC8gNzIuMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC9wYyQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIDE1O1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvY20kLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldERQSSh2aWV3UG9ydCkgLyAyLjU0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvbW0kLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldERQSSh2aWV3UG9ydCkgLyAyNS40O1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvaW4kLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldERQSSh2aWV3UG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC8lJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogc3ZnLlZpZXdQb3J0LkNvbXB1dGVTaXplKHZpZXdQb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLm51bVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzUGVyY2VudCAmJiBuIDwgMS4wKSByZXR1cm4gbiAqIHN2Zy5WaWV3UG9ydC5Db21wdXRlU2l6ZSh2aWV3UG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGltZSBleHRlbnNpb25zXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSB0aW1lIGFzIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUudG9NaWxsaXNlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMudmFsdWUrJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC9zJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubWF0Y2goL21zJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYW5nbGUgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgYW5nbGUgYXMgcmFkaWFuc1xuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUudG9SYWRpYW5zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnZhbHVlKycnO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvZGVnJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC9ncmFkJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogKE1hdGguUEkgLyAyMDAuMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC9yYWQkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiAoTWF0aC5QSSAvIDE4MC4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gdGV4dCBleHRlbnNpb25zXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSB0ZXh0IGJhc2VsaW5lXG4gICAgICAgICAgICAgICAgdmFyIHRleHRCYXNlbGluZU1hcHBpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICdiYXNlbGluZSc6ICdhbHBoYWJldGljJyxcbiAgICAgICAgICAgICAgICAgICAgJ2JlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWJlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgICdtaWRkbGUnOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NlbnRyYWwnOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2FmdGVyLWVkZ2UnOiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtYWZ0ZXItZWRnZSc6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgICAgICAnaWRlb2dyYXBoaWMnOiAnaWRlb2dyYXBoaWMnLFxuICAgICAgICAgICAgICAgICAgICAnYWxwaGFiZXRpYyc6ICdhbHBoYWJldGljJyxcbiAgICAgICAgICAgICAgICAgICAgJ2hhbmdpbmcnOiAnaGFuZ2luZycsXG4gICAgICAgICAgICAgICAgICAgICdtYXRoZW1hdGljYWwnOiAnYWxwaGFiZXRpYydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUudG9UZXh0QmFzZWxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHRCYXNlbGluZU1hcHBpbmdbdGhpcy52YWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAvLyBmb250c1xuICAgICAgICBzdmcuRm9udCA9IG5ldyAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLlN0eWxlcyA9ICdub3JtYWx8aXRhbGljfG9ibGlxdWV8aW5oZXJpdCc7XG4gICAgICAgICAgICB0aGlzLlZhcmlhbnRzID0gJ25vcm1hbHxzbWFsbC1jYXBzfGluaGVyaXQnO1xuICAgICAgICAgICAgdGhpcy5XZWlnaHRzID0gJ25vcm1hbHxib2xkfGJvbGRlcnxsaWdodGVyfDEwMHwyMDB8MzAwfDQwMHw1MDB8NjAwfDcwMHw4MDB8OTAwfGluaGVyaXQnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLkNyZWF0ZUZvbnQgPSBmdW5jdGlvbihmb250U3R5bGUsIGZvbnRWYXJpYW50LCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgaW5oZXJpdCkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gaW5oZXJpdCAhPSBudWxsID8gdGhpcy5QYXJzZShpbmhlcml0KSA6IHRoaXMuQ3JlYXRlRm9udCgnJywgJycsICcnLCAnJywgJycsIHN2Zy5jdHguZm9udCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHkgfHwgZi5mb250RmFtaWx5LCBcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IGZvbnRTaXplIHx8IGYuZm9udFNpemUsIFxuICAgICAgICAgICAgICAgICAgICBmb250U3R5bGU6IGZvbnRTdHlsZSB8fCBmLmZvbnRTdHlsZSwgXG4gICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQgfHwgZi5mb250V2VpZ2h0LCBcbiAgICAgICAgICAgICAgICAgICAgZm9udFZhcmlhbnQ6IGZvbnRWYXJpYW50IHx8IGYuZm9udFZhcmlhbnQsXG4gICAgICAgICAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbdGhpcy5mb250U3R5bGUsIHRoaXMuZm9udFZhcmlhbnQsIHRoaXMuZm9udFdlaWdodCwgdGhpcy5mb250U2l6ZSwgdGhpcy5mb250RmFtaWx5XS5qb2luKCcgJykgfSBcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLlBhcnNlID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgIHZhciBmID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBzdmcudHJpbShzdmcuY29tcHJlc3NTcGFjZXMocyB8fCAnJykpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgdmFyIHNldCA9IHsgZm9udFNpemU6IGZhbHNlLCBmb250U3R5bGU6IGZhbHNlLCBmb250V2VpZ2h0OiBmYWxzZSwgZm9udFZhcmlhbnQ6IGZhbHNlIH1cbiAgICAgICAgICAgICAgICB2YXIgZmYgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldC5mb250U3R5bGUgJiYgdGhhdC5TdHlsZXMuaW5kZXhPZihkW2ldKSAhPSAtMSkgeyBpZiAoZFtpXSAhPSAnaW5oZXJpdCcpIGYuZm9udFN0eWxlID0gZFtpXTsgc2V0LmZvbnRTdHlsZSA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNldC5mb250VmFyaWFudCAmJiB0aGF0LlZhcmlhbnRzLmluZGV4T2YoZFtpXSkgIT0gLTEpIHsgaWYgKGRbaV0gIT0gJ2luaGVyaXQnKSBmLmZvbnRWYXJpYW50ID0gZFtpXTsgc2V0LmZvbnRTdHlsZSA9IHNldC5mb250VmFyaWFudCA9IHRydWU7ICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzZXQuZm9udFdlaWdodCAmJiB0aGF0LldlaWdodHMuaW5kZXhPZihkW2ldKSAhPSAtMSkgeyBpZiAoZFtpXSAhPSAnaW5oZXJpdCcpIGYuZm9udFdlaWdodCA9IGRbaV07IHNldC5mb250U3R5bGUgPSBzZXQuZm9udFZhcmlhbnQgPSBzZXQuZm9udFdlaWdodCA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNldC5mb250U2l6ZSkgeyBpZiAoZFtpXSAhPSAnaW5oZXJpdCcpIGYuZm9udFNpemUgPSBkW2ldLnNwbGl0KCcvJylbMF07IHNldC5mb250U3R5bGUgPSBzZXQuZm9udFZhcmlhbnQgPSBzZXQuZm9udFdlaWdodCA9IHNldC5mb250U2l6ZSA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IGlmIChkW2ldICE9ICdpbmhlcml0JykgZmYgKz0gZFtpXTsgfVxuICAgICAgICAgICAgICAgIH0gaWYgKGZmICE9ICcnKSBmLmZvbnRGYW1pbHkgPSBmZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBwb2ludHMgYW5kIHBhdGhzXG4gICAgICAgIHN2Zy5Ub051bWJlckFycmF5ID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgdmFyIGEgPSBzdmcudHJpbShzdmcuY29tcHJlc3NTcGFjZXMoKHMgfHwgJycpLnJlcGxhY2UoLywvZywgJyAnKSkpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBwYXJzZUZsb2F0KGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0gICAgICAgXG4gICAgICAgIHN2Zy5Qb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9ICAgXG4gICAgICAgICAgICBzdmcuUG9pbnQucHJvdG90eXBlLmFuZ2xlVG8gPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIocC55IC0gdGhpcy55LCBwLnggLSB0aGlzLngpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdmcuUG9pbnQucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHZhciB4cCA9IHRoaXMueCAqIHZbMF0gKyB0aGlzLnkgKiB2WzJdICsgdls0XTtcbiAgICAgICAgICAgICAgICB2YXIgeXAgPSB0aGlzLnggKiB2WzFdICsgdGhpcy55ICogdlszXSArIHZbNV07XG4gICAgICAgICAgICAgICAgdGhpcy54ID0geHA7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0geXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgc3ZnLkNyZWF0ZVBvaW50ID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgdmFyIGEgPSBzdmcuVG9OdW1iZXJBcnJheShzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3ZnLlBvaW50KGFbMF0sIGFbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5DcmVhdGVQYXRoID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgdmFyIGEgPSBzdmcuVG9OdW1iZXJBcnJheShzKTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YS5sZW5ndGg7IGkrPTIpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobmV3IHN2Zy5Qb2ludChhW2ldLCBhW2krMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBib3VuZGluZyBib3hcbiAgICAgICAgc3ZnLkJvdW5kaW5nQm94ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHsgLy8gcGFzcyBpbiBpbml0aWFsIHBvaW50cyBpZiB5b3Ugd2FudFxuICAgICAgICAgICAgdGhpcy54MSA9IE51bWJlci5OYU47XG4gICAgICAgICAgICB0aGlzLnkxID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgIHRoaXMueDIgPSBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgdGhpcy55MiA9IE51bWJlci5OYU47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMueCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy54MTsgfVxuICAgICAgICAgICAgdGhpcy55ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnkxOyB9XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLngyIC0gdGhpcy54MTsgfVxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxOyB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7ICAgIFxuICAgICAgICAgICAgICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMueDEpIHx8IGlzTmFOKHRoaXMueDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLngxID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh4IDwgdGhpcy54MSkgdGhpcy54MSA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID4gdGhpcy54MikgdGhpcy54MiA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy55MikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPCB0aGlzLnkxKSB0aGlzLnkxID0geTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPiB0aGlzLnkyKSB0aGlzLnkyID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkWCA9IGZ1bmN0aW9uKHgpIHsgdGhpcy5hZGRQb2ludCh4LCBudWxsKTsgfVxuICAgICAgICAgICAgdGhpcy5hZGRZID0gZnVuY3Rpb24oeSkgeyB0aGlzLmFkZFBvaW50KG51bGwsIHkpOyB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkQm91bmRpbmdCb3ggPSBmdW5jdGlvbihiYikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQoYmIueDEsIGJiLnkxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50KGJiLngyLCBiYi55Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkUXVhZHJhdGljQ3VydmUgPSBmdW5jdGlvbihwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNwMXggPSBwMHggKyAyLzMgKiAocDF4IC0gcDB4KTsgLy8gQ1AxID0gUVAwICsgMi8zICooUVAxLVFQMClcbiAgICAgICAgICAgICAgICB2YXIgY3AxeSA9IHAweSArIDIvMyAqIChwMXkgLSBwMHkpOyAvLyBDUDEgPSBRUDAgKyAyLzMgKihRUDEtUVAwKVxuICAgICAgICAgICAgICAgIHZhciBjcDJ4ID0gY3AxeCArIDEvMyAqIChwMnggLSBwMHgpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuICAgICAgICAgICAgICAgIHZhciBjcDJ5ID0gY3AxeSArIDEvMyAqIChwMnkgLSBwMHkpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIGNwMXgsIGNwMngsIGNwMXksIGNwMnksIHAyeCwgcDJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hZGRCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgICAgICAgICAgICAgLy8gZnJvbSBodHRwOi8vYmxvZy5oYWNrZXJzLWNhZmUubmV0LzIwMDkvMDYvaG93LXRvLWNhbGN1bGF0ZS1iZXppZXItY3VydmVzLWJvdW5kaW5nLmh0bWxcbiAgICAgICAgICAgICAgICB2YXIgcDAgPSBbcDB4LCBwMHldLCBwMSA9IFtwMXgsIHAxeV0sIHAyID0gW3AyeCwgcDJ5XSwgcDMgPSBbcDN4LCBwM3ldO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQocDBbMF0sIHAwWzFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50KHAzWzBdLCBwM1sxXSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8PTE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uKHQpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coMS10LCAzKSAqIHAwW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICArIDMgKiBNYXRoLnBvdygxLXQsIDIpICogdCAqIHAxW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICArIDMgKiAoMS10KSAqIE1hdGgucG93KHQsIDIpICogcDJbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgICsgTWF0aC5wb3codCwgMykgKiBwM1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSA2ICogcDBbaV0gLSAxMiAqIHAxW2ldICsgNiAqIHAyW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IC0zICogcDBbaV0gKyA5ICogcDFbaV0gLSA5ICogcDJbaV0gKyAzICogcDNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gMyAqIHAxW2ldIC0gMyAqIHAwW2ldO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT0gMCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IDApIHRoaXMuYWRkWChmKHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB0aGlzLmFkZFkoZih0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIyYWMgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBjICogYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIyYWMgPCAwKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB0aGlzLmFkZFgoZih0MSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkgdGhpcy5hZGRZKGYodDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IDApIHRoaXMuYWRkWChmKHQyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB0aGlzLmFkZFkoZih0MikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmlzUG9pbnRJbkJveCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMueDEgPD0geCAmJiB4IDw9IHRoaXMueDIgJiYgdGhpcy55MSA8PSB5ICYmIHkgPD0gdGhpcy55Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQoeDEsIHkxKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQoeDIsIHkyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gdHJhbnNmb3Jtc1xuICAgICAgICBzdmcuVHJhbnNmb3JtID0gZnVuY3Rpb24odikgeyAgIFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5UeXBlID0ge31cbiAgICAgICAgXG4gICAgICAgICAgICAvLyB0cmFuc2xhdGVcbiAgICAgICAgICAgIHRoaXMuVHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gc3ZnLkNyZWF0ZVBvaW50KHMpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnAueCB8fCAwLjAsIHRoaXMucC55IHx8IDAuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudW5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC0xLjAgKiB0aGlzLnAueCB8fCAwLjAsIC0xLjAgKiB0aGlzLnAueSB8fCAwLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VG9Qb2ludCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgdGhpcy5wLnggfHwgMC4wLCB0aGlzLnAueSB8fCAwLjBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHJvdGF0ZVxuICAgICAgICAgICAgdGhpcy5UeXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHN2Zy5Ub051bWJlckFycmF5KHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5nbGUgPSBuZXcgc3ZnLlByb3BlcnR5KCdhbmdsZScsIGFbMF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY3ggPSBhWzFdIHx8IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5jeSA9IGFbMl0gfHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5jeCwgdGhpcy5jeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUodGhpcy5hbmdsZS50b1JhZGlhbnMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXRoaXMuY3gsIC10aGlzLmN5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5jeCwgdGhpcy5jeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLTEuMCAqIHRoaXMuYW5nbGUudG9SYWRpYW5zKCkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC10aGlzLmN4LCAtdGhpcy5jeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuYW5nbGUudG9SYWRpYW5zKCk7XG4gICAgICAgICAgICAgICAgICAgIHAuYXBwbHlUcmFuc2Zvcm0oWzEsIDAsIDAsIDEsIHRoaXMucC54IHx8IDAuMCwgdGhpcy5wLnkgfHwgMC4wXSk7XG4gICAgICAgICAgICAgICAgICAgIHAuYXBwbHlUcmFuc2Zvcm0oW01hdGguY29zKGEpLCBNYXRoLnNpbihhKSwgLU1hdGguc2luKGEpLCBNYXRoLmNvcyhhKSwgMCwgMF0pO1xuICAgICAgICAgICAgICAgICAgICBwLmFwcGx5VHJhbnNmb3JtKFsxLCAwLCAwLCAxLCAtdGhpcy5wLnggfHwgMC4wLCAtdGhpcy5wLnkgfHwgMC4wXSk7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuVHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBzdmcuQ3JlYXRlUG9pbnQocyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUodGhpcy5wLnggfHwgMS4wLCB0aGlzLnAueSB8fCB0aGlzLnAueCB8fCAxLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEuMCAvIHRoaXMucC54IHx8IDEuMCwgMS4wIC8gdGhpcy5wLnkgfHwgdGhpcy5wLnggfHwgMS4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVRvUG9pbnQgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuYXBwbHlUcmFuc2Zvcm0oW3RoaXMucC54IHx8IDAuMCwgMCwgMCwgdGhpcy5wLnkgfHwgMC4wLCAwLCAwXSk7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLlR5cGUubWF0cml4ID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgIHRoaXMubSA9IHN2Zy5Ub051bWJlckFycmF5KHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zZm9ybSh0aGlzLm1bMF0sIHRoaXMubVsxXSwgdGhpcy5tWzJdLCB0aGlzLm1bM10sIHRoaXMubVs0XSwgdGhpcy5tWzVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5tWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMubVsyXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLm1bNF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5tWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMubVszXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSB0aGlzLm1bNV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBnID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXQgPSAxIC8gKGEqKGUqaS1mKmgpLWIqKGQqaS1mKmcpK2MqKGQqaC1lKmcpKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldCooZSppLWYqaCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXQqKGYqZy1kKmkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0KihjKmgtYippKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldCooYSppLWMqZyksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXQqKGIqZi1jKmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0KihjKmQtYSpmKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VG9Qb2ludCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcC5hcHBseVRyYW5zZm9ybSh0aGlzLm0pO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuVHlwZS5Ta2V3QmFzZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2UgPSB0aGF0LlR5cGUubWF0cml4O1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZShzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnYW5nbGUnLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuVHlwZS5Ta2V3QmFzZS5wcm90b3R5cGUgPSBuZXcgdGhpcy5UeXBlLm1hdHJpeDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5UeXBlLnNrZXdYID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZSA9IHRoYXQuVHlwZS5Ta2V3QmFzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2Uocyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tID0gWzEsIDAsIE1hdGgudGFuKHRoaXMuYW5nbGUudG9SYWRpYW5zKCkpLCAxLCAwLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuVHlwZS5za2V3WC5wcm90b3R5cGUgPSBuZXcgdGhpcy5UeXBlLlNrZXdCYXNlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLlR5cGUuc2tld1kgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlID0gdGhhdC5UeXBlLlNrZXdCYXNlO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZShzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm0gPSBbMSwgTWF0aC50YW4odGhpcy5hbmdsZS50b1JhZGlhbnMoKSksIDAsIDEsIDAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5UeXBlLnNrZXdZLnByb3RvdHlwZSA9IG5ldyB0aGlzLlR5cGUuU2tld0Jhc2U7XG4gICAgICAgIFxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3Jtc1tpXS5hcHBseShjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT10aGlzLnRyYW5zZm9ybXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXNbaV0udW5hcHBseShjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hcHBseVRvUG9pbnQgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXNbaV0uYXBwbHlUb1BvaW50KHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGRhdGEgPSBzdmcudHJpbShzdmcuY29tcHJlc3NTcGFjZXModikpLnJlcGxhY2UoL1xcKShbYS16QS1aXSkvZywgJykgJDEnKS5yZXBsYWNlKC9cXCkoXFxzPyxcXHM/KS9nLCcpICcpLnNwbGl0KC9cXHMoPz1bYS16XSkvKTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzdmcudHJpbShkYXRhW2ldLnNwbGl0KCcoJylbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBzID0gZGF0YVtpXS5zcGxpdCgnKCcpWzFdLnJlcGxhY2UoJyknLCcnKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gbmV3IHRoaXMuVHlwZVt0eXBlXShzKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gYXNwZWN0IHJhdGlvXG4gICAgICAgIHN2Zy5Bc3BlY3RSYXRpbyA9IGZ1bmN0aW9uKGN0eCwgYXNwZWN0UmF0aW8sIHdpZHRoLCBkZXNpcmVkV2lkdGgsIGhlaWdodCwgZGVzaXJlZEhlaWdodCwgbWluWCwgbWluWSwgcmVmWCwgcmVmWSkge1xuICAgICAgICAgICAgLy8gYXNwZWN0IHJhdGlvIC0gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGVcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvID0gc3ZnLmNvbXByZXNzU3BhY2VzKGFzcGVjdFJhdGlvKTtcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW8ucmVwbGFjZSgvXmRlZmVyXFxzLywnJyk7IC8vIGlnbm9yZSBkZWZlclxuICAgICAgICAgICAgdmFyIGFsaWduID0gYXNwZWN0UmF0aW8uc3BsaXQoJyAnKVswXSB8fCAneE1pZFlNaWQnO1xuICAgICAgICAgICAgdmFyIG1lZXRPclNsaWNlID0gYXNwZWN0UmF0aW8uc3BsaXQoJyAnKVsxXSB8fCAnbWVldCc7ICAgICAgICAgICAgICAgICAgXG4gICAgXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgc2NhbGVcbiAgICAgICAgICAgIHZhciBzY2FsZVggPSB3aWR0aCAvIGRlc2lyZWRXaWR0aDtcbiAgICAgICAgICAgIHZhciBzY2FsZVkgPSBoZWlnaHQgLyBkZXNpcmVkSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHNjYWxlTWluID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgdmFyIHNjYWxlTWF4ID0gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgaWYgKG1lZXRPclNsaWNlID09ICdtZWV0JykgeyBkZXNpcmVkV2lkdGggKj0gc2NhbGVNaW47IGRlc2lyZWRIZWlnaHQgKj0gc2NhbGVNaW47IH1cbiAgICAgICAgICAgIGlmIChtZWV0T3JTbGljZSA9PSAnc2xpY2UnKSB7IGRlc2lyZWRXaWR0aCAqPSBzY2FsZU1heDsgZGVzaXJlZEhlaWdodCAqPSBzY2FsZU1heDsgfSAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmVmWCA9IG5ldyBzdmcuUHJvcGVydHkoJ3JlZlgnLCByZWZYKTtcbiAgICAgICAgICAgIHJlZlkgPSBuZXcgc3ZnLlByb3BlcnR5KCdyZWZZJywgcmVmWSk7XG4gICAgICAgICAgICBpZiAocmVmWC5oYXNWYWx1ZSgpICYmIHJlZlkuaGFzVmFsdWUoKSkgeyAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXNjYWxlTWluICogcmVmWC50b1BpeGVscygneCcpLCAtc2NhbGVNaW4gKiByZWZZLnRvUGl4ZWxzKCd5JykpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGFsaWduXG4gICAgICAgICAgICAgICAgaWYgKGFsaWduLm1hdGNoKC9eeE1pZC8pICYmICgobWVldE9yU2xpY2UgPT0gJ21lZXQnICYmIHNjYWxlTWluID09IHNjYWxlWSkgfHwgKG1lZXRPclNsaWNlID09ICdzbGljZScgJiYgc2NhbGVNYXggPT0gc2NhbGVZKSkpIGN0eC50cmFuc2xhdGUod2lkdGggLyAyLjAgLSBkZXNpcmVkV2lkdGggLyAyLjAsIDApOyBcbiAgICAgICAgICAgICAgICBpZiAoYWxpZ24ubWF0Y2goL1lNaWQkLykgJiYgKChtZWV0T3JTbGljZSA9PSAnbWVldCcgJiYgc2NhbGVNaW4gPT0gc2NhbGVYKSB8fCAobWVldE9yU2xpY2UgPT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PSBzY2FsZVgpKSkgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLyAyLjAgLSBkZXNpcmVkSGVpZ2h0IC8gMi4wKTsgXG4gICAgICAgICAgICAgICAgaWYgKGFsaWduLm1hdGNoKC9eeE1heC8pICYmICgobWVldE9yU2xpY2UgPT0gJ21lZXQnICYmIHNjYWxlTWluID09IHNjYWxlWSkgfHwgKG1lZXRPclNsaWNlID09ICdzbGljZScgJiYgc2NhbGVNYXggPT0gc2NhbGVZKSkpIGN0eC50cmFuc2xhdGUod2lkdGggLSBkZXNpcmVkV2lkdGgsIDApOyBcbiAgICAgICAgICAgICAgICBpZiAoYWxpZ24ubWF0Y2goL1lNYXgkLykgJiYgKChtZWV0T3JTbGljZSA9PSAnbWVldCcgJiYgc2NhbGVNaW4gPT0gc2NhbGVYKSB8fCAobWVldE9yU2xpY2UgPT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PSBzY2FsZVgpKSkgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLSBkZXNpcmVkSGVpZ2h0KTsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHNjYWxlXG4gICAgICAgICAgICBpZiAoYWxpZ24gPT0gJ25vbmUnKSBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgZWxzZSBpZiAobWVldE9yU2xpY2UgPT0gJ21lZXQnKSBjdHguc2NhbGUoc2NhbGVNaW4sIHNjYWxlTWluKTsgXG4gICAgICAgICAgICBlbHNlIGlmIChtZWV0T3JTbGljZSA9PSAnc2xpY2UnKSBjdHguc2NhbGUoc2NhbGVNYXgsIHNjYWxlTWF4KTsgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyB0cmFuc2xhdGVcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUobWluWCA9PSBudWxsID8gMCA6IC1taW5YLCBtaW5ZID09IG51bGwgPyAwIDogLW1pblkpOyAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gZWxlbWVudHNcbiAgICAgICAgc3ZnLkVsZW1lbnQgPSB7fVxuICAgICAgICBcbiAgICAgICAgc3ZnLkVtcHR5UHJvcGVydHkgPSBuZXcgc3ZnLlByb3BlcnR5KCdFTVBUWScsICcnKTtcbiAgICAgICAgXG4gICAgICAgIHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlID0gZnVuY3Rpb24obm9kZSkgeyAgXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGdldCBvciBjcmVhdGUgYXR0cmlidXRlXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZUlmTm90RXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGEgIT0gbnVsbCkgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZUlmTm90RXhpc3RzID09IHRydWUpIHsgYSA9IG5ldyBzdmcuUHJvcGVydHkobmFtZSwgJycpOyB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSBhOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgfHwgc3ZnLkVtcHR5UHJvcGVydHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGEgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7IFxuICAgICAgICAgICAgICAgICAgICBpZiAoYS5tYXRjaCgvOmhyZWYkLykpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2FdOyBcbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN2Zy5FbXB0eVByb3BlcnR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIHN0eWxlLCBjcmF3bHMgdXAgbm9kZSB0cmVlXG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gZnVuY3Rpb24obmFtZSwgY3JlYXRlSWZOb3RFeGlzdHMsIHNraXBBbmNlc3RvcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuc3R5bGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChzICE9IG51bGwpIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5hdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGEgIT0gbnVsbCAmJiBhLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBhOyAvLyBtb3ZlIHVwIHRvIG1lIHRvIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoc2tpcEFuY2VzdG9ycyAhPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcyA9IHAuc3R5bGUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHMgIT0gbnVsbCAmJiBwcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoY3JlYXRlSWZOb3RFeGlzdHMgPT0gdHJ1ZSkgeyBzID0gbmV3IHN2Zy5Qcm9wZXJ0eShuYW1lLCAnJyk7IHRoaXMuc3R5bGVzW25hbWVdID0gczsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzIHx8IHN2Zy5FbXB0eVByb3BlcnR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBiYXNlIHJlbmRlclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCByZW5kZXIgZGlzcGxheT1ub25lXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PSAnbm9uZScpIHJldHVybjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBkb24ndCByZW5kZXIgdmlzaWJpbGl0eT1oaWRkZW5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09ICdoaWRkZW4nKSByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnbWFzaycpLmhhc1ZhbHVlKCkpIHsgLy8gbWFza1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFzayA9IHRoaXMuYXR0cmlidXRlKCdtYXNrJykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFzayAhPSBudWxsKSBtYXNrLmFwcGx5KGN0eCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3R5bGUoJ2ZpbHRlcicpLmhhc1ZhbHVlKCkpIHsgLy8gZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLnN0eWxlKCdmaWx0ZXInKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgIT0gbnVsbCkgZmlsdGVyLmFwcGx5KGN0eCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29udGV4dChjdHgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKGN0eCk7ICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7ICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBiYXNlIHNldCBjb250ZXh0XG4gICAgICAgICAgICB0aGlzLnNldENvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBPVkVSUklERSBNRSFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYmFzZSBjbGVhciBjb250ZXh0XG4gICAgICAgICAgICB0aGlzLmNsZWFyQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIC8vIE9WRVJSSURFIE1FIVxuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGJhc2UgcmVuZGVyIGNoaWxkcmVuXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZE5vZGUsIGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoY3JlYXRlKSBjaGlsZCA9IHN2Zy5DcmVhdGVFbGVtZW50KGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPSAndGl0bGUnKSB7IHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChub2RlICE9IG51bGwgJiYgbm9kZS5ub2RlVHlwZSA9PSAxKSB7IC8vRUxFTUVOVF9OT0RFXG4gICAgICAgICAgICAgICAgLy8gYWRkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8bm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGUubm9kZU5hbWVdID0gbmV3IHN2Zy5Qcm9wZXJ0eShhdHRyaWJ1dGUubm9kZU5hbWUsIGF0dHJpYnV0ZS5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGFnIHN0eWxlc1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZXMgPSBzdmcuU3R5bGVzW25vZGUubm9kZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBzdHlsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGFkZCBjbGFzcyBzdHlsZXNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ2NsYXNzJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHN2Zy5jb21wcmVzc1NwYWNlcyh0aGlzLmF0dHJpYnV0ZSgnY2xhc3MnKS52YWx1ZSkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPGNsYXNzZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHN2Zy5TdHlsZXNbJy4nK2NsYXNzZXNbal1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBzdHlsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gc3ZnLlN0eWxlc1tub2RlLm5vZGVOYW1lKycuJytjbGFzc2VzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gc3R5bGVzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBhZGQgaWQgc3R5bGVzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdpZCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHN2Zy5TdHlsZXNbJyMnICsgdGhpcy5hdHRyaWJ1dGUoJ2lkJykudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBzdHlsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gYWRkIGlubGluZSBzdHlsZXNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ3N0eWxlJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gdGhpcy5hdHRyaWJ1dGUoJ3N0eWxlJykudmFsdWUuc3BsaXQoJzsnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN2Zy50cmltKHN0eWxlc1tpXSkgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbaV0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHN2Zy50cmltKHN0eWxlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdmcudHJpbShzdHlsZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBuZXcgc3ZnLlByb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gICBcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBpZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnaWQnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdmcuRGVmaW5pdGlvbnNbdGhpcy5hdHRyaWJ1dGUoJ2lkJykudmFsdWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5EZWZpbml0aW9uc1t0aGlzLmF0dHJpYnV0ZSgnaWQnKS52YWx1ZV0gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGFkZCBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PSAxKSB0aGlzLmFkZENoaWxkKGNoaWxkTm9kZSwgdHJ1ZSk7IC8vRUxFTUVOVF9OT0RFXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmVUZXh0Tm9kZXMgJiYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PSAzIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PSA0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBjaGlsZE5vZGUubm9kZVZhbHVlIHx8IGNoaWxkTm9kZS50ZXh0IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN2Zy50cmltKHN2Zy5jb21wcmVzc1NwYWNlcyh0ZXh0KSkgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKG5ldyBzdmcuRWxlbWVudC50c3BhbihjaGlsZE5vZGUpLCBmYWxzZSk7IC8vIFRFWFRfTk9ERVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIC8vIGZpbGxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnZmlsbCcpLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcyA9IHRoaXMuc3R5bGUoJ2ZpbGwnKS5nZXRGaWxsU3R5bGVEZWZpbml0aW9uKHRoaXMsIHRoaXMuc3R5bGUoJ2ZpbGwtb3BhY2l0eScpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZzICE9IG51bGwpIGN0eC5maWxsU3R5bGUgPSBmcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdHlsZSgnZmlsbCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGxTdHlsZSA9IHRoaXMuc3R5bGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGxTdHlsZS52YWx1ZSA9PSAnY3VycmVudENvbG9yJykgZmlsbFN0eWxlLnZhbHVlID0gdGhpcy5zdHlsZSgnY29sb3InKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IChmaWxsU3R5bGUudmFsdWUgPT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogZmlsbFN0eWxlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ2ZpbGwtb3BhY2l0eScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGxTdHlsZSA9IG5ldyBzdmcuUHJvcGVydHkoJ2ZpbGwnLCBjdHguZmlsbFN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlID0gZmlsbFN0eWxlLmFkZE9wYWNpdHkodGhpcy5zdHlsZSgnZmlsbC1vcGFjaXR5JykpO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIHN0cm9rZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdzdHJva2UnKS5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnMgPSB0aGlzLnN0eWxlKCdzdHJva2UnKS5nZXRGaWxsU3R5bGVEZWZpbml0aW9uKHRoaXMsIHRoaXMuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnMgIT0gbnVsbCkgY3R4LnN0cm9rZVN0eWxlID0gZnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3R5bGUoJ3N0cm9rZScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cm9rZVN0eWxlID0gdGhpcy5zdHlsZSgnc3Ryb2tlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJva2VTdHlsZS52YWx1ZSA9PSAnY3VycmVudENvbG9yJykgc3Ryb2tlU3R5bGUudmFsdWUgPSB0aGlzLnN0eWxlKCdjb2xvcicpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAoc3Ryb2tlU3R5bGUudmFsdWUgPT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogc3Ryb2tlU3R5bGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJva2VTdHlsZSA9IG5ldyBzdmcuUHJvcGVydHkoJ3N0cm9rZScsIGN0eC5zdHJva2VTdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGUuYWRkT3BhY2l0eSh0aGlzLnN0eWxlKCdzdHJva2Utb3BhY2l0eScpKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGUudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdzdHJva2Utd2lkdGgnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdMaW5lV2lkdGggPSB0aGlzLnN0eWxlKCdzdHJva2Utd2lkdGgnKS50b1BpeGVscygpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbmV3TGluZVdpZHRoID09IDAgPyAwLjAwMSA6IG5ld0xpbmVXaWR0aDsgLy8gYnJvd3NlcnMgZG9uJ3QgcmVzcGVjdCAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdzdHJva2UtbGluZWNhcCcpLmhhc1ZhbHVlKCkpIGN0eC5saW5lQ2FwID0gdGhpcy5zdHlsZSgnc3Ryb2tlLWxpbmVjYXAnKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJykuaGFzVmFsdWUoKSkgY3R4LmxpbmVKb2luID0gdGhpcy5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJykudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ3N0cm9rZS1taXRlcmxpbWl0JykuaGFzVmFsdWUoKSkgY3R4Lm1pdGVyTGltaXQgPSB0aGlzLnN0eWxlKCdzdHJva2UtbWl0ZXJsaW1pdCcpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5JykuaGFzVmFsdWUoKSAmJiB0aGlzLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5JykudmFsdWUgIT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnYXBzID0gc3ZnLlRvTnVtYmVyQXJyYXkodGhpcy5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjdHguc2V0TGluZURhc2gpICE9ICd1bmRlZmluZWQnKSB7IGN0eC5zZXRMaW5lRGFzaChnYXBzKTsgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YoY3R4LndlYmtpdExpbmVEYXNoKSAhPSAndW5kZWZpbmVkJykgeyBjdHgud2Via2l0TGluZURhc2ggPSBnYXBzOyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZihjdHgubW96RGFzaCkgIT0gJ3VuZGVmaW5lZCcgJiYgIShnYXBzLmxlbmd0aD09MSAmJiBnYXBzWzBdPT0wKSkgeyBjdHgubW96RGFzaCA9IGdhcHM7IH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnN0eWxlKCdzdHJva2UtZGFzaG9mZnNldCcpLm51bVZhbHVlT3JEZWZhdWx0KDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGN0eC5saW5lRGFzaE9mZnNldCkgIT0gJ3VuZGVmaW5lZCcpIHsgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb2Zmc2V0OyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZihjdHgud2Via2l0TGluZURhc2hPZmZzZXQpICE9ICd1bmRlZmluZWQnKSB7IGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCA9IG9mZnNldDsgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YoY3R4Lm1vekRhc2hPZmZzZXQpICE9ICd1bmRlZmluZWQnKSB7IGN0eC5tb3pEYXNoT2Zmc2V0ID0gb2Zmc2V0OyB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZm9udFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoY3R4LmZvbnQpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5mb250ID0gc3ZnLkZvbnQuQ3JlYXRlRm9udCggXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlKCdmb250LXN0eWxlJykudmFsdWUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZSgnZm9udC12YXJpYW50JykudmFsdWUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZSgnZm9udC13ZWlnaHQnKS52YWx1ZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlKCdmb250LXNpemUnKS5oYXNWYWx1ZSgpID8gdGhpcy5zdHlsZSgnZm9udC1zaXplJykudG9QaXhlbHMoKSArICdweCcgOiAnJywgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlKCdmb250LWZhbWlseScpLnZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ3RyYW5zZm9ybScpLmhhc1ZhbHVlKCkpIHsgXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgc3ZnLlRyYW5zZm9ybSh0aGlzLmF0dHJpYnV0ZSgndHJhbnNmb3JtJykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uYXBwbHkoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY2xpcFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdjbGlwLXBhdGgnLCBmYWxzZSwgdHJ1ZSkuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IHRoaXMuc3R5bGUoJ2NsaXAtcGF0aCcsIGZhbHNlLCB0cnVlKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlwICE9IG51bGwpIGNsaXAuYXBwbHkoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gb3BhY2l0eVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdvcGFjaXR5JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLnN0eWxlKCdvcGFjaXR5JykubnVtVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2UucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aChjdHgpO1xuICAgICAgICAgICAgICAgIHN2Zy5Nb3VzZS5jaGVja1BhdGgodGhpcywgY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmZpbGxTdHlsZSAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnZmlsbC1ydWxlJykudmFsdWVPckRlZmF1bHQoJ2luaGVyaXQnKSAhPSAnaW5oZXJpdCcpIHsgY3R4LmZpbGwodGhpcy5zdHlsZSgnZmlsbC1ydWxlJykudmFsdWUpOyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyBjdHguZmlsbCgpOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdHguc3Ryb2tlU3R5bGUgIT0gJycpIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VycyA9IHRoaXMuZ2V0TWFya2VycygpO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ21hcmtlci1zdGFydCcpLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFya2VyID0gdGhpcy5zdHlsZSgnbWFya2VyLXN0YXJ0JykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyLnJlbmRlcihjdHgsIG1hcmtlcnNbMF1bMF0sIG1hcmtlcnNbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdtYXJrZXItbWlkJykuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLnN0eWxlKCdtYXJrZXItbWlkJykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0xO2k8bWFya2Vycy5sZW5ndGgtMTtpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXIucmVuZGVyKGN0eCwgbWFya2Vyc1tpXVswXSwgbWFya2Vyc1tpXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ21hcmtlci1lbmQnKS5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuc3R5bGUoJ21hcmtlci1lbmQnKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXIucmVuZGVyKGN0eCwgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aC0xXVswXSwgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aC0xXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldE1hcmtlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2UucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBzdmcgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5zdmcgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmJhc2VDbGVhckNvbnRleHQgPSB0aGlzLmNsZWFyQ29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlQ2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICAgICAgICAgICAgc3ZnLlZpZXdQb3J0LlJlbW92ZUN1cnJlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5iYXNlU2V0Q29udGV4dCA9IHRoaXMuc2V0Q29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRpYWwgdmFsdWVzIGFuZCBkZWZhdWx0c1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICAgICAgICBjdHgubGluZUNhcCA9ICdidXR0JztcbiAgICAgICAgICAgICAgICBjdHgubGluZUpvaW4gPSAnbWl0ZXInO1xuICAgICAgICAgICAgICAgIGN0eC5taXRlckxpbWl0ID0gNDsgXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjdHguZm9udCkgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGN0eC5jYW52YXMpLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2VTZXRDb250ZXh0KGN0eCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyB2aWV3IHBvcnRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXR0cmlidXRlKCd4JykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ3gnLCB0cnVlKS52YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZSgneScpLmhhc1ZhbHVlKCkpIHRoaXMuYXR0cmlidXRlKCd5JywgdHJ1ZSkudmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpLCB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5JykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHN2Zy5WaWV3UG9ydC53aWR0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzdmcuVmlld1BvcnQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnLCB0cnVlKS52YWx1ZSA9ICcxMDAlJztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JywgdHJ1ZSkudmFsdWUgPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZih0aGlzLnJvb3QpID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdyZWZYJykuaGFzVmFsdWUoKSAmJiB0aGlzLmF0dHJpYnV0ZSgncmVmWScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSAtdGhpcy5hdHRyaWJ1dGUoJ3JlZlgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IC10aGlzLmF0dHJpYnV0ZSgncmVmWScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS52YWx1ZU9yRGVmYXVsdCgnaGlkZGVuJykgIT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh3aWR0aCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdmcuVmlld1BvcnQuU2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KTsgXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyB2aWV3Ym94XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCd2aWV3Qm94JykuaGFzVmFsdWUoKSkgeyAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdCb3ggPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLmF0dHJpYnV0ZSgndmlld0JveCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pblggPSB2aWV3Qm94WzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluWSA9IHZpZXdCb3hbMV07XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gdmlld0JveFsyXTtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gdmlld0JveFszXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHN2Zy5Bc3BlY3RSYXRpbyhjdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLnZhbHVlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5WaWV3UG9ydC53aWR0aCgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnLlZpZXdQb3J0LmhlaWdodCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSgncmVmWCcpLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUoJ3JlZlknKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzdmcuVmlld1BvcnQuUmVtb3ZlQ3VycmVudCgpO1xuICAgICAgICAgICAgICAgICAgICBzdmcuVmlld1BvcnQuU2V0Q3VycmVudCh2aWV3Qm94WzJdLCB2aWV3Qm94WzNdKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuc3ZnLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuXG4gICAgICAgIC8vIHJlY3QgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5yZWN0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB2YXIgcnggPSB0aGlzLmF0dHJpYnV0ZSgncngnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciByeSA9IHRoaXMuYXR0cmlidXRlKCdyeScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdyeCcpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuYXR0cmlidXRlKCdyeScpLmhhc1ZhbHVlKCkpIHJ5ID0gcng7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdyeScpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuYXR0cmlidXRlKCdyeCcpLmhhc1ZhbHVlKCkpIHJ4ID0gcnk7XG4gICAgICAgICAgICAgICAgcnggPSBNYXRoLm1pbihyeCwgd2lkdGggLyAyLjApO1xuICAgICAgICAgICAgICAgIHJ5ID0gTWF0aC5taW4ocnksIGhlaWdodCAvIDIuMCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcngsIHkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJ4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByeSlcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcngsIHkgKyBoZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHJ4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJ5KVxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyByeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnJlY3QucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIGNpcmNsZSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmNpcmNsZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gdGhpcy5hdHRyaWJ1dGUoJ2N4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSB0aGlzLmF0dHJpYnV0ZSgnY3knKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5hdHRyaWJ1dGUoJ3InKS50b1BpeGVscygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTsgXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3goY3ggLSByLCBjeSAtIHIsIGN4ICsgciwgY3kgKyByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5jaXJjbGUucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTsgXG5cbiAgICAgICAgLy8gZWxsaXBzZSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmVsbGlwc2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciBLQVBQQSA9IDQgKiAoKE1hdGguc3FydCgyKSAtIDEpIC8gMyk7XG4gICAgICAgICAgICAgICAgdmFyIHJ4ID0gdGhpcy5hdHRyaWJ1dGUoJ3J4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgcnkgPSB0aGlzLmF0dHJpYnV0ZSgncnknKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIHZhciBjeCA9IHRoaXMuYXR0cmlidXRlKCdjeCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gdGhpcy5hdHRyaWJ1dGUoJ2N5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGN4LCBjeSAtIHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggKyAoS0FQUEEgKiByeCksIGN5IC0gcnksICBjeCArIHJ4LCBjeSAtIChLQVBQQSAqIHJ5KSwgY3ggKyByeCwgY3kpO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCArIHJ4LCBjeSArIChLQVBQQSAqIHJ5KSwgY3ggKyAoS0FQUEEgKiByeCksIGN5ICsgcnksIGN4LCBjeSArIHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggLSAoS0FQUEEgKiByeCksIGN5ICsgcnksIGN4IC0gcngsIGN5ICsgKEtBUFBBICogcnkpLCBjeCAtIHJ4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4IC0gcngsIGN5IC0gKEtBUFBBICogcnkpLCBjeCAtIChLQVBQQSAqIHJ4KSwgY3kgLSByeSwgY3gsIGN5IC0gcnkpO1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KGN4IC0gcngsIGN5IC0gcnksIGN4ICsgcngsIGN5ICsgcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmVsbGlwc2UucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTsgICAgICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8vIGxpbmUgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5saW5lID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldFBvaW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBzdmcuUG9pbnQodGhpcy5hdHRyaWJ1dGUoJ3gxJykudG9QaXhlbHMoJ3gnKSwgdGhpcy5hdHRyaWJ1dGUoJ3kxJykudG9QaXhlbHMoJ3knKSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBzdmcuUG9pbnQodGhpcy5hdHRyaWJ1dGUoJ3gyJykudG9QaXhlbHMoJ3gnKSwgdGhpcy5hdHRyaWJ1dGUoJ3kyJykudG9QaXhlbHMoJ3knKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveChwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnksIHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0TWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpOyAgXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBwb2ludHNbMF0uYW5nbGVUbyhwb2ludHNbMV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbW3BvaW50c1swXSwgYV0sIFtwb2ludHNbMV0sIGFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5saW5lLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7ICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAvLyBwb2x5bGluZSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LnBvbHlsaW5lID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IHN2Zy5DcmVhdGVQYXRoKHRoaXMuYXR0cmlidXRlKCdwb2ludHMnKS52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmIgPSBuZXcgc3ZnLkJvdW5kaW5nQm94KHRoaXMucG9pbnRzWzBdLngsIHRoaXMucG9pbnRzWzBdLnkpO1xuICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy5wb2ludHNbMF0ueCwgdGhpcy5wb2ludHNbMF0ueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MTsgaTx0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYi5hZGRQb2ludCh0aGlzLnBvaW50c1tpXS54LCB0aGlzLnBvaW50c1tpXS55KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHgubGluZVRvKHRoaXMucG9pbnRzW2ldLngsIHRoaXMucG9pbnRzW2ldLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0TWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXJrZXJzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMucG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goW3RoaXMucG9pbnRzW2ldLCB0aGlzLnBvaW50c1tpXS5hbmdsZVRvKHRoaXMucG9pbnRzW2krMV0pXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcmtlcnMucHVzaChbdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoLTFdLCBtYXJrZXJzW21hcmtlcnMubGVuZ3RoLTFdWzFdXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5wb2x5bGluZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlOyAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAvLyBwb2x5Z29uIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQucG9seWdvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LnBvbHlsaW5lO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmJhc2VQYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5iYXNlUGF0aChjdHgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMucG9pbnRzWzBdLngsIHRoaXMucG9pbnRzWzBdLnkpO1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5wb2x5Z29uLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5wb2x5bGluZTtcblxuICAgICAgICAvLyBwYXRoIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQucGF0aCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuYXR0cmlidXRlKCdkJykudmFsdWU7XG4gICAgICAgICAgICAvLyBUT0RPOiBjb252ZXJ0IHRvIHJlYWwgbGV4ZXIgYmFzZWQgb24gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvcGF0aHMuaHRtbCNQYXRoRGF0YUJORlxuICAgICAgICAgICAgZCA9IGQucmVwbGFjZSgvLC9nbSwnICcpOyAvLyBnZXQgcmlkIG9mIGFsbCBjb21tYXNcbiAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoLyhbTW1aekxsSGhWdkNjU3NRcVR0QWFdKShbTW1aekxsSGhWdkNjU3NRcVR0QWFdKS9nbSwnJDEgJDInKTsgLy8gc2VwYXJhdGUgY29tbWFuZHMgZnJvbSBjb21tYW5kc1xuICAgICAgICAgICAgZCA9IGQucmVwbGFjZSgvKFtNbVp6TGxIaFZ2Q2NTc1FxVHRBYV0pKFtNbVp6TGxIaFZ2Q2NTc1FxVHRBYV0pL2dtLCckMSAkMicpOyAvLyBzZXBhcmF0ZSBjb21tYW5kcyBmcm9tIGNvbW1hbmRzXG4gICAgICAgICAgICBkID0gZC5yZXBsYWNlKC8oW01tWnpMbEhoVnZDY1NzUXFUdEFhXSkoW15cXHNdKS9nbSwnJDEgJDInKTsgLy8gc2VwYXJhdGUgY29tbWFuZHMgZnJvbSBwb2ludHNcbiAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoLyhbXlxcc10pKFtNbVp6TGxIaFZ2Q2NTc1FxVHRBYV0pL2dtLCckMSAkMicpOyAvLyBzZXBhcmF0ZSBjb21tYW5kcyBmcm9tIHBvaW50c1xuICAgICAgICAgICAgZCA9IGQucmVwbGFjZSgvKFswLTldKShbK1xcLV0pL2dtLCckMSAkMicpOyAvLyBzZXBhcmF0ZSBkaWdpdHMgd2hlbiBubyBjb21tYVxuICAgICAgICAgICAgZCA9IGQucmVwbGFjZSgvKFxcLlswLTldKikoXFwuKS9nbSwnJDEgJDInKTsgLy8gc2VwYXJhdGUgZGlnaXRzIHdoZW4gbm8gY29tbWFcbiAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoLyhbQWFdKFxccytbMC05XSspezN9KVxccysoWzAxXSlcXHMqKFswMV0pL2dtLCckMSAkMyAkNCAnKTsgLy8gc2hvcnRoYW5kIGVsbGlwdGljYWwgYXJjIHBhdGggc3ludGF4XG4gICAgICAgICAgICBkID0gc3ZnLmNvbXByZXNzU3BhY2VzKGQpOyAvLyBjb21wcmVzcyBtdWx0aXBsZSBzcGFjZXNcbiAgICAgICAgICAgIGQgPSBzdmcudHJpbShkKTtcbiAgICAgICAgICAgIHRoaXMuUGF0aFBhcnNlciA9IG5ldyAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zID0gZC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQ29tbWFuZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IHN2Zy5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sID0gbmV3IHN2Zy5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IHN2Zy5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmdsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuaXNFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaSA+PSB0aGlzLnRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ29tbWFuZE9yRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRW5kKCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pICsgMV0ubWF0Y2goL15bQS1aYS16XSQvKSAhPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVsYXRpdmVDb21tYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCh0aGlzLmNvbW1hbmQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmkrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2NhbGFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuZ2V0VG9rZW4oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMubmV4dENvbW1hbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSB0aGlzLmNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZCA9IHRoaXMuZ2V0VG9rZW4oKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBzdmcuUG9pbnQodGhpcy5nZXRTY2FsYXIoKSwgdGhpcy5nZXRTY2FsYXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VBYnNvbHV0ZShwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBc0NvbnRyb2xQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QXNDdXJyZW50UG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmdldFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwOyAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c0NvbW1hbmQudG9Mb3dlckNhc2UoKSAhPSAnYycgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQ29tbWFuZC50b0xvd2VyQ2FzZSgpICE9ICdzJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQudG9Mb3dlckNhc2UoKSAhPSAncScgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQ29tbWFuZC50b0xvd2VyQ2FzZSgpICE9ICd0JyApe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVmbGVjdCBwb2ludFxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBzdmcuUG9pbnQoMiAqIHRoaXMuY3VycmVudC54IC0gdGhpcy5jb250cm9sLngsIDIgKiB0aGlzLmN1cnJlbnQueSAtIHRoaXMuY29udHJvbC55KTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlQWJzb2x1dGUgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmVsYXRpdmVDb21tYW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAueCArPSB0aGlzLmN1cnJlbnQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAueSArPSB0aGlzLmN1cnJlbnQueTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRNYXJrZXIgPSBmdW5jdGlvbihwLCBmcm9tLCBwcmlvclRvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsYXN0IGFuZ2xlIGlzbid0IGZpbGxlZCBpbiBiZWNhdXNlIHdlIGRpZG4ndCBoYXZlIHRoaXMgcG9pbnQgeWV0IC4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJpb3JUbyAhPSBudWxsICYmIHRoaXMuYW5nbGVzLmxlbmd0aCA+IDAgJiYgdGhpcy5hbmdsZXNbdGhpcy5hbmdsZXMubGVuZ3RoLTFdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzW3RoaXMuYW5nbGVzLmxlbmd0aC0xXSA9IHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aC0xXS5hbmdsZVRvKHByaW9yVG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTWFya2VyQW5nbGUocCwgZnJvbSA9PSBudWxsID8gbnVsbCA6IGZyb20uYW5nbGVUbyhwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkTWFya2VyQW5nbGUgPSBmdW5jdGlvbihwLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzLnB1c2goYSk7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TWFya2VyUG9pbnRzID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnBvaW50czsgfVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TWFya2VyQW5nbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmFuZ2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5nbGVzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqPWkrMTsgajx0aGlzLmFuZ2xlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmdsZXNbal0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmdsZXNbaV0gPSB0aGlzLmFuZ2xlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFuZ2xlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KShkKTtcblxuICAgICAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBwID0gdGhpcy5QYXRoUGFyc2VyO1xuICAgICAgICAgICAgICAgIHBwLnJlc2V0KCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYmIgPSBuZXcgc3ZnLkJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0VuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBwLm5leHRDb21tYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHAuY29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcC5hZGRNYXJrZXIocCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYi5hZGRQb2ludChwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHAuc3RhcnQgPSBwcC5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmFkZE1hcmtlcihwLCBwcC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkUG9pbnQocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBwcC5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcC5hZGRNYXJrZXIocCwgYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkUG9pbnQocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1AgPSBuZXcgc3ZnLlBvaW50KChwcC5pc1JlbGF0aXZlQ29tbWFuZCgpID8gcHAuY3VycmVudC54IDogMCkgKyBwcC5nZXRTY2FsYXIoKSwgcHAuY3VycmVudC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcC5hZGRNYXJrZXIobmV3UCwgcHAuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuY3VycmVudCA9IG5ld1A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkUG9pbnQocHAuY3VycmVudC54LCBwcC5jdXJyZW50LnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyhwcC5jdXJyZW50LngsIHBwLmN1cnJlbnQueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1AgPSBuZXcgc3ZnLlBvaW50KHBwLmN1cnJlbnQueCwgKHBwLmlzUmVsYXRpdmVDb21tYW5kKCkgPyBwcC5jdXJyZW50LnkgOiAwKSArIHBwLmdldFNjYWxhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcC5hZGRNYXJrZXIobmV3UCwgcHAuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuY3VycmVudCA9IG5ld1A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkUG9pbnQocHAuY3VycmVudC54LCBwcC5jdXJyZW50LnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyhwcC5jdXJyZW50LngsIHBwLmN1cnJlbnQueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnIgPSBwcC5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwMSA9IHBwLmdldFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNudHJsID0gcHAuZ2V0QXNDb250cm9sUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmFkZE1hcmtlcihjcCwgY250cmwsIHAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYi5hZGRCZXppZXJDdXJ2ZShjdXJyLngsIGN1cnIueSwgcDEueCwgcDEueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHguYmV6aWVyQ3VydmVUbyhwMS54LCBwMS55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyciA9IHBwLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAxID0gcHAuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNudHJsID0gcHAuZ2V0QXNDb250cm9sUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmFkZE1hcmtlcihjcCwgY250cmwsIHAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYi5hZGRCZXppZXJDdXJ2ZShjdXJyLngsIGN1cnIueSwgcDEueCwgcDEueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHguYmV6aWVyQ3VydmVUbyhwMS54LCBwMS55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyciA9IHBwLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNudHJsID0gcHAuZ2V0QXNDb250cm9sUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmFkZE1hcmtlcihjcCwgY250cmwsIGNudHJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYi5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyLngsIGN1cnIueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHgucXVhZHJhdGljQ3VydmVUbyhjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyciA9IHBwLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNudHJsID0gcHAuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuY29udHJvbCA9IGNudHJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuYWRkTWFya2VyKGNwLCBjbnRybCwgY250cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJiLmFkZFF1YWRyYXRpY0N1cnZlKGN1cnIueCwgY3Vyci55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNudHJsLngsIGNudHJsLnksIGNwLngsIGNwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyID0gcHAuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBwcC5nZXRTY2FsYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBwcC5nZXRTY2FsYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeEF4aXNSb3RhdGlvbiA9IHBwLmdldFNjYWxhcigpICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhcmdlQXJjRmxhZyA9IHBwLmdldFNjYWxhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzd2VlcEZsYWcgPSBwcC5nZXRTY2FsYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVyc2lvbiBmcm9tIGVuZHBvaW50IHRvIGNlbnRlciBwYXJhbWV0ZXJpemF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geDEnLCB5MSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycnAgPSBuZXcgc3ZnLlBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIChjdXJyLnggLSBjcC54KSAvIDIuMCArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogKGN1cnIueSAtIGNwLnkpIC8gMi4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiAoY3Vyci54IC0gY3AueCkgLyAyLjAgKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIChjdXJyLnkgLSBjcC55KSAvIDIuMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRqdXN0IHJhZGlpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBNYXRoLnBvdyhjdXJycC54LDIpL01hdGgucG93KHJ4LDIpK01hdGgucG93KGN1cnJwLnksMikvTWF0aC5wb3cocnksMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ4ICo9IE1hdGguc3FydChsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnkgKj0gTWF0aC5zcXJ0KGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjeCcsIGN5J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gKGxhcmdlQXJjRmxhZyA9PSBzd2VlcEZsYWcgPyAtMSA6IDEpICogTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKE1hdGgucG93KHJ4LDIpKk1hdGgucG93KHJ5LDIpKS0oTWF0aC5wb3cocngsMikqTWF0aC5wb3coY3VycnAueSwyKSktKE1hdGgucG93KHJ5LDIpKk1hdGgucG93KGN1cnJwLngsMikpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChNYXRoLnBvdyhyeCwyKSpNYXRoLnBvdyhjdXJycC55LDIpK01hdGgucG93KHJ5LDIpKk1hdGgucG93KGN1cnJwLngsMikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocykpIHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcHAgPSBuZXcgc3ZnLlBvaW50KHMgKiByeCAqIGN1cnJwLnkgLyByeSwgcyAqIC1yeSAqIGN1cnJwLnggLyByeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3gsIGN5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRwID0gbmV3IHN2Zy5Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnIueCArIGNwLngpIC8gMi4wICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiBjcHAueCAtIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyLnkgKyBjcC55KSAvIDIuMCArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnggKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2ZWN0b3IgbWFnbml0dWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBmdW5jdGlvbih2KSB7IHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codlswXSwyKSArIE1hdGgucG93KHZbMV0sMikpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmF0aW8gYmV0d2VlbiB0d28gdmVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZnVuY3Rpb24odSwgdikgeyByZXR1cm4gKHVbMF0qdlswXSt1WzFdKnZbMV0pIC8gKG0odSkqbSh2KSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZ2xlIGJldHdlZW4gdHdvIHZlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGZ1bmN0aW9uKHUsIHYpIHsgcmV0dXJuICh1WzBdKnZbMV0gPCB1WzFdKnZbMF0gPyAtMSA6IDEpICogTWF0aC5hY29zKHIodSx2KSk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsIGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGExID0gYShbMSwwXSwgWyhjdXJycC54LWNwcC54KS9yeCwoY3VycnAueS1jcHAueSkvcnldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmdsZSBkZWx0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gWyhjdXJycC54LWNwcC54KS9yeCwoY3VycnAueS1jcHAueSkvcnldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gWygtY3VycnAueC1jcHAueCkvcngsKC1jdXJycC55LWNwcC55KS9yeV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkID0gYSh1LCB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocih1LHYpIDw9IC0xKSBhZCA9IE1hdGguUEk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIodSx2KSA+PSAxKSBhZCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgbWFya2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXIgPSAxIC0gc3dlZXBGbGFnID8gMS4wIDogLTEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWggPSBhMSArIGRpciAqIChhZCAvIDIuMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbGZXYXkgPSBuZXcgc3ZnLlBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50cC54ICsgcnggKiBNYXRoLmNvcyhhaCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRwLnkgKyByeSAqIE1hdGguc2luKGFoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuYWRkTWFya2VyQW5nbGUoaGFsZldheSwgYWggLSBkaXIgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuYWRkTWFya2VyQW5nbGUoY3AsIGFoIC0gZGlyICogTWF0aC5QSSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYi5hZGRQb2ludChjcC54LCBjcC55KTsgLy8gVE9ETzogdGhpcyBpcyB0b28gbmFpdmUsIG1ha2UgaXQgYmV0dGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gcnggPiByeSA/IHJ4IDogcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IHJ4ID4gcnkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gcnggPiByeSA/IHJ5IC8gcnggOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY2VudHAueCwgY2VudHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoeEF4aXNSb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzeCwgc3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIGExLCBhMSArIGFkLCAxIC0gc3dlZXBGbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEvc3gsIDEvc3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKC14QXhpc1JvdGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY2VudHAueCwgLWNlbnRwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBwLmN1cnJlbnQgPSBwcC5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBiYjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuUGF0aFBhcnNlci5nZXRNYXJrZXJQb2ludHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGVzID0gdGhpcy5QYXRoUGFyc2VyLmdldE1hcmtlckFuZ2xlcygpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBtYXJrZXJzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goW3BvaW50c1tpXSwgYW5nbGVzW2ldXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnBhdGgucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIHBhdHRlcm4gZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5wYXR0ZXJuID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUGF0dGVybiA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS50b1BpeGVscygneScsIHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBTdmcgPSBuZXcgc3ZnLkVsZW1lbnQuc3ZnKCk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzWyd2aWV3Qm94J10gPSBuZXcgc3ZnLlByb3BlcnR5KCd2aWV3Qm94JywgdGhpcy5hdHRyaWJ1dGUoJ3ZpZXdCb3gnKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzWyd3aWR0aCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnd2lkdGgnLCB3aWR0aCArICdweCcpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3RyYW5zZm9ybSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndHJhbnNmb3JtJywgdGhpcy5hdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICBjLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgYy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIGNjdHggPSBjLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCd4JykuaGFzVmFsdWUoKSAmJiB0aGlzLmF0dHJpYnV0ZSgneScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2N0eC50cmFuc2xhdGUodGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcsIHRydWUpLCB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5JywgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgM3gzIGdyaWQgc28gd2hlbiB3ZSB0cmFuc2Zvcm0gdGhlcmUncyBubyB3aGl0ZSBzcGFjZSBvbiBlZGdlc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHg9LTE7IHg8PTE7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5PS0xOyB5PD0xOyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2N0eC50cmFuc2xhdGUoeCAqIGMud2lkdGgsIHkgKiBjLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLnJlbmRlcihjY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4oYywgJ3JlcGVhdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnBhdHRlcm4ucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gbWFya2VyIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQubWFya2VyID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYmFzZVJlbmRlciA9IHRoaXMucmVuZGVyO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgsIHBvaW50LCBhbmdsZSkge1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdvcmllbnQnKS52YWx1ZU9yRGVmYXVsdCgnYXV0bycpID09ICdhdXRvJykgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdtYXJrZXJVbml0cycpLnZhbHVlT3JEZWZhdWx0KCdzdHJva2VXaWR0aCcpID09ICdzdHJva2VXaWR0aCcpIGN0eC5zY2FsZShjdHgubGluZVdpZHRoLCBjdHgubGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxuICAgICAgICAgICAgICAgIHZhciB0ZW1wU3ZnID0gbmV3IHN2Zy5FbGVtZW50LnN2ZygpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1sndmlld0JveCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndmlld0JveCcsIHRoaXMuYXR0cmlidXRlKCd2aWV3Qm94JykudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1sncmVmWCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgncmVmWCcsIHRoaXMuYXR0cmlidXRlKCdyZWZYJykudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1sncmVmWSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgncmVmWScsIHRoaXMuYXR0cmlidXRlKCdyZWZZJykudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snd2lkdGgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3dpZHRoJywgdGhpcy5hdHRyaWJ1dGUoJ21hcmtlcldpZHRoJykudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCB0aGlzLmF0dHJpYnV0ZSgnbWFya2VySGVpZ2h0JykudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snZmlsbCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnZmlsbCcsIHRoaXMuYXR0cmlidXRlKCdmaWxsJykudmFsdWVPckRlZmF1bHQoJ2JsYWNrJykpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snc3Ryb2tlJ10gPSBuZXcgc3ZnLlByb3BlcnR5KCdzdHJva2UnLCB0aGlzLmF0dHJpYnV0ZSgnc3Ryb2tlJykudmFsdWVPckRlZmF1bHQoJ25vbmUnKSk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnbWFya2VyVW5pdHMnKS52YWx1ZU9yRGVmYXVsdCgnc3Ryb2tlV2lkdGgnKSA9PSAnc3Ryb2tlV2lkdGgnKSBjdHguc2NhbGUoMS9jdHgubGluZVdpZHRoLCAxL2N0eC5saW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnb3JpZW50JykudmFsdWVPckRlZmF1bHQoJ2F1dG8nKSA9PSAnYXV0bycpIGN0eC5yb3RhdGUoLWFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1wb2ludC54LCAtcG9pbnQueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQubWFya2VyLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIGRlZmluaXRpb25zIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuZGVmcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpOyAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBOT09QXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuZGVmcy5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBiYXNlIGZvciBncmFkaWVudHNcbiAgICAgICAgc3ZnLkVsZW1lbnQuR3JhZGllbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRVbml0cyA9IHRoaXMuYXR0cmlidXRlKCdncmFkaWVudFVuaXRzJykudmFsdWVPckRlZmF1bHQoJ29iamVjdEJvdW5kaW5nQm94Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc3RvcHMgPSBbXTsgICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PSAnc3RvcCcpIHRoaXMuc3RvcHMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9ICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0R3JhZGllbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBPVkVSUklERSBNRSFcbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUdyYWRpZW50ID0gZnVuY3Rpb24oY3R4LCBlbGVtZW50LCBwYXJlbnRPcGFjaXR5UHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wc0NvbnRhaW5lciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHNDb250YWluZXIgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBhZGRQYXJlbnRPcGFjaXR5ID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBzdmcuUHJvcGVydHkoJ2NvbG9yJywgY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAuYWRkT3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZyA9IHRoaXMuZ2V0R3JhZGllbnQoY3R4LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZyA9PSBudWxsKSByZXR1cm4gYWRkUGFyZW50T3BhY2l0eShzdG9wc0NvbnRhaW5lci5zdG9wc1tzdG9wc0NvbnRhaW5lci5zdG9wcy5sZW5ndGggLSAxXS5jb2xvcik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHN0b3BzQ29udGFpbmVyLnN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGcuYWRkQ29sb3JTdG9wKHN0b3BzQ29udGFpbmVyLnN0b3BzW2ldLm9mZnNldCwgYWRkUGFyZW50T3BhY2l0eShzdG9wc0NvbnRhaW5lci5zdG9wc1tpXS5jb2xvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXIgYXMgdHJhbnNmb3JtZWQgcGF0dGVybiBvbiB0ZW1wb3JhcnkgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIHZhciByb290VmlldyA9IHN2Zy5WaWV3UG9ydC52aWV3UG9ydHNbMF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBzdmcuRWxlbWVudC5yZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QuYXR0cmlidXRlc1sneCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneCcsIC1zdmcuTUFYX1ZJUlRVQUxfUElYRUxTLzMuMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QuYXR0cmlidXRlc1sneSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneScsIC1zdmcuTUFYX1ZJUlRVQUxfUElYRUxTLzMuMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QuYXR0cmlidXRlc1snd2lkdGgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3dpZHRoJywgc3ZnLk1BWF9WSVJUVUFMX1BJWEVMUyk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCBzdmcuTUFYX1ZJUlRVQUxfUElYRUxTKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cCA9IG5ldyBzdmcuRWxlbWVudC5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmF0dHJpYnV0ZXNbJ3RyYW5zZm9ybSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndHJhbnNmb3JtJywgdGhpcy5hdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBncm91cC5jaGlsZHJlbiA9IFsgcmVjdCBdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBTdmcgPSBuZXcgc3ZnLkVsZW1lbnQuc3ZnKCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1sneCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneCcsIDApO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3knXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3knLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzWyd3aWR0aCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnd2lkdGgnLCByb290Vmlldy53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCByb290Vmlldy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmNoaWxkcmVuID0gWyBncm91cCBdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgYy53aWR0aCA9IHJvb3RWaWV3LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjLmhlaWdodCA9IHJvb3RWaWV3LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBDdHggPSBjLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDdHguZmlsbFN0eWxlID0gZztcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5yZW5kZXIodGVtcEN0eCk7ICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBDdHguY3JlYXRlUGF0dGVybihjLCAnbm8tcmVwZWF0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBnOyAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LkdyYWRpZW50QmFzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBsaW5lYXIgZ3JhZGllbnQgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5saW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkdyYWRpZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRHcmFkaWVudCA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBiYiA9IHRoaXMuZ3JhZGllbnRVbml0cyA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnID8gZWxlbWVudC5nZXRCb3VuZGluZ0JveCgpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXR0cmlidXRlKCd4MScpLmhhc1ZhbHVlKClcbiAgICAgICAgICAgICAgICAgJiYgIXRoaXMuYXR0cmlidXRlKCd5MScpLmhhc1ZhbHVlKClcbiAgICAgICAgICAgICAgICAgJiYgIXRoaXMuYXR0cmlidXRlKCd4MicpLmhhc1ZhbHVlKClcbiAgICAgICAgICAgICAgICAgJiYgIXRoaXMuYXR0cmlidXRlKCd5MicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUoJ3gxJywgdHJ1ZSkudmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSgneTEnLCB0cnVlKS52YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlKCd4MicsIHRydWUpLnZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUoJ3kyJywgdHJ1ZSkudmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gKHRoaXMuZ3JhZGllbnRVbml0cyA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnIFxuICAgICAgICAgICAgICAgICAgICA/IGJiLngoKSArIGJiLndpZHRoKCkgKiB0aGlzLmF0dHJpYnV0ZSgneDEnKS5udW1WYWx1ZSgpIFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuYXR0cmlidXRlKCd4MScpLnRvUGl4ZWxzKCd4JykpO1xuICAgICAgICAgICAgICAgIHZhciB5MSA9ICh0aGlzLmdyYWRpZW50VW5pdHMgPT0gJ29iamVjdEJvdW5kaW5nQm94JyBcbiAgICAgICAgICAgICAgICAgICAgPyBiYi55KCkgKyBiYi5oZWlnaHQoKSAqIHRoaXMuYXR0cmlidXRlKCd5MScpLm51bVZhbHVlKClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmF0dHJpYnV0ZSgneTEnKS50b1BpeGVscygneScpKTtcbiAgICAgICAgICAgICAgICB2YXIgeDIgPSAodGhpcy5ncmFkaWVudFVuaXRzID09ICdvYmplY3RCb3VuZGluZ0JveCcgXG4gICAgICAgICAgICAgICAgICAgID8gYmIueCgpICsgYmIud2lkdGgoKSAqIHRoaXMuYXR0cmlidXRlKCd4MicpLm51bVZhbHVlKClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmF0dHJpYnV0ZSgneDInKS50b1BpeGVscygneCcpKTtcbiAgICAgICAgICAgICAgICB2YXIgeTIgPSAodGhpcy5ncmFkaWVudFVuaXRzID09ICdvYmplY3RCb3VuZGluZ0JveCcgXG4gICAgICAgICAgICAgICAgICAgID8gYmIueSgpICsgYmIuaGVpZ2h0KCkgKiB0aGlzLmF0dHJpYnV0ZSgneTInKS5udW1WYWx1ZSgpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5hdHRyaWJ1dGUoJ3kyJykudG9QaXhlbHMoJ3knKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoeDEgPT0geDIgJiYgeTEgPT0geTIpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmxpbmVhckdyYWRpZW50LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5HcmFkaWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyByYWRpYWwgZ3JhZGllbnQgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5yYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkdyYWRpZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRHcmFkaWVudCA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBiYiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXR0cmlidXRlKCdjeCcpLmhhc1ZhbHVlKCkpIHRoaXMuYXR0cmlidXRlKCdjeCcsIHRydWUpLnZhbHVlID0gJzUwJSc7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZSgnY3knKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgnY3knLCB0cnVlKS52YWx1ZSA9ICc1MCUnO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdHRyaWJ1dGUoJ3InKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgncicsIHRydWUpLnZhbHVlID0gJzUwJSc7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gKHRoaXMuZ3JhZGllbnRVbml0cyA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnIFxuICAgICAgICAgICAgICAgICAgICA/IGJiLngoKSArIGJiLndpZHRoKCkgKiB0aGlzLmF0dHJpYnV0ZSgnY3gnKS5udW1WYWx1ZSgpIFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuYXR0cmlidXRlKCdjeCcpLnRvUGl4ZWxzKCd4JykpO1xuICAgICAgICAgICAgICAgIHZhciBjeSA9ICh0aGlzLmdyYWRpZW50VW5pdHMgPT0gJ29iamVjdEJvdW5kaW5nQm94JyBcbiAgICAgICAgICAgICAgICAgICAgPyBiYi55KCkgKyBiYi5oZWlnaHQoKSAqIHRoaXMuYXR0cmlidXRlKCdjeScpLm51bVZhbHVlKCkgXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5hdHRyaWJ1dGUoJ2N5JykudG9QaXhlbHMoJ3knKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGZ4ID0gY3g7XG4gICAgICAgICAgICAgICAgdmFyIGZ5ID0gY3k7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdmeCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnggPSAodGhpcy5ncmFkaWVudFVuaXRzID09ICdvYmplY3RCb3VuZGluZ0JveCcgXG4gICAgICAgICAgICAgICAgICAgID8gYmIueCgpICsgYmIud2lkdGgoKSAqIHRoaXMuYXR0cmlidXRlKCdmeCcpLm51bVZhbHVlKCkgXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5hdHRyaWJ1dGUoJ2Z4JykudG9QaXhlbHMoJ3gnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnZnknKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ5ID0gKHRoaXMuZ3JhZGllbnRVbml0cyA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnIFxuICAgICAgICAgICAgICAgICAgICA/IGJiLnkoKSArIGJiLmhlaWdodCgpICogdGhpcy5hdHRyaWJ1dGUoJ2Z5JykubnVtVmFsdWUoKSBcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmF0dHJpYnV0ZSgnZnknKS50b1BpeGVscygneScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIHIgPSAodGhpcy5ncmFkaWVudFVuaXRzID09ICdvYmplY3RCb3VuZGluZ0JveCcgXG4gICAgICAgICAgICAgICAgICAgID8gKGJiLndpZHRoKCkgKyBiYi5oZWlnaHQoKSkgLyAyLjAgKiB0aGlzLmF0dHJpYnV0ZSgncicpLm51bVZhbHVlKClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmF0dHJpYnV0ZSgncicpLnRvUGl4ZWxzKCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoZngsIGZ5LCAwLCBjeCwgY3ksIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnJhZGlhbEdyYWRpZW50LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5HcmFkaWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBncmFkaWVudCBzdG9wIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuc3RvcCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMuYXR0cmlidXRlKCdvZmZzZXQnKS5udW1WYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub2Zmc2V0IDwgMCkgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMub2Zmc2V0ID4gMSkgdGhpcy5vZmZzZXQgPSAxO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgc3RvcENvbG9yID0gdGhpcy5zdHlsZSgnc3RvcC1jb2xvcicpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ3N0b3Atb3BhY2l0eScpLmhhc1ZhbHVlKCkpIHN0b3BDb2xvciA9IHN0b3BDb2xvci5hZGRPcGFjaXR5KHRoaXMuc3R5bGUoJ3N0b3Atb3BhY2l0eScpKTtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBzdG9wQ29sb3IudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuc3RvcC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBhbmltYXRpb24gYmFzZSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LkFuaW1hdGVCYXNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN2Zy5BbmltYXRpb25zLnB1c2godGhpcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSAwLjA7XG4gICAgICAgICAgICB0aGlzLmJlZ2luID0gdGhpcy5hdHRyaWJ1dGUoJ2JlZ2luJykudG9NaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgIHRoaXMubWF4RHVyYXRpb24gPSB0aGlzLmJlZ2luICsgdGhpcy5hdHRyaWJ1dGUoJ2R1cicpLnRvTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0UHJvcGVydHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlVHlwZSA9IHRoaXMuYXR0cmlidXRlKCdhdHRyaWJ1dGVUeXBlJykudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmF0dHJpYnV0ZSgnYXR0cmlidXRlTmFtZScpLnZhbHVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVUeXBlID09ICdDU1MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5zdHlsZShhdHRyaWJ1dGVOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCB0cnVlKTsgICAgICAgICAgXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxVbml0cyA9ICcnO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVkID0gZmFsc2U7ICAgICAgIFxuXG4gICAgICAgICAgICB0aGlzLmNhbGNWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIE9WRVJSSURFIE1FIVxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKGRlbHRhKSB7IFxuICAgICAgICAgICAgICAgIC8vIHNldCBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSB0aGlzLmdldFByb3BlcnR5KCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbFVuaXRzID0gdGhpcy5nZXRQcm9wZXJ0eSgpLmdldFVuaXRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgcGFzdCB0aGUgZW5kIHRpbWVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kdXJhdGlvbiA+IHRoaXMubWF4RHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCBmb3IgaW5kZWZpbml0ZWx5IHJlcGVhdGluZyBhbmltYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgncmVwZWF0Q291bnQnKS52YWx1ZSA9PSAnaW5kZWZpbml0ZSdcbiAgICAgICAgICAgICAgICAgICAgIHx8IHRoaXMuYXR0cmlidXRlKCdyZXBlYXREdXInKS52YWx1ZSA9PSAnaW5kZWZpbml0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSAwLjBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmF0dHJpYnV0ZSgnZmlsbCcpLnZhbHVlT3JEZWZhdWx0KCdyZW1vdmUnKSA9PSAnZnJlZXplJyAmJiAhdGhpcy5mcm96ZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmFuaW1hdGlvbkZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5hbmltYXRpb25Gcm96ZW5WYWx1ZSA9IHRoaXMuZ2V0UHJvcGVydHkoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmF0dHJpYnV0ZSgnZmlsbCcpLnZhbHVlT3JEZWZhdWx0KCdyZW1vdmUnKSA9PSAncmVtb3ZlJyAmJiAhdGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRQcm9wZXJ0eSgpLnZhbHVlID0gdGhpcy5wYXJlbnQuYW5pbWF0aW9uRnJvemVuID8gdGhpcy5wYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgOiB0aGlzLmluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbiArIGRlbHRhO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgcGFzdCB0aGUgYmVnaW4gdGltZVxuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmVnaW4gPCB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY2FsY1ZhbHVlKCk7IC8vIHR3ZWVuXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ3R5cGUnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdHJhbnNmb3JtLCBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuYXR0cmlidXRlKCd0eXBlJykudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHR5cGUgKyAnKCcgKyBuZXdWYWx1ZSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRQcm9wZXJ0eSgpLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy5hdHRyaWJ1dGUoJ2Zyb20nKTtcbiAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmF0dHJpYnV0ZSgndG8nKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdGhpcy5hdHRyaWJ1dGUoJ3ZhbHVlcycpO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVzLmhhc1ZhbHVlKCkpIHRoaXMudmFsdWVzLnZhbHVlID0gdGhpcy52YWx1ZXMudmFsdWUuc3BsaXQoJzsnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gZnJhY3Rpb24gb2YgZHVyYXRpb24gd2UndmUgY292ZXJlZFxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSB7IHByb2dyZXNzOiAodGhpcy5kdXJhdGlvbiAtIHRoaXMuYmVnaW4pIC8gKHRoaXMubWF4RHVyYXRpb24gLSB0aGlzLmJlZ2luKSB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gcmV0LnByb2dyZXNzICogKHRoaXMudmFsdWVzLnZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGIgPSBNYXRoLmZsb29yKHApLCB1YiA9IE1hdGguY2VpbChwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0LmZyb20gPSBuZXcgc3ZnLlByb3BlcnR5KCdmcm9tJywgcGFyc2VGbG9hdCh0aGlzLnZhbHVlcy52YWx1ZVtsYl0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnRvID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndG8nLCBwYXJzZUZsb2F0KHRoaXMudmFsdWVzLnZhbHVlW3ViXSkpO1xuICAgICAgICAgICAgICAgICAgICByZXQucHJvZ3Jlc3MgPSAocCAtIGxiKSAvICh1YiAtIGxiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5mcm9tID0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgICAgICAgICByZXQudG8gPSB0aGlzLnRvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuQW5pbWF0ZUJhc2UucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gYW5pbWF0ZSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmFuaW1hdGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jYWxjVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMucHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHAuZnJvbS5udW1WYWx1ZSgpICsgKHAudG8ubnVtVmFsdWUoKSAtIHAuZnJvbS5udW1WYWx1ZSgpKSAqIHAucHJvZ3Jlc3M7IFxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdWYWx1ZSArIHRoaXMuaW5pdGlhbFVuaXRzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5hbmltYXRlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAvLyBhbmltYXRlIGNvbG9yIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuYW5pbWF0ZUNvbG9yID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuQW5pbWF0ZUJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FsY1ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSBuZXcgUkdCQ29sb3IocC5mcm9tLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSBuZXcgUkdCQ29sb3IocC50by52YWx1ZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGZyb20ub2sgJiYgdG8ub2spIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdlZW4gY29sb3IgbGluZWFybHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBmcm9tLnIgKyAodG8uciAtIGZyb20ucikgKiBwLnByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IGZyb20uZyArICh0by5nIC0gZnJvbS5nKSAqIHAucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gZnJvbS5iICsgKHRvLmIgLSBmcm9tLmIpICogcC5wcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyZ2IoJytwYXJzZUludChyLDEwKSsnLCcrcGFyc2VJbnQoZywxMCkrJywnK3BhcnNlSW50KGIsMTApKycpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlKCdmcm9tJykudmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmFuaW1hdGVDb2xvci5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuQW5pbWF0ZUJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBhbmltYXRlIHRyYW5zZm9ybSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmFuaW1hdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jYWxjVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMucHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gc3ZnLlRvTnVtYmVyQXJyYXkocC5mcm9tLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSBzdmcuVG9OdW1iZXJBcnJheShwLnRvLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZnJvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSArPSBmcm9tW2ldICsgKHRvW2ldIC0gZnJvbVtpXSkgKiBwLnByb2dyZXNzICsgJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmFuaW1hdGVUcmFuc2Zvcm0ucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LmFuaW1hdGU7XG4gICAgICAgIFxuICAgICAgICAvLyBmb250IGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuZm9udCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuXG4gICAgICAgICAgICB0aGlzLmhvcml6QWR2WCA9IHRoaXMuYXR0cmlidXRlKCdob3Jpei1hZHYteCcpLm51bVZhbHVlKCk7ICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmlzUlRMID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzQXJhYmljID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZvbnRGYWNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubWlzc2luZ0dseXBoID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhzID0gW107ICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PSAnZm9udC1mYWNlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbnRGYWNlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5zdHlsZSgnZm9udC1mYW1pbHknKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmcuRGVmaW5pdGlvbnNbY2hpbGQuc3R5bGUoJ2ZvbnQtZmFtaWx5JykudmFsdWVdID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09ICdtaXNzaW5nLWdseXBoJykgdGhpcy5taXNzaW5nR2x5cGggPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09ICdnbHlwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmFyYWJpY0Zvcm0gIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNSVEwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0FyYWJpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHRoaXMuZ2x5cGhzW2NoaWxkLnVuaWNvZGVdKSA9PSAndW5kZWZpbmVkJykgdGhpcy5nbHlwaHNbY2hpbGQudW5pY29kZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2NoaWxkLnVuaWNvZGVdW2NoaWxkLmFyYWJpY0Zvcm1dID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdseXBoc1tjaGlsZC51bmljb2RlXSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgIFxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmZvbnQucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gZm9udC1mYWNlIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuZm9udGZhY2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTsgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXNjZW50ID0gdGhpcy5hdHRyaWJ1dGUoJ2FzY2VudCcpLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kZXNjZW50ID0gdGhpcy5hdHRyaWJ1dGUoJ2Rlc2NlbnQnKS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudW5pdHNQZXJFbSA9IHRoaXMuYXR0cmlidXRlKCd1bml0cy1wZXItZW0nKS5udW1WYWx1ZSgpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5mb250ZmFjZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBtaXNzaW5nLWdseXBoIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQubWlzc2luZ2dseXBoID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQucGF0aDtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTsgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaG9yaXpBZHZYID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5taXNzaW5nZ2x5cGgucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LnBhdGg7XG4gICAgICAgIFxuICAgICAgICAvLyBnbHlwaCBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmdseXBoID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQucGF0aDtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTsgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaG9yaXpBZHZYID0gdGhpcy5hdHRyaWJ1dGUoJ2hvcml6LWFkdi14JykubnVtVmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMudW5pY29kZSA9IHRoaXMuYXR0cmlidXRlKCd1bmljb2RlJykudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFyYWJpY0Zvcm0gPSB0aGlzLmF0dHJpYnV0ZSgnYXJhYmljLWZvcm0nKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5nbHlwaC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQucGF0aDtcbiAgICAgICAgXG4gICAgICAgIC8vIHRleHQgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC50ZXh0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlVGV4dE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYmFzZVNldENvbnRleHQgPSB0aGlzLnNldENvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLnNldENvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2VTZXRDb250ZXh0KGN0eCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIHRleHRCYXNlbGluZSA9IHRoaXMuc3R5bGUoJ2RvbWluYW50LWJhc2VsaW5lJykudG9UZXh0QmFzZWxpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEJhc2VsaW5lID09IG51bGwpIHRleHRCYXNlbGluZSA9IHRoaXMuc3R5bGUoJ2FsaWdubWVudC1iYXNlbGluZScpLnRvVGV4dEJhc2VsaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRCYXNlbGluZSAhPSBudWxsKSBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMucGFyZW50LnN0eWxlKCdmb250LXNpemUnKS5udW1WYWx1ZU9yRGVmYXVsdChzdmcuRm9udC5QYXJzZShzdmcuY3R4LmZvbnQpLmZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveCh4LCB5IC0gZm9udFNpemUsIHggKyBNYXRoLmZsb29yKGZvbnRTaXplICogMi4wIC8gMy4wKSAqIHRoaXMuY2hpbGRyZW5bMF0uZ2V0VGV4dCgpLmxlbmd0aCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIHRoaXMueCArPSB0aGlzLmdldEFuY2hvckRlbHRhKGN0eCwgdGhpcywgMCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZChjdHgsIHRoaXMsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRBbmNob3JEZWx0YSA9IGZ1bmN0aW9uIChjdHgsIHBhcmVudCwgc3RhcnRJKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbmNob3IgPSB0aGlzLnN0eWxlKCd0ZXh0LWFuY2hvcicpLnZhbHVlT3JEZWZhdWx0KCdzdGFydCcpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0QW5jaG9yICE9ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT1zdGFydEk7IGk8cGFyZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IHN0YXJ0SSAmJiBjaGlsZC5hdHRyaWJ1dGUoJ3gnKS5oYXNWYWx1ZSgpKSBicmVhazsgLy8gbmV3IGdyb3VwXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSBjaGlsZC5tZWFzdXJlVGV4dFJlY3Vyc2l2ZShjdHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMSAqICh0ZXh0QW5jaG9yID09ICdlbmQnID8gd2lkdGggOiB3aWR0aCAvIDIuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkID0gZnVuY3Rpb24oY3R4LCBwYXJlbnQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQueCA9IGNoaWxkLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4JykgKyB0aGlzLmdldEFuY2hvckRlbHRhKGN0eCwgcGFyZW50LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZSgnZHgnKS5oYXNWYWx1ZSgpKSBjaGlsZC54ICs9IGNoaWxkLmF0dHJpYnV0ZSgnZHgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdkeCcpLmhhc1ZhbHVlKCkpIHRoaXMueCArPSB0aGlzLmF0dHJpYnV0ZSgnZHgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuYXR0cmlidXRlKCdkeCcpLmhhc1ZhbHVlKCkpIHRoaXMueCArPSBjaGlsZC5hdHRyaWJ1dGUoJ2R4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQueCA9IHRoaXMueDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gY2hpbGQueCArIGNoaWxkLm1lYXN1cmVUZXh0KGN0eCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZSgneScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQueSA9IGNoaWxkLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGUoJ2R5JykuaGFzVmFsdWUoKSkgY2hpbGQueSArPSBjaGlsZC5hdHRyaWJ1dGUoJ2R5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnZHknKS5oYXNWYWx1ZSgpKSB0aGlzLnkgKz0gdGhpcy5hdHRyaWJ1dGUoJ2R5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZSgnZHknKS5oYXNWYWx1ZSgpKSB0aGlzLnkgKz0gY2hpbGQuYXR0cmlidXRlKCdkeScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnkgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMueSA9IGNoaWxkLnk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2hpbGQucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGNoaWxkLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGQoY3R4LCBjaGlsZCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnRleHQucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyB0ZXh0IGJhc2VcbiAgICAgICAgc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRHbHlwaCA9IGZ1bmN0aW9uKGZvbnQsIHRleHQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRleHRbaV07XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZm9udC5pc0FyYWJpYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJhYmljRm9ybSA9ICdpc29sYXRlZCc7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoaT09MCB8fCB0ZXh0W2ktMV09PScgJykgJiYgaTx0ZXh0Lmxlbmd0aC0yICYmIHRleHRbaSsxXSE9JyAnKSBhcmFiaWNGb3JtID0gJ3Rlcm1pbmFsJzsgXG4gICAgICAgICAgICAgICAgICAgIGlmIChpPjAgJiYgdGV4dFtpLTFdIT0nICcgJiYgaTx0ZXh0Lmxlbmd0aC0yICYmIHRleHRbaSsxXSE9JyAnKSBhcmFiaWNGb3JtID0gJ21lZGlhbCc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpPjAgJiYgdGV4dFtpLTFdIT0nICcgJiYgKGkgPT0gdGV4dC5sZW5ndGgtMSB8fCB0ZXh0W2krMV09PScgJykpIGFyYWJpY0Zvcm0gPSAnaW5pdGlhbCc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoZm9udC5nbHlwaHNbY10pICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzW2NdW2FyYWJpY0Zvcm1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdseXBoID09IG51bGwgJiYgZm9udC5nbHlwaHNbY10udHlwZSA9PSAnZ2x5cGgnKSBnbHlwaCA9IGZvbnQuZ2x5cGhzW2NdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzW2NdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGggPT0gbnVsbCkgZ2x5cGggPSBmb250Lm1pc3NpbmdHbHlwaDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2x5cGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VzdG9tRm9udCA9IHRoaXMucGFyZW50LnN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tRm9udCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMucGFyZW50LnN0eWxlKCdmb250LXNpemUnKS5udW1WYWx1ZU9yRGVmYXVsdChzdmcuRm9udC5QYXJzZShzdmcuY3R4LmZvbnQpLmZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnRTdHlsZSA9IHRoaXMucGFyZW50LnN0eWxlKCdmb250LXN0eWxlJykudmFsdWVPckRlZmF1bHQoc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tRm9udC5pc1JUTCkgdGV4dCA9IHRleHQuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLnBhcmVudC5hdHRyaWJ1dGUoJ2R4JykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaChjdXN0b21Gb250LCB0ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IGZvbnRTaXplIC8gY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoc2NhbGUsIC1zY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbHcgPSBjdHgubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGN0eC5saW5lV2lkdGggKiBjdXN0b21Gb250LmZvbnRGYWNlLnVuaXRzUGVyRW0gLyBmb250U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb250U3R5bGUgPT0gJ2l0YWxpYycpIGN0eC50cmFuc2Zvcm0oMSwgMCwgLjQsIDEsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2x5cGgucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9udFN0eWxlID09ICdpdGFsaWMnKSBjdHgudHJhbnNmb3JtKDEsIDAsIC0uNCwgMSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbHc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoMS9zY2FsZSwgLTEvc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdGhpcy54LCAtdGhpcy55KTsgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueCArPSBmb250U2l6ZSAqIChnbHlwaC5ob3JpekFkdlggfHwgY3VzdG9tRm9udC5ob3JpekFkdlgpIC8gY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihkeFtpXSkgIT0gJ3VuZGVmaW5lZCcgJiYgIWlzTmFOKGR4W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueCArPSBkeFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGN0eC5maWxsU3R5bGUgIT0gJycpIGN0eC5maWxsVGV4dChzdmcuY29tcHJlc3NTcGFjZXModGhpcy5nZXRUZXh0KCkpLCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSAhPSAnJykgY3R4LnN0cm9rZVRleHQoc3ZnLmNvbXByZXNzU3BhY2VzKHRoaXMuZ2V0VGV4dCgpKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldFRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBPVkVSUklERSBNRVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVUZXh0UmVjdXJzaXZlID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dChjdHgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICs9IHRoaXMuY2hpbGRyZW5baV0ubWVhc3VyZVRleHRSZWN1cnNpdmUoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbUZvbnQgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUZvbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9udFNpemUgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1zaXplJykubnVtVmFsdWVPckRlZmF1bHQoc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZWFzdXJlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1c3RvbUZvbnQuaXNSVEwpIHRleHQgPSB0ZXh0LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLnBhcmVudC5hdHRyaWJ1dGUoJ2R4JykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaChjdXN0b21Gb250LCB0ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmUgKz0gKGdseXBoLmhvcml6QWR2WCB8fCBjdXN0b21Gb250Lmhvcml6QWR2WCkgKiBmb250U2l6ZSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoZHhbaV0pICE9ICd1bmRlZmluZWQnICYmICFpc05hTihkeFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlICs9IGR4W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWFzdXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciB0ZXh0VG9NZWFzdXJlID0gc3ZnLmNvbXByZXNzU3BhY2VzKHRoaXMuZ2V0VGV4dCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWN0eC5tZWFzdXJlVGV4dCkgcmV0dXJuIHRleHRUb01lYXN1cmUubGVuZ3RoICogMTA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvbnRleHQoY3R4KTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGV4dFRvTWVhc3VyZSkud2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gdHNwYW4gXG4gICAgICAgIHN2Zy5FbGVtZW50LnRzcGFuID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlVGV4dE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gbm9kZS5ub2RlVmFsdWUgfHwgbm9kZS50ZXh0IHx8ICcnO1xuICAgICAgICAgICAgdGhpcy5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC50c3Bhbi5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gdHJlZlxuICAgICAgICBzdmcuRWxlbWVudC50cmVmID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldFRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSByZXR1cm4gZWxlbWVudC5jaGlsZHJlblswXS5nZXRUZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQudHJlZi5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlOyAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8vIGEgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5hID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmhhc1RleHQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXNbaV0ubm9kZVR5cGUgIT0gMykgdGhpcy5oYXNUZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHRoaXMgbWlnaHQgY29udGFpbiB0ZXh0XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLmhhc1RleHQgPyBub2RlLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlIDogJyc7XG4gICAgICAgICAgICB0aGlzLmdldFRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgICAgICAgICAgfSAgICAgICBcblxuICAgICAgICAgICAgdGhpcy5iYXNlUmVuZGVyQ2hpbGRyZW4gPSB0aGlzLnJlbmRlckNoaWxkcmVuO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGFzIHRleHQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhc2VSZW5kZXJDaGlsZHJlbihjdHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9udFNpemUgPSBuZXcgc3ZnLlByb3BlcnR5KCdmb250U2l6ZScsIHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBzdmcuTW91c2UuY2hlY2tCb3VuZGluZ0JveCh0aGlzLCBuZXcgc3ZnLkJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55IC0gZm9udFNpemUudG9QaXhlbHMoJ3knKSwgdGhpcy54ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB0aGlzLnkpKTsgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGFzIHRlbXBvcmFyeSBncm91cFxuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IG5ldyBzdmcuRWxlbWVudC5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBnLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGcucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cub3Blbih0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMub25tb3VzZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdmcuY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuYS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlOyAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy8gaW1hZ2UgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5pbWFnZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBocmVmID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkudmFsdWU7XG4gICAgICAgICAgICBpZiAoaHJlZiA9PSAnJykgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHZhciBpc1N2ZyA9IGhyZWYubWF0Y2goL1xcLnN2ZyQvKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdmcuSW1hZ2VzLnB1c2godGhpcyk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpc1N2Zykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWyd1c2VDT1JTJ10gPT0gdHJ1ZSkgeyB0aGlzLmltZy5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnOyB9XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyBzZWxmLmxvYWRlZCA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICB0aGlzLmltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7IHN2Zy5sb2coJ0VSUk9SOiBpbWFnZSBcIicgKyBocmVmICsgJ1wiIG5vdCBmb3VuZCcpOyBzZWxmLmxvYWRlZCA9IHRydWU7IH1cbiAgICAgICAgICAgICAgICB0aGlzLmltZy5zcmMgPSBocmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWcgPSBzdmcuYWpheChocmVmKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTsgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPT0gMCB8fCBoZWlnaHQgPT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdTdmcodGhpcy5pbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgc3ZnLkFzcGVjdFJhdGlvKGN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1nLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWcuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDApOyBcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltZywgMCwgMCk7ICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmltYWdlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gZ3JvdXAgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5nID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBiYiA9IG5ldyBzdmcuQm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYi5hZGRCb3VuZGluZ0JveCh0aGlzLmNoaWxkcmVuW2ldLmdldEJvdW5kaW5nQm94KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmcucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG5cbiAgICAgICAgLy8gc3ltYm9sIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuc3ltYm9sID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBOTyBSRU5ERVJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuc3ltYm9sLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlOyAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgLy8gc3R5bGUgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5zdHlsZSA9IGZ1bmN0aW9uKG5vZGUpIHsgXG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gdGV4dCwgb3Igc3BhY2VzIHRoZW4gQ0RBVEFcbiAgICAgICAgICAgIHZhciBjc3MgPSAnJ1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjc3MgKz0gbm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNzcyA9IGNzcy5yZXBsYWNlKC8oXFwvXFwqKFteKl18W1xcclxcbl18KFxcKisoW14qXFwvXXxbXFxyXFxuXSkpKSpcXCorXFwvKXwoXltcXHNdKlxcL1xcLy4qKS9nbSwgJycpOyAvLyByZW1vdmUgY29tbWVudHNcbiAgICAgICAgICAgIGNzcyA9IHN2Zy5jb21wcmVzc1NwYWNlcyhjc3MpOyAvLyByZXBsYWNlIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHZhciBjc3NEZWZzID0gY3NzLnNwbGl0KCd9Jyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8Y3NzRGVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzdmcudHJpbShjc3NEZWZzW2ldKSAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzRGVmID0gY3NzRGVmc1tpXS5zcGxpdCgneycpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzQ2xhc3NlcyA9IGNzc0RlZlswXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzUHJvcHMgPSBjc3NEZWZbMV0uc3BsaXQoJzsnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPGNzc0NsYXNzZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc3NDbGFzcyA9IHN2Zy50cmltKGNzc0NsYXNzZXNbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0NsYXNzICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaz0wOyBrPGNzc1Byb3BzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wID0gY3NzUHJvcHNba10uaW5kZXhPZignOicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGNzc1Byb3BzW2tdLnN1YnN0cigwLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY3NzUHJvcHNba10uc3Vic3RyKHByb3AgKyAxLCBjc3NQcm9wc1trXS5sZW5ndGggLSBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1tzdmcudHJpbShuYW1lKV0gPSBuZXcgc3ZnLlByb3BlcnR5KHN2Zy50cmltKG5hbWUpLCBzdmcudHJpbSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5TdHlsZXNbY3NzQ2xhc3NdID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0NsYXNzID09ICdAZm9udC1mYWNlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9udEZhbWlseSA9IHByb3BzWydmb250LWZhbWlseSddLnZhbHVlLnJlcGxhY2UoL1wiL2csJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjcyA9IHByb3BzWydzcmMnXS52YWx1ZS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzPTA7IHM8c3Jjcy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNyY3Nbc10uaW5kZXhPZignZm9ybWF0KFwic3ZnXCIpJykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybFN0YXJ0ID0gc3Jjc1tzXS5pbmRleE9mKCd1cmwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsRW5kID0gc3Jjc1tzXS5pbmRleE9mKCcpJywgdXJsU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBzcmNzW3NdLnN1YnN0cih1cmxTdGFydCArIDUsIHVybEVuZCAtIHVybFN0YXJ0IC0gNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IHN2Zy5wYXJzZVhtbChzdmcuYWpheCh1cmwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9udHMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ZvbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmPTA7IGY8Zm9udHMubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnQgPSBzdmcuQ3JlYXRlRWxlbWVudChmb250c1tmXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5EZWZpbml0aW9uc1tmb250RmFtaWx5XSA9IGZvbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnN0eWxlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIHVzZSBlbGVtZW50IFxuICAgICAgICBzdmcuRWxlbWVudC51c2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmJhc2VTZXRDb250ZXh0ID0gdGhpcy5zZXRDb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5zZXRDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlU2V0Q29udGV4dChjdHgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIGN0eC50cmFuc2xhdGUodGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSBjdHgudHJhbnNsYXRlKDAsIHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSBlbGVtZW50LnBhdGgoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9IG51bGwpIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wU3ZnID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50IGluIHN5bWJvbCBjYXNlcyAoaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0cnVjdC5odG1sI1VzZUVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnID0gbmV3IHN2Zy5FbGVtZW50LnN2ZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy50eXBlID0gJ3N2Zyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3ZpZXdCb3gnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3ZpZXdCb3gnLCBlbGVtZW50LmF0dHJpYnV0ZSgndmlld0JveCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1sncHJlc2VydmVBc3BlY3RSYXRpbyddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgncHJlc2VydmVBc3BlY3RSYXRpbycsIGVsZW1lbnQuYXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzWydvdmVyZmxvdyddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnb3ZlcmZsb3cnLCBlbGVtZW50LmF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcFN2Zy50eXBlID09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBzeW1ib2wgb3Igc3ZnLCBpbmhlcml0IHdpZHRoL2hlaWdodCBmcm9tIG1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkgdGVtcFN2Zy5hdHRyaWJ1dGVzWyd3aWR0aCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnd2lkdGgnLCB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLmhhc1ZhbHVlKCkpIHRlbXBTdmcuYXR0cmlidXRlc1snaGVpZ2h0J10gPSBuZXcgc3ZnLlByb3BlcnR5KCdoZWlnaHQnLCB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRQYXJlbnQgPSB0ZW1wU3ZnLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLnBhcmVudCA9IG9sZFBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQudXNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gbWFzayBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50Lm1hc2sgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBhcyB0ZW1wIHN2ZyAgIFxuICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA9PSAwICYmIGhlaWdodCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYiA9IG5ldyBzdmcuQm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJiLmFkZEJvdW5kaW5nQm94KHRoaXMuY2hpbGRyZW5baV0uZ2V0Qm91bmRpbmdCb3goKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKGJiLngxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKGJiLnkxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5mbG9vcihiYi53aWR0aCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IE1hdGguZmxvb3IoYmIuaGVpZ2h0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyB0ZW1wb3JhcmlseSByZW1vdmUgbWFzayB0byBhdm9pZCByZWN1cnNpb25cbiAgICAgICAgICAgICAgICB2YXIgbWFzayA9IGVsZW1lbnQuYXR0cmlidXRlKCdtYXNrJykudmFsdWU7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGUoJ21hc2snKS52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgY01hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgY01hc2sud2lkdGggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNNYXNrLmhlaWdodCA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXNrQ3R4ID0gY01hc2suZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihtYXNrQ3R4KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgYy53aWR0aCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYy5oZWlnaHQgPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcEN0eCA9IGMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW5kZXIodGVtcEN0eCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgICAgICAgICAgICAgICAgdGVtcEN0eC5maWxsU3R5bGUgPSBtYXNrQ3R4LmNyZWF0ZVBhdHRlcm4oY01hc2ssICduby1yZXBlYXQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEN0eC5maWxsUmVjdCgwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRlbXBDdHguY3JlYXRlUGF0dGVybihjLCAnbm8tcmVwZWF0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyByZWFzc2lnbiBtYXNrXG4gICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGUoJ21hc2snKS52YWx1ZSA9IG1hc2s7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIC8vIE5PIFJFTkRFUlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50Lm1hc2sucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gY2xpcCBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmNsaXBQYXRoID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkQmVnaW5QYXRoID0gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5iZWdpblBhdGg7XG4gICAgICAgICAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5iZWdpblBhdGggPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIG9sZENsb3NlUGF0aCA9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuY2xvc2VQYXRoO1xuICAgICAgICAgICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgb2xkQmVnaW5QYXRoLmNhbGwoY3R4KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGNoaWxkLnBhdGgpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGUoJ3RyYW5zZm9ybScpLmhhc1ZhbHVlKCkpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtID0gbmV3IHN2Zy5UcmFuc2Zvcm0oY2hpbGQuYXR0cmlidXRlKCd0cmFuc2Zvcm0nKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmFwcGx5KGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5wYXRoKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmNsb3NlUGF0aCA9IG9sZENsb3NlUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHsgdHJhbnNmb3JtLnVuYXBwbHkoY3R4KTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9sZENsb3NlUGF0aC5jYWxsKGN0eCk7XG4gICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmJlZ2luUGF0aCA9IG9sZEJlZ2luUGF0aDtcbiAgICAgICAgICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmNsb3NlUGF0aCA9IG9sZENsb3NlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBOTyBSRU5ERVJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5jbGlwUGF0aC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG5cbiAgICAgICAgLy8gZmlsdGVyc1xuICAgICAgICBzdmcuRWxlbWVudC5maWx0ZXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBhcyB0ZW1wIHN2ZyAgIFxuICAgICAgICAgICAgICAgIHZhciBiYiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoYmIueDEpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihiYi55MSk7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5mbG9vcihiYi53aWR0aCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5mbG9vcihiYi5oZWlnaHQoKSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0ZW1wb3JhcmlseSByZW1vdmUgZmlsdGVyIHRvIGF2b2lkIHJlY3Vyc2lvblxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBlbGVtZW50LnN0eWxlKCdmaWx0ZXInKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlKCdmaWx0ZXInKS52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBweCA9IDAsIHB5ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWZkID0gdGhpcy5jaGlsZHJlbltpXS5leHRyYUZpbHRlckRpc3RhbmNlIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIHB4ID0gTWF0aC5tYXgocHgsIGVmZCk7XG4gICAgICAgICAgICAgICAgICAgIHB5ID0gTWF0aC5tYXgocHksIGVmZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgYy53aWR0aCA9IHdpZHRoICsgMipweDtcbiAgICAgICAgICAgICAgICBjLmhlaWdodCA9IGhlaWdodCArIDIqcHk7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBDdHggPSBjLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgdGVtcEN0eC50cmFuc2xhdGUoLXggKyBweCwgLXkgKyBweSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW5kZXIodGVtcEN0eCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBhcHBseSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5hcHBseSh0ZW1wQ3R4LCAwLCAwLCB3aWR0aCArIDIqcHgsIGhlaWdodCArIDIqcHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgb24gbWVcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGMsIDAsIDAsIHdpZHRoICsgMipweCwgaGVpZ2h0ICsgMipweSwgeCAtIHB4LCB5IC0gcHksIHdpZHRoICsgMipweCwgaGVpZ2h0ICsgMipweSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gcmVhc3NpZ24gZmlsdGVyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZSgnZmlsdGVyJywgdHJ1ZSkudmFsdWUgPSBmaWx0ZXI7ICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgLy8gTk8gUkVOREVSXG4gICAgICAgICAgICB9ICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmZpbHRlci5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICBzdmcuRWxlbWVudC5mZU1vcnBob2xvZ3kgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmZlTW9ycGhvbG9neS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICBzdmcuRWxlbWVudC5mZUNvbXBvc2l0ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuZmVDb21wb3NpdGUucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgc3ZnLkVsZW1lbnQuZmVDb2xvck1hdHJpeCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gc3ZnLlRvTnVtYmVyQXJyYXkodGhpcy5hdHRyaWJ1dGUoJ3ZhbHVlcycpLnZhbHVlKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5hdHRyaWJ1dGUoJ3R5cGUnKS52YWx1ZU9yRGVmYXVsdCgnbWF0cml4JykpIHsgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ZpbHRlcnMuaHRtbCNmZUNvbG9yTWF0cml4RWxlbWVudFxuICAgICAgICAgICAgICAgIGNhc2UgJ3NhdHVyYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBtYXRyaXhbMF07XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCA9IFswLjIxMyswLjc4NypzLDAuNzE1LTAuNzE1KnMsMC4wNzItMC4wNzIqcywwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjIxMy0wLjIxMypzLDAuNzE1KzAuMjg1KnMsMC4wNzItMC4wNzIqcywwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjIxMy0wLjIxMypzLDAuNzE1LTAuNzE1KnMsMC4wNzIrMC45MjgqcywwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMCwxLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMCwwLDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdodWVSb3RhdGUnOlxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG1hdHJpeFswXSAqIE1hdGguUEkgLyAxODAuMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBmdW5jdGlvbiAobTEsbTIsbTMpIHsgcmV0dXJuIG0xICsgTWF0aC5jb3MoYSkqbTIgKyBNYXRoLnNpbihhKSptMzsgfTtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4ID0gW2MoMC4yMTMsMC43ODcsLTAuMjEzKSxjKDAuNzE1LC0wLjcxNSwtMC43MTUpLGMoMC4wNzIsLTAuMDcyLDAuOTI4KSwwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjKDAuMjEzLC0wLjIxMywwLjE0MyksYygwLjcxNSwwLjI4NSwwLjE0MCksYygwLjA3MiwtMC4wNzIsLTAuMjgzKSwwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjKDAuMjEzLC0wLjIxMywtMC43ODcpLGMoMC43MTUsLTAuNzE1LDAuNzE1KSxjKDAuMDcyLDAuOTI4LDAuMDcyKSwwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMCwxLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMCwwLDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsdW1pbmFuY2VUb0FscGhhJzpcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4ID0gWzAsMCwwLDAsMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsMCwwLDAsMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsMCwwLDAsMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMjEyNSwwLjcxNTQsMC4wNzIxLDAsMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsMCwwLDAsMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBpbUdldChpbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJnYmEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1nW3kqd2lkdGgqNCArIHgqNCArIHJnYmFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBpbVNldChpbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJnYmEsIHZhbCkge1xuICAgICAgICAgICAgICAgIGltZ1t5KndpZHRoKjQgKyB4KjQgKyByZ2JhXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gbShpLCB2KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pID0gbWF0cml4W2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiBtaSAqIChtaSA8IDAgPyB2IC0gMjU1IDogdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3N1bWluZyB4PT0wICYmIHk9PTAgZm9yIG5vd1xuICAgICAgICAgICAgICAgIHZhciBzcmNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCBtKDAscikrbSgxLGcpK20oMixiKSttKDMsYSkrbSg0LDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSwgbSg1LHIpK20oNixnKSttKDcsYikrbSg4LGEpK20oOSwxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDIsIG0oMTAscikrbSgxMSxnKSttKDEyLGIpK20oMTMsYSkrbSgxNCwxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMsIG0oMTUscikrbSgxNixnKSttKDE3LGIpK20oMTgsYSkrbSgxOSwxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKHNyY0RhdGEsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmZlQ29sb3JNYXRyaXgucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgc3ZnLkVsZW1lbnQuZmVHYXVzc2lhbkJsdXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcblxuICAgICAgICAgICAgdGhpcy5ibHVyUmFkaXVzID0gTWF0aC5mbG9vcih0aGlzLmF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJykubnVtVmFsdWUoKSk7XG4gICAgICAgICAgICB0aGlzLmV4dHJhRmlsdGVyRGlzdGFuY2UgPSB0aGlzLmJsdXJSYWRpdXM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHN0YWNrQmx1ckNhbnZhc1JHQkEpID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN2Zy5sb2coJ0VSUk9SOiBTdGFja0JsdXIuanMgbXVzdCBiZSBpbmNsdWRlZCBmb3IgYmx1ciB0byB3b3JrJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU3RhY2tCbHVyIHJlcXVpcmVzIGNhbnZhcyBiZSBvbiBkb2N1bWVudFxuICAgICAgICAgICAgICAgIGN0eC5jYW52YXMuaWQgPSBzdmcuVW5pcXVlSWQoKTtcbiAgICAgICAgICAgICAgICBjdHguY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjdHguY2FudmFzKTtcbiAgICAgICAgICAgICAgICBzdGFja0JsdXJDYW52YXNSR0JBKGN0eC5jYW52YXMuaWQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMuYmx1clJhZGl1cyk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjdHguY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5mZUdhdXNzaWFuQmx1ci5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyB0aXRsZSBlbGVtZW50LCBkbyBub3RoaW5nXG4gICAgICAgIHN2Zy5FbGVtZW50LnRpdGxlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnRpdGxlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcblxuICAgICAgICAvLyBkZXNjIGVsZW1lbnQsIGRvIG5vdGhpbmdcbiAgICAgICAgc3ZnLkVsZW1lbnQuZGVzYyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5kZXNjLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTsgICAgICAgXG4gICAgICAgIFxuICAgICAgICBzdmcuRWxlbWVudC5NSVNTSU5HID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgc3ZnLmxvZygnRVJST1I6IEVsZW1lbnQgXFwnJyArIG5vZGUubm9kZU5hbWUgKyAnXFwnIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuTUlTU0lORy5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBlbGVtZW50IGZhY3RvcnlcbiAgICAgICAgc3ZnLkNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7ICAgIFxuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IG5vZGUubm9kZU5hbWUucmVwbGFjZSgvXlteOl0rOi8sJycpOyAvLyByZW1vdmUgbmFtZXNwYWNlXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUucmVwbGFjZSgvXFwtL2csJycpOyAvLyByZW1vdmUgZGFzaGVzXG4gICAgICAgICAgICB2YXIgZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHN2Zy5FbGVtZW50W2NsYXNzTmFtZV0pICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZSA9IG5ldyBzdmcuRWxlbWVudFtjbGFzc05hbWVdKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZSA9IG5ldyBzdmcuRWxlbWVudC5NSVNTSU5HKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLnR5cGUgPSBub2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgLy8gbG9hZCBmcm9tIHVybFxuICAgICAgICBzdmcubG9hZCA9IGZ1bmN0aW9uKGN0eCwgdXJsKSB7XG4gICAgICAgICAgICBzdmcubG9hZFhtbChjdHgsIHN2Zy5hamF4KHVybCkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBsb2FkIGZyb20geG1sXG4gICAgICAgIHN2Zy5sb2FkWG1sID0gZnVuY3Rpb24oY3R4LCB4bWwpIHtcbiAgICAgICAgICAgIHN2Zy5sb2FkWG1sRG9jKGN0eCwgc3ZnLnBhcnNlWG1sKHhtbCkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzdmcubG9hZFhtbERvYyA9IGZ1bmN0aW9uKGN0eCwgZG9tKSB7XG4gICAgICAgICAgICBzdmcuaW5pdChjdHgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbWFwWFkgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBjdHguY2FudmFzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHAueCAtPSBlLm9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHAueSAtPSBlLm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUub2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod2luZG93LnNjcm9sbFgpIHAueCArPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LnNjcm9sbFkpIHAueSArPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYmluZCBtb3VzZVxuICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydpZ25vcmVNb3VzZSddICE9IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjdHguY2FudmFzLm9uY2xpY2sgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gbWFwWFkobmV3IHN2Zy5Qb2ludChlICE9IG51bGwgPyBlLmNsaWVudFggOiBldmVudC5jbGllbnRYLCBlICE9IG51bGwgPyBlLmNsaWVudFkgOiBldmVudC5jbGllbnRZKSk7XG4gICAgICAgICAgICAgICAgICAgIHN2Zy5Nb3VzZS5vbmNsaWNrKHAueCwgcC55KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGN0eC5jYW52YXMub25tb3VzZW1vdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gbWFwWFkobmV3IHN2Zy5Qb2ludChlICE9IG51bGwgPyBlLmNsaWVudFggOiBldmVudC5jbGllbnRYLCBlICE9IG51bGwgPyBlLmNsaWVudFkgOiBldmVudC5jbGllbnRZKSk7XG4gICAgICAgICAgICAgICAgICAgIHN2Zy5Nb3VzZS5vbm1vdXNlbW92ZShwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgZSA9IHN2Zy5DcmVhdGVFbGVtZW50KGRvbS5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgICAgICAgZS5yb290ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyByZW5kZXIgbG9vcFxuICAgICAgICAgICAgdmFyIGlzRmlyc3RSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdmcuVmlld1BvcnQuQ2xlYXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNhbnZhcy5wYXJlbnROb2RlKSBzdmcuVmlld1BvcnQuU2V0Q3VycmVudChjdHguY2FudmFzLnBhcmVudE5vZGUuY2xpZW50V2lkdGgsIGN0eC5jYW52YXMucGFyZW50Tm9kZS5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydpZ25vcmVEaW1lbnNpb25zJ10gIT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2FudmFzIHNpemVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuc3R5bGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNhbnZhcy53aWR0aCA9IGUuc3R5bGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jYW52YXMuc3R5bGUud2lkdGggPSBjdHguY2FudmFzLndpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5zdHlsZSgnaGVpZ2h0JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNhbnZhcy5oZWlnaHQgPSBlLnN0eWxlKCdoZWlnaHQnKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjdHguY2FudmFzLmhlaWdodCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNXaWR0aCA9IGN0eC5jYW52YXMuY2xpZW50V2lkdGggfHwgY3R4LmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgY0hlaWdodCA9IGN0eC5jYW52YXMuY2xpZW50SGVpZ2h0IHx8IGN0eC5jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChzdmcub3B0c1snaWdub3JlRGltZW5zaW9ucyddID09IHRydWUgJiYgZS5zdHlsZSgnd2lkdGgnKS5oYXNWYWx1ZSgpICYmIGUuc3R5bGUoJ2hlaWdodCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY1dpZHRoID0gZS5zdHlsZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgICAgICBjSGVpZ2h0ID0gZS5zdHlsZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ZnLlZpZXdQb3J0LlNldEN1cnJlbnQoY1dpZHRoLCBjSGVpZ2h0KTsgICAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydvZmZzZXRYJ10gIT0gbnVsbCkgZS5hdHRyaWJ1dGUoJ3gnLCB0cnVlKS52YWx1ZSA9IHN2Zy5vcHRzWydvZmZzZXRYJ107XG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydvZmZzZXRZJ10gIT0gbnVsbCkgZS5hdHRyaWJ1dGUoJ3knLCB0cnVlKS52YWx1ZSA9IHN2Zy5vcHRzWydvZmZzZXRZJ107XG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydzY2FsZVdpZHRoJ10gIT0gbnVsbCB8fCBzdmcub3B0c1snc2NhbGVIZWlnaHQnXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4UmF0aW8gPSBudWxsLCB5UmF0aW8gPSBudWxsLCB2aWV3Qm94ID0gc3ZnLlRvTnVtYmVyQXJyYXkoZS5hdHRyaWJ1dGUoJ3ZpZXdCb3gnKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ZnLm9wdHNbJ3NjYWxlV2lkdGgnXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5hdHRyaWJ1dGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkgeFJhdGlvID0gZS5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKSAvIHN2Zy5vcHRzWydzY2FsZVdpZHRoJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNOYU4odmlld0JveFsyXSkpIHhSYXRpbyA9IHZpZXdCb3hbMl0gLyBzdmcub3B0c1snc2NhbGVXaWR0aCddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ZnLm9wdHNbJ3NjYWxlSGVpZ2h0J10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuYXR0cmlidXRlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB5UmF0aW8gPSBlLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKSAvIHN2Zy5vcHRzWydzY2FsZUhlaWdodCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzTmFOKHZpZXdCb3hbM10pKSB5UmF0aW8gPSB2aWV3Qm94WzNdIC8gc3ZnLm9wdHNbJ3NjYWxlSGVpZ2h0J107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoeFJhdGlvID09IG51bGwpIHsgeFJhdGlvID0geVJhdGlvOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh5UmF0aW8gPT0gbnVsbCkgeyB5UmF0aW8gPSB4UmF0aW87IH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGUuYXR0cmlidXRlKCd3aWR0aCcsIHRydWUpLnZhbHVlID0gc3ZnLm9wdHNbJ3NjYWxlV2lkdGgnXTtcbiAgICAgICAgICAgICAgICAgICAgZS5hdHRyaWJ1dGUoJ2hlaWdodCcsIHRydWUpLnZhbHVlID0gc3ZnLm9wdHNbJ3NjYWxlSGVpZ2h0J107XG4gICAgICAgICAgICAgICAgICAgIGUuYXR0cmlidXRlKCd0cmFuc2Zvcm0nLCB0cnVlKS52YWx1ZSArPSAnIHNjYWxlKCcrKDEuMC94UmF0aW8pKycsJysoMS4wL3lSYXRpbykrJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGNsZWFyIGFuZCByZW5kZXJcbiAgICAgICAgICAgICAgICBpZiAoc3ZnLm9wdHNbJ2lnbm9yZUNsZWFyJ10gIT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNXaWR0aCwgY0hlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmlyc3RSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdFJlbmRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHN2Zy5vcHRzWydyZW5kZXJDYWxsYmFjayddKSA9PSAnZnVuY3Rpb24nKSBzdmcub3B0c1sncmVuZGVyQ2FsbGJhY2snXShkb20pO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgd2FpdGluZ0ZvckltYWdlcyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoc3ZnLkltYWdlc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgd2FpdGluZ0ZvckltYWdlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN2Zy5pbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgICAgIHZhciBuZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHdhaXRpbmdGb3JJbWFnZXMgJiYgc3ZnLkltYWdlc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRpbmdGb3JJbWFnZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB1cGRhdGUgZnJvbSBtb3VzZSBldmVudHM/XG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydpZ25vcmVNb3VzZSddICE9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVlZFVwZGF0ZSA9IG5lZWRVcGRhdGUgfCBzdmcuTW91c2UuaGFzRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB1cGRhdGUgZnJvbSBhbmltYXRpb25zP1xuICAgICAgICAgICAgICAgIGlmIChzdmcub3B0c1snaWdub3JlQW5pbWF0aW9uJ10gIT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c3ZnLkFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRVcGRhdGUgPSBuZWVkVXBkYXRlIHwgc3ZnLkFuaW1hdGlvbnNbaV0udXBkYXRlKDEwMDAgLyBzdmcuRlJBTUVSQVRFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHVwZGF0ZSBmcm9tIHJlZHJhdz9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHN2Zy5vcHRzWydmb3JjZVJlZHJhdyddKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdmcub3B0c1snZm9yY2VSZWRyYXcnXSgpID09IHRydWUpIG5lZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKG5lZWRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhdygpOyAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc3ZnLk1vdXNlLnJ1bkV2ZW50cygpOyAvLyBydW4gYW5kIGNsZWFyIG91ciBldmVudHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwIC8gc3ZnLkZSQU1FUkFURSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN2Zy5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc3ZnLmludGVydmFsSUQpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHN2Zy5pbnRlcnZhbElEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3ZnLk1vdXNlID0gbmV3IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLmhhc0V2ZW50cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ldmVudHMubGVuZ3RoICE9IDA7IH1cbiAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9uY2xpY2sgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7IHR5cGU6ICdvbmNsaWNrJywgeDogeCwgeTogeSwgXG4gICAgICAgICAgICAgICAgICAgIHJ1bjogZnVuY3Rpb24oZSkgeyBpZiAoZS5vbmNsaWNrKSBlLm9uY2xpY2soKTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goeyB0eXBlOiAnb25tb3VzZW1vdmUnLCB4OiB4LCB5OiB5LFxuICAgICAgICAgICAgICAgICAgICBydW46IGZ1bmN0aW9uKGUpIHsgaWYgKGUub25tb3VzZW1vdmUpIGUub25tb3VzZW1vdmUoKTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmNoZWNrUGF0aCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGN0eCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LmlzUG9pbnRJblBhdGggJiYgY3R4LmlzUG9pbnRJblBhdGgoZS54LCBlLnkpKSB0aGlzLmV2ZW50RWxlbWVudHNbaV0gPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jaGVja0JvdW5kaW5nQm94ID0gZnVuY3Rpb24oZWxlbWVudCwgYmIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJiLmlzUG9pbnRJbkJveChlLngsIGUueSkpIHRoaXMuZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucnVuRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3ZnLmN0eC5jYW52YXMuc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5ldmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5ldmVudEVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5ydW4oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gZG9uZSBydW5uaW5nLCBjbGVhclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gW107IFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzdmc7XG4gICAgfVxufSkoKTtcblxuaWYgKHR5cGVvZihDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5kcmF3U3ZnID0gZnVuY3Rpb24ocywgZHgsIGR5LCBkdywgZGgpIHtcbiAgICAgICAgY2FudmcodGhpcy5jYW52YXMsIHMsIHsgXG4gICAgICAgICAgICBpZ25vcmVNb3VzZTogdHJ1ZSwgXG4gICAgICAgICAgICBpZ25vcmVBbmltYXRpb246IHRydWUsIFxuICAgICAgICAgICAgaWdub3JlRGltZW5zaW9uczogdHJ1ZSwgXG4gICAgICAgICAgICBpZ25vcmVDbGVhcjogdHJ1ZSwgXG4gICAgICAgICAgICBvZmZzZXRYOiBkeCwgXG4gICAgICAgICAgICBvZmZzZXRZOiBkeSwgXG4gICAgICAgICAgICBzY2FsZVdpZHRoOiBkdywgXG4gICAgICAgICAgICBzY2FsZUhlaWdodDogZGhcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLy8gZGVwZW5kZW5jeSBmb3IgY2Fudmdcbi8qKlxuICogQSBjbGFzcyB0byBwYXJzZSBjb2xvciB2YWx1ZXNcbiAqIEBhdXRob3IgU3RveWFuIFN0ZWZhbm92IDxzc3Rvb0BnbWFpbC5jb20+XG4gKiBAbGluayAgIGh0dHA6Ly93d3cucGhwaWVkLmNvbS9yZ2ItY29sb3ItcGFyc2VyLWluLWphdmFzY3JpcHQvXG4gKiBAbGljZW5zZSBVc2UgaXQgaWYgeW91IGxpa2UgaXRcbiAqL1xuZnVuY3Rpb24gUkdCQ29sb3IoY29sb3Jfc3RyaW5nKVxue1xuICAgIHRoaXMub2sgPSBmYWxzZTtcblxuICAgIC8vIHN0cmlwIGFueSBsZWFkaW5nICNcbiAgICBpZiAoY29sb3Jfc3RyaW5nLmNoYXJBdCgwKSA9PSAnIycpIHsgLy8gcmVtb3ZlICMgaWYgYW55XG4gICAgICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZy5zdWJzdHIoMSw2KTtcbiAgICB9XG5cbiAgICBjb2xvcl9zdHJpbmcgPSBjb2xvcl9zdHJpbmcucmVwbGFjZSgvIC9nLCcnKTtcbiAgICBjb2xvcl9zdHJpbmcgPSBjb2xvcl9zdHJpbmcudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIGJlZm9yZSBnZXR0aW5nIGludG8gcmVnZXhwcywgdHJ5IHNpbXBsZSBtYXRjaGVzXG4gICAgLy8gYW5kIG92ZXJ3cml0ZSB0aGUgaW5wdXRcbiAgICB2YXIgc2ltcGxlX2NvbG9ycyA9IHtcbiAgICAgICAgYWxpY2VibHVlOiAnZjBmOGZmJyxcbiAgICAgICAgYW50aXF1ZXdoaXRlOiAnZmFlYmQ3JyxcbiAgICAgICAgYXF1YTogJzAwZmZmZicsXG4gICAgICAgIGFxdWFtYXJpbmU6ICc3ZmZmZDQnLFxuICAgICAgICBhenVyZTogJ2YwZmZmZicsXG4gICAgICAgIGJlaWdlOiAnZjVmNWRjJyxcbiAgICAgICAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgICAgICAgYmxhY2s6ICcwMDAwMDAnLFxuICAgICAgICBibGFuY2hlZGFsbW9uZDogJ2ZmZWJjZCcsXG4gICAgICAgIGJsdWU6ICcwMDAwZmYnLFxuICAgICAgICBibHVldmlvbGV0OiAnOGEyYmUyJyxcbiAgICAgICAgYnJvd246ICdhNTJhMmEnLFxuICAgICAgICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICAgICAgICBjYWRldGJsdWU6ICc1ZjllYTAnLFxuICAgICAgICBjaGFydHJldXNlOiAnN2ZmZjAwJyxcbiAgICAgICAgY2hvY29sYXRlOiAnZDI2OTFlJyxcbiAgICAgICAgY29yYWw6ICdmZjdmNTAnLFxuICAgICAgICBjb3JuZmxvd2VyYmx1ZTogJzY0OTVlZCcsXG4gICAgICAgIGNvcm5zaWxrOiAnZmZmOGRjJyxcbiAgICAgICAgY3JpbXNvbjogJ2RjMTQzYycsXG4gICAgICAgIGN5YW46ICcwMGZmZmYnLFxuICAgICAgICBkYXJrYmx1ZTogJzAwMDA4YicsXG4gICAgICAgIGRhcmtjeWFuOiAnMDA4YjhiJyxcbiAgICAgICAgZGFya2dvbGRlbnJvZDogJ2I4ODYwYicsXG4gICAgICAgIGRhcmtncmF5OiAnYTlhOWE5JyxcbiAgICAgICAgZGFya2dyZWVuOiAnMDA2NDAwJyxcbiAgICAgICAgZGFya2toYWtpOiAnYmRiNzZiJyxcbiAgICAgICAgZGFya21hZ2VudGE6ICc4YjAwOGInLFxuICAgICAgICBkYXJrb2xpdmVncmVlbjogJzU1NmIyZicsXG4gICAgICAgIGRhcmtvcmFuZ2U6ICdmZjhjMDAnLFxuICAgICAgICBkYXJrb3JjaGlkOiAnOTkzMmNjJyxcbiAgICAgICAgZGFya3JlZDogJzhiMDAwMCcsXG4gICAgICAgIGRhcmtzYWxtb246ICdlOTk2N2EnLFxuICAgICAgICBkYXJrc2VhZ3JlZW46ICc4ZmJjOGYnLFxuICAgICAgICBkYXJrc2xhdGVibHVlOiAnNDgzZDhiJyxcbiAgICAgICAgZGFya3NsYXRlZ3JheTogJzJmNGY0ZicsXG4gICAgICAgIGRhcmt0dXJxdW9pc2U6ICcwMGNlZDEnLFxuICAgICAgICBkYXJrdmlvbGV0OiAnOTQwMGQzJyxcbiAgICAgICAgZGVlcHBpbms6ICdmZjE0OTMnLFxuICAgICAgICBkZWVwc2t5Ymx1ZTogJzAwYmZmZicsXG4gICAgICAgIGRpbWdyYXk6ICc2OTY5NjknLFxuICAgICAgICBkb2RnZXJibHVlOiAnMWU5MGZmJyxcbiAgICAgICAgZmVsZHNwYXI6ICdkMTkyNzUnLFxuICAgICAgICBmaXJlYnJpY2s6ICdiMjIyMjInLFxuICAgICAgICBmbG9yYWx3aGl0ZTogJ2ZmZmFmMCcsXG4gICAgICAgIGZvcmVzdGdyZWVuOiAnMjI4YjIyJyxcbiAgICAgICAgZnVjaHNpYTogJ2ZmMDBmZicsXG4gICAgICAgIGdhaW5zYm9ybzogJ2RjZGNkYycsXG4gICAgICAgIGdob3N0d2hpdGU6ICdmOGY4ZmYnLFxuICAgICAgICBnb2xkOiAnZmZkNzAwJyxcbiAgICAgICAgZ29sZGVucm9kOiAnZGFhNTIwJyxcbiAgICAgICAgZ3JheTogJzgwODA4MCcsXG4gICAgICAgIGdyZWVuOiAnMDA4MDAwJyxcbiAgICAgICAgZ3JlZW55ZWxsb3c6ICdhZGZmMmYnLFxuICAgICAgICBob25leWRldzogJ2YwZmZmMCcsXG4gICAgICAgIGhvdHBpbms6ICdmZjY5YjQnLFxuICAgICAgICBpbmRpYW5yZWQgOiAnY2Q1YzVjJyxcbiAgICAgICAgaW5kaWdvIDogJzRiMDA4MicsXG4gICAgICAgIGl2b3J5OiAnZmZmZmYwJyxcbiAgICAgICAga2hha2k6ICdmMGU2OGMnLFxuICAgICAgICBsYXZlbmRlcjogJ2U2ZTZmYScsXG4gICAgICAgIGxhdmVuZGVyYmx1c2g6ICdmZmYwZjUnLFxuICAgICAgICBsYXduZ3JlZW46ICc3Y2ZjMDAnLFxuICAgICAgICBsZW1vbmNoaWZmb246ICdmZmZhY2QnLFxuICAgICAgICBsaWdodGJsdWU6ICdhZGQ4ZTYnLFxuICAgICAgICBsaWdodGNvcmFsOiAnZjA4MDgwJyxcbiAgICAgICAgbGlnaHRjeWFuOiAnZTBmZmZmJyxcbiAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICdmYWZhZDInLFxuICAgICAgICBsaWdodGdyZXk6ICdkM2QzZDMnLFxuICAgICAgICBsaWdodGdyZWVuOiAnOTBlZTkwJyxcbiAgICAgICAgbGlnaHRwaW5rOiAnZmZiNmMxJyxcbiAgICAgICAgbGlnaHRzYWxtb246ICdmZmEwN2EnLFxuICAgICAgICBsaWdodHNlYWdyZWVuOiAnMjBiMmFhJyxcbiAgICAgICAgbGlnaHRza3libHVlOiAnODdjZWZhJyxcbiAgICAgICAgbGlnaHRzbGF0ZWJsdWU6ICc4NDcwZmYnLFxuICAgICAgICBsaWdodHNsYXRlZ3JheTogJzc3ODg5OScsXG4gICAgICAgIGxpZ2h0c3RlZWxibHVlOiAnYjBjNGRlJyxcbiAgICAgICAgbGlnaHR5ZWxsb3c6ICdmZmZmZTAnLFxuICAgICAgICBsaW1lOiAnMDBmZjAwJyxcbiAgICAgICAgbGltZWdyZWVuOiAnMzJjZDMyJyxcbiAgICAgICAgbGluZW46ICdmYWYwZTYnLFxuICAgICAgICBtYWdlbnRhOiAnZmYwMGZmJyxcbiAgICAgICAgbWFyb29uOiAnODAwMDAwJyxcbiAgICAgICAgbWVkaXVtYXF1YW1hcmluZTogJzY2Y2RhYScsXG4gICAgICAgIG1lZGl1bWJsdWU6ICcwMDAwY2QnLFxuICAgICAgICBtZWRpdW1vcmNoaWQ6ICdiYTU1ZDMnLFxuICAgICAgICBtZWRpdW1wdXJwbGU6ICc5MzcwZDgnLFxuICAgICAgICBtZWRpdW1zZWFncmVlbjogJzNjYjM3MScsXG4gICAgICAgIG1lZGl1bXNsYXRlYmx1ZTogJzdiNjhlZScsXG4gICAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAnMDBmYTlhJyxcbiAgICAgICAgbWVkaXVtdHVycXVvaXNlOiAnNDhkMWNjJyxcbiAgICAgICAgbWVkaXVtdmlvbGV0cmVkOiAnYzcxNTg1JyxcbiAgICAgICAgbWlkbmlnaHRibHVlOiAnMTkxOTcwJyxcbiAgICAgICAgbWludGNyZWFtOiAnZjVmZmZhJyxcbiAgICAgICAgbWlzdHlyb3NlOiAnZmZlNGUxJyxcbiAgICAgICAgbW9jY2FzaW46ICdmZmU0YjUnLFxuICAgICAgICBuYXZham93aGl0ZTogJ2ZmZGVhZCcsXG4gICAgICAgIG5hdnk6ICcwMDAwODAnLFxuICAgICAgICBvbGRsYWNlOiAnZmRmNWU2JyxcbiAgICAgICAgb2xpdmU6ICc4MDgwMDAnLFxuICAgICAgICBvbGl2ZWRyYWI6ICc2YjhlMjMnLFxuICAgICAgICBvcmFuZ2U6ICdmZmE1MDAnLFxuICAgICAgICBvcmFuZ2VyZWQ6ICdmZjQ1MDAnLFxuICAgICAgICBvcmNoaWQ6ICdkYTcwZDYnLFxuICAgICAgICBwYWxlZ29sZGVucm9kOiAnZWVlOGFhJyxcbiAgICAgICAgcGFsZWdyZWVuOiAnOThmYjk4JyxcbiAgICAgICAgcGFsZXR1cnF1b2lzZTogJ2FmZWVlZScsXG4gICAgICAgIHBhbGV2aW9sZXRyZWQ6ICdkODcwOTMnLFxuICAgICAgICBwYXBheWF3aGlwOiAnZmZlZmQ1JyxcbiAgICAgICAgcGVhY2hwdWZmOiAnZmZkYWI5JyxcbiAgICAgICAgcGVydTogJ2NkODUzZicsXG4gICAgICAgIHBpbms6ICdmZmMwY2InLFxuICAgICAgICBwbHVtOiAnZGRhMGRkJyxcbiAgICAgICAgcG93ZGVyYmx1ZTogJ2IwZTBlNicsXG4gICAgICAgIHB1cnBsZTogJzgwMDA4MCcsXG4gICAgICAgIHJlZDogJ2ZmMDAwMCcsXG4gICAgICAgIHJvc3licm93bjogJ2JjOGY4ZicsXG4gICAgICAgIHJveWFsYmx1ZTogJzQxNjllMScsXG4gICAgICAgIHNhZGRsZWJyb3duOiAnOGI0NTEzJyxcbiAgICAgICAgc2FsbW9uOiAnZmE4MDcyJyxcbiAgICAgICAgc2FuZHlicm93bjogJ2Y0YTQ2MCcsXG4gICAgICAgIHNlYWdyZWVuOiAnMmU4YjU3JyxcbiAgICAgICAgc2Vhc2hlbGw6ICdmZmY1ZWUnLFxuICAgICAgICBzaWVubmE6ICdhMDUyMmQnLFxuICAgICAgICBzaWx2ZXI6ICdjMGMwYzAnLFxuICAgICAgICBza3libHVlOiAnODdjZWViJyxcbiAgICAgICAgc2xhdGVibHVlOiAnNmE1YWNkJyxcbiAgICAgICAgc2xhdGVncmF5OiAnNzA4MDkwJyxcbiAgICAgICAgc25vdzogJ2ZmZmFmYScsXG4gICAgICAgIHNwcmluZ2dyZWVuOiAnMDBmZjdmJyxcbiAgICAgICAgc3RlZWxibHVlOiAnNDY4MmI0JyxcbiAgICAgICAgdGFuOiAnZDJiNDhjJyxcbiAgICAgICAgdGVhbDogJzAwODA4MCcsXG4gICAgICAgIHRoaXN0bGU6ICdkOGJmZDgnLFxuICAgICAgICB0b21hdG86ICdmZjYzNDcnLFxuICAgICAgICB0dXJxdW9pc2U6ICc0MGUwZDAnLFxuICAgICAgICB2aW9sZXQ6ICdlZTgyZWUnLFxuICAgICAgICB2aW9sZXRyZWQ6ICdkMDIwOTAnLFxuICAgICAgICB3aGVhdDogJ2Y1ZGViMycsXG4gICAgICAgIHdoaXRlOiAnZmZmZmZmJyxcbiAgICAgICAgd2hpdGVzbW9rZTogJ2Y1ZjVmNScsXG4gICAgICAgIHllbGxvdzogJ2ZmZmYwMCcsXG4gICAgICAgIHllbGxvd2dyZWVuOiAnOWFjZDMyJ1xuICAgIH07XG4gICAgZm9yICh2YXIga2V5IGluIHNpbXBsZV9jb2xvcnMpIHtcbiAgICAgICAgaWYgKGNvbG9yX3N0cmluZyA9PSBrZXkpIHtcbiAgICAgICAgICAgIGNvbG9yX3N0cmluZyA9IHNpbXBsZV9jb2xvcnNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlbWQgb2Ygc2ltcGxlIHR5cGUtaW4gY29sb3JzXG5cbiAgICAvLyBhcnJheSBvZiBjb2xvciBkZWZpbml0aW9uIG9iamVjdHNcbiAgICB2YXIgY29sb3JfZGVmcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcmU6IC9ecmdiXFwoKFxcZHsxLDN9KSxcXHMqKFxcZHsxLDN9KSxcXHMqKFxcZHsxLDN9KVxcKSQvLFxuICAgICAgICAgICAgZXhhbXBsZTogWydyZ2IoMTIzLCAyMzQsIDQ1KScsICdyZ2IoMjU1LDIzNCwyNDUpJ10sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoYml0cyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1sxXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMl0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzNdKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlOiAvXihcXHd7Mn0pKFxcd3syfSkoXFx3ezJ9KSQvLFxuICAgICAgICAgICAgZXhhbXBsZTogWycjMDBmZjAwJywgJzMzNjY5OSddLFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGJpdHMpe1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMV0sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1syXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzNdLCAxNilcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByZTogL14oXFx3ezF9KShcXHd7MX0pKFxcd3sxfSkkLyxcbiAgICAgICAgICAgIGV4YW1wbGU6IFsnI2ZiMCcsICdmMGYnXSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChiaXRzKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzFdICsgYml0c1sxXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzJdICsgYml0c1syXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzNdICsgYml0c1szXSwgMTYpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF07XG5cbiAgICAvLyBzZWFyY2ggdGhyb3VnaCB0aGUgZGVmaW5pdGlvbnMgdG8gZmluZCBhIG1hdGNoXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcl9kZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZSA9IGNvbG9yX2RlZnNbaV0ucmU7XG4gICAgICAgIHZhciBwcm9jZXNzb3IgPSBjb2xvcl9kZWZzW2ldLnByb2Nlc3M7XG4gICAgICAgIHZhciBiaXRzID0gcmUuZXhlYyhjb2xvcl9zdHJpbmcpO1xuICAgICAgICBpZiAoYml0cykge1xuICAgICAgICAgICAgY2hhbm5lbHMgPSBwcm9jZXNzb3IoYml0cyk7XG4gICAgICAgICAgICB0aGlzLnIgPSBjaGFubmVsc1swXTtcbiAgICAgICAgICAgIHRoaXMuZyA9IGNoYW5uZWxzWzFdO1xuICAgICAgICAgICAgdGhpcy5iID0gY2hhbm5lbHNbMl07XG4gICAgICAgICAgICB0aGlzLm9rID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUvY2xlYW51cCB2YWx1ZXNcbiAgICB0aGlzLnIgPSAodGhpcy5yIDwgMCB8fCBpc05hTih0aGlzLnIpKSA/IDAgOiAoKHRoaXMuciA+IDI1NSkgPyAyNTUgOiB0aGlzLnIpO1xuICAgIHRoaXMuZyA9ICh0aGlzLmcgPCAwIHx8IGlzTmFOKHRoaXMuZykpID8gMCA6ICgodGhpcy5nID4gMjU1KSA/IDI1NSA6IHRoaXMuZyk7XG4gICAgdGhpcy5iID0gKHRoaXMuYiA8IDAgfHwgaXNOYU4odGhpcy5iKSkgPyAwIDogKCh0aGlzLmIgPiAyNTUpID8gMjU1IDogdGhpcy5iKTtcblxuICAgIC8vIHNvbWUgZ2V0dGVyc1xuICAgIHRoaXMudG9SR0IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyB0aGlzLnIgKyAnLCAnICsgdGhpcy5nICsgJywgJyArIHRoaXMuYiArICcpJztcbiAgICB9XG4gICAgdGhpcy50b0hleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnIudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgZyA9IHRoaXMuZy50b1N0cmluZygxNik7XG4gICAgICAgIHZhciBiID0gdGhpcy5iLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKHIubGVuZ3RoID09IDEpIHIgPSAnMCcgKyByO1xuICAgICAgICBpZiAoZy5sZW5ndGggPT0gMSkgZyA9ICcwJyArIGc7XG4gICAgICAgIGlmIChiLmxlbmd0aCA9PSAxKSBiID0gJzAnICsgYjtcbiAgICAgICAgcmV0dXJuICcjJyArIHIgKyBnICsgYjtcbiAgICB9XG5cbiAgICAvLyBoZWxwXG4gICAgdGhpcy5nZXRIZWxwWE1MID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBleGFtcGxlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAvLyBhZGQgcmVnZXhwc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yX2RlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBleGFtcGxlID0gY29sb3JfZGVmc1tpXS5leGFtcGxlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBleGFtcGxlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZXhhbXBsZXNbZXhhbXBsZXMubGVuZ3RoXSA9IGV4YW1wbGVbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHR5cGUtaW4gY29sb3JzXG4gICAgICAgIGZvciAodmFyIHNjIGluIHNpbXBsZV9jb2xvcnMpIHtcbiAgICAgICAgICAgIGV4YW1wbGVzW2V4YW1wbGVzLmxlbmd0aF0gPSBzYztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICB4bWwuc2V0QXR0cmlidXRlKCdpZCcsICdyZ2Jjb2xvci1leGFtcGxlcycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4YW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0X2l0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0X2NvbG9yID0gbmV3IFJHQkNvbG9yKGV4YW1wbGVzW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhhbXBsZV9kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBleGFtcGxlX2Rpdi5zdHlsZS5jc3NUZXh0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW46IDNweDsgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnYm9yZGVyOiAxcHggc29saWQgYmxhY2s7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2JhY2tncm91bmQ6JyArIGxpc3RfY29sb3IudG9IZXgoKSArICc7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2NvbG9yOicgKyBsaXN0X2NvbG9yLnRvSGV4KClcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgZXhhbXBsZV9kaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3Rlc3QnKSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RfaXRlbV92YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgICAgICAgICAgICAgICAgICAnICcgKyBleGFtcGxlc1tpXSArICcgLT4gJyArIGxpc3RfY29sb3IudG9SR0IoKSArICcgLT4gJyArIGxpc3RfY29sb3IudG9IZXgoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGlzdF9pdGVtLmFwcGVuZENoaWxkKGV4YW1wbGVfZGl2KTtcbiAgICAgICAgICAgICAgICBsaXN0X2l0ZW0uYXBwZW5kQ2hpbGQobGlzdF9pdGVtX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB4bWwuYXBwZW5kQ2hpbGQobGlzdF9pdGVtKTtcblxuICAgICAgICAgICAgfSBjYXRjaChlKXt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhtbDtcblxuICAgIH1cblxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gUkdCQ29sb3I7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuXy5taXhpbih7XG4gIHRyYW5zcG9zZTogZnVuY3Rpb24oYXJycykge1xuICAgIHJldHVybiBfLnppcC5hcHBseShfLCBhcnJzKTtcbiAgfVxufSk7XG4iLCIvLyBob3BlZnVsbHkgbm90IHRoYXQgdWdseSwgYnV0IHNlZW1lZCBhcyBnb29kIGEgcGxhY2UgYXMgYW55IGZvciB0aGlzIHN0dWZmLi4uXG5cbnZhciBkMyA9IHJlcXVpcmUoJ2QzLWJyb3dzZXJpZnknKTtcblxuXG52YXIgZm9ybWF0S01CID0gZnVuY3Rpb24ocHJlY2lzaW9uLCBkZWNpbWFsU2VwYXJhdG9yKSB7XG4gIHZhciBmb3JtYXRTSSA9IGQzLmZvcm1hdCgnLicgKyAocHJlY2lzaW9uIHx8IDMpICsgJ3MnKTtcbiAgZGVjaW1hbFNlcGFyYXRvciA9IGRlY2ltYWxTZXBhcmF0b3IgfHwgJy4nO1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0U0kodmFsdWUpXG4gICAgICAucmVwbGFjZSgnRycsICdCJykgIC8vIG5vdyBqdXN0IG5lZWQgdG8gY29udmVydCBHIEdpZ2lhIC0+IEIgQmlsbGlvblxuICAgICAgLnJlcGxhY2UoJy4nLCBkZWNpbWFsU2VwYXJhdG9yKTtcbiAgfTtcbn07XG5cblxudmFyIGZvcm1hdFNob3J0VGV4dCA9IGZ1bmN0aW9uKG1heFdpZHRoKSB7XG4gIHZhciBlbGxpcHNlV2lkdGggPSAxO1xuICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuICAgIGlmICh0ZXh0Lmxlbmd0aCAtIGVsbGlwc2VXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBtYXhXaWR0aCAtIGVsbGlwc2VXaWR0aCkgKyAnLi4uJztcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59O1xuXG5cbnZhciBjYXRlZ29yeUNvbG91cnMgPSBmdW5jdGlvbihjYXRzKSB7XG4gIC8vIGdldCBhbiBhcHByb3ByaWF0ZSBjb2xvdXIgc2NhbGUgZm9yIHRoZSBudW1iZXIgb2YgY2F0ZWdvcmllcyB3ZSBhcmVcbiAgLy8gZGVhbGluZyB3aXRoXG4gIHZhciBjb2xvdXJzID0gZDMuc2NhbGVbJ2NhdGVnb3J5JyArIChjYXRzID4gMTAgPyAnMjAnIDogJzEwJyldKCkucmFuZ2UoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICByZXR1cm4gZC5jb2xvciB8fCAoZC5kYXRhICYmIGQuZGF0YS5jb2xvcikgfHwgY29sb3Vyc1tpICUgY29sb3Vycy5sZW5ndGhdO1xuICB9O1xufTtcblxuXG52YXIgdTE2bGU2NCA9IGZ1bmN0aW9uKHN0cikge1xuICAvLyBiYXNlNjQtZW5jb2RlIGEgc3RyaW5nIGFzIFVURi0xNi1MRSAoZm9yIE1TIEV4Y2VsLCBwcm9iYWJseSkuIEl0IHdpbGwgb25seVxuICAvLyB3b3JrIGZvciAyLWJ5dGUtd2lkZSB1dGYtMTYgY2hhcmFjdGVycywgYW5kIHdpbGwgYnJlYWsgYXQgdGhlIGZpcnN0IGhpbnRcbiAgLy8gb2YgYW55IDQtYnl0ZSBjaGFyLiBUd28gYnl0ZXMgY292ZXJzIHRoZSBCYXNpYyBNdWx0aW5pbmd1YWwgUGxhbmUsIHNvIHdlXG4gIC8vIHNob3VsZCBiZSBnb29kLlxuICB2YXIgdTE2bnVtLFxuICAgICAgYXNjaWlCeXRlUGFpclN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkUpO1xuICBhc2NpaUJ5dGVQYWlyU3RyaW5nICs9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChzdHIsIGZ1bmN0aW9uKGFjYywgY2hyKSB7XG4gICAgdTE2bnVtID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgLyoganNoaW50IGJpdHdpc2U6ZmFsc2UgKi9cbiAgICByZXR1cm4gYWNjICsgU3RyaW5nLmZyb21DaGFyQ29kZSh1MTZudW0gJiAweEZGKSArIFN0cmluZy5mcm9tQ2hhckNvZGUodTE2bnVtID4+IDgpO1xuICAgIC8qIGpzaGludCBiaXR3aXNlOnRydWUgKi9cbiAgfSwgJycpO1xuICByZXR1cm4gYnRvYShhc2NpaUJ5dGVQYWlyU3RyaW5nKTtcbn07XG5cblxudmFyIHRleHRBc0RhdGFVUkwgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuICdkYXRhOnRleHQvcGxhaW47YmFzZTY0LCcgKyB1MTZsZTY0KHN0cik7XG59O1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUFyZ3ModHJhbnNmb3JtZXIsIHdyYXBwZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIGFyZ3VtZW50cyAqLykge1xuICAgIHZhciB0cmFuc2Zvcm1lZEFyZ3MgPSB0cmFuc2Zvcm1lci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB3cmFwcGVkLmFwcGx5KG51bGwsIHRyYW5zZm9ybWVkQXJncyk7XG4gIH07XG59XG5cblxuZnVuY3Rpb24gdG9EYXNoZWQobmFtZSkge1xuICAvLyB0cmFuc2Zvcm0gbmFtZXNMaWtlVGhpcyB0byBuYW1lcy1saWtlLXRoaXNcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbih1KSB7XG4gICAgcmV0dXJuICctJyArIHUudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gZGF0YShlbCwgbmFtZSwgbmV3VmFsdWUpIHtcbiAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLScgKyB0b0Rhc2hlZChuYW1lKSk7XG4gIH1cbiAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLScgKyB0b0Rhc2hlZChuYW1lKSwgbmV3VmFsdWUpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmb3JtYXRLTUI6IGZvcm1hdEtNQixcbiAgZm9ybWF0U2hvcnRUZXh0OiBmb3JtYXRTaG9ydFRleHQsXG4gIGNhdGVnb3J5Q29sb3VyczogY2F0ZWdvcnlDb2xvdXJzLFxuICB1MTZsZTY0OiB1MTZsZTY0LFxuICB0ZXh0QXNEYXRhVVJMOiB0ZXh0QXNEYXRhVVJMLFxuICB0cmFuc2Zvcm1BcmdzOiB0cmFuc2Zvcm1BcmdzLFxuICBkYXRhOiBkYXRhXG59O1xuIiwiLypcblx0QmFieSBQYXJzZVxuXHR2MC4yLjFcblx0aHR0cHM6Ly9naXRodWIuY29tL1JpY2gtSGFycmlzL0JhYnlQYXJzZVxuXG5cdGJhc2VkIG9uIFBhcGEgUGFyc2UgdjMuMC4xXG5cdGh0dHBzOi8vZ2l0aHViLmNvbS9taG9sdC9QYXBhUGFyc2VcbiovXG5cblxuKGZ1bmN0aW9uICggZ2xvYmFsICkge1xuXG5cdC8vIEEgY29uZmlndXJhdGlvbiBvYmplY3QgZnJvbSB3aGljaCB0byBkcmF3IGRlZmF1bHQgc2V0dGluZ3Ncblx0dmFyIERFRkFVTFRTID0ge1xuXHRcdGRlbGltaXRlcjogXCJcIixcdC8vIGVtcHR5OiBhdXRvLWRldGVjdFxuXHRcdGhlYWRlcjogZmFsc2UsXG5cdFx0ZHluYW1pY1R5cGluZzogZmFsc2UsXG5cdFx0cHJldmlldzogMCxcblx0XHRzdGVwOiB1bmRlZmluZWQsXG5cdFx0Y29tbWVudHM6IGZhbHNlLFxuXHRcdGNvbXBsZXRlOiB1bmRlZmluZWQsXG5cdFx0a2VlcEVtcHR5Um93czogZmFsc2Vcblx0fTtcblxuXHR2YXIgQmFieSA9IHt9O1xuXHRCYWJ5LnBhcnNlID0gQ3N2VG9Kc29uO1xuXHRCYWJ5LnVucGFyc2UgPSBKc29uVG9Dc3Y7XG5cdEJhYnkuUkVDT1JEX1NFUCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzApO1xuXHRCYWJ5LlVOSVRfU0VQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMSk7XG5cdEJhYnkuQllURV9PUkRFUl9NQVJLID0gXCJcXHVmZWZmXCI7XG5cdEJhYnkuQkFEX0RFTElNSVRFUlMgPSBbXCJcXHJcIiwgXCJcXG5cIiwgXCJcXFwiXCIsIEJhYnkuQllURV9PUkRFUl9NQVJLXTtcblxuXG5cdGZ1bmN0aW9uIENzdlRvSnNvbihfaW5wdXQsIF9jb25maWcpXG5cdHtcblx0XHR2YXIgY29uZmlnID0gY29weUFuZFZhbGlkYXRlQ29uZmlnKF9jb25maWcpO1xuXHRcdHZhciBwaCA9IG5ldyBQYXJzZXJIYW5kbGUoY29uZmlnKTtcblx0XHR2YXIgcmVzdWx0cyA9IHBoLnBhcnNlKF9pbnB1dCk7XG5cdFx0aWYgKGlzRnVuY3Rpb24oY29uZmlnLmNvbXBsZXRlKSlcblx0XHRcdGNvbmZpZy5jb21wbGV0ZShyZXN1bHRzKTtcblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cblxuXG5cdGZ1bmN0aW9uIEpzb25Ub0NzdihfaW5wdXQsIF9jb25maWcpXG5cdHtcblx0XHR2YXIgX291dHB1dCA9IFwiXCI7XG5cdFx0dmFyIF9maWVsZHMgPSBbXTtcblxuXHRcdC8vIERlZmF1bHQgY29uZmlndXJhdGlvblxuXHRcdHZhciBfcXVvdGVzID0gZmFsc2U7XHQvLyB3aGV0aGVyIHRvIHN1cnJvdW5kIGV2ZXJ5IGRhdHVtIHdpdGggcXVvdGVzXG5cdFx0dmFyIF9kZWxpbWl0ZXIgPSBcIixcIjtcdC8vIGRlbGltaXRpbmcgY2hhcmFjdGVyXG5cdFx0dmFyIF9uZXdsaW5lID0gXCJcXHJcXG5cIjtcdC8vIG5ld2xpbmUgY2hhcmFjdGVyKHMpXG5cblx0XHR1bnBhY2tDb25maWcoKTtcblxuXHRcdGlmICh0eXBlb2YgX2lucHV0ID09PSAnc3RyaW5nJylcblx0XHRcdF9pbnB1dCA9IEpTT04ucGFyc2UoX2lucHV0KTtcblxuXHRcdGlmIChfaW5wdXQgaW5zdGFuY2VvZiBBcnJheSlcblx0XHR7XG5cdFx0XHRpZiAoIV9pbnB1dC5sZW5ndGggfHwgX2lucHV0WzBdIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0XHRcdHJldHVybiBzZXJpYWxpemUobnVsbCwgX2lucHV0KTtcblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBfaW5wdXRbMF0gPT09ICdvYmplY3QnKVxuXHRcdFx0XHRyZXR1cm4gc2VyaWFsaXplKG9iamVjdEtleXMoX2lucHV0WzBdKSwgX2lucHV0KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIF9pbnB1dCA9PT0gJ29iamVjdCcpXG5cdFx0e1xuXHRcdFx0aWYgKHR5cGVvZiBfaW5wdXQuZGF0YSA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdF9pbnB1dC5kYXRhID0gSlNPTi5wYXJzZShfaW5wdXQuZGF0YSk7XG5cblx0XHRcdGlmIChfaW5wdXQuZGF0YSBpbnN0YW5jZW9mIEFycmF5KVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIV9pbnB1dC5maWVsZHMpXG5cdFx0XHRcdFx0X2lucHV0LmZpZWxkcyA9IF9pbnB1dC5kYXRhWzBdIGluc3RhbmNlb2YgQXJyYXlcblx0XHRcdFx0XHRcdFx0XHRcdD8gX2lucHV0LmZpZWxkc1xuXHRcdFx0XHRcdFx0XHRcdFx0OiBvYmplY3RLZXlzKF9pbnB1dC5kYXRhWzBdKTtcblxuXHRcdFx0XHRpZiAoIShfaW5wdXQuZGF0YVswXSBpbnN0YW5jZW9mIEFycmF5KSAmJiB0eXBlb2YgX2lucHV0LmRhdGFbMF0gIT09ICdvYmplY3QnKVxuXHRcdFx0XHRcdF9pbnB1dC5kYXRhID0gW19pbnB1dC5kYXRhXTtcdC8vIGhhbmRsZXMgaW5wdXQgbGlrZSBbMSwyLDNdIG9yIFtcImFzZGZcIl1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNlcmlhbGl6ZShfaW5wdXQuZmllbGRzIHx8IFtdLCBfaW5wdXQuZGF0YSB8fCBbXSk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVmYXVsdCAoYW55IHZhbGlkIHBhdGhzIHNob3VsZCByZXR1cm4gYmVmb3JlIHRoaXMpXG5cdFx0dGhyb3cgXCJleGNlcHRpb246IFVuYWJsZSB0byBzZXJpYWxpemUgdW5yZWNvZ25pemVkIGlucHV0XCI7XG5cblxuXHRcdGZ1bmN0aW9uIHVucGFja0NvbmZpZygpXG5cdFx0e1xuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnICE9PSAnb2JqZWN0Jylcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRpZiAodHlwZW9mIF9jb25maWcuZGVsaW1pdGVyID09PSAnc3RyaW5nJ1xuXHRcdFx0XHQmJiBfY29uZmlnLmRlbGltaXRlci5sZW5ndGggPT0gMVxuXHRcdFx0XHQmJiBCYWJ5LkJBRF9ERUxJTUlURVJTLmluZGV4T2YoX2NvbmZpZy5kZWxpbWl0ZXIpID09IC0xKVxuXHRcdFx0e1xuXHRcdFx0XHRfZGVsaW1pdGVyID0gX2NvbmZpZy5kZWxpbWl0ZXI7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZy5xdW90ZXMgPT09ICdib29sZWFuJ1xuXHRcdFx0XHR8fCBfY29uZmlnLnF1b3RlcyBpbnN0YW5jZW9mIEFycmF5KVxuXHRcdFx0XHRfcXVvdGVzID0gX2NvbmZpZy5xdW90ZXM7XG5cblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZy5uZXdsaW5lID09PSAnc3RyaW5nJylcblx0XHRcdFx0X25ld2xpbmUgPSBfY29uZmlnLm5ld2xpbmU7XG5cdFx0fVxuXG5cblx0XHQvLyBUdXJucyBhbiBvYmplY3QncyBrZXlzIGludG8gYW4gYXJyYXlcblx0XHRmdW5jdGlvbiBvYmplY3RLZXlzKG9iailcblx0XHR7XG5cdFx0XHRpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdHZhciBrZXlzID0gW107XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKVxuXHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdHJldHVybiBrZXlzO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBkb3VibGUgZm9yIGxvb3AgdGhhdCBpdGVyYXRlcyB0aGUgZGF0YSBhbmQgd3JpdGVzIG91dCBhIENTViBzdHJpbmcgaW5jbHVkaW5nIGhlYWRlciByb3dcblx0XHRmdW5jdGlvbiBzZXJpYWxpemUoZmllbGRzLCBkYXRhKVxuXHRcdHtcblx0XHRcdHZhciBjc3YgPSBcIlwiO1xuXG5cdFx0XHRpZiAodHlwZW9mIGZpZWxkcyA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGZpZWxkcyA9IEpTT04ucGFyc2UoZmllbGRzKTtcblx0XHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG5cdFx0XHR2YXIgaGFzSGVhZGVyID0gZmllbGRzIGluc3RhbmNlb2YgQXJyYXkgJiYgZmllbGRzLmxlbmd0aCA+IDA7XG5cdFx0XHR2YXIgZGF0YUtleWVkQnlGaWVsZCA9ICEoZGF0YVswXSBpbnN0YW5jZW9mIEFycmF5KTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUgYSBoZWFkZXIgcm93LCB3cml0ZSBpdCBmaXJzdFxuXHRcdFx0aWYgKGhhc0hlYWRlcilcblx0XHRcdHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoaSA+IDApXG5cdFx0XHRcdFx0XHRjc3YgKz0gX2RlbGltaXRlcjtcblx0XHRcdFx0XHRjc3YgKz0gc2FmZShmaWVsZHNbaV0sIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkYXRhLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0Y3N2ICs9IF9uZXdsaW5lO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGVuIHdyaXRlIG91dCB0aGUgZGF0YVxuXHRcdFx0Zm9yICh2YXIgcm93ID0gMDsgcm93IDwgZGF0YS5sZW5ndGg7IHJvdysrKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgbWF4Q29sID0gaGFzSGVhZGVyID8gZmllbGRzLmxlbmd0aCA6IGRhdGFbcm93XS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICh2YXIgY29sID0gMDsgY29sIDwgbWF4Q29sOyBjb2wrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChjb2wgPiAwKVxuXHRcdFx0XHRcdFx0Y3N2ICs9IF9kZWxpbWl0ZXI7XG5cdFx0XHRcdFx0dmFyIGNvbElkeCA9IGhhc0hlYWRlciAmJiBkYXRhS2V5ZWRCeUZpZWxkID8gZmllbGRzW2NvbF0gOiBjb2w7XG5cdFx0XHRcdFx0Y3N2ICs9IHNhZmUoZGF0YVtyb3ddW2NvbElkeF0sIGNvbCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocm93IDwgZGF0YS5sZW5ndGggLSAxKVxuXHRcdFx0XHRcdGNzdiArPSBfbmV3bGluZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNzdjtcblx0XHR9XG5cblx0XHQvLyBFbmNsb3NlcyBhIHZhbHVlIGFyb3VuZCBxdW90ZXMgaWYgbmVlZGVkIChtYWtlcyBhIHZhbHVlIHNhZmUgZm9yIENTViBpbnNlcnRpb24pXG5cdFx0ZnVuY3Rpb24gc2FmZShzdHIsIGNvbClcblx0XHR7XG5cdFx0XHRpZiAodHlwZW9mIHN0ciA9PT0gXCJ1bmRlZmluZWRcIilcblx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cblx0XHRcdHN0ciA9IHN0ci50b1N0cmluZygpLnJlcGxhY2UoL1wiL2csICdcIlwiJyk7XG5cblx0XHRcdHZhciBuZWVkc1F1b3RlcyA9ICh0eXBlb2YgX3F1b3RlcyA9PT0gJ2Jvb2xlYW4nICYmIF9xdW90ZXMpXG5cdFx0XHRcdFx0XHRcdHx8IChfcXVvdGVzIGluc3RhbmNlb2YgQXJyYXkgJiYgX3F1b3Rlc1tjb2xdKVxuXHRcdFx0XHRcdFx0XHR8fCBoYXNBbnkoc3RyLCBCYWJ5LkJBRF9ERUxJTUlURVJTKVxuXHRcdFx0XHRcdFx0XHR8fCBzdHIuaW5kZXhPZihfZGVsaW1pdGVyKSA+IC0xXG5cdFx0XHRcdFx0XHRcdHx8IHN0ci5jaGFyQXQoMCkgPT0gJyAnXG5cdFx0XHRcdFx0XHRcdHx8IHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09ICcgJztcblxuXHRcdFx0cmV0dXJuIG5lZWRzUXVvdGVzID8gJ1wiJyArIHN0ciArICdcIicgOiBzdHI7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFzQW55KHN0ciwgc3Vic3RyaW5ncylcblx0XHR7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN1YnN0cmluZ3MubGVuZ3RoOyBpKyspXG5cdFx0XHRcdGlmIChzdHIuaW5kZXhPZihzdWJzdHJpbmdzW2ldKSA+IC0xKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cblxuXG5cblxuXHQvLyBVc2Ugb25lIFBhcnNlckhhbmRsZSBwZXIgZW50aXJlIENTViBmaWxlIG9yIHN0cmluZ1xuXHRmdW5jdGlvbiBQYXJzZXJIYW5kbGUoX2NvbmZpZylcblx0e1xuXHRcdC8vIE9uZSBnb2FsIGlzIHRvIG1pbmltaXplIHRoZSB1c2Ugb2YgcmVndWxhciBleHByZXNzaW9ucy4uLlxuXHRcdHZhciBGTE9BVCA9IC9eXFxzKi0/KFxcZCpcXC4/XFxkK3xcXGQrXFwuP1xcZCopKGVbLStdP1xcZCspP1xccyokL2k7XG5cblx0XHR2YXIgX2RlbGltaXRlckVycm9yO1x0Ly8gVGVtcG9yYXJ5IHN0YXRlIGJldHdlZW4gZGVsaW1pdGVyIGRldGVjdGlvbiBhbmQgcHJvY2Vzc2luZyByZXN1bHRzXG5cdFx0dmFyIF9maWVsZHMgPSBbXTtcdFx0Ly8gRmllbGRzIGFyZSBmcm9tIHRoZSBoZWFkZXIgcm93IG9mIHRoZSBpbnB1dCwgaWYgdGhlcmUgaXMgb25lXG5cdFx0dmFyIF9yZXN1bHRzID0ge1x0XHQvLyBUaGUgbGFzdCByZXN1bHRzIHJldHVybmVkIGZyb20gdGhlIHBhcnNlclxuXHRcdFx0ZGF0YTogW10sXG5cdFx0XHRlcnJvcnM6IFtdLFxuXHRcdFx0bWV0YToge31cblx0XHR9O1xuXHRcdF9jb25maWcgPSBjb3B5KF9jb25maWcpO1xuXG5cdFx0dGhpcy5wYXJzZSA9IGZ1bmN0aW9uKGlucHV0KVxuXHRcdHtcblx0XHRcdF9kZWxpbWl0ZXJFcnJvciA9IGZhbHNlO1xuXHRcdFx0aWYgKCFfY29uZmlnLmRlbGltaXRlcilcblx0XHRcdHtcblx0XHRcdFx0dmFyIGRlbGltR3Vlc3MgPSBndWVzc0RlbGltaXRlcihpbnB1dCk7XG5cdFx0XHRcdGlmIChkZWxpbUd1ZXNzLnN1Y2Nlc3NmdWwpXG5cdFx0XHRcdFx0X2NvbmZpZy5kZWxpbWl0ZXIgPSBkZWxpbUd1ZXNzLmJlc3REZWxpbWl0ZXI7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdF9kZWxpbWl0ZXJFcnJvciA9IHRydWU7XHQvLyBhZGQgZXJyb3IgYWZ0ZXIgcGFyc2luZyAob3RoZXJ3aXNlIGl0IHdvdWxkIGJlIG92ZXJ3cml0dGVuKVxuXHRcdFx0XHRcdF9jb25maWcuZGVsaW1pdGVyID0gXCIsXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3Jlc3VsdHMubWV0YS5kZWxpbWl0ZXIgPSBfY29uZmlnLmRlbGltaXRlcjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzRnVuY3Rpb24oX2NvbmZpZy5zdGVwKSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHVzZXJTdGVwID0gX2NvbmZpZy5zdGVwO1xuXHRcdFx0XHRfY29uZmlnLnN0ZXAgPSBmdW5jdGlvbihyZXN1bHRzLCBwYXJzZXIpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRfcmVzdWx0cyA9IHJlc3VsdHM7XG5cdFx0XHRcdFx0aWYgKG5lZWRzSGVhZGVyUm93KCkpXG5cdFx0XHRcdFx0XHRwcm9jZXNzUmVzdWx0cygpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHVzZXJTdGVwKHByb2Nlc3NSZXN1bHRzKCksIHBhcnNlcik7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdF9yZXN1bHRzID0gbmV3IFBhcnNlcihfY29uZmlnKS5wYXJzZShpbnB1dCk7XG5cdFx0XHRyZXR1cm4gcHJvY2Vzc1Jlc3VsdHMoKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdHMoKVxuXHRcdHtcblx0XHRcdGlmIChfcmVzdWx0cyAmJiBfZGVsaW1pdGVyRXJyb3IpXG5cdFx0XHR7XG5cdFx0XHRcdGFkZEVycm9yKFwiRGVsaW1pdGVyXCIsIFwiVW5kZXRlY3RhYmxlRGVsaW1pdGVyXCIsIFwiVW5hYmxlIHRvIGF1dG8tZGV0ZWN0IGRlbGltaXRpbmcgY2hhcmFjdGVyOyBkZWZhdWx0ZWQgdG8gY29tbWFcIik7XG5cdFx0XHRcdF9kZWxpbWl0ZXJFcnJvciA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmVlZHNIZWFkZXJSb3coKSlcblx0XHRcdFx0ZmlsbEhlYWRlckZpZWxkcygpO1xuXG5cdFx0XHRyZXR1cm4gYXBwbHlIZWFkZXJBbmREeW5hbWljVHlwaW5nKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbmVlZHNIZWFkZXJSb3coKVxuXHRcdHtcblx0XHRcdHJldHVybiBfY29uZmlnLmhlYWRlciAmJiBfZmllbGRzLmxlbmd0aCA9PSAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbGxIZWFkZXJGaWVsZHMoKVxuXHRcdHtcblx0XHRcdGlmICghX3Jlc3VsdHMpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBuZWVkc0hlYWRlclJvdygpICYmIGkgPCBfcmVzdWx0cy5kYXRhLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IF9yZXN1bHRzLmRhdGFbaV0ubGVuZ3RoOyBqKyspXG5cdFx0XHRcdFx0X2ZpZWxkcy5wdXNoKF9yZXN1bHRzLmRhdGFbaV1bal0pO1xuXHRcdFx0X3Jlc3VsdHMuZGF0YS5zcGxpY2UoMCwgMSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYXBwbHlIZWFkZXJBbmREeW5hbWljVHlwaW5nKClcblx0XHR7XG5cdFx0XHRpZiAoIV9yZXN1bHRzIHx8ICghX2NvbmZpZy5oZWFkZXIgJiYgIV9jb25maWcuZHluYW1pY1R5cGluZykpXG5cdFx0XHRcdHJldHVybiBfcmVzdWx0cztcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBfcmVzdWx0cy5kYXRhLmxlbmd0aDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgcm93ID0ge307XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgX3Jlc3VsdHMuZGF0YVtpXS5sZW5ndGg7IGorKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChfY29uZmlnLmR5bmFtaWNUeXBpbmcpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gX3Jlc3VsdHMuZGF0YVtpXVtqXTtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSA9PSBcInRydWVcIilcblx0XHRcdFx0XHRcdFx0X3Jlc3VsdHMuZGF0YVtpXVtqXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2YWx1ZSA9PSBcImZhbHNlXCIpXG5cdFx0XHRcdFx0XHRcdF9yZXN1bHRzLmRhdGFbaV1bal0gPSBmYWxzZTtcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0X3Jlc3VsdHMuZGF0YVtpXVtqXSA9IHRyeVBhcnNlRmxvYXQodmFsdWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChfY29uZmlnLmhlYWRlcilcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoaiA+PSBfZmllbGRzLmxlbmd0aClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKCFyb3dbXCJfX3BhcnNlZF9leHRyYVwiXSlcblx0XHRcdFx0XHRcdFx0XHRyb3dbXCJfX3BhcnNlZF9leHRyYVwiXSA9IFtdO1xuXHRcdFx0XHRcdFx0XHRyb3dbXCJfX3BhcnNlZF9leHRyYVwiXS5wdXNoKF9yZXN1bHRzLmRhdGFbaV1bal0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cm93W19maWVsZHNbal1dID0gX3Jlc3VsdHMuZGF0YVtpXVtqXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoX2NvbmZpZy5oZWFkZXIpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRfcmVzdWx0cy5kYXRhW2ldID0gcm93O1xuXHRcdFx0XHRcdGlmIChqID4gX2ZpZWxkcy5sZW5ndGgpXG5cdFx0XHRcdFx0XHRhZGRFcnJvcihcIkZpZWxkTWlzbWF0Y2hcIiwgXCJUb29NYW55RmllbGRzXCIsIFwiVG9vIG1hbnkgZmllbGRzOiBleHBlY3RlZCBcIiArIF9maWVsZHMubGVuZ3RoICsgXCIgZmllbGRzIGJ1dCBwYXJzZWQgXCIgKyBqLCBpKTtcblx0XHRcdFx0XHRlbHNlIGlmIChqIDwgX2ZpZWxkcy5sZW5ndGgpXG5cdFx0XHRcdFx0XHRhZGRFcnJvcihcIkZpZWxkTWlzbWF0Y2hcIiwgXCJUb29GZXdGaWVsZHNcIiwgXCJUb28gZmV3IGZpZWxkczogZXhwZWN0ZWQgXCIgKyBfZmllbGRzLmxlbmd0aCArIFwiIGZpZWxkcyBidXQgcGFyc2VkIFwiICsgaiwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKF9jb25maWcuaGVhZGVyICYmIF9yZXN1bHRzLm1ldGEpO1xuXHRcdFx0XHRfcmVzdWx0cy5tZXRhLmZpZWxkcyA9IF9maWVsZHM7XG5cblx0XHRcdHJldHVybiBfcmVzdWx0cztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBndWVzc0RlbGltaXRlcihpbnB1dClcblx0XHR7XG5cdFx0XHR2YXIgZGVsaW1DaG9pY2VzID0gW1wiLFwiLCBcIlxcdFwiLCBcInxcIiwgXCI7XCIsIEJhYnkuUkVDT1JEX1NFUCwgQmFieS5VTklUX1NFUF07XG5cdFx0XHR2YXIgYmVzdERlbGltLCBiZXN0RGVsdGEsIGZpZWxkQ291bnRQcmV2Um93O1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlbGltQ2hvaWNlcy5sZW5ndGg7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0dmFyIGRlbGltID0gZGVsaW1DaG9pY2VzW2ldO1xuXHRcdFx0XHR2YXIgZGVsdGEgPSAwLCBhdmdGaWVsZENvdW50ID0gMDtcblx0XHRcdFx0ZmllbGRDb3VudFByZXZSb3cgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0dmFyIHByZXZpZXcgPSBuZXcgUGFyc2VyKHtcblx0XHRcdFx0XHRkZWxpbWl0ZXI6IGRlbGltLFxuXHRcdFx0XHRcdHByZXZpZXc6IDEwXG5cdFx0XHRcdH0pLnBhcnNlKGlucHV0KTtcblxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHByZXZpZXcuZGF0YS5sZW5ndGg7IGorKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciBmaWVsZENvdW50ID0gcHJldmlldy5kYXRhW2pdLmxlbmd0aDtcblx0XHRcdFx0XHRhdmdGaWVsZENvdW50ICs9IGZpZWxkQ291bnQ7XG5cblx0XHRcdFx0XHRpZiAodHlwZW9mIGZpZWxkQ291bnRQcmV2Um93ID09PSAndW5kZWZpbmVkJylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmaWVsZENvdW50UHJldlJvdyA9IGZpZWxkQ291bnQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoZmllbGRDb3VudCA+IDEpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZGVsdGEgKz0gTWF0aC5hYnMoZmllbGRDb3VudCAtIGZpZWxkQ291bnRQcmV2Um93KTtcblx0XHRcdFx0XHRcdGZpZWxkQ291bnRQcmV2Um93ID0gZmllbGRDb3VudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhdmdGaWVsZENvdW50IC89IHByZXZpZXcuZGF0YS5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCh0eXBlb2YgYmVzdERlbHRhID09PSAndW5kZWZpbmVkJyB8fCBkZWx0YSA8IGJlc3REZWx0YSlcblx0XHRcdFx0XHQmJiBhdmdGaWVsZENvdW50ID4gMS45OSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGJlc3REZWx0YSA9IGRlbHRhO1xuXHRcdFx0XHRcdGJlc3REZWxpbSA9IGRlbGltO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdF9jb25maWcuZGVsaW1pdGVyID0gYmVzdERlbGltO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdWNjZXNzZnVsOiAhIWJlc3REZWxpbSxcblx0XHRcdFx0YmVzdERlbGltaXRlcjogYmVzdERlbGltXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJ5UGFyc2VGbG9hdCh2YWwpXG5cdFx0e1xuXHRcdFx0dmFyIGlzTnVtYmVyID0gRkxPQVQudGVzdCh2YWwpO1xuXHRcdFx0cmV0dXJuIGlzTnVtYmVyID8gcGFyc2VGbG9hdCh2YWwpIDogdmFsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEVycm9yKHR5cGUsIGNvZGUsIG1zZywgcm93KVxuXHRcdHtcblx0XHRcdF9yZXN1bHRzLmVycm9ycy5wdXNoKHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Y29kZTogY29kZSxcblx0XHRcdFx0bWVzc2FnZTogbXNnLFxuXHRcdFx0XHRyb3c6IHJvd1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblxuXG5cblxuXG5cblx0ZnVuY3Rpb24gUGFyc2VyKGNvbmZpZylcblx0e1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgRU1QVFkgPSAvXlxccyokLztcblxuXHRcdHZhciBfaW5wdXQ7XHRcdC8vIFRoZSBpbnB1dCB0ZXh0IGJlaW5nIHBhcnNlZFxuXHRcdHZhciBfZGVsaW1pdGVyO1x0Ly8gVGhlIGRlbGltaXRpbmcgY2hhcmFjdGVyXG5cdFx0dmFyIF9jb21tZW50cztcdC8vIENvbW1lbnQgY2hhcmFjdGVyIChkZWZhdWx0ICcjJykgb3IgYm9vbGVhblxuXHRcdHZhciBfc3RlcDtcdFx0Ly8gVGhlIHN0ZXAgKHN0cmVhbWluZykgZnVuY3Rpb25cblx0XHR2YXIgX2NhbGxiYWNrO1x0Ly8gVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIGZpbmlzaGVkXG5cdFx0dmFyIF9wcmV2aWV3O1x0Ly8gTWF4aW11bSBudW1iZXIgb2YgbGluZXMgKG5vdCByb3dzKSB0byBwYXJzZVxuXHRcdHZhciBfY2g7XHRcdC8vIEN1cnJlbnQgY2hhcmFjdGVyXG5cdFx0dmFyIF9pO1x0XHRcdC8vIEN1cnJlbnQgY2hhcmFjdGVyJ3MgcG9zaXRpb25hbCBpbmRleFxuXHRcdHZhciBfaW5RdW90ZXM7XHQvLyBXaGV0aGVyIGluIHF1b3RlcyBvciBub3Rcblx0XHR2YXIgX2xpbmVOdW07XHQvLyBDdXJyZW50IGxpbmUgbnVtYmVyICgxLWJhc2VkIGluZGV4aW5nKVxuXHRcdHZhciBfZGF0YTtcdFx0Ly8gUGFyc2VkIGRhdGEgKHJlc3VsdHMpXG5cdFx0dmFyIF9lcnJvcnM7XHQvLyBQYXJzZSBlcnJvcnNcblx0XHR2YXIgX3Jvd0lkeDtcdC8vIEN1cnJlbnQgcm93IGluZGV4IHdpdGhpbiByZXN1bHRzICgwLWJhc2VkKVxuXHRcdHZhciBfY29sSWR4O1x0Ly8gQ3VycmVudCBjb2wgaW5kZXggd2l0aGluIHJlc3VsdCByb3cgKDAtYmFzZWQpXG5cdFx0dmFyIF9ydW5uaW5nUm93SWR4O1x0XHQvLyBDdW11bGF0aXZlIHJvdyBpbmRleCwgdXNlZCBieSB0aGUgcHJldmlldyBmZWF0dXJlXG5cdFx0dmFyIF9hYm9ydGVkID0gZmFsc2U7XHQvLyBBYm9ydCBmbGFnXG5cdFx0dmFyIF9wYXVzZWQgPSBmYWxzZTtcdC8vIFBhdXNlIGZsYWdcblxuXHRcdC8vIFVucGFjayB0aGUgY29uZmlnIG9iamVjdFxuXHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblx0XHRfZGVsaW1pdGVyID0gY29uZmlnLmRlbGltaXRlcjtcblx0XHRfY29tbWVudHMgPSBjb25maWcuY29tbWVudHM7XG5cdFx0X3N0ZXAgPSBjb25maWcuc3RlcDtcblx0XHRfcHJldmlldyA9IGNvbmZpZy5wcmV2aWV3O1xuXG5cdFx0Ly8gRGVsaW1pdGVyIGludGVncml0eSBjaGVja1xuXHRcdGlmICh0eXBlb2YgX2RlbGltaXRlciAhPT0gJ3N0cmluZydcblx0XHRcdHx8IF9kZWxpbWl0ZXIubGVuZ3RoICE9IDFcblx0XHRcdHx8IEJhYnkuQkFEX0RFTElNSVRFUlMuaW5kZXhPZihfZGVsaW1pdGVyKSA+IC0xKVxuXHRcdFx0X2RlbGltaXRlciA9IFwiLFwiO1xuXG5cdFx0Ly8gQ29tbWVudCBjaGFyYWN0ZXIgaW50ZWdyaXR5IGNoZWNrXG5cdFx0aWYgKF9jb21tZW50cyA9PT0gdHJ1ZSlcblx0XHRcdF9jb21tZW50cyA9IFwiI1wiO1xuXHRcdGVsc2UgaWYgKHR5cGVvZiBfY29tbWVudHMgIT09ICdzdHJpbmcnXG5cdFx0XHR8fCBfY29tbWVudHMubGVuZ3RoICE9IDFcblx0XHRcdHx8IEJhYnkuQkFEX0RFTElNSVRFUlMuaW5kZXhPZihfY29tbWVudHMpID4gLTFcblx0XHRcdHx8IF9jb21tZW50cyA9PSBfZGVsaW1pdGVyKVxuXHRcdFx0X2NvbW1lbnRzID0gZmFsc2U7XG5cblxuXHRcdHRoaXMucGFyc2UgPSBmdW5jdGlvbihpbnB1dClcblx0XHR7XG5cdFx0XHRpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJylcblx0XHRcdFx0dGhyb3cgXCJJbnB1dCBtdXN0IGJlIGEgc3RyaW5nXCI7XG5cdFx0XHRyZXNldChpbnB1dCk7XG5cdFx0XHRyZXR1cm4gcGFyc2VyTG9vcCgpO1xuXHRcdH07XG5cblx0XHR0aGlzLmFib3J0ID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdF9hYm9ydGVkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VyTG9vcCgpXG5cdFx0e1xuXHRcdFx0d2hpbGUgKF9pIDwgX2lucHV0Lmxlbmd0aClcblx0XHRcdHtcblx0XHRcdFx0aWYgKF9hYm9ydGVkKSBicmVhaztcblx0XHRcdFx0aWYgKF9wcmV2aWV3ID4gMCAmJiBfcnVubmluZ1Jvd0lkeCA+PSBfcHJldmlldykgYnJlYWs7XG5cdFx0XHRcdGlmIChfcGF1c2VkKSByZXR1cm4gZmluaXNoUGFyc2luZygpO1xuXG5cdFx0XHRcdGlmIChfY2ggPT0gJ1wiJylcblx0XHRcdFx0XHRwYXJzZVF1b3RlcygpO1xuXHRcdFx0XHRlbHNlIGlmIChfaW5RdW90ZXMpXG5cdFx0XHRcdFx0cGFyc2VJblF1b3RlcygpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0cGFyc2VOb3RJblF1b3RlcygpO1xuXG5cdFx0XHRcdG5leHRDaGFyKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmaW5pc2hQYXJzaW5nKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbmV4dENoYXIoKVxuXHRcdHtcblx0XHRcdF9pKys7XG5cdFx0XHRfY2ggPSBfaW5wdXRbX2ldO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbmlzaFBhcnNpbmcoKVxuXHRcdHtcblx0XHRcdGlmIChfYWJvcnRlZClcblx0XHRcdFx0YWRkRXJyb3IoXCJBYm9ydFwiLCBcIlBhcnNlQWJvcnRcIiwgXCJQYXJzaW5nIHdhcyBhYm9ydGVkIGJ5IHRoZSB1c2VyJ3Mgc3RlcCBmdW5jdGlvblwiKTtcblx0XHRcdGlmIChfaW5RdW90ZXMpXG5cdFx0XHRcdGFkZEVycm9yKFwiUXVvdGVzXCIsIFwiTWlzc2luZ1F1b3Rlc1wiLCBcIlVuZXNjYXBlZCBvciBtaXNtYXRjaGVkIHF1b3Rlc1wiKTtcblx0XHRcdGVuZFJvdygpO1x0Ly8gRW5kIG9mIGlucHV0IGlzIGFsc28gZW5kIG9mIHRoZSBsYXN0IHJvd1xuXHRcdFx0aWYgKCFpc0Z1bmN0aW9uKF9zdGVwKSlcblx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVF1b3RlcygpXG5cdFx0e1xuXHRcdFx0aWYgKHF1b3Rlc09uQm91bmRhcnkoKSAmJiAhcXVvdGVzRXNjYXBlZCgpKVxuXHRcdFx0XHRfaW5RdW90ZXMgPSAhX2luUXVvdGVzO1xuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRzYXZlQ2hhcigpO1xuXHRcdFx0XHRpZiAoX2luUXVvdGVzICYmIHF1b3Rlc0VzY2FwZWQoKSlcblx0XHRcdFx0XHRfaSsrXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRhZGRFcnJvcihcIlF1b3Rlc1wiLCBcIlVuZXhwZWN0ZWRRdW90ZXNcIiwgXCJVbmV4cGVjdGVkIHF1b3Rlc1wiKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUluUXVvdGVzKClcblx0XHR7XG5cdFx0XHRpZiAodHdvQ2hhckxpbmVCcmVhayhfaSkgfHwgb25lQ2hhckxpbmVCcmVhayhfaSkpXG5cdFx0XHRcdF9saW5lTnVtKys7XG5cdFx0XHRzYXZlQ2hhcigpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlTm90SW5RdW90ZXMoKVxuXHRcdHtcblx0XHRcdGlmIChfY2ggPT0gX2RlbGltaXRlcilcblx0XHRcdFx0bmV3RmllbGQoKTtcblx0XHRcdGVsc2UgaWYgKHR3b0NoYXJMaW5lQnJlYWsoX2kpKVxuXHRcdFx0e1xuXHRcdFx0XHRuZXdSb3coKTtcblx0XHRcdFx0bmV4dENoYXIoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG9uZUNoYXJMaW5lQnJlYWsoX2kpKVxuXHRcdFx0XHRuZXdSb3coKTtcblx0XHRcdGVsc2UgaWYgKGlzQ29tbWVudFN0YXJ0KCkpXG5cdFx0XHRcdHNraXBMaW5lKCk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHNhdmVDaGFyKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNDb21tZW50U3RhcnQoKVxuXHRcdHtcblx0XHRcdGlmICghX2NvbW1lbnRzKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdHZhciBmaXJzdENoYXJPZkxpbmUgPSBfaSA9PSAwXG5cdFx0XHRcdFx0XHRcdFx0XHR8fCBvbmVDaGFyTGluZUJyZWFrKF9pLTEpXG5cdFx0XHRcdFx0XHRcdFx0XHR8fCB0d29DaGFyTGluZUJyZWFrKF9pLTIpO1xuXHRcdFx0cmV0dXJuIGZpcnN0Q2hhck9mTGluZSAmJiBfaW5wdXRbX2ldID09PSBfY29tbWVudHM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2tpcExpbmUoKVxuXHRcdHtcblx0XHRcdHdoaWxlICghdHdvQ2hhckxpbmVCcmVhayhfaSlcblx0XHRcdFx0JiYgIW9uZUNoYXJMaW5lQnJlYWsoX2kpXG5cdFx0XHRcdCYmIF9pIDwgX2lucHV0Lmxlbmd0aClcblx0XHRcdHtcblx0XHRcdFx0bmV4dENoYXIoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzYXZlQ2hhcigpXG5cdFx0e1xuXHRcdFx0X2RhdGFbX3Jvd0lkeF1bX2NvbElkeF0gKz0gX2NoO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5ld0ZpZWxkKClcblx0XHR7XG5cdFx0XHRfZGF0YVtfcm93SWR4XS5wdXNoKFwiXCIpO1xuXHRcdFx0X2NvbElkeCA9IF9kYXRhW19yb3dJZHhdLmxlbmd0aCAtIDE7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbmV3Um93KClcblx0XHR7XG5cdFx0XHRlbmRSb3coKTtcblxuXHRcdFx0X2xpbmVOdW0rKztcblx0XHRcdF9ydW5uaW5nUm93SWR4Kys7XG5cdFx0XHRfZGF0YS5wdXNoKFtdKTtcblx0XHRcdF9yb3dJZHggPSBfZGF0YS5sZW5ndGggLSAxO1xuXHRcdFx0bmV3RmllbGQoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlbmRSb3coKVxuXHRcdHtcblx0XHRcdHRyaW1FbXB0eUxhc3RSb3coKTtcblx0XHRcdGlmIChpc0Z1bmN0aW9uKF9zdGVwKSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKF9kYXRhW19yb3dJZHhdKVxuXHRcdFx0XHRcdF9zdGVwKHJldHVybmFibGUoKSwgc2VsZik7XG5cdFx0XHRcdGNsZWFyRXJyb3JzQW5kRGF0YSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaW1FbXB0eUxhc3RSb3coKVxuXHRcdHtcblx0XHRcdGlmIChfZGF0YVtfcm93SWR4XS5sZW5ndGggPT0gMSAmJiBFTVBUWS50ZXN0KF9kYXRhW19yb3dJZHhdWzBdKSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKGNvbmZpZy5rZWVwRW1wdHlSb3dzKVxuXHRcdFx0XHRcdF9kYXRhW19yb3dJZHhdLnNwbGljZSgwLCAxKTtcdC8vIGxlYXZlIHJvdywgYnV0IG5vIGZpZWxkc1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0X2RhdGEuc3BsaWNlKF9yb3dJZHgsIDEpO1x0XHQvLyBjdXQgb3V0IHJvdyBlbnRpcmVseVxuXHRcdFx0XHRfcm93SWR4ID0gX2RhdGEubGVuZ3RoIC0gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0d29DaGFyTGluZUJyZWFrKGkpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGkgPCBfaW5wdXQubGVuZ3RoIC0gMSAmJlxuXHRcdFx0XHQoKF9pbnB1dFtpXSA9PSBcIlxcclwiICYmIF9pbnB1dFtpKzFdID09IFwiXFxuXCIpXG5cdFx0XHRcdHx8IChfaW5wdXRbaV0gPT0gXCJcXG5cIiAmJiBfaW5wdXRbaSsxXSA9PSBcIlxcclwiKSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbmVDaGFyTGluZUJyZWFrKGkpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9pbnB1dFtpXSA9PSBcIlxcclwiIHx8IF9pbnB1dFtpXSA9PSBcIlxcblwiO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHF1b3Rlc0VzY2FwZWQoKVxuXHRcdHtcblx0XHRcdC8vIFF1b3RlcyBhcyBkYXRhIGNhbm5vdCBiZSBvbiBib3VuZGFyeSwgZm9yIGV4YW1wbGU6ICxcIlwiLCBhcmUgbm90IGVzY2FwZWQgcXVvdGVzXG5cdFx0XHRyZXR1cm4gIXF1b3Rlc09uQm91bmRhcnkoKSAmJiBfaSA8IF9pbnB1dC5sZW5ndGggLSAxICYmIF9pbnB1dFtfaSsxXSA9PSAnXCInO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHF1b3Rlc09uQm91bmRhcnkoKVxuXHRcdHtcblx0XHRcdHJldHVybiAoIV9pblF1b3RlcyAmJiBpc0JvdW5kYXJ5KF9pLTEpKSB8fCBpc0JvdW5kYXJ5KF9pKzEpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQm91bmRhcnkoaSlcblx0XHR7XG5cdFx0XHRpZiAodHlwZW9mIGkgIT0gJ251bWJlcicpXG5cdFx0XHRcdGkgPSBfaTtcblxuXHRcdFx0dmFyIGNoID0gX2lucHV0W2ldO1xuXG5cdFx0XHRyZXR1cm4gKGkgPD0gLTEgfHwgaSA+PSBfaW5wdXQubGVuZ3RoKVxuXHRcdFx0XHR8fCAoY2ggPT0gX2RlbGltaXRlclxuXHRcdFx0XHRcdHx8IGNoID09IFwiXFxyXCJcblx0XHRcdFx0XHR8fCBjaCA9PSBcIlxcblwiKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRFcnJvcih0eXBlLCBjb2RlLCBtc2cpXG5cdFx0e1xuXHRcdFx0X2Vycm9ycy5wdXNoKHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Y29kZTogY29kZSxcblx0XHRcdFx0bWVzc2FnZTogbXNnLFxuXHRcdFx0XHRsaW5lOiBfbGluZU51bSxcblx0XHRcdFx0cm93OiBfcm93SWR4LFxuXHRcdFx0XHRpbmRleDogX2lcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc2V0KGlucHV0KVxuXHRcdHtcblx0XHRcdF9pbnB1dCA9IGlucHV0O1xuXHRcdFx0X2luUXVvdGVzID0gZmFsc2U7XG5cdFx0XHRfaSA9IDAsIF9ydW5uaW5nUm93SWR4ID0gMCwgX2xpbmVOdW0gPSAxO1xuXHRcdFx0Y2xlYXJFcnJvcnNBbmREYXRhKCk7XG5cdFx0XHRfZGF0YSA9IFsgW1wiXCJdIF07XHQvLyBzdGFydGluZyBwYXJzaW5nIHJlcXVpcmVzIGFuIGVtcHR5IGZpZWxkXG5cdFx0XHRfY2ggPSBfaW5wdXRbX2ldO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNsZWFyRXJyb3JzQW5kRGF0YSgpXG5cdFx0e1xuXHRcdFx0X2RhdGEgPSBbXTtcblx0XHRcdF9lcnJvcnMgPSBbXTtcblx0XHRcdF9yb3dJZHggPSAwO1xuXHRcdFx0X2NvbElkeCA9IDA7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmV0dXJuYWJsZSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogX2RhdGEsXG5cdFx0XHRcdGVycm9yczogX2Vycm9ycyxcblx0XHRcdFx0bWV0YToge1xuXHRcdFx0XHRcdGxpbmVzOiBfbGluZU51bSxcblx0XHRcdFx0XHRkZWxpbWl0ZXI6IF9kZWxpbWl0ZXIsXG5cdFx0XHRcdFx0YWJvcnRlZDogX2Fib3J0ZWRcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXBsYWNlcyBiYWQgY29uZmlnIHZhbHVlcyB3aXRoIGdvb2QsIGRlZmF1bHQgb25lc1xuXHRmdW5jdGlvbiBjb3B5QW5kVmFsaWRhdGVDb25maWcob3JpZ0NvbmZpZylcblx0e1xuXHRcdGlmICh0eXBlb2Ygb3JpZ0NvbmZpZyAhPT0gJ29iamVjdCcpXG5cdFx0XHRvcmlnQ29uZmlnID0ge307XG5cblx0XHR2YXIgY29uZmlnID0gY29weShvcmlnQ29uZmlnKTtcblxuXHRcdGlmICh0eXBlb2YgY29uZmlnLmRlbGltaXRlciAhPT0gJ3N0cmluZydcblx0XHRcdHx8IGNvbmZpZy5kZWxpbWl0ZXIubGVuZ3RoICE9IDFcblx0XHRcdHx8IEJhYnkuQkFEX0RFTElNSVRFUlMuaW5kZXhPZihjb25maWcuZGVsaW1pdGVyKSA+IC0xKVxuXHRcdFx0Y29uZmlnLmRlbGltaXRlciA9IERFRkFVTFRTLmRlbGltaXRlcjtcblxuXHRcdGlmICh0eXBlb2YgY29uZmlnLmhlYWRlciAhPT0gJ2Jvb2xlYW4nKVxuXHRcdFx0Y29uZmlnLmhlYWRlciA9IERFRkFVTFRTLmhlYWRlcjtcblxuXHRcdGlmICh0eXBlb2YgY29uZmlnLmR5bmFtaWNUeXBpbmcgIT09ICdib29sZWFuJylcblx0XHRcdGNvbmZpZy5keW5hbWljVHlwaW5nID0gREVGQVVMVFMuZHluYW1pY1R5cGluZztcblxuXHRcdGlmICh0eXBlb2YgY29uZmlnLnByZXZpZXcgIT09ICdudW1iZXInKVxuXHRcdFx0Y29uZmlnLnByZXZpZXcgPSBERUZBVUxUUy5wcmV2aWV3O1xuXG5cdFx0aWYgKHR5cGVvZiBjb25maWcuc3RlcCAhPT0gJ2Z1bmN0aW9uJylcblx0XHRcdGNvbmZpZy5zdGVwID0gREVGQVVMVFMuc3RlcDtcblxuXHRcdGlmICh0eXBlb2YgY29uZmlnLmNvbXBsZXRlICE9PSAnZnVuY3Rpb24nKVxuXHRcdFx0Y29uZmlnLmNvbXBsZXRlID0gREVGQVVMVFMuY29tcGxldGU7XG5cblx0XHRpZiAodHlwZW9mIGNvbmZpZy5rZWVwRW1wdHlSb3dzICE9PSAnYm9vbGVhbicpXG5cdFx0XHRjb25maWcua2VlcEVtcHR5Um93cyA9IERFRkFVTFRTLmtlZXBFbXB0eVJvd3M7XG5cblx0XHRyZXR1cm4gY29uZmlnO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29weShvYmopXG5cdHtcblx0XHRpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdHZhciBjcHkgPSBvYmogaW5zdGFuY2VvZiBBcnJheSA/IFtdIDoge307XG5cdFx0Zm9yICh2YXIga2V5IGluIG9iailcblx0XHRcdGNweVtrZXldID0gY29weShvYmpba2V5XSk7XG5cdFx0cmV0dXJuIGNweTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuYylcblx0e1xuXHRcdHJldHVybiB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJztcblx0fVxuXG5cblxuXG5cblxuXHQvLyBleHBvcnQgdG8gTm9kZS4uLlxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gQmFieTtcblx0fVxuXG5cdC8vIC4uLm9yIGFzIEFNRCBtb2R1bGUuLi5cblx0ZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHRkZWZpbmUoIGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhYnk7IH0pO1xuXHR9XG5cblx0Ly8gLi4ub3IgYXMgYnJvd3NlciBnbG9iYWxcblx0ZWxzZSB7XG5cdFx0Z2xvYmFsLkJhYnkgPSBCYWJ5O1xuXHR9XG5cblxuXG59KCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMgKSk7XG4iLCIvKiFcbiAqIG51bWVyYWwuanNcbiAqIHZlcnNpb24gOiAxLjUuM1xuICogYXV0aG9yIDogQWRhbSBEcmFwZXJcbiAqIGxpY2Vuc2UgOiBNSVRcbiAqIGh0dHA6Ly9hZGFtd2RyYXBlci5naXRodWIuY29tL051bWVyYWwtanMvXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgQ29uc3RhbnRzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIG51bWVyYWwsXG4gICAgICAgIFZFUlNJT04gPSAnMS41LjMnLFxuICAgICAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsYW5ndWFnZSBjb25maWcgZmlsZXNcbiAgICAgICAgbGFuZ3VhZ2VzID0ge30sXG4gICAgICAgIGN1cnJlbnRMYW5ndWFnZSA9ICdlbicsXG4gICAgICAgIHplcm9Gb3JtYXQgPSBudWxsLFxuICAgICAgICBkZWZhdWx0Rm9ybWF0ID0gJzAsMCcsXG4gICAgICAgIC8vIGNoZWNrIGZvciBub2RlSlNcbiAgICAgICAgaGFzTW9kdWxlID0gKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdHJ1Y3RvcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIC8vIE51bWVyYWwgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE51bWVyYWwgKG51bWJlcikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0b0ZpeGVkKCkgdGhhdCB0cmVhdHMgZmxvYXRzIG1vcmUgbGlrZSBkZWNpbWFsc1xuICAgICAqXG4gICAgICogRml4ZXMgYmluYXJ5IHJvdW5kaW5nIGlzc3VlcyAoZWcuICgwLjYxNSkudG9GaXhlZCgyKSA9PT0gJzAuNjEnKSB0aGF0IHByZXNlbnRcbiAgICAgKiBwcm9ibGVtcyBmb3IgYWNjb3VudGluZy0gYW5kIGZpbmFuY2UtcmVsYXRlZCBzb2Z0d2FyZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ZpeGVkICh2YWx1ZSwgcHJlY2lzaW9uLCByb3VuZGluZ0Z1bmN0aW9uLCBvcHRpb25hbHMpIHtcbiAgICAgICAgdmFyIHBvd2VyID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiksXG4gICAgICAgICAgICBvcHRpb25hbHNSZWdFeHAsXG4gICAgICAgICAgICBvdXRwdXQ7XG4gICAgICAgICAgICBcbiAgICAgICAgLy9yb3VuZGluZ0Z1bmN0aW9uID0gKHJvdW5kaW5nRnVuY3Rpb24gIT09IHVuZGVmaW5lZCA/IHJvdW5kaW5nRnVuY3Rpb24gOiBNYXRoLnJvdW5kKTtcbiAgICAgICAgLy8gTXVsdGlwbHkgdXAgYnkgcHJlY2lzaW9uLCByb3VuZCBhY2N1cmF0ZWx5LCB0aGVuIGRpdmlkZSBhbmQgdXNlIG5hdGl2ZSB0b0ZpeGVkKCk6XG4gICAgICAgIG91dHB1dCA9IChyb3VuZGluZ0Z1bmN0aW9uKHZhbHVlICogcG93ZXIpIC8gcG93ZXIpLnRvRml4ZWQocHJlY2lzaW9uKTtcblxuICAgICAgICBpZiAob3B0aW9uYWxzKSB7XG4gICAgICAgICAgICBvcHRpb25hbHNSZWdFeHAgPSBuZXcgUmVnRXhwKCcwezEsJyArIG9wdGlvbmFscyArICd9JCcpO1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2Uob3B0aW9uYWxzUmVnRXhwLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRm9ybWF0dGluZ1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8vIGRldGVybWluZSB3aGF0IHR5cGUgb2YgZm9ybWF0dGluZyB3ZSBuZWVkIHRvIGRvXG4gICAgZnVuY3Rpb24gZm9ybWF0TnVtZXJhbCAobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBvdXRwdXQ7XG5cbiAgICAgICAgLy8gZmlndXJlIG91dCB3aGF0IGtpbmQgb2YgZm9ybWF0IHdlIGFyZSBkZWFsaW5nIHdpdGhcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCckJykgPiAtMSkgeyAvLyBjdXJyZW5jeSEhISEhXG4gICAgICAgICAgICBvdXRwdXQgPSBmb3JtYXRDdXJyZW5jeShuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCclJykgPiAtMSkgeyAvLyBwZXJjZW50YWdlXG4gICAgICAgICAgICBvdXRwdXQgPSBmb3JtYXRQZXJjZW50YWdlKG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJzonKSA+IC0xKSB7IC8vIHRpbWVcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdFRpbWUobiwgZm9ybWF0KTtcbiAgICAgICAgfSBlbHNlIHsgLy8gcGxhaW4gb2wnIG51bWJlcnMgb3IgYnl0ZXNcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdE51bWJlcihuLl92YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBzdHJpbmdcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICAvLyByZXZlcnQgdG8gbnVtYmVyXG4gICAgZnVuY3Rpb24gdW5mb3JtYXROdW1lcmFsIChuLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIHN0cmluZ09yaWdpbmFsID0gc3RyaW5nLFxuICAgICAgICAgICAgdGhvdXNhbmRSZWdFeHAsXG4gICAgICAgICAgICBtaWxsaW9uUmVnRXhwLFxuICAgICAgICAgICAgYmlsbGlvblJlZ0V4cCxcbiAgICAgICAgICAgIHRyaWxsaW9uUmVnRXhwLFxuICAgICAgICAgICAgc3VmZml4ZXMgPSBbJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ10sXG4gICAgICAgICAgICBieXRlc011bHRpcGxpZXIgPSBmYWxzZSxcbiAgICAgICAgICAgIHBvd2VyO1xuXG4gICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignOicpID4gLTEpIHtcbiAgICAgICAgICAgIG4uX3ZhbHVlID0gdW5mb3JtYXRUaW1lKHN0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RyaW5nID09PSB6ZXJvRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgbi5fdmFsdWUgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uZGVsaW1pdGVycy5kZWNpbWFsICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1xcLi9nLCcnKS5yZXBsYWNlKGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmRlbGltaXRlcnMuZGVjaW1hbCwgJy4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZWUgaWYgYWJicmV2aWF0aW9ucyBhcmUgdGhlcmUgc28gdGhhdCB3ZSBjYW4gbXVsdGlwbHkgdG8gdGhlIGNvcnJlY3QgbnVtYmVyXG4gICAgICAgICAgICAgICAgdGhvdXNhbmRSZWdFeHAgPSBuZXcgUmVnRXhwKCdbXmEtekEtWl0nICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy50aG91c2FuZCArICcoPzpcXFxcKXwoXFxcXCcgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyAnKT8oPzpcXFxcKSk/KT8kJyk7XG4gICAgICAgICAgICAgICAgbWlsbGlvblJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLm1pbGxpb24gKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuICAgICAgICAgICAgICAgIGJpbGxpb25SZWdFeHAgPSBuZXcgUmVnRXhwKCdbXmEtekEtWl0nICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy5iaWxsaW9uICsgJyg/OlxcXFwpfChcXFxcJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArICcpPyg/OlxcXFwpKT8pPyQnKTtcbiAgICAgICAgICAgICAgICB0cmlsbGlvblJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRyaWxsaW9uICsgJyg/OlxcXFwpfChcXFxcJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArICcpPyg/OlxcXFwpKT8pPyQnKTtcblxuICAgICAgICAgICAgICAgIC8vIHNlZSBpZiBieXRlcyBhcmUgdGhlcmUgc28gdGhhdCB3ZSBjYW4gbXVsdGlwbHkgdG8gdGhlIGNvcnJlY3QgbnVtYmVyXG4gICAgICAgICAgICAgICAgZm9yIChwb3dlciA9IDA7IHBvd2VyIDw9IHN1ZmZpeGVzLmxlbmd0aDsgcG93ZXIrKykge1xuICAgICAgICAgICAgICAgICAgICBieXRlc011bHRpcGxpZXIgPSAoc3RyaW5nLmluZGV4T2Yoc3VmZml4ZXNbcG93ZXJdKSA+IC0xKSA/IE1hdGgucG93KDEwMjQsIHBvd2VyICsgMSkgOiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXNNdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRvIHNvbWUgbWF0aCB0byBjcmVhdGUgb3VyIG51bWJlclxuICAgICAgICAgICAgICAgIG4uX3ZhbHVlID0gKChieXRlc011bHRpcGxpZXIpID8gYnl0ZXNNdWx0aXBsaWVyIDogMSkgKiAoKHN0cmluZ09yaWdpbmFsLm1hdGNoKHRob3VzYW5kUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgMykgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2gobWlsbGlvblJlZ0V4cCkpID8gTWF0aC5wb3coMTAsIDYpIDogMSkgKiAoKHN0cmluZ09yaWdpbmFsLm1hdGNoKGJpbGxpb25SZWdFeHApKSA/IE1hdGgucG93KDEwLCA5KSA6IDEpICogKChzdHJpbmdPcmlnaW5hbC5tYXRjaCh0cmlsbGlvblJlZ0V4cCkpID8gTWF0aC5wb3coMTAsIDEyKSA6IDEpICogKChzdHJpbmcuaW5kZXhPZignJScpID4gLTEpID8gMC4wMSA6IDEpICogKCgoc3RyaW5nLnNwbGl0KCctJykubGVuZ3RoICsgTWF0aC5taW4oc3RyaW5nLnNwbGl0KCcoJykubGVuZ3RoLTEsIHN0cmluZy5zcGxpdCgnKScpLmxlbmd0aC0xKSkgJSAyKT8gMTogLTEpICogTnVtYmVyKHN0cmluZy5yZXBsYWNlKC9bXjAtOVxcLl0rL2csICcnKSk7XG5cbiAgICAgICAgICAgICAgICAvLyByb3VuZCBpZiB3ZSBhcmUgdGFsa2luZyBhYm91dCBieXRlc1xuICAgICAgICAgICAgICAgIG4uX3ZhbHVlID0gKGJ5dGVzTXVsdGlwbGllcikgPyBNYXRoLmNlaWwobi5fdmFsdWUpIDogbi5fdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4uX3ZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdEN1cnJlbmN5IChuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHN5bWJvbEluZGV4ID0gZm9ybWF0LmluZGV4T2YoJyQnKSxcbiAgICAgICAgICAgIG9wZW5QYXJlbkluZGV4ID0gZm9ybWF0LmluZGV4T2YoJygnKSxcbiAgICAgICAgICAgIG1pbnVzU2lnbkluZGV4ID0gZm9ybWF0LmluZGV4T2YoJy0nKSxcbiAgICAgICAgICAgIHNwYWNlID0gJycsXG4gICAgICAgICAgICBzcGxpY2VJbmRleCxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlIG9yIGFmdGVyIGN1cnJlbmN5XG4gICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignICQnKSA+IC0xKSB7XG4gICAgICAgICAgICBzcGFjZSA9ICcgJztcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgJCcsICcnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignJCAnKSA+IC0xKSB7XG4gICAgICAgICAgICBzcGFjZSA9ICcgJztcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCckICcsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCckJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9ybWF0IHRoZSBudW1iZXJcbiAgICAgICAgb3V0cHV0ID0gZm9ybWF0TnVtYmVyKG4uX3ZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuXG4gICAgICAgIC8vIHBvc2l0aW9uIHRoZSBzeW1ib2xcbiAgICAgICAgaWYgKHN5bWJvbEluZGV4IDw9IDEpIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKCcpID4gLTEgfHwgb3V0cHV0LmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBzcGxpY2VJbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbEluZGV4IDwgb3BlblBhcmVuSW5kZXggfHwgc3ltYm9sSW5kZXggPCBtaW51c1NpZ25JbmRleCl7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzeW1ib2wgYXBwZWFycyBiZWZvcmUgdGhlIFwiKFwiIG9yIFwiLVwiXG4gICAgICAgICAgICAgICAgICAgIHNwbGljZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwbGljZShzcGxpY2VJbmRleCwgMCwgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgc3BhY2UgKyBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0LmluZGV4T2YoJyknKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BsaWNlKC0xLCAwLCBzcGFjZSArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBzcGFjZSArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0UGVyY2VudGFnZSAobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBzcGFjZSA9ICcnLFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgdmFsdWUgPSBuLl92YWx1ZSAqIDEwMDtcblxuICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlICVcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgJScpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyAlJywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyUnLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQgPSBmb3JtYXROdW1iZXIodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIFxuICAgICAgICBpZiAob3V0cHV0LmluZGV4T2YoJyknKSA+IC0xICkge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgJyUnKTtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgJyUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRUaW1lIChuKSB7XG4gICAgICAgIHZhciBob3VycyA9IE1hdGguZmxvb3Iobi5fdmFsdWUvNjAvNjApLFxuICAgICAgICAgICAgbWludXRlcyA9IE1hdGguZmxvb3IoKG4uX3ZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkpLzYwKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSBNYXRoLnJvdW5kKG4uX3ZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkgLSAobWludXRlcyAqIDYwKSk7XG4gICAgICAgIHJldHVybiBob3VycyArICc6JyArICgobWludXRlcyA8IDEwKSA/ICcwJyArIG1pbnV0ZXMgOiBtaW51dGVzKSArICc6JyArICgoc2Vjb25kcyA8IDEwKSA/ICcwJyArIHNlY29uZHMgOiBzZWNvbmRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmZvcm1hdFRpbWUgKHN0cmluZykge1xuICAgICAgICB2YXIgdGltZUFycmF5ID0gc3RyaW5nLnNwbGl0KCc6JyksXG4gICAgICAgICAgICBzZWNvbmRzID0gMDtcbiAgICAgICAgLy8gdHVybiBob3VycyBhbmQgbWludXRlcyBpbnRvIHNlY29uZHMgYW5kIGFkZCB0aGVtIGFsbCB1cFxuICAgICAgICBpZiAodGltZUFycmF5Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgLy8gaG91cnNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgKE51bWJlcih0aW1lQXJyYXlbMF0pICogNjAgKiA2MCk7XG4gICAgICAgICAgICAvLyBtaW51dGVzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzFdKSAqIDYwKTtcbiAgICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgTnVtYmVyKHRpbWVBcnJheVsyXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZUFycmF5Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyAoTnVtYmVyKHRpbWVBcnJheVswXSkgKiA2MCk7XG4gICAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIE51bWJlcih0aW1lQXJyYXlbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIoc2Vjb25kcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0TnVtYmVyICh2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBuZWdQID0gZmFsc2UsXG4gICAgICAgICAgICBzaWduZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIG9wdERlYyA9IGZhbHNlLFxuICAgICAgICAgICAgYWJiciA9ICcnLFxuICAgICAgICAgICAgYWJicksgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIHRob3VzYW5kc1xuICAgICAgICAgICAgYWJick0gPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIG1pbGxpb25zXG4gICAgICAgICAgICBhYmJyQiA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gYmlsbGlvbnNcbiAgICAgICAgICAgIGFiYnJUID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byB0cmlsbGlvbnNcbiAgICAgICAgICAgIGFiYnJGb3JjZSA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb25cbiAgICAgICAgICAgIGJ5dGVzID0gJycsXG4gICAgICAgICAgICBvcmQgPSAnJyxcbiAgICAgICAgICAgIGFicyA9IE1hdGguYWJzKHZhbHVlKSxcbiAgICAgICAgICAgIHN1ZmZpeGVzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ10sXG4gICAgICAgICAgICBtaW4sXG4gICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICBwb3dlcixcbiAgICAgICAgICAgIHcsXG4gICAgICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgICAgICB0aG91c2FuZHMsXG4gICAgICAgICAgICBkID0gJycsXG4gICAgICAgICAgICBuZWcgPSBmYWxzZTtcblxuICAgICAgICAvLyBjaGVjayBpZiBudW1iZXIgaXMgemVybyBhbmQgYSBjdXN0b20gemVybyBmb3JtYXQgaGFzIGJlZW4gc2V0XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiB6ZXJvRm9ybWF0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb0Zvcm1hdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNlZSBpZiB3ZSBzaG91bGQgdXNlIHBhcmVudGhlc2VzIGZvciBuZWdhdGl2ZSBudW1iZXIgb3IgaWYgd2Ugc2hvdWxkIHByZWZpeCB3aXRoIGEgc2lnblxuICAgICAgICAgICAgLy8gaWYgYm90aCBhcmUgcHJlc2VudCB3ZSBkZWZhdWx0IHRvIHBhcmVudGhlc2VzXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJygnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbmVnUCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJysnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFwrL2csICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VlIGlmIGFiYnJldmlhdGlvbiBpcyB3YW50ZWRcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignYScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBhYmJyZXZpYXRpb24gaXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgYWJicksgPSBmb3JtYXQuaW5kZXhPZignYUsnKSA+PSAwO1xuICAgICAgICAgICAgICAgIGFiYnJNID0gZm9ybWF0LmluZGV4T2YoJ2FNJykgPj0gMDtcbiAgICAgICAgICAgICAgICBhYmJyQiA9IGZvcm1hdC5pbmRleE9mKCdhQicpID49IDA7XG4gICAgICAgICAgICAgICAgYWJiclQgPSBmb3JtYXQuaW5kZXhPZignYVQnKSA+PSAwO1xuICAgICAgICAgICAgICAgIGFiYnJGb3JjZSA9IGFiYnJLIHx8IGFiYnJNIHx8IGFiYnJCIHx8IGFiYnJUO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSBhYmJyZXZpYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyBhJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhYmJyID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnIGEnLCAnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ2EnLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFicyA+PSBNYXRoLnBvdygxMCwgMTIpICYmICFhYmJyRm9yY2UgfHwgYWJiclQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRyaWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDEyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCAxMikgJiYgYWJzID49IE1hdGgucG93KDEwLCA5KSAmJiAhYWJickZvcmNlIHx8IGFiYnJCKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLmJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgOSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPCBNYXRoLnBvdygxMCwgOSkgJiYgYWJzID49IE1hdGgucG93KDEwLCA2KSAmJiAhYWJickZvcmNlIHx8IGFiYnJNKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1pbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLm1pbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgNik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPCBNYXRoLnBvdygxMCwgNikgJiYgYWJzID49IE1hdGgucG93KDEwLCAzKSAmJiAhYWJickZvcmNlIHx8IGFiYnJLKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRob3VzYW5kXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSBhYmJyICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy50aG91c2FuZDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCAzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiB3ZSBhcmUgZm9ybWF0dGluZyBieXRlc1xuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdiJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyBiJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcyA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyBiJywgJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdiJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAocG93ZXIgPSAwOyBwb3dlciA8PSBzdWZmaXhlcy5sZW5ndGg7IHBvd2VyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gTWF0aC5wb3coMTAyNCwgcG93ZXIpO1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBNYXRoLnBvdygxMDI0LCBwb3dlcisxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gbWluICYmIHZhbHVlIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlcyA9IGJ5dGVzICsgc3VmZml4ZXNbcG93ZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiBvcmRpbmFsIGlzIHdhbnRlZFxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdvJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyBvJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBvcmQgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgbycsICcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnbycsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcmQgPSBvcmQgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5vcmRpbmFsKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdbLl0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0RGVjID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnWy5dJywgJy4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdyA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IGZvcm1hdC5zcGxpdCgnLicpWzFdO1xuICAgICAgICAgICAgdGhvdXNhbmRzID0gZm9ybWF0LmluZGV4T2YoJywnKTtcblxuICAgICAgICAgICAgaWYgKHByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChwcmVjaXNpb24uaW5kZXhPZignWycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uLnJlcGxhY2UoJ10nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbi5zcGxpdCgnWycpO1xuICAgICAgICAgICAgICAgICAgICBkID0gdG9GaXhlZCh2YWx1ZSwgKHByZWNpc2lvblswXS5sZW5ndGggKyBwcmVjaXNpb25bMV0ubGVuZ3RoKSwgcm91bmRpbmdGdW5jdGlvbiwgcHJlY2lzaW9uWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IHRvRml4ZWQodmFsdWUsIHByZWNpc2lvbi5sZW5ndGgsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHcgPSBkLnNwbGl0KCcuJylbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZC5zcGxpdCgnLicpWzFdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uZGVsaW1pdGVycy5kZWNpbWFsICsgZC5zcGxpdCgnLicpWzFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0RGVjICYmIE51bWJlcihkLnNsaWNlKDEpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ID0gdG9GaXhlZCh2YWx1ZSwgbnVsbCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvcm1hdCBudW1iZXJcbiAgICAgICAgICAgIGlmICh3LmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdyA9IHcuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbmVnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRob3VzYW5kcyA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdyA9IHcudG9TdHJpbmcoKS5yZXBsYWNlKC8oXFxkKSg/PShcXGR7M30pKyg/IVxcZCkpL2csICckMScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLnRob3VzYW5kcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignLicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdyA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKChuZWdQICYmIG5lZykgPyAnKCcgOiAnJykgKyAoKCFuZWdQICYmIG5lZykgPyAnLScgOiAnJykgKyAoKCFuZWcgJiYgc2lnbmVkKSA/ICcrJyA6ICcnKSArIHcgKyBkICsgKChvcmQpID8gb3JkIDogJycpICsgKChhYmJyKSA/IGFiYnIgOiAnJykgKyAoKGJ5dGVzKSA/IGJ5dGVzIDogJycpICsgKChuZWdQICYmIG5lZykgPyAnKScgOiAnJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIFRvcCBMZXZlbCBGdW5jdGlvbnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBudW1lcmFsID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlmIChudW1lcmFsLmlzTnVtZXJhbChpbnB1dCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gMCB8fCB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoIU51bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gbnVtZXJhbC5mbi51bmZvcm1hdChpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE51bWVyYWwoTnVtYmVyKGlucHV0KSk7XG4gICAgfTtcblxuICAgIC8vIHZlcnNpb24gbnVtYmVyXG4gICAgbnVtZXJhbC52ZXJzaW9uID0gVkVSU0lPTjtcblxuICAgIC8vIGNvbXBhcmUgbnVtZXJhbCBvYmplY3RcbiAgICBudW1lcmFsLmlzTnVtZXJhbCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE51bWVyYWw7XG4gICAgfTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxhbmd1YWdlcyBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsYW5ndWFnZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsYW5ndWFnZSBrZXkuXG4gICAgbnVtZXJhbC5sYW5ndWFnZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlcykge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRMYW5ndWFnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgJiYgIXZhbHVlcykge1xuICAgICAgICAgICAgaWYoIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxhbmd1YWdlIDogJyArIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50TGFuZ3VhZ2UgPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzIHx8ICFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgbG9hZExhbmd1YWdlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1lcmFsO1xuICAgIH07XG4gICAgXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGxvYWRlZCBsYW5ndWFnZSBkYXRhLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50XG4gICAgLy8gZ2xvYmFsIGxhbmd1YWdlIG9iamVjdC5cbiAgICBudW1lcmFsLmxhbmd1YWdlRGF0YSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxhbmd1YWdlIDogJyArIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBsYW5ndWFnZXNba2V5XTtcbiAgICB9O1xuXG4gICAgbnVtZXJhbC5sYW5ndWFnZSgnZW4nLCB7XG4gICAgICAgIGRlbGltaXRlcnM6IHtcbiAgICAgICAgICAgIHRob3VzYW5kczogJywnLFxuICAgICAgICAgICAgZGVjaW1hbDogJy4nXG4gICAgICAgIH0sXG4gICAgICAgIGFiYnJldmlhdGlvbnM6IHtcbiAgICAgICAgICAgIHRob3VzYW5kOiAnaycsXG4gICAgICAgICAgICBtaWxsaW9uOiAnbScsXG4gICAgICAgICAgICBiaWxsaW9uOiAnYicsXG4gICAgICAgICAgICB0cmlsbGlvbjogJ3QnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTA7XG4gICAgICAgICAgICByZXR1cm4gKH5+IChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbmN5OiB7XG4gICAgICAgICAgICBzeW1ib2w6ICckJ1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBudW1lcmFsLnplcm9Gb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHplcm9Gb3JtYXQgPSB0eXBlb2YoZm9ybWF0KSA9PT0gJ3N0cmluZycgPyBmb3JtYXQgOiBudWxsO1xuICAgIH07XG5cbiAgICBudW1lcmFsLmRlZmF1bHRGb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIGRlZmF1bHRGb3JtYXQgPSB0eXBlb2YoZm9ybWF0KSA9PT0gJ3N0cmluZycgPyBmb3JtYXQgOiAnMC4wJztcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBIZWxwZXJzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gbG9hZExhbmd1YWdlKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIGxhbmd1YWdlc1trZXldID0gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRmxvYXRpbmctcG9pbnQgaGVscGVyc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8vIFRoZSBmbG9hdGluZy1wb2ludCBoZWxwZXIgZnVuY3Rpb25zIGFuZCBpbXBsZW1lbnRhdGlvblxuICAgIC8vIGJvcnJvd3MgaGVhdmlseSBmcm9tIHNpbmZ1bC5qczogaHR0cDovL2d1aXBuLmdpdGh1Yi5pby9zaW5mdWwuanMvXG5cbiAgICAvKipcbiAgICAgKiBBcnJheS5wcm90b3R5cGUucmVkdWNlIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXRcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9SZWR1Y2UjQ29tcGF0aWJpbGl0eVxuICAgICAqL1xuICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgQXJyYXkucHJvdG90eXBlLnJlZHVjZSkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRfaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChudWxsID09PSB0aGlzIHx8ICd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcykge1xuICAgICAgICAgICAgICAgIC8vIEF0IHRoZSBtb21lbnQgYWxsIG1vZGVybiBicm93c2VycywgdGhhdCBzdXBwb3J0IHN0cmljdCBtb2RlLCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuIEZvciBpbnN0YW5jZSwgSUU4XG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3Qgc3VwcG9ydCBzdHJpY3QgbW9kZSwgc28gdGhpcyBjaGVjayBpcyBhY3R1YWxseSB1c2VsZXNzLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5yZWR1Y2UgY2FsbGVkIG9uIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgICAgICAgaXNWYWx1ZVNldCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoMSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9wdF9pbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgaXNWYWx1ZVNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBsZW5ndGggPiBpbmRleDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZVNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgdGhpc1tpbmRleF0sIGluZGV4LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbHVlU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc1ZhbHVlU2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG11bHRpcGxpZXIgbmVjZXNzYXJ5IHRvIG1ha2UgeCA+PSAxLFxuICAgICAqIGVmZmVjdGl2ZWx5IGVsaW1pbmF0aW5nIG1pc2NhbGN1bGF0aW9ucyBjYXVzZWQgYnlcbiAgICAgKiBmaW5pdGUgcHJlY2lzaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bHRpcGxpZXIoeCkge1xuICAgICAgICB2YXIgcGFydHMgPSB4LnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygxMCwgcGFydHNbMV0ubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMsIHJldHVybnMgdGhlIG1heGltdW1cbiAgICAgKiBtdWx0aXBsaWVyIHRoYXQgbXVzdCBiZSB1c2VkIHRvIG5vcm1hbGl6ZSBhbiBvcGVyYXRpb24gaW52b2x2aW5nXG4gICAgICogYWxsIG9mIHRoZW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29ycmVjdGlvbkZhY3RvcigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gYXJncy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgICAgICAgICAgIHZhciBtcCA9IG11bHRpcGxpZXIocHJldiksXG4gICAgICAgICAgICAgICAgbW4gPSBtdWx0aXBsaWVyKG5leHQpO1xuICAgICAgICByZXR1cm4gbXAgPiBtbiA/IG1wIDogbW47XG4gICAgICAgIH0sIC1JbmZpbml0eSk7XG4gICAgfSAgICAgICAgXG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgTnVtZXJhbCBQcm90b3R5cGVcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIG51bWVyYWwuZm4gPSBOdW1lcmFsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjbG9uZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1lcmFsKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdCA6IGZ1bmN0aW9uIChpbnB1dFN0cmluZywgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWVyYWwodGhpcywgXG4gICAgICAgICAgICAgICAgICBpbnB1dFN0cmluZyA/IGlucHV0U3RyaW5nIDogZGVmYXVsdEZvcm1hdCwgXG4gICAgICAgICAgICAgICAgICAocm91bmRpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSA/IHJvdW5kaW5nRnVuY3Rpb24gOiBNYXRoLnJvdW5kXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5mb3JtYXQgOiBmdW5jdGlvbiAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXRTdHJpbmcpID09PSAnW29iamVjdCBOdW1iZXJdJykgeyBcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXRTdHJpbmc7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZm9ybWF0TnVtZXJhbCh0aGlzLCBpbnB1dFN0cmluZyA/IGlucHV0U3RyaW5nIDogZGVmYXVsdEZvcm1hdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWVPZiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZCA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBjb3JyZWN0aW9uRmFjdG9yLmNhbGwobnVsbCwgdGhpcy5fdmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSArIGNvcnJGYWN0b3IgKiBjdXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBbdGhpcy5fdmFsdWUsIHZhbHVlXS5yZWR1Y2UoY2JhY2ssIDApIC8gY29yckZhY3RvcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1YnRyYWN0IDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IGNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtIC0gY29yckZhY3RvciAqIGN1cnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt2YWx1ZV0ucmVkdWNlKGNiYWNrLCB0aGlzLl92YWx1ZSAqIGNvcnJGYWN0b3IpIC8gY29yckZhY3RvcjsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIG11bHRpcGx5IDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IGNvcnJlY3Rpb25GYWN0b3IoYWNjdW0sIGN1cnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoYWNjdW0gKiBjb3JyRmFjdG9yKSAqIChjdXJyICogY29yckZhY3RvcikgL1xuICAgICAgICAgICAgICAgICAgICAoY29yckZhY3RvciAqIGNvcnJGYWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBbdGhpcy5fdmFsdWUsIHZhbHVlXS5yZWR1Y2UoY2JhY2ssIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGl2aWRlIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IGNvcnJlY3Rpb25GYWN0b3IoYWNjdW0sIGN1cnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoYWNjdW0gKiBjb3JyRmFjdG9yKSAvIChjdXJyICogY29yckZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt0aGlzLl92YWx1ZSwgdmFsdWVdLnJlZHVjZShjYmFjayk7ICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaWZmZXJlbmNlIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobnVtZXJhbCh0aGlzLl92YWx1ZSkuc3VidHJhY3QodmFsdWUpLnZhbHVlKCkpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBFeHBvc2luZyBOdW1lcmFsXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gQ29tbW9uSlMgbW9kdWxlIGlzIGRlZmluZWRcbiAgICBpZiAoaGFzTW9kdWxlKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbnVtZXJhbDtcbiAgICB9XG5cbiAgICAvKmdsb2JhbCBlbmRlcjpmYWxzZSAqL1xuICAgIGlmICh0eXBlb2YgZW5kZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIGhlcmUsIGB0aGlzYCBtZWFucyBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGdsb2JhbGAgb24gdGhlIHNlcnZlclxuICAgICAgICAvLyBhZGQgYG51bWVyYWxgIGFzIGEgZ2xvYmFsIG9iamVjdCB2aWEgYSBzdHJpbmcgaWRlbnRpZmllcixcbiAgICAgICAgLy8gZm9yIENsb3N1cmUgQ29tcGlsZXIgJ2FkdmFuY2VkJyBtb2RlXG4gICAgICAgIHRoaXNbJ251bWVyYWwnXSA9IG51bWVyYWw7XG4gICAgfVxuXG4gICAgLypnbG9iYWwgZGVmaW5lOmZhbHNlICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1lcmFsO1xuICAgICAgICB9KTtcbiAgICB9XG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cbnZhciBudiA9IHdpbmRvdy5udiB8fCB7fTtcblxuXG5udi52ZXJzaW9uID0gJzEuMS4xNWInO1xubnYuZGV2ID0gdHJ1ZSAvL3NldCBmYWxzZSB3aGVuIGluIHByb2R1Y3Rpb25cblxud2luZG93Lm52ID0gbnY7XG5cbm52LnRvb2x0aXAgPSBudi50b29sdGlwIHx8IHt9OyAvLyBGb3IgdGhlIHRvb2x0aXAgc3lzdGVtXG5udi51dGlscyA9IG52LnV0aWxzIHx8IHt9OyAvLyBVdGlsaXR5IHN1YnN5c3RlbVxubnYubW9kZWxzID0gbnYubW9kZWxzIHx8IHt9OyAvL3N0b3JlcyBhbGwgdGhlIHBvc3NpYmxlIG1vZGVscy9jb21wb25lbnRzXG5udi5jaGFydHMgPSB7fTsgLy9zdG9yZXMgYWxsIHRoZSByZWFkeSB0byB1c2UgY2hhcnRzXG5udi5ncmFwaHMgPSBbXTsgLy9zdG9yZXMgYWxsIHRoZSBncmFwaHMgY3VycmVudGx5IG9uIHRoZSBwYWdlXG5udi5sb2dzID0ge307IC8vc3RvcmVzIHNvbWUgc3RhdGlzdGljcyBhbmQgcG90ZW50aWFsIGVycm9yIG1lc3NhZ2VzXG5cbm52LmRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3JlbmRlcl9zdGFydCcsICdyZW5kZXJfZW5kJyk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICBEZXZlbG9wbWVudCByZW5kZXIgdGltZXJzIC0gZGlzYWJsZWQgaWYgZGV2ID0gZmFsc2VcblxuaWYgKG52LmRldikge1xuICBudi5kaXNwYXRjaC5vbigncmVuZGVyX3N0YXJ0JywgZnVuY3Rpb24oZSkge1xuICAgIG52LmxvZ3Muc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG4gIH0pO1xuXG4gIG52LmRpc3BhdGNoLm9uKCdyZW5kZXJfZW5kJywgZnVuY3Rpb24oZSkge1xuICAgIG52LmxvZ3MuZW5kVGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgIG52LmxvZ3MudG90YWxUaW1lID0gbnYubG9ncy5lbmRUaW1lIC0gbnYubG9ncy5zdGFydFRpbWU7XG4gICAgbnYubG9nKCd0b3RhbCcsIG52LmxvZ3MudG90YWxUaW1lKTsgLy8gdXNlZCBmb3IgZGV2ZWxvcG1lbnQsIHRvIGtlZXAgdHJhY2sgb2YgZ3JhcGggZ2VuZXJhdGlvbiB0aW1lc1xuICB9KTtcbn1cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICBQdWJsaWMgQ29yZSBOViBmdW5jdGlvbnNcblxuLy8gTG9ncyBhbGwgYXJndW1lbnRzLCBhbmQgcmV0dXJucyB0aGUgbGFzdCBzbyB5b3UgY2FuIHRlc3QgdGhpbmdzIGluIHBsYWNlXG4vLyBOb3RlOiBpbiBJRTggY29uc29sZS5sb2cgaXMgYW4gb2JqZWN0IG5vdCBhIGZ1bmN0aW9uLCBhbmQgaWYgbW9kZXJuaXpyIGlzIHVzZWRcbi8vIHRoZW4gY2FsbGluZyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB3aXRoIHdpdGggYW55dGhpbmcgb3RoZXIgdGhhbiBhIGZ1bmN0aW9uXG4vLyBjYXVzZXMgYSBUeXBlRXJyb3IgdG8gYmUgdGhyb3duLlxubnYubG9nID0gZnVuY3Rpb24oKSB7XG4gIGlmIChudi5kZXYgJiYgY29uc29sZS5sb2cgJiYgY29uc29sZS5sb2cuYXBwbHkpXG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICBlbHNlIGlmIChudi5kZXYgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09IFwiZnVuY3Rpb25cIiAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICAgIHZhciBsb2cgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbiAgICBsb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfVxuICByZXR1cm4gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbn07XG5cblxubnYucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHN0ZXApIHtcbiAgc3RlcCA9IHN0ZXAgfHwgMTsgLy8gbnVtYmVyIG9mIGdyYXBocyB0byBnZW5lcmF0ZSBpbiBlYWNoIHRpbWVvdXQgbG9vcFxuXG4gIG52LnJlbmRlci5hY3RpdmUgPSB0cnVlO1xuICBudi5kaXNwYXRjaC5yZW5kZXJfc3RhcnQoKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaGFydCwgZ3JhcGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXAgJiYgKGdyYXBoID0gbnYucmVuZGVyLnF1ZXVlW2ldKTsgaSsrKSB7XG4gICAgICBjaGFydCA9IGdyYXBoLmdlbmVyYXRlKCk7XG4gICAgICBpZiAodHlwZW9mIGdyYXBoLmNhbGxiYWNrID09IHR5cGVvZihGdW5jdGlvbikpIGdyYXBoLmNhbGxiYWNrKGNoYXJ0KTtcbiAgICAgIG52LmdyYXBocy5wdXNoKGNoYXJ0KTtcbiAgICB9XG5cbiAgICBudi5yZW5kZXIucXVldWUuc3BsaWNlKDAsIGkpO1xuXG4gICAgaWYgKG52LnJlbmRlci5xdWV1ZS5sZW5ndGgpIHNldFRpbWVvdXQoYXJndW1lbnRzLmNhbGxlZSwgMCk7XG4gICAgZWxzZSB7XG4gICAgICBudi5kaXNwYXRjaC5yZW5kZXJfZW5kKCk7XG4gICAgICBudi5yZW5kZXIuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9LCAwKTtcbn07XG5cbm52LnJlbmRlci5hY3RpdmUgPSBmYWxzZTtcbm52LnJlbmRlci5xdWV1ZSA9IFtdO1xuXG5udi5hZGRHcmFwaCA9IGZ1bmN0aW9uKG9iaikge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gdHlwZW9mKEZ1bmN0aW9uKSlcbiAgICBvYmogPSB7Z2VuZXJhdGU6IGFyZ3VtZW50c1swXSwgY2FsbGJhY2s6IGFyZ3VtZW50c1sxXX07XG5cbiAgbnYucmVuZGVyLnF1ZXVlLnB1c2gob2JqKTtcblxuICBpZiAoIW52LnJlbmRlci5hY3RpdmUpIG52LnJlbmRlcigpO1xufTtcblxubnYuaWRlbnRpdHkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9O1xuXG5udi5zdHJpcCA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvKFxcc3wmKS9nLCcnKTsgfTtcblxuZnVuY3Rpb24gZGF5c0luTW9udGgobW9udGgseWVhcikge1xuICByZXR1cm4gKG5ldyBEYXRlKHllYXIsIG1vbnRoKzEsIDApKS5nZXREYXRlKCk7XG59XG5cbmZ1bmN0aW9uIGQzX3RpbWVfcmFuZ2UoZmxvb3IsIHN0ZXAsIG51bWJlcikge1xuICByZXR1cm4gZnVuY3Rpb24odDAsIHQxLCBkdCkge1xuICAgIHZhciB0aW1lID0gZmxvb3IodDApLCB0aW1lcyA9IFtdO1xuICAgIGlmICh0aW1lIDwgdDApIHN0ZXAodGltZSk7XG4gICAgaWYgKGR0ID4gMSkge1xuICAgICAgd2hpbGUgKHRpbWUgPCB0MSkge1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCt0aW1lKTtcbiAgICAgICAgaWYgKChudW1iZXIoZGF0ZSkgJSBkdCA9PT0gMCkpIHRpbWVzLnB1c2goZGF0ZSk7XG4gICAgICAgIHN0ZXAodGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICh0aW1lIDwgdDEpIHsgdGltZXMucHVzaChuZXcgRGF0ZSgrdGltZSkpOyBzdGVwKHRpbWUpOyB9XG4gICAgfVxuICAgIHJldHVybiB0aW1lcztcbiAgfTtcbn1cblxuZDMudGltZS5tb250aEVuZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCAwKTtcbn07XG5cbmQzLnRpbWUubW9udGhFbmRzID0gZDNfdGltZV9yYW5nZShkMy50aW1lLm1vbnRoRW5kLCBmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgMSk7XG4gICAgZGF0ZS5zZXREYXRlKGRheXNJbk1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIDEsIGRhdGUuZ2V0RnVsbFllYXIoKSkpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcbiAgfVxuKTtcblxuLyogVXRpbGl0eSBjbGFzcyB0byBoYW5kbGUgY3JlYXRpb24gb2YgYW4gaW50ZXJhY3RpdmUgbGF5ZXIuXG5UaGlzIHBsYWNlcyBhIHJlY3RhbmdsZSBvbiB0b3Agb2YgdGhlIGNoYXJ0LiBXaGVuIHlvdSBtb3VzZSBtb3ZlIG92ZXIgaXQsIGl0IHNlbmRzIGEgZGlzcGF0Y2hcbmNvbnRhaW5pbmcgdGhlIFgtY29vcmRpbmF0ZS4gSXQgY2FuIGFsc28gcmVuZGVyIGEgdmVydGljYWwgbGluZSB3aGVyZSB0aGUgbW91c2UgaXMgbG9jYXRlZC5cblxuZGlzcGF0Y2guZWxlbWVudE1vdXNlbW92ZSBpcyB0aGUgaW1wb3J0YW50IGV2ZW50IHRvIGxhdGNoIG9udG8uICBJdCBpcyBmaXJlZCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgb3ZlclxudGhlIHJlY3RhbmdsZS4gVGhlIGRpc3BhdGNoIGlzIGdpdmVuIG9uZSBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIG1vdXNlWC9ZIGxvY2F0aW9uLlxuSXQgYWxzbyBoYXMgJ3BvaW50WFZhbHVlJywgd2hpY2ggaXMgdGhlIGNvbnZlcnNpb24gb2YgbW91c2VYIHRvIHRoZSB4LWF4aXMgc2NhbGUuXG4qL1xubnYuaW50ZXJhY3RpdmVHdWlkZWxpbmUgPSBmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciB0b29sdGlwID0gbnYubW9kZWxzLnRvb2x0aXAoKTtcblx0Ly9QdWJsaWMgc2V0dGluZ3Ncblx0dmFyIHdpZHRoID0gbnVsbFxuXHQsIGhlaWdodCA9IG51bGxcbiAgICAvL1BsZWFzZSBwYXNzIGluIHRoZSBib3VuZGluZyBjaGFydCdzIHRvcCBhbmQgbGVmdCBtYXJnaW5zXG4gICAgLy9UaGlzIGlzIGltcG9ydGFudCBmb3IgY2FsY3VsYXRpbmcgdGhlIGNvcnJlY3QgbW91c2VYL1kgcG9zaXRpb25zLlxuXHQsIG1hcmdpbiA9IHtsZWZ0OiAwLCB0b3A6IDB9XG5cdCwgeFNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcblx0LCB5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuXHQsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2VsZW1lbnRNb3VzZW1vdmUnLCAnZWxlbWVudE1vdXNlb3V0JywnZWxlbWVudERibGNsaWNrJylcblx0LCBzaG93R3VpZGVMaW5lID0gdHJ1ZVxuXHQsIHN2Z0NvbnRhaW5lciA9IG51bGwgIFxuICAgIC8vTXVzdCBwYXNzIGluIHRoZSBib3VuZGluZyBjaGFydCdzIDxzdmc+IGNvbnRhaW5lci5cbiAgICAvL1RoZSBtb3VzZW1vdmUgZXZlbnQgaXMgYXR0YWNoZWQgdG8gdGhpcyBjb250YWluZXIuXG5cdDtcblxuXHQvL1ByaXZhdGUgdmFyaWFibGVzXG5cdHZhciBpc01TSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpICE9PSAtMSAgLy9DaGVjayB1c2VyLWFnZW50IGZvciBNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXIuXG5cdDtcblxuXG5cdGZ1bmN0aW9uIGxheWVyKHNlbGVjdGlvbikge1xuXHRcdHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0dmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCB8fCA5NjApLCBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IDQwMCk7XG5cblx0XHRcdFx0dmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKFwiZy5udi13cmFwLm52LWludGVyYWN0aXZlTGluZUxheWVyXCIpLmRhdGEoW2RhdGFdKTtcblx0XHRcdFx0dmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcIiBudi13cmFwIG52LWludGVyYWN0aXZlTGluZUxheWVyXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0d3JhcEVudGVyLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsXCJudi1pbnRlcmFjdGl2ZUd1aWRlTGluZVwiKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghc3ZnQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBtb3VzZUhhbmRsZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGQzbW91c2UgPSBkMy5tb3VzZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VYID0gZDNtb3VzZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VZID0gZDNtb3VzZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VidHJhY3RNYXJnaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZU91dEFueVJlYXNvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc01TSUUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEQzLmpzIChvciBtYXliZSBTVkcuZ2V0U2NyZWVuQ1RNKSBoYXMgYSBuYXN0eSBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMubW91c2UoKSByZXR1cm5zIGluY29ycmVjdCBYLFkgbW91c2UgY29vcmRpbmF0ZXMgd2hlbiBtb3VzZSBtb3ZpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyIGEgcmVjdCBpbiBJRSAxMC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIb3dldmVyLCBkMy5ldmVudC5vZmZzZXRYL1kgYWxzbyByZXR1cm5zIHRoZSBtb3VzZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlIHRvIHRoZSB0cmlnZ2VyaW5nIDxyZWN0Pi4gU28gd2UgdXNlIG9mZnNldFgvWSBvbiBJRS4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VYID0gZDMuZXZlbnQub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZVkgPSBkMy5ldmVudC5vZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbiBJRSwgaWYgeW91IGF0dGFjaCBhIG1vdXNlIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSA8c3ZnPiBjb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCBhY3R1YWxseSB0cmlnZ2VyIGl0IGZvciBhbGwgdGhlIGNoaWxkIGVsZW1lbnRzIChsaWtlIDxwYXRoPiwgPGNpcmNsZT4sIGV0YykuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiB0aGlzIGhhcHBlbnMgb24gSUUsIHRoZSBvZmZzZXRYL1kgaXMgc2V0IHRvIHdoZXJlIGV2ZXIgdGhlIGNoaWxkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBsb2NhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFzIGEgcmVzdWx0LCB3ZSBkbyBOT1QgbmVlZCB0byBzdWJ0cmFjdCBtYXJnaW5zIHRvIGZpZ3VyZSBvdXQgdGhlIG1vdXNlIFgvWVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIHVuZGVyIHRoaXMgc2NlbmFyaW8uIFJlbW92aW5nIHRoZSBsaW5lIGJlbG93ICp3aWxsKiBjYXVzZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgaW50ZXJhY3RpdmUgbGF5ZXIgdG8gbm90IHdvcmsgcmlnaHQgb24gSUUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICBpZihkMy5ldmVudC50YXJnZXQudGFnTmFtZSAhPT0gXCJzdmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdE1hcmdpbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQzLmV2ZW50LnRhcmdldC5jbGFzc05hbWUuYmFzZVZhbC5tYXRjaChcIm52LWxlZ2VuZFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICBcdG1vdXNlT3V0QW55UmVhc29uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYoc3VidHJhY3RNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZVggLT0gbWFyZ2luLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VZIC09IG1hcmdpbi50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgLyogSWYgbW91c2VYL1kgaXMgb3V0c2lkZSBvZiB0aGUgY2hhcnQncyBib3VuZHMsXG4gICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlciBhIG1vdXNlT3V0IGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1vdXNlWCA8IDAgfHwgbW91c2VZIDwgMCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IG1vdXNlWCA+IGF2YWlsYWJsZVdpZHRoIHx8IG1vdXNlWSA+IGF2YWlsYWJsZUhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGQzLmV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgZDMuZXZlbnQucmVsYXRlZFRhcmdldC5vd25lclNWR0VsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IG1vdXNlT3V0QW55UmVhc29uXG4gICAgICAgICAgICAgICAgICAgICAgICApIFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBcdFx0aWYgKGlzTVNJRSkge1xuICAgICAgICAgICAgICAgICAgICAgIFx0XHRcdGlmIChkMy5ldmVudC5yZWxhdGVkVGFyZ2V0IFxuICAgICAgICAgICAgICAgICAgICAgIFx0XHRcdFx0JiYgZDMuZXZlbnQucmVsYXRlZFRhcmdldC5vd25lclNWR0VsZW1lbnQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgIFx0XHRcdFx0JiYgZDMuZXZlbnQucmVsYXRlZFRhcmdldC5jbGFzc05hbWUubWF0Y2godG9vbHRpcC5udlBvaW50ZXJFdmVudHNDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBcdFx0XHRcdHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICBcdFx0XHR9XG4gICAgICAgICAgICAgICAgICAgICAgXHRcdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlWDogbW91c2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlWTogbW91c2VZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIucmVuZGVyR3VpZGVMaW5lKG51bGwpOyAvL2hpZGUgdGhlIGd1aWRlbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50WFZhbHVlID0geFNjYWxlLmludmVydChtb3VzZVgpO1xuICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW1vdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlWDogbW91c2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlWTogbW91c2VZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50WFZhbHVlOiBwb2ludFhWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy9JZiB1c2VyIGRvdWJsZSBjbGlja3MgdGhlIGxheWVyLCBmaXJlIGEgZWxlbWVudERibGNsaWNrIGRpc3BhdGNoLlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChkMy5ldmVudC50eXBlID09PSBcImRibGNsaWNrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnREYmxjbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VYOiBtb3VzZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VZOiBtb3VzZVksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRYVmFsdWU6IHBvaW50WFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG5cdFx0XHRcdHN2Z0NvbnRhaW5lclxuXHRcdFx0XHQgICAgICAub24oXCJtb3VzZW1vdmVcIixtb3VzZUhhbmRsZXIsIHRydWUpXG5cdFx0XHRcdCAgICAgIC5vbihcIm1vdXNlb3V0XCIgLG1vdXNlSGFuZGxlcix0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgIC5vbihcImRibGNsaWNrXCIgLG1vdXNlSGFuZGxlcilcblx0XHRcdFx0ICAgICAgO1xuXG5cdFx0XHRcdCAvL0RyYXdzIGEgdmVydGljYWwgZ3VpZGVsaW5lIGF0IHRoZSBnaXZlbiBYIHBvc3Rpb24uXG5cdFx0XHRcdGxheWVyLnJlbmRlckd1aWRlTGluZSA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdFx0IFx0aWYgKCFzaG93R3VpZGVMaW5lKSByZXR1cm47XG5cdFx0XHRcdCBcdHZhciBsaW5lID0gd3JhcC5zZWxlY3QoXCIubnYtaW50ZXJhY3RpdmVHdWlkZUxpbmVcIilcblx0XHRcdFx0IFx0ICAgICAgLnNlbGVjdEFsbChcImxpbmVcIilcblx0XHRcdFx0IFx0ICAgICAgLmRhdGEoKHggIT0gbnVsbCkgPyBbbnYudXRpbHMuTmFOdG9aZXJvKHgpXSA6IFtdLCBTdHJpbmcpO1xuXG5cdFx0XHRcdCBcdGxpbmUuZW50ZXIoKVxuXHRcdFx0XHQgXHRcdC5hcHBlbmQoXCJsaW5lXCIpXG5cdFx0XHRcdCBcdFx0LmF0dHIoXCJjbGFzc1wiLCBcIm52LWd1aWRlbGluZVwiKVxuXHRcdFx0XHQgXHRcdC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDt9KVxuXHRcdFx0XHQgXHRcdC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDt9KVxuXHRcdFx0XHQgXHRcdC5hdHRyKFwieTFcIiwgYXZhaWxhYmxlSGVpZ2h0KVxuXHRcdFx0XHQgXHRcdC5hdHRyKFwieTJcIiwwKVxuXHRcdFx0XHQgXHRcdDtcblx0XHRcdFx0IFx0bGluZS5leGl0KCkucmVtb3ZlKCk7XG5cblx0XHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0bGF5ZXIuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcblx0bGF5ZXIudG9vbHRpcCA9IHRvb2x0aXA7XG5cblx0bGF5ZXIubWFyZ2luID0gZnVuY3Rpb24oXykge1xuXHQgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFyZ2luO1xuXHQgICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcblx0ICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuXHQgICAgcmV0dXJuIGxheWVyO1xuICAgIH07XG5cblx0bGF5ZXIud2lkdGggPSBmdW5jdGlvbihfKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XG5cdFx0d2lkdGggPSBfO1xuXHRcdHJldHVybiBsYXllcjtcblx0fTtcblxuXHRsYXllci5oZWlnaHQgPSBmdW5jdGlvbihfKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xuXHRcdGhlaWdodCA9IF87XG5cdFx0cmV0dXJuIGxheWVyO1xuXHR9O1xuXG5cdGxheWVyLnhTY2FsZSA9IGZ1bmN0aW9uKF8pIHtcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4U2NhbGU7XG5cdFx0eFNjYWxlID0gXztcblx0XHRyZXR1cm4gbGF5ZXI7XG5cdH07XG5cblx0bGF5ZXIuc2hvd0d1aWRlTGluZSA9IGZ1bmN0aW9uKF8pIHtcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93R3VpZGVMaW5lO1xuXHRcdHNob3dHdWlkZUxpbmUgPSBfO1xuXHRcdHJldHVybiBsYXllcjtcblx0fTtcblxuXHRsYXllci5zdmdDb250YWluZXIgPSBmdW5jdGlvbihfKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3ZnQ29udGFpbmVyO1xuXHRcdHN2Z0NvbnRhaW5lciA9IF87XG5cdFx0cmV0dXJuIGxheWVyO1xuXHR9O1xuXG5cblx0cmV0dXJuIGxheWVyO1xufTtcblxuLyogVXRpbGl0eSBjbGFzcyB0aGF0IHVzZXMgZDMuYmlzZWN0IHRvIGZpbmQgdGhlIGluZGV4IGluIGEgZ2l2ZW4gYXJyYXksIHdoZXJlIGEgc2VhcmNoIHZhbHVlIGNhbiBiZSBpbnNlcnRlZC5cblRoaXMgaXMgZGlmZmVyZW50IGZyb20gbm9ybWFsIGJpc2VjdExlZnQ7IHRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIG5lYXJlc3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBzZWFyY2ggdmFsdWUuXG5cbkZvciBpbnN0YW5jZSwgbGV0cyBzYXkgeW91ciBhcnJheSBpcyBbMSwyLDMsNSwxMCwzMF0sIGFuZCB5b3Ugc2VhcmNoIGZvciAyOC4gXG5Ob3JtYWwgZDMuYmlzZWN0TGVmdCB3aWxsIHJldHVybiA0LCBiZWNhdXNlIDI4IGlzIGluc2VydGVkIGFmdGVyIHRoZSBudW1iZXIgMTAuICBCdXQgaW50ZXJhY3RpdmVCaXNlY3Qgd2lsbCByZXR1cm4gNVxuYmVjYXVzZSAyOCBpcyBjbG9zZXIgdG8gMzAgdGhhbiAxMC5cblxuVW5pdCB0ZXN0cyBjYW4gYmUgZm91bmQgaW46IGludGVyYWN0aXZlQmlzZWN0VGVzdC5odG1sXG5cbkhhcyB0aGUgZm9sbG93aW5nIGtub3duIGlzc3VlczpcbiAgICogV2lsbCBub3Qgd29yayBpZiB0aGUgZGF0YSBwb2ludHMgbW92ZSBiYWNrd2FyZHMgKGllLCAxMCw5LDgsNywgZXRjKSBvciBpZiB0aGUgZGF0YSBwb2ludHMgYXJlIGluIHJhbmRvbSBvcmRlci5cbiAgICogV29uJ3Qgd29yayBpZiB0aGVyZSBhcmUgZHVwbGljYXRlIHggY29vcmRpbmF0ZSB2YWx1ZXMuXG4qL1xubnYuaW50ZXJhY3RpdmVCaXNlY3QgPSBmdW5jdGlvbiAodmFsdWVzLCBzZWFyY2hWYWwsIHhBY2Nlc3Nvcikge1xuXHQgIFwidXNlIHN0cmljdFwiO1xuICAgICAgaWYgKCEgdmFsdWVzIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiB4QWNjZXNzb3IgIT09ICdmdW5jdGlvbicpIHhBY2Nlc3NvciA9IGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZC54O31cblxuICAgICAgdmFyIGJpc2VjdCA9IGQzLmJpc2VjdG9yKHhBY2Nlc3NvcikubGVmdDtcbiAgICAgIHZhciBpbmRleCA9IGQzLm1heChbMCwgYmlzZWN0KHZhbHVlcyxzZWFyY2hWYWwpIC0gMV0pO1xuICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHhBY2Nlc3Nvcih2YWx1ZXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIGN1cnJlbnRWYWx1ZSA9IGluZGV4O1xuXG4gICAgICBpZiAoY3VycmVudFZhbHVlID09PSBzZWFyY2hWYWwpIHJldHVybiBpbmRleDsgIC8vZm91bmQgZXhhY3QgbWF0Y2hcblxuICAgICAgdmFyIG5leHRJbmRleCA9IGQzLm1pbihbaW5kZXgrMSwgdmFsdWVzLmxlbmd0aCAtIDFdKTtcbiAgICAgIHZhciBuZXh0VmFsdWUgPSB4QWNjZXNzb3IodmFsdWVzW25leHRJbmRleF0sIG5leHRJbmRleCk7XG4gICAgICBpZiAodHlwZW9mIG5leHRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIG5leHRWYWx1ZSA9IG5leHRJbmRleDtcblxuICAgICAgaWYgKE1hdGguYWJzKG5leHRWYWx1ZSAtIHNlYXJjaFZhbCkgPj0gTWF0aC5hYnMoY3VycmVudFZhbHVlIC0gc2VhcmNoVmFsKSlcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIG5leHRJbmRleFxufTtcblxuLypcblJldHVybnMgdGhlIGluZGV4IGluIHRoZSBhcnJheSBcInZhbHVlc1wiIHRoYXQgaXMgY2xvc2VzdCB0byBzZWFyY2hWYWwuXG5Pbmx5IHJldHVybnMgYW4gaW5kZXggaWYgc2VhcmNoVmFsIGlzIHdpdGhpbiBzb21lIFwidGhyZXNob2xkXCIuXG5PdGhlcndpc2UsIHJldHVybnMgbnVsbC5cbiovXG5udi5uZWFyZXN0VmFsdWVJbmRleCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNlYXJjaFZhbCwgdGhyZXNob2xkKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIHZhciB5RGlzdE1heCA9IEluZmluaXR5LCBpbmRleFRvSGlnaGxpZ2h0ID0gbnVsbDtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5hYnMoc2VhcmNoVmFsIC0gZCk7XG4gICAgICAgICBpZiAoIGRlbHRhIDw9IHlEaXN0TWF4ICYmIGRlbHRhIDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICB5RGlzdE1heCA9IGRlbHRhO1xuICAgICAgICAgICAgaW5kZXhUb0hpZ2hsaWdodCA9IGk7XG4gICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbmRleFRvSGlnaGxpZ2h0O1xufTsvKiBUb29sdGlwIHJlbmRlcmluZyBtb2RlbCBmb3IgbnZkMyBjaGFydHMuXG53aW5kb3cubnYubW9kZWxzLnRvb2x0aXAgaXMgdGhlIHVwZGF0ZWQsbmV3IHdheSB0byByZW5kZXIgdG9vbHRpcHMuXG5cbndpbmRvdy5udi50b29sdGlwLnNob3cgaXMgdGhlIG9sZCB0b29sdGlwIGNvZGUuXG53aW5kb3cubnYudG9vbHRpcC4qIGFsc28gaGFzIHZhcmlvdXMgaGVscGVyIG1ldGhvZHMuXG4qL1xuKGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgd2luZG93Lm52LnRvb2x0aXAgPSB7fTtcblxuICAvKiBNb2RlbCB3aGljaCBjYW4gYmUgaW5zdGFudGlhdGVkIHRvIGhhbmRsZSB0b29sdGlwIHJlbmRlcmluZy5cbiAgICBFeGFtcGxlIHVzYWdlOiBcbiAgICB2YXIgdGlwID0gbnYubW9kZWxzLnRvb2x0aXAoKS5ncmF2aXR5KCd3JykuZGlzdGFuY2UoMjMpXG4gICAgICAgICAgICAgICAgLmRhdGEobXlEYXRhT2JqZWN0KTtcblxuICAgICAgICB0aXAoKTsgICAgLy9qdXN0IGludm9rZSB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gdG8gcmVuZGVyIHRvb2x0aXAuXG4gICovXG4gIHdpbmRvdy5udi5tb2RlbHMudG9vbHRpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29udGVudCA9IG51bGwgICAgLy9IVE1MIGNvbnRlbnRzIG9mIHRoZSB0b29sdGlwLiAgSWYgbnVsbCwgdGhlIGNvbnRlbnQgaXMgZ2VuZXJhdGVkIHZpYSB0aGUgZGF0YSB2YXJpYWJsZS5cbiAgICAgICAgLCAgIGRhdGEgPSBudWxsICAgICAvKiBUb29sdGlwIGRhdGEuIElmIGRhdGEgaXMgZ2l2ZW4gaW4gdGhlIHByb3BlciBmb3JtYXQsIGEgY29uc2lzdGVudCB0b29sdGlwIGlzIGdlbmVyYXRlZC5cbiAgICAgICAgRm9ybWF0IG9mIGRhdGE6XG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJEYXRlXCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJBdWd1c3QgMjAwOVwiLCBcbiAgICAgICAgICAgIHNlcmllczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiU2VyaWVzIDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlZhbHVlIDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIiMwMDBcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiU2VyaWVzIDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlZhbHVlIDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIiMwMGZcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG5cbiAgICAgICAgfVxuXG4gICAgICAgICovXG4gICAgICAgICwgICBncmF2aXR5ID0gJ3cnICAgLy9DYW4gYmUgJ24nLCdzJywnZScsJ3cnLiBEZXRlcm1pbmVzIGhvdyB0b29sdGlwIGlzIHBvc2l0aW9uZWQuXG4gICAgICAgICwgICBkaXN0YW5jZSA9IDUwICAgLy9EaXN0YW5jZSB0byBvZmZzZXQgdG9vbHRpcCBmcm9tIHRoZSBtb3VzZSBsb2NhdGlvbi5cbiAgICAgICAgLCAgIHNuYXBEaXN0YW5jZSA9IDI1ICAgLy9Ub2xlcmFuY2UgYWxsb3dlZCBiZWZvcmUgdG9vbHRpcCBpcyBtb3ZlZCBmcm9tIGl0cyBjdXJyZW50IHBvc2l0aW9uIChjcmVhdGVzICdzbmFwcGluZycgZWZmZWN0KVxuICAgICAgICAsICAgZml4ZWRUb3AgPSBudWxsIC8vSWYgbm90IG51bGwsIHRoaXMgZml4ZXMgdGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcC5cbiAgICAgICAgLCAgIGNsYXNzZXMgPSBudWxsICAvL0F0dGFjaGVzIGFkZGl0aW9uYWwgQ1NTIGNsYXNzZXMgdG8gdGhlIHRvb2x0aXAgRElWIHRoYXQgaXMgY3JlYXRlZC5cbiAgICAgICAgLCAgIGNoYXJ0Q29udGFpbmVyID0gbnVsbCAgIC8vUGFyZW50IERJViwgb2YgdGhlIFNWRyBDb250YWluZXIgdGhhdCBob2xkcyB0aGUgY2hhcnQuXG4gICAgICAgICwgICB0b29sdGlwRWxlbSA9IG51bGwgIC8vYWN0dWFsIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgdG9vbHRpcC5cbiAgICAgICAgLCAgIHBvc2l0aW9uID0ge2xlZnQ6IG51bGwsIHRvcDogbnVsbH0gICAgICAvL1JlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwIGluc2lkZSBjaGFydENvbnRhaW5lci5cbiAgICAgICAgLCAgIGVuYWJsZWQgPSB0cnVlICAvL1RydWUgLT4gdG9vbHRpcHMgYXJlIHJlbmRlcmVkLiBGYWxzZSAtPiBkb24ndCByZW5kZXIgdG9vbHRpcHMuXG4gICAgICAgIC8vR2VuZXJhdGVzIGEgdW5pcXVlIGlkIHdoZW4geW91IGNyZWF0ZSBhIG5ldyB0b29sdGlwKCkgb2JqZWN0XG4gICAgICAgICwgICBpZCA9IFwibnZ0b29sdGlwLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwKVxuICAgICAgICA7XG5cbiAgICAgICAgLy9DU1MgY2xhc3MgdG8gc3BlY2lmeSB3aGV0aGVyIGVsZW1lbnQgc2hvdWxkIG5vdCBoYXZlIG1vdXNlIGV2ZW50cy5cbiAgICAgICAgdmFyICBudlBvaW50ZXJFdmVudHNDbGFzcyA9IFwibnYtcG9pbnRlci1ldmVudHMtbm9uZVwiO1xuXG4gICAgICAgIC8vRm9ybWF0IGZ1bmN0aW9uIGZvciB0aGUgdG9vbHRpcCB2YWx1ZXMgY29sdW1uXG4gICAgICAgIHZhciB2YWx1ZUZvcm1hdHRlciA9IGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9Gb3JtYXQgZnVuY3Rpb24gZm9yIHRoZSB0b29sdGlwIGhlYWRlciB2YWx1ZS5cbiAgICAgICAgdmFyIGhlYWRlckZvcm1hdHRlciA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vQnkgZGVmYXVsdCwgdGhlIHRvb2x0aXAgbW9kZWwgcmVuZGVycyBhIGJlYXV0aWZ1bCB0YWJsZSBpbnNpZGUgYSBESVYuXG4gICAgICAgIC8vWW91IGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGlmIGEgY3VzdG9tIHRvb2x0aXAgaXMgZGVzaXJlZC5cbiAgICAgICAgdmFyIGNvbnRlbnRHZW5lcmF0b3IgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSByZXR1cm4gY29udGVudDtcblxuICAgICAgICAgICAgaWYgKGQgPT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgICAgICAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRhYmxlXCIpKTtcbiAgICAgICAgICAgIHZhciB0aGVhZEVudGVyID0gdGFibGUuc2VsZWN0QWxsKFwidGhlYWRcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbZF0pXG4gICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidGhlYWRcIik7XG4gICAgICAgICAgICB0aGVhZEVudGVyLmFwcGVuZChcInRyXCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInRkXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjb2xzcGFuXCIsMylcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwic3Ryb25nXCIpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKFwieC12YWx1ZVwiLHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5odG1sKGhlYWRlckZvcm1hdHRlcihkLnZhbHVlKSk7XG5cbiAgICAgICAgICAgIHZhciB0Ym9keUVudGVyID0gdGFibGUuc2VsZWN0QWxsKFwidGJvZHlcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbZF0pXG4gICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidGJvZHlcIik7XG4gICAgICAgICAgICB2YXIgdHJvd0VudGVyID0gdGJvZHlFbnRlci5zZWxlY3RBbGwoXCJ0clwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAuc2VyaWVzfSlcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0clwiKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKFwiaGlnaGxpZ2h0XCIsIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAuaGlnaGxpZ2h0fSlcbiAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIHRyb3dFbnRlci5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKFwibGVnZW5kLWNvbG9yLWd1aWRlXCIsdHJ1ZSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgZnVuY3Rpb24ocCkgeyByZXR1cm4gcC5jb2xvcn0pO1xuICAgICAgICAgICAgdHJvd0VudGVyLmFwcGVuZChcInRkXCIpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoXCJrZXlcIix0cnVlKVxuICAgICAgICAgICAgICAgIC5odG1sKGZ1bmN0aW9uKHApIHtyZXR1cm4gcC5rZXl9KTtcbiAgICAgICAgICAgIHRyb3dFbnRlci5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKFwidmFsdWVcIix0cnVlKVxuICAgICAgICAgICAgICAgIC5odG1sKGZ1bmN0aW9uKHAsaSkgeyByZXR1cm4gdmFsdWVGb3JtYXR0ZXIocC52YWx1ZSxpKSB9KTtcblxuXG4gICAgICAgICAgICB0cm93RW50ZXIuc2VsZWN0QWxsKFwidGRcIikuZWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAuaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oWzAsMV0pLnJhbmdlKFtcIiNmZmZcIixwLmNvbG9yXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gMC42O1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImJvcmRlci1ib3R0b20tY29sb3JcIiwgb3BhY2l0eVNjYWxlKG9wYWNpdHkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiYm9yZGVyLXRvcC1jb2xvclwiLCBvcGFjaXR5U2NhbGUob3BhY2l0eSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBodG1sID0gdGFibGUubm9kZSgpLm91dGVySFRNTDtcbiAgICAgICAgICAgIGlmIChkLmZvb3RlciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGh0bWwgKz0gXCI8ZGl2IGNsYXNzPSdmb290ZXInPlwiICsgZC5mb290ZXIgKyBcIjwvZGl2PlwiO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGF0YVNlcmllc0V4aXN0cyA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGlmIChkICYmIGQuc2VyaWVzICYmIGQuc2VyaWVzLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9JbiBzaXR1YXRpb25zIHdoZXJlIHRoZSBjaGFydCBpcyBpbiBhICd2aWV3Qm94JywgcmUtcG9zaXRpb24gdGhlIHRvb2x0aXAgYmFzZWQgb24gaG93IGZhciBjaGFydCBpcyB6b29tZWQuXG4gICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRWaWV3Qm94UmF0aW8oKSB7XG4gICAgICAgICAgICBpZiAoY2hhcnRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHN2ZyA9IGQzLnNlbGVjdChjaGFydENvbnRhaW5lcik7XG4gICAgICAgICAgICAgIGlmIChzdmcubm9kZSgpLnRhZ05hbWUgIT09IFwic3ZnXCIpIHtcbiAgICAgICAgICAgICAgICAgc3ZnID0gc3ZnLnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgdmlld0JveCA9IChzdmcubm9kZSgpKSA/IHN2Zy5hdHRyKCd2aWV3Qm94JykgOiBudWxsO1xuICAgICAgICAgICAgICBpZiAodmlld0JveCkge1xuICAgICAgICAgICAgICAgIHZpZXdCb3ggPSB2aWV3Qm94LnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gcGFyc2VJbnQoc3ZnLnN0eWxlKCd3aWR0aCcpKSAvIHZpZXdCb3hbMl07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcG9zaXRpb24ubGVmdCA9IHBvc2l0aW9uLmxlZnQgKiByYXRpbztcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi50b3AgID0gcG9zaXRpb24udG9wICogcmF0aW87XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vQ3JlYXRlcyBuZXcgdG9vbHRpcCBjb250YWluZXIsIG9yIHVzZXMgZXhpc3Rpbmcgb25lIG9uIERPTS5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VG9vbHRpcENvbnRhaW5lcihuZXdDb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgYm9keTtcbiAgICAgICAgICAgIGlmIChjaGFydENvbnRhaW5lcilcbiAgICAgICAgICAgICAgICBib2R5ID0gZDMuc2VsZWN0KGNoYXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBib2R5ID0gZDMuc2VsZWN0KFwiYm9keVwiKTtcblxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGJvZHkuc2VsZWN0KFwiLm52dG9vbHRpcFwiKTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIubm9kZSgpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy9DcmVhdGUgbmV3IHRvb2x0aXAgZGl2IGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb24gRE9NLlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGJvZHkuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJudnRvb2x0aXAgXCIgKyAoY2xhc3Nlcz8gY2xhc3NlczogXCJ4eS10b29sdGlwXCIpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsaWQpXG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5ub2RlKCkuaW5uZXJIVE1MID0gbmV3Q29udGVudDtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZShcInRvcFwiLDApLnN0eWxlKFwibGVmdFwiLDApLnN0eWxlKFwib3BhY2l0eVwiLDApO1xuICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbChcImRpdiwgdGFibGUsIHRkLCB0clwiKS5jbGFzc2VkKG52UG9pbnRlckV2ZW50c0NsYXNzLHRydWUpXG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NlZChudlBvaW50ZXJFdmVudHNDbGFzcyx0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXIubm9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgXG5cbiAgICAgICAgLy9EcmF3IHRoZSB0b29sdGlwIG9udG8gdGhlIERPTS5cbiAgICAgICAgZnVuY3Rpb24gbnZ0b29sdGlwKCkge1xuICAgICAgICAgICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWRhdGFTZXJpZXNFeGlzdHMoZGF0YSkpIHJldHVybjtcblxuICAgICAgICAgICAgY29udmVydFZpZXdCb3hSYXRpbygpO1xuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICB2YXIgdG9wID0gKGZpeGVkVG9wICE9IG51bGwpID8gZml4ZWRUb3AgOiBwb3NpdGlvbi50b3A7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZ2V0VG9vbHRpcENvbnRhaW5lcihjb250ZW50R2VuZXJhdG9yKGRhdGEpKTtcbiAgICAgICAgICAgIHRvb2x0aXBFbGVtID0gY29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKGNoYXJ0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN2Z0NvbXAgPSBjaGFydENvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRSZWN0ID0gKHN2Z0NvbXApID8gc3ZnQ29tcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IGNoYXJ0Q29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdmdPZmZzZXQgPSB7bGVmdDowLHRvcDowfTtcbiAgICAgICAgICAgICAgICBpZiAoc3ZnQ29tcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ZnQm91bmQgPSBzdmdDb21wLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcnRCb3VuZCA9IGNoYXJ0Q29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ZnQm91bmRUb3AgPSBzdmdCb3VuZC50b3A7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL0RlZmVuc2l2ZSBjb2RlLiBTb21ldGltZXMsIHN2Z0JvdW5kVG9wIGNhbiBiZSBhIHJlYWxseSBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgICAgICAvLyAgbnVtYmVyLCBsaWtlIC0xMzQyNTQuIFRoYXQncyBhIGJ1Zy4gXG4gICAgICAgICAgICAgICAgICAgIC8vICBJZiBzdWNoIGEgbnVtYmVyIGlzIGZvdW5kLCB1c2UgemVybyBpbnN0ZWFkLiBGaXJlRm94IGJ1ZyBvbmx5XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdmdCb3VuZFRvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJCb3VuZCA9IGNoYXJ0Q29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnQm91bmRUb3AgPSAoTWF0aC5hYnMoc3ZnQm91bmRUb3ApID4gY29udGFpbmVyQm91bmQuaGVpZ2h0KSA/IDAgOiBzdmdCb3VuZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgc3ZnT2Zmc2V0LnRvcCA9IE1hdGguYWJzKHN2Z0JvdW5kVG9wIC0gY2hhcnRCb3VuZC50b3ApO1xuICAgICAgICAgICAgICAgICAgICBzdmdPZmZzZXQubGVmdCA9IE1hdGguYWJzKHN2Z0JvdW5kLmxlZnQgLSBjaGFydEJvdW5kLmxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL0lmIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGFuIG92ZXJmbG93IDxkaXY+IHdpdGggc2Nyb2xsYmFycywgc3VidHJhY3QgdGhlIHNjcm9sbCBvZmZzZXRzLlxuICAgICAgICAgICAgICAgIC8vWW91IG5lZWQgdG8gYWxzbyBhZGQgYW55IG9mZnNldCBiZXR3ZWVuIHRoZSA8c3ZnPiBlbGVtZW50IGFuZCBpdHMgY29udGFpbmluZyA8ZGl2PlxuICAgICAgICAgICAgICAgIC8vRmluYWxseSwgYWRkIGFueSBvZmZzZXQgb2YgdGhlIGNvbnRhaW5pbmcgPGRpdj4gb24gdGhlIHdob2xlIHBhZ2UuXG4gICAgICAgICAgICAgICAgbGVmdCArPSBjaGFydENvbnRhaW5lci5vZmZzZXRMZWZ0ICsgc3ZnT2Zmc2V0LmxlZnQgLSAyKmNoYXJ0Q29udGFpbmVyLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgdG9wICs9IGNoYXJ0Q29udGFpbmVyLm9mZnNldFRvcCArIHN2Z09mZnNldC50b3AgLSAyKmNoYXJ0Q29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNuYXBEaXN0YW5jZSAmJiBzbmFwRGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5mbG9vcih0b3Avc25hcERpc3RhbmNlKSAqIHNuYXBEaXN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbnYudG9vbHRpcC5jYWxjVG9vbHRpcFBvc2l0aW9uKFtsZWZ0LHRvcF0sIGdyYXZpdHksIGRpc3RhbmNlLCBjb250YWluZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAubnZQb2ludGVyRXZlbnRzQ2xhc3MgPSBudlBvaW50ZXJFdmVudHNDbGFzcztcbiAgICAgICAgXG4gICAgICAgIG52dG9vbHRpcC5jb250ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBfO1xuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1JldHVybnMgdG9vbHRpcEVsZW0uLi5ub3QgYWJsZSB0byBzZXQgaXQuXG4gICAgICAgIG52dG9vbHRpcC50b29sdGlwRWxlbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvb2x0aXBFbGVtO1xuICAgICAgICB9O1xuXG4gICAgICAgIG52dG9vbHRpcC5jb250ZW50R2VuZXJhdG9yID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29udGVudEdlbmVyYXRvcjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRHZW5lcmF0b3IgPSBfO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAuZGF0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gXztcbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgbnZ0b29sdGlwLmdyYXZpdHkgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF2aXR5O1xuICAgICAgICAgICAgZ3Jhdml0eSA9IF87XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG52dG9vbHRpcC5kaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRpc3RhbmNlO1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBfO1xuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAuc25hcERpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc25hcERpc3RhbmNlO1xuICAgICAgICAgICAgc25hcERpc3RhbmNlID0gXztcbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgbnZ0b29sdGlwLmNsYXNzZXMgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGFzc2VzO1xuICAgICAgICAgICAgY2xhc3NlcyA9IF87XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG52dG9vbHRpcC5jaGFydENvbnRhaW5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNoYXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgY2hhcnRDb250YWluZXIgPSBfO1xuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAucG9zaXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlZnQgPSAodHlwZW9mIF8ubGVmdCAhPT0gJ3VuZGVmaW5lZCcpID8gXy5sZWZ0IDogcG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgIHBvc2l0aW9uLnRvcCA9ICh0eXBlb2YgXy50b3AgIT09ICd1bmRlZmluZWQnKSA/IF8udG9wIDogcG9zaXRpb24udG9wO1xuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAuZml4ZWRUb3AgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmaXhlZFRvcDtcbiAgICAgICAgICAgIGZpeGVkVG9wID0gXztcbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgbnZ0b29sdGlwLmVuYWJsZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBlbmFibGVkO1xuICAgICAgICAgICAgZW5hYmxlZCA9IF87XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG52dG9vbHRpcC52YWx1ZUZvcm1hdHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlRm9ybWF0dGVyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVGb3JtYXR0ZXIgPSBfO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAuaGVhZGVyRm9ybWF0dGVyID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVhZGVyRm9ybWF0dGVyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyRm9ybWF0dGVyID0gXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9pZCgpIGlzIGEgcmVhZC1vbmx5IGZ1bmN0aW9uLiBZb3UgY2FuJ3QgdXNlIGl0IHRvIHNldCB0aGUgaWQuXG4gICAgICAgIG52dG9vbHRpcC5pZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgfTtcblxuXG4gIC8vT3JpZ2luYWwgdG9vbHRpcC5zaG93IGZ1bmN0aW9uLiBLZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAvLyBwb3MgPSBbbGVmdCx0b3BdXG4gIG52LnRvb2x0aXAuc2hvdyA9IGZ1bmN0aW9uKHBvcywgY29udGVudCwgZ3Jhdml0eSwgZGlzdCwgcGFyZW50Q29udGFpbmVyLCBjbGFzc2VzKSB7XG4gICAgICBcbiAgICAgICAgLy9DcmVhdGUgbmV3IHRvb2x0aXAgZGl2IGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb24gRE9NLlxuICAgICAgICB2YXIgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9ICdudnRvb2x0aXAgJyArIChjbGFzc2VzID8gY2xhc3NlcyA6ICd4eS10b29sdGlwJyk7XG5cbiAgICAgICAgdmFyIGJvZHkgPSBwYXJlbnRDb250YWluZXI7XG4gICAgICAgIGlmICggIXBhcmVudENvbnRhaW5lciB8fCBwYXJlbnRDb250YWluZXIudGFnTmFtZS5tYXRjaCgvZ3xzdmcvaSkpIHtcbiAgICAgICAgICAgIC8vSWYgdGhlIHBhcmVudCBlbGVtZW50IGlzIGFuIFNWRyBlbGVtZW50LCBwbGFjZSB0b29sdGlwIGluIHRoZSA8Ym9keT4gZWxlbWVudC5cbiAgICAgICAgICAgIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xuICAgICAgICB9XG4gICBcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICBjb250YWluZXIuc3R5bGUudG9wID0gMDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICBcbiAgICAgICAgLy9JZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBhbiBvdmVyZmxvdyA8ZGl2PiB3aXRoIHNjcm9sbGJhcnMsIHN1YnRyYWN0IHRoZSBzY3JvbGwgb2Zmc2V0cy5cbiAgICAgICAgaWYgKHBhcmVudENvbnRhaW5lcikge1xuICAgICAgICAgICBwb3NbMF0gPSBwb3NbMF0gLSBwYXJlbnRDb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgcG9zWzFdID0gcG9zWzFdIC0gcGFyZW50Q29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICBudi50b29sdGlwLmNhbGNUb29sdGlwUG9zaXRpb24ocG9zLCBncmF2aXR5LCBkaXN0LCBjb250YWluZXIpO1xuICB9O1xuXG4gIC8vTG9va3MgdXAgdGhlIGFuY2VzdHJ5IG9mIGEgRE9NIGVsZW1lbnQsIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBOT04tc3ZnIG5vZGUuXG4gIG52LnRvb2x0aXAuZmluZEZpcnN0Tm9uU1ZHUGFyZW50ID0gZnVuY3Rpb24oRWxlbSkge1xuICAgICAgICAgICAgd2hpbGUoRWxlbS50YWdOYW1lLm1hdGNoKC9eZ3xzdmckL2kpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgRWxlbSA9IEVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBFbGVtO1xuICB9O1xuXG4gIC8vRmluZHMgdGhlIHRvdGFsIG9mZnNldFRvcCBvZiBhIGdpdmVuIERPTSBlbGVtZW50LlxuICAvL0xvb2tzIHVwIHRoZSBlbnRpcmUgYW5jZXN0cnkgb2YgYW4gZWxlbWVudCwgdXAgdG8gdGhlIGZpcnN0IHJlbGF0aXZlbHkgcG9zaXRpb25lZCBlbGVtZW50LlxuICBudi50b29sdGlwLmZpbmRUb3RhbE9mZnNldFRvcCA9IGZ1bmN0aW9uICggRWxlbSwgaW5pdGlhbFRvcCApIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0VG9wID0gaW5pdGlhbFRvcDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCAhaXNOYU4oIEVsZW0ub2Zmc2V0VG9wICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3AgKz0gKEVsZW0ub2Zmc2V0VG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUoIEVsZW0gPSBFbGVtLm9mZnNldFBhcmVudCApO1xuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXRUb3A7XG4gIH07XG5cbiAgLy9GaW5kcyB0aGUgdG90YWwgb2Zmc2V0TGVmdCBvZiBhIGdpdmVuIERPTSBlbGVtZW50LlxuICAvL0xvb2tzIHVwIHRoZSBlbnRpcmUgYW5jZXN0cnkgb2YgYW4gZWxlbWVudCwgdXAgdG8gdGhlIGZpcnN0IHJlbGF0aXZlbHkgcG9zaXRpb25lZCBlbGVtZW50LlxuICBudi50b29sdGlwLmZpbmRUb3RhbE9mZnNldExlZnQgPSBmdW5jdGlvbiAoIEVsZW0sIGluaXRpYWxMZWZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldExlZnQgPSBpbml0aWFsTGVmdDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCAhaXNOYU4oIEVsZW0ub2Zmc2V0TGVmdCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCArPSAoRWxlbS5vZmZzZXRMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUoIEVsZW0gPSBFbGVtLm9mZnNldFBhcmVudCApO1xuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXRMZWZ0O1xuICB9O1xuXG4gIC8vR2xvYmFsIHV0aWxpdHkgZnVuY3Rpb24gdG8gcmVuZGVyIGEgdG9vbHRpcCBvbiB0aGUgRE9NLlxuICAvL3BvcyA9IFtsZWZ0LHRvcF0gY29vcmRpbmF0ZXMgb2Ygd2hlcmUgdG8gcGxhY2UgdGhlIHRvb2x0aXAsIHJlbGF0aXZlIHRvIHRoZSBTVkcgY2hhcnQgY29udGFpbmVyLlxuICAvL2dyYXZpdHkgPSBob3cgdG8gb3JpZW50IHRoZSB0b29sdGlwXG4gIC8vZGlzdCA9IGhvdyBmYXIgYXdheSBmcm9tIHRoZSBtb3VzZSB0byBwbGFjZSB0b29sdGlwXG4gIC8vY29udGFpbmVyID0gdG9vbHRpcCBESVZcbiAgbnYudG9vbHRpcC5jYWxjVG9vbHRpcFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zLCBncmF2aXR5LCBkaXN0LCBjb250YWluZXIpIHtcblxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlSW50KGNvbnRhaW5lci5vZmZzZXRIZWlnaHQpLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQoY29udGFpbmVyLm9mZnNldFdpZHRoKSxcbiAgICAgICAgICAgICAgICB3aW5kb3dXaWR0aCA9IG52LnV0aWxzLndpbmRvd1NpemUoKS53aWR0aCxcbiAgICAgICAgICAgICAgICB3aW5kb3dIZWlnaHQgPSBudi51dGlscy53aW5kb3dTaXplKCkuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGxlZnQsIHRvcDtcblxuICAgICAgICAgICAgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggPj0gZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aCA/IHdpbmRvd0hlaWdodCA6IHdpbmRvd0hlaWdodCAtIDE2O1xuICAgICAgICAgICAgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJIZWlnaHQgPj0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgPyB3aW5kb3dXaWR0aCA6IHdpbmRvd1dpZHRoIC0gMTY7XG5cbiAgICAgICAgICAgIGdyYXZpdHkgPSBncmF2aXR5IHx8ICdzJztcbiAgICAgICAgICAgIGRpc3QgPSBkaXN0IHx8IDIwO1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcFRvcCA9IGZ1bmN0aW9uICggRWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnYudG9vbHRpcC5maW5kVG90YWxPZmZzZXRUb3AoRWxlbSwgdG9wKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0b29sdGlwTGVmdCA9IGZ1bmN0aW9uICggRWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnYudG9vbHRpcC5maW5kVG90YWxPZmZzZXRMZWZ0KEVsZW0sbGVmdCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGdyYXZpdHkpIHtcbiAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IHBvc1swXSAtIHdpZHRoIC0gZGlzdDtcbiAgICAgICAgICAgICAgICB0b3AgPSBwb3NbMV0gLSAoaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIHRMZWZ0ID0gdG9vbHRpcExlZnQoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgdFRvcCA9IHRvb2x0aXBUb3AoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBpZiAodExlZnQgPCBzY3JvbGxMZWZ0KSBsZWZ0ID0gcG9zWzBdICsgZGlzdCA+IHNjcm9sbExlZnQgPyBwb3NbMF0gKyBkaXN0IDogc2Nyb2xsTGVmdCAtIHRMZWZ0ICsgbGVmdDtcbiAgICAgICAgICAgICAgICBpZiAodFRvcCA8IHNjcm9sbFRvcCkgdG9wID0gc2Nyb2xsVG9wIC0gdFRvcCArIHRvcDtcbiAgICAgICAgICAgICAgICBpZiAodFRvcCArIGhlaWdodCA+IHNjcm9sbFRvcCArIHdpbmRvd0hlaWdodCkgdG9wID0gc2Nyb2xsVG9wICsgd2luZG93SGVpZ2h0IC0gdFRvcCArIHRvcCAtIGhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IHBvc1swXSArIGRpc3Q7XG4gICAgICAgICAgICAgICAgdG9wID0gcG9zWzFdIC0gKGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciB0TGVmdCA9IHRvb2x0aXBMZWZ0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIHRUb3AgPSB0b29sdGlwVG9wKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgaWYgKHRMZWZ0ICsgd2lkdGggPiB3aW5kb3dXaWR0aCkgbGVmdCA9IHBvc1swXSAtIHdpZHRoIC0gZGlzdDtcbiAgICAgICAgICAgICAgICBpZiAodFRvcCA8IHNjcm9sbFRvcCkgdG9wID0gc2Nyb2xsVG9wICsgNTtcbiAgICAgICAgICAgICAgICBpZiAodFRvcCArIGhlaWdodCA+IHNjcm9sbFRvcCArIHdpbmRvd0hlaWdodCkgdG9wID0gc2Nyb2xsVG9wICsgd2luZG93SGVpZ2h0IC0gdFRvcCArIHRvcCAtIGhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgbGVmdCA9IHBvc1swXSAtICh3aWR0aCAvIDIpIC0gNTtcbiAgICAgICAgICAgICAgICB0b3AgPSBwb3NbMV0gKyBkaXN0O1xuICAgICAgICAgICAgICAgIHZhciB0TGVmdCA9IHRvb2x0aXBMZWZ0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIHRUb3AgPSB0b29sdGlwVG9wKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgaWYgKHRMZWZ0IDwgc2Nyb2xsTGVmdCkgbGVmdCA9IHNjcm9sbExlZnQgKyA1O1xuICAgICAgICAgICAgICAgIGlmICh0TGVmdCArIHdpZHRoID4gd2luZG93V2lkdGgpIGxlZnQgPSBsZWZ0IC0gd2lkdGgvMiArIDU7XG4gICAgICAgICAgICAgICAgaWYgKHRUb3AgKyBoZWlnaHQgPiBzY3JvbGxUb3AgKyB3aW5kb3dIZWlnaHQpIHRvcCA9IHNjcm9sbFRvcCArIHdpbmRvd0hlaWdodCAtIHRUb3AgKyB0b3AgLSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgIGxlZnQgPSBwb3NbMF0gLSAod2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICB0b3AgPSBwb3NbMV0gLSBoZWlnaHQgLSBkaXN0O1xuICAgICAgICAgICAgICAgIHZhciB0TGVmdCA9IHRvb2x0aXBMZWZ0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIHRUb3AgPSB0b29sdGlwVG9wKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgaWYgKHRMZWZ0IDwgc2Nyb2xsTGVmdCkgbGVmdCA9IHNjcm9sbExlZnQgKyA1O1xuICAgICAgICAgICAgICAgIGlmICh0TGVmdCArIHdpZHRoID4gd2luZG93V2lkdGgpIGxlZnQgPSBsZWZ0IC0gd2lkdGgvMiArIDU7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRvcCA+IHRUb3ApIHRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IHBvc1swXTtcbiAgICAgICAgICAgICAgICB0b3AgPSBwb3NbMV0gLSBkaXN0O1xuICAgICAgICAgICAgICAgIHZhciB0TGVmdCA9IHRvb2x0aXBMZWZ0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIHRUb3AgPSB0b29sdGlwVG9wKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0KydweCc7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUudG9wID0gdG9wKydweCc7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnOyBcblxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuXG4gICAgLy9HbG9iYWwgdXRpbGl0eSBmdW5jdGlvbiB0byByZW1vdmUgdG9vbHRpcHMgZnJvbSB0aGUgRE9NLlxuICAgIG52LnRvb2x0aXAuY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRvb2x0aXBzLCBtYXJrIHRoZW0gZm9yIHJlbW92YWwgYnkgdGhpcyBjbGFzcyAoc28gb3RoZXJzIGNsZWFudXBzIHdvbid0IGZpbmQgaXQpXG4gICAgICAgICAgICAgIHZhciB0b29sdGlwcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ252dG9vbHRpcCcpO1xuICAgICAgICAgICAgICB2YXIgcHVyZ2luZyA9IFtdO1xuICAgICAgICAgICAgICB3aGlsZSh0b29sdGlwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwdXJnaW5nLnB1c2godG9vbHRpcHNbMF0pO1xuICAgICAgICAgICAgICAgIHRvb2x0aXBzWzBdLnN0eWxlLnRyYW5zaXRpb25EZWxheSA9ICcwICFpbXBvcnRhbnQnO1xuICAgICAgICAgICAgICAgIHRvb2x0aXBzWzBdLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgICAgIHRvb2x0aXBzWzBdLmNsYXNzTmFtZSA9ICdudnRvb2x0aXAtcGVuZGluZy1yZW1vdmFsJztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChwdXJnaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZU1lID0gcHVyZ2luZy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZW1vdmVNZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJlbW92ZU1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgfTtcblxufSkoKTtcblxubnYudXRpbHMud2luZG93U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFNhbmUgZGVmYXVsdHNcbiAgICB2YXIgc2l6ZSA9IHt3aWR0aDogNjQwLCBoZWlnaHQ6IDQ4MH07XG5cbiAgICAvLyBFYXJsaWVyIElFIHVzZXMgRG9jLmJvZHlcbiAgICBpZiAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoKSB7XG4gICAgICAgIHNpemUud2lkdGggPSBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xuICAgICAgICBzaXplLmhlaWdodCA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIElFIGNhbiB1c2UgZGVwZW5kaW5nIG9uIG1vZGUgaXQgaXMgaW5cbiAgICBpZiAoZG9jdW1lbnQuY29tcGF0TW9kZT09J0NTUzFDb21wYXQnICYmXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGggKSB7XG4gICAgICAgIHNpemUud2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIHNpemUuaGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBNb3N0IHJlY2VudCBicm93c2VycyB1c2VcbiAgICBpZiAod2luZG93LmlubmVyV2lkdGggJiYgd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgIHNpemUud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgc2l6ZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiAoc2l6ZSk7XG59O1xuXG5cblxuLy8gRWFzeSB3YXkgdG8gYmluZCBtdWx0aXBsZSBmdW5jdGlvbnMgdG8gd2luZG93Lm9ucmVzaXplXG4vLyBUT0RPOiBnaXZlIGEgd2F5IHRvIHJlbW92ZSBhIGZ1bmN0aW9uIGFmdGVyIGl0cyBib3VuZCwgb3RoZXIgdGhhbiByZW1vdmluZyBhbGwgb2YgdGhlbVxubnYudXRpbHMud2luZG93UmVzaXplID0gZnVuY3Rpb24oZnVuKXtcbiAgaWYgKGZ1biA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIHZhciBvbGRyZXNpemUgPSB3aW5kb3cub25yZXNpemU7XG5cbiAgd2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24oZSkge1xuICAgIGlmICh0eXBlb2Ygb2xkcmVzaXplID09ICdmdW5jdGlvbicpIG9sZHJlc2l6ZShlKTtcbiAgICBmdW4oZSk7XG4gIH1cbn1cblxuLy8gQmFja3dhcmRzIGNvbXBhdGlibGUgd2F5IHRvIGltcGxlbWVudCBtb3JlIGQzLWxpa2UgY29sb3Jpbmcgb2YgZ3JhcGhzLlxuLy8gSWYgcGFzc2VkIGFuIGFycmF5LCB3cmFwIGl0IGluIGEgZnVuY3Rpb24gd2hpY2ggaW1wbGVtZW50cyB0aGUgb2xkIGRlZmF1bHRcbi8vIGJlaGF2aW9yXG5udi51dGlscy5nZXRDb2xvciA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbnYudXRpbHMuZGVmYXVsdENvbG9yKCk7IC8vaWYgeW91IHBhc3MgaW4gbm90aGluZywgZ2V0IGRlZmF1bHQgY29sb3JzIGJhY2tcblxuICAgIGlmKCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIGNvbG9yICkgPT09ICdbb2JqZWN0IEFycmF5XScgKVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gZC5jb2xvciB8fCBjb2xvcltpICUgY29sb3IubGVuZ3RoXTsgfTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgLy9jYW4ndCByZWFsbHkgaGVscCBpdCBpZiBzb21lb25lIHBhc3NlcyBydWJiaXNoIGFzIGNvbG9yXG59XG5cbi8vIERlZmF1bHQgY29sb3IgY2hvb3NlciB1c2VzIHRoZSBpbmRleCBvZiBhbiBvYmplY3QgYXMgYmVmb3JlLlxubnYudXRpbHMuZGVmYXVsdENvbG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbG9ycyA9IGQzLnNjYWxlLmNhdGVnb3J5MjAoKS5yYW5nZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBkLmNvbG9yIHx8IGNvbG9yc1tpICUgY29sb3JzLmxlbmd0aF0gfTtcbn1cblxuXG4vLyBSZXR1cm5zIGEgY29sb3IgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgcmVzdWx0IG9mICdnZXRLZXknIGZvciBlYWNoIHNlcmllcyBhbmRcbi8vIGxvb2tzIGZvciBhIGNvcnJlc3BvbmRpbmcgY29sb3IgZnJvbSB0aGUgZGljdGlvbmFyeSxcbm52LnV0aWxzLmN1c3RvbVRoZW1lID0gZnVuY3Rpb24oZGljdGlvbmFyeSwgZ2V0S2V5LCBkZWZhdWx0Q29sb3JzKSB7XG4gIGdldEtleSA9IGdldEtleSB8fCBmdW5jdGlvbihzZXJpZXMpIHsgcmV0dXJuIHNlcmllcy5rZXkgfTsgLy8gdXNlIGRlZmF1bHQgc2VyaWVzLmtleSBpZiBnZXRLZXkgaXMgdW5kZWZpbmVkXG4gIGRlZmF1bHRDb2xvcnMgPSBkZWZhdWx0Q29sb3JzIHx8IGQzLnNjYWxlLmNhdGVnb3J5MjAoKS5yYW5nZSgpOyAvL2RlZmF1bHQgY29sb3IgZnVuY3Rpb25cblxuICB2YXIgZGVmSW5kZXggPSBkZWZhdWx0Q29sb3JzLmxlbmd0aDsgLy9jdXJyZW50IGRlZmF1bHQgY29sb3IgKGdvaW5nIGluIHJldmVyc2UpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHNlcmllcywgaW5kZXgpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5KHNlcmllcyk7XG5cbiAgICBpZiAoIWRlZkluZGV4KSBkZWZJbmRleCA9IGRlZmF1bHRDb2xvcnMubGVuZ3RoOyAvL3VzZWQgYWxsIHRoZSBkZWZhdWx0IGNvbG9ycywgc3RhcnQgb3ZlclxuXG4gICAgaWYgKHR5cGVvZiBkaWN0aW9uYXJ5W2tleV0gIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICByZXR1cm4gKHR5cGVvZiBkaWN0aW9uYXJ5W2tleV0gPT09IFwiZnVuY3Rpb25cIikgPyBkaWN0aW9uYXJ5W2tleV0oKSA6IGRpY3Rpb25hcnlba2V5XTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gZGVmYXVsdENvbG9yc1stLWRlZkluZGV4XTsgLy8gbm8gbWF0Y2ggaW4gZGljdGlvbmFyeSwgdXNlIGRlZmF1bHQgY29sb3JcbiAgfVxufVxuXG5cblxuLy8gRnJvbSB0aGUgUEpBWCBleGFtcGxlIG9uIGQzanMub3JnLCB3aGlsZSB0aGlzIGlzIG5vdCByZWFsbHkgZGlyZWN0bHkgbmVlZGVkXG4vLyBpdCdzIGEgdmVyeSBjb29sIG1ldGhvZCBmb3IgZG9pbmcgcGpheCwgSSBtYXkgZXhwYW5kIHVwb24gaXQgYSBsaXR0bGUgYml0LFxuLy8gb3BlbiB0byBzdWdnZXN0aW9ucyBvbiBhbnl0aGluZyB0aGF0IG1heSBiZSB1c2VmdWxcbm52LnV0aWxzLnBqYXggPSBmdW5jdGlvbihsaW5rcywgY29udGVudCkge1xuICBkMy5zZWxlY3RBbGwobGlua3MpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgaGlzdG9yeS5wdXNoU3RhdGUodGhpcy5ocmVmLCB0aGlzLnRleHRDb250ZW50LCB0aGlzLmhyZWYpO1xuICAgIGxvYWQodGhpcy5ocmVmKTtcbiAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcblxuICBmdW5jdGlvbiBsb2FkKGhyZWYpIHtcbiAgICBkMy5odG1sKGhyZWYsIGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gZDMuc2VsZWN0KGNvbnRlbnQpLm5vZGUoKTtcbiAgICAgIHRhcmdldC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChkMy5zZWxlY3QoZnJhZ21lbnQpLnNlbGVjdChjb250ZW50KS5ub2RlKCksIHRhcmdldCk7XG4gICAgICBudi51dGlscy5wamF4KGxpbmtzLCBjb250ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIGQzLnNlbGVjdCh3aW5kb3cpLm9uKFwicG9wc3RhdGVcIiwgZnVuY3Rpb24oKSB7XG4gICAgaWYgKGQzLmV2ZW50LnN0YXRlKSBsb2FkKGQzLmV2ZW50LnN0YXRlKTtcbiAgfSk7XG59XG5cbi8qIEZvciBzaXR1YXRpb25zIHdoZXJlIHdlIHdhbnQgdG8gYXBwcm94aW1hdGUgdGhlIHdpZHRoIGluIHBpeGVscyBmb3IgYW4gU1ZHOnRleHQgZWxlbWVudC5cbk1vc3QgY29tbW9uIGluc3RhbmNlIGlzIHdoZW4gdGhlIGVsZW1lbnQgaXMgaW4gYSBkaXNwbGF5Om5vbmU7IGNvbnRhaW5lci5cbkZvcnVtbGEgaXMgOiB0ZXh0Lmxlbmd0aCAqIGZvbnQtc2l6ZSAqIGNvbnN0YW50X2ZhY3RvclxuKi9cbm52LnV0aWxzLmNhbGNBcHByb3hUZXh0V2lkdGggPSBmdW5jdGlvbiAoc3ZnVGV4dEVsZW0pIHtcbiAgICBpZiAodHlwZW9mIHN2Z1RleHRFbGVtLnN0eWxlID09PSAnZnVuY3Rpb24nXG4gICAgICAgICYmIHR5cGVvZiBzdmdUZXh0RWxlbS50ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHBhcnNlSW50KHN2Z1RleHRFbGVtLnN0eWxlKFwiZm9udC1zaXplXCIpLnJlcGxhY2UoXCJweFwiLFwiXCIpKTtcbiAgICAgICAgdmFyIHRleHRMZW5ndGggPSBzdmdUZXh0RWxlbS50ZXh0KCkubGVuZ3RoO1xuXG4gICAgICAgIHJldHVybiB0ZXh0TGVuZ3RoICogZm9udFNpemUgKiAwLjU7XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxuLyogTnVtYmVycyB0aGF0IGFyZSB1bmRlZmluZWQsIG51bGwgb3IgTmFOLCBjb252ZXJ0IHRoZW0gdG8gemVyb3MuXG4qL1xubnYudXRpbHMuTmFOdG9aZXJvID0gZnVuY3Rpb24obikge1xuICAgIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcidcbiAgICAgICAgfHwgaXNOYU4obilcbiAgICAgICAgfHwgbiA9PT0gbnVsbFxuICAgICAgICB8fCBuID09PSBJbmZpbml0eSkgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbjtcbn07XG5cbi8qXG5TbmlwcGV0IG9mIGNvZGUgeW91IGNhbiBpbnNlcnQgaW50byBlYWNoIG52Lm1vZGVscy4qIHRvIGdpdmUgeW91IHRoZSBhYmlsaXR5IHRvXG5kbyB0aGluZ3MgbGlrZTpcbmNoYXJ0Lm9wdGlvbnMoe1xuICBzaG93WEF4aXM6IHRydWUsXG4gIHRvb2x0aXBzOiB0cnVlXG59KTtcblxuVG8gZW5hYmxlIGluIHRoZSBjaGFydDpcbmNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcbiovXG5udi51dGlscy5vcHRpb25zRnVuYyA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICBpZiAoYXJncykge1xuICAgICAgZDMubWFwKGFyZ3MpLmZvckVhY2goKGZ1bmN0aW9uKGtleSx2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNba2V5XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgIHRoaXNba2V5XSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07bnYubW9kZWxzLmF4aXMgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIGF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgO1xuXG4gIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICwgd2lkdGggPSA3NSAvL29ubHkgdXNlZCBmb3IgdGlja0xhYmVsIGN1cnJlbnRseVxuICAgICwgaGVpZ2h0ID0gNjAgLy9vbmx5IHVzZWQgZm9yIHRpY2tMYWJlbCBjdXJyZW50bHlcbiAgICAsIHNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAsIGF4aXNMYWJlbFRleHQgPSBudWxsXG4gICAgLCBzaG93TWF4TWluID0gdHJ1ZSAvL1RPRE86IHNob3dNYXhNaW4gc2hvdWxkIGJlIGRpc2FibGVkIG9uIGFsbCBvcmRpbmFsIHNjYWxlZCBheGVzXG4gICAgLCBoaWdobGlnaHRaZXJvID0gdHJ1ZVxuICAgICwgcm90YXRlTGFiZWxzID0gMFxuICAgICwgcm90YXRlWUxhYmVsID0gdHJ1ZVxuICAgICwgc3RhZ2dlckxhYmVscyA9IGZhbHNlXG4gICAgLCBpc09yZGluYWwgPSBmYWxzZVxuICAgICwgdGlja3MgPSBudWxsXG4gICAgLCBheGlzTGFiZWxEaXN0YW5jZSA9IDEyIC8vVGhlIGxhcmdlciB0aGlzIG51bWJlciBpcywgdGhlIGNsb3NlciB0aGUgYXhpcyBsYWJlbCBpcyB0byB0aGUgYXhpcy5cbiAgICA7XG5cbiAgYXhpc1xuICAgIC5zY2FsZShzY2FsZSlcbiAgICAub3JpZW50KCdib3R0b20nKVxuICAgIC50aWNrRm9ybWF0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSlcbiAgICA7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHNjYWxlMDtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcblxuICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtYXhpcycpLmRhdGEoW2RhdGFdKTtcbiAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LWF4aXMnKTtcbiAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJylcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICBpZiAodGlja3MgIT09IG51bGwpXG4gICAgICAgIGF4aXMudGlja3ModGlja3MpO1xuICAgICAgZWxzZSBpZiAoYXhpcy5vcmllbnQoKSA9PSAndG9wJyB8fCBheGlzLm9yaWVudCgpID09ICdib3R0b20nKVxuICAgICAgICBheGlzLnRpY2tzKE1hdGguYWJzKHNjYWxlLnJhbmdlKClbMV0gLSBzY2FsZS5yYW5nZSgpWzBdKSAvIDEwMCk7XG5cblxuICAgICAgLy9UT0RPOiBjb25zaWRlciBjYWxjdWxhdGluZyB3aWR0aC9oZWlnaHQgYmFzZWQgb24gd2hldGhlciBvciBub3QgbGFiZWwgaXMgYWRkZWQsIGZvciByZWZlcmVuY2UgaW4gY2hhcnRzIHVzaW5nIHRoaXMgY29tcG9uZW50XG5cblxuICAgICAgZy50cmFuc2l0aW9uKCkuY2FsbChheGlzKTtcblxuICAgICAgc2NhbGUwID0gc2NhbGUwIHx8IGF4aXMuc2NhbGUoKTtcblxuICAgICAgdmFyIGZtdCA9IGF4aXMudGlja0Zvcm1hdCgpO1xuICAgICAgaWYgKGZtdCA9PSBudWxsKSB7XG4gICAgICAgIGZtdCA9IHNjYWxlMC50aWNrRm9ybWF0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBheGlzTGFiZWwgPSBnLnNlbGVjdEFsbCgndGV4dC5udi1heGlzbGFiZWwnKVxuICAgICAgICAgIC5kYXRhKFtheGlzTGFiZWxUZXh0IHx8IG51bGxdKTtcbiAgICAgIGF4aXNMYWJlbC5leGl0KCkucmVtb3ZlKCk7XG4gICAgICBzd2l0Y2ggKGF4aXMub3JpZW50KCkpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICBheGlzTGFiZWwuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICdudi1heGlzbGFiZWwnKTtcbiAgICAgICAgICB2YXIgdyA9IChzY2FsZS5yYW5nZSgpLmxlbmd0aD09MikgPyBzY2FsZS5yYW5nZSgpWzFdIDogKHNjYWxlLnJhbmdlKClbc2NhbGUucmFuZ2UoKS5sZW5ndGgtMV0rKHNjYWxlLnJhbmdlKClbMV0tc2NhbGUucmFuZ2UoKVswXSkpO1xuICAgICAgICAgIGF4aXNMYWJlbFxuICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAuYXR0cigneCcsIHcvMik7XG4gICAgICAgICAgaWYgKHNob3dNYXhNaW4pIHtcbiAgICAgICAgICAgIHZhciBheGlzTWF4TWluID0gd3JhcC5zZWxlY3RBbGwoJ2cubnYtYXhpc01heE1pbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShzY2FsZS5kb21haW4oKSk7XG4gICAgICAgICAgICBheGlzTWF4TWluLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYXhpc01heE1pbicpLmFwcGVuZCgndGV4dCcpO1xuICAgICAgICAgICAgYXhpc01heE1pbi5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICBheGlzTWF4TWluXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHNjYWxlKGQpICsgJywwKSdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLTAuNWVtJylcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIC1heGlzLnRpY2tQYWRkaW5nKCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdiA9IGZtdChkKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoJycgKyB2KS5tYXRjaCgnTmFOJykgPyAnJyA6IHY7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBheGlzTWF4TWluLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBzY2FsZS5yYW5nZSgpW2ldICsgJywwKSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdmFyIHhMYWJlbE1hcmdpbiA9IDM2O1xuICAgICAgICAgIHZhciBtYXhUZXh0V2lkdGggPSAzMDtcbiAgICAgICAgICB2YXIgeFRpY2tzID0gZy5zZWxlY3RBbGwoJ2cnKS5zZWxlY3QoXCJ0ZXh0XCIpO1xuICAgICAgICAgIGlmIChyb3RhdGVMYWJlbHMlMzYwKSB7XG4gICAgICAgICAgICAvL0NhbGN1bGF0ZSB0aGUgbG9uZ2VzdCB4VGljayB3aWR0aFxuICAgICAgICAgICAgeFRpY2tzLmVhY2goZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgICAgICAgIGlmKHdpZHRoID4gbWF4VGV4dFdpZHRoKSBtYXhUZXh0V2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy9Db252ZXJ0IHRvIHJhZGlhbnMgYmVmb3JlIGNhbGN1bGF0aW5nIHNpbi4gQWRkIDMwIHRvIG1hcmdpbiBmb3IgaGVhbHRoeSBwYWRkaW5nLlxuICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguYWJzKE1hdGguc2luKHJvdGF0ZUxhYmVscypNYXRoLlBJLzE4MCkpO1xuICAgICAgICAgICAgdmFyIHhMYWJlbE1hcmdpbiA9IChzaW4gPyBzaW4qbWF4VGV4dFdpZHRoIDogbWF4VGV4dFdpZHRoKSszMDtcbiAgICAgICAgICAgIC8vUm90YXRlIGFsbCB4VGlja3NcbiAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuICdyb3RhdGUoJyArIHJvdGF0ZUxhYmVscyArICcgMCwwKScgfSlcbiAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIHJvdGF0ZUxhYmVscyUzNjAgPiAwID8gJ3N0YXJ0JyA6ICdlbmQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXhpc0xhYmVsLmVudGVyKCkuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCAnbnYtYXhpc2xhYmVsJyk7XG4gICAgICAgICAgdmFyIHcgPSAoc2NhbGUucmFuZ2UoKS5sZW5ndGg9PTIpID8gc2NhbGUucmFuZ2UoKVsxXSA6IChzY2FsZS5yYW5nZSgpW3NjYWxlLnJhbmdlKCkubGVuZ3RoLTFdKyhzY2FsZS5yYW5nZSgpWzFdLXNjYWxlLnJhbmdlKClbMF0pKTtcbiAgICAgICAgICBheGlzTGFiZWxcbiAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgICAgICAgICAgIC5hdHRyKCd5JywgeExhYmVsTWFyZ2luKVxuICAgICAgICAgICAgICAuYXR0cigneCcsIHcvMik7XG4gICAgICAgICAgaWYgKHNob3dNYXhNaW4pIHtcbiAgICAgICAgICAvL2lmIChzaG93TWF4TWluICYmICFpc09yZGluYWwpIHtcbiAgICAgICAgICAgIHZhciBheGlzTWF4TWluID0gd3JhcC5zZWxlY3RBbGwoJ2cubnYtYXhpc01heE1pbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLy5kYXRhKHNjYWxlLmRvbWFpbigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoW3NjYWxlLmRvbWFpbigpWzBdLCBzY2FsZS5kb21haW4oKVtzY2FsZS5kb21haW4oKS5sZW5ndGggLSAxXV0pO1xuICAgICAgICAgICAgYXhpc01heE1pbi5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWF4aXNNYXhNaW4nKS5hcHBlbmQoJ3RleHQnKTtcbiAgICAgICAgICAgIGF4aXNNYXhNaW4uZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgYXhpc01heE1pblxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoc2NhbGUoZCkgKyAoaXNPcmRpbmFsID8gc2NhbGUucmFuZ2VCYW5kKCkgLyAyIDogMCkpICsgJywwKSdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjcxZW0nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgYXhpcy50aWNrUGFkZGluZygpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGksaikgeyByZXR1cm4gJ3JvdGF0ZSgnICsgcm90YXRlTGFiZWxzICsgJyAwLDApJyB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByb3RhdGVMYWJlbHMgPyAocm90YXRlTGFiZWxzJTM2MCA+IDAgPyAnc3RhcnQnIDogJ2VuZCcpIDogJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdiA9IGZtdChkKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoJycgKyB2KS5tYXRjaCgnTmFOJykgPyAnJyA6IHY7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBheGlzTWF4TWluLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgIC8vcmV0dXJuICd0cmFuc2xhdGUoJyArIHNjYWxlLnJhbmdlKClbaV0gKyAnLDApJ1xuICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gJ3RyYW5zbGF0ZSgnICsgc2NhbGUoZCkgKyAnLDApJ1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIChzY2FsZShkKSArIChpc09yZGluYWwgPyBzY2FsZS5yYW5nZUJhbmQoKSAvIDIgOiAwKSkgKyAnLDApJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhZ2dlckxhYmVscylcbiAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoMCwnICsgKGkgJSAyID09IDAgPyAnMCcgOiAnMTInKSArICcpJyB9KTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgYXhpc0xhYmVsLmVudGVyKCkuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCAnbnYtYXhpc2xhYmVsJyk7XG4gICAgICAgICAgYXhpc0xhYmVsXG4gICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByb3RhdGVZTGFiZWwgPyAnbWlkZGxlJyA6ICdiZWdpbicpXG4gICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCByb3RhdGVZTGFiZWwgPyAncm90YXRlKDkwKScgOiAnJylcbiAgICAgICAgICAgICAgLmF0dHIoJ3knLCByb3RhdGVZTGFiZWwgPyAoLU1hdGgubWF4KG1hcmdpbi5yaWdodCx3aWR0aCkgKyAxMikgOiAtMTApIC8vVE9ETzogY29uc2lkZXIgY2FsY3VsYXRpbmcgdGhpcyBiYXNlZCBvbiBsYXJnZXN0IHRpY2sgd2lkdGguLi4gT1IgYXQgbGVhc3QgZXhwb3NlIHRoaXMgb24gY2hhcnRcbiAgICAgICAgICAgICAgLmF0dHIoJ3gnLCByb3RhdGVZTGFiZWwgPyAoc2NhbGUucmFuZ2UoKVswXSAvIDIpIDogYXhpcy50aWNrUGFkZGluZygpKTtcbiAgICAgICAgICBpZiAoc2hvd01heE1pbikge1xuICAgICAgICAgICAgdmFyIGF4aXNNYXhNaW4gPSB3cmFwLnNlbGVjdEFsbCgnZy5udi1heGlzTWF4TWluJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKHNjYWxlLmRvbWFpbigpKTtcbiAgICAgICAgICAgIGF4aXNNYXhNaW4uZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1heGlzTWF4TWluJykuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKTtcbiAgICAgICAgICAgIGF4aXNNYXhNaW4uZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgYXhpc01heE1pblxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsJyArIHNjYWxlKGQpICsgJyknXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zMmVtJylcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBheGlzLnRpY2tQYWRkaW5nKCkpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpXG4gICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdiA9IGZtdChkKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoJycgKyB2KS5tYXRjaCgnTmFOJykgPyAnJyA6IHY7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBheGlzTWF4TWluLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsJyArIHNjYWxlLnJhbmdlKClbaV0gKyAnKSdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIC8qXG4gICAgICAgICAgLy9Gb3IgZHluYW1pY2FsbHkgcGxhY2luZyB0aGUgbGFiZWwuIENhbiBiZSB1c2VkIHdpdGggZHluYW1pY2FsbHktc2l6ZWQgY2hhcnQgYXhpcyBtYXJnaW5zXG4gICAgICAgICAgdmFyIHlUaWNrcyA9IGcuc2VsZWN0QWxsKCdnJykuc2VsZWN0KFwidGV4dFwiKTtcbiAgICAgICAgICB5VGlja3MuZWFjaChmdW5jdGlvbihkLGkpe1xuICAgICAgICAgICAgdmFyIGxhYmVsUGFkZGluZyA9IHRoaXMuZ2V0QkJveCgpLndpZHRoICsgYXhpcy50aWNrUGFkZGluZygpICsgMTY7XG4gICAgICAgICAgICBpZihsYWJlbFBhZGRpbmcgPiB3aWR0aCkgd2lkdGggPSBsYWJlbFBhZGRpbmc7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgKi9cbiAgICAgICAgICBheGlzTGFiZWwuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICdudi1heGlzbGFiZWwnKTtcbiAgICAgICAgICBheGlzTGFiZWxcbiAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIHJvdGF0ZVlMYWJlbCA/ICdtaWRkbGUnIDogJ2VuZCcpXG4gICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCByb3RhdGVZTGFiZWwgPyAncm90YXRlKC05MCknIDogJycpXG4gICAgICAgICAgICAgIC5hdHRyKCd5Jywgcm90YXRlWUxhYmVsID8gKC1NYXRoLm1heChtYXJnaW4ubGVmdCx3aWR0aCkgKyBheGlzTGFiZWxEaXN0YW5jZSkgOiAtMTApIC8vVE9ETzogY29uc2lkZXIgY2FsY3VsYXRpbmcgdGhpcyBiYXNlZCBvbiBsYXJnZXN0IHRpY2sgd2lkdGguLi4gT1IgYXQgbGVhc3QgZXhwb3NlIHRoaXMgb24gY2hhcnRcbiAgICAgICAgICAgICAgLmF0dHIoJ3gnLCByb3RhdGVZTGFiZWwgPyAoLXNjYWxlLnJhbmdlKClbMF0gLyAyKSA6IC1heGlzLnRpY2tQYWRkaW5nKCkpO1xuICAgICAgICAgIGlmIChzaG93TWF4TWluKSB7XG4gICAgICAgICAgICB2YXIgYXhpc01heE1pbiA9IHdyYXAuc2VsZWN0QWxsKCdnLm52LWF4aXNNYXhNaW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoc2NhbGUuZG9tYWluKCkpO1xuICAgICAgICAgICAgYXhpc01heE1pbi5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWF4aXNNYXhNaW4nKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApO1xuICAgICAgICAgICAgYXhpc01heE1pbi5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICBheGlzTWF4TWluXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwnICsgc2NhbGUwKGQpICsgJyknXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zMmVtJylcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAtYXhpcy50aWNrUGFkZGluZygpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxuICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHYgPSBmbXQoZCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKCcnICsgdikubWF0Y2goJ05hTicpID8gJycgOiB2O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXhpc01heE1pbi50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCcgKyBzY2FsZS5yYW5nZSgpW2ldICsgJyknXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXhpc0xhYmVsXG4gICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuXG4gICAgICBpZiAoc2hvd01heE1pbiAmJiAoYXhpcy5vcmllbnQoKSA9PT0gJ2xlZnQnIHx8IGF4aXMub3JpZW50KCkgPT09ICdyaWdodCcpKSB7XG4gICAgICAgIC8vY2hlY2sgaWYgbWF4IGFuZCBtaW4gb3ZlcmxhcCBvdGhlciB2YWx1ZXMsIGlmIHNvLCBoaWRlIHRoZSB2YWx1ZXMgdGhhdCBvdmVybGFwXG4gICAgICAgIGcuc2VsZWN0QWxsKCdnJykgLy8gdGhlIGcncyB3cmFwcGluZyBlYWNoIHRpY2tcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCd0ZXh0JykuYXR0cignb3BhY2l0eScsIDEpO1xuICAgICAgICAgICAgICBpZiAoc2NhbGUoZCkgPCBzY2FsZS5yYW5nZSgpWzFdICsgMTAgfHwgc2NhbGUoZCkgPiBzY2FsZS5yYW5nZSgpWzBdIC0gMTApIHsgLy8gMTAgaXMgYXNzdW1pbmcgdGV4dCBoZWlnaHQgaXMgMTYuLi4gaWYgZCBpcyAwLCBsZWF2ZSBpdCFcbiAgICAgICAgICAgICAgICBpZiAoZCA+IDFlLTEwIHx8IGQgPCAtMWUtMTApIC8vIGFjY291bnRzIGZvciBtaW5vciBmbG9hdGluZyBwb2ludCBlcnJvcnMuLi4gdGhvdWdoIGNvdWxkIGJlIHByb2JsZW1hdGljIGlmIHRoZSBzY2FsZSBpcyBFWFRSRU1FTFkgU01BTExcbiAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdvcGFjaXR5JywgMCk7XG5cbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCd0ZXh0JykuYXR0cignb3BhY2l0eScsIDApOyAvLyBEb24ndCByZW1vdmUgdGhlIFpFUk8gbGluZSEhXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vaWYgTWF4IGFuZCBNaW4gPSAwIG9ubHkgc2hvdyBtaW4sIElzc3VlICMyODFcbiAgICAgICAgaWYgKHNjYWxlLmRvbWFpbigpWzBdID09IHNjYWxlLmRvbWFpbigpWzFdICYmIHNjYWxlLmRvbWFpbigpWzBdID09IDApXG4gICAgICAgICAgd3JhcC5zZWxlY3RBbGwoJ2cubnYtYXhpc01heE1pbicpXG4gICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFpID8gMSA6IDAgfSk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKHNob3dNYXhNaW4gJiYgKGF4aXMub3JpZW50KCkgPT09ICd0b3AnIHx8IGF4aXMub3JpZW50KCkgPT09ICdib3R0b20nKSkge1xuICAgICAgICB2YXIgbWF4TWluUmFuZ2UgPSBbXTtcbiAgICAgICAgd3JhcC5zZWxlY3RBbGwoJ2cubnYtYXhpc01heE1pbicpXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmIChpKSAvLyBpPT0gMSwgbWF4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgbWF4TWluUmFuZ2UucHVzaChzY2FsZShkKSAtIHRoaXMuZ2V0QkJveCgpLndpZHRoIC0gNCkgIC8vYXNzdW1pbmcgdGhlIG1heCBhbmQgbWluIGxhYmVscyBhcmUgYXMgd2lkZSBhcyB0aGUgbmV4dCB0aWNrICh3aXRoIGFuIGV4dHJhIDQgcGl4ZWxzIGp1c3QgaW4gY2FzZSlcbiAgICAgICAgICAgICAgICAgIGVsc2UgLy8gaT09MCwgbWluIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgbWF4TWluUmFuZ2UucHVzaChzY2FsZShkKSArIHRoaXMuZ2V0QkJveCgpLndpZHRoICsgNClcbiAgICAgICAgICAgICAgfWNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpKSAvLyBpPT0gMSwgbWF4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgbWF4TWluUmFuZ2UucHVzaChzY2FsZShkKSAtIDQpICAvL2Fzc3VtaW5nIHRoZSBtYXggYW5kIG1pbiBsYWJlbHMgYXJlIGFzIHdpZGUgYXMgdGhlIG5leHQgdGljayAod2l0aCBhbiBleHRyYSA0IHBpeGVscyBqdXN0IGluIGNhc2UpXG4gICAgICAgICAgICAgICAgICBlbHNlIC8vIGk9PTAsIG1pbiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgIG1heE1pblJhbmdlLnB1c2goc2NhbGUoZCkgKyA0KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZy5zZWxlY3RBbGwoJ2cnKSAvLyB0aGUgZydzIHdyYXBwaW5nIGVhY2ggdGlja1xuICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgIGlmIChzY2FsZShkKSA8IG1heE1pblJhbmdlWzBdIHx8IHNjYWxlKGQpID4gbWF4TWluUmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZCA+IDFlLTEwIHx8IGQgPCAtMWUtMTApIC8vIGFjY291bnRzIGZvciBtaW5vciBmbG9hdGluZyBwb2ludCBlcnJvcnMuLi4gdGhvdWdoIGNvdWxkIGJlIHByb2JsZW1hdGljIGlmIHRoZSBzY2FsZSBpcyBFWFRSRU1FTFkgU01BTExcbiAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCd0ZXh0JykucmVtb3ZlKCk7IC8vIERvbid0IHJlbW92ZSB0aGUgWkVSTyBsaW5lISFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICB9XG5cblxuICAgICAgLy9oaWdobGlnaHQgemVybyBsaW5lIC4uLiBNYXliZSBzaG91bGQgbm90IGJlIGFuIG9wdGlvbiBhbmQgc2hvdWxkIGp1c3QgYmUgaW4gQ1NTP1xuICAgICAgaWYgKGhpZ2hsaWdodFplcm8pXG4gICAgICAgIGcuc2VsZWN0QWxsKCcudGljaycpXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhcGFyc2VGbG9hdChNYXRoLnJvdW5kKGQuX19kYXRhX18qMTAwMDAwKS8xMDAwMDAwKSAmJiAoZC5fX2RhdGFfXyAhPT0gdW5kZWZpbmVkKSB9KSAvL3RoaXMgaXMgYmVjYXVzZSBzb21ldGltZXMgdGhlIDAgdGljayBpcyBhIHZlcnkgc21hbGwgZnJhY3Rpb24sIFRPRE86IHRoaW5rIG9mIGNsZWFuZXIgdGVjaG5pcXVlXG4gICAgICAgICAgICAuY2xhc3NlZCgnemVybycsIHRydWUpO1xuXG4gICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgIHNjYWxlMCA9IHNjYWxlLmNvcHkoKTtcblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gIGNoYXJ0LmF4aXMgPSBheGlzO1xuXG4gIGQzLnJlYmluZChjaGFydCwgYXhpcywgJ29yaWVudCcsICd0aWNrVmFsdWVzJywgJ3RpY2tTdWJkaXZpZGUnLCAndGlja1NpemUnLCAndGlja1BhZGRpbmcnLCAndGlja0Zvcm1hdCcpO1xuICBkMy5yZWJpbmQoY2hhcnQsIHNjYWxlLCAnZG9tYWluJywgJ3JhbmdlJywgJ3JhbmdlQmFuZCcsICdyYW5nZUJhbmRzJyk7IC8vdGhlc2UgYXJlIGFsc28gYWNjZXNzaWJsZSBieSBjaGFydC5zY2FsZSgpLCBidXQgYWRkZWQgY29tbW9uIG9uZXMgZGlyZWN0bHkgZm9yIGVhc2Ugb2YgdXNlXG5cbiAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gIGNoYXJ0Lm1hcmdpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG4gIGNoYXJ0LndpZHRoID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgIHdpZHRoID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudGlja3MgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja3M7XG4gICAgdGlja3MgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5oZWlnaHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xuICAgIGhlaWdodCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmF4aXNMYWJlbCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBheGlzTGFiZWxUZXh0O1xuICAgIGF4aXNMYWJlbFRleHQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG4gIGNoYXJ0LnNob3dNYXhNaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd01heE1pbjtcbiAgICBzaG93TWF4TWluID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuICBjaGFydC5oaWdobGlnaHRaZXJvID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhpZ2hsaWdodFplcm87XG4gICAgaGlnaGxpZ2h0WmVybyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cbiAgY2hhcnQuc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgc2NhbGUgPSBfO1xuICAgIGF4aXMuc2NhbGUoc2NhbGUpO1xuICAgIGlzT3JkaW5hbCA9IHR5cGVvZiBzY2FsZS5yYW5nZUJhbmRzID09PSAnZnVuY3Rpb24nO1xuICAgIGQzLnJlYmluZChjaGFydCwgc2NhbGUsICdkb21haW4nLCAncmFuZ2UnLCAncmFuZ2VCYW5kJywgJ3JhbmdlQmFuZHMnKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuICBjaGFydC5yb3RhdGVZTGFiZWwgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByb3RhdGVZTGFiZWw7XG4gICAgcm90YXRlWUxhYmVsID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuICBjaGFydC5yb3RhdGVMYWJlbHMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByb3RhdGVMYWJlbHM7XG4gICAgcm90YXRlTGFiZWxzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuICBjaGFydC5zdGFnZ2VyTGFiZWxzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YWdnZXJMYWJlbHM7XG4gICAgc3RhZ2dlckxhYmVscyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmF4aXNMYWJlbERpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGF4aXNMYWJlbERpc3RhbmNlO1xuICAgIGF4aXNMYWJlbERpc3RhbmNlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIHJldHVybiBjaGFydDtcbn1cbi8vVE9ETzogY29uc2lkZXIgZGVwcmVjYXRpbmcgYW5kIHVzaW5nIG11bHRpYmFyIHdpdGggc2luZ2xlIHNlcmllcyBmb3IgdGhpc1xubnYubW9kZWxzLmhpc3RvcmljYWxCYXIgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgLCB3aWR0aCA9IDk2MFxuICAgICwgaGVpZ2h0ID0gNTAwXG4gICAgLCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSAvL0NyZWF0ZSBzZW1pLXVuaXF1ZSBJRCBpbiBjYXNlIHVzZXIgZG9lc24ndCBzZWxlY3Qgb25lXG4gICAgLCB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAsIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9XG4gICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAsIGZvcmNlWCA9IFtdXG4gICAgLCBmb3JjZVkgPSBbMF1cbiAgICAsIHBhZERhdGEgPSBmYWxzZVxuICAgICwgY2xpcEVkZ2UgPSB0cnVlXG4gICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgLCB4RG9tYWluXG4gICAgLCB5RG9tYWluXG4gICAgLCB4UmFuZ2VcbiAgICAsIHlSYW5nZVxuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnY2hhcnRDbGljaycsICdlbGVtZW50Q2xpY2snLCAnZWxlbWVudERibENsaWNrJywgJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JylcbiAgICAsIGludGVyYWN0aXZlID0gdHJ1ZVxuICAgIDtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIFNjYWxlc1xuXG4gICAgICB4ICAgLmRvbWFpbih4RG9tYWluIHx8IGQzLmV4dGVudChkYXRhWzBdLnZhbHVlcy5tYXAoZ2V0WCkuY29uY2F0KGZvcmNlWCkgKSlcblxuICAgICAgaWYgKHBhZERhdGEpXG4gICAgICAgIHgucmFuZ2UoeFJhbmdlIHx8IFthdmFpbGFibGVXaWR0aCAqIC41IC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoLCBhdmFpbGFibGVXaWR0aCAqIChkYXRhWzBdLnZhbHVlcy5sZW5ndGggLSAuNSkgIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoIF0pO1xuICAgICAgZWxzZVxuICAgICAgICB4LnJhbmdlKHhSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgeSAgIC5kb21haW4oeURvbWFpbiB8fCBkMy5leHRlbnQoZGF0YVswXS52YWx1ZXMubWFwKGdldFkpLmNvbmNhdChmb3JjZVkpICkpXG4gICAgICAgICAgLnJhbmdlKHlSYW5nZSB8fCBbYXZhaWxhYmxlSGVpZ2h0LCAwXSk7XG5cbiAgICAgIC8vIElmIHNjYWxlJ3MgZG9tYWluIGRvbid0IGhhdmUgYSByYW5nZSwgc2xpZ2h0bHkgYWRqdXN0IHRvIG1ha2Ugb25lLi4uIHNvIGEgY2hhcnQgY2FuIHNob3cgYSBzaW5nbGUgZGF0YSBwb2ludFxuXG4gICAgICBpZiAoeC5kb21haW4oKVswXSA9PT0geC5kb21haW4oKVsxXSlcbiAgICAgICAgeC5kb21haW4oKVswXSA/XG4gICAgICAgICAgICB4LmRvbWFpbihbeC5kb21haW4oKVswXSAtIHguZG9tYWluKClbMF0gKiAwLjAxLCB4LmRvbWFpbigpWzFdICsgeC5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgIDogeC5kb21haW4oWy0xLDFdKTtcblxuICAgICAgaWYgKHkuZG9tYWluKClbMF0gPT09IHkuZG9tYWluKClbMV0pXG4gICAgICAgIHkuZG9tYWluKClbMF0gP1xuICAgICAgICAgICAgeS5kb21haW4oW3kuZG9tYWluKClbMF0gKyB5LmRvbWFpbigpWzBdICogMC4wMSwgeS5kb21haW4oKVsxXSAtIHkuZG9tYWluKClbMV0gKiAwLjAxXSlcbiAgICAgICAgICA6IHkuZG9tYWluKFstMSwxXSk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWhpc3RvcmljYWxCYXItJyArIGlkKS5kYXRhKFtkYXRhWzBdLnZhbHVlc10pO1xuICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtaGlzdG9yaWNhbEJhci0nICsgaWQpO1xuICAgICAgdmFyIGRlZnNFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2RlZnMnKTtcbiAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1iYXJzJyk7XG5cbiAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICBjb250YWluZXJcbiAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkaXNwYXRjaC5jaGFydENsaWNrKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHBvczogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuXG4gICAgICBkZWZzRW50ZXIuYXBwZW5kKCdjbGlwUGF0aCcpXG4gICAgICAgICAgLmF0dHIoJ2lkJywgJ252LWNoYXJ0LWNsaXAtcGF0aC0nICsgaWQpXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgd3JhcC5zZWxlY3QoJyNudi1jaGFydC1jbGlwLXBhdGgtJyArIGlkICsgJyByZWN0JylcbiAgICAgICAgICAuYXR0cignd2lkdGgnLCBhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgZyAgIC5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwRWRnZSA/ICd1cmwoI252LWNoYXJ0LWNsaXAtcGF0aC0nICsgaWQgKyAnKScgOiAnJyk7XG5cblxuXG4gICAgICB2YXIgYmFycyA9IHdyYXAuc2VsZWN0KCcubnYtYmFycycpLnNlbGVjdEFsbCgnLm52LWJhcicpXG4gICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9LCBmdW5jdGlvbihkLGkpIHtyZXR1cm4gZ2V0WChkLGkpfSk7XG5cbiAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG5cbiAgICAgIHZhciBiYXJzRW50ZXIgPSBiYXJzLmVudGVyKCkuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAvLy5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiAoZ2V0WShkLGkpIDwgMCA/ICdudi1iYXIgbmVnYXRpdmUnIDogJ252LWJhciBwb3NpdGl2ZScpICsgJyBudi1iYXItJyArIGogKyAnLScgKyBpIH0pXG4gICAgICAgICAgLmF0dHIoJ3gnLCAwIClcbiAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQsaSkgeyAgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh5KE1hdGgubWF4KDAsIGdldFkoZCxpKSkpKSB9KVxuICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyhNYXRoLmFicyh5KGdldFkoZCxpKSkgLSB5KDApKSkgfSlcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyAoeChnZXRYKGQsaSkpIC0gYXZhaWxhYmxlV2lkdGggLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGggKiAuNDUpICsgJywwKSc7IH0pIFxuICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBpZiAoIWludGVyYWN0aXZlKSByZXR1cm47XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgIHNlcmllczogZGF0YVswXSxcbiAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgoZCxpKSksIHkoZ2V0WShkLGkpKV0sICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgdmFsdWUgYXBwZWFycyB0byBiZSBzaGlmdGVkXG4gICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogMCxcbiAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWludGVyYWN0aXZlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGlmICghaW50ZXJhY3RpdmUpIHJldHVybjtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50Q2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAvL2xhYmVsOiBkW2xhYmVsXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChkLGkpKSwgeShnZXRZKGQsaSkpXSxcbiAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgaWYgKCFpbnRlcmFjdGl2ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50RGJsQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgLy9sYWJlbDogZFtsYWJlbF0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpLCB5KGdldFkoZCxpKSldLFxuICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICBiYXJzXG4gICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGNvbG9yKGQsIGkpOyB9KVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiAoZ2V0WShkLGkpIDwgMCA/ICdudi1iYXIgbmVnYXRpdmUnIDogJ252LWJhciBwb3NpdGl2ZScpICsgJyBudi1iYXItJyArIGogKyAnLScgKyBpIH0pXG4gICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArICh4KGdldFgoZCxpKSkgLSBhdmFpbGFibGVXaWR0aCAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCAqIC40NSkgKyAnLDApJzsgfSkgXG4gICAgICAgICAgIC8vVE9ETzogYmV0dGVyIHdpZHRoIGNhbGN1bGF0aW9ucyB0aGF0IGRvbid0IGFzc3VtZSBhbHdheXMgdW5pZm9ybSBkYXRhIHNwYWNpbmc7d1xuICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIChhdmFpbGFibGVXaWR0aCAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCkgKiAuOSApO1xuXG5cbiAgICAgIGJhcnMudHJhbnNpdGlvbigpXG4gICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIHZhciBydmFsID0gZ2V0WShkLGkpIDwgMCA/XG4gICAgICAgICAgICAgICAgICAgIHkoMCkgOlxuICAgICAgICAgICAgICAgICAgICB5KDApIC0geShnZXRZKGQsaSkpIDwgMSA/XG4gICAgICAgICAgICAgICAgICAgICAgeSgwKSAtIDEgOlxuICAgICAgICAgICAgICAgICAgICAgIHkoZ2V0WShkLGkpKTtcbiAgICAgICAgICAgIHJldHVybiBudi51dGlscy5OYU50b1plcm8ocnZhbCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBudi51dGlscy5OYU50b1plcm8oTWF0aC5tYXgoTWF0aC5hYnMoeShnZXRZKGQsaSkpIC0geSgwKSksMSkpIH0pO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuICAvL0NyZWF0ZSBtZXRob2RzIHRvIGFsbG93IG91dHNpZGUgZnVuY3Rpb25zIHRvIGhpZ2hsaWdodCBhIHNwZWNpZmljIGJhci5cbiAgY2hhcnQuaGlnaGxpZ2h0UG9pbnQgPSBmdW5jdGlvbihwb2ludEluZGV4LCBpc0hvdmVyT3Zlcikge1xuICAgICAgZDMuc2VsZWN0KFwiLm52LWhpc3RvcmljYWxCYXItXCIgKyBpZClcbiAgICAgICAgLnNlbGVjdChcIi5udi1iYXJzIC5udi1iYXItMC1cIiArIHBvaW50SW5kZXgpXG4gICAgICAgICAgICAgIC5jbGFzc2VkKFwiaG92ZXJcIiwgaXNIb3Zlck92ZXIpXG4gICAgICAgICAgICAgICA7XG4gIH07XG5cbiAgY2hhcnQuY2xlYXJIaWdobGlnaHRzID0gZnVuY3Rpb24oKSB7XG4gICAgICBkMy5zZWxlY3QoXCIubnYtaGlzdG9yaWNhbEJhci1cIiArIGlkKVxuICAgICAgICAuc2VsZWN0KFwiLm52LWJhcnMgLm52LWJhci5ob3ZlclwiKVxuICAgICAgICAgICAgICAuY2xhc3NlZChcImhvdmVyXCIsIGZhbHNlKVxuICAgICAgICAgICAgICAgO1xuICB9O1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5cbiAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuICBcbiAgY2hhcnQueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXRYO1xuICAgIGdldFggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFk7XG4gICAgZ2V0WSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0Lm1hcmdpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJnaW47XG4gICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICBtYXJnaW4ucmlnaHQgID0gdHlwZW9mIF8ucmlnaHQgICE9ICd1bmRlZmluZWQnID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgbWFyZ2luLmJvdHRvbSA9IHR5cGVvZiBfLmJvdHRvbSAhPSAndW5kZWZpbmVkJyA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQud2lkdGggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XG4gICAgd2lkdGggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5oZWlnaHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xuICAgIGhlaWdodCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnhTY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4O1xuICAgIHggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55U2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICB5ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueERvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4RG9tYWluO1xuICAgIHhEb21haW4gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55RG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHlEb21haW47XG4gICAgeURvbWFpbiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnhSYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4UmFuZ2U7XG4gICAgeFJhbmdlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueVJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHlSYW5nZTtcbiAgICB5UmFuZ2UgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5mb3JjZVggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZm9yY2VYO1xuICAgIGZvcmNlWCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmZvcmNlWSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmb3JjZVk7XG4gICAgZm9yY2VZID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQucGFkRGF0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWREYXRhO1xuICAgIHBhZERhdGEgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5jbGlwRWRnZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGlwRWRnZTtcbiAgICBjbGlwRWRnZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmlkID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGlkO1xuICAgIGlkID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaW50ZXJhY3RpdmUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcmFjdGl2ZTtcbiAgICBpbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgcmV0dXJuIGNoYXJ0O1xufVxuXG4vLyBDaGFydCBkZXNpZ24gYmFzZWQgb24gdGhlIHJlY29tbWVuZGF0aW9ucyBvZiBTdGVwaGVuIEZldy4gSW1wbGVtZW50YXRpb25cbi8vIGJhc2VkIG9uIHRoZSB3b3JrIG9mIENsaW50IEl2eSwgSmFtaWUgTG92ZSwgYW5kIEphc29uIERhdmllcy5cbi8vIGh0dHA6Ly9wcm9qZWN0cy5pbnN0YW50Y29nbml0aW9uLmNvbS9wcm90b3Zpcy9idWxsZXRjaGFydC9cblxubnYubW9kZWxzLmJ1bGxldCA9IGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAsIG9yaWVudCA9ICdsZWZ0JyAvLyBUT0RPIHRvcCAmIGJvdHRvbVxuICAgICwgcmV2ZXJzZSA9IGZhbHNlXG4gICAgLCByYW5nZXMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnJhbmdlcyB9XG4gICAgLCBtYXJrZXJzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5tYXJrZXJzIH1cbiAgICAsIG1lYXN1cmVzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5tZWFzdXJlcyB9XG4gICAgLCByYW5nZUxhYmVscyA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQucmFuZ2VMYWJlbHMgPyBkLnJhbmdlTGFiZWxzIDogW10gfVxuICAgICwgbWFya2VyTGFiZWxzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5tYXJrZXJMYWJlbHMgPyBkLm1hcmtlckxhYmVscyA6IFtdICB9XG4gICAgLCBtZWFzdXJlTGFiZWxzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5tZWFzdXJlTGFiZWxzID8gZC5tZWFzdXJlTGFiZWxzIDogW10gIH1cbiAgICAsIGZvcmNlWCA9IFswXSAvLyBMaXN0IG9mIG51bWJlcnMgdG8gRm9yY2UgaW50byB0aGUgWCBzY2FsZSAoaWUuIDAsIG9yIGEgbWF4IC8gbWluLCBldGMuKVxuICAgICwgd2lkdGggPSAzODBcbiAgICAsIGhlaWdodCA9IDMwXG4gICAgLCB0aWNrRm9ybWF0ID0gbnVsbFxuICAgICwgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihbJyMxZjc3YjQnXSlcbiAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JylcbiAgICA7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICB2YXIgcmFuZ2V6ID0gcmFuZ2VzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKS5zb3J0KGQzLmRlc2NlbmRpbmcpLFxuICAgICAgICAgIG1hcmtlcnogPSBtYXJrZXJzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKS5zb3J0KGQzLmRlc2NlbmRpbmcpLFxuICAgICAgICAgIG1lYXN1cmV6ID0gbWVhc3VyZXMuY2FsbCh0aGlzLCBkLCBpKS5zbGljZSgpLnNvcnQoZDMuZGVzY2VuZGluZyksXG4gICAgICAgICAgcmFuZ2VMYWJlbHogPSByYW5nZUxhYmVscy5jYWxsKHRoaXMsIGQsIGkpLnNsaWNlKCksXG4gICAgICAgICAgbWFya2VyTGFiZWx6ID0gbWFya2VyTGFiZWxzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKSxcbiAgICAgICAgICBtZWFzdXJlTGFiZWx6ID0gbWVhc3VyZUxhYmVscy5jYWxsKHRoaXMsIGQsIGkpLnNsaWNlKCk7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIFNjYWxlc1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBuZXcgeC1zY2FsZS5cbiAgICAgIHZhciB4MSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgLmRvbWFpbiggZDMuZXh0ZW50KGQzLm1lcmdlKFtmb3JjZVgsIHJhbmdlel0pKSApXG4gICAgICAgICAgLnJhbmdlKHJldmVyc2UgPyBbYXZhaWxhYmxlV2lkdGgsIDBdIDogWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgIC8vIFJldHJpZXZlIHRoZSBvbGQgeC1zY2FsZSwgaWYgdGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgICB2YXIgeDAgPSB0aGlzLl9fY2hhcnRfXyB8fCBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgIC5kb21haW4oWzAsIEluZmluaXR5XSlcbiAgICAgICAgICAucmFuZ2UoeDEucmFuZ2UoKSk7XG5cbiAgICAgIC8vIFN0YXNoIHRoZSBuZXcgc2NhbGUuXG4gICAgICB0aGlzLl9fY2hhcnRfXyA9IHgxO1xuXG5cbiAgICAgIHZhciByYW5nZU1pbiA9IGQzLm1pbihyYW5nZXopLCAvL3JhbmdlelsyXVxuICAgICAgICAgIHJhbmdlTWF4ID0gZDMubWF4KHJhbmdleiksIC8vcmFuZ2V6WzBdXG4gICAgICAgICAgcmFuZ2VBdmcgPSByYW5nZXpbMV07XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWJ1bGxldCcpLmRhdGEoW2RdKTtcbiAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LWJ1bGxldCcpO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgZ0VudGVyLmFwcGVuZCgncmVjdCcpLmF0dHIoJ2NsYXNzJywgJ252LXJhbmdlIG52LXJhbmdlTWF4Jyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdyZWN0JykuYXR0cignY2xhc3MnLCAnbnYtcmFuZ2UgbnYtcmFuZ2VBdmcnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ3JlY3QnKS5hdHRyKCdjbGFzcycsICdudi1yYW5nZSBudi1yYW5nZU1pbicpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgncmVjdCcpLmF0dHIoJ2NsYXNzJywgJ252LW1lYXN1cmUnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdjbGFzcycsICdudi1tYXJrZXJUcmlhbmdsZScpO1xuXG4gICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXG4gICAgICB2YXIgdzAgPSBmdW5jdGlvbihkKSB7IHJldHVybiBNYXRoLmFicyh4MChkKSAtIHgwKDApKSB9LCAvLyBUT0RPOiBjb3VsZCBvcHRpbWl6ZSBieSBwcmVjYWxjdWxhdGluZyB4MCgwKSBhbmQgeDEoMClcbiAgICAgICAgICB3MSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIE1hdGguYWJzKHgxKGQpIC0geDEoMCkpIH07XG4gICAgICB2YXIgeHAwID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZCA8IDAgPyB4MChkKSA6IHgwKDApIH0sXG4gICAgICAgICAgeHAxID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZCA8IDAgPyB4MShkKSA6IHgxKDApIH07XG5cblxuICAgICAgZy5zZWxlY3QoJ3JlY3QubnYtcmFuZ2VNYXgnKVxuICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdzEocmFuZ2VNYXggPiAwID8gcmFuZ2VNYXggOiByYW5nZU1pbikpXG4gICAgICAgICAgLmF0dHIoJ3gnLCB4cDEocmFuZ2VNYXggPiAwID8gcmFuZ2VNYXggOiByYW5nZU1pbikpXG4gICAgICAgICAgLmRhdHVtKHJhbmdlTWF4ID4gMCA/IHJhbmdlTWF4IDogcmFuZ2VNaW4pXG4gICAgICAgICAgLypcbiAgICAgICAgICAuYXR0cigneCcsIHJhbmdlTWluIDwgMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VNYXggPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEocmFuZ2VNaW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6IHgxKHJhbmdlTWF4KVxuICAgICAgICAgICAgICAgICAgICAgICA6IHgxKDApKVxuICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgIGcuc2VsZWN0KCdyZWN0Lm52LXJhbmdlQXZnJylcbiAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHcxKHJhbmdlQXZnKSlcbiAgICAgICAgICAuYXR0cigneCcsIHhwMShyYW5nZUF2ZykpXG4gICAgICAgICAgLmRhdHVtKHJhbmdlQXZnKVxuICAgICAgICAgIC8qXG4gICAgICAgICAgLmF0dHIoJ3dpZHRoJywgcmFuZ2VNYXggPD0gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxKHJhbmdlTWF4KSAtIHgxKHJhbmdlQXZnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB4MShyYW5nZUF2ZykgLSB4MShyYW5nZU1pbikpXG4gICAgICAgICAgLmF0dHIoJ3gnLCByYW5nZU1heCA8PSAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICB4MShyYW5nZUF2ZylcbiAgICAgICAgICAgICAgICAgICAgICAgOiB4MShyYW5nZU1pbikpXG4gICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgZy5zZWxlY3QoJ3JlY3QubnYtcmFuZ2VNaW4nKVxuICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdzEocmFuZ2VNYXgpKVxuICAgICAgICAgIC5hdHRyKCd4JywgeHAxKHJhbmdlTWF4KSlcbiAgICAgICAgICAuYXR0cignd2lkdGgnLCB3MShyYW5nZU1heCA+IDAgPyByYW5nZU1pbiA6IHJhbmdlTWF4KSlcbiAgICAgICAgICAuYXR0cigneCcsIHhwMShyYW5nZU1heCA+IDAgPyByYW5nZU1pbiA6IHJhbmdlTWF4KSlcbiAgICAgICAgICAuZGF0dW0ocmFuZ2VNYXggPiAwID8gcmFuZ2VNaW4gOiByYW5nZU1heClcbiAgICAgICAgICAvKlxuICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHJhbmdlTWF4IDw9IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MShyYW5nZUF2ZykgLSB4MShyYW5nZU1pbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeDEocmFuZ2VNYXgpIC0geDEocmFuZ2VBdmcpKVxuICAgICAgICAgIC5hdHRyKCd4JywgcmFuZ2VNYXggPD0gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgeDEocmFuZ2VNaW4pXG4gICAgICAgICAgICAgICAgICAgICAgIDogeDEocmFuZ2VBdmcpKVxuICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgIGcuc2VsZWN0KCdyZWN0Lm52LW1lYXN1cmUnKVxuICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGNvbG9yKVxuICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQgLyAzKVxuICAgICAgICAgIC5hdHRyKCd5JywgYXZhaWxhYmxlSGVpZ2h0IC8gMylcbiAgICAgICAgICAuYXR0cignd2lkdGgnLCBtZWFzdXJleiA8IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSgwKSAtIHgxKG1lYXN1cmV6WzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB4MShtZWFzdXJlelswXSkgLSB4MSgwKSlcbiAgICAgICAgICAuYXR0cigneCcsIHhwMShtZWFzdXJleikpXG4gICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG1lYXN1cmV6WzBdLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBtZWFzdXJlTGFiZWx6WzBdIHx8ICdDdXJyZW50JyxcbiAgICAgICAgICAgICAgICBwb3M6IFt4MShtZWFzdXJlelswXSksIGF2YWlsYWJsZUhlaWdodC8yXVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBtZWFzdXJlelswXSxcbiAgICAgICAgICAgICAgICBsYWJlbDogbWVhc3VyZUxhYmVselswXSB8fCAnQ3VycmVudCdcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuXG4gICAgICB2YXIgaDMgPSAgYXZhaWxhYmxlSGVpZ2h0IC8gNjtcbiAgICAgIGlmIChtYXJrZXJ6WzBdKSB7XG4gICAgICAgIGcuc2VsZWN0QWxsKCdwYXRoLm52LW1hcmtlclRyaWFuZ2xlJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4MShtYXJrZXJ6WzBdKSArICcsJyArIChhdmFpbGFibGVIZWlnaHQgLyAyKSArICcpJyB9KVxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTTAsJyArIGgzICsgJ0wnICsgaDMgKyAnLCcgKyAoLWgzKSArICcgJyArICgtaDMpICsgJywnICsgKC1oMykgKyAnWicpXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWFya2VyelswXSxcbiAgICAgICAgICAgICAgICBsYWJlbDogbWFya2VyTGFiZWx6WzBdIHx8ICdQcmV2aW91cycsXG4gICAgICAgICAgICAgICAgcG9zOiBbeDEobWFya2VyelswXSksIGF2YWlsYWJsZUhlaWdodC8yXVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWFya2VyelswXSxcbiAgICAgICAgICAgICAgICBsYWJlbDogbWFya2VyTGFiZWx6WzBdIHx8ICdQcmV2aW91cydcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZy5zZWxlY3RBbGwoJ3BhdGgubnYtbWFya2VyVHJpYW5nbGUnKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuXG4gICAgICB3cmFwLnNlbGVjdEFsbCgnLm52LXJhbmdlJylcbiAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gcmFuZ2VMYWJlbHpbaV0gfHwgKCFpID8gXCJNYXhpbXVtXCIgOiBpID09IDEgPyBcIk1lYW5cIiA6IFwiTWluaW11bVwiKTtcblxuICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgIHZhbHVlOiBkLFxuICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICAgIHBvczogW3gxKGQpLCBhdmFpbGFibGVIZWlnaHQvMl1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSByYW5nZUxhYmVseltpXSB8fCAoIWkgPyBcIk1heGltdW1cIiA6IGkgPT0gMSA/IFwiTWVhblwiIDogXCJNaW5pbXVtXCIpO1xuXG4gICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICB2YWx1ZTogZCxcbiAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG5cbi8qIC8vIFRISVMgSVMgVEhFIFBSRVZJT1VTIEJVTExFVCBJTVBMRU1FTlRBVElPTiwgV0lMTCBSRU1PVkUgU0hPUlRMWVxuICAgICAgLy8gVXBkYXRlIHRoZSByYW5nZSByZWN0cy5cbiAgICAgIHZhciByYW5nZSA9IGcuc2VsZWN0QWxsKCdyZWN0Lm52LXJhbmdlJylcbiAgICAgICAgICAuZGF0YShyYW5nZXopO1xuXG4gICAgICByYW5nZS5lbnRlcigpLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gJ252LXJhbmdlIG52LXMnICsgaTsgfSlcbiAgICAgICAgICAuYXR0cignd2lkdGgnLCB3MClcbiAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgIC5hdHRyKCd4JywgcmV2ZXJzZSA/IHgwIDogMClcbiAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkgeyBcbiAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IChpIDw9IDApID8gJ01heGltdW0nIDogKGkgPiAxKSA/ICdNaW5pbXVtJyA6ICdNZWFuJywgLy9UT0RPOiBtYWtlIHRoZXNlIGxhYmVscyBhIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgcG9zOiBbeDEoZCksIGF2YWlsYWJsZUhlaWdodC8yXVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkgeyBcbiAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZCxcbiAgICAgICAgICAgICAgICBsYWJlbDogKGkgPD0gMCkgPyAnTWluaW11bScgOiAoaSA+PTEpID8gJ01heGltdW0nIDogJ01lYW4nIC8vVE9ETzogbWFrZSB0aGVzZSBsYWJlbHMgYSB2YXJpYWJsZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG5cbiAgICAgIGQzLnRyYW5zaXRpb24ocmFuZ2UpXG4gICAgICAgICAgLmF0dHIoJ3gnLCByZXZlcnNlID8geDEgOiAwKVxuICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHcxKVxuICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpO1xuXG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgbWVhc3VyZSByZWN0cy5cbiAgICAgIHZhciBtZWFzdXJlID0gZy5zZWxlY3RBbGwoJ3JlY3QubnYtbWVhc3VyZScpXG4gICAgICAgICAgLmRhdGEobWVhc3VyZXopO1xuXG4gICAgICBtZWFzdXJlLmVudGVyKCkuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiAnbnYtbWVhc3VyZSBudi1zJyArIGk7IH0pXG4gICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvcihkLGkgKSB9KVxuICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHcwKVxuICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQgLyAzKVxuICAgICAgICAgIC5hdHRyKCd4JywgcmV2ZXJzZSA/IHgwIDogMClcbiAgICAgICAgICAuYXR0cigneScsIGF2YWlsYWJsZUhlaWdodCAvIDMpXG4gICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7IFxuICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZCxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0N1cnJlbnQnLCAvL1RPRE86IG1ha2UgdGhlc2UgbGFiZWxzIGEgdmFyaWFibGVcbiAgICAgICAgICAgICAgICBwb3M6IFt4MShkKSwgYXZhaWxhYmxlSGVpZ2h0LzJdXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkgeyBcbiAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZCxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0N1cnJlbnQnIC8vVE9ETzogbWFrZSB0aGVzZSBsYWJlbHMgYSB2YXJpYWJsZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG5cbiAgICAgIGQzLnRyYW5zaXRpb24obWVhc3VyZSlcbiAgICAgICAgICAuYXR0cignd2lkdGgnLCB3MSlcbiAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0IC8gMylcbiAgICAgICAgICAuYXR0cigneCcsIHJldmVyc2UgPyB4MSA6IDApXG4gICAgICAgICAgLmF0dHIoJ3knLCBhdmFpbGFibGVIZWlnaHQgLyAzKTtcblxuXG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgbWFya2VyIGxpbmVzLlxuICAgICAgdmFyIG1hcmtlciA9IGcuc2VsZWN0QWxsKCdwYXRoLm52LW1hcmtlclRyaWFuZ2xlJylcbiAgICAgICAgICAuZGF0YShtYXJrZXJ6KTtcblxuICAgICAgdmFyIGgzID0gIGF2YWlsYWJsZUhlaWdodCAvIDY7XG4gICAgICBtYXJrZXIuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1tYXJrZXJUcmlhbmdsZScpXG4gICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgwKGQpICsgJywnICsgKGF2YWlsYWJsZUhlaWdodCAvIDIpICsgJyknIH0pXG4gICAgICAgICAgLmF0dHIoJ2QnLCAnTTAsJyArIGgzICsgJ0wnICsgaDMgKyAnLCcgKyAoLWgzKSArICcgJyArICgtaDMpICsgJywnICsgKC1oMykgKyAnWicpXG4gICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGQsXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdQcmV2aW91cycsXG4gICAgICAgICAgICAgICAgcG9zOiBbeDEoZCksIGF2YWlsYWJsZUhlaWdodC8yXVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnUHJldmlvdXMnXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG5cbiAgICAgIGQzLnRyYW5zaXRpb24obWFya2VyKVxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyAoeDEoZCkgLSB4MSgwKSkgKyAnLCcgKyAoYXZhaWxhYmxlSGVpZ2h0IC8gMikgKyAnKScgfSk7XG5cbiAgICAgIG1hcmtlci5leGl0KCkucmVtb3ZlKCk7XG4qL1xuXG4gICAgfSk7XG5cbiAgICAvLyBkMy50aW1lci5mbHVzaCgpOyAgLy8gTm90IG5lZWRlZD9cblxuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuXG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcbiAgXG4gIC8vIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbVxuICBjaGFydC5vcmllbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZW50O1xuICAgIG9yaWVudCA9IF87XG4gICAgcmV2ZXJzZSA9IG9yaWVudCA9PSAncmlnaHQnIHx8IG9yaWVudCA9PSAnYm90dG9tJztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgLy8gcmFuZ2VzIChiYWQsIHNhdGlzZmFjdG9yeSwgZ29vZClcbiAgY2hhcnQucmFuZ2VzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlcztcbiAgICByYW5nZXMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICAvLyBtYXJrZXJzIChwcmV2aW91cywgZ29hbClcbiAgY2hhcnQubWFya2VycyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJrZXJzO1xuICAgIG1hcmtlcnMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICAvLyBtZWFzdXJlcyAoYWN0dWFsLCBmb3JlY2FzdClcbiAgY2hhcnQubWVhc3VyZXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWVhc3VyZXM7XG4gICAgbWVhc3VyZXMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5mb3JjZVggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZm9yY2VYO1xuICAgIGZvcmNlWCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LndpZHRoID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgIHdpZHRoID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcbiAgICBoZWlnaHQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFyZ2luO1xuICAgIG1hcmdpbi50b3AgICAgPSB0eXBlb2YgXy50b3AgICAgIT0gJ3VuZGVmaW5lZCcgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRpY2tGb3JtYXQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0Zvcm1hdDtcbiAgICB0aWNrRm9ybWF0ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuY29sb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sb3I7XG4gICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIHJldHVybiBjaGFydDtcbn07XG5cblxuXG4vLyBDaGFydCBkZXNpZ24gYmFzZWQgb24gdGhlIHJlY29tbWVuZGF0aW9ucyBvZiBTdGVwaGVuIEZldy4gSW1wbGVtZW50YXRpb25cbi8vIGJhc2VkIG9uIHRoZSB3b3JrIG9mIENsaW50IEl2eSwgSmFtaWUgTG92ZSwgYW5kIEphc29uIERhdmllcy5cbi8vIGh0dHA6Ly9wcm9qZWN0cy5pbnN0YW50Y29nbml0aW9uLmNvbS9wcm90b3Zpcy9idWxsZXRjaGFydC9cbm52Lm1vZGVscy5idWxsZXRDaGFydCA9IGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgYnVsbGV0ID0gbnYubW9kZWxzLmJ1bGxldCgpXG4gICAgO1xuXG4gIHZhciBvcmllbnQgPSAnbGVmdCcgLy8gVE9ETyB0b3AgJiBib3R0b21cbiAgICAsIHJldmVyc2UgPSBmYWxzZVxuICAgICwgbWFyZ2luID0ge3RvcDogNSwgcmlnaHQ6IDQwLCBib3R0b206IDIwLCBsZWZ0OiAxMjB9XG4gICAgLCByYW5nZXMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnJhbmdlcyB9XG4gICAgLCBtYXJrZXJzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5tYXJrZXJzIH1cbiAgICAsIG1lYXN1cmVzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5tZWFzdXJlcyB9XG4gICAgLCB3aWR0aCA9IG51bGxcbiAgICAsIGhlaWdodCA9IDU1XG4gICAgLCB0aWNrRm9ybWF0ID0gbnVsbFxuICAgICwgdG9vbHRpcHMgPSB0cnVlXG4gICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xuICAgICAgICByZXR1cm4gJzxoMz4nICsgeCArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgJzxwPicgKyB5ICsgJzwvcD4nXG4gICAgICB9XG4gICAgLCBub0RhdGEgPSAnTm8gRGF0YSBBdmFpbGFibGUuJ1xuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnKVxuICAgIDtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG4gICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSArIG1hcmdpbi5sZWZ0LFxuICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCkgKyBtYXJnaW4udG9wLFxuICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLmtleSwgZS5sYWJlbCwgZS52YWx1ZSwgZSwgY2hhcnQpO1xuXG4gICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBlLnZhbHVlIDwgMCA/ICdlJyA6ICd3JywgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XG5cblxuICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNoYXJ0KHNlbGVjdGlvbikgfTtcbiAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBEaXNwbGF5IE5vIERhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cblxuICAgICAgaWYgKCFkIHx8ICFyYW5nZXMuY2FsbCh0aGlzLCBkLCBpKSkge1xuICAgICAgICB2YXIgbm9EYXRhVGV4dCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5kYXRhKFtub0RhdGFdKTtcblxuICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi1ub0RhdGEnKVxuICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAuYXR0cigneScsIDE4ICsgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXG4gICAgICB2YXIgcmFuZ2V6ID0gcmFuZ2VzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKS5zb3J0KGQzLmRlc2NlbmRpbmcpLFxuICAgICAgICAgIG1hcmtlcnogPSBtYXJrZXJzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKS5zb3J0KGQzLmRlc2NlbmRpbmcpLFxuICAgICAgICAgIG1lYXN1cmV6ID0gbWVhc3VyZXMuY2FsbCh0aGlzLCBkLCBpKS5zbGljZSgpLnNvcnQoZDMuZGVzY2VuZGluZyk7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWJ1bGxldENoYXJ0JykuZGF0YShbZF0pO1xuICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtYnVsbGV0Q2hhcnQnKTtcbiAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1idWxsZXRXcmFwJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtdGl0bGVzJyk7XG5cbiAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLyBDb21wdXRlIHRoZSBuZXcgeC1zY2FsZS5cbiAgICAgIHZhciB4MSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgLmRvbWFpbihbMCwgTWF0aC5tYXgocmFuZ2V6WzBdLCBtYXJrZXJ6WzBdLCBtZWFzdXJlelswXSldKSAgLy8gVE9ETzogbmVlZCB0byBhbGxvdyBmb3JjZVggYW5kIGZvcmNlWSwgYW5kIHhEb21haW4sIHlEb21haW5cbiAgICAgICAgICAucmFuZ2UocmV2ZXJzZSA/IFthdmFpbGFibGVXaWR0aCwgMF0gOiBbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgLy8gUmV0cmlldmUgdGhlIG9sZCB4LXNjYWxlLCBpZiB0aGlzIGlzIGFuIHVwZGF0ZS5cbiAgICAgIHZhciB4MCA9IHRoaXMuX19jaGFydF9fIHx8IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgLmRvbWFpbihbMCwgSW5maW5pdHldKVxuICAgICAgICAgIC5yYW5nZSh4MS5yYW5nZSgpKTtcblxuICAgICAgLy8gU3Rhc2ggdGhlIG5ldyBzY2FsZS5cbiAgICAgIHRoaXMuX19jaGFydF9fID0geDE7XG5cbiAgICAgIC8qXG4gICAgICAvLyBEZXJpdmUgd2lkdGgtc2NhbGVzIGZyb20gdGhlIHgtc2NhbGVzLlxuICAgICAgdmFyIHcwID0gYnVsbGV0V2lkdGgoeDApLFxuICAgICAgICAgIHcxID0gYnVsbGV0V2lkdGgoeDEpO1xuXG4gICAgICBmdW5jdGlvbiBidWxsZXRXaWR0aCh4KSB7XG4gICAgICAgIHZhciB4MCA9IHgoMCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHgoZCkgLSB4KDApKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYnVsbGV0VHJhbnNsYXRlKHgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeChkKSArICcsMCknO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgKi9cblxuICAgICAgdmFyIHcwID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gTWF0aC5hYnMoeDAoZCkgLSB4MCgwKSkgfSwgLy8gVE9ETzogY291bGQgb3B0aW1pemUgYnkgcHJlY2FsY3VsYXRpbmcgeDAoMCkgYW5kIHgxKDApXG4gICAgICAgICAgdzEgPSBmdW5jdGlvbihkKSB7IHJldHVybiBNYXRoLmFicyh4MShkKSAtIHgxKDApKSB9O1xuXG5cbiAgICAgIHZhciB0aXRsZSA9IGdFbnRlci5zZWxlY3QoJy5udi10aXRsZXMnKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC02LCcgKyAoaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pIC8gMiArICcpJyk7XG4gICAgICB0aXRsZS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi10aXRsZScpXG4gICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50aXRsZTsgfSk7XG5cbiAgICAgIHRpdGxlLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LXN1YnRpdGxlJylcbiAgICAgICAgICAuYXR0cignZHknLCAnMWVtJylcbiAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkLnN1YnRpdGxlOyB9KTtcblxuXG5cbiAgICAgIGJ1bGxldFxuICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuXG4gICAgICB2YXIgYnVsbGV0V3JhcCA9IGcuc2VsZWN0KCcubnYtYnVsbGV0V3JhcCcpO1xuXG4gICAgICBkMy50cmFuc2l0aW9uKGJ1bGxldFdyYXApLmNhbGwoYnVsbGV0KTtcblxuXG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHRpY2sgZm9ybWF0LlxuICAgICAgdmFyIGZvcm1hdCA9IHRpY2tGb3JtYXQgfHwgeDEudGlja0Zvcm1hdCggYXZhaWxhYmxlV2lkdGggLyAxMDAgKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSB0aWNrIGdyb3Vwcy5cbiAgICAgIHZhciB0aWNrID0gZy5zZWxlY3RBbGwoJ2cubnYtdGljaycpXG4gICAgICAgICAgLmRhdGEoeDEudGlja3MoIGF2YWlsYWJsZVdpZHRoIC8gNTAgKSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dENvbnRlbnQgfHwgZm9ybWF0KGQpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAvLyBJbml0aWFsaXplIHRoZSB0aWNrcyB3aXRoIHRoZSBvbGQgc2NhbGUsIHgwLlxuICAgICAgdmFyIHRpY2tFbnRlciA9IHRpY2suZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi10aWNrJylcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeDAoZCkgKyAnLDApJyB9KVxuICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpO1xuXG4gICAgICB0aWNrRW50ZXIuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgICAuYXR0cigneTEnLCBhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgLmF0dHIoJ3kyJywgYXZhaWxhYmxlSGVpZ2h0ICogNyAvIDYpO1xuXG4gICAgICB0aWNrRW50ZXIuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAgICAgICAuYXR0cignZHknLCAnMWVtJylcbiAgICAgICAgICAuYXR0cigneScsIGF2YWlsYWJsZUhlaWdodCAqIDcgLyA2KVxuICAgICAgICAgIC50ZXh0KGZvcm1hdCk7XG5cblxuICAgICAgLy8gVHJhbnNpdGlvbiB0aGUgdXBkYXRpbmcgdGlja3MgdG8gdGhlIG5ldyBzY2FsZSwgeDEuXG4gICAgICB2YXIgdGlja1VwZGF0ZSA9IGQzLnRyYW5zaXRpb24odGljaylcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeDEoZCkgKyAnLDApJyB9KVxuICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xuXG4gICAgICB0aWNrVXBkYXRlLnNlbGVjdCgnbGluZScpXG4gICAgICAgICAgLmF0dHIoJ3kxJywgYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgIC5hdHRyKCd5MicsIGF2YWlsYWJsZUhlaWdodCAqIDcgLyA2KTtcblxuICAgICAgdGlja1VwZGF0ZS5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgIC5hdHRyKCd5JywgYXZhaWxhYmxlSGVpZ2h0ICogNyAvIDYpO1xuXG4gICAgICAvLyBUcmFuc2l0aW9uIHRoZSBleGl0aW5nIHRpY2tzIHRvIHRoZSBuZXcgc2NhbGUsIHgxLlxuICAgICAgZDMudHJhbnNpdGlvbih0aWNrLmV4aXQoKSlcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeDEoZCkgKyAnLDApJyB9KVxuICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgLnJlbW92ZSgpO1xuXG5cbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5rZXkgPSBkLnRpdGxlO1xuICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICB9KTtcblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIH0pO1xuXG4gICAgZDMudGltZXIuZmx1c2goKTtcblxuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGJ1bGxldC5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICB9KTtcblxuICBidWxsZXQuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICB9KTtcblxuICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICB9KTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICBjaGFydC5idWxsZXQgPSBidWxsZXQ7XG5cbiAgZDMucmViaW5kKGNoYXJ0LCBidWxsZXQsICdjb2xvcicpO1xuXG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcbiAgXG4gIC8vIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbVxuICBjaGFydC5vcmllbnQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZW50O1xuICAgIG9yaWVudCA9IHg7XG4gICAgcmV2ZXJzZSA9IG9yaWVudCA9PSAncmlnaHQnIHx8IG9yaWVudCA9PSAnYm90dG9tJztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgLy8gcmFuZ2VzIChiYWQsIHNhdGlzZmFjdG9yeSwgZ29vZClcbiAgY2hhcnQucmFuZ2VzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlcztcbiAgICByYW5nZXMgPSB4O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICAvLyBtYXJrZXJzIChwcmV2aW91cywgZ29hbClcbiAgY2hhcnQubWFya2VycyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJrZXJzO1xuICAgIG1hcmtlcnMgPSB4O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICAvLyBtZWFzdXJlcyAoYWN0dWFsLCBmb3JlY2FzdClcbiAgY2hhcnQubWVhc3VyZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWVhc3VyZXM7XG4gICAgbWVhc3VyZXMgPSB4O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICB3aWR0aCA9IHg7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0geDtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50aWNrRm9ybWF0ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tGb3JtYXQ7XG4gICAgdGlja0Zvcm1hdCA9IHg7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXBzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXBzO1xuICAgIHRvb2x0aXBzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcDtcbiAgICB0b29sdGlwID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQubm9EYXRhID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vRGF0YTtcbiAgICBub0RhdGEgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgcmV0dXJuIGNoYXJ0O1xufTtcblxuXG5cbm52Lm1vZGVscy5jdW11bGF0aXZlTGluZUNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBsaW5lcyA9IG52Lm1vZGVscy5saW5lKClcbiAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICwgeUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAsIGNvbnRyb2xzID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgLCBpbnRlcmFjdGl2ZUxheWVyID0gbnYuaW50ZXJhY3RpdmVHdWlkZWxpbmUoKVxuICAgIDtcblxuICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAzMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9XG4gICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgLCB3aWR0aCA9IG51bGxcbiAgICAsIGhlaWdodCA9IG51bGxcbiAgICAsIHNob3dMZWdlbmQgPSB0cnVlXG4gICAgLCBzaG93WEF4aXMgPSB0cnVlXG4gICAgLCBzaG93WUF4aXMgPSB0cnVlXG4gICAgLCByaWdodEFsaWduWUF4aXMgPSBmYWxzZVxuICAgICwgdG9vbHRpcHMgPSB0cnVlXG4gICAgLCBzaG93Q29udHJvbHMgPSB0cnVlXG4gICAgLCB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IGZhbHNlXG4gICAgLCByZXNjYWxlWSA9IHRydWVcbiAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgIHJldHVybiAnPGgzPicgKyBrZXkgKyAnPC9oMz4nICtcbiAgICAgICAgICAgICAgICc8cD4nICsgIHkgKyAnIGF0ICcgKyB4ICsgJzwvcD4nXG4gICAgICB9XG4gICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxuICAgICwgeSAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueVNjYWxlKClcbiAgICAsIGlkID0gbGluZXMuaWQoKVxuICAgICwgc3RhdGUgPSB7IGluZGV4OiAwLCByZXNjYWxlWTogcmVzY2FsZVkgfVxuICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICwgbm9EYXRhID0gJ05vIERhdGEgQXZhaWxhYmxlLidcbiAgICAsIGF2ZXJhZ2UgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLmF2ZXJhZ2UgfVxuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnKVxuICAgICwgdHJhbnNpdGlvbkR1cmF0aW9uID0gMjUwXG4gICAgLCBub0Vycm9yQ2hlY2sgPSBmYWxzZSAgLy9pZiBzZXQgdG8gVFJVRSwgd2lsbCBieXBhc3MgYW4gZXJyb3IgY2hlY2sgaW4gdGhlIGluZGV4aWZ5IGZ1bmN0aW9uLlxuICAgIDtcblxuICB4QXhpc1xuICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgLnRpY2tQYWRkaW5nKDcpXG4gICAgO1xuICB5QXhpc1xuICAgIC5vcmllbnQoKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgIDtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb250cm9scy51cGRhdGVTdGF0ZShmYWxzZSk7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgdmFyIGR4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgLCBpbmRleCA9IHtpOiAwLCB4OiAwfVxuICAgICA7XG5cbiAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgeCA9IHhBeGlzLnRpY2tGb3JtYXQoKShsaW5lcy54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgIHkgPSB5QXhpcy50aWNrRm9ybWF0KCkobGluZXMueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgbnVsbCwgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ252LWNoYXJ0LScgKyBpZCwgdHJ1ZSksXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cblxuICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGNoYXJ0KSB9O1xuICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgLy9zZXQgc3RhdGUuZGlzYWJsZWRcbiAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXhEcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ2RyYWdzdGFydCcsIGRyYWdTdGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignZHJhZycsIGRyYWdNb3ZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdkcmFnZW5kJywgZHJhZ0VuZCk7XG5cblxuICAgICAgZnVuY3Rpb24gZHJhZ1N0YXJ0KGQsaSkge1xuICAgICAgICBkMy5zZWxlY3QoY2hhcnQuY29udGFpbmVyKVxuICAgICAgICAgICAgLnN0eWxlKCdjdXJzb3InLCAnZXctcmVzaXplJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRyYWdNb3ZlKGQsaSkge1xuICAgICAgICBpbmRleC54ID0gZDMuZXZlbnQueDtcbiAgICAgICAgaW5kZXguaSA9IE1hdGgucm91bmQoZHguaW52ZXJ0KGluZGV4LngpKTtcbiAgICAgICAgdXBkYXRlWmVybygpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkcmFnRW5kKGQsaSkge1xuICAgICAgICBkMy5zZWxlY3QoY2hhcnQuY29udGFpbmVyKVxuICAgICAgICAgICAgLnN0eWxlKCdjdXJzb3InLCAnYXV0bycpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBzdGF0ZSBhbmQgc2VuZCBzdGF0ZUNoYW5nZSB3aXRoIG5ldyBpbmRleFxuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4Lmk7XG4gICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIFNjYWxlc1xuXG4gICAgICB4ID0gbGluZXMueFNjYWxlKCk7XG4gICAgICB5ID0gbGluZXMueVNjYWxlKCk7XG5cblxuICAgICAgaWYgKCFyZXNjYWxlWSkge1xuICAgICAgICB2YXIgc2VyaWVzRG9tYWlucyA9IGRhdGFcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcykgeyByZXR1cm4gIXNlcmllcy5kaXNhYmxlZCB9KVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgIHZhciBpbml0aWFsRG9tYWluID0gZDMuZXh0ZW50KHNlcmllcy52YWx1ZXMsIGxpbmVzLnkoKSk7XG5cbiAgICAgICAgICAgIC8vYWNjb3VudCBmb3Igc2VyaWVzIGJlaW5nIGRpc2FibGVkIHdoZW4gbG9zaW5nIDk1JSBvciBtb3JlXG4gICAgICAgICAgICBpZiAoaW5pdGlhbERvbWFpblswXSA8IC0uOTUpIGluaXRpYWxEb21haW5bMF0gPSAtLjk1O1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAoaW5pdGlhbERvbWFpblswXSAtIGluaXRpYWxEb21haW5bMV0pIC8gKDEgKyBpbml0aWFsRG9tYWluWzFdKSxcbiAgICAgICAgICAgICAgKGluaXRpYWxEb21haW5bMV0gLSBpbml0aWFsRG9tYWluWzBdKSAvICgxICsgaW5pdGlhbERvbWFpblswXSlcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNvbXBsZXRlRG9tYWluID0gW1xuICAgICAgICAgIGQzLm1pbihzZXJpZXNEb21haW5zLCBmdW5jdGlvbihkKSB7IHJldHVybiBkWzBdIH0pLFxuICAgICAgICAgIGQzLm1heChzZXJpZXNEb21haW5zLCBmdW5jdGlvbihkKSB7IHJldHVybiBkWzFdIH0pXG4gICAgICAgIF1cblxuICAgICAgICBsaW5lcy55RG9tYWluKGNvbXBsZXRlRG9tYWluKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmVzLnlEb21haW4obnVsbCk7XG4gICAgICB9XG5cblxuICAgICAgZHggIC5kb21haW4oWzAsIGRhdGFbMF0udmFsdWVzLmxlbmd0aCAtIDFdKSAvL0Fzc3VtZXMgYWxsIHNlcmllcyBoYXZlIHNhbWUgbGVuZ3RoXG4gICAgICAgICAgLnJhbmdlKFswLCBhdmFpbGFibGVXaWR0aF0pXG4gICAgICAgICAgLmNsYW1wKHRydWUpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIHZhciBkYXRhID0gaW5kZXhpZnkoaW5kZXguaSwgZGF0YSk7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICB2YXIgaW50ZXJhY3RpdmVQb2ludGVyRXZlbnRzID0gKHVzZUludGVyYWN0aXZlR3VpZGVsaW5lKSA/IFwibm9uZVwiIDogXCJhbGxcIjtcbiAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWN1bXVsYXRpdmVMaW5lJykuZGF0YShbZGF0YV0pO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtY3VtdWxhdGl2ZUxpbmUnKS5hcHBlbmQoJ2cnKTtcbiAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWludGVyYWN0aXZlJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJykuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLFwibm9uZVwiKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1iYWNrZ3JvdW5kJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGluZXNXcmFwJykuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLGludGVyYWN0aXZlUG9pbnRlckV2ZW50cyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYXZnTGluZXNXcmFwJykuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLFwibm9uZVwiKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtY29udHJvbHNXcmFwJyk7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIExlZ2VuZFxuXG4gICAgICBpZiAoc2hvd0xlZ2VuZCkge1xuICAgICAgICBsZWdlbmQud2lkdGgoYXZhaWxhYmxlV2lkdGgpO1xuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAuZGF0dW0oZGF0YSlcbiAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgaWYgKCBtYXJnaW4udG9wICE9IGxlZ2VuZC5oZWlnaHQoKSkge1xuICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgICAgIH1cblxuICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKVxuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBDb250cm9sc1xuXG4gICAgICBpZiAoc2hvd0NvbnRyb2xzKSB7XG4gICAgICAgIHZhciBjb250cm9sc0RhdGEgPSBbXG4gICAgICAgICAgeyBrZXk6ICdSZS1zY2FsZSB5LWF4aXMnLCBkaXNhYmxlZDogIXJlc2NhbGVZIH1cbiAgICAgICAgXTtcblxuICAgICAgICBjb250cm9sc1xuICAgICAgICAgICAgLndpZHRoKDE0MClcbiAgICAgICAgICAgIC5jb2xvcihbJyM0NDQnLCAnIzQ0NCcsICcjNDQ0J10pXG4gICAgICAgICAgICAucmlnaHRBbGlnbihmYWxzZSlcbiAgICAgICAgICAgIC5tYXJnaW4oe3RvcDogNSwgcmlnaHQ6IDAsIGJvdHRvbTogNSwgbGVmdDogMjB9KVxuICAgICAgICAgICAgO1xuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtY29udHJvbHNXcmFwJylcbiAgICAgICAgICAgIC5kYXR1bShjb250cm9sc0RhdGEpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoLW1hcmdpbi50b3ApICsnKScpXG4gICAgICAgICAgICAuY2FsbChjb250cm9scyk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2hvdyBlcnJvciBpZiBzZXJpZXMgZ29lcyBiZWxvdyAxMDAlXG4gICAgICB2YXIgdGVtcERpc2FibGVkID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50ZW1wRGlzYWJsZWQgfSk7XG5cbiAgICAgIHdyYXAuc2VsZWN0KCcudGVtcERpc2FibGVkJykucmVtb3ZlKCk7IC8vY2xlYW4tdXAgYW5kIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgaWYgKHRlbXBEaXNhYmxlZC5sZW5ndGgpIHtcbiAgICAgICAgd3JhcC5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICd0ZW1wRGlzYWJsZWQnKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAuYXR0cigneScsICctLjcxZW0nKVxuICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxuICAgICAgICAgICAgLnRleHQodGVtcERpc2FibGVkLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLmtleSB9KS5qb2luKCcsICcpICsgJyB2YWx1ZXMgY2Fubm90IGJlIGNhbGN1bGF0ZWQgZm9yIHRoaXMgdGltZSBwZXJpb2QuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy9TZXQgdXAgaW50ZXJhY3RpdmUgbGF5ZXJcbiAgICAgIGlmICh1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSkge1xuICAgICAgICBpbnRlcmFjdGl2ZUxheWVyXG4gICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgIC5tYXJnaW4oe2xlZnQ6bWFyZ2luLmxlZnQsdG9wOm1hcmdpbi50b3B9KVxuICAgICAgICAgIC5zdmdDb250YWluZXIoY29udGFpbmVyKVxuICAgICAgICAgIC54U2NhbGUoeCk7XG4gICAgICAgIHdyYXAuc2VsZWN0KFwiLm52LWludGVyYWN0aXZlXCIpLmNhbGwoaW50ZXJhY3RpdmVMYXllcik7XG4gICAgICB9XG5cbiAgICAgIGdFbnRlci5zZWxlY3QoJy5udi1iYWNrZ3JvdW5kJylcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpO1xuXG4gICAgICBnLnNlbGVjdCgnLm52LWJhY2tncm91bmQgcmVjdCcpXG4gICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgIGxpbmVzXG4gICAgICAgIC8vLngoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0pXG4gICAgICAgIC55KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuZGlzcGxheS55IH0pXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgIWRhdGFbaV0udGVtcERpc2FibGVkOyB9KSk7XG5cblxuXG4gICAgICB2YXIgbGluZXNXcmFwID0gZy5zZWxlY3QoJy5udi1saW5lc1dyYXAnKVxuICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAgIWQuZGlzYWJsZWQgJiYgIWQudGVtcERpc2FibGVkIH0pKTtcblxuICAgICAgLy9kMy50cmFuc2l0aW9uKGxpbmVzV3JhcCkuY2FsbChsaW5lcyk7XG4gICAgICBsaW5lc1dyYXAuY2FsbChsaW5lcyk7XG5cbiAgICAgIC8qSGFuZGxlIGF2ZXJhZ2UgbGluZXMgW0FOLTYxMl0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgIC8vU3RvcmUgYSBzZXJpZXMgaW5kZXggbnVtYmVyIGluIHRoZSBkYXRhIGFycmF5LlxuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgZC5zZXJpZXNJbmRleCA9IGk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGF2Z0xpbmVEYXRhID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiAhZC5kaXNhYmxlZCAmJiAhIWF2ZXJhZ2UoZCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGF2Z0xpbmVzID0gZy5zZWxlY3QoXCIubnYtYXZnTGluZXNXcmFwXCIpLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgICAgLmRhdGEoYXZnTGluZURhdGEsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQua2V5OyB9KTtcblxuICAgICAgdmFyIGdldEF2Z0xpbmVZID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgIC8vSWYgYXZlcmFnZSBsaW5lcyBnbyBvZmYgdGhlIHN2ZyBlbGVtZW50LCBjbGFtcCB0aGVtIHRvIHRoZSBzdmcgYm91bmRzLlxuICAgICAgICAgIHZhciB5VmFsID0geShhdmVyYWdlKGQpKTtcbiAgICAgICAgICBpZiAoeVZhbCA8IDApIHJldHVybiAwO1xuICAgICAgICAgIGlmICh5VmFsID4gYXZhaWxhYmxlSGVpZ2h0KSByZXR1cm4gYXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICAgIHJldHVybiB5VmFsO1xuICAgICAgfTtcblxuICAgICAgYXZnTGluZXMuZW50ZXIoKVxuICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLDIpXG4gICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScsJzEwLDEwJylcbiAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLGZ1bmN0aW9uIChkLGkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lcy5jb2xvcigpKGQsZC5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5hdHRyKCd4MScsMClcbiAgICAgICAgICAgICAgLmF0dHIoJ3gyJyxhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZ2V0QXZnTGluZVkpXG4gICAgICAgICAgICAgIC5hdHRyKCd5MicsIGdldEF2Z0xpbmVZKTtcblxuICAgICAgYXZnTGluZXNcbiAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgICAgICAvL0lmIGF2ZXJhZ2UgbGluZXMgZ28gb2Zmc2NyZWVuLCBtYWtlIHRoZW0gdHJhbnNwYXJlbnRcbiAgICAgICAgICAgICAgICAgIHZhciB5VmFsID0geShhdmVyYWdlKGQpKTtcbiAgICAgICAgICAgICAgICAgIGlmICh5VmFsIDwgMCB8fCB5VmFsID4gYXZhaWxhYmxlSGVpZ2h0KSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuYXR0cigneDEnLDApXG4gICAgICAgICAgICAgIC5hdHRyKCd4MicsYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgIC5hdHRyKCd5MScsIGdldEF2Z0xpbmVZKVxuICAgICAgICAgICAgICAuYXR0cigneTInLCBnZXRBdmdMaW5lWSk7XG5cbiAgICAgIGF2Z0xpbmVzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgLy9DcmVhdGUgaW5kZXggbGluZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICB2YXIgaW5kZXhMaW5lID0gbGluZXNXcmFwLnNlbGVjdEFsbCgnLm52LWluZGV4TGluZScpXG4gICAgICAgICAgLmRhdGEoW2luZGV4XSk7XG4gICAgICBpbmRleExpbmUuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKS5hdHRyKCdjbGFzcycsICdudi1pbmRleExpbmUnKVxuICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDMpXG4gICAgICAgICAgLmF0dHIoJ3gnLCAtMilcbiAgICAgICAgICAuYXR0cignZmlsbCcsICdyZWQnKVxuICAgICAgICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCAuNSlcbiAgICAgICAgICAuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLFwiYWxsXCIpXG4gICAgICAgICAgLmNhbGwoaW5kZXhEcmFnKVxuXG4gICAgICBpbmRleExpbmVcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgZHgoZC5pKSArICcsMCknIH0pXG4gICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodClcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgQXhlc1xuXG4gICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgIHhBeGlzXG4gICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgLy9TdWdnZXN0IGhvdyBtYW55IHRpY2tzIGJhc2VkIG9uIHRoZSBjaGFydCB3aWR0aCBhbmQgRDMgc2hvdWxkIGxpc3RlbiAoNzAgaXMgdGhlIG9wdGltYWwgbnVtYmVyIGZvciBNTS9ERC9ZWSBkYXRlcylcbiAgICAgICAgICAudGlja3MoIE1hdGgubWluKGRhdGFbMF0udmFsdWVzLmxlbmd0aCxhdmFpbGFibGVXaWR0aC83MCkgKVxuICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcblxuICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB5LnJhbmdlKClbMF0gKyAnKScpO1xuICAgICAgICBkMy50cmFuc2l0aW9uKGcuc2VsZWN0KCcubnYteC5udi1heGlzJykpXG4gICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICB9XG5cblxuICAgICAgaWYgKHNob3dZQXhpcykge1xuICAgICAgICB5QXhpc1xuICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgIC50aWNrcyggYXZhaWxhYmxlSGVpZ2h0IC8gMzYgKVxuICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgICBkMy50cmFuc2l0aW9uKGcuc2VsZWN0KCcubnYteS5udi1heGlzJykpXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICB9XG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlWmVybygpIHtcbiAgICAgICAgaW5kZXhMaW5lXG4gICAgICAgICAgLmRhdGEoW2luZGV4XSk7XG5cbiAgICAgICAgLy9XaGVuIGRyYWdnaW5nIHRoZSBpbmRleCBsaW5lLCB0dXJuIG9mZiBsaW5lIHRyYW5zaXRpb25zLlxuICAgICAgICAvLyBUaGVuIHR1cm4gdGhlbSBiYWNrIG9uIHdoZW4gZG9uZSBkcmFnZ2luZy5cbiAgICAgICAgdmFyIG9sZER1cmF0aW9uID0gY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKCk7XG4gICAgICAgIGNoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigwKTtcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgIGNoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbihvbGREdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGcuc2VsZWN0KCcubnYtYmFja2dyb3VuZCByZWN0JylcbiAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbmRleC54ID0gZDMubW91c2UodGhpcylbMF07XG4gICAgICAgICAgICBpbmRleC5pID0gTWF0aC5yb3VuZChkeC5pbnZlcnQoaW5kZXgueCkpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgc3RhdGUgYW5kIHNlbmQgc3RhdGVDaGFuZ2Ugd2l0aCBuZXcgaW5kZXhcbiAgICAgICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXguaTtcbiAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcblxuICAgICAgICAgICAgdXBkYXRlWmVybygpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudENsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpbmRleC5pID0gZS5wb2ludEluZGV4O1xuICAgICAgICBpbmRleC54ID0gZHgoaW5kZXguaSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHN0YXRlIGFuZCBzZW5kIHN0YXRlQ2hhbmdlIHdpdGggbmV3IGluZGV4XG4gICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXguaTtcbiAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuXG4gICAgICAgIHVwZGF0ZVplcm8oKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb250cm9scy5kaXNwYXRjaC5vbignbGVnZW5kQ2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgZC5kaXNhYmxlZCA9ICFkLmRpc2FibGVkO1xuICAgICAgICByZXNjYWxlWSA9ICFkLmRpc2FibGVkO1xuXG4gICAgICAgIHN0YXRlLnJlc2NhbGVZID0gcmVzY2FsZVk7XG4gICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuXG4gICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBuZXdTdGF0ZS5kaXNhYmxlZDtcbiAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGxpbmVzLmNsZWFySGlnaGxpZ2h0cygpO1xuICAgICAgICAgIHZhciBzaW5nbGVQb2ludCwgcG9pbnRJbmRleCwgcG9pbnRYTG9jYXRpb24sIGFsbERhdGEgPSBbXTtcblxuXG4gICAgICAgICAgZGF0YVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oc2VyaWVzLCBpKSB7XG4gICAgICAgICAgICBzZXJpZXMuc2VyaWVzSW5kZXggPSBpO1xuICAgICAgICAgICAgcmV0dXJuICFzZXJpZXMuZGlzYWJsZWQ7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICBwb2ludEluZGV4ID0gbnYuaW50ZXJhY3RpdmVCaXNlY3Qoc2VyaWVzLnZhbHVlcywgZS5wb2ludFhWYWx1ZSwgY2hhcnQueCgpKTtcbiAgICAgICAgICAgICAgbGluZXMuaGlnaGxpZ2h0UG9pbnQoaSwgcG9pbnRJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHZhciBwb2ludCA9IHNlcmllcy52YWx1ZXNbcG9pbnRJbmRleF07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2luZ2xlUG9pbnQgPT09ICd1bmRlZmluZWQnKSBzaW5nbGVQb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50WExvY2F0aW9uID09PSAndW5kZWZpbmVkJykgcG9pbnRYTG9jYXRpb24gPSBjaGFydC54U2NhbGUoKShjaGFydC54KCkocG9pbnQscG9pbnRJbmRleCkpO1xuICAgICAgICAgICAgICBhbGxEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAga2V5OiBzZXJpZXMua2V5LFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYXJ0LnkoKShwb2ludCwgcG9pbnRJbmRleCksXG4gICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3Ioc2VyaWVzLHNlcmllcy5zZXJpZXNJbmRleClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvL0hpZ2hsaWdodCB0aGUgdG9vbHRpcCBlbnRyeSBiYXNlZCBvbiB3aGljaCBwb2ludCB0aGUgbW91c2UgaXMgY2xvc2VzdCB0by5cbiAgICAgICAgICBpZiAoYWxsRGF0YS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgeVZhbHVlID0gY2hhcnQueVNjYWxlKCkuaW52ZXJ0KGUubW91c2VZKTtcbiAgICAgICAgICAgIHZhciBkb21haW5FeHRlbnQgPSBNYXRoLmFicyhjaGFydC55U2NhbGUoKS5kb21haW4oKVswXSAtIGNoYXJ0LnlTY2FsZSgpLmRvbWFpbigpWzFdKTtcbiAgICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjAzICogZG9tYWluRXh0ZW50O1xuICAgICAgICAgICAgdmFyIGluZGV4VG9IaWdobGlnaHQgPSBudi5uZWFyZXN0VmFsdWVJbmRleChhbGxEYXRhLm1hcChmdW5jdGlvbihkKXtyZXR1cm4gZC52YWx1ZX0pLHlWYWx1ZSx0aHJlc2hvbGQpO1xuICAgICAgICAgICAgaWYgKGluZGV4VG9IaWdobGlnaHQgIT09IG51bGwpXG4gICAgICAgICAgICAgIGFsbERhdGFbaW5kZXhUb0hpZ2hsaWdodF0uaGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgeFZhbHVlID0geEF4aXMudGlja0Zvcm1hdCgpKGNoYXJ0LngoKShzaW5nbGVQb2ludCxwb2ludEluZGV4KSwgcG9pbnRJbmRleCk7XG4gICAgICAgICAgaW50ZXJhY3RpdmVMYXllci50b29sdGlwXG4gICAgICAgICAgICAgICAgICAucG9zaXRpb24oe2xlZnQ6IHBvaW50WExvY2F0aW9uICsgbWFyZ2luLmxlZnQsIHRvcDogZS5tb3VzZVkgKyBtYXJnaW4udG9wfSlcbiAgICAgICAgICAgICAgICAgIC5jaGFydENvbnRhaW5lcih0aGF0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAuZW5hYmxlZCh0b29sdGlwcylcbiAgICAgICAgICAgICAgICAgIC52YWx1ZUZvcm1hdHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5QXhpcy50aWNrRm9ybWF0KCkoZCk7XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgLmRhdGEoXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHhWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogYWxsRGF0YVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICkoKTtcblxuICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIucmVuZGVyR3VpZGVMaW5lKHBvaW50WExvY2F0aW9uKTtcblxuICAgICAgfSk7XG5cbiAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oXCJlbGVtZW50TW91c2VvdXRcIixmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoKTtcbiAgICAgICAgICBsaW5lcy5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgIH0pO1xuXG4gICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgc2hvd1Rvb2x0aXAoZSwgdGhhdC5wYXJlbnROb2RlKTtcbiAgICAgIH0pO1xuXG5cbiAgICAgIC8vIFVwZGF0ZSBjaGFydCBmcm9tIGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0byBldmVudCBoYW5kbGVyXG4gICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBlLmluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGluZGV4LmkgPSBlLmluZGV4O1xuICAgICAgICAgIGluZGV4LnggPSBkeChpbmRleC5pKTtcblxuICAgICAgICAgIHN0YXRlLmluZGV4ID0gZS5pbmRleDtcblxuICAgICAgICAgIGluZGV4TGluZVxuICAgICAgICAgICAgLmRhdGEoW2luZGV4XSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0eXBlb2YgZS5yZXNjYWxlWSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXNjYWxlWSA9IGUucmVzY2FsZVk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICB9KTtcblxuICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gIH0pO1xuXG4gIGRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gIH0pO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gIGNoYXJ0LmxpbmVzID0gbGluZXM7XG4gIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbiAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgY2hhcnQuaW50ZXJhY3RpdmVMYXllciA9IGludGVyYWN0aXZlTGF5ZXI7XG5cbiAgZDMucmViaW5kKGNoYXJ0LCBsaW5lcywgJ2RlZmluZWQnLCAnaXNBcmVhJywgJ3gnLCAneScsICd4U2NhbGUnLCd5U2NhbGUnLCAnc2l6ZScsICd4RG9tYWluJywgJ3lEb21haW4nLCAneFJhbmdlJywgJ3lSYW5nZScsICdmb3JjZVgnLCAnZm9yY2VZJywgJ2ludGVyYWN0aXZlJywgJ2NsaXBFZGdlJywgJ2NsaXBWb3Jvbm9pJywndXNlVm9yb25vaScsICAnaWQnKTtcblxuICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICB3aWR0aCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuY29sb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sb3I7XG4gICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5yZXNjYWxlWSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByZXNjYWxlWTtcbiAgICByZXNjYWxlWSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dDb250cm9scyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93Q29udHJvbHM7XG4gICAgc2hvd0NvbnRyb2xzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZTtcbiAgICB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IF87XG4gICAgaWYgKF8gPT09IHRydWUpIHtcbiAgICAgICBjaGFydC5pbnRlcmFjdGl2ZShmYWxzZSk7XG4gICAgICAgY2hhcnQudXNlVm9yb25vaShmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93TGVnZW5kID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dMZWdlbmQ7XG4gICAgc2hvd0xlZ2VuZCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dYQXhpcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93WEF4aXM7XG4gICAgc2hvd1hBeGlzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd1lBeGlzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dZQXhpcztcbiAgICBzaG93WUF4aXMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5yaWdodEFsaWduWUF4aXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByaWdodEFsaWduWUF4aXM7XG4gICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50b29sdGlwcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0b29sdGlwcztcbiAgICB0b29sdGlwcyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXBDb250ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXA7XG4gICAgdG9vbHRpcCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnN0YXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXRlO1xuICAgIHN0YXRlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuZGVmYXVsdFN0YXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRlZmF1bHRTdGF0ZTtcbiAgICBkZWZhdWx0U3RhdGUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5ub0RhdGEgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9EYXRhO1xuICAgIG5vRGF0YSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmF2ZXJhZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYXZlcmFnZTtcbiAgICAgYXZlcmFnZSA9IF87XG4gICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50cmFuc2l0aW9uRHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0Lm5vRXJyb3JDaGVjayA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub0Vycm9yQ2hlY2s7XG4gICAgbm9FcnJvckNoZWNrID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEZ1bmN0aW9uc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qIE5vcm1hbGl6ZSB0aGUgZGF0YSBhY2NvcmRpbmcgdG8gYW4gaW5kZXggcG9pbnQuICovXG4gIGZ1bmN0aW9uIGluZGV4aWZ5KGlkeCwgZGF0YSkge1xuICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbihsaW5lLCBpKSB7XG4gICAgICBpZiAoIWxpbmUudmFsdWVzKSB7XG4gICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgIH1cbiAgICAgIHZhciB2ID0gbGluZXMueSgpKGxpbmUudmFsdWVzW2lkeF0sIGlkeCk7XG5cbiAgICAgIC8vVE9ETzogaW1wbGVtZW50IGNoZWNrIGJlbG93LCBhbmQgZGlzYWJsZSBzZXJpZXMgaWYgc2VyaWVzIGxvc2VzIDEwMCUgb3IgbW9yZSBjYXVzZSBkaXZpZGUgYnkgMCBpc3N1ZVxuICAgICAgaWYgKHYgPCAtLjk1ICYmICFub0Vycm9yQ2hlY2spIHtcbiAgICAgICAgLy9pZiBhIHNlcmllcyBsb3NlcyBtb3JlIHRoYW4gMTAwJSwgY2FsY3VsYXRpb25zIGZhaWwuLiBhbnl0aGluZyBjbG9zZSBjYW4gY2F1c2UgbWFqb3IgZGlzdG9ydGlvbiAoYnV0IGlzIG1hdGhlbWF0aWNhbGx5IGNvcnJlY3QgdGlsbCBpdCBoaXRzIDEwMClcblxuICAgICAgICBsaW5lLnRlbXBEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgfVxuXG4gICAgICBsaW5lLnRlbXBEaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICBsaW5lLnZhbHVlcyA9IGxpbmUudmFsdWVzLm1hcChmdW5jdGlvbihwb2ludCwgcG9pbnRJbmRleCkge1xuICAgICAgICBwb2ludC5kaXNwbGF5ID0geyd5JzogKGxpbmVzLnkoKShwb2ludCwgcG9pbnRJbmRleCkgLSB2KSAvICgxICsgdikgfTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfSlcblxuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfSlcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICByZXR1cm4gY2hhcnQ7XG59XG4vL1RPRE86IGNvbnNpZGVyIGRlcHJlY2F0aW5nIGJ5IGFkZGluZyBuZWNlc3NhcnkgZmVhdHVyZXMgdG8gbXVsdGlCYXIgbW9kZWxcbm52Lm1vZGVscy5kaXNjcmV0ZUJhciA9IGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAsIHdpZHRoID0gOTYwXG4gICAgLCBoZWlnaHQgPSA1MDBcbiAgICAsIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApIC8vQ3JlYXRlIHNlbWktdW5pcXVlIElEIGluIGNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcbiAgICAsIHggPSBkMy5zY2FsZS5vcmRpbmFsKClcbiAgICAsIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9XG4gICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAsIGZvcmNlWSA9IFswXSAvLyAwIGlzIGZvcmNlZCBieSBkZWZhdWx0Li4gdGhpcyBtYWtlcyBzZW5zZSBmb3IgdGhlIG1ham9yaXR5IG9mIGJhciBncmFwaHMuLi4gdXNlciBjYW4gYWx3YXlzIGRvIGNoYXJ0LmZvcmNlWShbXSkgdG8gcmVtb3ZlXG4gICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgLCBzaG93VmFsdWVzID0gZmFsc2VcbiAgICAsIHZhbHVlRm9ybWF0ID0gZDMuZm9ybWF0KCcsLjJmJylcbiAgICAsIHhEb21haW5cbiAgICAsIHlEb21haW5cbiAgICAsIHhSYW5nZVxuICAgICwgeVJhbmdlXG4gICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdjaGFydENsaWNrJywgJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsQ2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnKVxuICAgICwgcmVjdENsYXNzID0gJ2Rpc2NyZXRlQmFyJ1xuICAgIDtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgeDAsIHkwO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcblxuXG4gICAgICAvL2FkZCBzZXJpZXMgaW5kZXggdG8gZWFjaCBkYXRhIHBvaW50IGZvciByZWZlcmVuY2VcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsIGkpIHtcbiAgICAgICAgc2VyaWVzLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgcG9pbnQuc2VyaWVzID0gaTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgU2NhbGVzXG5cbiAgICAgIC8vIHJlbWFwIGFuZCBmbGF0dGVuIHRoZSBkYXRhIGZvciB1c2UgaW4gY2FsY3VsYXRpbmcgdGhlIHNjYWxlcycgZG9tYWluc1xuICAgICAgdmFyIHNlcmllc0RhdGEgPSAoeERvbWFpbiAmJiB5RG9tYWluKSA/IFtdIDogLy8gaWYgd2Uga25vdyB4RG9tYWluIGFuZCB5RG9tYWluLCBubyBuZWVkIHRvIGNhbGN1bGF0ZVxuICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IGdldFgoZCxpKSwgeTogZ2V0WShkLGkpLCB5MDogZC55MCB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgeCAgIC5kb21haW4oeERvbWFpbiB8fCBkMy5tZXJnZShzZXJpZXNEYXRhKS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0pKVxuICAgICAgICAgIC5yYW5nZUJhbmRzKHhSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdLCAuMSk7XG5cbiAgICAgIHkgICAuZG9tYWluKHlEb21haW4gfHwgZDMuZXh0ZW50KGQzLm1lcmdlKHNlcmllc0RhdGEpLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfSkuY29uY2F0KGZvcmNlWSkpKTtcblxuXG4gICAgICAvLyBJZiBzaG93VmFsdWVzLCBwYWQgdGhlIFkgYXhpcyByYW5nZSB0byBhY2NvdW50IGZvciBsYWJlbCBoZWlnaHRcbiAgICAgIGlmIChzaG93VmFsdWVzKSB5LnJhbmdlKHlSYW5nZSB8fCBbYXZhaWxhYmxlSGVpZ2h0IC0gKHkuZG9tYWluKClbMF0gPCAwID8gMTIgOiAwKSwgeS5kb21haW4oKVsxXSA+IDAgPyAxMiA6IDBdKTtcbiAgICAgIGVsc2UgeS5yYW5nZSh5UmFuZ2UgfHwgW2F2YWlsYWJsZUhlaWdodCwgMF0pO1xuXG4gICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgaWYgdGhleSBleGlzdFxuICAgICAgeDAgPSB4MCB8fCB4O1xuICAgICAgeTAgPSB5MCB8fCB5LmNvcHkoKS5yYW5nZShbeSgwKSx5KDApXSk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWRpc2NyZXRlYmFyJykuZGF0YShbZGF0YV0pO1xuICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtZGlzY3JldGViYXInKTtcbiAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1ncm91cHMnKTtcblxuICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblxuICAgICAgLy9UT0RPOiBieSBkZWZpbml0aW9uLCB0aGUgZGlzY3JldGUgYmFyIHNob3VsZCBub3QgaGF2ZSBtdWx0aXBsZSBncm91cHMsIHdpbGwgbW9kaWZ5L3JlbW92ZSBsYXRlclxuICAgICAgdmFyIGdyb3VwcyA9IHdyYXAuc2VsZWN0KCcubnYtZ3JvdXBzJykuc2VsZWN0QWxsKCcubnYtZ3JvdXAnKVxuICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXkgfSk7XG4gICAgICBncm91cHMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMWUtNik7XG4gICAgICBncm91cHMuZXhpdCgpXG4gICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMWUtNilcbiAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICBncm91cHNcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICdudi1ncm91cCBudi1zZXJpZXMtJyArIGkgfSlcbiAgICAgICAgICAuY2xhc3NlZCgnaG92ZXInLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmhvdmVyIH0pO1xuICAgICAgZ3JvdXBzXG4gICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxuICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgLjc1KTtcblxuXG4gICAgICB2YXIgYmFycyA9IGdyb3Vwcy5zZWxlY3RBbGwoJ2cubnYtYmFyJylcbiAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcyB9KTtcblxuICAgICAgYmFycy5leGl0KCkucmVtb3ZlKCk7XG5cblxuICAgICAgdmFyIGJhcnNFbnRlciA9IGJhcnMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGksaikge1xuICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgKHgoZ2V0WChkLGkpKSArIHgucmFuZ2VCYW5kKCkgKiAuMDUgKSArICcsICcgKyB5KDApICsgJyknXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkgeyAvL1RPRE86IGZpZ3VyZSBvdXQgd2h5IGogd29ya3MgYWJvdmUsIGJ1dCBub3QgaGVyZVxuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgIHNlcmllczogZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgIHBvczogW3goZ2V0WChkLGkpKSArICh4LnJhbmdlQmFuZCgpICogKGQuc2VyaWVzICsgLjUpIC8gZGF0YS5sZW5ndGgpLCB5KGdldFkoZCxpKSldLCAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhlIHZhbHVlIGFwcGVhcnMgdG8gYmUgc2hpZnRlZFxuICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgIGU6IGQzLmV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQsaSksXG4gICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgIGU6IGQzLmV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRDbGljayh7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQsaSksXG4gICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICBwb3M6IFt4KGdldFgoZCxpKSkgKyAoeC5yYW5nZUJhbmQoKSAqIChkLnNlcmllcyArIC41KSAvIGRhdGEubGVuZ3RoKSwgeShnZXRZKGQsaSkpXSwgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoZSB2YWx1ZSBhcHBlYXJzIHRvIGJlIHNoaWZ0ZWRcbiAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnREYmxDbGljayh7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQsaSksXG4gICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICBwb3M6IFt4KGdldFgoZCxpKSkgKyAoeC5yYW5nZUJhbmQoKSAqIChkLnNlcmllcyArIC41KSAvIGRhdGEubGVuZ3RoKSwgeShnZXRZKGQsaSkpXSwgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoZSB2YWx1ZSBhcHBlYXJzIHRvIGJlIHNoaWZ0ZWRcbiAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgYmFyc0VudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDApXG4gICAgICAgICAgLmF0dHIoJ3dpZHRoJywgeC5yYW5nZUJhbmQoKSAqIC45IC8gZGF0YS5sZW5ndGggKVxuXG4gICAgICBpZiAoc2hvd1ZhbHVlcykge1xuICAgICAgICBiYXJzRW50ZXIuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAgICAgICA7XG5cbiAgICAgICAgYmFycy5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gdmFsdWVGb3JtYXQoZ2V0WShkLGkpKSB9KVxuICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAuYXR0cigneCcsIHgucmFuZ2VCYW5kKCkgKiAuOSAvIDIpXG4gICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyB5KGdldFkoZCxpKSkgLSB5KDApICsgMTIgOiAtNCB9KVxuXG4gICAgICAgICAgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFycy5zZWxlY3RBbGwoJ3RleHQnKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgYmFyc1xuICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WShkLGkpIDwgMCA/ICdudi1iYXIgbmVnYXRpdmUnIDogJ252LWJhciBwb3NpdGl2ZScgfSlcbiAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCxpKSB9KVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsaSkgfSlcbiAgICAgICAgLnNlbGVjdCgncmVjdCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgcmVjdENsYXNzKVxuICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAuYXR0cignd2lkdGgnLCB4LnJhbmdlQmFuZCgpICogLjkgLyBkYXRhLmxlbmd0aCk7XG4gICAgICBiYXJzLnRyYW5zaXRpb24oKVxuICAgICAgICAvLy5kZWxheShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGkgKiAxMjAwIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoIH0pXG4gICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSB4KGdldFgoZCxpKSkgKyB4LnJhbmdlQmFuZCgpICogLjA1LFxuICAgICAgICAgICAgICAgIHRvcCA9IGdldFkoZCxpKSA8IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB5KDApIC0geShnZXRZKGQsaSkpIDwgMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHkoMCkgLSAxIDogLy9tYWtlIDEgcHggcG9zaXRpdmUgYmFycyBzaG93IHVwIGFib3ZlIHk9MFxuICAgICAgICAgICAgICAgICAgICAgICAgICB5KGdldFkoZCxpKSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGxlZnQgKyAnLCAnICsgdG9wICsgJyknXG4gICAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdCgncmVjdCcpXG4gICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgcmV0dXJuICBNYXRoLm1heChNYXRoLmFicyh5KGdldFkoZCxpKSkgLSB5KCh5RG9tYWluICYmIHlEb21haW5bMF0pIHx8IDApKSB8fCAxKVxuICAgICAgICAgIH0pO1xuXG5cbiAgICAgIC8vc3RvcmUgb2xkIHNjYWxlcyBmb3IgdXNlIGluIHRyYW5zaXRpb25zIG9uIHVwZGF0ZVxuICAgICAgeDAgPSB4LmNvcHkoKTtcbiAgICAgIHkwID0geS5jb3B5KCk7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuXG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICBjaGFydC54ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFg7XG4gICAgZ2V0WCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnkgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ2V0WTtcbiAgICBnZXRZID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICB3aWR0aCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueFNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHg7XG4gICAgeCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnlTY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5O1xuICAgIHkgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC54RG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHhEb21haW47XG4gICAgeERvbWFpbiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnlEb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geURvbWFpbjtcbiAgICB5RG9tYWluID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueFJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHhSYW5nZTtcbiAgICB4UmFuZ2UgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55UmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geVJhbmdlO1xuICAgIHlSYW5nZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmZvcmNlWSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmb3JjZVk7XG4gICAgZm9yY2VZID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuY29sb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sb3I7XG4gICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaWQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaWQ7XG4gICAgaWQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93VmFsdWVzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dWYWx1ZXM7XG4gICAgc2hvd1ZhbHVlcyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnZhbHVlRm9ybWF0PSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWVGb3JtYXQ7XG4gICAgdmFsdWVGb3JtYXQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5yZWN0Q2xhc3M9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByZWN0Q2xhc3M7XG4gICAgcmVjdENsYXNzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICByZXR1cm4gY2hhcnQ7XG59XG5cbm52Lm1vZGVscy5kaXNjcmV0ZUJhckNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBkaXNjcmV0ZWJhciA9IG52Lm1vZGVscy5kaXNjcmV0ZUJhcigpXG4gICAgLCB4QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgIDtcblxuICB2YXIgbWFyZ2luID0ge3RvcDogMTUsIHJpZ2h0OiAxMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9XG4gICAgLCB3aWR0aCA9IG51bGxcbiAgICAsIGhlaWdodCA9IG51bGxcbiAgICAsIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoKVxuICAgICwgc2hvd1hBeGlzID0gdHJ1ZVxuICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxuICAgICwgcmlnaHRBbGlnbllBeGlzID0gZmFsc2VcbiAgICAsIHN0YWdnZXJMYWJlbHMgPSBmYWxzZVxuICAgICwgdG9vbHRpcHMgPSB0cnVlXG4gICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xuICAgICAgICByZXR1cm4gJzxoMz4nICsgeCArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICc8L3A+J1xuICAgICAgfVxuICAgICwgeFxuICAgICwgeVxuICAgICwgbm9EYXRhID0gXCJObyBEYXRhIEF2YWlsYWJsZS5cIlxuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnYmVmb3JlVXBkYXRlJylcbiAgICAsIHRyYW5zaXRpb25EdXJhdGlvbiA9IDI1MFxuICAgIDtcblxuICB4QXhpc1xuICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgLmhpZ2hsaWdodFplcm8oZmFsc2UpXG4gICAgLnNob3dNYXhNaW4oZmFsc2UpXG4gICAgLnRpY2tGb3JtYXQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KVxuICAgIDtcbiAgeUF4aXNcbiAgICAub3JpZW50KChyaWdodEFsaWduWUF4aXMpID8gJ3JpZ2h0JyA6ICdsZWZ0JylcbiAgICAudGlja0Zvcm1hdChkMy5mb3JtYXQoJywuMWYnKSlcbiAgICA7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgeCA9IHhBeGlzLnRpY2tGb3JtYXQoKShkaXNjcmV0ZWJhci54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgIHkgPSB5QXhpcy50aWNrRm9ybWF0KCkoZGlzY3JldGViYXIueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgZS52YWx1ZSA8IDAgPyAnbicgOiAncycsIG51bGwsIG9mZnNldEVsZW1lbnQpO1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG5cbiAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgZGlzcGF0Y2guYmVmb3JlVXBkYXRlKCk7IFxuICAgICAgICBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikuY2FsbChjaGFydCk7IFxuICAgICAgfTtcbiAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIFNjYWxlc1xuXG4gICAgICB4ID0gZGlzY3JldGViYXIueFNjYWxlKCk7XG4gICAgICB5ID0gZGlzY3JldGViYXIueVNjYWxlKCkuY2xhbXAodHJ1ZSk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWRpc2NyZXRlQmFyV2l0aEF4ZXMnKS5kYXRhKFtkYXRhXSk7XG4gICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1kaXNjcmV0ZUJhcldpdGhBeGVzJykuYXBwZW5kKCdnJyk7XG4gICAgICB2YXIgZGVmc0VudGVyID0gZ0VudGVyLmFwcGVuZCgnZGVmcycpO1xuICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJylcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi16ZXJvTGluZScpXG4gICAgICAgICAgICAuYXBwZW5kKCdsaW5lJyk7XG4gICAgICAgIFxuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG5cbiAgICAgIGcuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgaWYgKHJpZ2h0QWxpZ25ZQXhpcykge1xuICAgICAgICAgIGcuc2VsZWN0KFwiLm52LXkubnYtYXhpc1wiKVxuICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGF2YWlsYWJsZVdpZHRoICsgXCIsMClcIik7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG5cbiAgICAgIGRpc2NyZXRlYmFyXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpO1xuXG5cbiAgICAgIHZhciBiYXJzV3JhcCA9IGcuc2VsZWN0KCcubnYtYmFyc1dyYXAnKVxuICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSlcblxuICAgICAgYmFyc1dyYXAudHJhbnNpdGlvbigpLmNhbGwoZGlzY3JldGViYXIpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblxuICAgICAgZGVmc0VudGVyLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgICAgIC5hdHRyKCdpZCcsICdudi14LWxhYmVsLWNsaXAtJyArIGRpc2NyZXRlYmFyLmlkKCkpXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgZy5zZWxlY3QoJyNudi14LWxhYmVsLWNsaXAtJyArIGRpc2NyZXRlYmFyLmlkKCkgKyAnIHJlY3QnKVxuICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHgucmFuZ2VCYW5kKCkgKiAoc3RhZ2dlckxhYmVscyA/IDIgOiAxKSlcbiAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTYpXG4gICAgICAgICAgLmF0dHIoJ3gnLCAteC5yYW5nZUJhbmQoKSAvIChzdGFnZ2VyTGFiZWxzID8gMSA6IDIgKSk7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIEF4ZXNcblxuICAgICAgaWYgKHNob3dYQXhpcykge1xuICAgICAgICAgIHhBeGlzXG4gICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgIC50aWNrcyggYXZhaWxhYmxlV2lkdGggLyAxMDAgKVxuICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQsIDApO1xuXG4gICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoeS5yYW5nZSgpWzBdICsgKChkaXNjcmV0ZWJhci5zaG93VmFsdWVzKCkgJiYgeS5kb21haW4oKVswXSA8IDApID8gMTYgOiAwKSkgKyAnKScpO1xuICAgICAgICAgIC8vZDMudHJhbnNpdGlvbihnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpKVxuICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJykudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcblxuXG4gICAgICAgICAgdmFyIHhUaWNrcyA9IGcuc2VsZWN0KCcubnYteC5udi1heGlzJykuc2VsZWN0QWxsKCdnJyk7XG5cbiAgICAgICAgICBpZiAoc3RhZ2dlckxhYmVscykge1xuICAgICAgICAgICAgeFRpY2tzXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiAndHJhbnNsYXRlKDAsJyArIChqICUgMiA9PSAwID8gJzUnIDogJzE3JykgKyAnKScgfSlcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG93WUF4aXMpIHtcbiAgICAgICAgICB5QXhpc1xuICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAudGlja3MoIGF2YWlsYWJsZUhlaWdodCAvIDM2IClcbiAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJykudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gWmVybyBsaW5lXG4gICAgICBnLnNlbGVjdChcIi5udi16ZXJvTGluZSBsaW5lXCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwwKVxuICAgICAgICAuYXR0cihcIngyXCIsYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgIC5hdHRyKFwieTFcIiwgeSgwKSlcbiAgICAgICAgLmF0dHIoXCJ5MlwiLCB5KDApKVxuICAgICAgICA7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICB9KTtcblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgZGlzY3JldGViYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgfSk7XG5cbiAgZGlzY3JldGViYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICB9KTtcblxuICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICB9KTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICBjaGFydC5kaXNjcmV0ZWJhciA9IGRpc2NyZXRlYmFyO1xuICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICBjaGFydC55QXhpcyA9IHlBeGlzO1xuXG4gIGQzLnJlYmluZChjaGFydCwgZGlzY3JldGViYXIsICd4JywgJ3knLCAneERvbWFpbicsICd5RG9tYWluJywgJ3hSYW5nZScsICd5UmFuZ2UnLCAnZm9yY2VYJywgJ2ZvcmNlWScsICdpZCcsICdzaG93VmFsdWVzJywgJ3ZhbHVlRm9ybWF0Jyk7XG5cbiAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuICBcbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICB3aWR0aCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuY29sb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sb3I7XG4gICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICBkaXNjcmV0ZWJhci5jb2xvcihjb2xvcik7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dYQXhpcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93WEF4aXM7XG4gICAgc2hvd1hBeGlzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd1lBeGlzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dZQXhpcztcbiAgICBzaG93WUF4aXMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5yaWdodEFsaWduWUF4aXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByaWdodEFsaWduWUF4aXM7XG4gICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zdGFnZ2VyTGFiZWxzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YWdnZXJMYWJlbHM7XG4gICAgc3RhZ2dlckxhYmVscyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXBzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXBzO1xuICAgIHRvb2x0aXBzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcDtcbiAgICB0b29sdGlwID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQubm9EYXRhID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vRGF0YTtcbiAgICBub0RhdGEgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50cmFuc2l0aW9uRHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICByZXR1cm4gY2hhcnQ7XG59XG5cbm52Lm1vZGVscy5kaXN0cmlidXRpb24gPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgLCB3aWR0aCA9IDQwMCAvL3RlY2huaWNhbGx5IHdpZHRoIG9yIGhlaWdodCBkZXBlbmRpbmcgb24geCBvciB5Li4uLlxuICAgICwgc2l6ZSA9IDhcbiAgICAsIGF4aXMgPSAneCcgLy8gJ3gnIG9yICd5Jy4uLiBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG4gICAgLCBnZXREYXRhID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZFtheGlzXSB9ICAvLyBkZWZhdWx0cyBkLnggb3IgZC55XG4gICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgLCBzY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgLCBkb21haW5cbiAgICA7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHNjYWxlMDtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGF2YWlsYWJsZUxlbmd0aCA9IHdpZHRoIC0gKGF4aXMgPT09ICd4JyA/IG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0IDogbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pLFxuICAgICAgICAgIG5heGlzID0gYXhpcyA9PSAneCcgPyAneScgOiAneCcsXG4gICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBTY2FsZXNcblxuICAgICAgc2NhbGUwID0gc2NhbGUwIHx8IHNjYWxlO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuXG4gICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtZGlzdHJpYnV0aW9uJykuZGF0YShbZGF0YV0pO1xuICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LWRpc3RyaWJ1dGlvbicpO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgdmFyIGRpc3RXcmFwID0gZy5zZWxlY3RBbGwoJ2cubnYtZGlzdCcpXG4gICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9LCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmtleSB9KTtcblxuICAgICAgZGlzdFdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKTtcbiAgICAgIGRpc3RXcmFwXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAnbnYtZGlzdCBudi1zZXJpZXMtJyArIGkgfSlcbiAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gY29sb3IoZCwgaSkgfSk7XG5cbiAgICAgIHZhciBkaXN0ID0gZGlzdFdyYXAuc2VsZWN0QWxsKCdsaW5lLm52LWRpc3QnICsgYXhpcylcbiAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcyB9KVxuICAgICAgZGlzdC5lbnRlcigpLmFwcGVuZCgnbGluZScpXG4gICAgICAgICAgLmF0dHIoYXhpcyArICcxJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBzY2FsZTAoZ2V0RGF0YShkLGkpKSB9KVxuICAgICAgICAgIC5hdHRyKGF4aXMgKyAnMicsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gc2NhbGUwKGdldERhdGEoZCxpKSkgfSlcbiAgICAgIGRpc3RXcmFwLmV4aXQoKS5zZWxlY3RBbGwoJ2xpbmUubnYtZGlzdCcgKyBheGlzKVxuICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAuYXR0cihheGlzICsgJzEnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHNjYWxlKGdldERhdGEoZCxpKSkgfSlcbiAgICAgICAgICAuYXR0cihheGlzICsgJzInLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHNjYWxlKGdldERhdGEoZCxpKSkgfSlcbiAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMClcbiAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICBkaXN0XG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAnbnYtZGlzdCcgKyBheGlzICsgJyBudi1kaXN0JyArIGF4aXMgKyAnLScgKyBpIH0pXG4gICAgICAgICAgLmF0dHIobmF4aXMgKyAnMScsIDApXG4gICAgICAgICAgLmF0dHIobmF4aXMgKyAnMicsIHNpemUpO1xuICAgICAgZGlzdFxuICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAuYXR0cihheGlzICsgJzEnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHNjYWxlKGdldERhdGEoZCxpKSkgfSlcbiAgICAgICAgICAuYXR0cihheGlzICsgJzInLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHNjYWxlKGdldERhdGEoZCxpKSkgfSlcblxuXG4gICAgICBzY2FsZTAgPSBzY2FsZS5jb3B5KCk7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuICBcbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICB3aWR0aCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmF4aXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYXhpcztcbiAgICBheGlzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgIHNpemUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5nZXREYXRhID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldERhdGE7XG4gICAgZ2V0RGF0YSA9IGQzLmZ1bmN0b3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNjYWxlO1xuICAgIHNjYWxlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuY29sb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sb3I7XG4gICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICByZXR1cm4gY2hhcnQ7XG59XG5cbm52Lm1vZGVscy5oaXN0b3JpY2FsQmFyQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIGJhcnMgPSBudi5tb2RlbHMuaGlzdG9yaWNhbEJhcigpXG4gICAgLCB4QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICwgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgO1xuXG5cbiAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogOTAsIGJvdHRvbTogNTAsIGxlZnQ6IDkwfVxuICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICwgd2lkdGggPSBudWxsXG4gICAgLCBoZWlnaHQgPSBudWxsXG4gICAgLCBzaG93TGVnZW5kID0gZmFsc2VcbiAgICAsIHNob3dYQXhpcyA9IHRydWVcbiAgICAsIHNob3dZQXhpcyA9IHRydWVcbiAgICAsIHJpZ2h0QWxpZ25ZQXhpcyA9IGZhbHNlXG4gICAgLCB0b29sdGlwcyA9IHRydWVcbiAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgIHJldHVybiAnPGgzPicgKyBrZXkgKyAnPC9oMz4nICtcbiAgICAgICAgICAgICAgICc8cD4nICsgIHkgKyAnIGF0ICcgKyB4ICsgJzwvcD4nXG4gICAgICB9XG4gICAgLCB4XG4gICAgLCB5XG4gICAgLCBzdGF0ZSA9IHt9XG4gICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgLCBub0RhdGEgPSAnTm8gRGF0YSBBdmFpbGFibGUuJ1xuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnKVxuICAgICwgdHJhbnNpdGlvbkR1cmF0aW9uID0gMjUwXG4gICAgO1xuXG4gIHhBeGlzXG4gICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAudGlja1BhZGRpbmcoNylcbiAgICA7XG4gIHlBeGlzXG4gICAgLm9yaWVudCggKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgIDtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG5cbiAgICAvLyBOZXcgYWRkaXRpb24gdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIFNWRyBpcyBzY2FsZWQgd2l0aCB2aWV3Qm94LCBtYXkgbW92ZSBUT0RPOiBjb25zaWRlciBpbXBsZW1lbnRpbmcgZXZlcnl3aGVyZSBlbHNlXG4gICAgaWYgKG9mZnNldEVsZW1lbnQpIHtcbiAgICAgIHZhciBzdmcgPSBkMy5zZWxlY3Qob2Zmc2V0RWxlbWVudCkuc2VsZWN0KCdzdmcnKTtcbiAgICAgIHZhciB2aWV3Qm94ID0gKHN2Zy5ub2RlKCkpID8gc3ZnLmF0dHIoJ3ZpZXdCb3gnKSA6IG51bGw7XG4gICAgICBpZiAodmlld0JveCkge1xuICAgICAgICB2aWV3Qm94ID0gdmlld0JveC5zcGxpdCgnICcpO1xuICAgICAgICB2YXIgcmF0aW8gPSBwYXJzZUludChzdmcuc3R5bGUoJ3dpZHRoJykpIC8gdmlld0JveFsyXTtcbiAgICAgICAgZS5wb3NbMF0gPSBlLnBvc1swXSAqIHJhdGlvO1xuICAgICAgICBlLnBvc1sxXSA9IGUucG9zWzFdICogcmF0aW87XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICB4ID0geEF4aXMudGlja0Zvcm1hdCgpKGJhcnMueCgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICB5ID0geUF4aXMudGlja0Zvcm1hdCgpKGJhcnMueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgbnVsbCwgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cblxuICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGNoYXJ0KSB9O1xuICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgLy9zZXQgc3RhdGUuZGlzYWJsZWRcbiAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gRGlzcGxheSBub0RhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cblxuICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICB2YXIgbm9EYXRhVGV4dCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5kYXRhKFtub0RhdGFdKTtcblxuICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi1ub0RhdGEnKVxuICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAuYXR0cigneScsIG1hcmdpbi50b3AgKyBhdmFpbGFibGVIZWlnaHQgLyAyKVxuICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBTY2FsZXNcblxuICAgICAgeCA9IGJhcnMueFNjYWxlKCk7XG4gICAgICB5ID0gYmFycy55U2NhbGUoKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcblxuICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtaGlzdG9yaWNhbEJhckNoYXJ0JykuZGF0YShbZGF0YV0pO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtaGlzdG9yaWNhbEJhckNoYXJ0JykuYXBwZW5kKCdnJyk7XG4gICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1iYXJzV3JhcCcpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTGVnZW5kXG5cbiAgICAgIGlmIChzaG93TGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZC53aWR0aChhdmFpbGFibGVXaWR0aCk7XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdyYXAuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoLW1hcmdpbi50b3ApICsnKScpXG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgaWYgKHJpZ2h0QWxpZ25ZQXhpcykge1xuICAgICAgICBnLnNlbGVjdChcIi5udi15Lm52LWF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgIH1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTWFpbiBDaGFydCBDb21wb25lbnQocylcblxuICAgICAgYmFyc1xuICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkIH0pKTtcblxuXG4gICAgICB2YXIgYmFyc1dyYXAgPSBnLnNlbGVjdCgnLm52LWJhcnNXcmFwJylcbiAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpXG5cbiAgICAgIGJhcnNXcmFwLnRyYW5zaXRpb24oKS5jYWxsKGJhcnMpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBBeGVzXG5cbiAgICAgIGlmIChzaG93WEF4aXMpIHtcbiAgICAgICAgeEF4aXNcbiAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodCwgMCk7XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKTtcbiAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgIHlBeGlzXG4gICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVIZWlnaHQgLyAzNiApXG4gICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJylcbiAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICB9XG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignbGVnZW5kQ2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgZC5kaXNhYmxlZCA9ICFkLmRpc2FibGVkO1xuXG4gICAgICAgIGlmICghZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkubGVuZ3RoKSB7XG4gICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgd3JhcC5zZWxlY3RBbGwoJy5udi1zZXJpZXMnKS5jbGFzc2VkKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG4gICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcblxuICAgICAgICBzZWxlY3Rpb24udHJhbnNpdGlvbigpLmNhbGwoY2hhcnQpO1xuICAgICAgfSk7XG5cbiAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignbGVnZW5kRGJsY2xpY2snLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgLy9Eb3VibGUgY2xpY2tpbmcgc2hvdWxkIGFsd2F5cyBlbmFibGUgY3VycmVudCBzZXJpZXMsIGFuZCBkaXNhYmxlZCBhbGwgb3RoZXJzLlxuICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgZC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG4gICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgfSk7XG5cblxuICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IGUuZGlzYWJsZWRbaV07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBiYXJzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gIH0pO1xuXG4gIGJhcnMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICB9KTtcblxuICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICB9KTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICBjaGFydC5iYXJzID0gYmFycztcbiAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICBjaGFydC55QXhpcyA9IHlBeGlzO1xuXG4gIGQzLnJlYmluZChjaGFydCwgYmFycywgJ2RlZmluZWQnLCAnaXNBcmVhJywgJ3gnLCAneScsICdzaXplJywgJ3hTY2FsZScsICd5U2NhbGUnLFxuICAgICd4RG9tYWluJywgJ3lEb21haW4nLCAneFJhbmdlJywgJ3lSYW5nZScsICdmb3JjZVgnLCAnZm9yY2VZJywgJ2ludGVyYWN0aXZlJywgJ2NsaXBFZGdlJywgJ2NsaXBWb3Jvbm9pJywgJ2lkJywgJ2ludGVycG9sYXRlJywnaGlnaGxpZ2h0UG9pbnQnLCdjbGVhckhpZ2hsaWdodHMnLCAnaW50ZXJhY3RpdmUnKTtcblxuICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICB3aWR0aCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuY29sb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sb3I7XG4gICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93TGVnZW5kID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dMZWdlbmQ7XG4gICAgc2hvd0xlZ2VuZCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dYQXhpcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93WEF4aXM7XG4gICAgc2hvd1hBeGlzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd1lBeGlzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dZQXhpcztcbiAgICBzaG93WUF4aXMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5yaWdodEFsaWduWUF4aXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByaWdodEFsaWduWUF4aXM7XG4gICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50b29sdGlwcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0b29sdGlwcztcbiAgICB0b29sdGlwcyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXBDb250ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXA7XG4gICAgdG9vbHRpcCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnN0YXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXRlO1xuICAgIHN0YXRlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuZGVmYXVsdFN0YXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRlZmF1bHRTdGF0ZTtcbiAgICBkZWZhdWx0U3RhdGUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5ub0RhdGEgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9EYXRhO1xuICAgIG5vRGF0YSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIHJldHVybiBjaGFydDtcbn1cbm52Lm1vZGVscy5pbmRlbnRlZFRyZWUgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9IC8vVE9ETzogaW1wbGVtZW50LCBtYXliZSBhcyBtYXJnaW4gb24gdGhlIGNvbnRhaW5pbmcgZGl2XG4gICAgLCB3aWR0aCA9IDk2MFxuICAgICwgaGVpZ2h0ID0gNTAwXG4gICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgLCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKVxuICAgICwgaGVhZGVyID0gdHJ1ZVxuICAgICwgZmlsdGVyWmVybyA9IGZhbHNlXG4gICAgLCBub0RhdGEgPSBcIk5vIERhdGEgQXZhaWxhYmxlLlwiXG4gICAgLCBjaGlsZEluZGVudCA9IDIwXG4gICAgLCBjb2x1bW5zID0gW3trZXk6J2tleScsIGxhYmVsOiAnTmFtZScsIHR5cGU6J3RleHQnfV0gLy9UT0RPOiBjb25zaWRlciBmdW5jdGlvbnMgbGlrZSBjaGFydC5hZGRDb2x1bW4sIGNoYXJ0LnJlbW92ZUNvbHVtbiwgaW5zdGVhZCBvZiBhIGJsb2NrIGxpa2UgdGhpc1xuICAgICwgdGFibGVDbGFzcyA9IG51bGxcbiAgICAsIGljb25PcGVuID0gJ2ltYWdlcy9ncmV5LXBsdXMucG5nJyAvL1RPRE86IGNvbnNpZGVyIHJlbW92aW5nIHRoaXMgYW5kIHJlcGxhY2luZyB3aXRoIGEgJysnIG9yICctJyB1bmxlc3MgdXNlciBkZWZpbmVzIGltYWdlc1xuICAgICwgaWNvbkNsb3NlID0gJ2ltYWdlcy9ncmV5LW1pbnVzLnBuZydcbiAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsY2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnKVxuICAgICwgZ2V0VXJsID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC51cmwgfVxuICAgIDtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBpZHggPSAwO1xuXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBkZXB0aCA9IDEsXG4gICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICB2YXIgdHJlZSA9IGQzLmxheW91dC50cmVlKClcbiAgICAgICAgICAuY2hpbGRyZW4oZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMgfSlcbiAgICAgICAgICAuc2l6ZShbaGVpZ2h0LCBjaGlsZEluZGVudF0pOyAvL05vdCBzdXJlIGlmIHRoaXMgaXMgbmVlZGVkIG5vdyB0aGF0IHRoZSByZXN1bHQgaXMgSFRNTFxuXG4gICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHsgY29udGFpbmVyLnRyYW5zaXRpb24oKS5kdXJhdGlvbig2MDApLmNhbGwoY2hhcnQpIH07XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgaWYgKCFkYXRhWzBdKSBkYXRhWzBdID0ge2tleTogbm9EYXRhfTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICB2YXIgbm9kZXMgPSB0cmVlLm5vZGVzKGRhdGFbMF0pO1xuXG4gICAgICAvLyBub2Rlcy5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgLy8gICBkLmlkID0gaSsrO1xuICAgICAgLy8gfSlcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgIHZhciB3cmFwID0gZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbCgnZGl2JykuZGF0YShbW25vZGVzXV0pO1xuICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2RpdicpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1pbmRlbnRlZHRyZWUnKTtcbiAgICAgIHZhciB0YWJsZUVudGVyID0gd3JhcEVudGVyLmFwcGVuZCgndGFibGUnKTtcbiAgICAgIHZhciB0YWJsZSA9IHdyYXAuc2VsZWN0KCd0YWJsZScpLmF0dHIoJ3dpZHRoJywgJzEwMCUnKS5hdHRyKCdjbGFzcycsIHRhYmxlQ2xhc3MpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgdmFyIHRoZWFkID0gdGFibGVFbnRlci5hcHBlbmQoJ3RoZWFkJyk7XG5cbiAgICAgICAgdmFyIHRoZWFkUm93MSA9IHRoZWFkLmFwcGVuZCgndHInKTtcblxuICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgdGhlYWRSb3cxXG4gICAgICAgICAgICAuYXBwZW5kKCd0aCcpXG4gICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGNvbHVtbi53aWR0aCA/IGNvbHVtbi53aWR0aCA6ICcxMCUnKVxuICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYWxpZ24nLCBjb2x1bW4udHlwZSA9PSAnbnVtZXJpYycgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgICAgICAgICAgLmFwcGVuZCgnc3BhbicpXG4gICAgICAgICAgICAgIC50ZXh0KGNvbHVtbi5sYWJlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG5cbiAgICAgIHZhciB0Ym9keSA9IHRhYmxlLnNlbGVjdEFsbCgndGJvZHknKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuICAgICAgdGJvZHkuZW50ZXIoKS5hcHBlbmQoJ3Rib2R5Jyk7XG5cblxuXG4gICAgICAvL2NvbXB1dGUgbWF4IGdlbmVyYXRpb25zXG4gICAgICBkZXB0aCA9IGQzLm1heChub2RlcywgZnVuY3Rpb24obm9kZSkgeyByZXR1cm4gbm9kZS5kZXB0aCB9KTtcbiAgICAgIHRyZWUuc2l6ZShbaGVpZ2h0LCBkZXB0aCAqIGNoaWxkSW5kZW50XSk7IC8vVE9ETzogc2VlIGlmIHRoaXMgaXMgbmVjZXNzYXJ5IGF0IGFsbFxuXG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgbm9kZXPigKZcbiAgICAgIHZhciBub2RlID0gdGJvZHkuc2VsZWN0QWxsKCd0cicpXG4gICAgICAgICAgLy8gLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5pZCB8fCAoZC5pZCA9PSArK2kpfSk7XG4gICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gKGZpbHRlclplcm8gJiYgIWQuY2hpbGRyZW4pID8gZmlsdGVyWmVybyhkKSA6ICB0cnVlOyB9ICl9LCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGQuaWQgfHwgKGQuaWQgfHwgKytpZHgpfSk7XG4gICAgICAgICAgLy8uc3R5bGUoJ2Rpc3BsYXknLCAndGFibGUtcm93Jyk7IC8vVE9ETzogc2VlIGlmIHRoaXMgZG9lcyBhbnl0aGluZ1xuXG4gICAgICBub2RlLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgbm9kZS5zZWxlY3QoJ2ltZy5udi10cmVlaWNvbicpXG4gICAgICAgICAgLmF0dHIoJ3NyYycsIGljb24pXG4gICAgICAgICAgLmNsYXNzZWQoJ2ZvbGRlZCcsIGZvbGRlZCk7XG5cbiAgICAgIHZhciBub2RlRW50ZXIgPSBub2RlLmVudGVyKCkuYXBwZW5kKCd0cicpO1xuXG5cbiAgICAgIGNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbihjb2x1bW4sIGluZGV4KSB7XG5cbiAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZUVudGVyLmFwcGVuZCgndGQnKVxuICAgICAgICAgICAgLnN0eWxlKCdwYWRkaW5nLWxlZnQnLCBmdW5jdGlvbihkKSB7IHJldHVybiAoaW5kZXggPyAwIDogZC5kZXB0aCAqIGNoaWxkSW5kZW50ICsgMTIgKyAoaWNvbihkKSA/IDAgOiAxNikpICsgJ3B4JyB9LCAnaW1wb3J0YW50JykgLy9UT0RPOiBjaGVjayB3aHkgSSBkaWQgdGhlIHRlcm5hcnkgaGVyZVxuICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFsaWduJywgY29sdW1uLnR5cGUgPT0gJ251bWVyaWMnID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG5cblxuICAgICAgICBpZiAoaW5kZXggPT0gMCkge1xuICAgICAgICAgIG5vZGVOYW1lLmFwcGVuZCgnaW1nJylcbiAgICAgICAgICAgICAgLmNsYXNzZWQoJ252LXRyZWVpY29uJywgdHJ1ZSlcbiAgICAgICAgICAgICAgLmNsYXNzZWQoJ252LWZvbGRlZCcsIGZvbGRlZClcbiAgICAgICAgICAgICAgLmF0dHIoJ3NyYycsIGljb24pXG4gICAgICAgICAgICAgIC5zdHlsZSgnd2lkdGgnLCAnMTRweCcpXG4gICAgICAgICAgICAgIC5zdHlsZSgnaGVpZ2h0JywgJzE0cHgnKVxuICAgICAgICAgICAgICAuc3R5bGUoJ3BhZGRpbmcnLCAnMCAxcHgnKVxuICAgICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCBmdW5jdGlvbihkKSB7IHJldHVybiBpY29uKGQpID8gJ2lubGluZS1ibG9jaycgOiAnbm9uZSc7IH0pXG4gICAgICAgICAgICAgIC5vbignY2xpY2snLCBjbGljayk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIG5vZGVOYW1lLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgIGlmICghaW5kZXggJiYgZ2V0VXJsKGQpKVxuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgIC5hcHBlbmQoJ2EnKVxuICAgICAgICAgICAgICAuYXR0cignaHJlZicsZ2V0VXJsKVxuICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBkMy5mdW5jdG9yKGNvbHVtbi5jbGFzc2VzKSlcbiAgICAgICAgICAgICAgLmFwcGVuZCgnc3BhbicpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgIC5hcHBlbmQoJ3NwYW4nKVxuXG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCdzcGFuJylcbiAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZDMuZnVuY3Rvcihjb2x1bW4uY2xhc3NlcykgKVxuICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBjb2x1bW4uZm9ybWF0ID8gY29sdW1uLmZvcm1hdChkKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRbY29sdW1uLmtleV0gfHwgJy0nKSB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAgKGNvbHVtbi5zaG93Q291bnQpIHtcbiAgICAgICAgICBub2RlTmFtZS5hcHBlbmQoJ3NwYW4nKVxuICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtY2hpbGRyZW5Db3VudCcpO1xuXG4gICAgICAgICAgbm9kZS5zZWxlY3RBbGwoJ3NwYW4ubnYtY2hpbGRyZW5Db3VudCcpLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKGQudmFsdWVzICYmIGQudmFsdWVzLmxlbmd0aCkgfHwgKGQuX3ZhbHVlcyAmJiBkLl92YWx1ZXMubGVuZ3RoKSkgPyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGlzIGlzIGEgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICcoJyArICgoZC52YWx1ZXMgJiYgKGQudmFsdWVzLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBmaWx0ZXJaZXJvID8gZmlsdGVyWmVybyhkKSA6ICB0cnVlOyB9KS5sZW5ndGgpKSAvL0lmIGNoaWxkcmVuIGFyZSBpbiB2YWx1ZXMgY2hlY2sgaXRzIGNoaWxkcmVuIGFuZCBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgfHwgKGQuX3ZhbHVlcyAmJiBkLl92YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGZpbHRlclplcm8gPyBmaWx0ZXJaZXJvKGQpIDogIHRydWU7IH0pLmxlbmd0aCkgICAgIC8vT3RoZXJ3aXNlLCBkbyB0aGUgc2FtZSwgYnV0IHdpdGggdGhlIG90aGVyIG5hbWUsIF92YWx1ZXMuLi5cbiAgICAgICAgICAgICAgICAgICAgfHwgMCkgKyAnKScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhpcyBpcyB0aGUgY2F0Y2gtYWxsIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNoaWxkcmVuIGFmdGVyIGEgZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgIDogJycgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhpcyBpcyBub3QgYSBwYXJlbnQsIGp1c3QgZ2l2ZSBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgKGNvbHVtbi5jbGljaylcbiAgICAgICAgLy8gICBub2RlTmFtZS5zZWxlY3QoJ3NwYW4nKS5vbignY2xpY2snLCBjb2x1bW4uY2xpY2spO1xuXG4gICAgICB9KTtcblxuICAgICAgbm9kZVxuICAgICAgICAub3JkZXIoKVxuICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCkgeyBcbiAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50Q2xpY2soe1xuICAgICAgICAgICAgcm93OiB0aGlzLCAvL1RPRE86IGRlY2lkZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHNob3VsZCBiZSBjb25zaXN0ZW50IHdpdGggc2NhdHRlci9saW5lIGV2ZW50cyBvciBzaG91bGQgYmUgYW4gaHRtbCBsaW5rIChhIGhyZWYpXG4gICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgcG9zOiBbZC54LCBkLnldXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkKSB7IFxuICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnREYmxjbGljayh7XG4gICAgICAgICAgICByb3c6IHRoaXMsXG4gICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgcG9zOiBbZC54LCBkLnldXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkgeyBcbiAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgIHJvdzogdGhpcyxcbiAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICBwb3M6IFtkLngsIGQueV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHsgXG4gICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgIHJvdzogdGhpcyxcbiAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICBwb3M6IFtkLngsIGQueV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cblxuXG5cbiAgICAgIC8vIFRvZ2dsZSBjaGlsZHJlbiBvbiBjbGljay5cbiAgICAgIGZ1bmN0aW9uIGNsaWNrKGQsIF8sIHVuc2hpZnQpIHtcbiAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgaWYoZDMuZXZlbnQuc2hpZnRLZXkgJiYgIXVuc2hpZnQpIHtcbiAgICAgICAgICAvL0lmIHlvdSBzaGlmdC1jbGljaywgaXQnbGwgdG9nZ2xlIGZvbGQgYWxsIHRoZSBjaGlsZHJlbiwgaW5zdGVhZCBvZiBpdHNlbGZcbiAgICAgICAgICBkMy5ldmVudC5zaGlmdEtleSA9IGZhbHNlO1xuICAgICAgICAgIGQudmFsdWVzICYmIGQudmFsdWVzLmZvckVhY2goZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICBpZiAobm9kZS52YWx1ZXMgfHwgbm9kZS5fdmFsdWVzKSB7XG4gICAgICAgICAgICAgIGNsaWNrKG5vZGUsIDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFoYXNDaGlsZHJlbihkKSkge1xuICAgICAgICAgIC8vZG93bmxvYWQgZmlsZVxuICAgICAgICAgIC8vd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkLnVybDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZC52YWx1ZXMpIHtcbiAgICAgICAgICBkLl92YWx1ZXMgPSBkLnZhbHVlcztcbiAgICAgICAgICBkLnZhbHVlcyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZC52YWx1ZXMgPSBkLl92YWx1ZXM7XG4gICAgICAgICAgZC5fdmFsdWVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgIH1cblxuXG4gICAgICBmdW5jdGlvbiBpY29uKGQpIHtcbiAgICAgICAgcmV0dXJuIChkLl92YWx1ZXMgJiYgZC5fdmFsdWVzLmxlbmd0aCkgPyBpY29uT3BlbiA6IChkLnZhbHVlcyAmJiBkLnZhbHVlcy5sZW5ndGgpID8gaWNvbkNsb3NlIDogJyc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZvbGRlZChkKSB7XG4gICAgICAgIHJldHVybiAoZC5fdmFsdWVzICYmIGQuX3ZhbHVlcy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYXNDaGlsZHJlbihkKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBkLnZhbHVlcyB8fCBkLl92YWx1ZXM7XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCk7XG4gICAgICB9XG5cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG4gIFxuICBjaGFydC5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFyZ2luO1xuICAgIG1hcmdpbi50b3AgICAgPSB0eXBlb2YgXy50b3AgICAgIT0gJ3VuZGVmaW5lZCcgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LndpZHRoID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgIHdpZHRoID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcbiAgICBoZWlnaHQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5jb2xvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2xvcjtcbiAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgIHNjYXR0ZXIuY29sb3IoY29sb3IpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5pZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpZDtcbiAgICBpZCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhlYWRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWFkZXI7XG4gICAgaGVhZGVyID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQubm9EYXRhID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vRGF0YTtcbiAgICBub0RhdGEgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5maWx0ZXJaZXJvID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZpbHRlclplcm87XG4gICAgZmlsdGVyWmVybyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbHVtbnMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sdW1ucztcbiAgICBjb2x1bW5zID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudGFibGVDbGFzcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0YWJsZUNsYXNzO1xuICAgIHRhYmxlQ2xhc3MgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5pY29uT3BlbiA9IGZ1bmN0aW9uKF8pe1xuICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpY29uT3BlbjtcbiAgICBpY29uT3BlbiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cbiAgY2hhcnQuaWNvbkNsb3NlID0gZnVuY3Rpb24oXyl7XG4gICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGljb25DbG9zZTtcbiAgICBpY29uQ2xvc2UgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG4gIGNoYXJ0LmdldFVybCA9IGZ1bmN0aW9uKF8pe1xuICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXRVcmw7XG4gICAgZ2V0VXJsID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgcmV0dXJuIGNoYXJ0O1xufTtudi5tb2RlbHMubGVnZW5kID0gZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBtYXJnaW4gPSB7dG9wOiA1LCByaWdodDogMCwgYm90dG9tOiA1LCBsZWZ0OiAwfVxuICAgICwgd2lkdGggPSA0MDBcbiAgICAsIGhlaWdodCA9IDIwXG4gICAgLCBnZXRLZXkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLmtleSB9XG4gICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgLCBhbGlnbiA9IHRydWVcbiAgICAsIHJpZ2h0QWxpZ24gPSB0cnVlXG4gICAgLCB1cGRhdGVTdGF0ZSA9IHRydWUgICAvL0lmIHRydWUsIGxlZ2VuZCB3aWxsIHVwZGF0ZSBkYXRhLmRpc2FibGVkIGFuZCB0cmlnZ2VyIGEgJ3N0YXRlQ2hhbmdlJyBkaXNwYXRjaC5cbiAgICAsIHJhZGlvQnV0dG9uTW9kZSA9IGZhbHNlICAgLy9JZiB0cnVlLCBjbGlja2luZyBsZWdlbmQgaXRlbXMgd2lsbCBjYXVzZSBpdCB0byBiZWhhdmUgbGlrZSBhIHJhZGlvIGJ1dHRvbi4gKG9ubHkgb25lIGNhbiBiZSBzZWxlY3RlZCBhdCBhIHRpbWUpXG4gICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdsZWdlbmRDbGljaycsICdsZWdlbmREYmxjbGljaycsICdsZWdlbmRNb3VzZW92ZXInLCAnbGVnZW5kTW91c2VvdXQnLCAnc3RhdGVDaGFuZ2UnKVxuICAgIDtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi1sZWdlbmQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbGVnZW5kJykuYXBwZW5kKCdnJyk7XG4gICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICB2YXIgc2VyaWVzID0gZy5zZWxlY3RBbGwoJy5udi1zZXJpZXMnKVxuICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG4gICAgICB2YXIgc2VyaWVzRW50ZXIgPSBzZXJpZXMuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1zZXJpZXMnKVxuICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkaXNwYXRjaC5sZWdlbmRNb3VzZW92ZXIoZCxpKTsgIC8vVE9ETzogTWFrZSBjb25zaXN0ZW50IHdpdGggb3RoZXIgZXZlbnQgb2JqZWN0c1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgZGlzcGF0Y2gubGVnZW5kTW91c2VvdXQoZCxpKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoLmxlZ2VuZENsaWNrKGQsaSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlU3RhdGUpIHtcbiAgICAgICAgICAgICAgIGlmIChyYWRpb0J1dHRvbk1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAvL1JhZGlvIGJ1dHRvbiBtb2RlOiBzZXQgZXZlcnkgc2VyaWVzIHRvIGRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgIC8vICBhbmQgZW5hYmxlIHRoZSBjbGlja2VkIHNlcmllcy5cbiAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzKSB7IHNlcmllcy5kaXNhYmxlZCA9IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gIWQuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZXZlcnkoZnVuY3Rpb24oc2VyaWVzKSB7IHJldHVybiBzZXJpZXMuZGlzYWJsZWR9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIE5WRDMgbGVnZW5kcyBpcywgaWYgZXZlcnkgc2luZ2xlIHNlcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBkaXNhYmxlZCwgdHVybiBhbGwgc2VyaWVzJyBiYWNrIG9uLlxuICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzKSB7IHNlcmllcy5kaXNhYmxlZCA9IGZhbHNlfSk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KVxuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkaXNwYXRjaC5sZWdlbmREYmxjbGljayhkLGkpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy90aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBOVkQzIGxlZ2VuZHMsIHdoZW4gZG91YmxlIGNsaWNraW5nIG9uZSxcbiAgICAgICAgICAgICAgICAvLyBpcyB0byBzZXQgYWxsIG90aGVyIHNlcmllcycgdG8gZmFsc2UsIGFuZCBtYWtlIHRoZSBkb3VibGUgY2xpY2tlZCBzZXJpZXMgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICBzZXJpZXNFbnRlci5hcHBlbmQoJ2NpcmNsZScpXG4gICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAyKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ252LWxlZ2VuZC1zeW1ib2wnKVxuICAgICAgICAgIC5hdHRyKCdyJywgNSk7XG4gICAgICBzZXJpZXNFbnRlci5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywnbnYtbGVnZW5kLXRleHQnKVxuICAgICAgICAgIC5hdHRyKCdkeScsICcuMzJlbScpXG4gICAgICAgICAgLmF0dHIoJ2R4JywgJzgnKTtcbiAgICAgIHNlcmllcy5jbGFzc2VkKCdkaXNhYmxlZCcsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuZGlzYWJsZWQgfSk7XG4gICAgICBzZXJpZXMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgc2VyaWVzLnNlbGVjdCgnY2lyY2xlJylcbiAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCxpKX0pXG4gICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSkgfSk7XG4gICAgICBzZXJpZXMuc2VsZWN0KCd0ZXh0JykudGV4dChnZXRLZXkpO1xuXG5cbiAgICAgIC8vVE9ETzogaW1wbGVtZW50IGZpeGVkLXdpZHRoIGFuZCBtYXgtd2lkdGggb3B0aW9ucyAobWF4LXdpZHRoIGlzIGVzcGVjaWFsbHkgdXNlZnVsIHdpdGggdGhlIGFsaWduIG9wdGlvbilcblxuICAgICAgLy8gTkVXIEFMSUdOSU5HIENPREUsIFRPRE86IGNsZWFuIHVwXG4gICAgICBpZiAoYWxpZ24pIHtcblxuICAgICAgICB2YXIgc2VyaWVzV2lkdGhzID0gW107XG4gICAgICAgIHNlcmllcy5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICB2YXIgbGVnZW5kVGV4dCA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVUZXh0TGVuZ3RoO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vZGVUZXh0TGVuZ3RoID0gbGVnZW5kVGV4dC5nZXRDb21wdXRlZFRleHRMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGVnZW5kVGV4dCBpcyBkaXNwbGF5Om5vbmUnZCAobm9kZVRleHRMZW5ndGggPT0gMCksIHNpbXVsYXRlIGFuIGVycm9yIHNvIHdlIGFwcHJveGltYXRlLCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgaWYobm9kZVRleHRMZW5ndGggPD0gMCkgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgbm9kZVRleHRMZW5ndGggPSBudi51dGlscy5jYWxjQXBwcm94VGV4dFdpZHRoKGxlZ2VuZFRleHQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2VyaWVzV2lkdGhzLnB1c2gobm9kZVRleHRMZW5ndGggKyAyOCk7IC8vIDI4IGlzIH4gdGhlIHdpZHRoIG9mIHRoZSBjaXJjbGUgcGx1cyBzb21lIHBhZGRpbmdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzZXJpZXNQZXJSb3cgPSAwO1xuICAgICAgICB2YXIgbGVnZW5kV2lkdGggPSAwO1xuICAgICAgICB2YXIgY29sdW1uV2lkdGhzID0gW107XG5cbiAgICAgICAgd2hpbGUgKCBsZWdlbmRXaWR0aCA8IGF2YWlsYWJsZVdpZHRoICYmIHNlcmllc1BlclJvdyA8IHNlcmllc1dpZHRocy5sZW5ndGgpIHtcbiAgICAgICAgICBjb2x1bW5XaWR0aHNbc2VyaWVzUGVyUm93XSA9IHNlcmllc1dpZHRoc1tzZXJpZXNQZXJSb3ddO1xuICAgICAgICAgIGxlZ2VuZFdpZHRoICs9IHNlcmllc1dpZHRoc1tzZXJpZXNQZXJSb3crK107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcmllc1BlclJvdyA9PT0gMCkgc2VyaWVzUGVyUm93ID0gMTsgLy9taW5pbXVtIG9mIG9uZSBzZXJpZXMgcGVyIHJvd1xuXG5cbiAgICAgICAgd2hpbGUgKCBsZWdlbmRXaWR0aCA+IGF2YWlsYWJsZVdpZHRoICYmIHNlcmllc1BlclJvdyA+IDEgKSB7XG4gICAgICAgICAgY29sdW1uV2lkdGhzID0gW107XG4gICAgICAgICAgc2VyaWVzUGVyUm93LS07XG5cbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNlcmllc1dpZHRocy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgaWYgKHNlcmllc1dpZHRoc1trXSA+IChjb2x1bW5XaWR0aHNbayAlIHNlcmllc1BlclJvd10gfHwgMCkgKVxuICAgICAgICAgICAgICBjb2x1bW5XaWR0aHNbayAlIHNlcmllc1BlclJvd10gPSBzZXJpZXNXaWR0aHNba107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGVnZW5kV2lkdGggPSBjb2x1bW5XaWR0aHMucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1ciwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2ICsgY3VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgY3VyWCA9IDA7IGkgPCBzZXJpZXNQZXJSb3c7IGkrKykge1xuICAgICAgICAgICAgeFBvc2l0aW9uc1tpXSA9IGN1clg7XG4gICAgICAgICAgICBjdXJYICs9IGNvbHVtbldpZHRoc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcmllc1xuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHhQb3NpdGlvbnNbaSAlIHNlcmllc1BlclJvd10gKyAnLCcgKyAoNSArIE1hdGguZmxvb3IoaSAvIHNlcmllc1BlclJvdykgKiAyMCkgKyAnKSc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvL3Bvc2l0aW9uIGxlZ2VuZCBhcyBmYXIgcmlnaHQgYXMgcG9zc2libGUgd2l0aGluIHRoZSB0b3RhbCB3aWR0aFxuICAgICAgICBpZiAocmlnaHRBbGlnbikge1xuICAgICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICh3aWR0aCAtIG1hcmdpbi5yaWdodCAtIGxlZ2VuZFdpZHRoKSArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCcgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlaWdodCA9IG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tICsgKE1hdGguY2VpbChzZXJpZXNXaWR0aHMubGVuZ3RoIC8gc2VyaWVzUGVyUm93KSAqIDIwKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB2YXIgeXBvcyA9IDUsXG4gICAgICAgICAgICBuZXd4cG9zID0gNSxcbiAgICAgICAgICAgIG1heHdpZHRoID0gMCxcbiAgICAgICAgICAgIHhwb3M7XG4gICAgICAgIHNlcmllc1xuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKS5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgKyAyODtcbiAgICAgICAgICAgICAgeHBvcyA9IG5ld3hwb3M7XG5cbiAgICAgICAgICAgICAgaWYgKHdpZHRoIDwgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQgKyB4cG9zICsgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV3eHBvcyA9IHhwb3MgPSA1O1xuICAgICAgICAgICAgICAgIHlwb3MgKz0gMjA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuZXd4cG9zICs9IGxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKG5ld3hwb3MgPiBtYXh3aWR0aCkgbWF4d2lkdGggPSBuZXd4cG9zO1xuXG4gICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4cG9zICsgJywnICsgeXBvcyArICcpJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vcG9zaXRpb24gbGVnZW5kIGFzIGZhciByaWdodCBhcyBwb3NzaWJsZSB3aXRoaW4gdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgIGcuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKHdpZHRoIC0gbWFyZ2luLnJpZ2h0IC0gbWF4d2lkdGgpICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgaGVpZ2h0ID0gbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20gKyB5cG9zICsgMTU7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICBjaGFydC5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFyZ2luO1xuICAgIG1hcmdpbi50b3AgICAgPSB0eXBlb2YgXy50b3AgICAgIT0gJ3VuZGVmaW5lZCcgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LndpZHRoID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgIHdpZHRoID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcbiAgICBoZWlnaHQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5rZXkgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ2V0S2V5O1xuICAgIGdldEtleSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmFsaWduID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFsaWduO1xuICAgIGFsaWduID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQucmlnaHRBbGlnbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByaWdodEFsaWduO1xuICAgIHJpZ2h0QWxpZ24gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC51cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB1cGRhdGVTdGF0ZTtcbiAgICB1cGRhdGVTdGF0ZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnJhZGlvQnV0dG9uTW9kZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYWRpb0J1dHRvbk1vZGU7XG4gICAgcmFkaW9CdXR0b25Nb2RlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIHJldHVybiBjaGFydDtcbn1cblxubnYubW9kZWxzLmxpbmUgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyICBzY2F0dGVyID0gbnYubW9kZWxzLnNjYXR0ZXIoKVxuICAgIDtcblxuICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAsIHdpZHRoID0gOTYwXG4gICAgLCBoZWlnaHQgPSA1MDBcbiAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKCkgLy8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBjb2xvclxuICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9IC8vIGFjY2Vzc29yIHRvIGdldCB0aGUgeCB2YWx1ZSBmcm9tIGEgZGF0YSBwb2ludFxuICAgICwgZ2V0WSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9IC8vIGFjY2Vzc29yIHRvIGdldCB0aGUgeSB2YWx1ZSBmcm9tIGEgZGF0YSBwb2ludFxuICAgICwgZGVmaW5lZCA9IGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWlzTmFOKGdldFkoZCxpKSkgJiYgZ2V0WShkLGkpICE9PSBudWxsIH0gLy8gYWxsb3dzIGEgbGluZSB0byBiZSBub3QgY29udGludW91cyB3aGVuIGl0IGlzIG5vdCBkZWZpbmVkXG4gICAgLCBpc0FyZWEgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLmFyZWEgfSAvLyBkZWNpZGVzIGlmIGEgbGluZSBpcyBhbiBhcmVhIG9yIGp1c3QgYSBsaW5lXG4gICAgLCBjbGlwRWRnZSA9IGZhbHNlIC8vIGlmIHRydWUsIG1hc2tzIGxpbmVzIHdpdGhpbiB4IGFuZCB5IHNjYWxlXG4gICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxuICAgICwgeSAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueVNjYWxlKClcbiAgICAsIGludGVycG9sYXRlID0gXCJsaW5lYXJcIiAvLyBjb250cm9scyB0aGUgbGluZSBpbnRlcnBvbGF0aW9uXG4gICAgO1xuXG4gIHNjYXR0ZXJcbiAgICAuc2l6ZSgxNikgLy8gZGVmYXVsdCBzaXplXG4gICAgLnNpemVEb21haW4oWzE2LDI1Nl0pIC8vc2V0IHRvIHNwZWVkIHVwIGNhbGN1bGF0aW9uLCBuZWVkcyB0byBiZSB1bnNldCBpZiB0aGVyZSBpcyBhIGN1c3RvbSBzaXplIGFjY2Vzc29yXG4gICAgO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciB4MCwgeTAgLy91c2VkIHRvIHN0b3JlIHByZXZpb3VzIHNjYWxlc1xuICAgICAgO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIFNjYWxlc1xuXG4gICAgICB4ID0gc2NhdHRlci54U2NhbGUoKTtcbiAgICAgIHkgPSBzY2F0dGVyLnlTY2FsZSgpO1xuXG4gICAgICB4MCA9IHgwIHx8IHg7XG4gICAgICB5MCA9IHkwIHx8IHk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWxpbmUnKS5kYXRhKFtkYXRhXSk7XG4gICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1saW5lJyk7XG4gICAgICB2YXIgZGVmc0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZGVmcycpO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKVxuXG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZ3JvdXBzJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtc2NhdHRlcldyYXAnKTtcblxuICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblxuXG4gICAgICBzY2F0dGVyXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG5cbiAgICAgIHZhciBzY2F0dGVyV3JhcCA9IHdyYXAuc2VsZWN0KCcubnYtc2NhdHRlcldyYXAnKTtcbiAgICAgICAgICAvLy5kYXR1bShkYXRhKTsgLy8gRGF0YSBhdXRvbWF0aWNhbGx5IHRyaWNrbGVzIGRvd24gZnJvbSB0aGUgd3JhcFxuXG4gICAgICBzY2F0dGVyV3JhcC50cmFuc2l0aW9uKCkuY2FsbChzY2F0dGVyKTtcblxuXG5cbiAgICAgIGRlZnNFbnRlci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAuYXR0cignaWQnLCAnbnYtZWRnZS1jbGlwLScgKyBzY2F0dGVyLmlkKCkpXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgd3JhcC5zZWxlY3QoJyNudi1lZGdlLWNsaXAtJyArIHNjYXR0ZXIuaWQoKSArICcgcmVjdCcpXG4gICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChhdmFpbGFibGVIZWlnaHQgPiAwKSA/IGF2YWlsYWJsZUhlaWdodCA6IDApO1xuXG4gICAgICBnICAgLmF0dHIoJ2NsaXAtcGF0aCcsIGNsaXBFZGdlID8gJ3VybCgjbnYtZWRnZS1jbGlwLScgKyBzY2F0dGVyLmlkKCkgKyAnKScgOiAnJyk7XG4gICAgICBzY2F0dGVyV3JhcFxuICAgICAgICAgIC5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwRWRnZSA/ICd1cmwoI252LWVkZ2UtY2xpcC0nICsgc2NhdHRlci5pZCgpICsgJyknIDogJycpO1xuXG5cblxuXG4gICAgICB2YXIgZ3JvdXBzID0gd3JhcC5zZWxlY3QoJy5udi1ncm91cHMnKS5zZWxlY3RBbGwoJy5udi1ncm91cCcpXG4gICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9LCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmtleSB9KTtcbiAgICAgIGdyb3Vwcy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KTtcblxuICAgICAgZ3JvdXBzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgZ3JvdXBzXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAnbnYtZ3JvdXAgbnYtc2VyaWVzLScgKyBpIH0pXG4gICAgICAgICAgLmNsYXNzZWQoJ2hvdmVyJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5ob3ZlciB9KVxuICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSl7IHJldHVybiBjb2xvcihkLCBpKSB9KVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKXsgcmV0dXJuIGNvbG9yKGQsIGkpfSk7XG4gICAgICBncm91cHNcbiAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXG4gICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAuNSk7XG5cblxuXG4gICAgICB2YXIgYXJlYVBhdGhzID0gZ3JvdXBzLnNlbGVjdEFsbCgncGF0aC5udi1hcmVhJylcbiAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBpc0FyZWEoZCkgPyBbZF0gOiBbXSB9KTsgLy8gdGhpcyBpcyBkb25lIGRpZmZlcmVudGx5IHRoYW4gbGluZXMgYmVjYXVzZSBJIG5lZWQgdG8gY2hlY2sgaWYgc2VyaWVzIGlzIGFuIGFyZWFcbiAgICAgIGFyZWFQYXRocy5lbnRlcigpLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LWFyZWEnKVxuICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQzLnN2Zy5hcmVhKClcbiAgICAgICAgICAgICAgICAuaW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUpXG4gICAgICAgICAgICAgICAgLmRlZmluZWQoZGVmaW5lZClcbiAgICAgICAgICAgICAgICAueChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh4MChnZXRYKGQsaSkpKSB9KVxuICAgICAgICAgICAgICAgIC55MChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh5MChnZXRZKGQsaSkpKSB9KVxuICAgICAgICAgICAgICAgIC55MShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHkwKCB5LmRvbWFpbigpWzBdIDw9IDAgPyB5LmRvbWFpbigpWzFdID49IDAgPyAwIDogeS5kb21haW4oKVsxXSA6IHkuZG9tYWluKClbMF0gKSB9KVxuICAgICAgICAgICAgICAgIC8vLnkxKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geTAoMCkgfSkgLy9hc3N1bWluZyAwIGlzIHdpdGhpbiB5IGRvbWFpbi4uIG1heSBuZWVkIHRvIHR3ZWFrIHRoaXNcbiAgICAgICAgICAgICAgICAuYXBwbHkodGhpcywgW2QudmFsdWVzXSlcbiAgICAgICAgICB9KTtcbiAgICAgIGdyb3Vwcy5leGl0KCkuc2VsZWN0QWxsKCdwYXRoLm52LWFyZWEnKVxuICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgIGFyZWFQYXRoc1xuICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkMy5zdmcuYXJlYSgpXG4gICAgICAgICAgICAgICAgLmludGVycG9sYXRlKGludGVycG9sYXRlKVxuICAgICAgICAgICAgICAgIC5kZWZpbmVkKGRlZmluZWQpXG4gICAgICAgICAgICAgICAgLngoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBudi51dGlscy5OYU50b1plcm8oeChnZXRYKGQsaSkpKSB9KVxuICAgICAgICAgICAgICAgIC55MChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh5KGdldFkoZCxpKSkpIH0pXG4gICAgICAgICAgICAgICAgLnkxKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geSggeS5kb21haW4oKVswXSA8PSAwID8geS5kb21haW4oKVsxXSA+PSAwID8gMCA6IHkuZG9tYWluKClbMV0gOiB5LmRvbWFpbigpWzBdICkgfSlcbiAgICAgICAgICAgICAgICAvLy55MShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHkwKDApIH0pIC8vYXNzdW1pbmcgMCBpcyB3aXRoaW4geSBkb21haW4uLiBtYXkgbmVlZCB0byB0d2VhayB0aGlzXG4gICAgICAgICAgICAgICAgLmFwcGx5KHRoaXMsIFtkLnZhbHVlc10pXG4gICAgICAgICAgfSk7XG5cblxuXG4gICAgICB2YXIgbGluZVBhdGhzID0gZ3JvdXBzLnNlbGVjdEFsbCgncGF0aC5udi1saW5lJylcbiAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBbZC52YWx1ZXNdIH0pO1xuICAgICAgbGluZVBhdGhzLmVudGVyKCkuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtbGluZScpXG4gICAgICAgICAgLmF0dHIoJ2QnLFxuICAgICAgICAgICAgZDMuc3ZnLmxpbmUoKVxuICAgICAgICAgICAgICAuaW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUpXG4gICAgICAgICAgICAgIC5kZWZpbmVkKGRlZmluZWQpXG4gICAgICAgICAgICAgIC54KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHgwKGdldFgoZCxpKSkpIH0pXG4gICAgICAgICAgICAgIC55KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHkwKGdldFkoZCxpKSkpIH0pXG4gICAgICAgICAgKTtcblxuICAgICAgbGluZVBhdGhzXG4gICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5hdHRyKCdkJyxcbiAgICAgICAgICAgIGQzLnN2Zy5saW5lKClcbiAgICAgICAgICAgICAgLmludGVycG9sYXRlKGludGVycG9sYXRlKVxuICAgICAgICAgICAgICAuZGVmaW5lZChkZWZpbmVkKVxuICAgICAgICAgICAgICAueChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh4KGdldFgoZCxpKSkpIH0pXG4gICAgICAgICAgICAgIC55KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHkoZ2V0WShkLGkpKSkgfSlcbiAgICAgICAgICApO1xuXG5cblxuICAgICAgLy9zdG9yZSBvbGQgc2NhbGVzIGZvciB1c2UgaW4gdHJhbnNpdGlvbnMgb24gdXBkYXRlXG4gICAgICB4MCA9IHguY29weSgpO1xuICAgICAgeTAgPSB5LmNvcHkoKTtcblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGNoYXJ0LmRpc3BhdGNoID0gc2NhdHRlci5kaXNwYXRjaDtcbiAgY2hhcnQuc2NhdHRlciA9IHNjYXR0ZXI7XG5cbiAgZDMucmViaW5kKGNoYXJ0LCBzY2F0dGVyLCAnaWQnLCAnaW50ZXJhY3RpdmUnLCAnc2l6ZScsICd4U2NhbGUnLCAneVNjYWxlJywgJ3pTY2FsZScsICd4RG9tYWluJywgJ3lEb21haW4nLCAneFJhbmdlJywgJ3lSYW5nZScsXG4gICAgJ3NpemVEb21haW4nLCAnZm9yY2VYJywgJ2ZvcmNlWScsICdmb3JjZVNpemUnLCAnY2xpcFZvcm9ub2knLCAndXNlVm9yb25vaScsICdjbGlwUmFkaXVzJywgJ3BhZERhdGEnLCdoaWdobGlnaHRQb2ludCcsJ2NsZWFySGlnaGxpZ2h0cycpO1xuXG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICBjaGFydC5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFyZ2luO1xuICAgIG1hcmdpbi50b3AgICAgPSB0eXBlb2YgXy50b3AgICAgIT0gJ3VuZGVmaW5lZCcgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LndpZHRoID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgIHdpZHRoID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcbiAgICBoZWlnaHQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC54ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFg7XG4gICAgZ2V0WCA9IF87XG4gICAgc2NhdHRlci54KF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFk7XG4gICAgZ2V0WSA9IF87XG4gICAgc2NhdHRlci55KF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5jbGlwRWRnZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGlwRWRnZTtcbiAgICBjbGlwRWRnZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgc2NhdHRlci5jb2xvcihjb2xvcik7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGludGVycG9sYXRlO1xuICAgIGludGVycG9sYXRlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkZWZpbmVkO1xuICAgIGRlZmluZWQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5pc0FyZWEgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaXNBcmVhO1xuICAgIGlzQXJlYSA9IGQzLmZ1bmN0b3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICByZXR1cm4gY2hhcnQ7XG59XG5cbm52Lm1vZGVscy5saW5lQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIGxpbmVzID0gbnYubW9kZWxzLmxpbmUoKVxuICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgLCB5QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICwgaW50ZXJhY3RpdmVMYXllciA9IG52LmludGVyYWN0aXZlR3VpZGVsaW5lKClcbiAgICA7XG5cbiAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMjAsIGJvdHRvbTogNTAsIGxlZnQ6IDYwfVxuICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICwgd2lkdGggPSBudWxsXG4gICAgLCBoZWlnaHQgPSBudWxsXG4gICAgLCBzaG93TGVnZW5kID0gdHJ1ZVxuICAgICwgc2hvd1hBeGlzID0gdHJ1ZVxuICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxuICAgICwgcmlnaHRBbGlnbllBeGlzID0gZmFsc2VcbiAgICAsIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lID0gZmFsc2VcbiAgICAsIHRvb2x0aXBzID0gdHJ1ZVxuICAgICwgdG9vbHRpcCA9IGZ1bmN0aW9uKGtleSwgeCwgeSwgZSwgZ3JhcGgpIHtcbiAgICAgICAgcmV0dXJuICc8aDM+JyArIGtleSArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICcgYXQgJyArIHggKyAnPC9wPidcbiAgICAgIH1cbiAgICAsIHhcbiAgICAsIHlcbiAgICAsIHN0YXRlID0ge31cbiAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAsIG5vRGF0YSA9ICdObyBEYXRhIEF2YWlsYWJsZS4nXG4gICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScpXG4gICAgLCB0cmFuc2l0aW9uRHVyYXRpb24gPSAyNTBcbiAgICA7XG5cbiAgeEF4aXNcbiAgICAub3JpZW50KCdib3R0b20nKVxuICAgIC50aWNrUGFkZGluZyg3KVxuICAgIDtcbiAgeUF4aXNcbiAgICAub3JpZW50KChyaWdodEFsaWduWUF4aXMpID8gJ3JpZ2h0JyA6ICdsZWZ0JylcbiAgICA7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgeCA9IHhBeGlzLnRpY2tGb3JtYXQoKShsaW5lcy54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgIHkgPSB5QXhpcy50aWNrRm9ybWF0KCkobGluZXMueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgbnVsbCwgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cblxuICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGNoYXJ0KSB9O1xuICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgLy9zZXQgc3RhdGUuZGlzYWJsZWRcbiAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG5cbiAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBEaXNwbGF5IG5vRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIFNjYWxlc1xuXG4gICAgICB4ID0gbGluZXMueFNjYWxlKCk7XG4gICAgICB5ID0gbGluZXMueVNjYWxlKCk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWxpbmVDaGFydCcpLmRhdGEoW2RhdGFdKTtcbiAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LWxpbmVDaGFydCcpLmFwcGVuZCgnZycpO1xuICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICBnRW50ZXIuYXBwZW5kKFwicmVjdFwiKS5zdHlsZShcIm9wYWNpdHlcIiwwKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1saW5lc1dyYXAnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtaW50ZXJhY3RpdmUnKTtcblxuICAgICAgZy5zZWxlY3QoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIixhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwoYXZhaWxhYmxlSGVpZ2h0ID4gMCkgPyBhdmFpbGFibGVIZWlnaHQgOiAwKTtcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBMZWdlbmRcblxuICAgICAgaWYgKHNob3dMZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLndpZHRoKGF2YWlsYWJsZVdpZHRoKTtcblxuICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAuY2FsbChsZWdlbmQpO1xuXG4gICAgICAgIGlmICggbWFyZ2luLnRvcCAhPSBsZWdlbmQuaGVpZ2h0KCkpIHtcbiAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICB9XG5cbiAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJylcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vU2V0IHVwIGludGVyYWN0aXZlIGxheWVyXG4gICAgICBpZiAodXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUpIHtcbiAgICAgICAgaW50ZXJhY3RpdmVMYXllclxuICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAubWFyZ2luKHtsZWZ0Om1hcmdpbi5sZWZ0LCB0b3A6bWFyZ2luLnRvcH0pXG4gICAgICAgICAgIC5zdmdDb250YWluZXIoY29udGFpbmVyKVxuICAgICAgICAgICAueFNjYWxlKHgpO1xuICAgICAgICB3cmFwLnNlbGVjdChcIi5udi1pbnRlcmFjdGl2ZVwiKS5jYWxsKGludGVyYWN0aXZlTGF5ZXIpO1xuICAgICAgfVxuXG5cbiAgICAgIGxpbmVzXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgfSkpO1xuXG5cbiAgICAgIHZhciBsaW5lc1dyYXAgPSBnLnNlbGVjdCgnLm52LWxpbmVzV3JhcCcpXG4gICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuXG4gICAgICBsaW5lc1dyYXAudHJhbnNpdGlvbigpLmNhbGwobGluZXMpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBBeGVzXG5cbiAgICAgIGlmIChzaG93WEF4aXMpIHtcbiAgICAgICAgeEF4aXNcbiAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAudGlja3MoIGF2YWlsYWJsZVdpZHRoIC8gMTAwIClcbiAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodCwgMCk7XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKTtcbiAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgIHlBeGlzXG4gICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVIZWlnaHQgLyAzNiApXG4gICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJylcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbiAgICAgIH1cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgICAgc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgaW50ZXJhY3RpdmVMYXllci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBsaW5lcy5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgICAgICB2YXIgc2luZ2xlUG9pbnQsIHBvaW50SW5kZXgsIHBvaW50WExvY2F0aW9uLCBhbGxEYXRhID0gW107XG4gICAgICAgICAgZGF0YVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oc2VyaWVzLCBpKSB7XG4gICAgICAgICAgICBzZXJpZXMuc2VyaWVzSW5kZXggPSBpO1xuICAgICAgICAgICAgcmV0dXJuICFzZXJpZXMuZGlzYWJsZWQ7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICBwb2ludEluZGV4ID0gbnYuaW50ZXJhY3RpdmVCaXNlY3Qoc2VyaWVzLnZhbHVlcywgZS5wb2ludFhWYWx1ZSwgY2hhcnQueCgpKTtcbiAgICAgICAgICAgICAgbGluZXMuaGlnaGxpZ2h0UG9pbnQoaSwgcG9pbnRJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHZhciBwb2ludCA9IHNlcmllcy52YWx1ZXNbcG9pbnRJbmRleF07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2luZ2xlUG9pbnQgPT09ICd1bmRlZmluZWQnKSBzaW5nbGVQb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50WExvY2F0aW9uID09PSAndW5kZWZpbmVkJykgcG9pbnRYTG9jYXRpb24gPSBjaGFydC54U2NhbGUoKShjaGFydC54KCkocG9pbnQscG9pbnRJbmRleCkpO1xuICAgICAgICAgICAgICBhbGxEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAga2V5OiBzZXJpZXMua2V5LFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYXJ0LnkoKShwb2ludCwgcG9pbnRJbmRleCksXG4gICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3Ioc2VyaWVzLHNlcmllcy5zZXJpZXNJbmRleClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy9IaWdobGlnaHQgdGhlIHRvb2x0aXAgZW50cnkgYmFzZWQgb24gd2hpY2ggcG9pbnQgdGhlIG1vdXNlIGlzIGNsb3Nlc3QgdG8uXG4gICAgICAgICAgaWYgKGFsbERhdGEubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIHlWYWx1ZSA9IGNoYXJ0LnlTY2FsZSgpLmludmVydChlLm1vdXNlWSk7XG4gICAgICAgICAgICB2YXIgZG9tYWluRXh0ZW50ID0gTWF0aC5hYnMoY2hhcnQueVNjYWxlKCkuZG9tYWluKClbMF0gLSBjaGFydC55U2NhbGUoKS5kb21haW4oKVsxXSk7XG4gICAgICAgICAgICB2YXIgdGhyZXNob2xkID0gMC4wMyAqIGRvbWFpbkV4dGVudDtcbiAgICAgICAgICAgIHZhciBpbmRleFRvSGlnaGxpZ2h0ID0gbnYubmVhcmVzdFZhbHVlSW5kZXgoYWxsRGF0YS5tYXAoZnVuY3Rpb24oZCl7cmV0dXJuIGQudmFsdWV9KSx5VmFsdWUsdGhyZXNob2xkKTtcbiAgICAgICAgICAgIGlmIChpbmRleFRvSGlnaGxpZ2h0ICE9PSBudWxsKVxuICAgICAgICAgICAgICBhbGxEYXRhW2luZGV4VG9IaWdobGlnaHRdLmhpZ2hsaWdodCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHhWYWx1ZSA9IHhBeGlzLnRpY2tGb3JtYXQoKShjaGFydC54KCkoc2luZ2xlUG9pbnQscG9pbnRJbmRleCkpO1xuICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIudG9vbHRpcFxuICAgICAgICAgICAgICAgICAgLnBvc2l0aW9uKHtsZWZ0OiBwb2ludFhMb2NhdGlvbiArIG1hcmdpbi5sZWZ0LCB0b3A6IGUubW91c2VZICsgbWFyZ2luLnRvcH0pXG4gICAgICAgICAgICAgICAgICAuY2hhcnRDb250YWluZXIodGhhdC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgLmVuYWJsZWQodG9vbHRpcHMpXG4gICAgICAgICAgICAgICAgICAudmFsdWVGb3JtYXR0ZXIoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4geUF4aXMudGlja0Zvcm1hdCgpKGQpO1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIC5kYXRhKFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB4VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGFsbERhdGFcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICApKCk7XG5cbiAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLnJlbmRlckd1aWRlTGluZShwb2ludFhMb2NhdGlvbik7XG5cbiAgICAgIH0pO1xuXG4gICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKFwiZWxlbWVudE1vdXNlb3V0XCIsZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKCk7XG4gICAgICAgICAgbGluZXMuY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICB9KTtcblxuICAgICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICB9KTtcblxuXG4gICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhLmxlbmd0aCA9PT0gZS5kaXNhYmxlZC5sZW5ndGgpIHtcbiAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IGUuZGlzYWJsZWRbaV07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICB9KTtcblxuICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gIH0pO1xuXG4gIGRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gIH0pO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gIGNoYXJ0LmxpbmVzID0gbGluZXM7XG4gIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbiAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgY2hhcnQuaW50ZXJhY3RpdmVMYXllciA9IGludGVyYWN0aXZlTGF5ZXI7XG5cbiAgZDMucmViaW5kKGNoYXJ0LCBsaW5lcywgJ2RlZmluZWQnLCAnaXNBcmVhJywgJ3gnLCAneScsICdzaXplJywgJ3hTY2FsZScsICd5U2NhbGUnLCAneERvbWFpbicsICd5RG9tYWluJywgJ3hSYW5nZScsICd5UmFuZ2UnXG4gICAgLCAnZm9yY2VYJywgJ2ZvcmNlWScsICdpbnRlcmFjdGl2ZScsICdjbGlwRWRnZScsICdjbGlwVm9yb25vaScsICd1c2VWb3Jvbm9pJywnaWQnLCAnaW50ZXJwb2xhdGUnKTtcblxuICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICB3aWR0aCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuY29sb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sb3I7XG4gICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93TGVnZW5kID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dMZWdlbmQ7XG4gICAgc2hvd0xlZ2VuZCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dYQXhpcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93WEF4aXM7XG4gICAgc2hvd1hBeGlzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd1lBeGlzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dZQXhpcztcbiAgICBzaG93WUF4aXMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5yaWdodEFsaWduWUF4aXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByaWdodEFsaWduWUF4aXM7XG4gICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC51c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lO1xuICAgIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lID0gXztcbiAgICBpZiAoXyA9PT0gdHJ1ZSkge1xuICAgICAgIGNoYXJ0LmludGVyYWN0aXZlKGZhbHNlKTtcbiAgICAgICBjaGFydC51c2VWb3Jvbm9pKGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXBzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXBzO1xuICAgIHRvb2x0aXBzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcDtcbiAgICB0b29sdGlwID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhdGU7XG4gICAgc3RhdGUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5kZWZhdWx0U3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGVmYXVsdFN0YXRlO1xuICAgIGRlZmF1bHRTdGF0ZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0Lm5vRGF0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub0RhdGE7XG4gICAgbm9EYXRhID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgcmV0dXJuIGNoYXJ0O1xufVxuXG5udi5tb2RlbHMubGluZVBsdXNCYXJDaGFydCA9IGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgbGluZXMgPSBudi5tb2RlbHMubGluZSgpXG4gICAgLCBiYXJzID0gbnYubW9kZWxzLmhpc3RvcmljYWxCYXIoKVxuICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgLCB5MUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgLCB5MkF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICA7XG5cbiAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogNjAsIGJvdHRvbTogNTAsIGxlZnQ6IDYwfVxuICAgICwgd2lkdGggPSBudWxsXG4gICAgLCBoZWlnaHQgPSBudWxsXG4gICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH1cbiAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcbiAgICAsIHRvb2x0aXBzID0gdHJ1ZVxuICAgICwgdG9vbHRpcCA9IGZ1bmN0aW9uKGtleSwgeCwgeSwgZSwgZ3JhcGgpIHtcbiAgICAgICAgcmV0dXJuICc8aDM+JyArIGtleSArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICcgYXQgJyArIHggKyAnPC9wPic7XG4gICAgICB9XG4gICAgLCB4XG4gICAgLCB5MVxuICAgICwgeTJcbiAgICAsIHN0YXRlID0ge31cbiAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAsIG5vRGF0YSA9IFwiTm8gRGF0YSBBdmFpbGFibGUuXCJcbiAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJylcbiAgICA7XG5cbiAgYmFyc1xuICAgIC5wYWREYXRhKHRydWUpXG4gICAgO1xuICBsaW5lc1xuICAgIC5jbGlwRWRnZShmYWxzZSlcbiAgICAucGFkRGF0YSh0cnVlKVxuICAgIDtcbiAgeEF4aXNcbiAgICAub3JpZW50KCdib3R0b20nKVxuICAgIC50aWNrUGFkZGluZyg3KVxuICAgIC5oaWdobGlnaHRaZXJvKGZhbHNlKVxuICAgIDtcbiAgeTFBeGlzXG4gICAgLm9yaWVudCgnbGVmdCcpXG4gICAgO1xuICB5MkF4aXNcbiAgICAub3JpZW50KCdyaWdodCcpXG4gICAgO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICAgIHggPSB4QXhpcy50aWNrRm9ybWF0KCkobGluZXMueCgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgIHkgPSAoZS5zZXJpZXMuYmFyID8geTFBeGlzIDogeTJBeGlzKS50aWNrRm9ybWF0KCkobGluZXMueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgIGNvbnRlbnQgPSB0b29sdGlwKGUuc2VyaWVzLmtleSwgeCwgeSwgZSwgY2hhcnQpO1xuXG4gICAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIGUudmFsdWUgPCAwID8gJ24nIDogJ3MnLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgICB9XG4gICAgO1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIudHJhbnNpdGlvbigpLmNhbGwoY2hhcnQpOyB9O1xuICAgICAgLy8gY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgLy9zZXQgc3RhdGUuZGlzYWJsZWRcbiAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG5cbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLmxlbmd0aCB9KS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxuICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgbm9EYXRhVGV4dFxuICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcbiAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgU2NhbGVzXG5cbiAgICAgIHZhciBkYXRhQmFycyA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkICYmIGQuYmFyIH0pO1xuICAgICAgdmFyIGRhdGFMaW5lcyA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmJhciB9KTsgLy8gcmVtb3ZlZCB0aGUgIWQuZGlzYWJsZWQgY2xhdXNlIGhlcmUgdG8gZml4IElzc3VlICMyNDBcblxuICAgICAgLy94ID0geEF4aXMuc2NhbGUoKTtcbiAgICAgICB4ID0gZGF0YUxpbmVzLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZDsgfSkubGVuZ3RoICYmIGRhdGFMaW5lcy5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQ7IH0pWzBdLnZhbHVlcy5sZW5ndGggPyBsaW5lcy54U2NhbGUoKSA6IGJhcnMueFNjYWxlKCk7XG4gICAgICAvL3ggPSBkYXRhTGluZXMuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkOyB9KS5sZW5ndGggPyBsaW5lcy54U2NhbGUoKSA6IGJhcnMueFNjYWxlKCk7IC8vb2xkIGNvZGUgYmVmb3JlIGNoYW5nZSBhYm92ZVxuICAgICAgeTEgPSBiYXJzLnlTY2FsZSgpO1xuICAgICAgeTIgPSBsaW5lcy55U2NhbGUoKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgIHZhciB3cmFwID0gZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWxpbmVQbHVzQmFyJykuZGF0YShbZGF0YV0pO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtbGluZVBsdXNCYXInKS5hcHBlbmQoJ2cnKTtcbiAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkxIG52LWF4aXMnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15MiBudi1heGlzJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYmFyc1dyYXAnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1saW5lc1dyYXAnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIExlZ2VuZFxuXG4gICAgICBpZiAoc2hvd0xlZ2VuZCkge1xuICAgICAgICBsZWdlbmQud2lkdGgoIGF2YWlsYWJsZVdpZHRoIC8gMiApO1xuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAuZGF0dW0oZGF0YS5tYXAoZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICAgIHNlcmllcy5vcmlnaW5hbEtleSA9IHNlcmllcy5vcmlnaW5hbEtleSA9PT0gdW5kZWZpbmVkID8gc2VyaWVzLmtleSA6IHNlcmllcy5vcmlnaW5hbEtleTtcbiAgICAgICAgICAgICAgc2VyaWVzLmtleSA9IHNlcmllcy5vcmlnaW5hbEtleSArIChzZXJpZXMuYmFyID8gJyAobGVmdCBheGlzKScgOiAnIChyaWdodCBheGlzKScpO1xuICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKCBhdmFpbGFibGVXaWR0aCAvIDIgKSArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxuXG5cbiAgICAgIGxpbmVzXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgIWRhdGFbaV0uYmFyIH0pKVxuXG4gICAgICBiYXJzXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS5iYXIgfSkpXG5cblxuXG4gICAgICB2YXIgYmFyc1dyYXAgPSBnLnNlbGVjdCgnLm52LWJhcnNXcmFwJylcbiAgICAgICAgICAuZGF0dW0oZGF0YUJhcnMubGVuZ3RoID8gZGF0YUJhcnMgOiBbe3ZhbHVlczpbXX1dKVxuXG4gICAgICB2YXIgbGluZXNXcmFwID0gZy5zZWxlY3QoJy5udi1saW5lc1dyYXAnKVxuICAgICAgICAgIC5kYXR1bShkYXRhTGluZXNbMF0gJiYgIWRhdGFMaW5lc1swXS5kaXNhYmxlZCA/IGRhdGFMaW5lcyA6IFt7dmFsdWVzOltdfV0gKTtcbiAgICAgICAgICAvLy5kYXR1bSghZGF0YUxpbmVzWzBdLmRpc2FibGVkID8gZGF0YUxpbmVzIDogW3t2YWx1ZXM6ZGF0YUxpbmVzWzBdLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gW2RbMF0sIG51bGxdIH0pIH1dICk7XG5cbiAgICAgIGQzLnRyYW5zaXRpb24oYmFyc1dyYXApLmNhbGwoYmFycyk7XG4gICAgICBkMy50cmFuc2l0aW9uKGxpbmVzV3JhcCkuY2FsbChsaW5lcyk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIEF4ZXNcblxuICAgICAgeEF4aXNcbiAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgIC50aWNrcyggYXZhaWxhYmxlV2lkdGggLyAxMDAgKVxuICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodCwgMCk7XG5cbiAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB5MS5yYW5nZSgpWzBdICsgJyknKTtcbiAgICAgIGQzLnRyYW5zaXRpb24oZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKSlcbiAgICAgICAgICAuY2FsbCh4QXhpcyk7XG5cblxuICAgICAgeTFBeGlzXG4gICAgICAgIC5zY2FsZSh5MSlcbiAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVIZWlnaHQgLyAzNiApXG4gICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICBkMy50cmFuc2l0aW9uKGcuc2VsZWN0KCcubnYteTEubnYtYXhpcycpKVxuICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGRhdGFCYXJzLmxlbmd0aCA/IDEgOiAwKVxuICAgICAgICAgIC5jYWxsKHkxQXhpcyk7XG5cblxuICAgICAgeTJBeGlzXG4gICAgICAgIC5zY2FsZSh5MilcbiAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVIZWlnaHQgLyAzNiApXG4gICAgICAgIC50aWNrU2l6ZShkYXRhQmFycy5sZW5ndGggPyAwIDogLWF2YWlsYWJsZVdpZHRoLCAwKTsgLy8gU2hvdyB0aGUgeTIgcnVsZXMgb25seSBpZiB5MSBoYXMgbm9uZVxuXG4gICAgICBnLnNlbGVjdCgnLm52LXkyLm52LWF4aXMnKVxuICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGRhdGFMaW5lcy5sZW5ndGggPyAxIDogMClcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgYXZhaWxhYmxlV2lkdGggKyAnLDApJyk7XG4gICAgICAgICAgLy8uYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeC5yYW5nZSgpWzFdICsgJywwKScpO1xuXG4gICAgICBkMy50cmFuc2l0aW9uKGcuc2VsZWN0KCcubnYteTIubnYtYXhpcycpKVxuICAgICAgICAgIC5jYWxsKHkyQXhpcyk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7IFxuICAgICAgICBzdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgfSk7XG5cblxuICAgICAgLy8gVXBkYXRlIGNoYXJ0IGZyb20gYSBzdGF0ZSBvYmplY3QgcGFzc2VkIHRvIGV2ZW50IGhhbmRsZXJcbiAgICAgIGRpc3BhdGNoLm9uKCdjaGFuZ2VTdGF0ZScsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIGUuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICB9KTtcblxuICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gIH0pO1xuXG4gIGJhcnMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgfSk7XG5cbiAgYmFycy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gIH0pO1xuXG4gIGRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gIH0pO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbiAgY2hhcnQubGluZXMgPSBsaW5lcztcbiAgY2hhcnQuYmFycyA9IGJhcnM7XG4gIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gIGNoYXJ0LnkxQXhpcyA9IHkxQXhpcztcbiAgY2hhcnQueTJBeGlzID0geTJBeGlzO1xuXG4gIGQzLnJlYmluZChjaGFydCwgbGluZXMsICdkZWZpbmVkJywgJ3NpemUnLCAnY2xpcFZvcm9ub2knLCAnaW50ZXJwb2xhdGUnKTtcbiAgLy9UT0RPOiBjb25zaWRlciByZWJpbmRpbmcgeCwgeSBhbmQgc29tZSBvdGhlciBzdHVmZiwgYW5kIHNpbXBseSBkbyBzb2VtdGhpZ24gbGlsZSBiYXJzLngobGluZXMueCgpKSwgZXRjLlxuICAvL2QzLnJlYmluZChjaGFydCwgbGluZXMsICd4JywgJ3knLCAnc2l6ZScsICd4RG9tYWluJywgJ3lEb21haW4nLCAneFJhbmdlJywgJ3lSYW5nZScsICdmb3JjZVgnLCAnZm9yY2VZJywgJ2ludGVyYWN0aXZlJywgJ2NsaXBFZGdlJywgJ2NsaXBWb3Jvbm9pJywgJ2lkJyk7XG5cbiAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuICBcbiAgY2hhcnQueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXRYO1xuICAgIGdldFggPSBfO1xuICAgIGxpbmVzLngoXyk7XG4gICAgYmFycy54KF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFk7XG4gICAgZ2V0WSA9IF87XG4gICAgbGluZXMueShfKTtcbiAgICBiYXJzLnkoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0Lm1hcmdpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJnaW47XG4gICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICBtYXJnaW4ucmlnaHQgID0gdHlwZW9mIF8ucmlnaHQgICE9ICd1bmRlZmluZWQnID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgbWFyZ2luLmJvdHRvbSA9IHR5cGVvZiBfLmJvdHRvbSAhPSAndW5kZWZpbmVkJyA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQud2lkdGggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XG4gICAgd2lkdGggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5oZWlnaHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xuICAgIGhlaWdodCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd0xlZ2VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93TGVnZW5kO1xuICAgIHNob3dMZWdlbmQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50b29sdGlwcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0b29sdGlwcztcbiAgICB0b29sdGlwcyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXBDb250ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXA7XG4gICAgdG9vbHRpcCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnN0YXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXRlO1xuICAgIHN0YXRlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuZGVmYXVsdFN0YXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRlZmF1bHRTdGF0ZTtcbiAgICBkZWZhdWx0U3RhdGUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5ub0RhdGEgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9EYXRhO1xuICAgIG5vRGF0YSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICByZXR1cm4gY2hhcnQ7XG59XG5udi5tb2RlbHMubGluZVdpdGhGb2N1c0NoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBsaW5lcyA9IG52Lm1vZGVscy5saW5lKClcbiAgICAsIGxpbmVzMiA9IG52Lm1vZGVscy5saW5lKClcbiAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICwgeUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgLCB4MkF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgLCB5MkF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAsIGJydXNoID0gZDMuc3ZnLmJydXNoKClcbiAgICA7XG5cbiAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMzAsIGJvdHRvbTogMzAsIGxlZnQ6IDYwfVxuICAgICwgbWFyZ2luMiA9IHt0b3A6IDAsIHJpZ2h0OiAzMCwgYm90dG9tOiAyMCwgbGVmdDogNjB9XG4gICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgLCB3aWR0aCA9IG51bGxcbiAgICAsIGhlaWdodCA9IG51bGxcbiAgICAsIGhlaWdodDIgPSAxMDBcbiAgICAsIHhcbiAgICAsIHlcbiAgICAsIHgyXG4gICAgLCB5MlxuICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcbiAgICAsIGJydXNoRXh0ZW50ID0gbnVsbFxuICAgICwgdG9vbHRpcHMgPSB0cnVlXG4gICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xuICAgICAgICByZXR1cm4gJzxoMz4nICsga2V5ICsgJzwvaDM+JyArXG4gICAgICAgICAgICAgICAnPHA+JyArICB5ICsgJyBhdCAnICsgeCArICc8L3A+J1xuICAgICAgfVxuICAgICwgbm9EYXRhID0gXCJObyBEYXRhIEF2YWlsYWJsZS5cIlxuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnYnJ1c2gnKVxuICAgICwgdHJhbnNpdGlvbkR1cmF0aW9uID0gMjUwXG4gICAgO1xuXG4gIGxpbmVzXG4gICAgLmNsaXBFZGdlKHRydWUpXG4gICAgO1xuICBsaW5lczJcbiAgICAuaW50ZXJhY3RpdmUoZmFsc2UpXG4gICAgO1xuICB4QXhpc1xuICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgLnRpY2tQYWRkaW5nKDUpXG4gICAgO1xuICB5QXhpc1xuICAgIC5vcmllbnQoJ2xlZnQnKVxuICAgIDtcbiAgeDJBeGlzXG4gICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAudGlja1BhZGRpbmcoNSlcbiAgICA7XG4gIHkyQXhpc1xuICAgIC5vcmllbnQoJ2xlZnQnKVxuICAgIDtcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgeCA9IHhBeGlzLnRpY2tGb3JtYXQoKShsaW5lcy54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgIHkgPSB5QXhpcy50aWNrRm9ybWF0KCkobGluZXMueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgbnVsbCwgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0MSA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tIC0gaGVpZ2h0MixcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQyID0gaGVpZ2h0MiAtIG1hcmdpbjIudG9wIC0gbWFyZ2luMi5ib3R0b207XG5cbiAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikuY2FsbChjaGFydCkgfTtcbiAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodDEgLyAyKVxuICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBTY2FsZXNcblxuICAgICAgeCA9IGxpbmVzLnhTY2FsZSgpO1xuICAgICAgeSA9IGxpbmVzLnlTY2FsZSgpO1xuICAgICAgeDIgPSBsaW5lczIueFNjYWxlKCk7XG4gICAgICB5MiA9IGxpbmVzMi55U2NhbGUoKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcblxuICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtbGluZVdpdGhGb2N1c0NoYXJ0JykuZGF0YShbZGF0YV0pO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtbGluZVdpdGhGb2N1c0NoYXJ0JykuYXBwZW5kKCdnJyk7XG4gICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XG5cbiAgICAgIHZhciBmb2N1c0VudGVyID0gZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWZvY3VzJyk7XG4gICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcbiAgICAgIGZvY3VzRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGluZXNXcmFwJyk7XG5cbiAgICAgIHZhciBjb250ZXh0RW50ZXIgPSBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtY29udGV4dCcpO1xuICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkgbnYtYXhpcycpO1xuICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxpbmVzV3JhcCcpO1xuICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJydXNoQmFja2dyb3VuZCcpO1xuICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYnJ1c2gnKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTGVnZW5kXG5cbiAgICAgIGlmIChzaG93TGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZC53aWR0aChhdmFpbGFibGVXaWR0aCk7XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQxID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20gLSBoZWlnaHQyO1xuICAgICAgICB9XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJylcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG5cbiAgICAgIGxpbmVzXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQxKVxuICAgICAgICAuY29sb3IoXG4gICAgICAgICAgZGF0YVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgIGxpbmVzMlxuICAgICAgICAuZGVmaW5lZChsaW5lcy5kZWZpbmVkKCkpXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQyKVxuICAgICAgICAuY29sb3IoXG4gICAgICAgICAgZGF0YVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCcpXG4gICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKCBhdmFpbGFibGVIZWlnaHQxICsgbWFyZ2luLmJvdHRvbSArIG1hcmdpbjIudG9wKSArICcpJylcblxuICAgICAgdmFyIGNvbnRleHRMaW5lc1dyYXAgPSBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LWxpbmVzV3JhcCcpXG4gICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuXG4gICAgICBkMy50cmFuc2l0aW9uKGNvbnRleHRMaW5lc1dyYXApLmNhbGwobGluZXMyKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvKlxuICAgICAgdmFyIGZvY3VzTGluZXNXcmFwID0gZy5zZWxlY3QoJy5udi1mb2N1cyAubnYtbGluZXNXcmFwJylcbiAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpXG5cbiAgICAgIGQzLnRyYW5zaXRpb24oZm9jdXNMaW5lc1dyYXApLmNhbGwobGluZXMpO1xuICAgICAqL1xuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBNYWluIChGb2N1cykgQXhlc1xuXG4gICAgICB4QXhpc1xuICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVXaWR0aCAvIDEwMCApXG4gICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0MSwgMCk7XG5cbiAgICAgIHlBeGlzXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAudGlja3MoIGF2YWlsYWJsZUhlaWdodDEgLyAzNiApXG4gICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgZy5zZWxlY3QoJy5udi1mb2N1cyAubnYteC5udi1heGlzJylcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyBhdmFpbGFibGVIZWlnaHQxICsgJyknKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgQnJ1c2hcblxuICAgICAgYnJ1c2hcbiAgICAgICAgLngoeDIpXG4gICAgICAgIC5vbignYnJ1c2gnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vV2hlbiBicnVzaGluZywgdHVybiBvZmYgdHJhbnNpdGlvbnMgYmVjYXVzZSBjaGFydCBuZWVkcyB0byBjaGFuZ2UgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICB2YXIgb2xkVHJhbnNpdGlvbiA9IGNoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbigpO1xuICAgICAgICAgICAgY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uKDApOyBcbiAgICAgICAgICAgIG9uQnJ1c2goKTtcbiAgICAgICAgICAgIGNoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbihvbGRUcmFuc2l0aW9uKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIGlmIChicnVzaEV4dGVudCkgYnJ1c2guZXh0ZW50KGJydXNoRXh0ZW50KTtcblxuICAgICAgdmFyIGJydXNoQkcgPSBnLnNlbGVjdCgnLm52LWJydXNoQmFja2dyb3VuZCcpLnNlbGVjdEFsbCgnZycpXG4gICAgICAgICAgLmRhdGEoW2JydXNoRXh0ZW50IHx8IGJydXNoLmV4dGVudCgpXSlcblxuICAgICAgdmFyIGJydXNoQkdlbnRlciA9IGJydXNoQkcuZW50ZXIoKVxuICAgICAgICAgIC5hcHBlbmQoJ2cnKTtcblxuICAgICAgYnJ1c2hCR2VudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZnQnKVxuICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodDIpO1xuXG4gICAgICBicnVzaEJHZW50ZXIuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCAncmlnaHQnKVxuICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodDIpO1xuXG4gICAgICB2YXIgZ0JydXNoID0gZy5zZWxlY3QoJy5udi14Lm52LWJydXNoJylcbiAgICAgICAgICAuY2FsbChicnVzaCk7XG4gICAgICBnQnJ1c2guc2VsZWN0QWxsKCdyZWN0JylcbiAgICAgICAgICAvLy5hdHRyKCd5JywgLTUpXG4gICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodDIpO1xuICAgICAgZ0JydXNoLnNlbGVjdEFsbCgnLnJlc2l6ZScpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCByZXNpemVQYXRoKTtcblxuICAgICAgb25CcnVzaCgpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBTZWNvbmRhcnkgKENvbnRleHQpIEF4ZXNcblxuICAgICAgeDJBeGlzXG4gICAgICAgIC5zY2FsZSh4MilcbiAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVXaWR0aCAvIDEwMCApXG4gICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0MiwgMCk7XG5cbiAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteC5udi1heGlzJylcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB5Mi5yYW5nZSgpWzBdICsgJyknKTtcbiAgICAgIGQzLnRyYW5zaXRpb24oZy5zZWxlY3QoJy5udi1jb250ZXh0IC5udi14Lm52LWF4aXMnKSlcbiAgICAgICAgICAuY2FsbCh4MkF4aXMpO1xuXG5cbiAgICAgIHkyQXhpc1xuICAgICAgICAuc2NhbGUoeTIpXG4gICAgICAgIC50aWNrcyggYXZhaWxhYmxlSGVpZ2h0MiAvIDM2IClcbiAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICBkMy50cmFuc2l0aW9uKGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteS5udi1heGlzJykpXG4gICAgICAgICAgLmNhbGwoeTJBeGlzKTtcblxuICAgICAgZy5zZWxlY3QoJy5udi1jb250ZXh0IC5udi14Lm52LWF4aXMnKVxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkyLnJhbmdlKClbMF0gKyAnKScpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkgeyBcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICB9KTtcblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgLy8gRnVuY3Rpb25zXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAvLyBUYWtlbiBmcm9tIGNyb3NzZmlsdGVyIChodHRwOi8vc3F1YXJlLmdpdGh1Yi5jb20vY3Jvc3NmaWx0ZXIvKVxuICAgICAgZnVuY3Rpb24gcmVzaXplUGF0aChkKSB7XG4gICAgICAgIHZhciBlID0gKyhkID09ICdlJyksXG4gICAgICAgICAgICB4ID0gZSA/IDEgOiAtMSxcbiAgICAgICAgICAgIHkgPSBhdmFpbGFibGVIZWlnaHQyIC8gMztcbiAgICAgICAgcmV0dXJuICdNJyArICguNSAqIHgpICsgJywnICsgeVxuICAgICAgICAgICAgKyAnQTYsNiAwIDAgJyArIGUgKyAnICcgKyAoNi41ICogeCkgKyAnLCcgKyAoeSArIDYpXG4gICAgICAgICAgICArICdWJyArICgyICogeSAtIDYpXG4gICAgICAgICAgICArICdBNiw2IDAgMCAnICsgZSArICcgJyArICguNSAqIHgpICsgJywnICsgKDIgKiB5KVxuICAgICAgICAgICAgKyAnWidcbiAgICAgICAgICAgICsgJ00nICsgKDIuNSAqIHgpICsgJywnICsgKHkgKyA4KVxuICAgICAgICAgICAgKyAnVicgKyAoMiAqIHkgLSA4KVxuICAgICAgICAgICAgKyAnTScgKyAoNC41ICogeCkgKyAnLCcgKyAoeSArIDgpXG4gICAgICAgICAgICArICdWJyArICgyICogeSAtIDgpO1xuICAgICAgfVxuXG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUJydXNoQkcoKSB7XG4gICAgICAgIGlmICghYnJ1c2guZW1wdHkoKSkgYnJ1c2guZXh0ZW50KGJydXNoRXh0ZW50KTtcbiAgICAgICAgYnJ1c2hCR1xuICAgICAgICAgICAgLmRhdGEoW2JydXNoLmVtcHR5KCkgPyB4Mi5kb21haW4oKSA6IGJydXNoRXh0ZW50XSlcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICB2YXIgbGVmdFdpZHRoID0geDIoZFswXSkgLSB4LnJhbmdlKClbMF0sXG4gICAgICAgICAgICAgICAgICByaWdodFdpZHRoID0geC5yYW5nZSgpWzFdIC0geDIoZFsxXSk7XG4gICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJy5sZWZ0JylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAgbGVmdFdpZHRoIDwgMCA/IDAgOiBsZWZ0V2lkdGgpO1xuXG4gICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJy5yaWdodCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4MihkWzFdKSlcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCByaWdodFdpZHRoIDwgMCA/IDAgOiByaWdodFdpZHRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgfVxuXG5cbiAgICAgIGZ1bmN0aW9uIG9uQnJ1c2goKSB7XG4gICAgICAgIGJydXNoRXh0ZW50ID0gYnJ1c2guZW1wdHkoKSA/IG51bGwgOiBicnVzaC5leHRlbnQoKTtcbiAgICAgICAgdmFyIGV4dGVudCA9IGJydXNoLmVtcHR5KCkgPyB4Mi5kb21haW4oKSA6IGJydXNoLmV4dGVudCgpO1xuXG4gICAgICAgIC8vVGhlIGJydXNoIGV4dGVudCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZS4gIElmIGl0IGlzLCBkb24ndCB1cGRhdGUgdGhlIGxpbmUgY2hhcnQuXG4gICAgICAgIGlmIChNYXRoLmFicyhleHRlbnRbMF0gLSBleHRlbnRbMV0pIDw9IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwYXRjaC5icnVzaCh7ZXh0ZW50OiBleHRlbnQsIGJydXNoOiBicnVzaH0pO1xuXG5cbiAgICAgICAgdXBkYXRlQnJ1c2hCRygpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBNYWluIChGb2N1cylcbiAgICAgICAgdmFyIGZvY3VzTGluZXNXcmFwID0gZy5zZWxlY3QoJy5udi1mb2N1cyAubnYtbGluZXNXcmFwJylcbiAgICAgICAgICAgIC5kYXR1bShcbiAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBkLmtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkLnZhbHVlcy5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzLngoKShkLGkpID49IGV4dGVudFswXSAmJiBsaW5lcy54KCkoZCxpKSA8PSBleHRlbnRbMV07XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIGZvY3VzTGluZXNXcmFwLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pLmNhbGwobGluZXMpO1xuXG5cbiAgICAgICAgLy8gVXBkYXRlIE1haW4gKEZvY3VzKSBBeGVzXG4gICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LXgubnYtYXhpcycpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LXkubnYtYXhpcycpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgbGluZXMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgfSk7XG5cbiAgbGluZXMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICB9KTtcblxuICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICB9KTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gIGNoYXJ0LmxpbmVzID0gbGluZXM7XG4gIGNoYXJ0LmxpbmVzMiA9IGxpbmVzMjtcbiAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgY2hhcnQueDJBeGlzID0geDJBeGlzO1xuICBjaGFydC55MkF4aXMgPSB5MkF4aXM7XG5cbiAgZDMucmViaW5kKGNoYXJ0LCBsaW5lcywgJ2RlZmluZWQnLCAnaXNBcmVhJywgJ3NpemUnLCAneERvbWFpbicsICd5RG9tYWluJywgJ3hSYW5nZScsICd5UmFuZ2UnLCAnZm9yY2VYJywgJ2ZvcmNlWScsICdpbnRlcmFjdGl2ZScsICdjbGlwRWRnZScsICdjbGlwVm9yb25vaScsICdpZCcpO1xuXG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcbiAgXG4gIGNoYXJ0LnggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGluZXMueDtcbiAgICBsaW5lcy54KF8pO1xuICAgIGxpbmVzMi54KF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxpbmVzLnk7XG4gICAgbGluZXMueShfKTtcbiAgICBsaW5lczIueShfKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5tYXJnaW4yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjI7XG4gICAgbWFyZ2luMiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LndpZHRoID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgIHdpZHRoID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcbiAgICBoZWlnaHQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5oZWlnaHQyID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDI7XG4gICAgaGVpZ2h0MiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID1udi51dGlscy5nZXRDb2xvcihfKTtcbiAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93TGVnZW5kID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dMZWdlbmQ7XG4gICAgc2hvd0xlZ2VuZCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXBzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXBzO1xuICAgIHRvb2x0aXBzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcDtcbiAgICB0b29sdGlwID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGluZXMuaW50ZXJwb2xhdGUoKTtcbiAgICBsaW5lcy5pbnRlcnBvbGF0ZShfKTtcbiAgICBsaW5lczIuaW50ZXJwb2xhdGUoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0Lm5vRGF0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub0RhdGE7XG4gICAgbm9EYXRhID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgLy8gQ2hhcnQgaGFzIG11bHRpcGxlIHNpbWlsYXIgQXhlcywgdG8gcHJldmVudCBjb2RlIGR1cGxpY2F0aW9uLCBwcm9iYWJseSBuZWVkIHRvIGxpbmsgYWxsIGF4aXMgZnVuY3Rpb25zIG1hbnVhbGx5IGxpa2UgYmVsb3dcbiAgY2hhcnQueFRpY2tGb3JtYXQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geEF4aXMudGlja0Zvcm1hdCgpO1xuICAgIHhBeGlzLnRpY2tGb3JtYXQoXyk7XG4gICAgeDJBeGlzLnRpY2tGb3JtYXQoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnlUaWNrRm9ybWF0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHlBeGlzLnRpY2tGb3JtYXQoKTtcbiAgICB5QXhpcy50aWNrRm9ybWF0KF8pO1xuICAgIHkyQXhpcy50aWNrRm9ybWF0KF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcbiAgXG4gIGNoYXJ0LmJydXNoRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJydXNoRXh0ZW50O1xuICAgIGJydXNoRXh0ZW50ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgcmV0dXJuIGNoYXJ0O1xufVxuXG5udi5tb2RlbHMubGluZVBsdXNCYXJXaXRoRm9jdXNDaGFydCA9IGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgbGluZXMgPSBudi5tb2RlbHMubGluZSgpXG4gICAgLCBsaW5lczIgPSBudi5tb2RlbHMubGluZSgpXG4gICAgLCBiYXJzID0gbnYubW9kZWxzLmhpc3RvcmljYWxCYXIoKVxuICAgICwgYmFyczIgPSBudi5tb2RlbHMuaGlzdG9yaWNhbEJhcigpXG4gICAgLCB4QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIHgyQXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIHkxQXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIHkyQXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIHkzQXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIHk0QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICwgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKVxuICAgIDtcblxuICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAzMCwgYm90dG9tOiAzMCwgbGVmdDogNjB9XG4gICAgLCBtYXJnaW4yID0ge3RvcDogMCwgcmlnaHQ6IDMwLCBib3R0b206IDIwLCBsZWZ0OiA2MH1cbiAgICAsIHdpZHRoID0gbnVsbFxuICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICwgaGVpZ2h0MiA9IDEwMFxuICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9XG4gICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAsIHNob3dMZWdlbmQgPSB0cnVlXG4gICAgLCBleHRlbnRcbiAgICAsIGJydXNoRXh0ZW50ID0gbnVsbFxuICAgICwgdG9vbHRpcHMgPSB0cnVlXG4gICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xuICAgICAgICByZXR1cm4gJzxoMz4nICsga2V5ICsgJzwvaDM+JyArXG4gICAgICAgICAgICAgICAnPHA+JyArICB5ICsgJyBhdCAnICsgeCArICc8L3A+JztcbiAgICAgIH1cbiAgICAsIHhcbiAgICAsIHgyXG4gICAgLCB5MVxuICAgICwgeTJcbiAgICAsIHkzXG4gICAgLCB5NFxuICAgICwgbm9EYXRhID0gXCJObyBEYXRhIEF2YWlsYWJsZS5cIlxuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnYnJ1c2gnKVxuICAgICwgdHJhbnNpdGlvbkR1cmF0aW9uID0gMFxuICAgIDtcblxuICBsaW5lc1xuICAgIC5jbGlwRWRnZSh0cnVlKVxuICAgIDtcbiAgbGluZXMyXG4gICAgLmludGVyYWN0aXZlKGZhbHNlKVxuICAgIDtcbiAgeEF4aXNcbiAgICAub3JpZW50KCdib3R0b20nKVxuICAgIC50aWNrUGFkZGluZyg1KVxuICAgIDtcbiAgeTFBeGlzXG4gICAgLm9yaWVudCgnbGVmdCcpXG4gICAgO1xuICB5MkF4aXNcbiAgICAub3JpZW50KCdyaWdodCcpXG4gICAgO1xuICB4MkF4aXNcbiAgICAub3JpZW50KCdib3R0b20nKVxuICAgIC50aWNrUGFkZGluZyg1KVxuICAgIDtcbiAgeTNBeGlzXG4gICAgLm9yaWVudCgnbGVmdCcpXG4gICAgO1xuICB5NEF4aXNcbiAgICAub3JpZW50KCdyaWdodCcpXG4gICAgO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgIGUucG9pbnRJbmRleCArPSBNYXRoLmNlaWwoZXh0ZW50WzBdKTtcbiAgICB9XG4gICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICB4ID0geEF4aXMudGlja0Zvcm1hdCgpKGxpbmVzLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgeSA9IChlLnNlcmllcy5iYXIgPyB5MUF4aXMgOiB5MkF4aXMpLnRpY2tGb3JtYXQoKShsaW5lcy55KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgIGNvbnRlbnQgPSB0b29sdGlwKGUuc2VyaWVzLmtleSwgeCwgeSwgZSwgY2hhcnQpO1xuXG4gICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBlLnZhbHVlIDwgMCA/ICduJyA6ICdzJywgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cbiAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQxID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20gLSBoZWlnaHQyLFxuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodDIgPSBoZWlnaHQyIC0gbWFyZ2luMi50b3AgLSBtYXJnaW4yLmJvdHRvbTtcblxuICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGNoYXJ0KTsgfTtcbiAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodDEgLyAyKVxuICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBTY2FsZXNcblxuICAgICAgdmFyIGRhdGFCYXJzID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgJiYgZC5iYXIgfSk7XG4gICAgICB2YXIgZGF0YUxpbmVzID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuYmFyIH0pOyAvLyByZW1vdmVkIHRoZSAhZC5kaXNhYmxlZCBjbGF1c2UgaGVyZSB0byBmaXggSXNzdWUgIzI0MFxuXG4gICAgICB4ID0gYmFycy54U2NhbGUoKTtcbiAgICAgIHgyID0geDJBeGlzLnNjYWxlKCk7XG4gICAgICB5MSA9IGJhcnMueVNjYWxlKCk7XG4gICAgICB5MiA9IGxpbmVzLnlTY2FsZSgpO1xuICAgICAgeTMgPSBiYXJzMi55U2NhbGUoKTtcbiAgICAgIHk0ID0gbGluZXMyLnlTY2FsZSgpO1xuXG4gICAgICB2YXIgc2VyaWVzMSA9IGRhdGFcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCAmJiBkLmJhciB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZ2V0WChkLGkpLCB5OiBnZXRZKGQsaSkgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICB2YXIgc2VyaWVzMiA9IGRhdGFcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCAmJiAhZC5iYXIgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIGQudmFsdWVzLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGdldFgoZCxpKSwgeTogZ2V0WShkLGkpIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgeCAgIC5yYW5nZShbMCwgYXZhaWxhYmxlV2lkdGhdKTtcbiAgICAgIFxuICAgICAgeDIgIC5kb21haW4oZDMuZXh0ZW50KGQzLm1lcmdlKHNlcmllczEuY29uY2F0KHNlcmllczIpKSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0gKSlcbiAgICAgICAgICAucmFuZ2UoWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcblxuICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtbGluZVBsdXNCYXInKS5kYXRhKFtkYXRhXSk7XG4gICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1saW5lUGx1c0JhcicpLmFwcGVuZCgnZycpO1xuICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuICAgICAgXG4gICAgICB2YXIgZm9jdXNFbnRlciA9IGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1mb2N1cycpO1xuICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgIGZvY3VzRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteTEgbnYtYXhpcycpO1xuICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15MiBudi1heGlzJyk7XG4gICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG4gICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxpbmVzV3JhcCcpO1xuXG4gICAgICB2YXIgY29udGV4dEVudGVyID0gZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWNvbnRleHQnKTtcbiAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15MSBudi1heGlzJyk7XG4gICAgICBjb250ZXh0RW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteTIgbnYtYXhpcycpO1xuICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG4gICAgICBjb250ZXh0RW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGluZXNXcmFwJyk7XG4gICAgICBjb250ZXh0RW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYnJ1c2hCYWNrZ3JvdW5kJyk7XG4gICAgICBjb250ZXh0RW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1icnVzaCcpO1xuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIExlZ2VuZFxuXG4gICAgICBpZiAoc2hvd0xlZ2VuZCkge1xuICAgICAgICBsZWdlbmQud2lkdGgoIGF2YWlsYWJsZVdpZHRoIC8gMiApO1xuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAuZGF0dW0oZGF0YS5tYXAoZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICAgIHNlcmllcy5vcmlnaW5hbEtleSA9IHNlcmllcy5vcmlnaW5hbEtleSA9PT0gdW5kZWZpbmVkID8gc2VyaWVzLmtleSA6IHNlcmllcy5vcmlnaW5hbEtleTtcbiAgICAgICAgICAgICAgc2VyaWVzLmtleSA9IHNlcmllcy5vcmlnaW5hbEtleSArIChzZXJpZXMuYmFyID8gJyAobGVmdCBheGlzKScgOiAnIChyaWdodCBheGlzKScpO1xuICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQxID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20gLSBoZWlnaHQyO1xuICAgICAgICB9XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoIGF2YWlsYWJsZVdpZHRoIC8gMiApICsgJywnICsgKC1tYXJnaW4udG9wKSArJyknKTtcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIENvbnRleHQgQ29tcG9uZW50c1xuXG4gICAgICBiYXJzMlxuICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0MilcbiAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiBkYXRhW2ldLmJhciB9KSk7XG5cbiAgICAgIGxpbmVzMlxuICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0MilcbiAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiAhZGF0YVtpXS5iYXIgfSkpO1xuICAgICAgICBcbiAgICAgIHZhciBiYXJzMldyYXAgPSBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LWJhcnNXcmFwJylcbiAgICAgICAgICAuZGF0dW0oZGF0YUJhcnMubGVuZ3RoID8gZGF0YUJhcnMgOiBbe3ZhbHVlczpbXX1dKTtcblxuICAgICAgdmFyIGxpbmVzMldyYXAgPSBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LWxpbmVzV3JhcCcpXG4gICAgICAgICAgLmRhdHVtKCFkYXRhTGluZXNbMF0uZGlzYWJsZWQgPyBkYXRhTGluZXMgOiBbe3ZhbHVlczpbXX1dKTtcbiAgICAgICAgICBcbiAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCcpXG4gICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKCBhdmFpbGFibGVIZWlnaHQxICsgbWFyZ2luLmJvdHRvbSArIG1hcmdpbjIudG9wKSArICcpJylcblxuICAgICAgYmFyczJXcmFwLnRyYW5zaXRpb24oKS5jYWxsKGJhcnMyKTtcbiAgICAgIGxpbmVzMldyYXAudHJhbnNpdGlvbigpLmNhbGwobGluZXMyKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBCcnVzaFxuXG4gICAgICBicnVzaFxuICAgICAgICAueCh4MilcbiAgICAgICAgLm9uKCdicnVzaCcsIG9uQnJ1c2gpO1xuXG4gICAgICBpZiAoYnJ1c2hFeHRlbnQpIGJydXNoLmV4dGVudChicnVzaEV4dGVudCk7XG5cbiAgICAgIHZhciBicnVzaEJHID0gZy5zZWxlY3QoJy5udi1icnVzaEJhY2tncm91bmQnKS5zZWxlY3RBbGwoJ2cnKVxuICAgICAgICAgIC5kYXRhKFticnVzaEV4dGVudCB8fCBicnVzaC5leHRlbnQoKV0pXG5cbiAgICAgIHZhciBicnVzaEJHZW50ZXIgPSBicnVzaEJHLmVudGVyKClcbiAgICAgICAgICAuYXBwZW5kKCdnJyk7XG5cbiAgICAgIGJydXNoQkdlbnRlci5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsZWZ0JylcbiAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQyKTtcblxuICAgICAgYnJ1c2hCR2VudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3JpZ2h0JylcbiAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQyKTtcblxuICAgICAgdmFyIGdCcnVzaCA9IGcuc2VsZWN0KCcubnYteC5udi1icnVzaCcpXG4gICAgICAgICAgLmNhbGwoYnJ1c2gpO1xuICAgICAgZ0JydXNoLnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAgICAgLy8uYXR0cigneScsIC01KVxuICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQyKTtcbiAgICAgIGdCcnVzaC5zZWxlY3RBbGwoJy5yZXNpemUnKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgcmVzaXplUGF0aCk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBTZWNvbmRhcnkgKENvbnRleHQpIEF4ZXNcblxuICAgICAgeDJBeGlzXG4gICAgICAgIC50aWNrcyggYXZhaWxhYmxlV2lkdGggLyAxMDAgKVxuICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodDIsIDApO1xuXG4gICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeTMucmFuZ2UoKVswXSArICcpJyk7XG4gICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LXgubnYtYXhpcycpLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5jYWxsKHgyQXhpcyk7XG5cblxuICAgICAgeTNBeGlzXG4gICAgICAgIC5zY2FsZSh5MylcbiAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVIZWlnaHQyIC8gMzYgKVxuICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteTEubnYtYXhpcycpXG4gICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgZGF0YUJhcnMubGVuZ3RoID8gMSA6IDApXG4gICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeDIucmFuZ2UoKVswXSArICcpJyk7XG4gICAgICAgICAgXG4gICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LXkxLm52LWF4aXMnKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAuY2FsbCh5M0F4aXMpO1xuICAgICAgICAgIFxuXG4gICAgICB5NEF4aXNcbiAgICAgICAgLnNjYWxlKHk0KVxuICAgICAgICAudGlja3MoIGF2YWlsYWJsZUhlaWdodDIgLyAzNiApXG4gICAgICAgIC50aWNrU2l6ZShkYXRhQmFycy5sZW5ndGggPyAwIDogLWF2YWlsYWJsZVdpZHRoLCAwKTsgLy8gU2hvdyB0aGUgeTIgcnVsZXMgb25seSBpZiB5MSBoYXMgbm9uZVxuXG4gICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LXkyLm52LWF4aXMnKVxuICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGRhdGFMaW5lcy5sZW5ndGggPyAxIDogMClcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeDIucmFuZ2UoKVsxXSArICcsMCknKTtcblxuICAgICAgZy5zZWxlY3QoJy5udi1jb250ZXh0IC5udi15Mi5udi1heGlzJykudHJhbnNpdGlvbigpXG4gICAgICAgICAgLmNhbGwoeTRBeGlzKTtcbiAgICAgICAgICBcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkgeyBcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICB9KTtcblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgLy8gRnVuY3Rpb25zXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAvLyBUYWtlbiBmcm9tIGNyb3NzZmlsdGVyIChodHRwOi8vc3F1YXJlLmdpdGh1Yi5jb20vY3Jvc3NmaWx0ZXIvKVxuICAgICAgZnVuY3Rpb24gcmVzaXplUGF0aChkKSB7XG4gICAgICAgIHZhciBlID0gKyhkID09ICdlJyksXG4gICAgICAgICAgICB4ID0gZSA/IDEgOiAtMSxcbiAgICAgICAgICAgIHkgPSBhdmFpbGFibGVIZWlnaHQyIC8gMztcbiAgICAgICAgcmV0dXJuICdNJyArICguNSAqIHgpICsgJywnICsgeVxuICAgICAgICAgICAgKyAnQTYsNiAwIDAgJyArIGUgKyAnICcgKyAoNi41ICogeCkgKyAnLCcgKyAoeSArIDYpXG4gICAgICAgICAgICArICdWJyArICgyICogeSAtIDYpXG4gICAgICAgICAgICArICdBNiw2IDAgMCAnICsgZSArICcgJyArICguNSAqIHgpICsgJywnICsgKDIgKiB5KVxuICAgICAgICAgICAgKyAnWidcbiAgICAgICAgICAgICsgJ00nICsgKDIuNSAqIHgpICsgJywnICsgKHkgKyA4KVxuICAgICAgICAgICAgKyAnVicgKyAoMiAqIHkgLSA4KVxuICAgICAgICAgICAgKyAnTScgKyAoNC41ICogeCkgKyAnLCcgKyAoeSArIDgpXG4gICAgICAgICAgICArICdWJyArICgyICogeSAtIDgpO1xuICAgICAgfVxuXG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUJydXNoQkcoKSB7XG4gICAgICAgIGlmICghYnJ1c2guZW1wdHkoKSkgYnJ1c2guZXh0ZW50KGJydXNoRXh0ZW50KTtcbiAgICAgICAgYnJ1c2hCR1xuICAgICAgICAgICAgLmRhdGEoW2JydXNoLmVtcHR5KCkgPyB4Mi5kb21haW4oKSA6IGJydXNoRXh0ZW50XSlcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICB2YXIgbGVmdFdpZHRoID0geDIoZFswXSkgLSB4Mi5yYW5nZSgpWzBdLFxuICAgICAgICAgICAgICAgICAgcmlnaHRXaWR0aCA9IHgyLnJhbmdlKClbMV0gLSB4MihkWzFdKTtcbiAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgnLmxlZnQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsICBsZWZ0V2lkdGggPCAwID8gMCA6IGxlZnRXaWR0aCk7XG5cbiAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgnLnJpZ2h0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHgyKGRbMV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHJpZ2h0V2lkdGggPCAwID8gMCA6IHJpZ2h0V2lkdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICB9XG5cblxuICAgICAgZnVuY3Rpb24gb25CcnVzaCgpIHtcbiAgICAgICAgYnJ1c2hFeHRlbnQgPSBicnVzaC5lbXB0eSgpID8gbnVsbCA6IGJydXNoLmV4dGVudCgpO1xuICAgICAgICBleHRlbnQgPSBicnVzaC5lbXB0eSgpID8geDIuZG9tYWluKCkgOiBicnVzaC5leHRlbnQoKTtcblxuXG4gICAgICAgIGRpc3BhdGNoLmJydXNoKHtleHRlbnQ6IGV4dGVudCwgYnJ1c2g6IGJydXNofSk7XG5cbiAgICAgICAgdXBkYXRlQnJ1c2hCRygpO1xuXG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gUHJlcGFyZSBNYWluIChGb2N1cykgQmFycyBhbmQgTGluZXNcbiAgICAgICAgXG4gICAgICAgIGJhcnNcbiAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodDEpXG4gICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS5iYXIgfSkpO1xuXG5cbiAgICAgICAgbGluZXNcbiAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodDEpXG4gICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgIWRhdGFbaV0uYmFyIH0pKTtcblxuICAgICAgICB2YXIgZm9jdXNCYXJzV3JhcCA9IGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LWJhcnNXcmFwJylcbiAgICAgICAgICAgIC5kYXR1bSghZGF0YUJhcnMubGVuZ3RoID8gW3t2YWx1ZXM6W119XSA6XG4gICAgICAgICAgICAgIGRhdGFCYXJzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogZC5rZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogZC52YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXJzLngoKShkLGkpID49IGV4dGVudFswXSAmJiBiYXJzLngoKShkLGkpIDw9IGV4dGVudFsxXTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBmb2N1c0xpbmVzV3JhcCA9IGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LWxpbmVzV3JhcCcpXG4gICAgICAgICAgICAuZGF0dW0oZGF0YUxpbmVzWzBdLmRpc2FibGVkID8gW3t2YWx1ZXM6W119XSA6XG4gICAgICAgICAgICAgIGRhdGFMaW5lc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGQua2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGQudmFsdWVzLmZpbHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZXMueCgpKGQsaSkgPj0gZXh0ZW50WzBdICYmIGxpbmVzLngoKShkLGkpIDw9IGV4dGVudFsxXTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFVwZGF0ZSBNYWluIChGb2N1cykgWCBBeGlzXG5cbiAgICAgICAgaWYgKGRhdGFCYXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgeCA9IGJhcnMueFNjYWxlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gbGluZXMueFNjYWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHhBeGlzXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoIGF2YWlsYWJsZVdpZHRoIC8gMTAwIClcbiAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQxLCAwKTtcblxuICAgICAgICB4QXhpcy5kb21haW4oW01hdGguY2VpbChleHRlbnRbMF0pLCBNYXRoLmZsb29yKGV4dGVudFsxXSldKTtcbiAgICAgICAgXG4gICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gVXBkYXRlIE1haW4gKEZvY3VzKSBCYXJzIGFuZCBMaW5lc1xuXG4gICAgICAgIGZvY3VzQmFyc1dyYXAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikuY2FsbChiYXJzKTtcbiAgICAgICAgZm9jdXNMaW5lc1dyYXAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikuY2FsbChsaW5lcyk7XG4gICAgICAgIFxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0dXAgYW5kIFVwZGF0ZSBNYWluIChGb2N1cykgWSBBeGVzXG4gICAgICAgIFxuICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi14Lm52LWF4aXMnKVxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkxLnJhbmdlKClbMF0gKyAnKScpO1xuXG5cbiAgICAgICAgeTFBeGlzXG4gICAgICAgIC5zY2FsZSh5MSlcbiAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVIZWlnaHQxIC8gMzYgKVxuICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi15MS5udi1heGlzJylcbiAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBkYXRhQmFycy5sZW5ndGggPyAxIDogMCk7XG5cblxuICAgICAgICB5MkF4aXNcbiAgICAgICAgLnNjYWxlKHkyKVxuICAgICAgICAudGlja3MoIGF2YWlsYWJsZUhlaWdodDEgLyAzNiApXG4gICAgICAgIC50aWNrU2l6ZShkYXRhQmFycy5sZW5ndGggPyAwIDogLWF2YWlsYWJsZVdpZHRoLCAwKTsgLy8gU2hvdyB0aGUgeTIgcnVsZXMgb25seSBpZiB5MSBoYXMgbm9uZVxuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LXkyLm52LWF4aXMnKVxuICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGRhdGFMaW5lcy5sZW5ndGggPyAxIDogMClcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeC5yYW5nZSgpWzFdICsgJywwKScpO1xuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LXkxLm52LWF4aXMnKS50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgICAgICAgICAgLmNhbGwoeTFBeGlzKTtcbiAgICAgICAgZy5zZWxlY3QoJy5udi1mb2N1cyAubnYteTIubnYtYXhpcycpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICAgICAgICAuY2FsbCh5MkF4aXMpO1xuICAgICAgfVxuXG4gICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgICBvbkJydXNoKCk7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGxpbmVzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gIH0pO1xuXG4gIGxpbmVzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgfSk7XG5cbiAgYmFycy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICB9KTtcblxuICBiYXJzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgfSk7XG5cbiAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgfSk7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICBjaGFydC5saW5lcyA9IGxpbmVzO1xuICBjaGFydC5saW5lczIgPSBsaW5lczI7XG4gIGNoYXJ0LmJhcnMgPSBiYXJzO1xuICBjaGFydC5iYXJzMiA9IGJhcnMyO1xuICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICBjaGFydC54MkF4aXMgPSB4MkF4aXM7XG4gIGNoYXJ0LnkxQXhpcyA9IHkxQXhpcztcbiAgY2hhcnQueTJBeGlzID0geTJBeGlzO1xuICBjaGFydC55M0F4aXMgPSB5M0F4aXM7XG4gIGNoYXJ0Lnk0QXhpcyA9IHk0QXhpcztcblxuICBkMy5yZWJpbmQoY2hhcnQsIGxpbmVzLCAnZGVmaW5lZCcsICdzaXplJywgJ2NsaXBWb3Jvbm9pJywgJ2ludGVycG9sYXRlJyk7XG4gIC8vVE9ETzogY29uc2lkZXIgcmViaW5kaW5nIHgsIHkgYW5kIHNvbWUgb3RoZXIgc3R1ZmYsIGFuZCBzaW1wbHkgZG8gc29lbXRoaWduIGxpbGUgYmFycy54KGxpbmVzLngoKSksIGV0Yy5cbiAgLy9kMy5yZWJpbmQoY2hhcnQsIGxpbmVzLCAneCcsICd5JywgJ3NpemUnLCAneERvbWFpbicsICd5RG9tYWluJywgJ3hSYW5nZScsICd5UmFuZ2UnLCAnZm9yY2VYJywgJ2ZvcmNlWScsICdpbnRlcmFjdGl2ZScsICdjbGlwRWRnZScsICdjbGlwVm9yb25vaScsICdpZCcpO1xuXG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcbiAgXG4gIGNoYXJ0LnggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ2V0WDtcbiAgICBnZXRYID0gXztcbiAgICBsaW5lcy54KF8pO1xuICAgIGJhcnMueChfKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXRZO1xuICAgIGdldFkgPSBfO1xuICAgIGxpbmVzLnkoXyk7XG4gICAgYmFycy55KF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFyZ2luO1xuICAgIG1hcmdpbi50b3AgICAgPSB0eXBlb2YgXy50b3AgICAgIT0gJ3VuZGVmaW5lZCcgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LndpZHRoID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgIHdpZHRoID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcbiAgICBoZWlnaHQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5jb2xvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2xvcjtcbiAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dMZWdlbmQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd0xlZ2VuZDtcbiAgICBzaG93TGVnZW5kID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcHMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcHM7XG4gICAgdG9vbHRpcHMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50b29sdGlwQ29udGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0b29sdGlwO1xuICAgIHRvb2x0aXAgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5ub0RhdGEgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9EYXRhO1xuICAgIG5vRGF0YSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmJydXNoRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJydXNoRXh0ZW50O1xuICAgIGJydXNoRXh0ZW50ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgcmV0dXJuIGNoYXJ0O1xufVxuXG5udi5tb2RlbHMubXVsdGlCYXIgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgLCB3aWR0aCA9IDk2MFxuICAgICwgaGVpZ2h0ID0gNTAwXG4gICAgLCB4ID0gZDMuc2NhbGUub3JkaW5hbCgpXG4gICAgLCB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAsIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApIC8vQ3JlYXRlIHNlbWktdW5pcXVlIElEIGluIGNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcbiAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICwgZ2V0WSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9XG4gICAgLCBmb3JjZVkgPSBbMF0gLy8gMCBpcyBmb3JjZWQgYnkgZGVmYXVsdC4uIHRoaXMgbWFrZXMgc2Vuc2UgZm9yIHRoZSBtYWpvcml0eSBvZiBiYXIgZ3JhcGhzLi4uIHVzZXIgY2FuIGFsd2F5cyBkbyBjaGFydC5mb3JjZVkoW10pIHRvIHJlbW92ZVxuICAgICwgY2xpcEVkZ2UgPSB0cnVlXG4gICAgLCBzdGFja2VkID0gZmFsc2VcbiAgICAsIHN0YWNrT2Zmc2V0ID0gJ3plcm8nIC8vIG9wdGlvbnMgaW5jbHVkZSAnc2lsaG91ZXR0ZScsICd3aWdnbGUnLCAnZXhwYW5kJywgJ3plcm8nLCBvciBhIGN1c3RvbSBmdW5jdGlvblxuICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICwgaGlkZWFibGUgPSBmYWxzZVxuICAgICwgYmFyQ29sb3IgPSBudWxsIC8vIGFkZGluZyB0aGUgYWJpbGl0eSB0byBzZXQgdGhlIGNvbG9yIGZvciBlYWNoIHJhdGhlciB0aGFuIHRoZSB3aG9sZSBncm91cFxuICAgICwgZGlzYWJsZWQgLy8gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGJhckNvbG9yIHRvIGNvbW11bmljYXRlIGZyb20gbXVsdGlCYXJIb3Jpem9udGFsQ2hhcnQgd2hhdCBzZXJpZXMgYXJlIGRpc2FibGVkXG4gICAgLCBkZWxheSA9IDEyMDBcbiAgICAsIHhEb21haW5cbiAgICAsIHlEb21haW5cbiAgICAsIHhSYW5nZVxuICAgICwgeVJhbmdlXG4gICAgLCBncm91cFNwYWNpbmcgPSAwLjFcbiAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2NoYXJ0Q2xpY2snLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxDbGljaycsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcpXG4gICAgO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciB4MCwgeTAgLy91c2VkIHRvIHN0b3JlIHByZXZpb3VzIHNjYWxlc1xuICAgICAgO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcblxuICAgICAgaWYoaGlkZWFibGUgJiYgZGF0YS5sZW5ndGgpIGhpZGVhYmxlID0gW3tcbiAgICAgICAgdmFsdWVzOiBkYXRhWzBdLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGQueCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHNlcmllczogZC5zZXJpZXMsXG4gICAgICAgICAgc2l6ZTogMC4wMVxuICAgICAgICB9O31cbiAgICAgICl9XTtcblxuICAgICAgaWYgKHN0YWNrZWQpXG4gICAgICAgIGRhdGEgPSBkMy5sYXlvdXQuc3RhY2soKVxuICAgICAgICAgICAgICAgICAub2Zmc2V0KHN0YWNrT2Zmc2V0KVxuICAgICAgICAgICAgICAgICAudmFsdWVzKGZ1bmN0aW9uKGQpeyByZXR1cm4gZC52YWx1ZXMgfSlcbiAgICAgICAgICAgICAgICAgLnkoZ2V0WSlcbiAgICAgICAgICAgICAgICAgKCFkYXRhLmxlbmd0aCAmJiBoaWRlYWJsZSA/IGhpZGVhYmxlIDogZGF0YSk7XG5cblxuICAgICAgLy9hZGQgc2VyaWVzIGluZGV4IHRvIGVhY2ggZGF0YSBwb2ludCBmb3IgcmVmZXJlbmNlXG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLCBpKSB7XG4gICAgICAgIHNlcmllcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgIHBvaW50LnNlcmllcyA9IGk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIEhBQ0sgZm9yIG5lZ2F0aXZlIHZhbHVlIHN0YWNraW5nXG4gICAgICBpZiAoc3RhY2tlZClcbiAgICAgICAgZGF0YVswXS52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgIHZhciBwb3NCYXNlID0gMCwgbmVnQmFzZSA9IDA7XG4gICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIGYgPSBkLnZhbHVlc1tpXVxuICAgICAgICAgICAgZi5zaXplID0gTWF0aC5hYnMoZi55KTtcbiAgICAgICAgICAgIGlmIChmLnk8MCkgIHtcbiAgICAgICAgICAgICAgZi55MSA9IG5lZ0Jhc2U7XG4gICAgICAgICAgICAgIG5lZ0Jhc2UgPSBuZWdCYXNlIC0gZi5zaXplO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGYueTEgPSBmLnNpemUgKyBwb3NCYXNlO1xuICAgICAgICAgICAgICBwb3NCYXNlID0gcG9zQmFzZSArIGYuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBTY2FsZXNcblxuICAgICAgLy8gcmVtYXAgYW5kIGZsYXR0ZW4gdGhlIGRhdGEgZm9yIHVzZSBpbiBjYWxjdWxhdGluZyB0aGUgc2NhbGVzJyBkb21haW5zXG4gICAgICB2YXIgc2VyaWVzRGF0YSA9ICh4RG9tYWluICYmIHlEb21haW4pID8gW10gOiAvLyBpZiB3ZSBrbm93IHhEb21haW4gYW5kIHlEb21haW4sIG5vIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICBkYXRhLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZ2V0WChkLGkpLCB5OiBnZXRZKGQsaSksIHkwOiBkLnkwLCB5MTogZC55MSB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgeCAgIC5kb21haW4oeERvbWFpbiB8fCBkMy5tZXJnZShzZXJpZXNEYXRhKS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0pKVxuICAgICAgICAgIC5yYW5nZUJhbmRzKHhSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdLCBncm91cFNwYWNpbmcpO1xuXG4gICAgICAvL3kgICAuZG9tYWluKHlEb21haW4gfHwgZDMuZXh0ZW50KGQzLm1lcmdlKHNlcmllc0RhdGEpLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgKyAoc3RhY2tlZCA/IGQueTEgOiAwKSB9KS5jb25jYXQoZm9yY2VZKSkpXG4gICAgICB5ICAgLmRvbWFpbih5RG9tYWluIHx8IGQzLmV4dGVudChkMy5tZXJnZShzZXJpZXNEYXRhKS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gc3RhY2tlZCA/IChkLnkgPiAwID8gZC55MSA6IGQueTEgKyBkLnkgKSA6IGQueSB9KS5jb25jYXQoZm9yY2VZKSkpXG4gICAgICAgICAgLnJhbmdlKHlSYW5nZSB8fCBbYXZhaWxhYmxlSGVpZ2h0LCAwXSk7XG5cbiAgICAgIC8vIElmIHNjYWxlJ3MgZG9tYWluIGRvbid0IGhhdmUgYSByYW5nZSwgc2xpZ2h0bHkgYWRqdXN0IHRvIG1ha2Ugb25lLi4uIHNvIGEgY2hhcnQgY2FuIHNob3cgYSBzaW5nbGUgZGF0YSBwb2ludFxuICAgICAgaWYgKHguZG9tYWluKClbMF0gPT09IHguZG9tYWluKClbMV0pXG4gICAgICAgIHguZG9tYWluKClbMF0gP1xuICAgICAgICAgICAgeC5kb21haW4oW3guZG9tYWluKClbMF0gLSB4LmRvbWFpbigpWzBdICogMC4wMSwgeC5kb21haW4oKVsxXSArIHguZG9tYWluKClbMV0gKiAwLjAxXSlcbiAgICAgICAgICA6IHguZG9tYWluKFstMSwxXSk7XG5cbiAgICAgIGlmICh5LmRvbWFpbigpWzBdID09PSB5LmRvbWFpbigpWzFdKVxuICAgICAgICB5LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgIHkuZG9tYWluKFt5LmRvbWFpbigpWzBdICsgeS5kb21haW4oKVswXSAqIDAuMDEsIHkuZG9tYWluKClbMV0gLSB5LmRvbWFpbigpWzFdICogMC4wMV0pXG4gICAgICAgICAgOiB5LmRvbWFpbihbLTEsMV0pO1xuXG5cbiAgICAgIHgwID0geDAgfHwgeDtcbiAgICAgIHkwID0geTAgfHwgeTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcblxuICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtbXVsdGliYXInKS5kYXRhKFtkYXRhXSk7XG4gICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1tdWx0aWJhcicpO1xuICAgICAgdmFyIGRlZnNFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2RlZnMnKTtcbiAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJylcblxuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWdyb3VwcycpO1xuXG4gICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXG4gICAgICBkZWZzRW50ZXIuYXBwZW5kKCdjbGlwUGF0aCcpXG4gICAgICAgICAgLmF0dHIoJ2lkJywgJ252LWVkZ2UtY2xpcC0nICsgaWQpXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcbiAgICAgIHdyYXAuc2VsZWN0KCcjbnYtZWRnZS1jbGlwLScgKyBpZCArICcgcmVjdCcpXG4gICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgIGcgICAuYXR0cignY2xpcC1wYXRoJywgY2xpcEVkZ2UgPyAndXJsKCNudi1lZGdlLWNsaXAtJyArIGlkICsgJyknIDogJycpO1xuXG5cblxuICAgICAgdmFyIGdyb3VwcyA9IHdyYXAuc2VsZWN0KCcubnYtZ3JvdXBzJykuc2VsZWN0QWxsKCcubnYtZ3JvdXAnKVxuICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSwgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBpIH0pO1xuICAgICAgZ3JvdXBzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMWUtNilcbiAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDFlLTYpO1xuICAgICAgZ3JvdXBzLmV4aXQoKVxuICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QubnYtYmFyJylcbiAgICAgICAgLmRlbGF5KGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgIHJldHVybiBpICogZGVsYXkvIGRhdGFbMF0udmFsdWVzLmxlbmd0aDtcbiAgICAgICAgfSlcbiAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHN0YWNrZWQgPyB5MChkLnkwKSA6IHkwKDApIH0pXG4gICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDApXG4gICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgZ3JvdXBzXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAnbnYtZ3JvdXAgbnYtc2VyaWVzLScgKyBpIH0pXG4gICAgICAgICAgLmNsYXNzZWQoJ2hvdmVyJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5ob3ZlciB9KVxuICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSl7IHJldHVybiBjb2xvcihkLCBpKSB9KVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKXsgcmV0dXJuIGNvbG9yKGQsIGkpIH0pO1xuICAgICAgZ3JvdXBzXG4gICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxuICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgLjc1KTtcblxuXG4gICAgICB2YXIgYmFycyA9IGdyb3Vwcy5zZWxlY3RBbGwoJ3JlY3QubnYtYmFyJylcbiAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiAoaGlkZWFibGUgJiYgIWRhdGEubGVuZ3RoKSA/IGhpZGVhYmxlLnZhbHVlcyA6IGQudmFsdWVzIH0pO1xuXG4gICAgICBiYXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuXG4gICAgICB2YXIgYmFyc0VudGVyID0gYmFycy5lbnRlcigpLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRZKGQsaSkgPCAwID8gJ252LWJhciBuZWdhdGl2ZScgOiAnbnYtYmFyIHBvc2l0aXZlJ30pXG4gICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbihkLGksaikge1xuICAgICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA/IDAgOiAoaiAqIHgucmFuZ2VCYW5kKCkgLyBkYXRhLmxlbmd0aCApXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHkwKHN0YWNrZWQgPyBkLnkwIDogMCkgfSlcbiAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMClcbiAgICAgICAgICAuYXR0cignd2lkdGgnLCB4LnJhbmdlQmFuZCgpIC8gKHN0YWNrZWQgPyAxIDogZGF0YS5sZW5ndGgpIClcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4KGdldFgoZCxpKSkgKyAnLDApJzsgfSlcbiAgICAgICAgICA7XG4gICAgICBiYXJzXG4gICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCxpLGopeyByZXR1cm4gY29sb3IoZCwgaiwgaSk7ICB9KVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpLGopeyByZXR1cm4gY29sb3IoZCwgaiwgaSk7IH0pXG4gICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGkpIHsgLy9UT0RPOiBmaWd1cmUgb3V0IHdoeSBqIHdvcmtzIGFib3ZlLCBidXQgbm90IGhlcmVcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQsaSksXG4gICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICBwb3M6IFt4KGdldFgoZCxpKSkgKyAoeC5yYW5nZUJhbmQoKSAqIChzdGFja2VkID8gZGF0YS5sZW5ndGggLyAyIDogZC5zZXJpZXMgKyAuNSkgLyBkYXRhLmxlbmd0aCksIHkoZ2V0WShkLGkpICsgKHN0YWNrZWQgPyBkLnkwIDogMCkpXSwgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoZSB2YWx1ZSBhcHBlYXJzIHRvIGJlIHNoaWZ0ZWRcbiAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50Q2xpY2soe1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpICsgKHgucmFuZ2VCYW5kKCkgKiAoc3RhY2tlZCA/IGRhdGEubGVuZ3RoIC8gMiA6IGQuc2VyaWVzICsgLjUpIC8gZGF0YS5sZW5ndGgpLCB5KGdldFkoZCxpKSArIChzdGFja2VkID8gZC55MCA6IDApKV0sICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgdmFsdWUgYXBwZWFycyB0byBiZSBzaGlmdGVkXG4gICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50RGJsQ2xpY2soe1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpICsgKHgucmFuZ2VCYW5kKCkgKiAoc3RhY2tlZCA/IGRhdGEubGVuZ3RoIC8gMiA6IGQuc2VyaWVzICsgLjUpIC8gZGF0YS5sZW5ndGgpLCB5KGdldFkoZCxpKSArIChzdGFja2VkID8gZC55MCA6IDApKV0sICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgdmFsdWUgYXBwZWFycyB0byBiZSBzaGlmdGVkXG4gICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfSk7XG4gICAgICBiYXJzXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRZKGQsaSkgPCAwID8gJ252LWJhciBuZWdhdGl2ZScgOiAnbnYtYmFyIHBvc2l0aXZlJ30pXG4gICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoZ2V0WChkLGkpKSArICcsMCknOyB9KVxuXG4gICAgICBpZiAoYmFyQ29sb3IpIHtcbiAgICAgICAgaWYgKCFkaXNhYmxlZCkgZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIHRydWUgfSk7XG4gICAgICAgIGJhcnNcbiAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGksaikgeyByZXR1cm4gZDMucmdiKGJhckNvbG9yKGQsaSkpLmRhcmtlciggIGRpc2FibGVkLm1hcChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGkgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSl7IHJldHVybiAhZGlzYWJsZWRbaV0gIH0pW2pdICAgKS50b1N0cmluZygpOyB9KVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuIGQzLnJnYihiYXJDb2xvcihkLGkpKS5kYXJrZXIoICBkaXNhYmxlZC5tYXAoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBpIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpeyByZXR1cm4gIWRpc2FibGVkW2ldICB9KVtqXSAgICkudG9TdHJpbmcoKTsgfSk7XG4gICAgICB9XG5cblxuICAgICAgaWYgKHN0YWNrZWQpXG4gICAgICAgICAgYmFycy50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kZWxheShmdW5jdGlvbihkLGkpIHtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKiBkZWxheSAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQsaSkge1xuXG4gICAgICAgICAgICAgIHJldHVybiB5KChzdGFja2VkID8gZC55MSA6IDApKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLmFicyh5KGQueSArIChzdGFja2VkID8gZC55MCA6IDApKSAtIHkoKHN0YWNrZWQgPyBkLnkwIDogMCkpKSwxKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPyAwIDogKGQuc2VyaWVzICogeC5yYW5nZUJhbmQoKSAvIGRhdGEubGVuZ3RoIClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCB4LnJhbmdlQmFuZCgpIC8gKHN0YWNrZWQgPyAxIDogZGF0YS5sZW5ndGgpICk7XG4gICAgICBlbHNlXG4gICAgICAgICAgYmFycy50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kZWxheShmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAqIGRlbGF5LyBkYXRhWzBdLnZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQuc2VyaWVzICogeC5yYW5nZUJhbmQoKSAvIGRhdGEubGVuZ3RoXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgeC5yYW5nZUJhbmQoKSAvIGRhdGEubGVuZ3RoKVxuICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0WShkLGkpIDwgMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICB5KDApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHkoMCkgLSB5KGdldFkoZCxpKSkgPCAxID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSAtIDEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgeShnZXRZKGQsaSkpIHx8IDA7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLmFicyh5KGdldFkoZCxpKSkgLSB5KDApKSwxKSB8fCAwO1xuICAgICAgICAgICAgfSk7XG5cblxuXG4gICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgIHgwID0geC5jb3B5KCk7XG4gICAgICB5MCA9IHkuY29weSgpO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcblxuICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgY2hhcnQueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXRYO1xuICAgIGdldFggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFk7XG4gICAgZ2V0WSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0Lm1hcmdpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJnaW47XG4gICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICBtYXJnaW4ucmlnaHQgID0gdHlwZW9mIF8ucmlnaHQgICE9ICd1bmRlZmluZWQnID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgbWFyZ2luLmJvdHRvbSA9IHR5cGVvZiBfLmJvdHRvbSAhPSAndW5kZWZpbmVkJyA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQud2lkdGggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XG4gICAgd2lkdGggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5oZWlnaHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xuICAgIGhlaWdodCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnhTY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4O1xuICAgIHggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55U2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICB5ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueERvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4RG9tYWluO1xuICAgIHhEb21haW4gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55RG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHlEb21haW47XG4gICAgeURvbWFpbiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnhSYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4UmFuZ2U7XG4gICAgeFJhbmdlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueVJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHlSYW5nZTtcbiAgICB5UmFuZ2UgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5mb3JjZVkgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZm9yY2VZO1xuICAgIGZvcmNlWSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnN0YWNrZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhY2tlZDtcbiAgICBzdGFja2VkID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc3RhY2tPZmZzZXQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhY2tPZmZzZXQ7XG4gICAgc3RhY2tPZmZzZXQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5jbGlwRWRnZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGlwRWRnZTtcbiAgICBjbGlwRWRnZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmJhckNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJhckNvbG9yO1xuICAgIGJhckNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmRpc2FibGVkID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRpc2FibGVkO1xuICAgIGRpc2FibGVkID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaWQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaWQ7XG4gICAgaWQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5oaWRlYWJsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoaWRlYWJsZTtcbiAgICBoaWRlYWJsZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmRlbGF5ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRlbGF5O1xuICAgIGRlbGF5ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuZ3JvdXBTcGFjaW5nID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyb3VwU3BhY2luZztcbiAgICBncm91cFNwYWNpbmcgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgcmV0dXJuIGNoYXJ0O1xufVxuXG5udi5tb2RlbHMubXVsdGlCYXJDaGFydCA9IGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgbXVsdGliYXIgPSBudi5tb2RlbHMubXVsdGlCYXIoKVxuICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgLCB5QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICwgY29udHJvbHMgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICA7XG5cbiAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMjAsIGJvdHRvbTogNTAsIGxlZnQ6IDYwfVxuICAgICwgd2lkdGggPSBudWxsXG4gICAgLCBoZWlnaHQgPSBudWxsXG4gICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgLCBzaG93Q29udHJvbHMgPSB0cnVlXG4gICAgLCBzaG93TGVnZW5kID0gdHJ1ZVxuICAgICwgc2hvd1hBeGlzID0gdHJ1ZVxuICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxuICAgICwgcmlnaHRBbGlnbllBeGlzID0gZmFsc2VcbiAgICAsIHJlZHVjZVhUaWNrcyA9IHRydWUgLy8gaWYgZmFsc2UgYSB0aWNrIHdpbGwgc2hvdyBmb3IgZXZlcnkgZGF0YSBwb2ludFxuICAgICwgc3RhZ2dlckxhYmVscyA9IGZhbHNlXG4gICAgLCByb3RhdGVMYWJlbHMgPSAwXG4gICAgLCB0b29sdGlwcyA9IHRydWVcbiAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgIHJldHVybiAnPGgzPicgKyBrZXkgKyAnPC9oMz4nICtcbiAgICAgICAgICAgICAgICc8cD4nICsgIHkgKyAnIG9uICcgKyB4ICsgJzwvcD4nXG4gICAgICB9XG4gICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxuICAgICwgeSAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueVNjYWxlKClcbiAgICAsIHN0YXRlID0geyBzdGFja2VkOiBmYWxzZSB9XG4gICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgLCBub0RhdGEgPSBcIk5vIERhdGEgQXZhaWxhYmxlLlwiXG4gICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScpXG4gICAgLCBjb250cm9sV2lkdGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNob3dDb250cm9scyA/IDE4MCA6IDAgfVxuICAgICwgdHJhbnNpdGlvbkR1cmF0aW9uID0gMjUwXG4gICAgO1xuXG4gIG11bHRpYmFyXG4gICAgLnN0YWNrZWQoZmFsc2UpXG4gICAgO1xuICB4QXhpc1xuICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgLnRpY2tQYWRkaW5nKDcpXG4gICAgLmhpZ2hsaWdodFplcm8odHJ1ZSlcbiAgICAuc2hvd01heE1pbihmYWxzZSlcbiAgICAudGlja0Zvcm1hdChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pXG4gICAgO1xuICB5QXhpc1xuICAgIC5vcmllbnQoKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgIC50aWNrRm9ybWF0KGQzLmZvcm1hdCgnLC4xZicpKVxuICAgIDtcblxuICBjb250cm9scy51cGRhdGVTdGF0ZShmYWxzZSk7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQgfHwgMCApLFxuICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgIHggPSB4QXhpcy50aWNrRm9ybWF0KCkobXVsdGliYXIueCgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICB5ID0geUF4aXMudGlja0Zvcm1hdCgpKG11bHRpYmFyLnkoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgY29udGVudCA9IHRvb2x0aXAoZS5zZXJpZXMua2V5LCB4LCB5LCBlLCBjaGFydCk7XG5cbiAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIGUudmFsdWUgPCAwID8gJ24nIDogJ3MnLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgfTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGNoYXJ0KSB9O1xuICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgLy9zZXQgc3RhdGUuZGlzYWJsZWRcbiAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIERpc3BsYXkgbm9EYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG5cbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLmxlbmd0aCB9KS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxuICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgbm9EYXRhVGV4dFxuICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcbiAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgU2NhbGVzXG5cbiAgICAgIHggPSBtdWx0aWJhci54U2NhbGUoKTtcbiAgICAgIHkgPSBtdWx0aWJhci55U2NhbGUoKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcblxuICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtbXVsdGlCYXJXaXRoTGVnZW5kJykuZGF0YShbZGF0YV0pO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtbXVsdGlCYXJXaXRoTGVnZW5kJykuYXBwZW5kKCdnJyk7XG4gICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1iYXJzV3JhcCcpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1jb250cm9sc1dyYXAnKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTGVnZW5kXG5cbiAgICAgIGlmIChzaG93TGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZC53aWR0aChhdmFpbGFibGVXaWR0aCAtIGNvbnRyb2xXaWR0aCgpKTtcblxuICAgICAgICBpZiAobXVsdGliYXIuYmFyQ29sb3IoKSlcbiAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgIHNlcmllcy5jb2xvciA9IGQzLnJnYignI2NjYycpLmRhcmtlcihpICogMS41KS50b1N0cmluZygpO1xuICAgICAgICAgIH0pXG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgY29udHJvbFdpZHRoKCkgKyAnLCcgKyAoLW1hcmdpbi50b3ApICsnKScpO1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBDb250cm9sc1xuXG4gICAgICBpZiAoc2hvd0NvbnRyb2xzKSB7XG4gICAgICAgIHZhciBjb250cm9sc0RhdGEgPSBbXG4gICAgICAgICAgeyBrZXk6ICdHcm91cGVkJywgZGlzYWJsZWQ6IG11bHRpYmFyLnN0YWNrZWQoKSB9LFxuICAgICAgICAgIHsga2V5OiAnU3RhY2tlZCcsIGRpc2FibGVkOiAhbXVsdGliYXIuc3RhY2tlZCgpIH1cbiAgICAgICAgXTtcblxuICAgICAgICBjb250cm9scy53aWR0aChjb250cm9sV2lkdGgoKSkuY29sb3IoWycjNDQ0JywgJyM0NDQnLCAnIzQ0NCddKTtcbiAgICAgICAgZy5zZWxlY3QoJy5udi1jb250cm9sc1dyYXAnKVxuICAgICAgICAgICAgLmRhdHVtKGNvbnRyb2xzRGF0YSlcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJylcbiAgICAgICAgICAgIC5jYWxsKGNvbnRyb2xzKTtcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgIGlmIChyaWdodEFsaWduWUF4aXMpIHtcbiAgICAgICAgICBnLnNlbGVjdChcIi5udi15Lm52LWF4aXNcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBhdmFpbGFibGVXaWR0aCArIFwiLDApXCIpO1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTWFpbiBDaGFydCBDb21wb25lbnQocylcblxuICAgICAgbXVsdGliYXJcbiAgICAgICAgLmRpc2FibGVkKGRhdGEubWFwKGZ1bmN0aW9uKHNlcmllcykgeyByZXR1cm4gc2VyaWVzLmRpc2FibGVkIH0pKVxuICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkIH0pKVxuXG5cbiAgICAgIHZhciBiYXJzV3JhcCA9IGcuc2VsZWN0KCcubnYtYmFyc1dyYXAnKVxuICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSlcblxuICAgICAgYmFyc1dyYXAudHJhbnNpdGlvbigpLmNhbGwobXVsdGliYXIpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBBeGVzXG5cbiAgICAgIGlmIChzaG93WEF4aXMpIHtcbiAgICAgICAgICB4QXhpc1xuICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAudGlja3MoIGF2YWlsYWJsZVdpZHRoIC8gMTAwIClcbiAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcblxuICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKTtcbiAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG5cbiAgICAgICAgICB2YXIgeFRpY2tzID0gZy5zZWxlY3QoJy5udi14Lm52LWF4aXMgPiBnJykuc2VsZWN0QWxsKCdnJyk7XG5cbiAgICAgICAgICB4VGlja3NcbiAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGluZSwgdGV4dCcpXG4gICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpXG5cbiAgICAgICAgICBpZiAoc3RhZ2dlckxhYmVscykge1xuICAgICAgICAgICAgICB2YXIgZ2V0VHJhbnNsYXRlID0gZnVuY3Rpb24oeCx5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCI7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgdmFyIHN0YWdnZXJVcCA9IDUsIHN0YWdnZXJEb3duID0gMTc7ICAvL3BpeGVscyB0byBzdGFnZ2VyIGJ5XG4gICAgICAgICAgICAgIC8vIElzc3VlICMxNDBcbiAgICAgICAgICAgICAgeFRpY2tzXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpLGopIHsgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAgZ2V0VHJhbnNsYXRlKDAsIChqICUgMiA9PSAwID8gc3RhZ2dlclVwIDogc3RhZ2dlckRvd24pKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHZhciB0b3RhbEluQmV0d2VlblRpY2tzID0gZDMuc2VsZWN0QWxsKFwiLm52LXgubnYtYXhpcyAubnYtd3JhcCBnIGcgdGV4dFwiKVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgIGcuc2VsZWN0QWxsKFwiLm52LXgubnYtYXhpcyAubnYtYXhpc01heE1pbiB0ZXh0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRUcmFuc2xhdGUoMCwgKGkgPT09IDAgfHwgdG90YWxJbkJldHdlZW5UaWNrcyAlIDIgIT09IDApID8gc3RhZ2dlckRvd24gOiBzdGFnZ2VyVXApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZWR1Y2VYVGlja3MpXG4gICAgICAgICAgICB4VGlja3NcbiAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpICUgTWF0aC5jZWlsKGRhdGFbMF0udmFsdWVzLmxlbmd0aCAvIChhdmFpbGFibGVXaWR0aCAvIDEwMCkpICE9PSAwO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQsIGxpbmUnKVxuICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKTtcblxuICAgICAgICAgIGlmKHJvdGF0ZUxhYmVscylcbiAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAuc2VsZWN0QWxsKCcudGljayB0ZXh0JylcbiAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICdyb3RhdGUoJyArIHJvdGF0ZUxhYmVscyArICcgMCwwKScpXG4gICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByb3RhdGVMYWJlbHMgPiAwID8gJ3N0YXJ0JyA6ICdlbmQnKTtcbiAgICAgICAgICBcbiAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLnNlbGVjdEFsbCgnZy5udi1heGlzTWF4TWluIHRleHQnKVxuICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcbiAgICAgIH1cblxuXG4gICAgICBpZiAoc2hvd1lBeGlzKSB7ICAgICAgXG4gICAgICAgICAgeUF4aXNcbiAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVIZWlnaHQgLyAzNiApXG4gICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICB9XG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkgeyBcbiAgICAgICAgc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb250cm9scy5kaXNwYXRjaC5vbignbGVnZW5kQ2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgaWYgKCFkLmRpc2FibGVkKSByZXR1cm47XG4gICAgICAgIGNvbnRyb2xzRGF0YSA9IGNvbnRyb2xzRGF0YS5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICAgIHMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9KTtcbiAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHN3aXRjaCAoZC5rZXkpIHtcbiAgICAgICAgICBjYXNlICdHcm91cGVkJzpcbiAgICAgICAgICAgIG11bHRpYmFyLnN0YWNrZWQoZmFsc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnU3RhY2tlZCc6XG4gICAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5zdGFja2VkID0gbXVsdGliYXIuc3RhY2tlZCgpO1xuICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG5cbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSlcbiAgICAgIH0pO1xuXG4gICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxuICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IGUuZGlzYWJsZWRbaV07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGUuc3RhY2tlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKGUuc3RhY2tlZCk7XG4gICAgICAgICAgc3RhdGUuc3RhY2tlZCA9IGUuc3RhY2tlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgbXVsdGliYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgfSk7XG5cbiAgbXVsdGliYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICB9KTtcbiAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgfSk7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgY2hhcnQubXVsdGliYXIgPSBtdWx0aWJhcjtcbiAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICBjaGFydC55QXhpcyA9IHlBeGlzO1xuXG4gIGQzLnJlYmluZChjaGFydCwgbXVsdGliYXIsICd4JywgJ3knLCAneERvbWFpbicsICd5RG9tYWluJywgJ3hSYW5nZScsICd5UmFuZ2UnLCAnZm9yY2VYJywgJ2ZvcmNlWScsICdjbGlwRWRnZScsXG4gICAnaWQnLCAnc3RhY2tlZCcsICdzdGFja09mZnNldCcsICdkZWxheScsICdiYXJDb2xvcicsJ2dyb3VwU3BhY2luZycpO1xuXG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcbiAgXG4gIGNoYXJ0Lm1hcmdpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJnaW47XG4gICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICBtYXJnaW4ucmlnaHQgID0gdHlwZW9mIF8ucmlnaHQgICE9ICd1bmRlZmluZWQnID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgbWFyZ2luLmJvdHRvbSA9IHR5cGVvZiBfLmJvdHRvbSAhPSAndW5kZWZpbmVkJyA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQud2lkdGggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XG4gICAgd2lkdGggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5oZWlnaHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xuICAgIGhlaWdodCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd0NvbnRyb2xzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dDb250cm9scztcbiAgICBzaG93Q29udHJvbHMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93TGVnZW5kID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dMZWdlbmQ7XG4gICAgc2hvd0xlZ2VuZCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dYQXhpcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93WEF4aXM7XG4gICAgc2hvd1hBeGlzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd1lBeGlzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dZQXhpcztcbiAgICBzaG93WUF4aXMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5yaWdodEFsaWduWUF4aXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByaWdodEFsaWduWUF4aXM7XG4gICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5yZWR1Y2VYVGlja3M9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByZWR1Y2VYVGlja3M7XG4gICAgcmVkdWNlWFRpY2tzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQucm90YXRlTGFiZWxzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJvdGF0ZUxhYmVscztcbiAgICByb3RhdGVMYWJlbHMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG4gIGNoYXJ0LnN0YWdnZXJMYWJlbHMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhZ2dlckxhYmVscztcbiAgICBzdGFnZ2VyTGFiZWxzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0b29sdGlwO1xuICAgIHRvb2x0aXAgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50b29sdGlwcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0b29sdGlwcztcbiAgICB0b29sdGlwcyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXBDb250ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXA7XG4gICAgdG9vbHRpcCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnN0YXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXRlO1xuICAgIHN0YXRlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuZGVmYXVsdFN0YXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRlZmF1bHRTdGF0ZTtcbiAgICBkZWZhdWx0U3RhdGUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcbiAgXG4gIGNoYXJ0Lm5vRGF0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub0RhdGE7XG4gICAgbm9EYXRhID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgcmV0dXJuIGNoYXJ0O1xufVxuXG5udi5tb2RlbHMubXVsdGlCYXJIb3Jpem9udGFsID0gZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICwgd2lkdGggPSA5NjBcbiAgICAsIGhlaWdodCA9IDUwMFxuICAgICwgaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgLy9DcmVhdGUgc2VtaS11bmlxdWUgSUQgaW4gY2FzZSB1c2VyIGRvZXNuJ3Qgc2VsZWN0IG9uZVxuICAgICwgeCA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgICwgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH1cbiAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICwgZm9yY2VZID0gWzBdIC8vIDAgaXMgZm9yY2VkIGJ5IGRlZmF1bHQuLiB0aGlzIG1ha2VzIHNlbnNlIGZvciB0aGUgbWFqb3JpdHkgb2YgYmFyIGdyYXBocy4uLiB1c2VyIGNhbiBhbHdheXMgZG8gY2hhcnQuZm9yY2VZKFtdKSB0byByZW1vdmVcbiAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAsIGJhckNvbG9yID0gbnVsbCAvLyBhZGRpbmcgdGhlIGFiaWxpdHkgdG8gc2V0IHRoZSBjb2xvciBmb3IgZWFjaCByYXRoZXIgdGhhbiB0aGUgd2hvbGUgZ3JvdXBcbiAgICAsIGRpc2FibGVkIC8vIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBiYXJDb2xvciB0byBjb21tdW5pY2F0ZSBmcm9tIG11bHRpQmFySG9yaXpvbnRhbENoYXJ0IHdoYXQgc2VyaWVzIGFyZSBkaXNhYmxlZFxuICAgICwgc3RhY2tlZCA9IGZhbHNlXG4gICAgLCBzaG93VmFsdWVzID0gZmFsc2VcbiAgICAsIHNob3dCYXJMYWJlbHMgPSBmYWxzZVxuICAgICwgdmFsdWVQYWRkaW5nID0gNjBcbiAgICAsIHZhbHVlRm9ybWF0ID0gZDMuZm9ybWF0KCcsLjJmJylcbiAgICAsIGRlbGF5ID0gMTIwMFxuICAgICwgeERvbWFpblxuICAgICwgeURvbWFpblxuICAgICwgeFJhbmdlXG4gICAgLCB5UmFuZ2VcbiAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2NoYXJ0Q2xpY2snLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxDbGljaycsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcpXG4gICAgO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciB4MCwgeTAgLy91c2VkIHRvIHN0b3JlIHByZXZpb3VzIHNjYWxlc1xuICAgICAgO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcblxuXG4gICAgICBpZiAoc3RhY2tlZClcbiAgICAgICAgZGF0YSA9IGQzLmxheW91dC5zdGFjaygpXG4gICAgICAgICAgICAgICAgIC5vZmZzZXQoJ3plcm8nKVxuICAgICAgICAgICAgICAgICAudmFsdWVzKGZ1bmN0aW9uKGQpeyByZXR1cm4gZC52YWx1ZXMgfSlcbiAgICAgICAgICAgICAgICAgLnkoZ2V0WSlcbiAgICAgICAgICAgICAgICAgKGRhdGEpO1xuXG5cbiAgICAgIC8vYWRkIHNlcmllcyBpbmRleCB0byBlYWNoIGRhdGEgcG9pbnQgZm9yIHJlZmVyZW5jZVxuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICBwb2ludC5zZXJpZXMgPSBpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIEhBQ0sgZm9yIG5lZ2F0aXZlIHZhbHVlIHN0YWNraW5nXG4gICAgICBpZiAoc3RhY2tlZClcbiAgICAgICAgZGF0YVswXS52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgIHZhciBwb3NCYXNlID0gMCwgbmVnQmFzZSA9IDA7XG4gICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIGYgPSBkLnZhbHVlc1tpXVxuICAgICAgICAgICAgZi5zaXplID0gTWF0aC5hYnMoZi55KTtcbiAgICAgICAgICAgIGlmIChmLnk8MCkgIHtcbiAgICAgICAgICAgICAgZi55MSA9IG5lZ0Jhc2UgLSBmLnNpemU7XG4gICAgICAgICAgICAgIG5lZ0Jhc2UgPSBuZWdCYXNlIC0gZi5zaXplO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGYueTEgPSBwb3NCYXNlO1xuICAgICAgICAgICAgICBwb3NCYXNlID0gcG9zQmFzZSArIGYuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgU2NhbGVzXG5cbiAgICAgIC8vIHJlbWFwIGFuZCBmbGF0dGVuIHRoZSBkYXRhIGZvciB1c2UgaW4gY2FsY3VsYXRpbmcgdGhlIHNjYWxlcycgZG9tYWluc1xuICAgICAgdmFyIHNlcmllc0RhdGEgPSAoeERvbWFpbiAmJiB5RG9tYWluKSA/IFtdIDogLy8gaWYgd2Uga25vdyB4RG9tYWluIGFuZCB5RG9tYWluLCBubyBuZWVkIHRvIGNhbGN1bGF0ZVxuICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IGdldFgoZCxpKSwgeTogZ2V0WShkLGkpLCB5MDogZC55MCwgeTE6IGQueTEgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgIHggICAuZG9tYWluKHhEb21haW4gfHwgZDMubWVyZ2Uoc2VyaWVzRGF0YSkubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9KSlcbiAgICAgICAgICAucmFuZ2VCYW5kcyh4UmFuZ2UgfHwgWzAsIGF2YWlsYWJsZUhlaWdodF0sIC4xKTtcblxuICAgICAgLy95ICAgLmRvbWFpbih5RG9tYWluIHx8IGQzLmV4dGVudChkMy5tZXJnZShzZXJpZXNEYXRhKS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55ICsgKHN0YWNrZWQgPyBkLnkwIDogMCkgfSkuY29uY2F0KGZvcmNlWSkpKVxuICAgICAgeSAgIC5kb21haW4oeURvbWFpbiB8fCBkMy5leHRlbnQoZDMubWVyZ2Uoc2VyaWVzRGF0YSkubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHN0YWNrZWQgPyAoZC55ID4gMCA/IGQueTEgKyBkLnkgOiBkLnkxICkgOiBkLnkgfSkuY29uY2F0KGZvcmNlWSkpKVxuXG4gICAgICBpZiAoc2hvd1ZhbHVlcyAmJiAhc3RhY2tlZClcbiAgICAgICAgeS5yYW5nZSh5UmFuZ2UgfHwgWyh5LmRvbWFpbigpWzBdIDwgMCA/IHZhbHVlUGFkZGluZyA6IDApLCBhdmFpbGFibGVXaWR0aCAtICh5LmRvbWFpbigpWzFdID4gMCA/IHZhbHVlUGFkZGluZyA6IDApIF0pO1xuICAgICAgZWxzZVxuICAgICAgICB5LnJhbmdlKHlSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgeDAgPSB4MCB8fCB4O1xuICAgICAgeTAgPSB5MCB8fCBkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oeS5kb21haW4oKSkucmFuZ2UoW3koMCkseSgwKV0pO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuXG4gICAgICB2YXIgd3JhcCA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1tdWx0aWJhckhvcml6b250YWwnKS5kYXRhKFtkYXRhXSk7XG4gICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1tdWx0aWJhckhvcml6b250YWwnKTtcbiAgICAgIHZhciBkZWZzRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZ3JvdXBzJyk7XG5cbiAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cbiAgICAgIHZhciBncm91cHMgPSB3cmFwLnNlbGVjdCgnLm52LWdyb3VwcycpLnNlbGVjdEFsbCgnLm52LWdyb3VwJylcbiAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0sIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gaSB9KTtcbiAgICAgIGdyb3Vwcy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KTtcbiAgICAgIGdyb3Vwcy5leGl0KCkudHJhbnNpdGlvbigpXG4gICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgIGdyb3Vwc1xuICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ252LWdyb3VwIG52LXNlcmllcy0nICsgaSB9KVxuICAgICAgICAgIC5jbGFzc2VkKCdob3ZlcicsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaG92ZXIgfSlcbiAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpeyByZXR1cm4gY29sb3IoZCwgaSkgfSlcbiAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSl7IHJldHVybiBjb2xvcihkLCBpKSB9KTtcbiAgICAgIGdyb3Vwcy50cmFuc2l0aW9uKClcbiAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMSlcbiAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIC43NSk7XG5cblxuICAgICAgdmFyIGJhcnMgPSBncm91cHMuc2VsZWN0QWxsKCdnLm52LWJhcicpXG4gICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMgfSk7XG5cbiAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG5cbiAgICAgIHZhciBiYXJzRW50ZXIgPSBiYXJzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpLGopIHtcbiAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHkwKHN0YWNrZWQgPyBkLnkwIDogMCkgKyAnLCcgKyAoc3RhY2tlZCA/IDAgOiAoaiAqIHgucmFuZ2VCYW5kKCkgLyBkYXRhLmxlbmd0aCApICsgeChnZXRYKGQsaSkpKSArICcpJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICBiYXJzRW50ZXIuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAuYXR0cignd2lkdGgnLCAwKVxuICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB4LnJhbmdlQmFuZCgpIC8gKHN0YWNrZWQgPyAxIDogZGF0YS5sZW5ndGgpIClcblxuICAgICAgYmFyc1xuICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7IC8vVE9ETzogZmlndXJlIG91dCB3aHkgaiB3b3JrcyBhYm92ZSwgYnV0IG5vdCBoZXJlXG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgcG9zOiBbIHkoZ2V0WShkLGkpICsgKHN0YWNrZWQgPyBkLnkwIDogMCkpLCB4KGdldFgoZCxpKSkgKyAoeC5yYW5nZUJhbmQoKSAqIChzdGFja2VkID8gZGF0YS5sZW5ndGggLyAyIDogZC5zZXJpZXMgKyAuNSkgLyBkYXRhLmxlbmd0aCkgXSxcbiAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50Q2xpY2soe1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpICsgKHgucmFuZ2VCYW5kKCkgKiAoc3RhY2tlZCA/IGRhdGEubGVuZ3RoIC8gMiA6IGQuc2VyaWVzICsgLjUpIC8gZGF0YS5sZW5ndGgpLCB5KGdldFkoZCxpKSArIChzdGFja2VkID8gZC55MCA6IDApKV0sICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgdmFsdWUgYXBwZWFycyB0byBiZSBzaGlmdGVkXG4gICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50RGJsQ2xpY2soe1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpICsgKHgucmFuZ2VCYW5kKCkgKiAoc3RhY2tlZCA/IGRhdGEubGVuZ3RoIC8gMiA6IGQuc2VyaWVzICsgLjUpIC8gZGF0YS5sZW5ndGgpLCB5KGdldFkoZCxpKSArIChzdGFja2VkID8gZC55MCA6IDApKV0sICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgdmFsdWUgYXBwZWFycyB0byBiZSBzaGlmdGVkXG4gICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfSk7XG5cblxuICAgICAgYmFyc0VudGVyLmFwcGVuZCgndGV4dCcpO1xuXG4gICAgICBpZiAoc2hvd1ZhbHVlcyAmJiAhc3RhY2tlZCkge1xuICAgICAgICBiYXJzLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyAnZW5kJyA6ICdzdGFydCcgfSlcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeC5yYW5nZUJhbmQoKSAvIChkYXRhLmxlbmd0aCAqIDIpKVxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zMmVtJylcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gdmFsdWVGb3JtYXQoZ2V0WShkLGkpKSB9KVxuICAgICAgICBiYXJzLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyAtNCA6IHkoZ2V0WShkLGkpKSAtIHkoMCkgKyA0IH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXJzLnNlbGVjdEFsbCgndGV4dCcpLnRleHQoJycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvd0JhckxhYmVscyAmJiAhc3RhY2tlZCkge1xuICAgICAgICBiYXJzRW50ZXIuYXBwZW5kKCd0ZXh0JykuY2xhc3NlZCgnbnYtYmFyLWxhYmVsJyx0cnVlKTtcbiAgICAgICAgYmFycy5zZWxlY3QoJ3RleHQubnYtYmFyLWxhYmVsJylcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WShkLGkpIDwgMCA/ICdzdGFydCcgOiAnZW5kJyB9KVxuICAgICAgICAgICAgLmF0dHIoJ3knLCB4LnJhbmdlQmFuZCgpIC8gKGRhdGEubGVuZ3RoICogMikpXG4gICAgICAgICAgICAuYXR0cignZHknLCAnLjMyZW0nKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRYKGQsaSkgfSk7XG4gICAgICAgIGJhcnMudHJhbnNpdGlvbigpXG4gICAgICAgICAgLnNlbGVjdCgndGV4dC5udi1iYXItbGFiZWwnKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyB5KDApIC0geShnZXRZKGQsaSkpICsgNCA6IC00IH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJhcnMuc2VsZWN0QWxsKCd0ZXh0Lm52LWJhci1sYWJlbCcpLnRleHQoJycpO1xuICAgICAgfVxuXG4gICAgICBiYXJzXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRZKGQsaSkgPCAwID8gJ252LWJhciBuZWdhdGl2ZScgOiAnbnYtYmFyIHBvc2l0aXZlJ30pXG5cbiAgICAgIGlmIChiYXJDb2xvcikge1xuICAgICAgICBpZiAoIWRpc2FibGVkKSBkaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICAgICAgYmFyc1xuICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiBkMy5yZ2IoYmFyQ29sb3IoZCxpKSkuZGFya2VyKCAgZGlzYWJsZWQubWFwKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gaSB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKXsgcmV0dXJuICFkaXNhYmxlZFtpXSAgfSlbal0gICApLnRvU3RyaW5nKCk7IH0pXG4gICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGksaikgeyByZXR1cm4gZDMucmdiKGJhckNvbG9yKGQsaSkpLmRhcmtlciggIGRpc2FibGVkLm1hcChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGkgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSl7IHJldHVybiAhZGlzYWJsZWRbaV0gIH0pW2pdICAgKS50b1N0cmluZygpOyB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YWNrZWQpXG4gICAgICAgIGJhcnMudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB5KGQueTEpICsgJywnICsgeChnZXRYKGQsaSkpICsgJyknXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIC5zZWxlY3QoJ3JlY3QnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh5KGdldFkoZCxpKSArIGQueTApIC0geShkLnkwKSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgeC5yYW5nZUJhbmQoKSApO1xuICAgICAgZWxzZVxuICAgICAgICBiYXJzLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAvL1RPRE86IHN0YWNrZWQgbXVzdCBiZSBhbGwgcG9zaXRpdmUgb3IgYWxsIG5lZ2F0aXZlLCBub3QgYm90aD9cbiAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArXG4gICAgICAgICAgICAgIChnZXRZKGQsaSkgPCAwID8geShnZXRZKGQsaSkpIDogeSgwKSlcbiAgICAgICAgICAgICAgKyAnLCcgK1xuICAgICAgICAgICAgICAoZC5zZXJpZXMgKiB4LnJhbmdlQmFuZCgpIC8gZGF0YS5sZW5ndGhcbiAgICAgICAgICAgICAgK1xuICAgICAgICAgICAgICB4KGdldFgoZCxpKSkgKVxuICAgICAgICAgICAgICArICcpJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAuc2VsZWN0KCdyZWN0JylcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB4LnJhbmdlQmFuZCgpIC8gZGF0YS5sZW5ndGggKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLmFicyh5KGdldFkoZCxpKSkgLSB5KDApKSwxKVxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgLy9zdG9yZSBvbGQgc2NhbGVzIGZvciB1c2UgaW4gdHJhbnNpdGlvbnMgb24gdXBkYXRlXG4gICAgICB4MCA9IHguY29weSgpO1xuICAgICAgeTAgPSB5LmNvcHkoKTtcblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5cbiAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gIGNoYXJ0LnggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ2V0WDtcbiAgICBnZXRYID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXRZO1xuICAgIGdldFkgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFyZ2luO1xuICAgIG1hcmdpbi50b3AgICAgPSB0eXBlb2YgXy50b3AgICAgIT0gJ3VuZGVmaW5lZCcgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LndpZHRoID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgIHdpZHRoID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcbiAgICBoZWlnaHQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC54U2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDtcbiAgICB4ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueVNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHk7XG4gICAgeSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnhEb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geERvbWFpbjtcbiAgICB4RG9tYWluID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueURvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5RG9tYWluO1xuICAgIHlEb21haW4gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC54UmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geFJhbmdlO1xuICAgIHhSYW5nZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnlSYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5UmFuZ2U7XG4gICAgeVJhbmdlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuZm9yY2VZID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZvcmNlWTtcbiAgICBmb3JjZVkgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zdGFja2VkID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YWNrZWQ7XG4gICAgc3RhY2tlZCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmJhckNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJhckNvbG9yO1xuICAgIGJhckNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmRpc2FibGVkID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRpc2FibGVkO1xuICAgIGRpc2FibGVkID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaWQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaWQ7XG4gICAgaWQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5kZWxheSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkZWxheTtcbiAgICBkZWxheSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dWYWx1ZXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd1ZhbHVlcztcbiAgICBzaG93VmFsdWVzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd0JhckxhYmVscyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93QmFyTGFiZWxzO1xuICAgIHNob3dCYXJMYWJlbHMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuXG4gIGNoYXJ0LnZhbHVlRm9ybWF0PSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWVGb3JtYXQ7XG4gICAgdmFsdWVGb3JtYXQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC52YWx1ZVBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWVQYWRkaW5nO1xuICAgIHZhbHVlUGFkZGluZyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICByZXR1cm4gY2hhcnQ7XG59XG5cbm52Lm1vZGVscy5tdWx0aUJhckhvcml6b250YWxDaGFydCA9IGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgbXVsdGliYXIgPSBudi5tb2RlbHMubXVsdGlCYXJIb3Jpem9udGFsKClcbiAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICwgeUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKCkuaGVpZ2h0KDMwKVxuICAgICwgY29udHJvbHMgPSBudi5tb2RlbHMubGVnZW5kKCkuaGVpZ2h0KDMwKVxuICAgIDtcblxuICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9XG4gICAgLCB3aWR0aCA9IG51bGxcbiAgICAsIGhlaWdodCA9IG51bGxcbiAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAsIHNob3dDb250cm9scyA9IHRydWVcbiAgICAsIHNob3dMZWdlbmQgPSB0cnVlXG4gICAgLCBzaG93WEF4aXMgPSB0cnVlXG4gICAgLCBzaG93WUF4aXMgPSB0cnVlXG4gICAgLCBzdGFja2VkID0gZmFsc2VcbiAgICAsIHRvb2x0aXBzID0gdHJ1ZVxuICAgICwgdG9vbHRpcCA9IGZ1bmN0aW9uKGtleSwgeCwgeSwgZSwgZ3JhcGgpIHtcbiAgICAgICAgcmV0dXJuICc8aDM+JyArIGtleSArICcgLSAnICsgeCArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICc8L3A+J1xuICAgICAgfVxuICAgICwgeCAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueFNjYWxlKClcbiAgICAsIHkgLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnlTY2FsZSgpXG4gICAgLCBzdGF0ZSA9IHsgc3RhY2tlZDogc3RhY2tlZCB9XG4gICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgLCBub0RhdGEgPSAnTm8gRGF0YSBBdmFpbGFibGUuJ1xuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnKVxuICAgICwgY29udHJvbFdpZHRoID0gZnVuY3Rpb24oKSB7IHJldHVybiBzaG93Q29udHJvbHMgPyAxODAgOiAwIH1cbiAgICAsIHRyYW5zaXRpb25EdXJhdGlvbiA9IDI1MFxuICAgIDtcblxuICBtdWx0aWJhclxuICAgIC5zdGFja2VkKHN0YWNrZWQpXG4gICAgO1xuICB4QXhpc1xuICAgIC5vcmllbnQoJ2xlZnQnKVxuICAgIC50aWNrUGFkZGluZyg1KVxuICAgIC5oaWdobGlnaHRaZXJvKGZhbHNlKVxuICAgIC5zaG93TWF4TWluKGZhbHNlKVxuICAgIC50aWNrRm9ybWF0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSlcbiAgICA7XG4gIHlBeGlzXG4gICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAudGlja0Zvcm1hdChkMy5mb3JtYXQoJywuMWYnKSlcbiAgICA7XG5cbiAgY29udHJvbHMudXBkYXRlU3RhdGUoZmFsc2UpO1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG4gICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICB4ID0geEF4aXMudGlja0Zvcm1hdCgpKG11bHRpYmFyLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgeSA9IHlBeGlzLnRpY2tGb3JtYXQoKShtdWx0aWJhci55KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgIGNvbnRlbnQgPSB0b29sdGlwKGUuc2VyaWVzLmtleSwgeCwgeSwgZSwgY2hhcnQpO1xuXG4gICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBlLnZhbHVlIDwgMCA/ICdlJyA6ICd3JywgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikuY2FsbChjaGFydCkgfTtcbiAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgIC8vc2V0IHN0YXRlLmRpc2FibGVkXG4gICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XG4gICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgaWYgKHN0YXRlW2tleV0gaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XS5zbGljZSgwKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIFNjYWxlc1xuXG4gICAgICB4ID0gbXVsdGliYXIueFNjYWxlKCk7XG4gICAgICB5ID0gbXVsdGliYXIueVNjYWxlKCk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LW11bHRpQmFySG9yaXpvbnRhbENoYXJ0JykuZGF0YShbZGF0YV0pO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtbXVsdGlCYXJIb3Jpem9udGFsQ2hhcnQnKS5hcHBlbmQoJ2cnKTtcbiAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkgbnYtYXhpcycpXG4gICAgICAgICAgICAuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtemVyb0xpbmUnKVxuICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWNvbnRyb2xzV3JhcCcpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBMZWdlbmRcblxuICAgICAgaWYgKHNob3dMZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLndpZHRoKGF2YWlsYWJsZVdpZHRoIC0gY29udHJvbFdpZHRoKCkpO1xuXG4gICAgICAgIGlmIChtdWx0aWJhci5iYXJDb2xvcigpKVxuICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgc2VyaWVzLmNvbG9yID0gZDMucmdiKCcjY2NjJykuZGFya2VyKGkgKiAxLjUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSlcblxuICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAuY2FsbChsZWdlbmQpO1xuXG4gICAgICAgIGlmICggbWFyZ2luLnRvcCAhPSBsZWdlbmQuaGVpZ2h0KCkpIHtcbiAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICB9XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBjb250cm9sV2lkdGgoKSArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIENvbnRyb2xzXG5cbiAgICAgIGlmIChzaG93Q29udHJvbHMpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xzRGF0YSA9IFtcbiAgICAgICAgICB7IGtleTogJ0dyb3VwZWQnLCBkaXNhYmxlZDogbXVsdGliYXIuc3RhY2tlZCgpIH0sXG4gICAgICAgICAgeyBrZXk6ICdTdGFja2VkJywgZGlzYWJsZWQ6ICFtdWx0aWJhci5zdGFja2VkKCkgfVxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnRyb2xzLndpZHRoKGNvbnRyb2xXaWR0aCgpKS5jb2xvcihbJyM0NDQnLCAnIzQ0NCcsICcjNDQ0J10pO1xuICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRyb2xzV3JhcCcpXG4gICAgICAgICAgICAuZGF0dW0oY29udHJvbHNEYXRhKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKVxuICAgICAgICAgICAgLmNhbGwoY29udHJvbHMpO1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTWFpbiBDaGFydCBDb21wb25lbnQocylcblxuICAgICAgbXVsdGliYXJcbiAgICAgICAgLmRpc2FibGVkKGRhdGEubWFwKGZ1bmN0aW9uKHNlcmllcykgeyByZXR1cm4gc2VyaWVzLmRpc2FibGVkIH0pKVxuICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkIH0pKVxuXG5cbiAgICAgIHZhciBiYXJzV3JhcCA9IGcuc2VsZWN0KCcubnYtYmFyc1dyYXAnKVxuICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSlcblxuICAgICAgYmFyc1dyYXAudHJhbnNpdGlvbigpLmNhbGwobXVsdGliYXIpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBBeGVzXG5cbiAgICAgIGlmIChzaG93WEF4aXMpIHtcbiAgICAgICAgICB4QXhpc1xuICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAudGlja3MoIGF2YWlsYWJsZUhlaWdodCAvIDI0IClcbiAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgICAgICAgdmFyIHhUaWNrcyA9IGcuc2VsZWN0KCcubnYteC5udi1heGlzJykuc2VsZWN0QWxsKCdnJyk7XG5cbiAgICAgICAgICB4VGlja3NcbiAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGluZSwgdGV4dCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgICAgeUF4aXNcbiAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVXaWR0aCAvIDEwMCApXG4gICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVIZWlnaHQsIDApO1xuXG4gICAgICAgICAgZy5zZWxlY3QoJy5udi15Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyBhdmFpbGFibGVIZWlnaHQgKyAnKScpO1xuICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJykudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gWmVybyBsaW5lXG4gICAgICBnLnNlbGVjdChcIi5udi16ZXJvTGluZSBsaW5lXCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwgeSgwKSlcbiAgICAgICAgLmF0dHIoXCJ4MlwiLCB5KDApKVxuICAgICAgICAuYXR0cihcInkxXCIsIDApXG4gICAgICAgIC5hdHRyKFwieTJcIiwgLWF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgY29udHJvbHMuZGlzcGF0Y2gub24oJ2xlZ2VuZENsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgIGlmICghZC5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICBjb250cm9sc0RhdGEgPSBjb250cm9sc0RhdGEubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICBzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSk7XG4gICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICBzd2l0Y2ggKGQua2V5KSB7XG4gICAgICAgICAgY2FzZSAnR3JvdXBlZCc6XG4gICAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKGZhbHNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1N0YWNrZWQnOlxuICAgICAgICAgICAgbXVsdGliYXIuc3RhY2tlZCh0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuc3RhY2tlZCA9IG11bHRpYmFyLnN0YWNrZWQoKTtcbiAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuXG4gICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBjaGFydCBmcm9tIGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0byBldmVudCBoYW5kbGVyXG4gICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZS5zdGFja2VkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG11bHRpYmFyLnN0YWNrZWQoZS5zdGFja2VkKTtcbiAgICAgICAgICBzdGF0ZS5zdGFja2VkID0gZS5zdGFja2VkO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgbXVsdGliYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgfSk7XG5cbiAgbXVsdGliYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICB9KTtcbiAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgfSk7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgY2hhcnQubXVsdGliYXIgPSBtdWx0aWJhcjtcbiAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICBjaGFydC55QXhpcyA9IHlBeGlzO1xuXG4gIGQzLnJlYmluZChjaGFydCwgbXVsdGliYXIsICd4JywgJ3knLCAneERvbWFpbicsICd5RG9tYWluJywgJ3hSYW5nZScsICd5UmFuZ2UnLCAnZm9yY2VYJywgJ2ZvcmNlWScsXG4gICAgJ2NsaXBFZGdlJywgJ2lkJywgJ2RlbGF5JywgJ3Nob3dWYWx1ZXMnLCdzaG93QmFyTGFiZWxzJywgJ3ZhbHVlRm9ybWF0JywgJ3N0YWNrZWQnLCAnYmFyQ29sb3InKTtcblxuICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICB3aWR0aCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuY29sb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sb3I7XG4gICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93Q29udHJvbHMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd0NvbnRyb2xzO1xuICAgIHNob3dDb250cm9scyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dMZWdlbmQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd0xlZ2VuZDtcbiAgICBzaG93TGVnZW5kID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd1hBeGlzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dYQXhpcztcbiAgICBzaG93WEF4aXMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93WUF4aXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd1lBeGlzO1xuICAgIHNob3dZQXhpcyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXAgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcDtcbiAgICB0b29sdGlwID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcHMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcHM7XG4gICAgdG9vbHRpcHMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50b29sdGlwQ29udGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0b29sdGlwO1xuICAgIHRvb2x0aXAgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGF0ZTtcbiAgICBzdGF0ZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmRlZmF1bHRTdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkZWZhdWx0U3RhdGU7XG4gICAgZGVmYXVsdFN0YXRlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQubm9EYXRhID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vRGF0YTtcbiAgICBub0RhdGEgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50cmFuc2l0aW9uRHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgcmV0dXJuIGNoYXJ0O1xufVxubnYubW9kZWxzLm11bHRpQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMjAsIGJvdHRvbTogNTAsIGxlZnQ6IDYwfSxcbiAgICAgIGNvbG9yID0gZDMuc2NhbGUuY2F0ZWdvcnkyMCgpLnJhbmdlKCksXG4gICAgICB3aWR0aCA9IG51bGwsIFxuICAgICAgaGVpZ2h0ID0gbnVsbCxcbiAgICAgIHNob3dMZWdlbmQgPSB0cnVlLFxuICAgICAgdG9vbHRpcHMgPSB0cnVlLFxuICAgICAgdG9vbHRpcCA9IGZ1bmN0aW9uKGtleSwgeCwgeSwgZSwgZ3JhcGgpIHtcbiAgICAgICAgcmV0dXJuICc8aDM+JyArIGtleSArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICcgYXQgJyArIHggKyAnPC9wPidcbiAgICAgIH0sXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHlEb21haW4xLFxuICAgICAgeURvbWFpbjJcbiAgICAgIDsgLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LmxpbmVzLlt4L3ldU2NhbGUoKVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKSxcbiAgICAgIHlTY2FsZTEgPSBkMy5zY2FsZS5saW5lYXIoKSxcbiAgICAgIHlTY2FsZTIgPSBkMy5zY2FsZS5saW5lYXIoKSxcblxuICAgICAgbGluZXMxID0gbnYubW9kZWxzLmxpbmUoKS55U2NhbGUoeVNjYWxlMSksXG4gICAgICBsaW5lczIgPSBudi5tb2RlbHMubGluZSgpLnlTY2FsZSh5U2NhbGUyKSxcblxuICAgICAgYmFyczEgPSBudi5tb2RlbHMubXVsdGlCYXIoKS5zdGFja2VkKGZhbHNlKS55U2NhbGUoeVNjYWxlMSksXG4gICAgICBiYXJzMiA9IG52Lm1vZGVscy5tdWx0aUJhcigpLnN0YWNrZWQoZmFsc2UpLnlTY2FsZSh5U2NhbGUyKSxcblxuICAgICAgc3RhY2sxID0gbnYubW9kZWxzLnN0YWNrZWRBcmVhKCkueVNjYWxlKHlTY2FsZTEpLFxuICAgICAgc3RhY2syID0gbnYubW9kZWxzLnN0YWNrZWRBcmVhKCkueVNjYWxlKHlTY2FsZTIpLFxuXG4gICAgICB4QXhpcyA9IG52Lm1vZGVscy5heGlzKCkuc2NhbGUoeCkub3JpZW50KCdib3R0b20nKS50aWNrUGFkZGluZyg1KSxcbiAgICAgIHlBeGlzMSA9IG52Lm1vZGVscy5heGlzKCkuc2NhbGUoeVNjYWxlMSkub3JpZW50KCdsZWZ0JyksXG4gICAgICB5QXhpczIgPSBudi5tb2RlbHMuYXhpcygpLnNjYWxlKHlTY2FsZTIpLm9yaWVudCgncmlnaHQnKSxcblxuICAgICAgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpLmhlaWdodCgzMCksXG4gICAgICBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScpO1xuXG4gIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQgfHwgMCApLFxuICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgIHggPSB4QXhpcy50aWNrRm9ybWF0KCkobGluZXMxLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgeSA9ICgoZS5zZXJpZXMueUF4aXMgPT0gMikgPyB5QXhpczIgOiB5QXhpczEpLnRpY2tGb3JtYXQoKShsaW5lczEueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9mZnNldEVsZW1lbnQub2Zmc2V0UGFyZW50KTtcbiAgfTtcblxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHsgY29udGFpbmVyLnRyYW5zaXRpb24oKS5jYWxsKGNoYXJ0KTsgfTtcbiAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgIHZhciBkYXRhTGluZXMxID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiAhZC5kaXNhYmxlZCAmJiBkLnR5cGUgPT0gJ2xpbmUnICYmIGQueUF4aXMgPT0gMX0pXG4gICAgICB2YXIgZGF0YUxpbmVzMiA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gIWQuZGlzYWJsZWQgJiYgZC50eXBlID09ICdsaW5lJyAmJiBkLnlBeGlzID09IDJ9KVxuICAgICAgdmFyIGRhdGFCYXJzMSA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gIWQuZGlzYWJsZWQgJiYgZC50eXBlID09ICdiYXInICYmIGQueUF4aXMgPT0gMX0pXG4gICAgICB2YXIgZGF0YUJhcnMyID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiAhZC5kaXNhYmxlZCAmJiBkLnR5cGUgPT0gJ2JhcicgJiYgZC55QXhpcyA9PSAyfSlcbiAgICAgIHZhciBkYXRhU3RhY2sxID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiAhZC5kaXNhYmxlZCAmJiBkLnR5cGUgPT0gJ2FyZWEnICYmIGQueUF4aXMgPT0gMX0pXG4gICAgICB2YXIgZGF0YVN0YWNrMiA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gIWQuZGlzYWJsZWQgJiYgZC50eXBlID09ICdhcmVhJyAmJiBkLnlBeGlzID09IDJ9KVxuXG4gICAgICB2YXIgc2VyaWVzMSA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gIWQuZGlzYWJsZWQgJiYgZC55QXhpcyA9PSAxfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IGQueCwgeTogZC55IH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgIHZhciBzZXJpZXMyID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiAhZC5kaXNhYmxlZCAmJiBkLnlBeGlzID09IDJ9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZC54LCB5OiBkLnkgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcblxuICAgICAgeCAgIC5kb21haW4oZDMuZXh0ZW50KGQzLm1lcmdlKHNlcmllczEuY29uY2F0KHNlcmllczIpKSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0gKSlcbiAgICAgICAgICAucmFuZ2UoWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy53cmFwLm11bHRpQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3dyYXAgbnZkMyBtdWx0aUNoYXJ0JykuYXBwZW5kKCdnJyk7XG5cbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICd4IGF4aXMnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICd5MSBheGlzJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAneTIgYXhpcycpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2xpbmVzMVdyYXAnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdsaW5lczJXcmFwJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnYmFyczFXcmFwJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnYmFyczJXcmFwJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnc3RhY2sxV3JhcCcpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3N0YWNrMldyYXAnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdsZWdlbmRXcmFwJyk7XG5cbiAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgaWYgKHNob3dMZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLndpZHRoKCBhdmFpbGFibGVXaWR0aCAvIDIgKTtcblxuICAgICAgICBnLnNlbGVjdCgnLmxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgLmRhdHVtKGRhdGEubWFwKGZ1bmN0aW9uKHNlcmllcykgeyBcbiAgICAgICAgICAgICAgc2VyaWVzLm9yaWdpbmFsS2V5ID0gc2VyaWVzLm9yaWdpbmFsS2V5ID09PSB1bmRlZmluZWQgPyBzZXJpZXMua2V5IDogc2VyaWVzLm9yaWdpbmFsS2V5O1xuICAgICAgICAgICAgICBzZXJpZXMua2V5ID0gc2VyaWVzLm9yaWdpbmFsS2V5ICsgKHNlcmllcy55QXhpcyA9PSAxID8gJycgOiAnIChyaWdodCBheGlzKScpO1xuICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGcuc2VsZWN0KCcubGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKCBhdmFpbGFibGVXaWR0aCAvIDIgKSArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICB9XG5cblxuICAgICAgbGluZXMxXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpXG4gICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcltpICUgY29sb3IubGVuZ3RoXTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS55QXhpcyA9PSAxICYmIGRhdGFbaV0udHlwZSA9PSAnbGluZSd9KSk7XG5cbiAgICAgIGxpbmVzMlxuICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAuaW50ZXJwb2xhdGUoXCJtb25vdG9uZVwiKVxuICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3JbaSAlIGNvbG9yLmxlbmd0aF07XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmIGRhdGFbaV0ueUF4aXMgPT0gMiAmJiBkYXRhW2ldLnR5cGUgPT0gJ2xpbmUnfSkpO1xuXG4gICAgICBiYXJzMVxuICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3JbaSAlIGNvbG9yLmxlbmd0aF07XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmIGRhdGFbaV0ueUF4aXMgPT0gMSAmJiBkYXRhW2ldLnR5cGUgPT0gJ2Jhcid9KSk7XG5cbiAgICAgIGJhcnMyXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcltpICUgY29sb3IubGVuZ3RoXTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS55QXhpcyA9PSAyICYmIGRhdGFbaV0udHlwZSA9PSAnYmFyJ30pKTtcblxuICAgICAgc3RhY2sxXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcltpICUgY29sb3IubGVuZ3RoXTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS55QXhpcyA9PSAxICYmIGRhdGFbaV0udHlwZSA9PSAnYXJlYSd9KSk7XG5cbiAgICAgIHN0YWNrMlxuICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3JbaSAlIGNvbG9yLmxlbmd0aF07XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmIGRhdGFbaV0ueUF4aXMgPT0gMiAmJiBkYXRhW2ldLnR5cGUgPT0gJ2FyZWEnfSkpO1xuXG4gICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cblxuICAgICAgdmFyIGxpbmVzMVdyYXAgPSBnLnNlbGVjdCgnLmxpbmVzMVdyYXAnKVxuICAgICAgICAgIC5kYXR1bShkYXRhTGluZXMxKVxuICAgICAgdmFyIGJhcnMxV3JhcCA9IGcuc2VsZWN0KCcuYmFyczFXcmFwJylcbiAgICAgICAgICAuZGF0dW0oZGF0YUJhcnMxKVxuICAgICAgdmFyIHN0YWNrMVdyYXAgPSBnLnNlbGVjdCgnLnN0YWNrMVdyYXAnKVxuICAgICAgICAgIC5kYXR1bShkYXRhU3RhY2sxKVxuXG4gICAgICB2YXIgbGluZXMyV3JhcCA9IGcuc2VsZWN0KCcubGluZXMyV3JhcCcpXG4gICAgICAgICAgLmRhdHVtKGRhdGFMaW5lczIpXG4gICAgICB2YXIgYmFyczJXcmFwID0gZy5zZWxlY3QoJy5iYXJzMldyYXAnKVxuICAgICAgICAgIC5kYXR1bShkYXRhQmFyczIpXG4gICAgICB2YXIgc3RhY2syV3JhcCA9IGcuc2VsZWN0KCcuc3RhY2syV3JhcCcpXG4gICAgICAgICAgLmRhdHVtKGRhdGFTdGFjazIpXG5cbiAgICAgIHZhciBleHRyYVZhbHVlMSA9IGRhdGFTdGFjazEubGVuZ3RoID8gZGF0YVN0YWNrMS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGEudmFsdWVzfSkucmVkdWNlKGZ1bmN0aW9uKGEsYil7XG4gICAgICAgIHJldHVybiBhLm1hcChmdW5jdGlvbihhVmFsLGkpe3JldHVybiB7eDogYVZhbC54LCB5OiBhVmFsLnkgKyBiW2ldLnl9fSlcbiAgICAgIH0pLmNvbmNhdChbe3g6MCwgeTowfV0pIDogW11cbiAgICAgIHZhciBleHRyYVZhbHVlMiA9IGRhdGFTdGFjazIubGVuZ3RoID8gZGF0YVN0YWNrMi5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGEudmFsdWVzfSkucmVkdWNlKGZ1bmN0aW9uKGEsYil7XG4gICAgICAgIHJldHVybiBhLm1hcChmdW5jdGlvbihhVmFsLGkpe3JldHVybiB7eDogYVZhbC54LCB5OiBhVmFsLnkgKyBiW2ldLnl9fSlcbiAgICAgIH0pLmNvbmNhdChbe3g6MCwgeTowfV0pIDogW11cblxuICAgICAgeVNjYWxlMSAuZG9tYWluKHlEb21haW4xIHx8IGQzLmV4dGVudChkMy5tZXJnZShzZXJpZXMxKS5jb25jYXQoZXh0cmFWYWx1ZTEpLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfSApKVxuICAgICAgICAgICAgICAucmFuZ2UoWzAsIGF2YWlsYWJsZUhlaWdodF0pXG5cbiAgICAgIHlTY2FsZTIgLmRvbWFpbih5RG9tYWluMiB8fCBkMy5leHRlbnQoZDMubWVyZ2Uoc2VyaWVzMikuY29uY2F0KGV4dHJhVmFsdWUyKSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH0gKSlcbiAgICAgICAgICAgICAgLnJhbmdlKFswLCBhdmFpbGFibGVIZWlnaHRdKVxuXG4gICAgICBsaW5lczEueURvbWFpbih5U2NhbGUxLmRvbWFpbigpKVxuICAgICAgYmFyczEueURvbWFpbih5U2NhbGUxLmRvbWFpbigpKVxuICAgICAgc3RhY2sxLnlEb21haW4oeVNjYWxlMS5kb21haW4oKSlcblxuICAgICAgbGluZXMyLnlEb21haW4oeVNjYWxlMi5kb21haW4oKSlcbiAgICAgIGJhcnMyLnlEb21haW4oeVNjYWxlMi5kb21haW4oKSlcbiAgICAgIHN0YWNrMi55RG9tYWluKHlTY2FsZTIuZG9tYWluKCkpXG5cbiAgICAgIGlmKGRhdGFTdGFjazEubGVuZ3RoKXtkMy50cmFuc2l0aW9uKHN0YWNrMVdyYXApLmNhbGwoc3RhY2sxKTt9XG4gICAgICBpZihkYXRhU3RhY2syLmxlbmd0aCl7ZDMudHJhbnNpdGlvbihzdGFjazJXcmFwKS5jYWxsKHN0YWNrMik7fVxuXG4gICAgICBpZihkYXRhQmFyczEubGVuZ3RoKXtkMy50cmFuc2l0aW9uKGJhcnMxV3JhcCkuY2FsbChiYXJzMSk7fVxuICAgICAgaWYoZGF0YUJhcnMyLmxlbmd0aCl7ZDMudHJhbnNpdGlvbihiYXJzMldyYXApLmNhbGwoYmFyczIpO31cblxuICAgICAgaWYoZGF0YUxpbmVzMS5sZW5ndGgpe2QzLnRyYW5zaXRpb24obGluZXMxV3JhcCkuY2FsbChsaW5lczEpO31cbiAgICAgIGlmKGRhdGFMaW5lczIubGVuZ3RoKXtkMy50cmFuc2l0aW9uKGxpbmVzMldyYXApLmNhbGwobGluZXMyKTt9XG4gICAgICBcblxuXG4gICAgICB4QXhpc1xuICAgICAgICAudGlja3MoIGF2YWlsYWJsZVdpZHRoIC8gMTAwIClcbiAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQsIDApO1xuXG4gICAgICBnLnNlbGVjdCgnLnguYXhpcycpXG4gICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgYXZhaWxhYmxlSGVpZ2h0ICsgJyknKTtcbiAgICAgIGQzLnRyYW5zaXRpb24oZy5zZWxlY3QoJy54LmF4aXMnKSlcbiAgICAgICAgICAuY2FsbCh4QXhpcyk7XG5cbiAgICAgIHlBeGlzMVxuICAgICAgICAudGlja3MoIGF2YWlsYWJsZUhlaWdodCAvIDM2IClcbiAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG5cbiAgICAgIGQzLnRyYW5zaXRpb24oZy5zZWxlY3QoJy55MS5heGlzJykpXG4gICAgICAgICAgLmNhbGwoeUF4aXMxKTtcblxuICAgICAgeUF4aXMyXG4gICAgICAgIC50aWNrcyggYXZhaWxhYmxlSGVpZ2h0IC8gMzYgKVxuICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgIGQzLnRyYW5zaXRpb24oZy5zZWxlY3QoJy55Mi5heGlzJykpXG4gICAgICAgICAgLmNhbGwoeUF4aXMyKTtcblxuICAgICAgZy5zZWxlY3QoJy55Mi5heGlzJylcbiAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBzZXJpZXMyLmxlbmd0aCA/IDEgOiAwKVxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4LnJhbmdlKClbMV0gKyAnLDApJyk7XG5cbiAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkgeyBcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgXG4gICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgc2hvd1Rvb2x0aXAoZSwgdGhhdC5wYXJlbnROb2RlKTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBsaW5lczEuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgfSk7XG5cbiAgbGluZXMxLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgfSk7XG5cbiAgbGluZXMyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gIH0pO1xuXG4gIGxpbmVzMi5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gIH0pO1xuXG4gIGJhcnMxLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gIH0pO1xuXG4gIGJhcnMxLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgfSk7XG5cbiAgYmFyczIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgfSk7XG5cbiAgYmFyczIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICB9KTtcblxuICBzdGFjazEuZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgIC8vZGlzYWJsZSB0b29sdGlwcyB3aGVuIHZhbHVlIH49IDBcbiAgICAvLy8vIFRPRE86IGNvbnNpZGVyIHJlbW92aW5nIHBvaW50cyBmcm9tIHZvcm9ub2kgdGhhdCBoYXZlIDAgdmFsdWUgaW5zdGVhZCBvZiB0aGlzIGhhY2tcbiAgICBpZiAoIU1hdGgucm91bmQoc3RhY2sxLnkoKShlLnBvaW50KSAqIDEwMCkpIHsgIC8vIDEwMCB3aWxsIG5vdCBiZSBnb29kIGZvciB2ZXJ5IHNtYWxsIG51bWJlcnMuLi4gd2lsbCBoYXZlIHRvIHRoaW5rIGFib3V0IG1ha2luZyB0aGlzIHZhbHUgZHluYW1pYywgYmFzZWQgb24gZGF0YSByYW5nZVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZDMuc2VsZWN0QWxsKCcucG9pbnQuaG92ZXInKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKSB9LCAwKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBlLnBvcyA9IFtlLnBvc1swXSArIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdLFxuICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICB9KTtcblxuICBzdGFjazEuZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oZSkge1xuICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICB9KTtcblxuICBzdGFjazIuZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgIC8vZGlzYWJsZSB0b29sdGlwcyB3aGVuIHZhbHVlIH49IDBcbiAgICAvLy8vIFRPRE86IGNvbnNpZGVyIHJlbW92aW5nIHBvaW50cyBmcm9tIHZvcm9ub2kgdGhhdCBoYXZlIDAgdmFsdWUgaW5zdGVhZCBvZiB0aGlzIGhhY2tcbiAgICBpZiAoIU1hdGgucm91bmQoc3RhY2syLnkoKShlLnBvaW50KSAqIDEwMCkpIHsgIC8vIDEwMCB3aWxsIG5vdCBiZSBnb29kIGZvciB2ZXJ5IHNtYWxsIG51bWJlcnMuLi4gd2lsbCBoYXZlIHRvIHRoaW5rIGFib3V0IG1ha2luZyB0aGlzIHZhbHUgZHluYW1pYywgYmFzZWQgb24gZGF0YSByYW5nZVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZDMuc2VsZWN0QWxsKCcucG9pbnQuaG92ZXInKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKSB9LCAwKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBlLnBvcyA9IFtlLnBvc1swXSArIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdLFxuICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICB9KTtcblxuICBzdGFjazIuZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oZSkge1xuICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICB9KTtcblxuICAgIGxpbmVzMS5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICB9KTtcblxuICBsaW5lczEuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICB9KTtcblxuICBsaW5lczIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgfSk7XG5cbiAgbGluZXMyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgfSk7XG5cbiAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgfSk7XG5cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEdsb2JhbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgY2hhcnQubGluZXMxID0gbGluZXMxO1xuICBjaGFydC5saW5lczIgPSBsaW5lczI7XG4gIGNoYXJ0LmJhcnMxID0gYmFyczE7XG4gIGNoYXJ0LmJhcnMyID0gYmFyczI7XG4gIGNoYXJ0LnN0YWNrMSA9IHN0YWNrMTtcbiAgY2hhcnQuc3RhY2syID0gc3RhY2syO1xuICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICBjaGFydC55QXhpczEgPSB5QXhpczE7XG4gIGNoYXJ0LnlBeGlzMiA9IHlBeGlzMjtcbiAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gIGNoYXJ0LnggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ2V0WDtcbiAgICBnZXRYID0gXztcbiAgICBsaW5lczEueChfKTtcbiAgICBiYXJzMS54KF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFk7XG4gICAgZ2V0WSA9IF87XG4gICAgbGluZXMxLnkoXyk7XG4gICAgYmFyczEueShfKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueURvbWFpbjEgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geURvbWFpbjE7XG4gICAgeURvbWFpbjEgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55RG9tYWluMiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5RG9tYWluMjtcbiAgICB5RG9tYWluMiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0Lm1hcmdpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJnaW47XG4gICAgbWFyZ2luID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQud2lkdGggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XG4gICAgd2lkdGggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5oZWlnaHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xuICAgIGhlaWdodCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gXztcbiAgICBsZWdlbmQuY29sb3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dMZWdlbmQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd0xlZ2VuZDtcbiAgICBzaG93TGVnZW5kID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcHMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcHM7XG4gICAgdG9vbHRpcHMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50b29sdGlwQ29udGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0b29sdGlwO1xuICAgIHRvb2x0aXAgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICByZXR1cm4gY2hhcnQ7XG59XG5cblxubnYubW9kZWxzLm9obGNCYXIgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgLCB3aWR0aCA9IDk2MFxuICAgICwgaGVpZ2h0ID0gNTAwXG4gICAgLCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSAvL0NyZWF0ZSBzZW1pLXVuaXF1ZSBJRCBpbiBjYXNlIHVzZXIgZG9lc24ndCBzZWxlY3Qgb25lXG4gICAgLCB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAsIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9XG4gICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAsIGdldE9wZW4gPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm9wZW4gfVxuICAgICwgZ2V0Q2xvc2UgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLmNsb3NlIH1cbiAgICAsIGdldEhpZ2ggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLmhpZ2ggfVxuICAgICwgZ2V0TG93ID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5sb3cgfVxuICAgICwgZm9yY2VYID0gW11cbiAgICAsIGZvcmNlWSA9IFtdXG4gICAgLCBwYWREYXRhICAgICA9IGZhbHNlIC8vIElmIHRydWUsIGFkZHMgaGFsZiBhIGRhdGEgcG9pbnRzIHdpZHRoIHRvIGZyb250IGFuZCBiYWNrLCBmb3IgbGluaW5nIHVwIGEgbGluZSBjaGFydCB3aXRoIGEgYmFyIGNoYXJ0XG4gICAgLCBjbGlwRWRnZSA9IHRydWVcbiAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAsIHhEb21haW5cbiAgICAsIHlEb21haW5cbiAgICAsIHhSYW5nZVxuICAgICwgeVJhbmdlXG4gICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdjaGFydENsaWNrJywgJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsQ2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnKVxuICAgIDtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy9UT0RPOiBzdG9yZSBvbGQgc2NhbGVzIGZvciB0cmFuc2l0aW9uc1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgU2NhbGVzXG5cbiAgICAgIHggICAuZG9tYWluKHhEb21haW4gfHwgZDMuZXh0ZW50KGRhdGFbMF0udmFsdWVzLm1hcChnZXRYKS5jb25jYXQoZm9yY2VYKSApKTtcblxuICAgICAgaWYgKHBhZERhdGEpXG4gICAgICAgIHgucmFuZ2UoeFJhbmdlIHx8IFthdmFpbGFibGVXaWR0aCAqIC41IC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoLCBhdmFpbGFibGVXaWR0aCAqIChkYXRhWzBdLnZhbHVlcy5sZW5ndGggLSAuNSkgIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoIF0pO1xuICAgICAgZWxzZVxuICAgICAgICB4LnJhbmdlKHhSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgeSAgIC5kb21haW4oeURvbWFpbiB8fCBbXG4gICAgICAgICAgICBkMy5taW4oZGF0YVswXS52YWx1ZXMubWFwKGdldExvdykuY29uY2F0KGZvcmNlWSkpLFxuICAgICAgICAgICAgZDMubWF4KGRhdGFbMF0udmFsdWVzLm1hcChnZXRIaWdoKS5jb25jYXQoZm9yY2VZKSlcbiAgICAgICAgICBdKVxuICAgICAgICAgIC5yYW5nZSh5UmFuZ2UgfHwgW2F2YWlsYWJsZUhlaWdodCwgMF0pO1xuXG4gICAgICAvLyBJZiBzY2FsZSdzIGRvbWFpbiBkb24ndCBoYXZlIGEgcmFuZ2UsIHNsaWdodGx5IGFkanVzdCB0byBtYWtlIG9uZS4uLiBzbyBhIGNoYXJ0IGNhbiBzaG93IGEgc2luZ2xlIGRhdGEgcG9pbnRcbiAgICAgIGlmICh4LmRvbWFpbigpWzBdID09PSB4LmRvbWFpbigpWzFdKVxuICAgICAgICB4LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgIHguZG9tYWluKFt4LmRvbWFpbigpWzBdIC0geC5kb21haW4oKVswXSAqIDAuMDEsIHguZG9tYWluKClbMV0gKyB4LmRvbWFpbigpWzFdICogMC4wMV0pXG4gICAgICAgICAgOiB4LmRvbWFpbihbLTEsMV0pO1xuXG4gICAgICBpZiAoeS5kb21haW4oKVswXSA9PT0geS5kb21haW4oKVsxXSlcbiAgICAgICAgeS5kb21haW4oKVswXSA/XG4gICAgICAgICAgICB5LmRvbWFpbihbeS5kb21haW4oKVswXSArIHkuZG9tYWluKClbMF0gKiAwLjAxLCB5LmRvbWFpbigpWzFdIC0geS5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgIDogeS5kb21haW4oWy0xLDFdKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcblxuICAgICAgdmFyIHdyYXAgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtb2hsY0JhcicpLmRhdGEoW2RhdGFbMF0udmFsdWVzXSk7XG4gICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1vaGxjQmFyJyk7XG4gICAgICB2YXIgZGVmc0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZGVmcycpO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXRpY2tzJyk7XG5cbiAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICBjb250YWluZXJcbiAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkaXNwYXRjaC5jaGFydENsaWNrKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHBvczogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuXG4gICAgICBkZWZzRW50ZXIuYXBwZW5kKCdjbGlwUGF0aCcpXG4gICAgICAgICAgLmF0dHIoJ2lkJywgJ252LWNoYXJ0LWNsaXAtcGF0aC0nICsgaWQpXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgd3JhcC5zZWxlY3QoJyNudi1jaGFydC1jbGlwLXBhdGgtJyArIGlkICsgJyByZWN0JylcbiAgICAgICAgICAuYXR0cignd2lkdGgnLCBhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgZyAgIC5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwRWRnZSA/ICd1cmwoI252LWNoYXJ0LWNsaXAtcGF0aC0nICsgaWQgKyAnKScgOiAnJyk7XG5cblxuXG4gICAgICB2YXIgdGlja3MgPSB3cmFwLnNlbGVjdCgnLm52LXRpY2tzJykuc2VsZWN0QWxsKCcubnYtdGljaycpXG4gICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgdGlja3MuZXhpdCgpLnJlbW92ZSgpO1xuXG5cbiAgICAgIHZhciB0aWNrc0VudGVyID0gdGlja3MuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiAoZ2V0T3BlbihkLGkpID4gZ2V0Q2xvc2UoZCxpKSA/ICdudi10aWNrIG5lZ2F0aXZlJyA6ICdudi10aWNrIHBvc2l0aXZlJykgKyAnIG52LXRpY2stJyArIGogKyAnLScgKyBpIH0pXG4gICAgICAgICAgLmF0dHIoJ2QnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIHZhciB3ID0gKGF2YWlsYWJsZVdpZHRoIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoKSAqIC45O1xuICAgICAgICAgICAgcmV0dXJuICdtMCwwbDAsJ1xuICAgICAgICAgICAgICAgICArICh5KGdldE9wZW4oZCxpKSlcbiAgICAgICAgICAgICAgICAgLSB5KGdldEhpZ2goZCxpKSkpXG4gICAgICAgICAgICAgICAgICsgJ2wnXG4gICAgICAgICAgICAgICAgICsgKC13LzIpXG4gICAgICAgICAgICAgICAgICsgJywwbCdcbiAgICAgICAgICAgICAgICAgKyAody8yKVxuICAgICAgICAgICAgICAgICArICcsMGwwLCdcbiAgICAgICAgICAgICAgICAgKyAoeShnZXRMb3coZCxpKSkgLSB5KGdldE9wZW4oZCxpKSkpXG4gICAgICAgICAgICAgICAgICsgJ2wwLCdcbiAgICAgICAgICAgICAgICAgKyAoeShnZXRDbG9zZShkLGkpKVxuICAgICAgICAgICAgICAgICAtIHkoZ2V0TG93KGQsaSkpKVxuICAgICAgICAgICAgICAgICArICdsJ1xuICAgICAgICAgICAgICAgICArICh3LzIpXG4gICAgICAgICAgICAgICAgICsgJywwbCdcbiAgICAgICAgICAgICAgICAgKyAoLXcvMilcbiAgICAgICAgICAgICAgICAgKyAnLDB6JztcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoZ2V0WChkLGkpKSArICcsJyArIHkoZ2V0SGlnaChkLGkpKSArICcpJzsgfSlcbiAgICAgICAgICAvLy5hdHRyKCdmaWxsJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvclswXTsgfSlcbiAgICAgICAgICAvLy5hdHRyKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGNvbG9yWzBdOyB9KVxuICAgICAgICAgIC8vLmF0dHIoJ3gnLCAwIClcbiAgICAgICAgICAvLy5hdHRyKCd5JywgZnVuY3Rpb24oZCxpKSB7ICByZXR1cm4geShNYXRoLm1heCgwLCBnZXRZKGQsaSkpKSB9KVxuICAgICAgICAgIC8vLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gTWF0aC5hYnMoeShnZXRZKGQsaSkpIC0geSgwKSkgfSlcbiAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbMF0sXG4gICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpLCB5KGdldFkoZCxpKSldLCAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhlIHZhbHVlIGFwcGVhcnMgdG8gYmUgc2hpZnRlZFxuICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIC8vbGFiZWw6IGRbbGFiZWxdLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpLCB5KGdldFkoZCxpKSldLFxuICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50RGJsQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgLy9sYWJlbDogZFtsYWJlbF0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpLCB5KGdldFkoZCxpKSldLFxuICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICB0aWNrc1xuICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiAoZ2V0T3BlbihkLGkpID4gZ2V0Q2xvc2UoZCxpKSA/ICdudi10aWNrIG5lZ2F0aXZlJyA6ICdudi10aWNrIHBvc2l0aXZlJykgKyAnIG52LXRpY2stJyArIGogKyAnLScgKyBpIH0pXG4gICAgICBkMy50cmFuc2l0aW9uKHRpY2tzKVxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoZ2V0WChkLGkpKSArICcsJyArIHkoZ2V0SGlnaChkLGkpKSArICcpJzsgfSlcbiAgICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgdmFyIHcgPSAoYXZhaWxhYmxlV2lkdGggLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGgpICogLjk7XG4gICAgICAgICAgICByZXR1cm4gJ20wLDBsMCwnXG4gICAgICAgICAgICAgICAgICsgKHkoZ2V0T3BlbihkLGkpKVxuICAgICAgICAgICAgICAgICAtIHkoZ2V0SGlnaChkLGkpKSlcbiAgICAgICAgICAgICAgICAgKyAnbCdcbiAgICAgICAgICAgICAgICAgKyAoLXcvMilcbiAgICAgICAgICAgICAgICAgKyAnLDBsJ1xuICAgICAgICAgICAgICAgICArICh3LzIpXG4gICAgICAgICAgICAgICAgICsgJywwbDAsJ1xuICAgICAgICAgICAgICAgICArICh5KGdldExvdyhkLGkpKVxuICAgICAgICAgICAgICAgICAtIHkoZ2V0T3BlbihkLGkpKSlcbiAgICAgICAgICAgICAgICAgKyAnbDAsJ1xuICAgICAgICAgICAgICAgICArICh5KGdldENsb3NlKGQsaSkpXG4gICAgICAgICAgICAgICAgIC0geShnZXRMb3coZCxpKSkpXG4gICAgICAgICAgICAgICAgICsgJ2wnXG4gICAgICAgICAgICAgICAgICsgKHcvMilcbiAgICAgICAgICAgICAgICAgKyAnLDBsJ1xuICAgICAgICAgICAgICAgICArICgtdy8yKVxuICAgICAgICAgICAgICAgICArICcsMHonO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLy8uYXR0cignd2lkdGgnLCAoYXZhaWxhYmxlV2lkdGggLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGgpICogLjkgKVxuXG5cbiAgICAgIC8vZDMudHJhbnNpdGlvbih0aWNrcylcbiAgICAgICAgICAvLy5hdHRyKCd5JywgZnVuY3Rpb24oZCxpKSB7ICByZXR1cm4geShNYXRoLm1heCgwLCBnZXRZKGQsaSkpKSB9KVxuICAgICAgICAgIC8vLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gTWF0aC5hYnMoeShnZXRZKGQsaSkpIC0geSgwKSkgfSk7XG4gICAgICAgICAgLy8ub3JkZXIoKTsgIC8vIG5vdCBzdXJlIGlmIHRoaXMgbWFrZXMgYW55IHNlbnNlIGZvciB0aGlzIG1vZGVsXG5cbiAgICB9KTtcblxuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuXG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICBjaGFydC54ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFg7XG4gICAgZ2V0WCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnkgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ2V0WTtcbiAgICBnZXRZID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQub3BlbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXRPcGVuO1xuICAgIGdldE9wZW4gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5jbG9zZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXRDbG9zZTtcbiAgICBnZXRDbG9zZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhpZ2ggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ2V0SGlnaDtcbiAgICBnZXRIaWdoID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQubG93ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldExvdztcbiAgICBnZXRMb3cgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFyZ2luO1xuICAgIG1hcmdpbi50b3AgICAgPSB0eXBlb2YgXy50b3AgICAgIT0gJ3VuZGVmaW5lZCcgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LndpZHRoID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgIHdpZHRoID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcbiAgICBoZWlnaHQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC54U2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDtcbiAgICB4ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueVNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHk7XG4gICAgeSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnhEb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geERvbWFpbjtcbiAgICB4RG9tYWluID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueURvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5RG9tYWluO1xuICAgIHlEb21haW4gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC54UmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geFJhbmdlO1xuICAgIHhSYW5nZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnlSYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5UmFuZ2U7XG4gICAgeVJhbmdlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuZm9yY2VYID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZvcmNlWDtcbiAgICBmb3JjZVggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5mb3JjZVkgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZm9yY2VZO1xuICAgIGZvcmNlWSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnBhZERhdGEgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkRGF0YTtcbiAgICBwYWREYXRhID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuY2xpcEVkZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEVkZ2U7XG4gICAgY2xpcEVkZ2UgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5jb2xvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2xvcjtcbiAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5pZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpZDtcbiAgICBpZCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICByZXR1cm4gY2hhcnQ7XG59XG5udi5tb2RlbHMucGllID0gZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICwgd2lkdGggPSA1MDBcbiAgICAsIGhlaWdodCA9IDUwMFxuICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9XG4gICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAsIGdldERlc2NyaXB0aW9uID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5kZXNjcmlwdGlvbiB9XG4gICAgLCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSAvL0NyZWF0ZSBzZW1pLXVuaXF1ZSBJRCBpbiBjYXNlIHVzZXIgZG9lc24ndCBzZWxlY3Qgb25lXG4gICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgLCB2YWx1ZUZvcm1hdCA9IGQzLmZvcm1hdCgnLC4yZicpXG4gICAgLCBzaG93TGFiZWxzID0gdHJ1ZVxuICAgICwgcGllTGFiZWxzT3V0c2lkZSA9IHRydWVcbiAgICAsIGRvbnV0TGFiZWxzT3V0c2lkZSA9IGZhbHNlXG4gICAgLCBsYWJlbFR5cGUgPSBcImtleVwiXG4gICAgLCBsYWJlbFRocmVzaG9sZCA9IC4wMiAvL2lmIHNsaWNlIHBlcmNlbnRhZ2UgaXMgdW5kZXIgdGhpcywgZG9uJ3Qgc2hvdyBsYWJlbFxuICAgICwgZG9udXQgPSBmYWxzZVxuICAgICwgbGFiZWxTdW5iZWFtTGF5b3V0ID0gZmFsc2VcbiAgICAsIHN0YXJ0QW5nbGUgPSBmYWxzZVxuICAgICwgZW5kQW5nbGUgPSBmYWxzZVxuICAgICwgZG9udXRSYXRpbyA9IDAuNVxuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnY2hhcnRDbGljaycsICdlbGVtZW50Q2xpY2snLCAnZWxlbWVudERibENsaWNrJywgJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JylcbiAgICA7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgcmFkaXVzID0gTWF0aC5taW4oYXZhaWxhYmxlV2lkdGgsIGF2YWlsYWJsZUhlaWdodCkgLyAyLFxuICAgICAgICAgIGFyY1JhZGl1cyA9IHJhZGl1cy0ocmFkaXVzIC8gNSksXG4gICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuXG4gICAgICAvL3ZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LXdyYXAubnYtcGllJykuZGF0YShbZGF0YV0pO1xuICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtd3JhcC5udi1waWUnKS5kYXRhKGRhdGEpO1xuICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsJ252ZDMgbnYtd3JhcCBudi1waWUgbnYtY2hhcnQtJyArIGlkKTtcbiAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1waWUnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1waWVMYWJlbHMnKTtcblxuICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuICAgICAgZy5zZWxlY3QoJy5udi1waWUnKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBhdmFpbGFibGVXaWR0aCAvIDIgKyAnLCcgKyBhdmFpbGFibGVIZWlnaHQgLyAyICsgJyknKTtcbiAgICAgIGcuc2VsZWN0KCcubnYtcGllTGFiZWxzJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgYXZhaWxhYmxlV2lkdGggLyAyICsgJywnICsgYXZhaWxhYmxlSGVpZ2h0IC8gMiArICcpJyk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgY29udGFpbmVyXG4gICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICBkaXNwYXRjaC5jaGFydENsaWNrKHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgIHBvczogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cblxuICAgICAgdmFyIGFyYyA9IGQzLnN2Zy5hcmMoKVxuICAgICAgICAgICAgICAgICAgLm91dGVyUmFkaXVzKGFyY1JhZGl1cyk7XG5cbiAgICAgIGlmIChzdGFydEFuZ2xlKSBhcmMuc3RhcnRBbmdsZShzdGFydEFuZ2xlKVxuICAgICAgaWYgKGVuZEFuZ2xlKSBhcmMuZW5kQW5nbGUoZW5kQW5nbGUpO1xuICAgICAgaWYgKGRvbnV0KSBhcmMuaW5uZXJSYWRpdXMocmFkaXVzICogZG9udXRSYXRpbyk7XG5cbiAgICAgIC8vIFNldHVwIHRoZSBQaWUgY2hhcnQgYW5kIGNob29zZSB0aGUgZGF0YSBlbGVtZW50XG4gICAgICB2YXIgcGllID0gZDMubGF5b3V0LnBpZSgpXG4gICAgICAgICAgLnNvcnQobnVsbClcbiAgICAgICAgICAudmFsdWUoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5kaXNhYmxlZCA/IDAgOiBnZXRZKGQpIH0pO1xuXG4gICAgICB2YXIgc2xpY2VzID0gd3JhcC5zZWxlY3QoJy5udi1waWUnKS5zZWxlY3RBbGwoJy5udi1zbGljZScpXG4gICAgICAgICAgLmRhdGEocGllKTtcblxuICAgICAgdmFyIHBpZUxhYmVscyA9IHdyYXAuc2VsZWN0KCcubnYtcGllTGFiZWxzJykuc2VsZWN0QWxsKCcubnYtbGFiZWwnKVxuICAgICAgICAgIC5kYXRhKHBpZSk7XG5cbiAgICAgIHNsaWNlcy5leGl0KCkucmVtb3ZlKCk7XG4gICAgICBwaWVMYWJlbHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICB2YXIgYWUgPSBzbGljZXMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtc2xpY2UnKVxuICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSl7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXRYKGQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHBvczogW2QzLmV2ZW50LnBhZ2VYLCBkMy5ldmVudC5wYWdlWV0sXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldFgoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldFgoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHBvczogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudERibENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldFgoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHBvczogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICBzbGljZXNcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvcihkLCBpKTsgfSlcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGNvbG9yKGQsIGkpOyB9KTtcblxuICAgICAgICB2YXIgcGF0aHMgPSBhZS5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCkgeyB0aGlzLl9jdXJyZW50ID0gZDsgfSk7XG4gICAgICAgICAgICAvLy5hdHRyKCdkJywgYXJjKTtcblxuICAgICAgICBzbGljZXMuc2VsZWN0KCdwYXRoJylcbiAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cignZCcsIGFyYylcbiAgICAgICAgICAgIC5hdHRyVHdlZW4oJ2QnLCBhcmNUd2Vlbik7XG5cbiAgICAgICAgaWYgKHNob3dMYWJlbHMpIHtcbiAgICAgICAgICAvLyBUaGlzIGRvZXMgdGhlIG5vcm1hbCBsYWJlbFxuICAgICAgICAgIHZhciBsYWJlbHNBcmMgPSBkMy5zdmcuYXJjKCkuaW5uZXJSYWRpdXMoMCk7XG5cbiAgICAgICAgICBpZiAocGllTGFiZWxzT3V0c2lkZSl7IGxhYmVsc0FyYyA9IGFyYzsgfVxuXG4gICAgICAgICAgaWYgKGRvbnV0TGFiZWxzT3V0c2lkZSkgeyBsYWJlbHNBcmMgPSBkMy5zdmcuYXJjKCkub3V0ZXJSYWRpdXMoYXJjLm91dGVyUmFkaXVzKCkpOyB9XG5cbiAgICAgICAgICBwaWVMYWJlbHMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmNsYXNzZWQoXCJudi1sYWJlbFwiLHRydWUpXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBncm91cFxuICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsU3VuYmVhbUxheW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGQub3V0ZXJSYWRpdXMgPSBhcmNSYWRpdXMgKyAxMDsgLy8gU2V0IE91dGVyIENvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICBkLmlubmVyUmFkaXVzID0gYXJjUmFkaXVzICsgMTU7IC8vIFNldCBJbm5lciBDb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0ZUFuZ2xlID0gKGQuc3RhcnRBbmdsZSArIGQuZW5kQW5nbGUpIC8gMiAqICgxODAgLyBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGQuc3RhcnRBbmdsZStkLmVuZEFuZ2xlKS8yIDwgTWF0aC5QSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlQW5nbGUgLT0gOTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZUFuZ2xlICs9IDkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgbGFiZWxzQXJjLmNlbnRyb2lkKGQpICsgJykgcm90YXRlKCcgKyByb3RhdGVBbmdsZSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBkLm91dGVyUmFkaXVzID0gcmFkaXVzICsgMTA7IC8vIFNldCBPdXRlciBDb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgZC5pbm5lclJhZGl1cyA9IHJhZGl1cyArIDE1OyAvLyBTZXQgSW5uZXIgQ29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBsYWJlbHNBcmMuY2VudHJvaWQoZCkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBncm91cC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICcjZmZmJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJyNmZmYnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJ4XCIsIDMpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwicnlcIiwgMyk7XG5cbiAgICAgICAgICAgICAgICBncm91cC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgbGFiZWxTdW5iZWFtTGF5b3V0ID8gKChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgPCBNYXRoLlBJID8gJ3N0YXJ0JyA6ICdlbmQnKSA6ICdtaWRkbGUnKSAvL2NlbnRlciB0aGUgdGV4dCBvbiBpdCdzIG9yaWdpbiBvciBiZWdpbi9lbmQgaWYgb3J0aG9nb25hbCBhbGlnbmVkXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsICcjMDAwJylcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbGFiZWxMb2NhdGlvbkhhc2ggPSB7fTtcbiAgICAgICAgICB2YXIgYXZnSGVpZ2h0ID0gMTQ7XG4gICAgICAgICAgdmFyIGF2Z1dpZHRoID0gMTQwO1xuICAgICAgICAgIHZhciBjcmVhdGVIYXNoS2V5ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcblxuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihjb29yZGluYXRlc1swXS9hdmdXaWR0aCkgKiBhdmdXaWR0aCArICcsJyArIE1hdGguZmxvb3IoY29vcmRpbmF0ZXNbMV0vYXZnSGVpZ2h0KSAqIGF2Z0hlaWdodDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHBpZUxhYmVscy50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsU3VuYmVhbUxheW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGQub3V0ZXJSYWRpdXMgPSBhcmNSYWRpdXMgKyAxMDsgLy8gU2V0IE91dGVyIENvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgICBkLmlubmVyUmFkaXVzID0gYXJjUmFkaXVzICsgMTU7IC8vIFNldCBJbm5lciBDb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0ZUFuZ2xlID0gKGQuc3RhcnRBbmdsZSArIGQuZW5kQW5nbGUpIC8gMiAqICgxODAgLyBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGQuc3RhcnRBbmdsZStkLmVuZEFuZ2xlKS8yIDwgTWF0aC5QSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlQW5nbGUgLT0gOTA7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZUFuZ2xlICs9IDkwO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgbGFiZWxzQXJjLmNlbnRyb2lkKGQpICsgJykgcm90YXRlKCcgKyByb3RhdGVBbmdsZSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBkLm91dGVyUmFkaXVzID0gcmFkaXVzICsgMTA7IC8vIFNldCBPdXRlciBDb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgICAgZC5pbm5lclJhZGl1cyA9IHJhZGl1cyArIDE1OyAvLyBTZXQgSW5uZXIgQ29vcmRpbmF0ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICBPdmVybGFwcGluZyBwaWUgbGFiZWxzIGFyZSBub3QgZ29vZC4gV2hhdCB0aGlzIGF0dGVtcHRzIHRvIGRvIGlzLCBwcmV2ZW50IG92ZXJsYXBwaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIEVhY2ggbGFiZWwgbG9jYXRpb24gaXMgaGFzaGVkLCBhbmQgaWYgYSBoYXNoIGNvbGxpc2lvbiBvY2N1cnMsIHdlIGFzc3VtZSBhbiBvdmVybGFwLlxuICAgICAgICAgICAgICAgICAgICAgIEFkanVzdCB0aGUgbGFiZWwncyB5LXBvc2l0aW9uIHRvIHJlbW92ZSB0aGUgb3ZlcmxhcC5cbiAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBsYWJlbHNBcmMuY2VudHJvaWQoZCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2hLZXkgPSBjcmVhdGVIYXNoS2V5KGNlbnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsTG9jYXRpb25IYXNoW2hhc2hLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJbMV0gLT0gYXZnSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBsYWJlbExvY2F0aW9uSGFzaFtjcmVhdGVIYXNoS2V5KGNlbnRlcildID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgY2VudGVyICsgJyknXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICBwaWVMYWJlbHMuc2VsZWN0KFwiLm52LWxhYmVsIHRleHRcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgbGFiZWxTdW5iZWFtTGF5b3V0ID8gKChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgPCBNYXRoLlBJID8gJ3N0YXJ0JyA6ICdlbmQnKSA6ICdtaWRkbGUnKSAvL2NlbnRlciB0aGUgdGV4dCBvbiBpdCdzIG9yaWdpbiBvciBiZWdpbi9lbmQgaWYgb3J0aG9nb25hbCBhbGlnbmVkXG4gICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsVHlwZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwia2V5XCIgOiBnZXRYKGQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogZ2V0WShkLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICBcInBlcmNlbnRcIjogZDMuZm9ybWF0KCclJykocGVyY2VudClcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKGQudmFsdWUgJiYgcGVyY2VudCA+IGxhYmVsVGhyZXNob2xkKSA/IGxhYmVsVHlwZXNbbGFiZWxUeXBlXSA6ICcnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgYW5nbGUgb2YgYW4gYXJjLCBjb252ZXJ0aW5nIGZyb20gcmFkaWFucyB0byBkZWdyZWVzLlxuICAgICAgICBmdW5jdGlvbiBhbmdsZShkKSB7XG4gICAgICAgICAgdmFyIGEgPSAoZC5zdGFydEFuZ2xlICsgZC5lbmRBbmdsZSkgKiA5MCAvIE1hdGguUEkgLSA5MDtcbiAgICAgICAgICByZXR1cm4gYSA+IDkwID8gYSAtIDE4MCA6IGE7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhcmNUd2VlbihhKSB7XG4gICAgICAgICAgYS5lbmRBbmdsZSA9IGlzTmFOKGEuZW5kQW5nbGUpID8gMCA6IGEuZW5kQW5nbGU7XG4gICAgICAgICAgYS5zdGFydEFuZ2xlID0gaXNOYU4oYS5zdGFydEFuZ2xlKSA/IDAgOiBhLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgaWYgKCFkb251dCkgYS5pbm5lclJhZGl1cyA9IDA7XG4gICAgICAgICAgdmFyIGkgPSBkMy5pbnRlcnBvbGF0ZSh0aGlzLl9jdXJyZW50LCBhKTtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaSgwKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyYyhpKHQpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdHdlZW5QaWUoYikge1xuICAgICAgICAgIGIuaW5uZXJSYWRpdXMgPSAwO1xuICAgICAgICAgIHZhciBpID0gZDMuaW50ZXJwb2xhdGUoe3N0YXJ0QW5nbGU6IDAsIGVuZEFuZ2xlOiAwfSwgYik7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFyYyhpKHQpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICB3aWR0aCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudmFsdWVzID0gZnVuY3Rpb24oXykge1xuICAgIG52LmxvZyhcInBpZS52YWx1ZXMoKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLlwiKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXRYO1xuICAgIGdldFggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFk7XG4gICAgZ2V0WSA9IGQzLmZ1bmN0b3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmRlc2NyaXB0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldERlc2NyaXB0aW9uO1xuICAgIGdldERlc2NyaXB0aW9uID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd0xhYmVscyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93TGFiZWxzO1xuICAgIHNob3dMYWJlbHMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5sYWJlbFN1bmJlYW1MYXlvdXQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxTdW5iZWFtTGF5b3V0O1xuICAgIGxhYmVsU3VuYmVhbUxheW91dCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmRvbnV0TGFiZWxzT3V0c2lkZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb251dExhYmVsc091dHNpZGU7XG4gICAgZG9udXRMYWJlbHNPdXRzaWRlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQucGllTGFiZWxzT3V0c2lkZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwaWVMYWJlbHNPdXRzaWRlO1xuICAgIHBpZUxhYmVsc091dHNpZGUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5sYWJlbFR5cGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGFiZWxUeXBlO1xuICAgIGxhYmVsVHlwZSA9IF87XG4gICAgbGFiZWxUeXBlID0gbGFiZWxUeXBlIHx8IFwia2V5XCI7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmRvbnV0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbnV0O1xuICAgIGRvbnV0ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuZG9udXRSYXRpbyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb251dFJhdGlvO1xuICAgIGRvbnV0UmF0aW8gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXJ0QW5nbGU7XG4gICAgc3RhcnRBbmdsZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVuZEFuZ2xlO1xuICAgIGVuZEFuZ2xlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaWQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaWQ7XG4gICAgaWQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5jb2xvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2xvcjtcbiAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC52YWx1ZUZvcm1hdCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZUZvcm1hdDtcbiAgICB2YWx1ZUZvcm1hdCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmxhYmVsVGhyZXNob2xkID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxhYmVsVGhyZXNob2xkO1xuICAgIGxhYmVsVGhyZXNob2xkID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICByZXR1cm4gY2hhcnQ7XG59XG5udi5tb2RlbHMucGllQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHBpZSA9IG52Lm1vZGVscy5waWUoKVxuICAgICwgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgO1xuXG4gIHZhciBtYXJnaW4gPSB7dG9wOiAzMCwgcmlnaHQ6IDIwLCBib3R0b206IDIwLCBsZWZ0OiAyMH1cbiAgICAsIHdpZHRoID0gbnVsbFxuICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcbiAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAsIHRvb2x0aXBzID0gdHJ1ZVxuICAgICwgdG9vbHRpcCA9IGZ1bmN0aW9uKGtleSwgeSwgZSwgZ3JhcGgpIHtcbiAgICAgICAgcmV0dXJuICc8aDM+JyArIGtleSArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICc8L3A+J1xuICAgICAgfVxuICAgICwgc3RhdGUgPSB7fVxuICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICwgbm9EYXRhID0gXCJObyBEYXRhIEF2YWlsYWJsZS5cIlxuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnKVxuICAgIDtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG4gICAgdmFyIHRvb2x0aXBMYWJlbCA9IHBpZS5kZXNjcmlwdGlvbigpKGUucG9pbnQpIHx8IHBpZS54KCkoZS5wb2ludClcbiAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCAob2Zmc2V0RWxlbWVudCAmJiBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQpIHx8IDAgKSxcbiAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIChvZmZzZXRFbGVtZW50ICYmIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wKSB8fCAwKSxcbiAgICAgICAgeSA9IHBpZS52YWx1ZUZvcm1hdCgpKHBpZS55KCkoZS5wb2ludCkpLFxuICAgICAgICBjb250ZW50ID0gdG9vbHRpcCh0b29sdGlwTGFiZWwsIHksIGUsIGNoYXJ0KTtcblxuICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgZS52YWx1ZSA8IDAgPyAnbicgOiAncycsIG51bGwsIG9mZnNldEVsZW1lbnQpO1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIudHJhbnNpdGlvbigpLmNhbGwoY2hhcnQpOyB9O1xuICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgLy9zZXQgc3RhdGUuZGlzYWJsZWRcbiAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG5cbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxuICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgbm9EYXRhVGV4dFxuICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcbiAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcblxuICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtcGllQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1waWVDaGFydCcpLmFwcGVuZCgnZycpO1xuICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcGllV3JhcCcpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTGVnZW5kXG5cbiAgICAgIGlmIChzaG93TGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZFxuICAgICAgICAgIC53aWR0aCggYXZhaWxhYmxlV2lkdGggKVxuICAgICAgICAgIC5rZXkocGllLngoKSk7XG5cbiAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdyYXAuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoLW1hcmdpbi50b3ApICsnKScpO1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTWFpbiBDaGFydCBDb21wb25lbnQocylcblxuICAgICAgcGllXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpO1xuXG5cbiAgICAgIHZhciBwaWVXcmFwID0gZy5zZWxlY3QoJy5udi1waWVXcmFwJylcbiAgICAgICAgICAuZGF0dW0oW2RhdGFdKTtcblxuICAgICAgZDMudHJhbnNpdGlvbihwaWVXcmFwKS5jYWxsKHBpZSk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgcGllLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVXBkYXRlIGNoYXJ0IGZyb20gYSBzdGF0ZSBvYmplY3QgcGFzc2VkIHRvIGV2ZW50IGhhbmRsZXJcbiAgICAgIGRpc3BhdGNoLm9uKCdjaGFuZ2VTdGF0ZScsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIGUuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgcGllLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gIH0pO1xuXG4gIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUpO1xuICB9KTtcblxuICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICB9KTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gIGNoYXJ0LnBpZSA9IHBpZTtcblxuICBkMy5yZWJpbmQoY2hhcnQsIHBpZSwgJ3ZhbHVlRm9ybWF0JywgJ3ZhbHVlcycsICd4JywgJ3knLCAnZGVzY3JpcHRpb24nLCAnaWQnLCAnc2hvd0xhYmVscycsICdkb251dExhYmVsc091dHNpZGUnLCAncGllTGFiZWxzT3V0c2lkZScsICdsYWJlbFR5cGUnLCAnZG9udXQnLCAnZG9udXRSYXRpbycsICdsYWJlbFRocmVzaG9sZCcpO1xuICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG4gIFxuICBjaGFydC5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFyZ2luO1xuICAgIG1hcmdpbi50b3AgICAgPSB0eXBlb2YgXy50b3AgICAgIT0gJ3VuZGVmaW5lZCcgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LndpZHRoID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgIHdpZHRoID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcbiAgICBoZWlnaHQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5jb2xvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2xvcjtcbiAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XG4gICAgcGllLmNvbG9yKGNvbG9yKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd0xlZ2VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93TGVnZW5kO1xuICAgIHNob3dMZWdlbmQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50b29sdGlwcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0b29sdGlwcztcbiAgICB0b29sdGlwcyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXBDb250ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXA7XG4gICAgdG9vbHRpcCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnN0YXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXRlO1xuICAgIHN0YXRlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuZGVmYXVsdFN0YXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRlZmF1bHRTdGF0ZTtcbiAgICBkZWZhdWx0U3RhdGUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5ub0RhdGEgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9EYXRhO1xuICAgIG5vRGF0YSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICByZXR1cm4gY2hhcnQ7XG59XG5cbm52Lm1vZGVscy5zY2F0dGVyID0gZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBtYXJnaW4gICAgICAgPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICwgd2lkdGggICAgICAgID0gOTYwXG4gICAgLCBoZWlnaHQgICAgICAgPSA1MDBcbiAgICAsIGNvbG9yICAgICAgICA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpIC8vIGNob29zZXMgY29sb3JcbiAgICAsIGlkICAgICAgICAgICA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMCkgLy9DcmVhdGUgc2VtaS11bmlxdWUgSUQgaW5jYXNlIHVzZXIgZG9lc24ndCBzZWxlY3Qgb25lXG4gICAgLCB4ICAgICAgICAgICAgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICwgeSAgICAgICAgICAgID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAsIHogICAgICAgICAgICA9IGQzLnNjYWxlLmxpbmVhcigpIC8vbGluZWFyIGJlY2F1c2UgZDMuc3ZnLnNoYXBlLnNpemUgaXMgdHJlYXRlZCBhcyBhcmVhXG4gICAgLCBnZXRYICAgICAgICAgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfSAvLyBhY2Nlc3NvciB0byBnZXQgdGhlIHggdmFsdWVcbiAgICAsIGdldFkgICAgICAgICA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9IC8vIGFjY2Vzc29yIHRvIGdldCB0aGUgeSB2YWx1ZVxuICAgICwgZ2V0U2l6ZSAgICAgID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zaXplIHx8IDF9IC8vIGFjY2Vzc29yIHRvIGdldCB0aGUgcG9pbnQgc2l6ZVxuICAgICwgZ2V0U2hhcGUgICAgID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zaGFwZSB8fCAnY2lyY2xlJyB9IC8vIGFjY2Vzc29yIHRvIGdldCBwb2ludCBzaGFwZVxuICAgICwgb25seUNpcmNsZXMgID0gdHJ1ZSAvLyBTZXQgdG8gZmFsc2UgdG8gdXNlIHNoYXBlc1xuICAgICwgZm9yY2VYICAgICAgID0gW10gLy8gTGlzdCBvZiBudW1iZXJzIHRvIEZvcmNlIGludG8gdGhlIFggc2NhbGUgKGllLiAwLCBvciBhIG1heCAvIG1pbiwgZXRjLilcbiAgICAsIGZvcmNlWSAgICAgICA9IFtdIC8vIExpc3Qgb2YgbnVtYmVycyB0byBGb3JjZSBpbnRvIHRoZSBZIHNjYWxlXG4gICAgLCBmb3JjZVNpemUgICAgPSBbXSAvLyBMaXN0IG9mIG51bWJlcnMgdG8gRm9yY2UgaW50byB0aGUgU2l6ZSBzY2FsZVxuICAgICwgaW50ZXJhY3RpdmUgID0gdHJ1ZSAvLyBJZiB0cnVlLCBwbG90cyBhIHZvcm9ub2kgb3ZlcmxheSBmb3IgYWR2YW5jZWQgcG9pbnQgaW50ZXJzZWN0aW9uXG4gICAgLCBwb2ludEtleSAgICAgPSBudWxsXG4gICAgLCBwb2ludEFjdGl2ZSAgPSBmdW5jdGlvbihkKSB7IHJldHVybiAhZC5ub3RBY3RpdmUgfSAvLyBhbnkgcG9pbnRzIHRoYXQgcmV0dXJuIGZhbHNlIHdpbGwgYmUgZmlsdGVyZWQgb3V0XG4gICAgLCBwYWREYXRhICAgICAgPSBmYWxzZSAvLyBJZiB0cnVlLCBhZGRzIGhhbGYgYSBkYXRhIHBvaW50cyB3aWR0aCB0byBmcm9udCBhbmQgYmFjaywgZm9yIGxpbmluZyB1cCBhIGxpbmUgY2hhcnQgd2l0aCBhIGJhciBjaGFydFxuICAgICwgcGFkRGF0YU91dGVyID0gLjEgLy9vdXRlclBhZGRpbmcgdG8gaW1pdGF0ZSBvcmRpbmFsIHNjYWxlIG91dGVyIHBhZGRpbmdcbiAgICAsIGNsaXBFZGdlICAgICA9IGZhbHNlIC8vIGlmIHRydWUsIG1hc2tzIHBvaW50cyB3aXRoaW4geCBhbmQgeSBzY2FsZVxuICAgICwgY2xpcFZvcm9ub2kgID0gdHJ1ZSAvLyBpZiB0cnVlLCBtYXNrcyBlYWNoIHBvaW50IHdpdGggYSBjaXJjbGUuLi4gY2FuIHR1cm4gb2ZmIHRvIHNsaWdodGx5IGluY3JlYXNlIHBlcmZvcm1hbmNlXG4gICAgLCBjbGlwUmFkaXVzICAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDI1IH0gLy8gZnVuY3Rpb24gdG8gZ2V0IHRoZSByYWRpdXMgZm9yIHZvcm9ub2kgcG9pbnQgY2xpcHNcbiAgICAsIHhEb21haW4gICAgICA9IG51bGwgLy8gT3ZlcnJpZGUgeCBkb21haW4gKHNraXBzIHRoZSBjYWxjdWxhdGlvbiBmcm9tIGRhdGEpXG4gICAgLCB5RG9tYWluICAgICAgPSBudWxsIC8vIE92ZXJyaWRlIHkgZG9tYWluXG4gICAgLCB4UmFuZ2UgICAgICAgPSBudWxsIC8vIE92ZXJyaWRlIHggcmFuZ2VcbiAgICAsIHlSYW5nZSAgICAgICA9IG51bGwgLy8gT3ZlcnJpZGUgeSByYW5nZVxuICAgICwgc2l6ZURvbWFpbiAgID0gbnVsbCAvLyBPdmVycmlkZSBwb2ludCBzaXplIGRvbWFpblxuICAgICwgc2l6ZVJhbmdlICAgID0gbnVsbFxuICAgICwgc2luZ2xlUG9pbnQgID0gZmFsc2VcbiAgICAsIGRpc3BhdGNoICAgICA9IGQzLmRpc3BhdGNoKCdlbGVtZW50Q2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnKVxuICAgICwgdXNlVm9yb25vaSAgID0gdHJ1ZVxuICAgIDtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgeDAsIHkwLCB6MCAvLyB1c2VkIHRvIHN0b3JlIHByZXZpb3VzIHNjYWxlc1xuICAgICwgdGltZW91dElEXG4gICAgLCBuZWVkc1VwZGF0ZSA9IGZhbHNlIC8vIEZsYWcgZm9yIHdoZW4gdGhlIHBvaW50cyBhcmUgdmlzdWFsbHkgdXBkYXRpbmcsIGJ1dCB0aGUgaW50ZXJhY3RpdmUgbGF5ZXIgaXMgYmVoaW5kLCB0byBkaXNhYmxlIHRvb2x0aXBzXG4gICAgO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcblxuICAgICAgLy9hZGQgc2VyaWVzIGluZGV4IHRvIGVhY2ggZGF0YSBwb2ludCBmb3IgcmVmZXJlbmNlXG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLCBpKSB7XG4gICAgICAgIHNlcmllcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgIHBvaW50LnNlcmllcyA9IGk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBTY2FsZXNcblxuICAgICAgLy8gcmVtYXAgYW5kIGZsYXR0ZW4gdGhlIGRhdGEgZm9yIHVzZSBpbiBjYWxjdWxhdGluZyB0aGUgc2NhbGVzJyBkb21haW5zXG4gICAgICB2YXIgc2VyaWVzRGF0YSA9ICh4RG9tYWluICYmIHlEb21haW4gJiYgc2l6ZURvbWFpbikgPyBbXSA6IC8vIGlmIHdlIGtub3cgeERvbWFpbiBhbmQgeURvbWFpbiBhbmQgc2l6ZURvbWFpbiwgbm8gbmVlZCB0byBjYWxjdWxhdGUuLi4uIGlmIFNpemUgaXMgY29uc3RhbnQgcmVtZW1iZXIgdG8gc2V0IHNpemVEb21haW4gdG8gc3BlZWQgdXAgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIGQzLm1lcmdlKFxuICAgICAgICAgICAgICBkYXRhLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQudmFsdWVzLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IGdldFgoZCxpKSwgeTogZ2V0WShkLGkpLCBzaXplOiBnZXRTaXplKGQsaSkgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICB4ICAgLmRvbWFpbih4RG9tYWluIHx8IGQzLmV4dGVudChzZXJpZXNEYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLng7IH0pLmNvbmNhdChmb3JjZVgpKSlcblxuICAgICAgaWYgKHBhZERhdGEgJiYgZGF0YVswXSlcbiAgICAgICAgeC5yYW5nZSh4UmFuZ2UgfHwgWyhhdmFpbGFibGVXaWR0aCAqIHBhZERhdGFPdXRlciArICBhdmFpbGFibGVXaWR0aCkgLyAoMiAqZGF0YVswXS52YWx1ZXMubGVuZ3RoKSwgYXZhaWxhYmxlV2lkdGggLSBhdmFpbGFibGVXaWR0aCAqICgxICsgcGFkRGF0YU91dGVyKSAvICgyICogZGF0YVswXS52YWx1ZXMubGVuZ3RoKSAgXSk7XG4gICAgICAgIC8veC5yYW5nZShbYXZhaWxhYmxlV2lkdGggKiAuNSAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCwgYXZhaWxhYmxlV2lkdGggKiAoZGF0YVswXS52YWx1ZXMubGVuZ3RoIC0gLjUpICAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCBdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeC5yYW5nZSh4UmFuZ2UgfHwgWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgIHkgICAuZG9tYWluKHlEb21haW4gfHwgZDMuZXh0ZW50KHNlcmllc0RhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9KS5jb25jYXQoZm9yY2VZKSkpXG4gICAgICAgICAgLnJhbmdlKHlSYW5nZSB8fCBbYXZhaWxhYmxlSGVpZ2h0LCAwXSk7XG5cbiAgICAgIHogICAuZG9tYWluKHNpemVEb21haW4gfHwgZDMuZXh0ZW50KHNlcmllc0RhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc2l6ZSB9KS5jb25jYXQoZm9yY2VTaXplKSkpXG4gICAgICAgICAgLnJhbmdlKHNpemVSYW5nZSB8fCBbMTYsIDI1Nl0pO1xuXG4gICAgICAvLyBJZiBzY2FsZSdzIGRvbWFpbiBkb24ndCBoYXZlIGEgcmFuZ2UsIHNsaWdodGx5IGFkanVzdCB0byBtYWtlIG9uZS4uLiBzbyBhIGNoYXJ0IGNhbiBzaG93IGEgc2luZ2xlIGRhdGEgcG9pbnRcbiAgICAgIGlmICh4LmRvbWFpbigpWzBdID09PSB4LmRvbWFpbigpWzFdIHx8IHkuZG9tYWluKClbMF0gPT09IHkuZG9tYWluKClbMV0pIHNpbmdsZVBvaW50ID0gdHJ1ZTtcbiAgICAgIGlmICh4LmRvbWFpbigpWzBdID09PSB4LmRvbWFpbigpWzFdKVxuICAgICAgICB4LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgIHguZG9tYWluKFt4LmRvbWFpbigpWzBdIC0geC5kb21haW4oKVswXSAqIDAuMDEsIHguZG9tYWluKClbMV0gKyB4LmRvbWFpbigpWzFdICogMC4wMV0pXG4gICAgICAgICAgOiB4LmRvbWFpbihbLTEsMV0pO1xuXG4gICAgICBpZiAoeS5kb21haW4oKVswXSA9PT0geS5kb21haW4oKVsxXSlcbiAgICAgICAgeS5kb21haW4oKVswXSA/XG4gICAgICAgICAgICB5LmRvbWFpbihbeS5kb21haW4oKVswXSAtIHkuZG9tYWluKClbMF0gKiAwLjAxLCB5LmRvbWFpbigpWzFdICsgeS5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgIDogeS5kb21haW4oWy0xLDFdKTtcblxuICAgICAgaWYgKCBpc05hTih4LmRvbWFpbigpWzBdKSkge1xuICAgICAgICAgIHguZG9tYWluKFstMSwxXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICggaXNOYU4oeS5kb21haW4oKVswXSkpIHtcbiAgICAgICAgICB5LmRvbWFpbihbLTEsMV0pO1xuICAgICAgfVxuXG5cbiAgICAgIHgwID0geDAgfHwgeDtcbiAgICAgIHkwID0geTAgfHwgeTtcbiAgICAgIHowID0gejAgfHwgejtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcblxuICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtc2NhdHRlcicpLmRhdGEoW2RhdGFdKTtcbiAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LXNjYXR0ZXIgbnYtY2hhcnQtJyArIGlkICsgKHNpbmdsZVBvaW50ID8gJyBudi1zaW5nbGUtcG9pbnQnIDogJycpKTtcbiAgICAgIHZhciBkZWZzRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZ3JvdXBzJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcG9pbnQtcGF0aHMnKTtcblxuICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIGRlZnNFbnRlci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAuYXR0cignaWQnLCAnbnYtZWRnZS1jbGlwLScgKyBpZClcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpO1xuXG4gICAgICB3cmFwLnNlbGVjdCgnI252LWVkZ2UtY2xpcC0nICsgaWQgKyAnIHJlY3QnKVxuICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAoYXZhaWxhYmxlSGVpZ2h0ID4gMCkgPyBhdmFpbGFibGVIZWlnaHQgOiAwKTtcblxuICAgICAgZyAgIC5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwRWRnZSA/ICd1cmwoI252LWVkZ2UtY2xpcC0nICsgaWQgKyAnKScgOiAnJyk7XG5cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlSW50ZXJhY3RpdmVMYXllcigpIHtcblxuICAgICAgICBpZiAoIWludGVyYWN0aXZlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIGV2ZW50RWxlbWVudHM7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZDMubWVyZ2UoZGF0YS5tYXAoZnVuY3Rpb24oZ3JvdXAsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cC52YWx1ZXNcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwb2ludCwgcG9pbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vICpBZGRpbmcgbm9pc2UgdG8gbWFrZSBkdXBsaWNhdGVzIHZlcnkgdW5saWtlbHlcbiAgICAgICAgICAgICAgICAvLyAqSW5qZWN0aW5nIHNlcmllcyBhbmQgcG9pbnQgaW5kZXggZm9yIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIC8qICpBZGRpbmcgYSAnaml0dGVyJyB0byB0aGUgcG9pbnRzLCBiZWNhdXNlIHRoZXJlJ3MgYW4gaXNzdWUgaW4gZDMuZ2VvbS52b3Jvbm9pLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHBYID0gZ2V0WChwb2ludCxwb2ludEluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgcFkgPSBnZXRZKHBvaW50LHBvaW50SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt4KHBYKSsgTWF0aC5yYW5kb20oKSAqIDFlLTcsXG4gICAgICAgICAgICAgICAgICAgICAgICB5KHBZKSsgTWF0aC5yYW5kb20oKSAqIDFlLTcsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleCwgcG9pbnRdOyAvL3RlbXAgaGFjayB0byBhZGQgbm9pc2UgdW50aWxsIEkgdGhpbmsgb2YgYSBiZXR0ZXIgd2F5IHNvIHRoZXJlIGFyZSBubyBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocG9pbnRBcnJheSwgcG9pbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludEFjdGl2ZShwb2ludEFycmF5WzRdLCBwb2ludEluZGV4KTsgLy8gSXNzdWUgIzIzNy4uIG1vdmUgZmlsdGVyIHRvIGFmdGVyIG1hcCwgc28gcG9pbnRJbmRleCBpcyBjb3JyZWN0IVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cblxuXG4gICAgICAgIC8vaW5qZWN0IHNlcmllcyBhbmQgcG9pbnQgaW5kZXggZm9yIHJlZmVyZW5jZSBpbnRvIHZvcm9ub2lcbiAgICAgICAgaWYgKHVzZVZvcm9ub2kgPT09IHRydWUpIHtcblxuICAgICAgICAgIGlmIChjbGlwVm9yb25vaSkge1xuICAgICAgICAgICAgdmFyIHBvaW50Q2xpcHNFbnRlciA9IHdyYXAuc2VsZWN0KCdkZWZzJykuc2VsZWN0QWxsKCcubnYtcG9pbnQtY2xpcHMnKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtpZF0pXG4gICAgICAgICAgICAgIC5lbnRlcigpO1xuXG4gICAgICAgICAgICBwb2ludENsaXBzRW50ZXIuYXBwZW5kKCdjbGlwUGF0aCcpXG4gICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtcG9pbnQtY2xpcHMnKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ252LXBvaW50cy1jbGlwLScgKyBpZCk7XG5cbiAgICAgICAgICAgIHZhciBwb2ludENsaXBzID0gd3JhcC5zZWxlY3QoJyNudi1wb2ludHMtY2xpcC0nICsgaWQpLnNlbGVjdEFsbCgnY2lyY2xlJylcbiAgICAgICAgICAgICAgICAuZGF0YSh2ZXJ0aWNlcyk7XG4gICAgICAgICAgICBwb2ludENsaXBzLmVudGVyKCkuYXBwZW5kKCdjaXJjbGUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgY2xpcFJhZGl1cyk7XG4gICAgICAgICAgICBwb2ludENsaXBzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHBvaW50Q2xpcHNcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBmdW5jdGlvbihkKSB7IHJldHVybiBkWzBdIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZFsxXSB9KTtcblxuICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1wb2ludC1wYXRocycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsaXAtcGF0aCcsICd1cmwoI252LXBvaW50cy1jbGlwLScgKyBpZCArICcpJyk7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICBpZih2ZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElzc3VlICMyODMgLSBBZGRpbmcgMiBkdW1teSBwb2ludHMgdG8gdGhlIHZvcm9ub2kgYi9jIHZvcm9ub2kgcmVxdWlyZXMgbWluIDMgcG9pbnRzIHRvIHdvcmtcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goW3gucmFuZ2UoKVswXSAtIDIwLCB5LnJhbmdlKClbMF0gLSAyMCwgbnVsbCwgbnVsbF0pO1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChbeC5yYW5nZSgpWzFdICsgMjAsIHkucmFuZ2UoKVsxXSArIDIwLCBudWxsLCBudWxsXSk7XG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt4LnJhbmdlKClbMF0gLSAyMCwgeS5yYW5nZSgpWzBdICsgMjAsIG51bGwsIG51bGxdKTtcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goW3gucmFuZ2UoKVsxXSArIDIwLCB5LnJhbmdlKClbMV0gLSAyMCwgbnVsbCwgbnVsbF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBib3VuZHMgPSBkMy5nZW9tLnBvbHlnb24oW1xuICAgICAgICAgICAgICBbLTEwLC0xMF0sXG4gICAgICAgICAgICAgIFstMTAsaGVpZ2h0ICsgMTBdLFxuICAgICAgICAgICAgICBbd2lkdGggKyAxMCxoZWlnaHQgKyAxMF0sXG4gICAgICAgICAgICAgIFt3aWR0aCArIDEwLC0xMF1cbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIHZhciB2b3Jvbm9pID0gZDMuZ2VvbS52b3Jvbm9pKHZlcnRpY2VzKS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdkYXRhJzogYm91bmRzLmNsaXAoZCksXG4gICAgICAgICAgICAgICAgJ3Nlcmllcyc6IHZlcnRpY2VzW2ldWzJdLFxuICAgICAgICAgICAgICAgICdwb2ludCc6IHZlcnRpY2VzW2ldWzNdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICB2YXIgcG9pbnRQYXRocyA9IHdyYXAuc2VsZWN0KCcubnYtcG9pbnQtcGF0aHMnKS5zZWxlY3RBbGwoJ3BhdGgnKVxuICAgICAgICAgICAgICAuZGF0YSh2b3Jvbm9pKTtcbiAgICAgICAgICBwb2ludFBhdGhzLmVudGVyKCkuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAnbnYtcGF0aC0nK2k7IH0pO1xuICAgICAgICAgIHBvaW50UGF0aHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgIHBvaW50UGF0aHNcbiAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGF0YS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnTSAwIDAnXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ00nICsgZC5kYXRhLmpvaW4oJ0wnKSArICdaJztcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbW91c2VFdmVudENhbGxiYWNrID0gZnVuY3Rpb24oZCxtRGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSBkYXRhW2Quc2VyaWVzXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlcmllcyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciBwb2ludCAgPSBzZXJpZXMudmFsdWVzW2QucG9pbnRdO1xuXG4gICAgICAgICAgICAgICAgbURpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKHBvaW50LCBkLnBvaW50KSkgKyBtYXJnaW4ubGVmdCwgeShnZXRZKHBvaW50LCBkLnBvaW50KSkgKyBtYXJnaW4udG9wXSxcbiAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGQucG9pbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcG9pbnRQYXRoc1xuICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIG1vdXNlRXZlbnRDYWxsYmFjayhkLCBkaXNwYXRjaC5lbGVtZW50Q2xpY2spO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBtb3VzZUV2ZW50Q2FsbGJhY2soZCwgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcik7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgbW91c2VFdmVudENhbGxiYWNrKGQsIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCk7XG4gICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgIC8vIGJyaW5nIGRhdGEgaW4gZm9ybSBuZWVkZWQgZm9yIGNsaWNrIGhhbmRsZXJzXG4gICAgICAgICAgdmFyIGRhdGFXaXRoUG9pbnRzID0gdmVydGljZXMubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnZGF0YSc6IGQsXG4gICAgICAgICAgICAgICAgJ3Nlcmllcyc6IHZlcnRpY2VzW2ldWzJdLFxuICAgICAgICAgICAgICAgICdwb2ludCc6IHZlcnRpY2VzW2ldWzNdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgLy8gYWRkIGV2ZW50IGhhbmRsZXJzIHRvIHBvaW50cyBpbnN0ZWFkIHZvcm9ub2kgcGF0aHNcbiAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LWdyb3VwcycpLnNlbGVjdEFsbCgnLm52LWdyb3VwJylcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5udi1wb2ludCcpXG4gICAgICAgICAgICAgIC8vLmRhdGEoZGF0YVdpdGhQb2ludHMpXG4gICAgICAgICAgICAgIC8vLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdhdXRvJykgLy8gcmVjYXRpdmF0ZSBldmVudHMsIGRpc2FibGVkIGJ5IGNzc1xuICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgLy9udi5sb2coJ3Rlc3QnLCBkLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUgfHwgIWRhdGFbZC5zZXJpZXNdKSByZXR1cm4gMDsgLy9jaGVjayBpZiB0aGlzIGlzIGEgZHVtbXkgcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzID0gZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ICA9IHNlcmllcy52YWx1ZXNbaV07XG5cbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50Q2xpY2soe1xuICAgICAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgocG9pbnQsIGkpKSArIG1hcmdpbi5sZWZ0LCB5KGdldFkocG9pbnQsIGkpKSArIG1hcmdpbi50b3BdLFxuICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGlmIChuZWVkc1VwZGF0ZSB8fCAhZGF0YVtkLnNlcmllc10pIHJldHVybiAwOyAvL2NoZWNrIGlmIHRoaXMgaXMgYSBkdW1teSBwb2ludFxuICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgID0gc2VyaWVzLnZhbHVlc1tpXTtcblxuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgocG9pbnQsIGkpKSArIG1hcmdpbi5sZWZ0LCB5KGdldFkocG9pbnQsIGkpKSArIG1hcmdpbi50b3BdLFxuICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRzVXBkYXRlIHx8ICFkYXRhW2Quc2VyaWVzXSkgcmV0dXJuIDA7IC8vY2hlY2sgaWYgdGhpcyBpcyBhIGR1bW15IHBvaW50XG4gICAgICAgICAgICAgICAgdmFyIHNlcmllcyA9IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICBwb2ludCAgPSBzZXJpZXMudmFsdWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgIHZhciBncm91cHMgPSB3cmFwLnNlbGVjdCgnLm52LWdyb3VwcycpLnNlbGVjdEFsbCgnLm52LWdyb3VwJylcbiAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0sIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQua2V5IH0pO1xuICAgICAgZ3JvdXBzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMWUtNilcbiAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDFlLTYpO1xuICAgICAgZ3JvdXBzLmV4aXQoKVxuICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgIGdyb3Vwc1xuICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ252LWdyb3VwIG52LXNlcmllcy0nICsgaSB9KVxuICAgICAgICAgIC5jbGFzc2VkKCdob3ZlcicsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaG92ZXIgfSk7XG4gICAgICBncm91cHNcbiAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvcihkLCBpKSB9KVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvcihkLCBpKSB9KVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxuICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgLjUpO1xuXG5cbiAgICAgIGlmIChvbmx5Q2lyY2xlcykge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBncm91cHMuc2VsZWN0QWxsKCdjaXJjbGUubnYtcG9pbnQnKVxuICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMgfSwgcG9pbnRLZXkpO1xuICAgICAgICBwb2ludHMuZW50ZXIoKS5hcHBlbmQoJ2NpcmNsZScpXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoZCxpKSB7IHJldHVybiBkLmNvbG9yIH0pXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uIChkLGkpIHsgcmV0dXJuIGQuY29sb3IgfSlcbiAgICAgICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHgwKGdldFgoZCxpKSkpIH0pXG4gICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh5MChnZXRZKGQsaSkpKSB9KVxuICAgICAgICAgICAgLmF0dHIoJ3InLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIE1hdGguc3FydCh6KGdldFNpemUoZCxpKSkvTWF0aC5QSSkgfSk7XG4gICAgICAgIHBvaW50cy5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIGdyb3Vwcy5leGl0KCkuc2VsZWN0QWxsKCdwYXRoLm52LXBvaW50JykudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cignY3gnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh4KGdldFgoZCxpKSkpIH0pXG4gICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh5KGdldFkoZCxpKSkpIH0pXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgIHBvaW50cy5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ252LXBvaW50JywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdudi1wb2ludC0nICsgaSwgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdob3ZlcicsZmFsc2UpXG4gICAgICAgICAgICA7XG4gICAgICAgIH0pO1xuICAgICAgICBwb2ludHMudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cignY3gnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh4KGdldFgoZCxpKSkpIH0pXG4gICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh5KGdldFkoZCxpKSkpIH0pXG4gICAgICAgICAgICAuYXR0cigncicsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gTWF0aC5zcXJ0KHooZ2V0U2l6ZShkLGkpKS9NYXRoLlBJKSB9KTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gZ3JvdXBzLnNlbGVjdEFsbCgncGF0aC5udi1wb2ludCcpXG4gICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcyB9KTtcbiAgICAgICAgcG9pbnRzLmVudGVyKCkuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChkLGkpIHsgcmV0dXJuIGQuY29sb3IgfSlcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24gKGQsaSkgeyByZXR1cm4gZC5jb2xvciB9KVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeDAoZ2V0WChkLGkpKSArICcsJyArIHkwKGdldFkoZCxpKSkgKyAnKSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cignZCcsXG4gICAgICAgICAgICAgIGQzLnN2Zy5zeW1ib2woKVxuICAgICAgICAgICAgICAgIC50eXBlKGdldFNoYXBlKVxuICAgICAgICAgICAgICAgIC5zaXplKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geihnZXRTaXplKGQsaSkpIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICBwb2ludHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICBncm91cHMuZXhpdCgpLnNlbGVjdEFsbCgncGF0aC5udi1wb2ludCcpXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4KGdldFgoZCxpKSkgKyAnLCcgKyB5KGdldFkoZCxpKSkgKyAnKSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgIHBvaW50cy5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ252LXBvaW50JywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdudi1wb2ludC0nICsgaSwgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdob3ZlcicsZmFsc2UpXG4gICAgICAgICAgICA7XG4gICAgICAgIH0pO1xuICAgICAgICBwb2ludHMudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgIC8vbnYubG9nKGQsaSxnZXRYKGQsaSksIHgoZ2V0WChkLGkpKSk7XG4gICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4KGdldFgoZCxpKSkgKyAnLCcgKyB5KGdldFkoZCxpKSkgKyAnKSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cignZCcsXG4gICAgICAgICAgICAgIGQzLnN2Zy5zeW1ib2woKVxuICAgICAgICAgICAgICAgIC50eXBlKGdldFNoYXBlKVxuICAgICAgICAgICAgICAgIC5zaXplKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geihnZXRTaXplKGQsaSkpIH0pXG4gICAgICAgICAgICApO1xuICAgICAgfVxuXG5cbiAgICAgIC8vIERlbGF5IHVwZGF0aW5nIHRoZSBpbnZpc2libGUgaW50ZXJhY3RpdmUgbGF5ZXIgZm9yIHNtb290aGVyIGFuaW1hdGlvblxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7IC8vIHN0b3AgcmVwZWF0IGNhbGxzIHRvIHVwZGF0ZUludGVyYWN0aXZlTGF5ZXJcbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQodXBkYXRlSW50ZXJhY3RpdmVMYXllciwgMzAwKTtcbiAgICAgIC8vdXBkYXRlSW50ZXJhY3RpdmVMYXllcigpO1xuXG4gICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgIHgwID0geC5jb3B5KCk7XG4gICAgICB5MCA9IHkuY29weSgpO1xuICAgICAgejAgPSB6LmNvcHkoKTtcblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNoYXJ0LmNsZWFySGlnaGxpZ2h0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy9SZW1vdmUgdGhlICdob3ZlcicgY2xhc3MgZnJvbSBhbGwgaGlnaGxpZ2h0ZWQgcG9pbnRzLlxuICAgICAgZDMuc2VsZWN0QWxsKFwiLm52LWNoYXJ0LVwiICsgaWQgKyBcIiAubnYtcG9pbnQuaG92ZXJcIikuY2xhc3NlZChcImhvdmVyXCIsZmFsc2UpO1xuICB9O1xuXG4gIGNoYXJ0LmhpZ2hsaWdodFBvaW50ID0gZnVuY3Rpb24oc2VyaWVzSW5kZXgscG9pbnRJbmRleCxpc0hvdmVyT3Zlcikge1xuICAgICAgZDMuc2VsZWN0KFwiLm52LWNoYXJ0LVwiICsgaWQgKyBcIiAubnYtc2VyaWVzLVwiICsgc2VyaWVzSW5kZXggKyBcIiAubnYtcG9pbnQtXCIgKyBwb2ludEluZGV4KVxuICAgICAgICAgIC5jbGFzc2VkKFwiaG92ZXJcIixpc0hvdmVyT3Zlcik7XG4gIH07XG5cblxuICBkaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci5wb2ludCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgaWYgKGludGVyYWN0aXZlKSBjaGFydC5oaWdobGlnaHRQb2ludChkLnNlcmllc0luZGV4LGQucG9pbnRJbmRleCx0cnVlKTtcbiAgfSk7XG5cbiAgZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC5wb2ludCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgaWYgKGludGVyYWN0aXZlKSBjaGFydC5oaWdobGlnaHRQb2ludChkLnNlcmllc0luZGV4LGQucG9pbnRJbmRleCxmYWxzZSk7XG4gIH0pO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICBjaGFydC54ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFg7XG4gICAgZ2V0WCA9IGQzLmZ1bmN0b3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnkgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ2V0WTtcbiAgICBnZXRZID0gZDMuZnVuY3RvcihfKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXRTaXplO1xuICAgIGdldFNpemUgPSBkMy5mdW5jdG9yKF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFyZ2luO1xuICAgIG1hcmdpbi50b3AgICAgPSB0eXBlb2YgXy50b3AgICAgIT0gJ3VuZGVmaW5lZCcgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LndpZHRoID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgIHdpZHRoID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcbiAgICBoZWlnaHQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC54U2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDtcbiAgICB4ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueVNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHk7XG4gICAgeSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnpTY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB6O1xuICAgIHogPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC54RG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHhEb21haW47XG4gICAgeERvbWFpbiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnlEb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geURvbWFpbjtcbiAgICB5RG9tYWluID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2l6ZURvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplRG9tYWluO1xuICAgIHNpemVEb21haW4gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC54UmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geFJhbmdlO1xuICAgIHhSYW5nZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnlSYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5UmFuZ2U7XG4gICAgeVJhbmdlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2l6ZVJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemVSYW5nZTtcbiAgICBzaXplUmFuZ2UgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5mb3JjZVggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZm9yY2VYO1xuICAgIGZvcmNlWCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmZvcmNlWSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmb3JjZVk7XG4gICAgZm9yY2VZID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuZm9yY2VTaXplID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZvcmNlU2l6ZTtcbiAgICBmb3JjZVNpemUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5pbnRlcmFjdGl2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcmFjdGl2ZTtcbiAgICBpbnRlcmFjdGl2ZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnBvaW50S2V5ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBvaW50S2V5O1xuICAgIHBvaW50S2V5ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQucG9pbnRBY3RpdmUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcG9pbnRBY3RpdmU7XG4gICAgcG9pbnRBY3RpdmUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5wYWREYXRhID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZERhdGE7XG4gICAgcGFkRGF0YSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnBhZERhdGFPdXRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWREYXRhT3V0ZXI7XG4gICAgcGFkRGF0YU91dGVyID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuY2xpcEVkZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEVkZ2U7XG4gICAgY2xpcEVkZ2UgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5jbGlwVm9yb25vaT0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBWb3Jvbm9pO1xuICAgIGNsaXBWb3Jvbm9pID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudXNlVm9yb25vaT0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHVzZVZvcm9ub2k7XG4gICAgdXNlVm9yb25vaSA9IF87XG4gICAgaWYgKHVzZVZvcm9ub2kgPT09IGZhbHNlKSB7XG4gICAgICAgIGNsaXBWb3Jvbm9pID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5jbGlwUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBSYWRpdXM7XG4gICAgY2xpcFJhZGl1cyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNoYXBlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFNoYXBlO1xuICAgIGdldFNoYXBlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQub25seUNpcmNsZXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb25seUNpcmNsZXM7XG4gICAgb25seUNpcmNsZXMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5pZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpZDtcbiAgICBpZCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNpbmdsZVBvaW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpbmdsZVBvaW50O1xuICAgIHNpbmdsZVBvaW50ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIHJldHVybiBjaGFydDtcbn1cbm52Lm1vZGVscy5zY2F0dGVyQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHNjYXR0ZXIgICAgICA9IG52Lm1vZGVscy5zY2F0dGVyKClcbiAgICAsIHhBeGlzICAgICAgICA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIHlBeGlzICAgICAgICA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIGxlZ2VuZCAgICAgICA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICwgY29udHJvbHMgICAgID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgLCBkaXN0WCAgICAgICAgPSBudi5tb2RlbHMuZGlzdHJpYnV0aW9uKClcbiAgICAsIGRpc3RZICAgICAgICA9IG52Lm1vZGVscy5kaXN0cmlidXRpb24oKVxuICAgIDtcblxuICB2YXIgbWFyZ2luICAgICAgID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiA1MCwgbGVmdDogNzV9XG4gICAgLCB3aWR0aCAgICAgICAgPSBudWxsXG4gICAgLCBoZWlnaHQgICAgICAgPSBudWxsXG4gICAgLCBjb2xvciAgICAgICAgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICwgeCAgICAgICAgICAgID0gZDMuZmlzaGV5ZSA/IGQzLmZpc2hleWUuc2NhbGUoZDMuc2NhbGUubGluZWFyKS5kaXN0b3J0aW9uKDApIDogc2NhdHRlci54U2NhbGUoKVxuICAgICwgeSAgICAgICAgICAgID0gZDMuZmlzaGV5ZSA/IGQzLmZpc2hleWUuc2NhbGUoZDMuc2NhbGUubGluZWFyKS5kaXN0b3J0aW9uKDApIDogc2NhdHRlci55U2NhbGUoKVxuICAgICwgeFBhZGRpbmcgICAgID0gMFxuICAgICwgeVBhZGRpbmcgICAgID0gMFxuICAgICwgc2hvd0Rpc3RYICAgID0gZmFsc2VcbiAgICAsIHNob3dEaXN0WSAgICA9IGZhbHNlXG4gICAgLCBzaG93TGVnZW5kICAgPSB0cnVlXG4gICAgLCBzaG93WEF4aXMgICAgPSB0cnVlXG4gICAgLCBzaG93WUF4aXMgICAgPSB0cnVlXG4gICAgLCByaWdodEFsaWduWUF4aXMgPSBmYWxzZVxuICAgICwgc2hvd0NvbnRyb2xzID0gISFkMy5maXNoZXllXG4gICAgLCBmaXNoZXllICAgICAgPSAwXG4gICAgLCBwYXVzZUZpc2hleWUgPSBmYWxzZVxuICAgICwgdG9vbHRpcHMgICAgID0gdHJ1ZVxuICAgICwgdG9vbHRpcFggICAgID0gZnVuY3Rpb24oa2V5LCB4LCB5KSB7IHJldHVybiAnPHN0cm9uZz4nICsgeCArICc8L3N0cm9uZz4nIH1cbiAgICAsIHRvb2x0aXBZICAgICA9IGZ1bmN0aW9uKGtleSwgeCwgeSkgeyByZXR1cm4gJzxzdHJvbmc+JyArIHkgKyAnPC9zdHJvbmc+JyB9XG4gICAgLCB0b29sdGlwICAgICAgPSBudWxsXG4gICAgLCBzdGF0ZSA9IHt9XG4gICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgLCBkaXNwYXRjaCAgICAgPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnKVxuICAgICwgbm9EYXRhICAgICAgID0gXCJObyBEYXRhIEF2YWlsYWJsZS5cIlxuICAgICwgdHJhbnNpdGlvbkR1cmF0aW9uID0gMjUwXG4gICAgO1xuXG4gIHNjYXR0ZXJcbiAgICAueFNjYWxlKHgpXG4gICAgLnlTY2FsZSh5KVxuICAgIDtcbiAgeEF4aXNcbiAgICAub3JpZW50KCdib3R0b20nKVxuICAgIC50aWNrUGFkZGluZygxMClcbiAgICA7XG4gIHlBeGlzXG4gICAgLm9yaWVudCgocmlnaHRBbGlnbllBeGlzKSA/ICdyaWdodCcgOiAnbGVmdCcpXG4gICAgLnRpY2tQYWRkaW5nKDEwKVxuICAgIDtcbiAgZGlzdFhcbiAgICAuYXhpcygneCcpXG4gICAgO1xuICBkaXN0WVxuICAgIC5heGlzKCd5JylcbiAgICA7XG5cbiAgY29udHJvbHMudXBkYXRlU3RhdGUoZmFsc2UpO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciB4MCwgeTA7XG5cbiAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuICAgIC8vVE9ETzogbWFrZSB0b29sdGlwIHN0eWxlIGFuIG9wdGlvbiBiZXR3ZWVuIHNpbmdsZSBvciBkdWFsIG9uIGF4ZXMgKG1heWJlIG9uIGFsbCBjaGFydHMgd2l0aCBheGVzPylcblxuICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgbGVmdFggPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgdG9wWCA9IHkucmFuZ2UoKVswXSArIG1hcmdpbi50b3AgKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICBsZWZ0WSA9IHgucmFuZ2UoKVswXSArIG1hcmdpbi5sZWZ0ICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQgfHwgMCApLFxuICAgICAgICB0b3BZID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICB4VmFsID0geEF4aXMudGlja0Zvcm1hdCgpKHNjYXR0ZXIueCgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICB5VmFsID0geUF4aXMudGlja0Zvcm1hdCgpKHNjYXR0ZXIueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpO1xuXG4gICAgICBpZiggdG9vbHRpcFggIT0gbnVsbCApXG4gICAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0WCwgdG9wWF0sIHRvb2x0aXBYKGUuc2VyaWVzLmtleSwgeFZhbCwgeVZhbCwgZSwgY2hhcnQpLCAnbicsIDEsIG9mZnNldEVsZW1lbnQsICd4LW52dG9vbHRpcCcpO1xuICAgICAgaWYoIHRvb2x0aXBZICE9IG51bGwgKVxuICAgICAgICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdFksIHRvcFldLCB0b29sdGlwWShlLnNlcmllcy5rZXksIHhWYWwsIHlWYWwsIGUsIGNoYXJ0KSwgJ2UnLCAxLCBvZmZzZXRFbGVtZW50LCAneS1udnRvb2x0aXAnKTtcbiAgICAgIGlmKCB0b29sdGlwICE9IG51bGwgKVxuICAgICAgICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgdG9vbHRpcChlLnNlcmllcy5rZXksIHhWYWwsIHlWYWwsIGUsIGNoYXJ0KSwgZS52YWx1ZSA8IDAgPyAnbicgOiAncycsIG51bGwsIG9mZnNldEVsZW1lbnQpO1xuICB9O1xuXG4gIHZhciBjb250cm9sc0RhdGEgPSBbXG4gICAgeyBrZXk6ICdNYWduaWZ5JywgZGlzYWJsZWQ6IHRydWUgfVxuICBdO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHsgY29udGFpbmVyLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pLmNhbGwoY2hhcnQpOyB9O1xuICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgLy9zZXQgc3RhdGUuZGlzYWJsZWRcbiAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gRGlzcGxheSBub0RhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cblxuICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICB2YXIgbm9EYXRhVGV4dCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5kYXRhKFtub0RhdGFdKTtcblxuICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi1ub0RhdGEnKVxuICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAuYXR0cigneScsIG1hcmdpbi50b3AgKyBhdmFpbGFibGVIZWlnaHQgLyAyKVxuICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBTY2FsZXNcblxuICAgICAgeDAgPSB4MCB8fCB4O1xuICAgICAgeTAgPSB5MCB8fCB5O1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuXG4gICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1zY2F0dGVyQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1zY2F0dGVyQ2hhcnQgbnYtY2hhcnQtJyArIHNjYXR0ZXIuaWQoKSk7XG4gICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAvLyBiYWNrZ3JvdW5kIGZvciBwb2ludGVyIGV2ZW50c1xuICAgICAgZ0VudGVyLmFwcGVuZCgncmVjdCcpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtYmFja2dyb3VuZCcpO1xuXG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtc2NhdHRlcldyYXAnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1kaXN0V3JhcCcpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1jb250cm9sc1dyYXAnKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTGVnZW5kXG5cbiAgICAgIGlmIChzaG93TGVnZW5kKSB7XG4gICAgICAgIHZhciBsZWdlbmRXaWR0aCA9IChzaG93Q29udHJvbHMpID8gYXZhaWxhYmxlV2lkdGggLyAyIDogYXZhaWxhYmxlV2lkdGg7XG4gICAgICAgIGxlZ2VuZC53aWR0aChsZWdlbmRXaWR0aCk7XG5cbiAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdyYXAuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKGF2YWlsYWJsZVdpZHRoIC0gbGVnZW5kV2lkdGgpICsgJywnICsgKC1tYXJnaW4udG9wKSArJyknKTtcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gQ29udHJvbHNcblxuICAgICAgaWYgKHNob3dDb250cm9scykge1xuICAgICAgICBjb250cm9scy53aWR0aCgxODApLmNvbG9yKFsnIzQ0NCddKTtcbiAgICAgICAgZy5zZWxlY3QoJy5udi1jb250cm9sc1dyYXAnKVxuICAgICAgICAgICAgLmRhdHVtKGNvbnRyb2xzRGF0YSlcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJylcbiAgICAgICAgICAgIC5jYWxsKGNvbnRyb2xzKTtcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgIGlmIChyaWdodEFsaWduWUF4aXMpIHtcbiAgICAgICAgICBnLnNlbGVjdChcIi5udi15Lm52LWF4aXNcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBhdmFpbGFibGVXaWR0aCArIFwiLDApXCIpO1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTWFpbiBDaGFydCBDb21wb25lbnQocylcblxuICAgICAgc2NhdHRlclxuICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSk7XG5cbiAgICAgIGlmICh4UGFkZGluZyAhPT0gMClcbiAgICAgICAgc2NhdHRlci54RG9tYWluKG51bGwpO1xuXG4gICAgICBpZiAoeVBhZGRpbmcgIT09IDApXG4gICAgICAgIHNjYXR0ZXIueURvbWFpbihudWxsKTtcblxuICAgICAgd3JhcC5zZWxlY3QoJy5udi1zY2F0dGVyV3JhcCcpXG4gICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuICAgICAgICAgIC5jYWxsKHNjYXR0ZXIpO1xuXG4gICAgICAvL0FkanVzdCBmb3IgeCBhbmQgeSBwYWRkaW5nXG4gICAgICBpZiAoeFBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgdmFyIHhSYW5nZSA9IHguZG9tYWluKClbMV0gLSB4LmRvbWFpbigpWzBdO1xuICAgICAgICBzY2F0dGVyLnhEb21haW4oW3guZG9tYWluKClbMF0gLSAoeFBhZGRpbmcgKiB4UmFuZ2UpLCB4LmRvbWFpbigpWzFdICsgKHhQYWRkaW5nICogeFJhbmdlKV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoeVBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgdmFyIHlSYW5nZSA9IHkuZG9tYWluKClbMV0gLSB5LmRvbWFpbigpWzBdO1xuICAgICAgICBzY2F0dGVyLnlEb21haW4oW3kuZG9tYWluKClbMF0gLSAoeVBhZGRpbmcgKiB5UmFuZ2UpLCB5LmRvbWFpbigpWzFdICsgKHlQYWRkaW5nICogeVJhbmdlKV0pO1xuICAgICAgfVxuXG4gICAgICAvL09ubHkgbmVlZCB0byB1cGRhdGUgdGhlIHNjYXR0ZXIgYWdhaW4gaWYgeC95UGFkZGluZyBjaGFuZ2VkIHRoZSBkb21haW4uXG4gICAgICBpZiAoeVBhZGRpbmcgIT09IDAgfHwgeFBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1zY2F0dGVyV3JhcCcpXG4gICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpXG4gICAgICAgICAgICAuY2FsbChzY2F0dGVyKTtcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgQXhlc1xuICAgICAgaWYgKHNob3dYQXhpcykge1xuICAgICAgICB4QXhpc1xuICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAudGlja3MoIHhBeGlzLnRpY2tzKCkgJiYgeEF4aXMudGlja3MoKS5sZW5ndGggPyB4QXhpcy50aWNrcygpIDogYXZhaWxhYmxlV2lkdGggLyAxMDAgKVxuICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlSGVpZ2h0ICwgMCk7XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgICB9XG5cbiAgICAgIGlmIChzaG93WUF4aXMpIHtcbiAgICAgICAgeUF4aXNcbiAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgLnRpY2tzKCB5QXhpcy50aWNrcygpICYmIHlBeGlzLnRpY2tzKCkubGVuZ3RoID8geUF4aXMudGlja3MoKSA6IGF2YWlsYWJsZUhlaWdodCAvIDM2IClcbiAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICB9XG5cblxuICAgICAgaWYgKHNob3dEaXN0WCkge1xuICAgICAgICBkaXN0WFxuICAgICAgICAgICAgLmdldERhdGEoc2NhdHRlci54KCkpXG4gICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSk7XG4gICAgICAgIGdFbnRlci5zZWxlY3QoJy5udi1kaXN0V3JhcCcpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtZGlzdHJpYnV0aW9uWCcpO1xuICAgICAgICBnLnNlbGVjdCgnLm52LWRpc3RyaWJ1dGlvblgnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKVxuICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuICAgICAgICAgICAgLmNhbGwoZGlzdFgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvd0Rpc3RZKSB7XG4gICAgICAgIGRpc3RZXG4gICAgICAgICAgICAuZ2V0RGF0YShzY2F0dGVyLnkoKSlcbiAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSk7XG4gICAgICAgIGdFbnRlci5zZWxlY3QoJy5udi1kaXN0V3JhcCcpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtZGlzdHJpYnV0aW9uWScpO1xuICAgICAgICBnLnNlbGVjdCgnLm52LWRpc3RyaWJ1dGlvblknKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIFxuICAgICAgICAgICAgICAndHJhbnNsYXRlKCcgKyAocmlnaHRBbGlnbllBeGlzID8gYXZhaWxhYmxlV2lkdGggOiAtZGlzdFkuc2l6ZSgpICkgKyAnLDApJylcbiAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSlcbiAgICAgICAgICAgIC5jYWxsKGRpc3RZKTtcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cblxuICAgICAgaWYgKGQzLmZpc2hleWUpIHtcbiAgICAgICAgZy5zZWxlY3QoJy5udi1iYWNrZ3JvdW5kJylcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi1iYWNrZ3JvdW5kJykub24oJ21vdXNlbW92ZScsIHVwZGF0ZUZpc2hleWUpO1xuICAgICAgICBnLnNlbGVjdCgnLm52LWJhY2tncm91bmQnKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgcGF1c2VGaXNoZXllID0gIXBhdXNlRmlzaGV5ZTt9KTtcbiAgICAgICAgc2NhdHRlci5kaXNwYXRjaC5vbignZWxlbWVudENsaWNrLmZyZWV6ZUZpc2hleWUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBwYXVzZUZpc2hleWUgPSAhcGF1c2VGaXNoZXllO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGVGaXNoZXllKCkge1xuICAgICAgICBpZiAocGF1c2VGaXNoZXllKSB7XG4gICAgICAgICAgZy5zZWxlY3QoJy5udi1wb2ludC1wYXRocycpLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdhbGwnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBnLnNlbGVjdCgnLm52LXBvaW50LXBhdGhzJykuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnICk7XG5cbiAgICAgICAgdmFyIG1vdXNlID0gZDMubW91c2UodGhpcyk7XG4gICAgICAgIHguZGlzdG9ydGlvbihmaXNoZXllKS5mb2N1cyhtb3VzZVswXSk7XG4gICAgICAgIHkuZGlzdG9ydGlvbihmaXNoZXllKS5mb2N1cyhtb3VzZVsxXSk7XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi1zY2F0dGVyV3JhcCcpXG4gICAgICAgICAgICAuY2FsbChzY2F0dGVyKTtcblxuICAgICAgICBpZiAoc2hvd1hBeGlzKVxuICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJykuY2FsbCh4QXhpcyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc2hvd1lBeGlzKVxuICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJykuY2FsbCh5QXhpcyk7XG4gICAgICAgIFxuICAgICAgICBnLnNlbGVjdCgnLm52LWRpc3RyaWJ1dGlvblgnKVxuICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuICAgICAgICAgICAgLmNhbGwoZGlzdFgpO1xuICAgICAgICBnLnNlbGVjdCgnLm52LWRpc3RyaWJ1dGlvblknKVxuICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuICAgICAgICAgICAgLmNhbGwoZGlzdFkpO1xuICAgICAgfVxuXG5cblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgY29udHJvbHMuZGlzcGF0Y2gub24oJ2xlZ2VuZENsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgIGQuZGlzYWJsZWQgPSAhZC5kaXNhYmxlZDtcblxuICAgICAgICBmaXNoZXllID0gZC5kaXNhYmxlZCA/IDAgOiAyLjU7XG4gICAgICAgIGcuc2VsZWN0KCcubnYtYmFja2dyb3VuZCcpIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCBkLmRpc2FibGVkID8gJ25vbmUnIDogJ2FsbCcpO1xuICAgICAgICBnLnNlbGVjdCgnLm52LXBvaW50LXBhdGhzJykuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgZC5kaXNhYmxlZCA/ICdhbGwnIDogJ25vbmUnICk7XG5cbiAgICAgICAgaWYgKGQuZGlzYWJsZWQpIHtcbiAgICAgICAgICB4LmRpc3RvcnRpb24oZmlzaGV5ZSkuZm9jdXMoMCk7XG4gICAgICAgICAgeS5kaXN0b3J0aW9uKGZpc2hleWUpLmZvY3VzKDApO1xuXG4gICAgICAgICAgZy5zZWxlY3QoJy5udi1zY2F0dGVyV3JhcCcpLmNhbGwoc2NhdHRlcik7XG4gICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKS5jYWxsKHhBeGlzKTtcbiAgICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpLmNhbGwoeUF4aXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdXNlRmlzaGV5ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgIHN0YXRlLmRpc2FibGVkID0gbmV3U3RhdGUuZGlzYWJsZWQ7XG4gICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgc2NhdHRlci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkMy5zZWxlY3QoJy5udi1jaGFydC0nICsgc2NhdHRlci5pZCgpICsgJyAubnYtc2VyaWVzLScgKyBlLnNlcmllc0luZGV4ICsgJyAubnYtZGlzdHgtJyArIGUucG9pbnRJbmRleClcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZS5wb3NbMV0gLSBhdmFpbGFibGVIZWlnaHQ7fSk7XG4gICAgICAgIGQzLnNlbGVjdCgnLm52LWNoYXJ0LScgKyBzY2F0dGVyLmlkKCkgKyAnIC5udi1zZXJpZXMtJyArIGUuc2VyaWVzSW5kZXggKyAnIC5udi1kaXN0eS0nICsgZS5wb2ludEluZGV4KVxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgZS5wb3NbMF0gKyBkaXN0WC5zaXplKCkpO1xuXG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBjaGFydCBmcm9tIGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0byBldmVudCBoYW5kbGVyXG4gICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgICAgLy9zdG9yZSBvbGQgc2NhbGVzIGZvciB1c2UgaW4gdHJhbnNpdGlvbnMgb24gdXBkYXRlXG4gICAgICB4MCA9IHguY29weSgpO1xuICAgICAgeTAgPSB5LmNvcHkoKTtcblxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBzY2F0dGVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcblxuICAgIGQzLnNlbGVjdCgnLm52LWNoYXJ0LScgKyBzY2F0dGVyLmlkKCkgKyAnIC5udi1zZXJpZXMtJyArIGUuc2VyaWVzSW5kZXggKyAnIC5udi1kaXN0eC0nICsgZS5wb2ludEluZGV4KVxuICAgICAgICAuYXR0cigneTEnLCAwKTtcbiAgICBkMy5zZWxlY3QoJy5udi1jaGFydC0nICsgc2NhdHRlci5pZCgpICsgJyAubnYtc2VyaWVzLScgKyBlLnNlcmllc0luZGV4ICsgJyAubnYtZGlzdHktJyArIGUucG9pbnRJbmRleClcbiAgICAgICAgLmF0dHIoJ3gyJywgZGlzdFkuc2l6ZSgpKTtcbiAgfSk7XG4gIGRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gIH0pO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gIGNoYXJ0LnNjYXR0ZXIgPSBzY2F0dGVyO1xuICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gIGNoYXJ0LmNvbnRyb2xzID0gY29udHJvbHM7XG4gIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gIGNoYXJ0LnlBeGlzID0geUF4aXM7XG4gIGNoYXJ0LmRpc3RYID0gZGlzdFg7XG4gIGNoYXJ0LmRpc3RZID0gZGlzdFk7XG5cbiAgZDMucmViaW5kKGNoYXJ0LCBzY2F0dGVyLCAnaWQnLCAnaW50ZXJhY3RpdmUnLCAncG9pbnRBY3RpdmUnLCAneCcsICd5JywgJ3NoYXBlJywgJ3NpemUnLCAneFNjYWxlJywgJ3lTY2FsZScsICd6U2NhbGUnLCAneERvbWFpbicsICd5RG9tYWluJywgJ3hSYW5nZScsICd5UmFuZ2UnLCAnc2l6ZURvbWFpbicsICdzaXplUmFuZ2UnLCAnZm9yY2VYJywgJ2ZvcmNlWScsICdmb3JjZVNpemUnLCAnY2xpcFZvcm9ub2knLCAnY2xpcFJhZGl1cycsICd1c2VWb3Jvbm9pJyk7XG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcbiAgXG4gIGNoYXJ0Lm1hcmdpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJnaW47XG4gICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICBtYXJnaW4ucmlnaHQgID0gdHlwZW9mIF8ucmlnaHQgICE9ICd1bmRlZmluZWQnID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgbWFyZ2luLmJvdHRvbSA9IHR5cGVvZiBfLmJvdHRvbSAhPSAndW5kZWZpbmVkJyA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQud2lkdGggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XG4gICAgd2lkdGggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5oZWlnaHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xuICAgIGhlaWdodCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICBkaXN0WC5jb2xvcihjb2xvcik7XG4gICAgZGlzdFkuY29sb3IoY29sb3IpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93RGlzdFggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd0Rpc3RYO1xuICAgIHNob3dEaXN0WCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dEaXN0WSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93RGlzdFk7XG4gICAgc2hvd0Rpc3RZID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd0NvbnRyb2xzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dDb250cm9scztcbiAgICBzaG93Q29udHJvbHMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93TGVnZW5kID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dMZWdlbmQ7XG4gICAgc2hvd0xlZ2VuZCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dYQXhpcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93WEF4aXM7XG4gICAgc2hvd1hBeGlzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd1lBeGlzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dZQXhpcztcbiAgICBzaG93WUF4aXMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5yaWdodEFsaWduWUF4aXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByaWdodEFsaWduWUF4aXM7XG4gICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuXG4gIGNoYXJ0LmZpc2hleWUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZmlzaGV5ZTtcbiAgICBmaXNoZXllID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueFBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geFBhZGRpbmc7XG4gICAgeFBhZGRpbmcgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55UGFkZGluZyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5UGFkZGluZztcbiAgICB5UGFkZGluZyA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXBzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXBzO1xuICAgIHRvb2x0aXBzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcDtcbiAgICB0b29sdGlwID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcFhDb250ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXBYO1xuICAgIHRvb2x0aXBYID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcFlDb250ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXBZO1xuICAgIHRvb2x0aXBZID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhdGU7XG4gICAgc3RhdGUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5kZWZhdWx0U3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGVmYXVsdFN0YXRlO1xuICAgIGRlZmF1bHRTdGF0ZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuICBcbiAgY2hhcnQubm9EYXRhID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vRGF0YTtcbiAgICBub0RhdGEgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50cmFuc2l0aW9uRHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICByZXR1cm4gY2hhcnQ7XG59XG5cbm52Lm1vZGVscy5zY2F0dGVyUGx1c0xpbmVDaGFydCA9IGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgc2NhdHRlciAgICAgID0gbnYubW9kZWxzLnNjYXR0ZXIoKVxuICAgICwgeEF4aXMgICAgICAgID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICwgeUF4aXMgICAgICAgID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICwgbGVnZW5kICAgICAgID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgLCBjb250cm9scyAgICAgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAsIGRpc3RYICAgICAgICA9IG52Lm1vZGVscy5kaXN0cmlidXRpb24oKVxuICAgICwgZGlzdFkgICAgICAgID0gbnYubW9kZWxzLmRpc3RyaWJ1dGlvbigpXG4gICAgO1xuXG4gIHZhciBtYXJnaW4gICAgICAgPSB7dG9wOiAzMCwgcmlnaHQ6IDIwLCBib3R0b206IDUwLCBsZWZ0OiA3NX1cbiAgICAsIHdpZHRoICAgICAgICA9IG51bGxcbiAgICAsIGhlaWdodCAgICAgICA9IG51bGxcbiAgICAsIGNvbG9yICAgICAgICA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgLCB4ICAgICAgICAgICAgPSBkMy5maXNoZXllID8gZDMuZmlzaGV5ZS5zY2FsZShkMy5zY2FsZS5saW5lYXIpLmRpc3RvcnRpb24oMCkgOiBzY2F0dGVyLnhTY2FsZSgpXG4gICAgLCB5ICAgICAgICAgICAgPSBkMy5maXNoZXllID8gZDMuZmlzaGV5ZS5zY2FsZShkMy5zY2FsZS5saW5lYXIpLmRpc3RvcnRpb24oMCkgOiBzY2F0dGVyLnlTY2FsZSgpXG4gICAgLCBzaG93RGlzdFggICAgPSBmYWxzZVxuICAgICwgc2hvd0Rpc3RZICAgID0gZmFsc2VcbiAgICAsIHNob3dMZWdlbmQgICA9IHRydWVcbiAgICAsIHNob3dYQXhpcyAgICA9IHRydWVcbiAgICAsIHNob3dZQXhpcyAgICA9IHRydWVcbiAgICAsIHJpZ2h0QWxpZ25ZQXhpcyA9IGZhbHNlXG4gICAgLCBzaG93Q29udHJvbHMgPSAhIWQzLmZpc2hleWVcbiAgICAsIGZpc2hleWUgICAgICA9IDBcbiAgICAsIHBhdXNlRmlzaGV5ZSA9IGZhbHNlXG4gICAgLCB0b29sdGlwcyAgICAgPSB0cnVlXG4gICAgLCB0b29sdGlwWCAgICAgPSBmdW5jdGlvbihrZXksIHgsIHkpIHsgcmV0dXJuICc8c3Ryb25nPicgKyB4ICsgJzwvc3Ryb25nPicgfVxuICAgICwgdG9vbHRpcFkgICAgID0gZnVuY3Rpb24oa2V5LCB4LCB5KSB7IHJldHVybiAnPHN0cm9uZz4nICsgeSArICc8L3N0cm9uZz4nIH1cbiAgICAsIHRvb2x0aXAgICAgICA9IGZ1bmN0aW9uKGtleSwgeCwgeSwgZGF0ZSkgeyByZXR1cm4gJzxoMz4nICsga2V5ICsgJzwvaDM+JyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJzxwPicgKyBkYXRlICsgJzwvcD4nIH1cbiAgICAsIHN0YXRlID0ge31cbiAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJylcbiAgICAsIG5vRGF0YSAgICAgICA9IFwiTm8gRGF0YSBBdmFpbGFibGUuXCJcbiAgICAsIHRyYW5zaXRpb25EdXJhdGlvbiA9IDI1MFxuICAgIDtcblxuICBzY2F0dGVyXG4gICAgLnhTY2FsZSh4KVxuICAgIC55U2NhbGUoeSlcbiAgICA7XG4gIHhBeGlzXG4gICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAudGlja1BhZGRpbmcoMTApXG4gICAgO1xuICB5QXhpc1xuICAgIC5vcmllbnQoKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgIC50aWNrUGFkZGluZygxMClcbiAgICA7XG4gIGRpc3RYXG4gICAgLmF4aXMoJ3gnKVxuICAgIDtcbiAgZGlzdFlcbiAgICAuYXhpcygneScpXG4gICAgO1xuICBcbiAgY29udHJvbHMudXBkYXRlU3RhdGUoZmFsc2UpO1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgeDAsIHkwO1xuXG4gIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICAvL1RPRE86IG1ha2UgdG9vbHRpcCBzdHlsZSBhbiBvcHRpb24gYmV0d2VlbiBzaW5nbGUgb3IgZHVhbCBvbiBheGVzIChtYXliZSBvbiBhbGwgY2hhcnRzIHdpdGggYXhlcz8pXG5cbiAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQgfHwgMCApLFxuICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgIGxlZnRYID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgIHRvcFggPSB5LnJhbmdlKClbMF0gKyBtYXJnaW4udG9wICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgbGVmdFkgPSB4LnJhbmdlKClbMF0gKyBtYXJnaW4ubGVmdCArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgdG9wWSA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgeFZhbCA9IHhBeGlzLnRpY2tGb3JtYXQoKShzY2F0dGVyLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgeVZhbCA9IHlBeGlzLnRpY2tGb3JtYXQoKShzY2F0dGVyLnkoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKTtcblxuICAgICAgaWYoIHRvb2x0aXBYICE9IG51bGwgKVxuICAgICAgICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdFgsIHRvcFhdLCB0b29sdGlwWChlLnNlcmllcy5rZXksIHhWYWwsIHlWYWwsIGUsIGNoYXJ0KSwgJ24nLCAxLCBvZmZzZXRFbGVtZW50LCAneC1udnRvb2x0aXAnKTtcbiAgICAgIGlmKCB0b29sdGlwWSAhPSBudWxsIClcbiAgICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnRZLCB0b3BZXSwgdG9vbHRpcFkoZS5zZXJpZXMua2V5LCB4VmFsLCB5VmFsLCBlLCBjaGFydCksICdlJywgMSwgb2Zmc2V0RWxlbWVudCwgJ3ktbnZ0b29sdGlwJyk7XG4gICAgICBpZiggdG9vbHRpcCAhPSBudWxsIClcbiAgICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIHRvb2x0aXAoZS5zZXJpZXMua2V5LCB4VmFsLCB5VmFsLCBlLnBvaW50LnRvb2x0aXAsIGUsIGNoYXJ0KSwgZS52YWx1ZSA8IDAgPyAnbicgOiAncycsIG51bGwsIG9mZnNldEVsZW1lbnQpO1xuICB9O1xuXG4gIHZhciBjb250cm9sc0RhdGEgPSBbXG4gICAgeyBrZXk6ICdNYWduaWZ5JywgZGlzYWJsZWQ6IHRydWUgfVxuICBdO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHsgY29udGFpbmVyLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pLmNhbGwoY2hhcnQpOyB9O1xuICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgLy9zZXQgc3RhdGUuZGlzYWJsZWRcbiAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gRGlzcGxheSBub0RhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cblxuICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICB2YXIgbm9EYXRhVGV4dCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5kYXRhKFtub0RhdGFdKTtcblxuICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi1ub0RhdGEnKVxuICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAuYXR0cigneScsIG1hcmdpbi50b3AgKyBhdmFpbGFibGVIZWlnaHQgLyAyKVxuICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBTY2FsZXNcblxuICAgICAgeCA9IHNjYXR0ZXIueFNjYWxlKCk7XG4gICAgICB5ID0gc2NhdHRlci55U2NhbGUoKTtcblxuICAgICAgeDAgPSB4MCB8fCB4O1xuICAgICAgeTAgPSB5MCB8fCB5O1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuXG4gICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1zY2F0dGVyQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1zY2F0dGVyQ2hhcnQgbnYtY2hhcnQtJyArIHNjYXR0ZXIuaWQoKSk7XG4gICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpXG5cbiAgICAgIC8vIGJhY2tncm91bmQgZm9yIHBvaW50ZXIgZXZlbnRzXG4gICAgICBnRW50ZXIuYXBwZW5kKCdyZWN0JykuYXR0cignY2xhc3MnLCAnbnZkMyBudi1iYWNrZ3JvdW5kJykuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLFwibm9uZVwiKTtcblxuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkgbnYtYXhpcycpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXNjYXR0ZXJXcmFwJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcmVncmVzc2lvbkxpbmVzV3JhcCcpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWRpc3RXcmFwJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWNvbnRyb2xzV3JhcCcpO1xuXG4gICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgIGlmIChyaWdodEFsaWduWUF4aXMpIHtcbiAgICAgICAgICBnLnNlbGVjdChcIi5udi15Lm52LWF4aXNcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBhdmFpbGFibGVXaWR0aCArIFwiLDApXCIpO1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBMZWdlbmRcblxuICAgICAgaWYgKHNob3dMZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLndpZHRoKCBhdmFpbGFibGVXaWR0aCAvIDIgKTtcblxuICAgICAgICB3cmFwLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAuY2FsbChsZWdlbmQpO1xuXG4gICAgICAgIGlmICggbWFyZ2luLnRvcCAhPSBsZWdlbmQuaGVpZ2h0KCkpIHtcbiAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICB9XG5cbiAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoYXZhaWxhYmxlV2lkdGggLyAyKSArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIENvbnRyb2xzXG5cbiAgICAgIGlmIChzaG93Q29udHJvbHMpIHtcbiAgICAgICAgY29udHJvbHMud2lkdGgoMTgwKS5jb2xvcihbJyM0NDQnXSk7XG4gICAgICAgIGcuc2VsZWN0KCcubnYtY29udHJvbHNXcmFwJylcbiAgICAgICAgICAgIC5kYXR1bShjb250cm9sc0RhdGEpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoLW1hcmdpbi50b3ApICsnKScpXG4gICAgICAgICAgICAuY2FsbChjb250cm9scyk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG5cbiAgICAgIHNjYXR0ZXJcbiAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgfSkpXG5cbiAgICAgIHdyYXAuc2VsZWN0KCcubnYtc2NhdHRlcldyYXAnKVxuICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSlcbiAgICAgICAgICAuY2FsbChzY2F0dGVyKTtcblxuICAgICAgd3JhcC5zZWxlY3QoJy5udi1yZWdyZXNzaW9uTGluZXNXcmFwJylcbiAgICAgICAgICAuYXR0cignY2xpcC1wYXRoJywgJ3VybCgjbnYtZWRnZS1jbGlwLScgKyBzY2F0dGVyLmlkKCkgKyAnKScpO1xuXG4gICAgICB2YXIgcmVnV3JhcCA9IHdyYXAuc2VsZWN0KCcubnYtcmVncmVzc2lvbkxpbmVzV3JhcCcpLnNlbGVjdEFsbCgnLm52LXJlZ0xpbmVzJylcbiAgICAgICAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7cmV0dXJuIGQgfSk7XG4gICAgICBcbiAgICAgIHJlZ1dyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1yZWdMaW5lcycpO1xuXG4gICAgICB2YXIgcmVnTGluZSA9IHJlZ1dyYXAuc2VsZWN0QWxsKCcubnYtcmVnTGluZScpLmRhdGEoZnVuY3Rpb24oZCl7cmV0dXJuIFtkXX0pO1xuICAgICAgdmFyIHJlZ0xpbmVFbnRlciA9IHJlZ0xpbmUuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJykuYXR0cignY2xhc3MnLCAnbnYtcmVnTGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAwKTtcblxuICAgICAgcmVnTGluZVxuICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAuYXR0cigneDEnLCB4LnJhbmdlKClbMF0pXG4gICAgICAgICAgLmF0dHIoJ3gyJywgeC5yYW5nZSgpWzFdKVxuICAgICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uKGQsaSkge3JldHVybiB5KHguZG9tYWluKClbMF0gKiBkLnNsb3BlICsgZC5pbnRlcmNlcHQpIH0pXG4gICAgICAgICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiB5KHguZG9tYWluKClbMV0gKiBkLnNsb3BlICsgZC5pbnRlcmNlcHQpIH0pXG4gICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGksaikgeyByZXR1cm4gY29sb3IoZCxqKSB9KVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIHJldHVybiAoZC5kaXNhYmxlZCB8fCB0eXBlb2YgZC5zbG9wZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGQuaW50ZXJjZXB0ID09PSAndW5kZWZpbmVkJykgPyAwIDogMSBcbiAgICAgICAgICB9KTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgQXhlc1xuXG4gICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgIHhBeGlzXG4gICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgIC50aWNrcyggeEF4aXMudGlja3MoKSA/IHhBeGlzLnRpY2tzKCkgOiBhdmFpbGFibGVXaWR0aCAvIDEwMCApXG4gICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVIZWlnaHQgLCAwKTtcblxuICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB5LnJhbmdlKClbMF0gKyAnKScpXG4gICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG93WUF4aXMpIHtcbiAgICAgICAgeUF4aXNcbiAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgLnRpY2tzKCB5QXhpcy50aWNrcygpID8geUF4aXMudGlja3MoKSA6IGF2YWlsYWJsZUhlaWdodCAvIDM2IClcbiAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICB9XG5cblxuICAgICAgaWYgKHNob3dEaXN0WCkge1xuICAgICAgICBkaXN0WFxuICAgICAgICAgICAgLmdldERhdGEoc2NhdHRlci54KCkpXG4gICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSk7XG4gICAgICAgIGdFbnRlci5zZWxlY3QoJy5udi1kaXN0V3JhcCcpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtZGlzdHJpYnV0aW9uWCcpO1xuICAgICAgICBnLnNlbGVjdCgnLm52LWRpc3RyaWJ1dGlvblgnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKVxuICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuICAgICAgICAgICAgLmNhbGwoZGlzdFgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvd0Rpc3RZKSB7XG4gICAgICAgIGRpc3RZXG4gICAgICAgICAgICAuZ2V0RGF0YShzY2F0dGVyLnkoKSlcbiAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSk7XG4gICAgICAgIGdFbnRlci5zZWxlY3QoJy5udi1kaXN0V3JhcCcpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtZGlzdHJpYnV0aW9uWScpO1xuICAgICAgICBnLnNlbGVjdCgnLm52LWRpc3RyaWJ1dGlvblknKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChyaWdodEFsaWduWUF4aXMgPyBhdmFpbGFibGVXaWR0aCA6IC1kaXN0WS5zaXplKCkgKSArICcsMCknKVxuICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuICAgICAgICAgICAgLmNhbGwoZGlzdFkpO1xuICAgICAgfVxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblxuXG4gICAgICBpZiAoZDMuZmlzaGV5ZSkge1xuICAgICAgICBnLnNlbGVjdCgnLm52LWJhY2tncm91bmQnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgO1xuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtYmFja2dyb3VuZCcpLm9uKCdtb3VzZW1vdmUnLCB1cGRhdGVGaXNoZXllKTtcbiAgICAgICAgZy5zZWxlY3QoJy5udi1iYWNrZ3JvdW5kJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IHBhdXNlRmlzaGV5ZSA9ICFwYXVzZUZpc2hleWU7fSk7XG4gICAgICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRDbGljay5mcmVlemVGaXNoZXllJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcGF1c2VGaXNoZXllID0gIXBhdXNlRmlzaGV5ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlRmlzaGV5ZSgpIHtcbiAgICAgICAgaWYgKHBhdXNlRmlzaGV5ZSkge1xuICAgICAgICAgIGcuc2VsZWN0KCcubnYtcG9pbnQtcGF0aHMnKS5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnYWxsJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi1wb2ludC1wYXRocycpLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyApO1xuXG4gICAgICAgIHZhciBtb3VzZSA9IGQzLm1vdXNlKHRoaXMpO1xuICAgICAgICB4LmRpc3RvcnRpb24oZmlzaGV5ZSkuZm9jdXMobW91c2VbMF0pO1xuICAgICAgICB5LmRpc3RvcnRpb24oZmlzaGV5ZSkuZm9jdXMobW91c2VbMV0pO1xuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtc2NhdHRlcldyYXAnKVxuICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuICAgICAgICAgICAgLmNhbGwoc2NhdHRlcik7XG5cbiAgICAgICAgaWYgKHNob3dYQXhpcylcbiAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLmNhbGwoeEF4aXMpO1xuXG4gICAgICAgIGlmIChzaG93WUF4aXMpXG4gICAgICAgICAgZy5zZWxlY3QoJy5udi15Lm52LWF4aXMnKS5jYWxsKHlBeGlzKTtcbiAgICAgICAgXG4gICAgICAgIGcuc2VsZWN0KCcubnYtZGlzdHJpYnV0aW9uWCcpXG4gICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpXG4gICAgICAgICAgICAuY2FsbChkaXN0WCk7XG4gICAgICAgIGcuc2VsZWN0KCcubnYtZGlzdHJpYnV0aW9uWScpXG4gICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpXG4gICAgICAgICAgICAuY2FsbChkaXN0WSk7XG4gICAgICB9XG5cblxuXG4gICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICBjb250cm9scy5kaXNwYXRjaC5vbignbGVnZW5kQ2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgZC5kaXNhYmxlZCA9ICFkLmRpc2FibGVkO1xuXG4gICAgICAgIGZpc2hleWUgPSBkLmRpc2FibGVkID8gMCA6IDIuNTtcbiAgICAgICAgZy5zZWxlY3QoJy5udi1iYWNrZ3JvdW5kJykgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsIGQuZGlzYWJsZWQgPyAnbm9uZScgOiAnYWxsJyk7XG4gICAgICAgIGcuc2VsZWN0KCcubnYtcG9pbnQtcGF0aHMnKS5zdHlsZSgncG9pbnRlci1ldmVudHMnLCBkLmRpc2FibGVkID8gJ2FsbCcgOiAnbm9uZScgKTtcblxuICAgICAgICBpZiAoZC5kaXNhYmxlZCkge1xuICAgICAgICAgIHguZGlzdG9ydGlvbihmaXNoZXllKS5mb2N1cygwKTtcbiAgICAgICAgICB5LmRpc3RvcnRpb24oZmlzaGV5ZSkuZm9jdXMoMCk7XG5cbiAgICAgICAgICBnLnNlbGVjdCgnLm52LXNjYXR0ZXJXcmFwJykuY2FsbChzY2F0dGVyKTtcbiAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLmNhbGwoeEF4aXMpO1xuICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJykuY2FsbCh5QXhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF1c2VGaXNoZXllID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHsgXG4gICAgICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuXG4gICAgICBzY2F0dGVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGQzLnNlbGVjdCgnLm52LWNoYXJ0LScgKyBzY2F0dGVyLmlkKCkgKyAnIC5udi1zZXJpZXMtJyArIGUuc2VyaWVzSW5kZXggKyAnIC5udi1kaXN0eC0nICsgZS5wb2ludEluZGV4KVxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgZS5wb3NbMV0gLSBhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgICBkMy5zZWxlY3QoJy5udi1jaGFydC0nICsgc2NhdHRlci5pZCgpICsgJyAubnYtc2VyaWVzLScgKyBlLnNlcmllc0luZGV4ICsgJyAubnYtZGlzdHktJyArIGUucG9pbnRJbmRleClcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIGUucG9zWzBdICsgZGlzdFguc2l6ZSgpKTtcblxuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgICAgIH0pO1xuXG4gICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgc2hvd1Rvb2x0aXAoZSwgdGhhdC5wYXJlbnROb2RlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxuICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IGUuZGlzYWJsZWRbaV07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgICAgIC8vc3RvcmUgb2xkIHNjYWxlcyBmb3IgdXNlIGluIHRyYW5zaXRpb25zIG9uIHVwZGF0ZVxuICAgICAgeDAgPSB4LmNvcHkoKTtcbiAgICAgIHkwID0geS5jb3B5KCk7XG5cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgc2NhdHRlci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG5cbiAgICBkMy5zZWxlY3QoJy5udi1jaGFydC0nICsgc2NhdHRlci5pZCgpICsgJyAubnYtc2VyaWVzLScgKyBlLnNlcmllc0luZGV4ICsgJyAubnYtZGlzdHgtJyArIGUucG9pbnRJbmRleClcbiAgICAgICAgLmF0dHIoJ3kxJywgMCk7XG4gICAgZDMuc2VsZWN0KCcubnYtY2hhcnQtJyArIHNjYXR0ZXIuaWQoKSArICcgLm52LXNlcmllcy0nICsgZS5zZXJpZXNJbmRleCArICcgLm52LWRpc3R5LScgKyBlLnBvaW50SW5kZXgpXG4gICAgICAgIC5hdHRyKCd4MicsIGRpc3RZLnNpemUoKSk7XG4gIH0pO1xuICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICB9KTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICBjaGFydC5zY2F0dGVyID0gc2NhdHRlcjtcbiAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICBjaGFydC5jb250cm9scyA9IGNvbnRyb2xzO1xuICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICBjaGFydC55QXhpcyA9IHlBeGlzO1xuICBjaGFydC5kaXN0WCA9IGRpc3RYO1xuICBjaGFydC5kaXN0WSA9IGRpc3RZO1xuXG4gIGQzLnJlYmluZChjaGFydCwgc2NhdHRlciwgJ2lkJywgJ2ludGVyYWN0aXZlJywgJ3BvaW50QWN0aXZlJywgJ3gnLCAneScsICdzaGFwZScsICdzaXplJywgJ3hTY2FsZScsICd5U2NhbGUnLCAnelNjYWxlJywgJ3hEb21haW4nLCAneURvbWFpbicsICd4UmFuZ2UnLCAneVJhbmdlJywgJ3NpemVEb21haW4nLCAnc2l6ZVJhbmdlJywgJ2ZvcmNlWCcsICdmb3JjZVknLCAnZm9yY2VTaXplJywgJ2NsaXBWb3Jvbm9pJywgJ2NsaXBSYWRpdXMnLCAndXNlVm9yb25vaScpO1xuXG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcbiAgXG4gIGNoYXJ0Lm1hcmdpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJnaW47XG4gICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICBtYXJnaW4ucmlnaHQgID0gdHlwZW9mIF8ucmlnaHQgICE9ICd1bmRlZmluZWQnID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgbWFyZ2luLmJvdHRvbSA9IHR5cGVvZiBfLmJvdHRvbSAhPSAndW5kZWZpbmVkJyA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQud2lkdGggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XG4gICAgd2lkdGggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5oZWlnaHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xuICAgIGhlaWdodCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICBkaXN0WC5jb2xvcihjb2xvcik7XG4gICAgZGlzdFkuY29sb3IoY29sb3IpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93RGlzdFggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd0Rpc3RYO1xuICAgIHNob3dEaXN0WCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dEaXN0WSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93RGlzdFk7XG4gICAgc2hvd0Rpc3RZID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd0NvbnRyb2xzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dDb250cm9scztcbiAgICBzaG93Q29udHJvbHMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93TGVnZW5kID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dMZWdlbmQ7XG4gICAgc2hvd0xlZ2VuZCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dYQXhpcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93WEF4aXM7XG4gICAgc2hvd1hBeGlzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd1lBeGlzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dZQXhpcztcbiAgICBzaG93WUF4aXMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5yaWdodEFsaWduWUF4aXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByaWdodEFsaWduWUF4aXM7XG4gICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5maXNoZXllID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZpc2hleWU7XG4gICAgZmlzaGV5ZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXBzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXBzO1xuICAgIHRvb2x0aXBzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcDtcbiAgICB0b29sdGlwID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcFhDb250ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXBYO1xuICAgIHRvb2x0aXBYID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcFlDb250ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXBZO1xuICAgIHRvb2x0aXBZID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhdGU7XG4gICAgc3RhdGUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5kZWZhdWx0U3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGVmYXVsdFN0YXRlO1xuICAgIGRlZmF1bHRTdGF0ZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0Lm5vRGF0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub0RhdGE7XG4gICAgbm9EYXRhID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudHJhbnNpdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgcmV0dXJuIGNoYXJ0O1xufVxuXG5udi5tb2RlbHMuc3BhcmtsaW5lID0gZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBtYXJnaW4gPSB7dG9wOiAyLCByaWdodDogMCwgYm90dG9tOiAyLCBsZWZ0OiAwfVxuICAgICwgd2lkdGggPSA0MDBcbiAgICAsIGhlaWdodCA9IDMyXG4gICAgLCBhbmltYXRlID0gdHJ1ZVxuICAgICwgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgLCB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICwgZ2V0WSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9XG4gICAgLCBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKFsnIzAwMCddKVxuICAgICwgeERvbWFpblxuICAgICwgeURvbWFpblxuICAgICwgeFJhbmdlXG4gICAgLCB5UmFuZ2VcbiAgICA7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBTY2FsZXNcblxuICAgICAgeCAgIC5kb21haW4oeERvbWFpbiB8fCBkMy5leHRlbnQoZGF0YSwgZ2V0WCApKVxuICAgICAgICAgIC5yYW5nZSh4UmFuZ2UgfHwgWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgIHkgICAuZG9tYWluKHlEb21haW4gfHwgZDMuZXh0ZW50KGRhdGEsIGdldFkgKSlcbiAgICAgICAgICAucmFuZ2UoeVJhbmdlIHx8IFthdmFpbGFibGVIZWlnaHQsIDBdKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcblxuICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtc3BhcmtsaW5lJykuZGF0YShbZGF0YV0pO1xuICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtc3BhcmtsaW5lJyk7XG4gICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJylcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICB2YXIgcGF0aHMgPSB3cmFwLnNlbGVjdEFsbCgncGF0aCcpXG4gICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gW2RdIH0pO1xuICAgICAgcGF0aHMuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKTtcbiAgICAgIHBhdGhzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgIHBhdGhzXG4gICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSkgfSlcbiAgICAgICAgICAuYXR0cignZCcsIGQzLnN2Zy5saW5lKClcbiAgICAgICAgICAgIC54KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geChnZXRYKGQsaSkpIH0pXG4gICAgICAgICAgICAueShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHkoZ2V0WShkLGkpKSB9KVxuICAgICAgICAgICk7XG5cblxuICAgICAgLy8gVE9ETzogQWRkIENVUlJFTlQgZGF0YSBwb2ludCAoTmVlZCBNaW4sIE1hYywgQ3VycmVudCAvIE1vc3QgcmVjZW50KVxuICAgICAgdmFyIHBvaW50cyA9IHdyYXAuc2VsZWN0QWxsKCdjaXJjbGUubnYtcG9pbnQnKVxuICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgdmFyIHlWYWx1ZXMgPSBkYXRhLm1hcChmdW5jdGlvbihkLCBpKSB7IHJldHVybiBnZXRZKGQsaSk7IH0pO1xuICAgICAgICAgICAgICBmdW5jdGlvbiBwb2ludEluZGV4KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcblx0ICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBvaW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbWF4UG9pbnQgPSBwb2ludEluZGV4KHlWYWx1ZXMubGFzdEluZGV4T2YoeS5kb21haW4oKVsxXSkpLFxuICAgICAgICAgICAgICAgICAgbWluUG9pbnQgPSBwb2ludEluZGV4KHlWYWx1ZXMuaW5kZXhPZih5LmRvbWFpbigpWzBdKSksXG4gICAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnQgPSBwb2ludEluZGV4KHlWYWx1ZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIHJldHVybiBbbWluUG9pbnQsIG1heFBvaW50LCBjdXJyZW50UG9pbnRdLmZpbHRlcihmdW5jdGlvbiAoZCkge3JldHVybiBkICE9IG51bGw7fSk7XG4gICAgICAgICAgfSk7XG4gICAgICBwb2ludHMuZW50ZXIoKS5hcHBlbmQoJ2NpcmNsZScpO1xuICAgICAgcG9pbnRzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgIHBvaW50c1xuICAgICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geChnZXRYKGQsZC5wb2ludEluZGV4KSkgfSlcbiAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHkoZ2V0WShkLGQucG9pbnRJbmRleCkpIH0pXG4gICAgICAgICAgLmF0dHIoJ3InLCAyKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFgoZCwgZC5wb2ludEluZGV4KSA9PSB4LmRvbWFpbigpWzFdID8gJ252LXBvaW50IG52LWN1cnJlbnRWYWx1ZScgOlxuICAgICAgICAgICAgICAgICAgIGdldFkoZCwgZC5wb2ludEluZGV4KSA9PSB5LmRvbWFpbigpWzBdID8gJ252LXBvaW50IG52LW1pblZhbHVlJyA6ICdudi1wb2ludCBudi1tYXhWYWx1ZSdcbiAgICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuICBcbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICB3aWR0aCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXRYO1xuICAgIGdldFggPSBkMy5mdW5jdG9yKF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFk7XG4gICAgZ2V0WSA9IGQzLmZ1bmN0b3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnhTY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4O1xuICAgIHggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55U2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICB5ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueERvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4RG9tYWluO1xuICAgIHhEb21haW4gPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55RG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHlEb21haW47XG4gICAgeURvbWFpbiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnhSYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4UmFuZ2U7XG4gICAgeFJhbmdlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueVJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHlSYW5nZTtcbiAgICB5UmFuZ2UgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5hbmltYXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFuaW1hdGU7XG4gICAgYW5pbWF0ZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICByZXR1cm4gY2hhcnQ7XG59XG5cbm52Lm1vZGVscy5zcGFya2xpbmVQbHVzID0gZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBzcGFya2xpbmUgPSBudi5tb2RlbHMuc3BhcmtsaW5lKCk7XG5cbiAgdmFyIG1hcmdpbiA9IHt0b3A6IDE1LCByaWdodDogMTAwLCBib3R0b206IDEwLCBsZWZ0OiA1MH1cbiAgICAsIHdpZHRoID0gbnVsbFxuICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICwgeFxuICAgICwgeVxuICAgICwgaW5kZXggPSBbXVxuICAgICwgcGF1c2VkID0gZmFsc2VcbiAgICAsIHhUaWNrRm9ybWF0ID0gZDMuZm9ybWF0KCcscicpXG4gICAgLCB5VGlja0Zvcm1hdCA9IGQzLmZvcm1hdCgnLC4yZicpXG4gICAgLCBzaG93VmFsdWUgPSB0cnVlXG4gICAgLCBhbGlnblZhbHVlID0gdHJ1ZVxuICAgICwgcmlnaHRBbGlnblZhbHVlID0gZmFsc2VcbiAgICAsIG5vRGF0YSA9IFwiTm8gRGF0YSBBdmFpbGFibGUuXCJcbiAgICA7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgIFxuXG4gICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHsgY2hhcnQoc2VsZWN0aW9uKSB9O1xuICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG5cbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxuICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgbm9EYXRhVGV4dFxuICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcbiAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHNwYXJrbGluZS55KCkoZGF0YVtkYXRhLmxlbmd0aC0xXSwgZGF0YS5sZW5ndGgtMSk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgU2NhbGVzXG5cbiAgICAgIHggPSBzcGFya2xpbmUueFNjYWxlKCk7XG4gICAgICB5ID0gc3BhcmtsaW5lLnlTY2FsZSgpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuXG4gICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1zcGFya2xpbmVwbHVzJykuZGF0YShbZGF0YV0pO1xuICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtc3BhcmtsaW5lcGx1cycpO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXNwYXJrbGluZVdyYXAnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi12YWx1ZVdyYXAnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1ob3ZlckFyZWEnKTtcblxuICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxuXG4gICAgICB2YXIgc3BhcmtsaW5lV3JhcCA9IGcuc2VsZWN0KCcubnYtc3BhcmtsaW5lV3JhcCcpO1xuXG4gICAgICBzcGFya2xpbmVcbiAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgIHNwYXJrbGluZVdyYXBcbiAgICAgICAgICAuY2FsbChzcGFya2xpbmUpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIHZhciB2YWx1ZVdyYXAgPSBnLnNlbGVjdCgnLm52LXZhbHVlV3JhcCcpO1xuICAgICAgXG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZVdyYXAuc2VsZWN0QWxsKCcubnYtY3VycmVudFZhbHVlJylcbiAgICAgICAgICAuZGF0YShbY3VycmVudFZhbHVlXSk7XG5cbiAgICAgIHZhbHVlLmVudGVyKCkuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCAnbnYtY3VycmVudFZhbHVlJylcbiAgICAgICAgICAuYXR0cignZHgnLCByaWdodEFsaWduVmFsdWUgPyAtOCA6IDgpXG4gICAgICAgICAgLmF0dHIoJ2R5JywgJy45ZW0nKVxuICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByaWdodEFsaWduVmFsdWUgPyAnZW5kJyA6ICdzdGFydCcpO1xuXG4gICAgICB2YWx1ZVxuICAgICAgICAgIC5hdHRyKCd4JywgYXZhaWxhYmxlV2lkdGggKyAocmlnaHRBbGlnblZhbHVlID8gbWFyZ2luLnJpZ2h0IDogMCkpXG4gICAgICAgICAgLmF0dHIoJ3knLCBhbGlnblZhbHVlID8gZnVuY3Rpb24oZCkgeyByZXR1cm4geShkKSB9IDogMClcbiAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBzcGFya2xpbmUuY29sb3IoKShkYXRhW2RhdGEubGVuZ3RoLTFdLCBkYXRhLmxlbmd0aC0xKSlcbiAgICAgICAgICAudGV4dCh5VGlja0Zvcm1hdChjdXJyZW50VmFsdWUpKTtcblxuXG5cbiAgICAgIGdFbnRlci5zZWxlY3QoJy5udi1ob3ZlckFyZWEnKS5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgc3BhcmtsaW5lSG92ZXIpXG4gICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBwYXVzZWQgPSAhcGF1c2VkIH0pXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKCkgeyBpbmRleCA9IFtdOyB1cGRhdGVWYWx1ZUxpbmUoKTsgfSk7XG4gICAgICAgICAgLy8ub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7IGluZGV4ID0gbnVsbDsgdXBkYXRlVmFsdWVMaW5lKCk7IH0pO1xuXG4gICAgICBnLnNlbGVjdCgnLm52LWhvdmVyQXJlYSByZWN0JylcbiAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgLW1hcmdpbi5sZWZ0ICsgJywnICsgLW1hcmdpbi50b3AgKyAnKScgfSlcbiAgICAgICAgICAuYXR0cignd2lkdGgnLCBhdmFpbGFibGVXaWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KVxuICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQgKyBtYXJnaW4udG9wKTtcblxuXG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlTGluZSgpIHsgLy9pbmRleCBpcyBjdXJyZW50bHkgZ2xvYmFsICh3aXRoaW4gdGhlIGNoYXJ0KSwgbWF5IG9yIG1heSBub3Qga2VlcCBpdCB0aGF0IHdheVxuICAgICAgICBpZiAocGF1c2VkKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGhvdmVyVmFsdWUgPSBnLnNlbGVjdEFsbCgnLm52LWhvdmVyVmFsdWUnKS5kYXRhKGluZGV4KVxuXG4gICAgICAgIHZhciBob3ZlckVudGVyID0gaG92ZXJWYWx1ZS5lbnRlcigpXG4gICAgICAgICAgLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWhvdmVyVmFsdWUnKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDApXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDApO1xuXG4gICAgICAgIGhvdmVyVmFsdWUuZXhpdCgpXG4gICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbigyNTApXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMClcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMClcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICBob3ZlclZhbHVlXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeChzcGFya2xpbmUueCgpKGRhdGFbZF0sZCkpICsgJywwKScgfSlcbiAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDI1MClcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxKTtcblxuICAgICAgICBpZiAoIWluZGV4Lmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgIGhvdmVyRW50ZXIuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXG4gICAgICAgICAgICAuYXR0cigneTEnLCAtbWFyZ2luLnRvcClcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIDApXG4gICAgICAgICAgICAuYXR0cigneTInLCBhdmFpbGFibGVIZWlnaHQpO1xuXG5cbiAgICAgICAgaG92ZXJFbnRlci5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICdudi14VmFsdWUnKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAtNilcbiAgICAgICAgICAgIC5hdHRyKCd5JywgLW1hcmdpbi50b3ApXG4gICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnZW5kJylcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcuOWVtJylcblxuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtaG92ZXJWYWx1ZSAubnYteFZhbHVlJylcbiAgICAgICAgICAgIC50ZXh0KHhUaWNrRm9ybWF0KHNwYXJrbGluZS54KCkoZGF0YVtpbmRleFswXV0sIGluZGV4WzBdKSkpO1xuXG4gICAgICAgIGhvdmVyRW50ZXIuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCAnbnYteVZhbHVlJylcbiAgICAgICAgICAgIC5hdHRyKCd4JywgNilcbiAgICAgICAgICAgIC5hdHRyKCd5JywgLW1hcmdpbi50b3ApXG4gICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnc3RhcnQnKVxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy45ZW0nKVxuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtaG92ZXJWYWx1ZSAubnYteVZhbHVlJylcbiAgICAgICAgICAgIC50ZXh0KHlUaWNrRm9ybWF0KHNwYXJrbGluZS55KCkoZGF0YVtpbmRleFswXV0sIGluZGV4WzBdKSkpO1xuXG4gICAgICB9XG5cblxuICAgICAgZnVuY3Rpb24gc3BhcmtsaW5lSG92ZXIoKSB7XG4gICAgICAgIGlmIChwYXVzZWQpIHJldHVybjtcblxuICAgICAgICB2YXIgcG9zID0gZDMubW91c2UodGhpcylbMF0gLSBtYXJnaW4ubGVmdDtcblxuICAgICAgICBmdW5jdGlvbiBnZXRDbG9zZXN0SW5kZXgoZGF0YSwgeCkge1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKHNwYXJrbGluZS54KCkoZGF0YVswXSwgMCkgLSB4KTtcbiAgICAgICAgICB2YXIgY2xvc2VzdEluZGV4ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNwYXJrbGluZS54KCkoZGF0YVtpXSwgaSkgLSB4KSA8IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoc3BhcmtsaW5lLngoKShkYXRhW2ldLCBpKSAtIHgpO1xuICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBbZ2V0Q2xvc2VzdEluZGV4KGRhdGEsIE1hdGgucm91bmQoeC5pbnZlcnQocG9zKSkpXTtcblxuICAgICAgICB1cGRhdGVWYWx1ZUxpbmUoKTtcbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gIGNoYXJ0LnNwYXJrbGluZSA9IHNwYXJrbGluZTtcblxuICBkMy5yZWJpbmQoY2hhcnQsIHNwYXJrbGluZSwgJ3gnLCAneScsICd4U2NhbGUnLCAneVNjYWxlJywgJ2NvbG9yJyk7XG5cbiAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuICBcbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICB3aWR0aCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQueFRpY2tGb3JtYXQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geFRpY2tGb3JtYXQ7XG4gICAgeFRpY2tGb3JtYXQgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55VGlja0Zvcm1hdCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5VGlja0Zvcm1hdDtcbiAgICB5VGlja0Zvcm1hdCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dWYWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93VmFsdWU7XG4gICAgc2hvd1ZhbHVlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuYWxpZ25WYWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhbGlnblZhbHVlO1xuICAgIGFsaWduVmFsdWUgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5yaWdodEFsaWduVmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmlnaHRBbGlnblZhbHVlO1xuICAgIHJpZ2h0QWxpZ25WYWx1ZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0Lm5vRGF0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub0RhdGE7XG4gICAgbm9EYXRhID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIHJldHVybiBjaGFydDtcbn1cblxubnYubW9kZWxzLnN0YWNrZWRBcmVhID0gZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICwgd2lkdGggPSA5NjBcbiAgICAsIGhlaWdodCA9IDUwMFxuICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKSAvLyBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlIGNvbG9yXG4gICAgLCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMCkgLy9DcmVhdGUgc2VtaS11bmlxdWUgSUQgaW5jYXNlIHVzZXIgZG9lc24ndCBzZWxldCBvbmVcbiAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfSAvLyBhY2Nlc3NvciB0byBnZXQgdGhlIHggdmFsdWUgZnJvbSBhIGRhdGEgcG9pbnRcbiAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfSAvLyBhY2Nlc3NvciB0byBnZXQgdGhlIHkgdmFsdWUgZnJvbSBhIGRhdGEgcG9pbnRcbiAgICAsIHN0eWxlID0gJ3N0YWNrJ1xuICAgICwgb2Zmc2V0ID0gJ3plcm8nXG4gICAgLCBvcmRlciA9ICdkZWZhdWx0J1xuICAgICwgaW50ZXJwb2xhdGUgPSAnbGluZWFyJyAgLy8gY29udHJvbHMgdGhlIGxpbmUgaW50ZXJwb2xhdGlvblxuICAgICwgY2xpcEVkZ2UgPSBmYWxzZSAvLyBpZiB0cnVlLCBtYXNrcyBsaW5lcyB3aXRoaW4geCBhbmQgeSBzY2FsZVxuICAgICwgeCAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueFNjYWxlKClcbiAgICAsIHkgLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnlTY2FsZSgpXG4gICAgLCBzY2F0dGVyID0gbnYubW9kZWxzLnNjYXR0ZXIoKVxuICAgICwgZGlzcGF0Y2ggPSAgZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ2FyZWFDbGljaycsICdhcmVhTW91c2VvdmVyJywgJ2FyZWFNb3VzZW91dCcpXG4gICAgO1xuXG4gIHNjYXR0ZXJcbiAgICAuc2l6ZSgyLjIpIC8vIGRlZmF1bHQgc2l6ZVxuICAgIC5zaXplRG9tYWluKFsyLjIsMi4yXSkgLy8gYWxsIHRoZSBzYW1lIHNpemUgYnkgZGVmYXVsdFxuICAgIDtcblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIG9mZnNldDpcbiAgICogICAnd2lnZ2xlJyAoc3RyZWFtKVxuICAgKiAgICd6ZXJvJyAoc3RhY2tlZClcbiAgICogICAnZXhwYW5kJyAobm9ybWFsaXplIHRvIDEwMCUpXG4gICAqICAgJ3NpbGhvdWV0dGUnIChzaW1wbGUgY2VudGVyZWQpXG4gICAqXG4gICAqIG9yZGVyOlxuICAgKiAgICdpbnNpZGUtb3V0JyAoc3RyZWFtKVxuICAgKiAgICdkZWZhdWx0JyAoaW5wdXQgb3JkZXIpXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gU2V0dXAgU2NhbGVzXG5cbiAgICAgIHggPSBzY2F0dGVyLnhTY2FsZSgpO1xuICAgICAgeSA9IHNjYXR0ZXIueVNjYWxlKCk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIHZhciBkYXRhUmF3ID0gZGF0YTtcbiAgICAgIC8vIEluamVjdGluZyBwb2ludCBpbmRleCBpbnRvIGVhY2ggcG9pbnQgYmVjYXVzZSBkMy5sYXlvdXQuc3RhY2soKS5vdXQgZG9lcyBub3QgZ2l2ZSBpbmRleFxuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGFzZXJpZXMsIGkpIHtcbiAgICAgICAgYXNlcmllcy5zZXJpZXNJbmRleCA9IGk7XG4gICAgICAgIGFzZXJpZXMudmFsdWVzID0gYXNlcmllcy52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsIGopIHtcbiAgICAgICAgICBkLmluZGV4ID0gajtcbiAgICAgICAgICBkLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGRhdGFGaWx0ZXJlZCA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgcmV0dXJuICFzZXJpZXMuZGlzYWJsZWQ7XG4gICAgICB9KTtcblxuICAgICAgZGF0YSA9IGQzLmxheW91dC5zdGFjaygpXG4gICAgICAgICAgICAgICAub3JkZXIob3JkZXIpXG4gICAgICAgICAgICAgICAub2Zmc2V0KG9mZnNldClcbiAgICAgICAgICAgICAgIC52YWx1ZXMoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMgfSkgIC8vVE9ETzogbWFrZSB2YWx1ZXMgY3VzdG9taXplYWJsZSBpbiBFVkVSWSBtb2RlbCBpbiB0aGlzIGZhc2hpb25cbiAgICAgICAgICAgICAgIC54KGdldFgpXG4gICAgICAgICAgICAgICAueShnZXRZKVxuICAgICAgICAgICAgICAgLm91dChmdW5jdGlvbihkLCB5MCwgeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeUhlaWdodCA9IChnZXRZKGQpID09PSAwKSA/IDAgOiB5O1xuICAgICAgICAgICAgICAgICAgICBkLmRpc3BsYXkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgeTogeUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgIHkwOiB5MFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIChkYXRhRmlsdGVyZWQpO1xuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuXG4gICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1zdGFja2VkYXJlYScpLmRhdGEoW2RhdGFdKTtcbiAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LXN0YWNrZWRhcmVhJyk7XG4gICAgICB2YXIgZGVmc0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZGVmcycpO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWFyZWFXcmFwJyk7XG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtc2NhdHRlcldyYXAnKTtcblxuICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIHNjYXR0ZXJcbiAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgLngoZ2V0WClcbiAgICAgICAgLnkoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5kaXNwbGF5LnkgKyBkLmRpc3BsYXkueTAgfSlcbiAgICAgICAgLmZvcmNlWShbMF0pXG4gICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBkLnNlcmllc0luZGV4KTtcbiAgICAgICAgfSkpO1xuXG5cbiAgICAgIHZhciBzY2F0dGVyV3JhcCA9IGcuc2VsZWN0KCcubnYtc2NhdHRlcldyYXAnKVxuICAgICAgICAgIC5kYXR1bShkYXRhKTtcblxuICAgICAgc2NhdHRlcldyYXAuY2FsbChzY2F0dGVyKTtcblxuICAgICAgZGVmc0VudGVyLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgICAgIC5hdHRyKCdpZCcsICdudi1lZGdlLWNsaXAtJyArIGlkKVxuICAgICAgICAuYXBwZW5kKCdyZWN0Jyk7XG5cbiAgICAgIHdyYXAuc2VsZWN0KCcjbnYtZWRnZS1jbGlwLScgKyBpZCArICcgcmVjdCcpXG4gICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgIGcgICAuYXR0cignY2xpcC1wYXRoJywgY2xpcEVkZ2UgPyAndXJsKCNudi1lZGdlLWNsaXAtJyArIGlkICsgJyknIDogJycpO1xuXG4gICAgICB2YXIgYXJlYSA9IGQzLnN2Zy5hcmVhKClcbiAgICAgICAgICAueChmdW5jdGlvbihkLGkpICB7IHJldHVybiB4KGdldFgoZCxpKSkgfSlcbiAgICAgICAgICAueTAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4geShkLmRpc3BsYXkueTApXG4gICAgICAgICAgfSlcbiAgICAgICAgICAueTEoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4geShkLmRpc3BsYXkueSArIGQuZGlzcGxheS55MClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSk7XG5cbiAgICAgIHZhciB6ZXJvQXJlYSA9IGQzLnN2Zy5hcmVhKClcbiAgICAgICAgICAueChmdW5jdGlvbihkLGkpICB7IHJldHVybiB4KGdldFgoZCxpKSkgfSlcbiAgICAgICAgICAueTAoZnVuY3Rpb24oZCkgeyByZXR1cm4geShkLmRpc3BsYXkueTApIH0pXG4gICAgICAgICAgLnkxKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHkoZC5kaXNwbGF5LnkwKSB9KTtcblxuXG4gICAgICB2YXIgcGF0aCA9IGcuc2VsZWN0KCcubnYtYXJlYVdyYXAnKS5zZWxlY3RBbGwoJ3BhdGgubnYtYXJlYScpXG4gICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgcGF0aC5lbnRlcigpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAnbnYtYXJlYSBudi1hcmVhLScgKyBpIH0pXG4gICAgICAgICAgLmF0dHIoJ2QnLCBmdW5jdGlvbihkLGkpe1xuICAgICAgICAgICAgcmV0dXJuIHplcm9BcmVhKGQudmFsdWVzLCBkLnNlcmllc0luZGV4KTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgIGRpc3BhdGNoLmFyZWFNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgc2VyaWVzOiBkLmtleSxcbiAgICAgICAgICAgICAgcG9zOiBbZDMuZXZlbnQucGFnZVgsIGQzLmV2ZW50LnBhZ2VZXSxcbiAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzSW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgZGlzcGF0Y2guYXJlYU1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgIHNlcmllczogZC5rZXksXG4gICAgICAgICAgICAgIHBvczogW2QzLmV2ZW50LnBhZ2VYLCBkMy5ldmVudC5wYWdlWV0sXG4gICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllc0luZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgIGRpc3BhdGNoLmFyZWFDbGljayh7XG4gICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICBzZXJpZXM6IGQua2V5LFxuICAgICAgICAgICAgICBwb3M6IFtkMy5ldmVudC5wYWdlWCwgZDMuZXZlbnQucGFnZVldLFxuICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXNJbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcblxuICAgICAgcGF0aC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgIHBhdGhcbiAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpe1xuICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgZC5zZXJpZXNJbmRleClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKXsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgZC5zZXJpZXNJbmRleCkgfSk7XG4gICAgICBwYXRoLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlYShkLnZhbHVlcyxpKVxuICAgICAgICAgIH0pO1xuXG5cblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgc2NhdHRlci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci5hcmVhJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBnLnNlbGVjdCgnLm52LWNoYXJ0LScgKyBpZCArICcgLm52LWFyZWEtJyArIGUuc2VyaWVzSW5kZXgpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC5hcmVhJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBnLnNlbGVjdCgnLm52LWNoYXJ0LScgKyBpZCArICcgLm52LWFyZWEtJyArIGUuc2VyaWVzSW5kZXgpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAvL1NwZWNpYWwgb2Zmc2V0IGZ1bmN0aW9uc1xuICAgICAgY2hhcnQuZDNfc3RhY2tlZE9mZnNldF9zdGFja1BlcmNlbnQgPSBmdW5jdGlvbihzdGFja0RhdGEpIHtcbiAgICAgICAgICB2YXIgbiA9IHN0YWNrRGF0YS5sZW5ndGgsICAgIC8vSG93IG1hbnkgc2VyaWVzXG4gICAgICAgICAgbSA9IHN0YWNrRGF0YVswXS5sZW5ndGgsICAgICAvL2hvdyBtYW55IHBvaW50cyBwZXIgc2VyaWVzXG4gICAgICAgICAgayA9IDEgLyBuLFxuICAgICAgICAgICBpLFxuICAgICAgICAgICBqLFxuICAgICAgICAgICBvLFxuICAgICAgICAgICB5MCA9IFtdO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgeyAvL0xvb3BpbmcgdGhyb3VnaCBhbGwgcG9pbnRzXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBvID0gMDsgaSA8IGRhdGFSYXcubGVuZ3RoOyBpKyspICAvL2xvb3BpbmcgdGhyb3VnaCBzZXJpZXMnXG4gICAgICAgICAgICAgICAgbyArPSBnZXRZKGRhdGFSYXdbaV0udmFsdWVzW2pdKSAgIC8vdG90YWwgdmFsdWUgb2YgYWxsIHBvaW50cyBhdCBhIGNlcnRpYW4gcG9pbnQgaW4gdGltZS5cblxuICAgICAgICAgICAgaWYgKG8pIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICAgICBzdGFja0RhdGFbaV1bal1bMV0gLz0gbztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgICAgIHN0YWNrRGF0YVtpXVtqXVsxXSA9IGs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHkwW2pdID0gMDtcbiAgICAgICAgICByZXR1cm4geTA7XG4gICAgICB9O1xuXG4gICAgfSk7XG5cblxuICAgIHJldHVybiBjaGFydDtcbiAgfVxuXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRDbGljay5hcmVhJywgZnVuY3Rpb24oZSkge1xuICAgIGRpc3BhdGNoLmFyZWFDbGljayhlKTtcbiAgfSlcbiAgc2NhdHRlci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdLFxuICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgfSk7XG4gIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgfSk7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBHbG9iYWwgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gIGNoYXJ0LnNjYXR0ZXIgPSBzY2F0dGVyO1xuXG4gIGQzLnJlYmluZChjaGFydCwgc2NhdHRlciwgJ2ludGVyYWN0aXZlJywgJ3NpemUnLCAneFNjYWxlJywgJ3lTY2FsZScsICd6U2NhbGUnLCAneERvbWFpbicsICd5RG9tYWluJywgJ3hSYW5nZScsICd5UmFuZ2UnLFxuICAgICdzaXplRG9tYWluJywgJ2ZvcmNlWCcsICdmb3JjZVknLCAnZm9yY2VTaXplJywgJ2NsaXBWb3Jvbm9pJywgJ3VzZVZvcm9ub2knLCdjbGlwUmFkaXVzJywnaGlnaGxpZ2h0UG9pbnQnLCdjbGVhckhpZ2hsaWdodHMnKTtcblxuICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgY2hhcnQueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXRYO1xuICAgIGdldFggPSBkMy5mdW5jdG9yKF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC55ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdldFk7XG4gICAgZ2V0WSA9IGQzLmZ1bmN0b3IoXyk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICB3aWR0aCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuY2xpcEVkZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEVkZ2U7XG4gICAgY2xpcEVkZ2UgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5jb2xvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2xvcjtcbiAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5vZmZzZXQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb2Zmc2V0O1xuICAgIG9mZnNldCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0Lm9yZGVyID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yZGVyO1xuICAgIG9yZGVyID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgLy9zaG9ydGN1dCBmb3Igb2Zmc2V0ICsgb3JkZXJcbiAgY2hhcnQuc3R5bGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3R5bGU7XG4gICAgc3R5bGUgPSBfO1xuXG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnc3RhY2snOlxuICAgICAgICBjaGFydC5vZmZzZXQoJ3plcm8nKTtcbiAgICAgICAgY2hhcnQub3JkZXIoJ2RlZmF1bHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJlYW0nOlxuICAgICAgICBjaGFydC5vZmZzZXQoJ3dpZ2dsZScpO1xuICAgICAgICBjaGFydC5vcmRlcignaW5zaWRlLW91dCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmVhbS1jZW50ZXInOlxuICAgICAgICAgIGNoYXJ0Lm9mZnNldCgnc2lsaG91ZXR0ZScpO1xuICAgICAgICAgIGNoYXJ0Lm9yZGVyKCdpbnNpZGUtb3V0Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdleHBhbmQnOlxuICAgICAgICBjaGFydC5vZmZzZXQoJ2V4cGFuZCcpO1xuICAgICAgICBjaGFydC5vcmRlcignZGVmYXVsdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0YWNrX3BlcmNlbnQnOlxuICAgICAgICBjaGFydC5vZmZzZXQoY2hhcnQuZDNfc3RhY2tlZE9mZnNldF9zdGFja1BlcmNlbnQpO1xuICAgICAgICBjaGFydC5vcmRlcignZGVmYXVsdCcpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG5cdCAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcnBvbGF0ZTtcblx0ICAgIGludGVycG9sYXRlID0gXztcblx0ICAgIHJldHVybiBjaGFydDtcbiAgfTtcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIHJldHVybiBjaGFydDtcbn1cblxubnYubW9kZWxzLnN0YWNrZWRBcmVhQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHN0YWNrZWQgPSBudi5tb2RlbHMuc3RhY2tlZEFyZWEoKVxuICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgLCB5QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAsIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICwgY29udHJvbHMgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAsIGludGVyYWN0aXZlTGF5ZXIgPSBudi5pbnRlcmFjdGl2ZUd1aWRlbGluZSgpXG4gICAgO1xuXG4gIHZhciBtYXJnaW4gPSB7dG9wOiAzMCwgcmlnaHQ6IDI1LCBib3R0b206IDUwLCBsZWZ0OiA2MH1cbiAgICAsIHdpZHRoID0gbnVsbFxuICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKSAvLyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgaW4gZCwgaSBhbmQgcmV0dXJucyBjb2xvclxuICAgICwgc2hvd0NvbnRyb2xzID0gdHJ1ZVxuICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcbiAgICAsIHNob3dYQXhpcyA9IHRydWVcbiAgICAsIHNob3dZQXhpcyA9IHRydWVcbiAgICAsIHJpZ2h0QWxpZ25ZQXhpcyA9IGZhbHNlXG4gICAgLCB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IGZhbHNlXG4gICAgLCB0b29sdGlwcyA9IHRydWVcbiAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgIHJldHVybiAnPGgzPicgKyBrZXkgKyAnPC9oMz4nICtcbiAgICAgICAgICAgICAgICc8cD4nICsgIHkgKyAnIG9uICcgKyB4ICsgJzwvcD4nXG4gICAgICB9XG4gICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxuICAgICwgeSAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueVNjYWxlKClcbiAgICAsIHlBeGlzVGlja0Zvcm1hdCA9IGQzLmZvcm1hdCgnLC4yZicpXG4gICAgLCBzdGF0ZSA9IHsgc3R5bGU6IHN0YWNrZWQuc3R5bGUoKSB9XG4gICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgLCBub0RhdGEgPSAnTm8gRGF0YSBBdmFpbGFibGUuJ1xuICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnKVxuICAgICwgY29udHJvbFdpZHRoID0gMjUwXG4gICAgLCBjRGF0YSA9IFsnU3RhY2tlZCcsJ1N0cmVhbScsJ0V4cGFuZGVkJ11cbiAgICAsIGNvbnRyb2xMYWJlbHMgPSB7fVxuICAgICwgdHJhbnNpdGlvbkR1cmF0aW9uID0gMjUwXG4gICAgO1xuXG4gIHhBeGlzXG4gICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAudGlja1BhZGRpbmcoNylcbiAgICA7XG4gIHlBeGlzXG4gICAgLm9yaWVudCgocmlnaHRBbGlnbllBeGlzKSA/ICdyaWdodCcgOiAnbGVmdCcpXG4gICAgO1xuXG4gIGNvbnRyb2xzLnVwZGF0ZVN0YXRlKGZhbHNlKTtcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgeCA9IHhBeGlzLnRpY2tGb3JtYXQoKShzdGFja2VkLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgeSA9IHlBeGlzLnRpY2tGb3JtYXQoKShzdGFja2VkLnkoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgY29udGVudCA9IHRvb2x0aXAoZS5zZXJpZXMua2V5LCB4LCB5LCBlLCBjaGFydCk7XG5cbiAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIGUudmFsdWUgPCAwID8gJ24nIDogJ3MnLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgfTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGNoYXJ0KTsgfTtcbiAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgIC8vc2V0IHN0YXRlLmRpc2FibGVkXG4gICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XG4gICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgaWYgKHN0YXRlW2tleV0gaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XS5zbGljZSgwKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIFNjYWxlc1xuXG4gICAgICB4ID0gc3RhY2tlZC54U2NhbGUoKTtcbiAgICAgIHkgPSBzdGFja2VkLnlTY2FsZSgpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuXG4gICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1zdGFja2VkQXJlYUNoYXJ0JykuZGF0YShbZGF0YV0pO1xuICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtc3RhY2tlZEFyZWFDaGFydCcpLmFwcGVuZCgnZycpO1xuICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICBnRW50ZXIuYXBwZW5kKFwicmVjdFwiKS5zdHlsZShcIm9wYWNpdHlcIiwwKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1zdGFja2VkV3JhcCcpO1xuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1jb250cm9sc1dyYXAnKTtcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1pbnRlcmFjdGl2ZScpO1xuXG4gICAgICBnLnNlbGVjdChcInJlY3RcIikuYXR0cihcIndpZHRoXCIsYXZhaWxhYmxlV2lkdGgpLmF0dHIoXCJoZWlnaHRcIixhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIExlZ2VuZFxuXG4gICAgICBpZiAoc2hvd0xlZ2VuZCkge1xuICAgICAgICB2YXIgbGVnZW5kV2lkdGggPSAoc2hvd0NvbnRyb2xzKSA/IGF2YWlsYWJsZVdpZHRoIC0gY29udHJvbFdpZHRoIDogYXZhaWxhYmxlV2lkdGg7XG4gICAgICAgIGxlZ2VuZFxuICAgICAgICAgIC53aWR0aChsZWdlbmRXaWR0aCk7XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKGF2YWlsYWJsZVdpZHRoLWxlZ2VuZFdpZHRoKSArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIENvbnRyb2xzXG5cbiAgICAgIGlmIChzaG93Q29udHJvbHMpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xzRGF0YSA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGNvbnRyb2xMYWJlbHMuc3RhY2tlZCB8fCAnU3RhY2tlZCcsXG4gICAgICAgICAgICBtZXRhS2V5OiAnU3RhY2tlZCcsXG4gICAgICAgICAgICBkaXNhYmxlZDogc3RhY2tlZC5zdHlsZSgpICE9ICdzdGFjaycsXG4gICAgICAgICAgICBzdHlsZTogJ3N0YWNrJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiBjb250cm9sTGFiZWxzLnN0cmVhbSB8fCAnU3RyZWFtJyxcbiAgICAgICAgICAgIG1ldGFLZXk6ICdTdHJlYW0nLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHN0YWNrZWQuc3R5bGUoKSAhPSAnc3RyZWFtJyxcbiAgICAgICAgICAgIHN0eWxlOiAnc3RyZWFtJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiBjb250cm9sTGFiZWxzLmV4cGFuZGVkIHx8ICdFeHBhbmRlZCcsXG4gICAgICAgICAgICBtZXRhS2V5OiAnRXhwYW5kZWQnLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHN0YWNrZWQuc3R5bGUoKSAhPSAnZXhwYW5kJyxcbiAgICAgICAgICAgIHN0eWxlOiAnZXhwYW5kJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiBjb250cm9sTGFiZWxzLnN0YWNrX3BlcmNlbnQgfHwgJ1N0YWNrICUnLFxuICAgICAgICAgICAgbWV0YUtleTogJ1N0YWNrX1BlcmNlbnQnLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHN0YWNrZWQuc3R5bGUoKSAhPSAnc3RhY2tfcGVyY2VudCcsXG4gICAgICAgICAgICBzdHlsZTogJ3N0YWNrX3BlcmNlbnQnXG4gICAgICAgICAgfVxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnRyb2xXaWR0aCA9IChjRGF0YS5sZW5ndGgvMykgKiAyNjA7XG5cbiAgICAgICAgY29udHJvbHNEYXRhID0gY29udHJvbHNEYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIGNEYXRhLmluZGV4T2YoZC5tZXRhS2V5KSAhPT0gLTE7XG4gICAgICAgIH0pXG5cbiAgICAgICAgY29udHJvbHNcbiAgICAgICAgICAud2lkdGgoIGNvbnRyb2xXaWR0aCApXG4gICAgICAgICAgLmNvbG9yKFsnIzQ0NCcsICcjNDQ0JywgJyM0NDQnXSk7XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi1jb250cm9sc1dyYXAnKVxuICAgICAgICAgICAgLmRhdHVtKGNvbnRyb2xzRGF0YSlcbiAgICAgICAgICAgIC5jYWxsKGNvbnRyb2xzKTtcblxuXG4gICAgICAgIGlmICggbWFyZ2luLnRvcCAhPSBNYXRoLm1heChjb250cm9scy5oZWlnaHQoKSwgbGVnZW5kLmhlaWdodCgpKSApIHtcbiAgICAgICAgICBtYXJnaW4udG9wID0gTWF0aC5tYXgoY29udHJvbHMuaGVpZ2h0KCksIGxlZ2VuZC5oZWlnaHQoKSk7XG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgICAgIH1cblxuXG4gICAgICAgIGcuc2VsZWN0KCcubnYtY29udHJvbHNXcmFwJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvL1NldCB1cCBpbnRlcmFjdGl2ZSBsYXllclxuICAgICAgaWYgKHVzZUludGVyYWN0aXZlR3VpZGVsaW5lKSB7XG4gICAgICAgIGludGVyYWN0aXZlTGF5ZXJcbiAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgLm1hcmdpbih7bGVmdDogbWFyZ2luLmxlZnQsIHRvcDogbWFyZ2luLnRvcH0pXG4gICAgICAgICAgIC5zdmdDb250YWluZXIoY29udGFpbmVyKVxuICAgICAgICAgICAueFNjYWxlKHgpO1xuICAgICAgICB3cmFwLnNlbGVjdChcIi5udi1pbnRlcmFjdGl2ZVwiKS5jYWxsKGludGVyYWN0aXZlTGF5ZXIpO1xuICAgICAgfVxuXG4gICAgICBzdGFja2VkXG4gICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG5cbiAgICAgIHZhciBzdGFja2VkV3JhcCA9IGcuc2VsZWN0KCcubnYtc3RhY2tlZFdyYXAnKVxuICAgICAgICAgIC5kYXR1bShkYXRhKTtcblxuICAgICAgc3RhY2tlZFdyYXAudHJhbnNpdGlvbigpLmNhbGwoc3RhY2tlZCk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFNldHVwIEF4ZXNcblxuICAgICAgaWYgKHNob3dYQXhpcykge1xuICAgICAgICB4QXhpc1xuICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgIC50aWNrcyggYXZhaWxhYmxlV2lkdGggLyAxMDAgKVxuICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZUhlaWdodCwgMCk7XG5cbiAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgYXZhaWxhYmxlSGVpZ2h0ICsgJyknKTtcblxuICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbigwKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgIHlBeGlzXG4gICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgLnRpY2tzKHN0YWNrZWQub2Zmc2V0KCkgPT0gJ3dpZ2dsZScgPyAwIDogYXZhaWxhYmxlSGVpZ2h0IC8gMzYpXG4gICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVXaWR0aCwgMClcbiAgICAgICAgICAuc2V0VGlja0Zvcm1hdCggKHN0YWNrZWQuc3R5bGUoKSA9PSAnZXhwYW5kJyB8fCBzdGFja2VkLnN0eWxlKCkgPT0gJ3N0YWNrX3BlcmNlbnQnKVxuICAgICAgICAgICAgICAgID8gZDMuZm9ybWF0KCclJykgOiB5QXhpc1RpY2tGb3JtYXQpO1xuXG4gICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJylcbiAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDApXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgc3RhY2tlZC5kaXNwYXRjaC5vbignYXJlYUNsaWNrLnRvZ2dsZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgZC5kaXNhYmxlZCA9IChpICE9IGUuc2VyaWVzSW5kZXgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG5cbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgIHN0YXRlLmRpc2FibGVkID0gbmV3U3RhdGUuZGlzYWJsZWQ7XG4gICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgY29udHJvbHMuZGlzcGF0Y2gub24oJ2xlZ2VuZENsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgIGlmICghZC5kaXNhYmxlZCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnRyb2xzRGF0YSA9IGNvbnRyb2xzRGF0YS5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICAgIHMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9KTtcbiAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHN0YWNrZWQuc3R5bGUoZC5zdHlsZSk7XG5cblxuICAgICAgICBzdGF0ZS5zdHlsZSA9IHN0YWNrZWQuc3R5bGUoKTtcbiAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuXG4gICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfSk7XG5cblxuICAgICAgaW50ZXJhY3RpdmVMYXllci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBzdGFja2VkLmNsZWFySGlnaGxpZ2h0cygpO1xuICAgICAgICAgIHZhciBzaW5nbGVQb2ludCwgcG9pbnRJbmRleCwgcG9pbnRYTG9jYXRpb24sIGFsbERhdGEgPSBbXTtcbiAgICAgICAgICBkYXRhXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgIHNlcmllcy5zZXJpZXNJbmRleCA9IGk7XG4gICAgICAgICAgICByZXR1cm4gIXNlcmllcy5kaXNhYmxlZDtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgIHBvaW50SW5kZXggPSBudi5pbnRlcmFjdGl2ZUJpc2VjdChzZXJpZXMudmFsdWVzLCBlLnBvaW50WFZhbHVlLCBjaGFydC54KCkpO1xuICAgICAgICAgICAgICBzdGFja2VkLmhpZ2hsaWdodFBvaW50KGksIHBvaW50SW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBzZXJpZXMudmFsdWVzW3BvaW50SW5kZXhdO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHNpbmdsZVBvaW50ID09PSAndW5kZWZpbmVkJykgc2luZ2xlUG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludFhMb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHBvaW50WExvY2F0aW9uID0gY2hhcnQueFNjYWxlKCkoY2hhcnQueCgpKHBvaW50LHBvaW50SW5kZXgpKTtcblxuICAgICAgICAgICAgICAvL0lmIHdlIGFyZSBpbiAnZXhwYW5kJyBtb2RlLCB1c2UgdGhlIHN0YWNrZWQgcGVyY2VudCB2YWx1ZSBpbnN0ZWFkIG9mIHJhdyB2YWx1ZS5cbiAgICAgICAgICAgICAgdmFyIHRvb2x0aXBWYWx1ZSA9IChzdGFja2VkLnN0eWxlKCkgPT0gJ2V4cGFuZCcpID8gcG9pbnQuZGlzcGxheS55IDogY2hhcnQueSgpKHBvaW50LHBvaW50SW5kZXgpO1xuICAgICAgICAgICAgICBhbGxEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAga2V5OiBzZXJpZXMua2V5LFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHRvb2x0aXBWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcihzZXJpZXMsc2VyaWVzLnNlcmllc0luZGV4KSxcbiAgICAgICAgICAgICAgICAgIHN0YWNrZWRWYWx1ZTogcG9pbnQuZGlzcGxheVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGFsbERhdGEucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgLy9IaWdobGlnaHQgdGhlIHRvb2x0aXAgZW50cnkgYmFzZWQgb24gd2hpY2ggc3RhY2sgdGhlIG1vdXNlIGlzIGNsb3Nlc3QgdG8uXG4gICAgICAgICAgaWYgKGFsbERhdGEubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIHlWYWx1ZSA9IGNoYXJ0LnlTY2FsZSgpLmludmVydChlLm1vdXNlWSk7XG4gICAgICAgICAgICB2YXIgeURpc3RNYXggPSBJbmZpbml0eSwgaW5kZXhUb0hpZ2hsaWdodCA9IG51bGw7XG4gICAgICAgICAgICBhbGxEYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcblxuICAgICAgICAgICAgICAgLy9UbyBoYW5kbGUgc2l0dWF0aW9uIHdoZXJlIHRoZSBzdGFja2VkIGFyZWEgY2hhcnQgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gdXNlIGFic29sdXRlIHZhbHVlc1xuICAgICAgICAgICAgICAgLy93aGVuIGNoZWNraW5nIGlmIHRoZSBtb3VzZSBZIHZhbHVlIGlzIHdpdGhpbiB0aGUgc3RhY2sgYXJlYS5cbiAgICAgICAgICAgICAgIHlWYWx1ZSA9IE1hdGguYWJzKHlWYWx1ZSk7XG4gICAgICAgICAgICAgICB2YXIgc3RhY2tlZFkwID0gTWF0aC5hYnMoc2VyaWVzLnN0YWNrZWRWYWx1ZS55MCk7XG4gICAgICAgICAgICAgICB2YXIgc3RhY2tlZFkgPSBNYXRoLmFicyhzZXJpZXMuc3RhY2tlZFZhbHVlLnkpO1xuICAgICAgICAgICAgICAgaWYgKCB5VmFsdWUgPj0gc3RhY2tlZFkwICYmIHlWYWx1ZSA8PSAoc3RhY2tlZFkgKyBzdGFja2VkWTApKVxuICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaW5kZXhUb0hpZ2hsaWdodCA9IGk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbmRleFRvSGlnaGxpZ2h0ICE9IG51bGwpXG4gICAgICAgICAgICAgICBhbGxEYXRhW2luZGV4VG9IaWdobGlnaHRdLmhpZ2hsaWdodCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHhWYWx1ZSA9IHhBeGlzLnRpY2tGb3JtYXQoKShjaGFydC54KCkoc2luZ2xlUG9pbnQscG9pbnRJbmRleCkpO1xuXG4gICAgICAgICAgLy9JZiB3ZSBhcmUgaW4gJ2V4cGFuZCcgbW9kZSwgZm9yY2UgdGhlIGZvcm1hdCB0byBiZSBhIHBlcmNlbnRhZ2UuXG4gICAgICAgICAgdmFyIHZhbHVlRm9ybWF0dGVyID0gKHN0YWNrZWQuc3R5bGUoKSA9PSAnZXhwYW5kJykgP1xuICAgICAgICAgICAgICAgZnVuY3Rpb24oZCxpKSB7cmV0dXJuIGQzLmZvcm1hdChcIi4xJVwiKShkKTt9IDpcbiAgICAgICAgICAgICAgIGZ1bmN0aW9uKGQsaSkge3JldHVybiB5QXhpcy50aWNrRm9ybWF0KCkoZCk7IH07XG4gICAgICAgICAgaW50ZXJhY3RpdmVMYXllci50b29sdGlwXG4gICAgICAgICAgICAgICAgICAucG9zaXRpb24oe2xlZnQ6IHBvaW50WExvY2F0aW9uICsgbWFyZ2luLmxlZnQsIHRvcDogZS5tb3VzZVkgKyBtYXJnaW4udG9wfSlcbiAgICAgICAgICAgICAgICAgIC5jaGFydENvbnRhaW5lcih0aGF0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAuZW5hYmxlZCh0b29sdGlwcylcbiAgICAgICAgICAgICAgICAgIC52YWx1ZUZvcm1hdHRlcih2YWx1ZUZvcm1hdHRlcilcbiAgICAgICAgICAgICAgICAgIC5kYXRhKFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB4VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGFsbERhdGFcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICApKCk7XG5cbiAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLnJlbmRlckd1aWRlTGluZShwb2ludFhMb2NhdGlvbik7XG5cbiAgICAgIH0pO1xuXG4gICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKFwiZWxlbWVudE1vdXNlb3V0XCIsZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKCk7XG4gICAgICAgICAgc3RhY2tlZC5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgIH0pO1xuXG5cbiAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBjaGFydCBmcm9tIGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0byBldmVudCBoYW5kbGVyXG4gICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhLmxlbmd0aCA9PT0gZS5kaXNhYmxlZC5sZW5ndGgpIHtcbiAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IGUuZGlzYWJsZWRbaV07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGUuc3R5bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc3RhY2tlZC5zdHlsZShlLnN0eWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfSk7XG5cbiAgICB9KTtcblxuXG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgc3RhY2tlZC5kaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgLy9kaXNhYmxlIHRvb2x0aXBzIHdoZW4gdmFsdWUgfj0gMFxuICAgIC8vLy8gVE9ETzogY29uc2lkZXIgcmVtb3ZpbmcgcG9pbnRzIGZyb20gdm9yb25vaSB0aGF0IGhhdmUgMCB2YWx1ZSBpbnN0ZWFkIG9mIHRoaXMgaGFja1xuICAgIC8qXG4gICAgaWYgKCFNYXRoLnJvdW5kKHN0YWNrZWQueSgpKGUucG9pbnQpICogMTAwKSkgeyAgLy8gMTAwIHdpbGwgbm90IGJlIGdvb2QgZm9yIHZlcnkgc21hbGwgbnVtYmVycy4uLiB3aWxsIGhhdmUgdG8gdGhpbmsgYWJvdXQgbWFraW5nIHRoaXMgdmFsdSBkeW5hbWljLCBiYXNlZCBvbiBkYXRhIHJhbmdlXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBkMy5zZWxlY3RBbGwoJy5wb2ludC5ob3ZlcicpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpIH0sIDApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICovXG5cbiAgICBlLnBvcyA9IFtlLnBvc1swXSArIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdLFxuICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICB9KTtcblxuICBzdGFja2VkLmRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKGUpIHtcbiAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgfSk7XG5cbiAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgfSk7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgY2hhcnQuc3RhY2tlZCA9IHN0YWNrZWQ7XG4gIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbiAgY2hhcnQuY29udHJvbHMgPSBjb250cm9scztcbiAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgY2hhcnQuaW50ZXJhY3RpdmVMYXllciA9IGludGVyYWN0aXZlTGF5ZXI7XG5cbiAgZDMucmViaW5kKGNoYXJ0LCBzdGFja2VkLCAneCcsICd5JywgJ3NpemUnLCAneFNjYWxlJywgJ3lTY2FsZScsICd4RG9tYWluJywgJ3lEb21haW4nLCAneFJhbmdlJywgJ3lSYW5nZScsICdzaXplRG9tYWluJywgJ2ludGVyYWN0aXZlJywgJ3VzZVZvcm9ub2knLCAnb2Zmc2V0JywgJ29yZGVyJywgJ3N0eWxlJywgJ2NsaXBFZGdlJywgJ2ZvcmNlWCcsICdmb3JjZVknLCAnZm9yY2VTaXplJywgJ2ludGVycG9sYXRlJyk7XG5cbiAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gIGNoYXJ0Lm1hcmdpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJnaW47XG4gICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICBtYXJnaW4ucmlnaHQgID0gdHlwZW9mIF8ucmlnaHQgICE9ICd1bmRlZmluZWQnID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgbWFyZ2luLmJvdHRvbSA9IHR5cGVvZiBfLmJvdHRvbSAhPSAndW5kZWZpbmVkJyA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQud2lkdGggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XG4gICAgd2lkdGggPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5oZWlnaHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xuICAgIGhlaWdodCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbG9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICBzdGFja2VkLmNvbG9yKGNvbG9yKTtcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd0NvbnRyb2xzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dDb250cm9scztcbiAgICBzaG93Q29udHJvbHMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zaG93TGVnZW5kID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dMZWdlbmQ7XG4gICAgc2hvd0xlZ2VuZCA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnNob3dYQXhpcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93WEF4aXM7XG4gICAgc2hvd1hBeGlzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQuc2hvd1lBeGlzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dZQXhpcztcbiAgICBzaG93WUF4aXMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5yaWdodEFsaWduWUF4aXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByaWdodEFsaWduWUF4aXM7XG4gICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC51c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lO1xuICAgIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lID0gXztcbiAgICBpZiAoXyA9PT0gdHJ1ZSkge1xuICAgICAgIGNoYXJ0LmludGVyYWN0aXZlKGZhbHNlKTtcbiAgICAgICBjaGFydC51c2VWb3Jvbm9pKGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LnRvb2x0aXAgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcDtcbiAgICB0b29sdGlwID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQudG9vbHRpcHMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcHM7XG4gICAgdG9vbHRpcHMgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50b29sdGlwQ29udGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0b29sdGlwO1xuICAgIHRvb2x0aXAgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC5zdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGF0ZTtcbiAgICBzdGF0ZSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmRlZmF1bHRTdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkZWZhdWx0U3RhdGU7XG4gICAgZGVmYXVsdFN0YXRlID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgY2hhcnQubm9EYXRhID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vRGF0YTtcbiAgICBub0RhdGEgPSBfO1xuICAgIHJldHVybiBjaGFydDtcbiAgfTtcblxuICBjaGFydC50cmFuc2l0aW9uRHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbnRyb2xzRGF0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjRGF0YTtcbiAgICBjRGF0YSA9IF87XG4gICAgcmV0dXJuIGNoYXJ0O1xuICB9O1xuXG4gIGNoYXJ0LmNvbnRyb2xMYWJlbHMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29udHJvbExhYmVscztcbiAgICBpZiAodHlwZW9mIF8gIT09ICdvYmplY3QnKSByZXR1cm4gY29udHJvbExhYmVscztcbiAgICBjb250cm9sTGFiZWxzID0gXztcbiAgICByZXR1cm4gY2hhcnQ7XG4gIH07XG5cbiAgeUF4aXMuc2V0VGlja0Zvcm1hdCA9IHlBeGlzLnRpY2tGb3JtYXQ7XG5cbiAgeUF4aXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5QXhpc1RpY2tGb3JtYXQ7XG4gICAgeUF4aXNUaWNrRm9ybWF0ID0gXztcbiAgICByZXR1cm4geUF4aXM7XG4gIH07XG5cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHJldHVybiBjaGFydDtcbn1cbn0pKCk7IiwiLyohXG4gKiBCb290c3RyYXAgdjMuMy4wIChodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbSlcbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqL1xuXG5pZiAodHlwZW9mIGpRdWVyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5Jylcbn1cblxuK2Z1bmN0aW9uICgkKSB7XG4gIHZhciB2ZXJzaW9uID0gJC5mbi5qcXVlcnkuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpXG4gIGlmICgodmVyc2lvblswXSA8IDIgJiYgdmVyc2lvblsxXSA8IDkpIHx8ICh2ZXJzaW9uWzBdID09IDEgJiYgdmVyc2lvblsxXSA9PSA5ICYmIHZlcnNpb25bMl0gPCAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeSB2ZXJzaW9uIDEuOS4xIG9yIGhpZ2hlcicpXG4gIH1cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHRyYW5zaXRpb24uanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0cmFuc2l0aW9uc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENTUyBUUkFOU0lUSU9OIFNVUFBPUlQgKFNob3V0b3V0OiBodHRwOi8vd3d3Lm1vZGVybml6ci5jb20vKVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jvb3RzdHJhcCcpXG5cbiAgICB2YXIgdHJhbnNFbmRFdmVudE5hbWVzID0ge1xuICAgICAgV2Via2l0VHJhbnNpdGlvbiA6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgIE1velRyYW5zaXRpb24gICAgOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICBPVHJhbnNpdGlvbiAgICAgIDogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcbiAgICAgIHRyYW5zaXRpb24gICAgICAgOiAndHJhbnNpdGlvbmVuZCdcbiAgICB9XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHRyYW5zRW5kRXZlbnROYW1lcykge1xuICAgICAgaWYgKGVsLnN0eWxlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgZW5kOiB0cmFuc0VuZEV2ZW50TmFtZXNbbmFtZV0gfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSAvLyBleHBsaWNpdCBmb3IgaWU4ICggIC5fLilcbiAgfVxuXG4gIC8vIGh0dHA6Ly9ibG9nLmFsZXhtYWNjYXcuY29tL2Nzcy10cmFuc2l0aW9uc1xuICAkLmZuLmVtdWxhdGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gICAgdmFyICRlbCA9IHRoaXNcbiAgICAkKHRoaXMpLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlIH0pXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyBpZiAoIWNhbGxlZCkgJCgkZWwpLnRyaWdnZXIoJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKSB9XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgZHVyYXRpb24pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gICQoZnVuY3Rpb24gKCkge1xuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkVuZCgpXG5cbiAgICBpZiAoISQuc3VwcG9ydC50cmFuc2l0aW9uKSByZXR1cm5cblxuICAgICQuZXZlbnQuc3BlY2lhbC5ic1RyYW5zaXRpb25FbmQgPSB7XG4gICAgICBiaW5kVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgZGVsZWdhdGVUeXBlOiAkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsXG4gICAgICBoYW5kbGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyh0aGlzKSkgcmV0dXJuIGUuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogYWxlcnQuanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNhbGVydHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBBTEVSVCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgZGlzbWlzcyA9ICdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nXG4gIHZhciBBbGVydCAgID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgJChlbCkub24oJ2NsaWNrJywgZGlzbWlzcywgdGhpcy5jbG9zZSlcbiAgfVxuXG4gIEFsZXJ0LlZFUlNJT04gPSAnMy4zLjAnXG5cbiAgQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIEFsZXJ0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgID0gJCh0aGlzKVxuICAgIHZhciBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgdmFyICRwYXJlbnQgPSAkKHNlbGVjdG9yKVxuXG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgaWYgKCEkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgJHBhcmVudCA9ICR0aGlzLmNsb3Nlc3QoJy5hbGVydCcpXG4gICAgfVxuXG4gICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdjbG9zZS5icy5hbGVydCcpKVxuXG4gICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgJHBhcmVudC5yZW1vdmVDbGFzcygnaW4nKVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCgpIHtcbiAgICAgIC8vIGRldGFjaCBmcm9tIHBhcmVudCwgZmlyZSBldmVudCB0aGVuIGNsZWFuIHVwIGRhdGFcbiAgICAgICRwYXJlbnQuZGV0YWNoKCkudHJpZ2dlcignY2xvc2VkLmJzLmFsZXJ0JykucmVtb3ZlKClcbiAgICB9XG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiAkcGFyZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgJHBhcmVudFxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCByZW1vdmVFbGVtZW50KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgcmVtb3ZlRWxlbWVudCgpXG4gIH1cblxuXG4gIC8vIEFMRVJUIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMuYWxlcnQnKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmFsZXJ0JywgKGRhdGEgPSBuZXcgQWxlcnQodGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXS5jYWxsKCR0aGlzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5hbGVydFxuXG4gICQuZm4uYWxlcnQgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5hbGVydC5Db25zdHJ1Y3RvciA9IEFsZXJ0XG5cblxuICAvLyBBTEVSVCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYWxlcnQubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmFsZXJ0ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQUxFUlQgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMuYWxlcnQuZGF0YS1hcGknLCBkaXNtaXNzLCBBbGVydC5wcm90b3R5cGUuY2xvc2UpXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGJ1dHRvbi5qcyB2My4zLjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2J1dHRvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBCVVRUT04gUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIEJ1dHRvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgPSAkLmV4dGVuZCh7fSwgQnV0dG9uLkRFRkFVTFRTLCBvcHRpb25zKVxuICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2VcbiAgfVxuXG4gIEJ1dHRvbi5WRVJTSU9OICA9ICczLjMuMCdcblxuICBCdXR0b24uREVGQVVMVFMgPSB7XG4gICAgbG9hZGluZ1RleHQ6ICdsb2FkaW5nLi4uJ1xuICB9XG5cbiAgQnV0dG9uLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciBkICAgID0gJ2Rpc2FibGVkJ1xuICAgIHZhciAkZWwgID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciB2YWwgID0gJGVsLmlzKCdpbnB1dCcpID8gJ3ZhbCcgOiAnaHRtbCdcbiAgICB2YXIgZGF0YSA9ICRlbC5kYXRhKClcblxuICAgIHN0YXRlID0gc3RhdGUgKyAnVGV4dCdcblxuICAgIGlmIChkYXRhLnJlc2V0VGV4dCA9PSBudWxsKSAkZWwuZGF0YSgncmVzZXRUZXh0JywgJGVsW3ZhbF0oKSlcblxuICAgIC8vIHB1c2ggdG8gZXZlbnQgbG9vcCB0byBhbGxvdyBmb3JtcyB0byBzdWJtaXRcbiAgICBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgJGVsW3ZhbF0oZGF0YVtzdGF0ZV0gPT0gbnVsbCA/IHRoaXMub3B0aW9uc1tzdGF0ZV0gOiBkYXRhW3N0YXRlXSlcblxuICAgICAgaWYgKHN0YXRlID09ICdsb2FkaW5nVGV4dCcpIHtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlXG4gICAgICAgICRlbC5hZGRDbGFzcyhkKS5hdHRyKGQsIGQpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2VcbiAgICAgICAgJGVsLnJlbW92ZUNsYXNzKGQpLnJlbW92ZUF0dHIoZClcbiAgICAgIH1cbiAgICB9LCB0aGlzKSwgMClcbiAgfVxuXG4gIEJ1dHRvbi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGFuZ2VkID0gdHJ1ZVxuICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5jbG9zZXN0KCdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJylcblxuICAgIGlmICgkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgdmFyICRpbnB1dCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW5wdXQnKVxuICAgICAgaWYgKCRpbnB1dC5wcm9wKCd0eXBlJykgPT0gJ3JhZGlvJykge1xuICAgICAgICBpZiAoJGlucHV0LnByb3AoJ2NoZWNrZWQnKSAmJiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhY3RpdmUnKSkgY2hhbmdlZCA9IGZhbHNlXG4gICAgICAgIGVsc2UgJHBhcmVudC5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlZCkgJGlucHV0LnByb3AoJ2NoZWNrZWQnLCAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpLnRyaWdnZXIoJ2NoYW5nZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1wcmVzc2VkJywgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2FjdGl2ZScpKVxuICAgIH1cblxuICAgIGlmIChjaGFuZ2VkKSB0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCdhY3RpdmUnKVxuICB9XG5cblxuICAvLyBCVVRUT04gUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmJ1dHRvbicpXG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuYnV0dG9uJywgKGRhdGEgPSBuZXcgQnV0dG9uKHRoaXMsIG9wdGlvbnMpKSlcblxuICAgICAgaWYgKG9wdGlvbiA9PSAndG9nZ2xlJykgZGF0YS50b2dnbGUoKVxuICAgICAgZWxzZSBpZiAob3B0aW9uKSBkYXRhLnNldFN0YXRlKG9wdGlvbilcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uYnV0dG9uXG5cbiAgJC5mbi5idXR0b24gICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5idXR0b24uQ29uc3RydWN0b3IgPSBCdXR0b25cblxuXG4gIC8vIEJVVFRPTiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmJ1dHRvbi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uYnV0dG9uID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQlVUVE9OIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKCdjbGljay5icy5idXR0b24uZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlXj1cImJ1dHRvblwiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgJGJ0biA9ICQoZS50YXJnZXQpXG4gICAgICBpZiAoISRidG4uaGFzQ2xhc3MoJ2J0bicpKSAkYnRuID0gJGJ0bi5jbG9zZXN0KCcuYnRuJylcbiAgICAgIFBsdWdpbi5jYWxsKCRidG4sICd0b2dnbGUnKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgfSlcbiAgICAub24oJ2ZvY3VzLmJzLmJ1dHRvbi5kYXRhLWFwaSBibHVyLmJzLmJ1dHRvbi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5idG4nKS50b2dnbGVDbGFzcygnZm9jdXMnLCBlLnR5cGUgPT0gJ2ZvY3VzJylcbiAgICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBjYXJvdXNlbC5qcyB2My4zLjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Nhcm91c2VsXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ0FST1VTRUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIENhcm91c2VsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuJGluZGljYXRvcnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5jYXJvdXNlbC1pbmRpY2F0b3JzJylcbiAgICB0aGlzLm9wdGlvbnMgICAgID0gb3B0aW9uc1xuICAgIHRoaXMucGF1c2VkICAgICAgPVxuICAgIHRoaXMuc2xpZGluZyAgICAgPVxuICAgIHRoaXMuaW50ZXJ2YWwgICAgPVxuICAgIHRoaXMuJGFjdGl2ZSAgICAgPVxuICAgIHRoaXMuJGl0ZW1zICAgICAgPSBudWxsXG5cbiAgICB0aGlzLm9wdGlvbnMua2V5Ym9hcmQgJiYgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi5icy5jYXJvdXNlbCcsICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKSlcblxuICAgIHRoaXMub3B0aW9ucy5wYXVzZSA9PSAnaG92ZXInICYmICEoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSAmJiB0aGlzLiRlbGVtZW50XG4gICAgICAub24oJ21vdXNlZW50ZXIuYnMuY2Fyb3VzZWwnLCAkLnByb3h5KHRoaXMucGF1c2UsIHRoaXMpKVxuICAgICAgLm9uKCdtb3VzZWxlYXZlLmJzLmNhcm91c2VsJywgJC5wcm94eSh0aGlzLmN5Y2xlLCB0aGlzKSlcbiAgfVxuXG4gIENhcm91c2VsLlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIENhcm91c2VsLlRSQU5TSVRJT05fRFVSQVRJT04gPSA2MDBcblxuICBDYXJvdXNlbC5ERUZBVUxUUyA9IHtcbiAgICBpbnRlcnZhbDogNTAwMCxcbiAgICBwYXVzZTogJ2hvdmVyJyxcbiAgICB3cmFwOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICBjYXNlIDM3OiB0aGlzLnByZXYoKTsgYnJlYWtcbiAgICAgIGNhc2UgMzk6IHRoaXMubmV4dCgpOyBicmVha1xuICAgICAgZGVmYXVsdDogcmV0dXJuXG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuY3ljbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUgfHwgKHRoaXMucGF1c2VkID0gZmFsc2UpXG5cbiAgICB0aGlzLmludGVydmFsICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbClcblxuICAgIHRoaXMub3B0aW9ucy5pbnRlcnZhbFxuICAgICAgJiYgIXRoaXMucGF1c2VkXG4gICAgICAmJiAodGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCQucHJveHkodGhpcy5uZXh0LCB0aGlzKSwgdGhpcy5vcHRpb25zLmludGVydmFsKSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0SXRlbUluZGV4ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB0aGlzLiRpdGVtcyA9IGl0ZW0ucGFyZW50KCkuY2hpbGRyZW4oJy5pdGVtJylcbiAgICByZXR1cm4gdGhpcy4kaXRlbXMuaW5kZXgoaXRlbSB8fCB0aGlzLiRhY3RpdmUpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0SXRlbUZvckRpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIGFjdGl2ZSkge1xuICAgIHZhciBkZWx0YSA9IGRpcmVjdGlvbiA9PSAncHJldicgPyAtMSA6IDFcbiAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLmdldEl0ZW1JbmRleChhY3RpdmUpXG4gICAgdmFyIGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuJGl0ZW1zLmxlbmd0aFxuICAgIHJldHVybiB0aGlzLiRpdGVtcy5lcShpdGVtSW5kZXgpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIHRoYXQgICAgICAgID0gdGhpc1xuICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0SXRlbUluZGV4KHRoaXMuJGFjdGl2ZSA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLml0ZW0uYWN0aXZlJykpXG5cbiAgICBpZiAocG9zID4gKHRoaXMuJGl0ZW1zLmxlbmd0aCAtIDEpIHx8IHBvcyA8IDApIHJldHVyblxuXG4gICAgaWYgKHRoaXMuc2xpZGluZykgICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQub25lKCdzbGlkLmJzLmNhcm91c2VsJywgZnVuY3Rpb24gKCkgeyB0aGF0LnRvKHBvcykgfSkgLy8geWVzLCBcInNsaWRcIlxuICAgIGlmIChhY3RpdmVJbmRleCA9PSBwb3MpIHJldHVybiB0aGlzLnBhdXNlKCkuY3ljbGUoKVxuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUocG9zID4gYWN0aXZlSW5kZXggPyAnbmV4dCcgOiAncHJldicsIHRoaXMuJGl0ZW1zLmVxKHBvcykpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUgfHwgKHRoaXMucGF1c2VkID0gdHJ1ZSlcblxuICAgIGlmICh0aGlzLiRlbGVtZW50LmZpbmQoJy5uZXh0LCAucHJldicpLmxlbmd0aCAmJiAkLnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZClcbiAgICAgIHRoaXMuY3ljbGUodHJ1ZSlcbiAgICB9XG5cbiAgICB0aGlzLmludGVydmFsID0gY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNsaWRpbmcpIHJldHVyblxuICAgIHJldHVybiB0aGlzLnNsaWRlKCduZXh0JylcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNsaWRpbmcpIHJldHVyblxuICAgIHJldHVybiB0aGlzLnNsaWRlKCdwcmV2JylcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5zbGlkZSA9IGZ1bmN0aW9uICh0eXBlLCBuZXh0KSB7XG4gICAgdmFyICRhY3RpdmUgICA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLml0ZW0uYWN0aXZlJylcbiAgICB2YXIgJG5leHQgICAgID0gbmV4dCB8fCB0aGlzLmdldEl0ZW1Gb3JEaXJlY3Rpb24odHlwZSwgJGFjdGl2ZSlcbiAgICB2YXIgaXNDeWNsaW5nID0gdGhpcy5pbnRlcnZhbFxuICAgIHZhciBkaXJlY3Rpb24gPSB0eXBlID09ICduZXh0JyA/ICdsZWZ0JyA6ICdyaWdodCdcbiAgICB2YXIgZmFsbGJhY2sgID0gdHlwZSA9PSAnbmV4dCcgPyAnZmlyc3QnIDogJ2xhc3QnXG4gICAgdmFyIHRoYXQgICAgICA9IHRoaXNcblxuICAgIGlmICghJG5leHQubGVuZ3RoKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy53cmFwKSByZXR1cm5cbiAgICAgICRuZXh0ID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXRlbScpW2ZhbGxiYWNrXSgpXG4gICAgfVxuXG4gICAgaWYgKCRuZXh0Lmhhc0NsYXNzKCdhY3RpdmUnKSkgcmV0dXJuICh0aGlzLnNsaWRpbmcgPSBmYWxzZSlcblxuICAgIHZhciByZWxhdGVkVGFyZ2V0ID0gJG5leHRbMF1cbiAgICB2YXIgc2xpZGVFdmVudCA9ICQuRXZlbnQoJ3NsaWRlLmJzLmNhcm91c2VsJywge1xuICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfSlcbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc2xpZGVFdmVudClcbiAgICBpZiAoc2xpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLnNsaWRpbmcgPSB0cnVlXG5cbiAgICBpc0N5Y2xpbmcgJiYgdGhpcy5wYXVzZSgpXG5cbiAgICBpZiAodGhpcy4kaW5kaWNhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuJGluZGljYXRvcnMuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgdmFyICRuZXh0SW5kaWNhdG9yID0gJCh0aGlzLiRpbmRpY2F0b3JzLmNoaWxkcmVuKClbdGhpcy5nZXRJdGVtSW5kZXgoJG5leHQpXSlcbiAgICAgICRuZXh0SW5kaWNhdG9yICYmICRuZXh0SW5kaWNhdG9yLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgIH1cblxuICAgIHZhciBzbGlkRXZlbnQgPSAkLkV2ZW50KCdzbGlkLmJzLmNhcm91c2VsJywgeyByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LCBkaXJlY3Rpb246IGRpcmVjdGlvbiB9KSAvLyB5ZXMsIFwic2xpZFwiXG4gICAgaWYgKCQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3NsaWRlJykpIHtcbiAgICAgICRuZXh0LmFkZENsYXNzKHR5cGUpXG4gICAgICAkbmV4dFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcbiAgICAgICRhY3RpdmUuYWRkQ2xhc3MoZGlyZWN0aW9uKVxuICAgICAgJG5leHQuYWRkQ2xhc3MoZGlyZWN0aW9uKVxuICAgICAgJGFjdGl2ZVxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJG5leHQucmVtb3ZlQ2xhc3MoW3R5cGUsIGRpcmVjdGlvbl0uam9pbignICcpKS5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgICAgICAkYWN0aXZlLnJlbW92ZUNsYXNzKFsnYWN0aXZlJywgZGlyZWN0aW9uXS5qb2luKCcgJykpXG4gICAgICAgICAgdGhhdC5zbGlkaW5nID0gZmFsc2VcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgICAgICAgfSwgMClcbiAgICAgICAgfSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKENhcm91c2VsLlRSQU5TSVRJT05fRFVSQVRJT04pXG4gICAgfSBlbHNlIHtcbiAgICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAkbmV4dC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc2xpZEV2ZW50KVxuICAgIH1cblxuICAgIGlzQ3ljbGluZyAmJiB0aGlzLmN5Y2xlKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENBUk9VU0VMIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmNhcm91c2VsJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIENhcm91c2VsLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuICAgICAgdmFyIGFjdGlvbiAgPSB0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnID8gb3B0aW9uIDogb3B0aW9ucy5zbGlkZVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmNhcm91c2VsJywgKGRhdGEgPSBuZXcgQ2Fyb3VzZWwodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ251bWJlcicpIGRhdGEudG8ob3B0aW9uKVxuICAgICAgZWxzZSBpZiAoYWN0aW9uKSBkYXRhW2FjdGlvbl0oKVxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5pbnRlcnZhbCkgZGF0YS5wYXVzZSgpLmN5Y2xlKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uY2Fyb3VzZWxcblxuICAkLmZuLmNhcm91c2VsICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uY2Fyb3VzZWwuQ29uc3RydWN0b3IgPSBDYXJvdXNlbFxuXG5cbiAgLy8gQ0FST1VTRUwgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmNhcm91c2VsLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5jYXJvdXNlbCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENBUk9VU0VMIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGhyZWZcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICB2YXIgJHRhcmdldCA9ICQoJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSB8fCAoaHJlZiA9ICR0aGlzLmF0dHIoJ2hyZWYnKSkgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykpIC8vIHN0cmlwIGZvciBpZTdcbiAgICBpZiAoISR0YXJnZXQuaGFzQ2xhc3MoJ2Nhcm91c2VsJykpIHJldHVyblxuICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sICR0YXJnZXQuZGF0YSgpLCAkdGhpcy5kYXRhKCkpXG4gICAgdmFyIHNsaWRlSW5kZXggPSAkdGhpcy5hdHRyKCdkYXRhLXNsaWRlLXRvJylcbiAgICBpZiAoc2xpZGVJbmRleCkgb3B0aW9ucy5pbnRlcnZhbCA9IGZhbHNlXG5cbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb25zKVxuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgICR0YXJnZXQuZGF0YSgnYnMuY2Fyb3VzZWwnKS50byhzbGlkZUluZGV4KVxuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpJywgJ1tkYXRhLXNsaWRlXScsIGNsaWNrSGFuZGxlcilcbiAgICAub24oJ2NsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpJywgJ1tkYXRhLXNsaWRlLXRvXScsIGNsaWNrSGFuZGxlcilcblxuICAkKHdpbmRvdykub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJGNhcm91c2VsID0gJCh0aGlzKVxuICAgICAgUGx1Z2luLmNhbGwoJGNhcm91c2VsLCAkY2Fyb3VzZWwuZGF0YSgpKVxuICAgIH0pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGNvbGxhcHNlLmpzIHYzLjMuMFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jY29sbGFwc2VcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDT0xMQVBTRSBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBDb2xsYXBzZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCAgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyAgICAgICA9ICQuZXh0ZW5kKHt9LCBDb2xsYXBzZS5ERUZBVUxUUywgb3B0aW9ucylcbiAgICB0aGlzLiR0cmlnZ2VyICAgICAgPSAkKHRoaXMub3B0aW9ucy50cmlnZ2VyKS5maWx0ZXIoJ1tocmVmPVwiIycgKyBlbGVtZW50LmlkICsgJ1wiXSwgW2RhdGEtdGFyZ2V0PVwiIycgKyBlbGVtZW50LmlkICsgJ1wiXScpXG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gbnVsbFxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuJHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy4kZWxlbWVudCwgdGhpcy4kdHJpZ2dlcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRvZ2dsZSkgdGhpcy50b2dnbGUoKVxuICB9XG5cbiAgQ29sbGFwc2UuVkVSU0lPTiAgPSAnMy4zLjAnXG5cbiAgQ29sbGFwc2UuVFJBTlNJVElPTl9EVVJBVElPTiA9IDM1MFxuXG4gIENvbGxhcHNlLkRFRkFVTFRTID0ge1xuICAgIHRvZ2dsZTogdHJ1ZSxcbiAgICB0cmlnZ2VyOiAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNXaWR0aCA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3dpZHRoJylcbiAgICByZXR1cm4gaGFzV2lkdGggPyAnd2lkdGgnIDogJ2hlaWdodCdcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmcgfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaW4nKSkgcmV0dXJuXG5cbiAgICB2YXIgYWN0aXZlc0RhdGFcbiAgICB2YXIgYWN0aXZlcyA9IHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuZmluZCgnPiAucGFuZWwnKS5jaGlsZHJlbignLmluLCAuY29sbGFwc2luZycpXG5cbiAgICBpZiAoYWN0aXZlcyAmJiBhY3RpdmVzLmxlbmd0aCkge1xuICAgICAgYWN0aXZlc0RhdGEgPSBhY3RpdmVzLmRhdGEoJ2JzLmNvbGxhcHNlJylcbiAgICAgIGlmIChhY3RpdmVzRGF0YSAmJiBhY3RpdmVzRGF0YS50cmFuc2l0aW9uaW5nKSByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgc3RhcnRFdmVudCA9ICQuRXZlbnQoJ3Nob3cuYnMuY29sbGFwc2UnKVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzdGFydEV2ZW50KVxuICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIGlmIChhY3RpdmVzICYmIGFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICBQbHVnaW4uY2FsbChhY3RpdmVzLCAnaGlkZScpXG4gICAgICBhY3RpdmVzRGF0YSB8fCBhY3RpdmVzLmRhdGEoJ2JzLmNvbGxhcHNlJywgbnVsbClcbiAgICB9XG5cbiAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb24oKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzZScpXG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNpbmcnKVtkaW1lbnNpb25dKDApXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICB0aGlzLiR0cmlnZ2VyXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlZCcpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSAxXG5cbiAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2UgaW4nKVtkaW1lbnNpb25dKCcnKVxuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMFxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAudHJpZ2dlcignc2hvd24uYnMuY29sbGFwc2UnKVxuICAgIH1cblxuICAgIGlmICghJC5zdXBwb3J0LnRyYW5zaXRpb24pIHJldHVybiBjb21wbGV0ZS5jYWxsKHRoaXMpXG5cbiAgICB2YXIgc2Nyb2xsU2l6ZSA9ICQuY2FtZWxDYXNlKFsnc2Nyb2xsJywgZGltZW5zaW9uXS5qb2luKCctJykpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KGNvbXBsZXRlLCB0aGlzKSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OKVtkaW1lbnNpb25dKHRoaXMuJGVsZW1lbnRbMF1bc2Nyb2xsU2l6ZV0pXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uaW5nIHx8ICF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpbicpKSByZXR1cm5cblxuICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudCgnaGlkZS5icy5jb2xsYXBzZScpXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKHN0YXJ0RXZlbnQpXG4gICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuZGltZW5zaW9uKClcblxuICAgIHRoaXMuJGVsZW1lbnRbZGltZW5zaW9uXSh0aGlzLiRlbGVtZW50W2RpbWVuc2lvbl0oKSlbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzZSBpbicpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgdGhpcy4kdHJpZ2dlclxuICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZWQnKVxuICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSlcblxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDFcblxuICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDBcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZScpXG4gICAgICAgIC50cmlnZ2VyKCdoaWRkZW4uYnMuY29sbGFwc2UnKVxuICAgIH1cblxuICAgIGlmICghJC5zdXBwb3J0LnRyYW5zaXRpb24pIHJldHVybiBjb21wbGV0ZS5jYWxsKHRoaXMpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICBbZGltZW5zaW9uXSgwKVxuICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgJC5wcm94eShjb21wbGV0ZSwgdGhpcykpXG4gICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQ29sbGFwc2UuVFJBTlNJVElPTl9EVVJBVElPTilcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpc1t0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpbicpID8gJ2hpZGUnIDogJ3Nob3cnXSgpXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAkKHRoaXMub3B0aW9ucy5wYXJlbnQpXG4gICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS1wYXJlbnQ9XCInICsgdGhpcy5vcHRpb25zLnBhcmVudCArICdcIl0nKVxuICAgICAgLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgZWxlbWVudCkge1xuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpXG4gICAgICAgIHRoaXMuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKGdldFRhcmdldEZyb21UcmlnZ2VyKCRlbGVtZW50KSwgJGVsZW1lbnQpXG4gICAgICB9LCB0aGlzKSlcbiAgICAgIC5lbmQoKVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyA9IGZ1bmN0aW9uICgkZWxlbWVudCwgJHRyaWdnZXIpIHtcbiAgICB2YXIgaXNPcGVuID0gJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJylcblxuICAgICRlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pXG4gICAgJHRyaWdnZXJcbiAgICAgIC50b2dnbGVDbGFzcygnY29sbGFwc2VkJywgIWlzT3BlbilcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJHRyaWdnZXIpIHtcbiAgICB2YXIgaHJlZlxuICAgIHZhciB0YXJnZXQgPSAkdHJpZ2dlci5hdHRyKCdkYXRhLXRhcmdldCcpXG4gICAgICB8fCAoaHJlZiA9ICR0cmlnZ2VyLmF0dHIoJ2hyZWYnKSkgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuXG4gICAgcmV0dXJuICQodGFyZ2V0KVxuICB9XG5cblxuICAvLyBDT0xMQVBTRSBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5jb2xsYXBzZScpXG4gICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBDb2xsYXBzZS5ERUZBVUxUUywgJHRoaXMuZGF0YSgpLCB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbilcblxuICAgICAgaWYgKCFkYXRhICYmIG9wdGlvbnMudG9nZ2xlICYmIG9wdGlvbiA9PSAnc2hvdycpIG9wdGlvbnMudG9nZ2xlID0gZmFsc2VcbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuY29sbGFwc2UnLCAoZGF0YSA9IG5ldyBDb2xsYXBzZSh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uY29sbGFwc2VcblxuICAkLmZuLmNvbGxhcHNlICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uY29sbGFwc2UuQ29uc3RydWN0b3IgPSBDb2xsYXBzZVxuXG5cbiAgLy8gQ09MTEFQU0UgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmNvbGxhcHNlLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5jb2xsYXBzZSA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENPTExBUFNFIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLmNvbGxhcHNlLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcblxuICAgIGlmICghJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICB2YXIgJHRhcmdldCA9IGdldFRhcmdldEZyb21UcmlnZ2VyKCR0aGlzKVxuICAgIHZhciBkYXRhICAgID0gJHRhcmdldC5kYXRhKCdicy5jb2xsYXBzZScpXG4gICAgdmFyIG9wdGlvbiAgPSBkYXRhID8gJ3RvZ2dsZScgOiAkLmV4dGVuZCh7fSwgJHRoaXMuZGF0YSgpLCB7IHRyaWdnZXI6IHRoaXMgfSlcblxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbilcbiAgfSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogZHJvcGRvd24uanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNkcm9wZG93bnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBEUk9QRE9XTiBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgYmFja2Ryb3AgPSAnLmRyb3Bkb3duLWJhY2tkcm9wJ1xuICB2YXIgdG9nZ2xlICAgPSAnW2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIl0nXG4gIHZhciBEcm9wZG93biA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgJChlbGVtZW50KS5vbignY2xpY2suYnMuZHJvcGRvd24nLCB0aGlzLnRvZ2dsZSlcbiAgfVxuXG4gIERyb3Bkb3duLlZFUlNJT04gPSAnMy4zLjAnXG5cbiAgRHJvcGRvd24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzID0gJCh0aGlzKVxuXG4gICAgaWYgKCR0aGlzLmlzKCcuZGlzYWJsZWQsIDpkaXNhYmxlZCcpKSByZXR1cm5cblxuICAgIHZhciAkcGFyZW50ICA9IGdldFBhcmVudCgkdGhpcylcbiAgICB2YXIgaXNBY3RpdmUgPSAkcGFyZW50Lmhhc0NsYXNzKCdvcGVuJylcblxuICAgIGNsZWFyTWVudXMoKVxuXG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhJHBhcmVudC5jbG9zZXN0KCcubmF2YmFyLW5hdicpLmxlbmd0aCkge1xuICAgICAgICAvLyBpZiBtb2JpbGUgd2UgdXNlIGEgYmFja2Ryb3AgYmVjYXVzZSBjbGljayBldmVudHMgZG9uJ3QgZGVsZWdhdGVcbiAgICAgICAgJCgnPGRpdiBjbGFzcz1cImRyb3Bkb3duLWJhY2tkcm9wXCIvPicpLmluc2VydEFmdGVyKCQodGhpcykpLm9uKCdjbGljaycsIGNsZWFyTWVudXMpXG4gICAgICB9XG5cbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0geyByZWxhdGVkVGFyZ2V0OiB0aGlzIH1cbiAgICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnc2hvdy5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICR0aGlzXG4gICAgICAgIC50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKVxuXG4gICAgICAkcGFyZW50XG4gICAgICAgIC50b2dnbGVDbGFzcygnb3BlbicpXG4gICAgICAgIC50cmlnZ2VyKCdzaG93bi5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCEvKDM4fDQwfDI3fDMyKS8udGVzdChlLndoaWNoKSkgcmV0dXJuXG5cbiAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBpZiAoJHRoaXMuaXMoJy5kaXNhYmxlZCwgOmRpc2FibGVkJykpIHJldHVyblxuXG4gICAgdmFyICRwYXJlbnQgID0gZ2V0UGFyZW50KCR0aGlzKVxuICAgIHZhciBpc0FjdGl2ZSA9ICRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKVxuXG4gICAgaWYgKCghaXNBY3RpdmUgJiYgZS53aGljaCAhPSAyNykgfHwgKGlzQWN0aXZlICYmIGUud2hpY2ggPT0gMjcpKSB7XG4gICAgICBpZiAoZS53aGljaCA9PSAyNykgJHBhcmVudC5maW5kKHRvZ2dsZSkudHJpZ2dlcignZm9jdXMnKVxuICAgICAgcmV0dXJuICR0aGlzLnRyaWdnZXIoJ2NsaWNrJylcbiAgICB9XG5cbiAgICB2YXIgZGVzYyA9ICcgbGk6bm90KC5kaXZpZGVyKTp2aXNpYmxlIGEnXG4gICAgdmFyICRpdGVtcyA9ICRwYXJlbnQuZmluZCgnW3JvbGU9XCJtZW51XCJdJyArIGRlc2MgKyAnLCBbcm9sZT1cImxpc3Rib3hcIl0nICsgZGVzYylcblxuICAgIGlmICghJGl0ZW1zLmxlbmd0aCkgcmV0dXJuXG5cbiAgICB2YXIgaW5kZXggPSAkaXRlbXMuaW5kZXgoZS50YXJnZXQpXG5cbiAgICBpZiAoZS53aGljaCA9PSAzOCAmJiBpbmRleCA+IDApICAgICAgICAgICAgICAgICBpbmRleC0tICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBcbiAgICBpZiAoZS53aGljaCA9PSA0MCAmJiBpbmRleCA8ICRpdGVtcy5sZW5ndGggLSAxKSBpbmRleCsrICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG93blxuICAgIGlmICghfmluZGV4KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwXG5cbiAgICAkaXRlbXMuZXEoaW5kZXgpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyTWVudXMoZSkge1xuICAgIGlmIChlICYmIGUud2hpY2ggPT09IDMpIHJldHVyblxuICAgICQoYmFja2Ryb3ApLnJlbW92ZSgpXG4gICAgJCh0b2dnbGUpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgICAgICAgPSAkKHRoaXMpXG4gICAgICB2YXIgJHBhcmVudCAgICAgICA9IGdldFBhcmVudCgkdGhpcylcbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0geyByZWxhdGVkVGFyZ2V0OiB0aGlzIH1cblxuICAgICAgaWYgKCEkcGFyZW50Lmhhc0NsYXNzKCdvcGVuJykpIHJldHVyblxuXG4gICAgICAkcGFyZW50LnRyaWdnZXIoZSA9ICQuRXZlbnQoJ2hpZGUuYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KSlcblxuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgICAkdGhpcy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJylcbiAgICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoJ29wZW4nKS50cmlnZ2VyKCdoaWRkZW4uYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJlbnQoJHRoaXMpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiAvI1tBLVphLXpdLy50ZXN0KHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIHZhciAkcGFyZW50ID0gc2VsZWN0b3IgJiYgJChzZWxlY3RvcilcblxuICAgIHJldHVybiAkcGFyZW50ICYmICRwYXJlbnQubGVuZ3RoID8gJHBhcmVudCA6ICR0aGlzLnBhcmVudCgpXG4gIH1cblxuXG4gIC8vIERST1BET1dOIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMuZHJvcGRvd24nKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmRyb3Bkb3duJywgKGRhdGEgPSBuZXcgRHJvcGRvd24odGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXS5jYWxsKCR0aGlzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5kcm9wZG93blxuXG4gICQuZm4uZHJvcGRvd24gICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5kcm9wZG93bi5Db25zdHJ1Y3RvciA9IERyb3Bkb3duXG5cblxuICAvLyBEUk9QRE9XTiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uZHJvcGRvd24ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmRyb3Bkb3duID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQVBQTFkgVE8gU1RBTkRBUkQgRFJPUERPV04gRUxFTUVOVFNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCBjbGVhck1lbnVzKVxuICAgIC5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCAnLmRyb3Bkb3duIGZvcm0nLCBmdW5jdGlvbiAoZSkgeyBlLnN0b3BQcm9wYWdhdGlvbigpIH0pXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIHRvZ2dsZSwgRHJvcGRvd24ucHJvdG90eXBlLnRvZ2dsZSlcbiAgICAub24oJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknLCB0b2dnbGUsIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsICdbcm9sZT1cIm1lbnVcIl0nLCBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93bilcbiAgICAub24oJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknLCAnW3JvbGU9XCJsaXN0Ym94XCJdJywgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IG1vZGFsLmpzIHYzLjMuMFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jbW9kYWxzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gTU9EQUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIE1vZGFsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgID0gb3B0aW9uc1xuICAgIHRoaXMuJGJvZHkgICAgICAgICAgPSAkKGRvY3VtZW50LmJvZHkpXG4gICAgdGhpcy4kZWxlbWVudCAgICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLiRiYWNrZHJvcCAgICAgID1cbiAgICB0aGlzLmlzU2hvd24gICAgICAgID0gbnVsbFxuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggPSAwXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbW90ZSkge1xuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAuZmluZCgnLm1vZGFsLWNvbnRlbnQnKVxuICAgICAgICAubG9hZCh0aGlzLm9wdGlvbnMucmVtb3RlLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2xvYWRlZC5icy5tb2RhbCcpXG4gICAgICAgIH0sIHRoaXMpKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04gPSAzMDBcbiAgTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIE1vZGFsLkRFRkFVTFRTID0ge1xuICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlLFxuICAgIHNob3c6IHRydWVcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChfcmVsYXRlZFRhcmdldCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciBlICAgID0gJC5FdmVudCgnc2hvdy5icy5tb2RhbCcsIHsgcmVsYXRlZFRhcmdldDogX3JlbGF0ZWRUYXJnZXQgfSlcblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKHRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IHRydWVcblxuICAgIHRoaXMuY2hlY2tTY3JvbGxiYXIoKVxuICAgIHRoaXMuJGJvZHkuYWRkQ2xhc3MoJ21vZGFsLW9wZW4nKVxuXG4gICAgdGhpcy5zZXRTY3JvbGxiYXIoKVxuICAgIHRoaXMuZXNjYXBlKClcblxuICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJywgJC5wcm94eSh0aGlzLmhpZGUsIHRoaXMpKVxuXG4gICAgdGhpcy5iYWNrZHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9ICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoYXQuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKVxuXG4gICAgICBpZiAoIXRoYXQuJGVsZW1lbnQucGFyZW50KCkubGVuZ3RoKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnQuYXBwZW5kVG8odGhhdC4kYm9keSkgLy8gZG9uJ3QgbW92ZSBtb2RhbHMgZG9tIHBvc2l0aW9uXG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLnNob3coKVxuICAgICAgICAuc2Nyb2xsVG9wKDApXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLmFkZENsYXNzKCdpbicpXG4gICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKVxuXG4gICAgICB0aGF0LmVuZm9yY2VGb2N1cygpXG5cbiAgICAgIHZhciBlID0gJC5FdmVudCgnc2hvd24uYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICAgIHRyYW5zaXRpb24gP1xuICAgICAgICB0aGF0LiRlbGVtZW50LmZpbmQoJy5tb2RhbC1kaWFsb2cnKSAvLyB3YWl0IGZvciBtb2RhbCB0byBzbGlkZSBpblxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcihlKVxuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgZSA9ICQuRXZlbnQoJ2hpZGUuYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAoIXRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IGZhbHNlXG5cbiAgICB0aGlzLmVzY2FwZSgpXG5cbiAgICAkKGRvY3VtZW50KS5vZmYoJ2ZvY3VzaW4uYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLnJlbW92ZUNsYXNzKCdpbicpXG4gICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKVxuICAgICAgLm9mZignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcpXG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KHRoaXMuaGlkZU1vZGFsLCB0aGlzKSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIHRoaXMuaGlkZU1vZGFsKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5lbmZvcmNlRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgJChkb2N1bWVudClcbiAgICAgIC5vZmYoJ2ZvY3VzaW4uYnMubW9kYWwnKSAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcbiAgICAgIC5vbignZm9jdXNpbi5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0gIT09IGUudGFyZ2V0ICYmICF0aGlzLiRlbGVtZW50LmhhcyhlLnRhcmdldCkubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmVzY2FwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1Nob3duICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLndoaWNoID09IDI3ICYmIHRoaXMuaGlkZSgpXG4gICAgICB9LCB0aGlzKSlcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24pIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdrZXlkb3duLmRpc21pc3MuYnMubW9kYWwnKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5oaWRlTW9kYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdGhpcy4kZWxlbWVudC5oaWRlKClcbiAgICB0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGJvZHkucmVtb3ZlQ2xhc3MoJ21vZGFsLW9wZW4nKVxuICAgICAgdGhhdC5yZXNldFNjcm9sbGJhcigpXG4gICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2hpZGRlbi5icy5tb2RhbCcpXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZW1vdmVCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRiYWNrZHJvcCAmJiB0aGlzLiRiYWNrZHJvcC5yZW1vdmUoKVxuICAgIHRoaXMuJGJhY2tkcm9wID0gbnVsbFxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmJhY2tkcm9wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyIGFuaW1hdGUgPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgPyAnZmFkZScgOiAnJ1xuXG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMuYmFja2Ryb3ApIHtcbiAgICAgIHZhciBkb0FuaW1hdGUgPSAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiBhbmltYXRlXG5cbiAgICAgIHRoaXMuJGJhY2tkcm9wID0gJCgnPGRpdiBjbGFzcz1cIm1vZGFsLWJhY2tkcm9wICcgKyBhbmltYXRlICsgJ1wiIC8+JylcbiAgICAgICAgLnByZXBlbmRUbyh0aGlzLiRlbGVtZW50KVxuICAgICAgICAub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQpIHJldHVyblxuICAgICAgICAgIHRoaXMub3B0aW9ucy5iYWNrZHJvcCA9PSAnc3RhdGljJ1xuICAgICAgICAgICAgPyB0aGlzLiRlbGVtZW50WzBdLmZvY3VzLmNhbGwodGhpcy4kZWxlbWVudFswXSlcbiAgICAgICAgICAgIDogdGhpcy5oaWRlLmNhbGwodGhpcylcbiAgICAgICAgfSwgdGhpcykpXG5cbiAgICAgIGlmIChkb0FuaW1hdGUpIHRoaXMuJGJhY2tkcm9wWzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuXG4gICAgICB0aGlzLiRiYWNrZHJvcC5hZGRDbGFzcygnaW4nKVxuXG4gICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm5cblxuICAgICAgZG9BbmltYXRlID9cbiAgICAgICAgdGhpcy4kYmFja2Ryb3BcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjYWxsYmFjaylcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjYWxsYmFjaygpXG5cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24gJiYgdGhpcy4kYmFja2Ryb3ApIHtcbiAgICAgIHRoaXMuJGJhY2tkcm9wLnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5yZW1vdmVCYWNrZHJvcCgpXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2tSZW1vdmUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2tSZW1vdmUoKVxuXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5jaGVja1Njcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNjcm9sbGJhcldpZHRoID0gdGhpcy5tZWFzdXJlU2Nyb2xsYmFyKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5zZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvZHlQYWQgPSBwYXJzZUludCgodGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnKSB8fCAwKSwgMTApXG4gICAgaWYgKHRoaXMuc2Nyb2xsYmFyV2lkdGgpIHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgYm9keVBhZCArIHRoaXMuc2Nyb2xsYmFyV2lkdGgpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCAnJylcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5tZWFzdXJlU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkgeyAvLyB0aHggd2Fsc2hcbiAgICBpZiAoZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCA+PSB3aW5kb3cuaW5uZXJXaWR0aCkgcmV0dXJuIDBcbiAgICB2YXIgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gJ21vZGFsLXNjcm9sbGJhci1tZWFzdXJlJ1xuICAgIHRoaXMuJGJvZHkuYXBwZW5kKHNjcm9sbERpdilcbiAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYub2Zmc2V0V2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGhcbiAgICB0aGlzLiRib2R5WzBdLnJlbW92ZUNoaWxkKHNjcm9sbERpdilcbiAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGhcbiAgfVxuXG5cbiAgLy8gTU9EQUwgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uLCBfcmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLm1vZGFsJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIE1vZGFsLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLm1vZGFsJywgKGRhdGEgPSBuZXcgTW9kYWwodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXShfcmVsYXRlZFRhcmdldClcbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2hvdykgZGF0YS5zaG93KF9yZWxhdGVkVGFyZ2V0KVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5tb2RhbFxuXG4gICQuZm4ubW9kYWwgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5tb2RhbC5Db25zdHJ1Y3RvciA9IE1vZGFsXG5cblxuICAvLyBNT0RBTCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4ubW9kYWwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLm1vZGFsID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gTU9EQUwgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMubW9kYWwuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwibW9kYWxcIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgIHZhciBocmVmICAgID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgdmFyICR0YXJnZXQgPSAkKCR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JykgfHwgKGhyZWYgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykpKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgdmFyIG9wdGlvbiAgPSAkdGFyZ2V0LmRhdGEoJ2JzLm1vZGFsJykgPyAndG9nZ2xlJyA6ICQuZXh0ZW5kKHsgcmVtb3RlOiAhLyMvLnRlc3QoaHJlZikgJiYgaHJlZiB9LCAkdGFyZ2V0LmRhdGEoKSwgJHRoaXMuZGF0YSgpKVxuXG4gICAgaWYgKCR0aGlzLmlzKCdhJykpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgJHRhcmdldC5vbmUoJ3Nob3cuYnMubW9kYWwnLCBmdW5jdGlvbiAoc2hvd0V2ZW50KSB7XG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm4gLy8gb25seSByZWdpc3RlciBmb2N1cyByZXN0b3JlciBpZiBtb2RhbCB3aWxsIGFjdHVhbGx5IGdldCBzaG93blxuICAgICAgJHRhcmdldC5vbmUoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJHRoaXMuaXMoJzp2aXNpYmxlJykgJiYgJHRoaXMudHJpZ2dlcignZm9jdXMnKVxuICAgICAgfSlcbiAgICB9KVxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbiwgdGhpcylcbiAgfSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogdG9vbHRpcC5qcyB2My4zLjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3Rvb2x0aXBcbiAqIEluc3BpcmVkIGJ5IHRoZSBvcmlnaW5hbCBqUXVlcnkudGlwc3kgYnkgSmFzb24gRnJhbWVcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBUT09MVElQIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgVG9vbHRpcCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlICAgICAgID1cbiAgICB0aGlzLm9wdGlvbnMgICAgPVxuICAgIHRoaXMuZW5hYmxlZCAgICA9XG4gICAgdGhpcy50aW1lb3V0ICAgID1cbiAgICB0aGlzLmhvdmVyU3RhdGUgPVxuICAgIHRoaXMuJGVsZW1lbnQgICA9IG51bGxcblxuICAgIHRoaXMuaW5pdCgndG9vbHRpcCcsIGVsZW1lbnQsIG9wdGlvbnMpXG4gIH1cblxuICBUb29sdGlwLlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIFRvb2x0aXAuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIFRvb2x0aXAuREVGQVVMVFMgPSB7XG4gICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgc2VsZWN0b3I6IGZhbHNlLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGRlbGF5OiAwLFxuICAgIGh0bWw6IGZhbHNlLFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgdmlld3BvcnQ6IHtcbiAgICAgIHNlbGVjdG9yOiAnYm9keScsXG4gICAgICBwYWRkaW5nOiAwXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh0eXBlLCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbmFibGVkICAgPSB0cnVlXG4gICAgdGhpcy50eXBlICAgICAgPSB0eXBlXG4gICAgdGhpcy4kZWxlbWVudCAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgPSB0aGlzLmdldE9wdGlvbnMob3B0aW9ucylcbiAgICB0aGlzLiR2aWV3cG9ydCA9IHRoaXMub3B0aW9ucy52aWV3cG9ydCAmJiAkKHRoaXMub3B0aW9ucy52aWV3cG9ydC5zZWxlY3RvciB8fCB0aGlzLm9wdGlvbnMudmlld3BvcnQpXG5cbiAgICB2YXIgdHJpZ2dlcnMgPSB0aGlzLm9wdGlvbnMudHJpZ2dlci5zcGxpdCgnICcpXG5cbiAgICBmb3IgKHZhciBpID0gdHJpZ2dlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICB2YXIgdHJpZ2dlciA9IHRyaWdnZXJzW2ldXG5cbiAgICAgIGlmICh0cmlnZ2VyID09ICdjbGljaycpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMudG9nZ2xlLCB0aGlzKSlcbiAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAhPSAnbWFudWFsJykge1xuICAgICAgICB2YXIgZXZlbnRJbiAgPSB0cmlnZ2VyID09ICdob3ZlcicgPyAnbW91c2VlbnRlcicgOiAnZm9jdXNpbidcbiAgICAgICAgdmFyIGV2ZW50T3V0ID0gdHJpZ2dlciA9PSAnaG92ZXInID8gJ21vdXNlbGVhdmUnIDogJ2ZvY3Vzb3V0J1xuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oZXZlbnRJbiAgKyAnLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLmVudGVyLCB0aGlzKSlcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbihldmVudE91dCArICcuJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMubGVhdmUsIHRoaXMpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5zZWxlY3RvciA/XG4gICAgICAodGhpcy5fb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIHsgdHJpZ2dlcjogJ21hbnVhbCcsIHNlbGVjdG9yOiAnJyB9KSkgOlxuICAgICAgdGhpcy5maXhUaXRsZSgpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXREZWZhdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVG9vbHRpcC5ERUZBVUxUU1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0aGlzLmdldERlZmF1bHRzKCksIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKVxuXG4gICAgaWYgKG9wdGlvbnMuZGVsYXkgJiYgdHlwZW9mIG9wdGlvbnMuZGVsYXkgPT0gJ251bWJlcicpIHtcbiAgICAgIG9wdGlvbnMuZGVsYXkgPSB7XG4gICAgICAgIHNob3c6IG9wdGlvbnMuZGVsYXksXG4gICAgICAgIGhpZGU6IG9wdGlvbnMuZGVsYXlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0RGVsZWdhdGVPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zICA9IHt9XG4gICAgdmFyIGRlZmF1bHRzID0gdGhpcy5nZXREZWZhdWx0cygpXG5cbiAgICB0aGlzLl9vcHRpb25zICYmICQuZWFjaCh0aGlzLl9vcHRpb25zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGRlZmF1bHRzW2tleV0gIT0gdmFsdWUpIG9wdGlvbnNba2V5XSA9IHZhbHVlXG4gICAgfSlcblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgc2VsZiA9IG9iaiBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IgP1xuICAgICAgb2JqIDogJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGlmIChzZWxmICYmIHNlbGYuJHRpcCAmJiBzZWxmLiR0aXAuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgIHNlbGYuaG92ZXJTdGF0ZSA9ICdpbidcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc2VsZikge1xuICAgICAgc2VsZiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG9iai5jdXJyZW50VGFyZ2V0LCB0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKVxuICAgICAgJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgc2VsZilcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KVxuXG4gICAgc2VsZi5ob3ZlclN0YXRlID0gJ2luJ1xuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMuZGVsYXkgfHwgIXNlbGYub3B0aW9ucy5kZWxheS5zaG93KSByZXR1cm4gc2VsZi5zaG93KClcblxuICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaG92ZXJTdGF0ZSA9PSAnaW4nKSBzZWxmLnNob3coKVxuICAgIH0sIHNlbGYub3B0aW9ucy5kZWxheS5zaG93KVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHNlbGYgPSBvYmogaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yID9cbiAgICAgIG9iaiA6ICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBpZiAoIXNlbGYpIHtcbiAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihvYmouY3VycmVudFRhcmdldCwgdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSlcbiAgICAgICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHNlbGYpXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dClcblxuICAgIHNlbGYuaG92ZXJTdGF0ZSA9ICdvdXQnXG5cbiAgICBpZiAoIXNlbGYub3B0aW9ucy5kZWxheSB8fCAhc2VsZi5vcHRpb25zLmRlbGF5LmhpZGUpIHJldHVybiBzZWxmLmhpZGUoKVxuXG4gICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5ob3ZlclN0YXRlID09ICdvdXQnKSBzZWxmLmhpZGUoKVxuICAgIH0sIHNlbGYub3B0aW9ucy5kZWxheS5oaWRlKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9ICQuRXZlbnQoJ3Nob3cuYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGlmICh0aGlzLmhhc0NvbnRlbnQoKSAmJiB0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgICB2YXIgaW5Eb20gPSAkLmNvbnRhaW5zKHRoaXMuJGVsZW1lbnRbMF0ub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuJGVsZW1lbnRbMF0pXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCAhaW5Eb20pIHJldHVyblxuICAgICAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgICAgIHZhciAkdGlwID0gdGhpcy50aXAoKVxuXG4gICAgICB2YXIgdGlwSWQgPSB0aGlzLmdldFVJRCh0aGlzLnR5cGUpXG5cbiAgICAgIHRoaXMuc2V0Q29udGVudCgpXG4gICAgICAkdGlwLmF0dHIoJ2lkJywgdGlwSWQpXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXBJZClcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb24pICR0aXAuYWRkQ2xhc3MoJ2ZhZGUnKVxuXG4gICAgICB2YXIgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQgPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQuY2FsbCh0aGlzLCAkdGlwWzBdLCB0aGlzLiRlbGVtZW50WzBdKSA6XG4gICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnRcblxuICAgICAgdmFyIGF1dG9Ub2tlbiA9IC9cXHM/YXV0bz9cXHM/L2lcbiAgICAgIHZhciBhdXRvUGxhY2UgPSBhdXRvVG9rZW4udGVzdChwbGFjZW1lbnQpXG4gICAgICBpZiAoYXV0b1BsYWNlKSBwbGFjZW1lbnQgPSBwbGFjZW1lbnQucmVwbGFjZShhdXRvVG9rZW4sICcnKSB8fCAndG9wJ1xuXG4gICAgICAkdGlwXG4gICAgICAgIC5kZXRhY2goKVxuICAgICAgICAuY3NzKHsgdG9wOiAwLCBsZWZ0OiAwLCBkaXNwbGF5OiAnYmxvY2snIH0pXG4gICAgICAgIC5hZGRDbGFzcyhwbGFjZW1lbnQpXG4gICAgICAgIC5kYXRhKCdicy4nICsgdGhpcy50eXBlLCB0aGlzKVxuXG4gICAgICB0aGlzLm9wdGlvbnMuY29udGFpbmVyID8gJHRpcC5hcHBlbmRUbyh0aGlzLm9wdGlvbnMuY29udGFpbmVyKSA6ICR0aXAuaW5zZXJ0QWZ0ZXIodGhpcy4kZWxlbWVudClcblxuICAgICAgdmFyIHBvcyAgICAgICAgICA9IHRoaXMuZ2V0UG9zaXRpb24oKVxuICAgICAgdmFyIGFjdHVhbFdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICAgIHZhciBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodFxuXG4gICAgICBpZiAoYXV0b1BsYWNlKSB7XG4gICAgICAgIHZhciBvcmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRcbiAgICAgICAgdmFyICRjb250YWluZXIgICA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgPyAkKHRoaXMub3B0aW9ucy5jb250YWluZXIpIDogdGhpcy4kZWxlbWVudC5wYXJlbnQoKVxuICAgICAgICB2YXIgY29udGFpbmVyRGltID0gdGhpcy5nZXRQb3NpdGlvbigkY29udGFpbmVyKVxuXG4gICAgICAgIHBsYWNlbWVudCA9IHBsYWNlbWVudCA9PSAnYm90dG9tJyAmJiBwb3MuYm90dG9tICsgYWN0dWFsSGVpZ2h0ID4gY29udGFpbmVyRGltLmJvdHRvbSA/ICd0b3AnICAgIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICd0b3AnICAgICYmIHBvcy50b3AgICAgLSBhY3R1YWxIZWlnaHQgPCBjb250YWluZXJEaW0udG9wICAgID8gJ2JvdHRvbScgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ3JpZ2h0JyAgJiYgcG9zLnJpZ2h0ICArIGFjdHVhbFdpZHRoICA+IGNvbnRhaW5lckRpbS53aWR0aCAgPyAnbGVmdCcgICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAnbGVmdCcgICAmJiBwb3MubGVmdCAgIC0gYWN0dWFsV2lkdGggIDwgY29udGFpbmVyRGltLmxlZnQgICA/ICdyaWdodCcgIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50XG5cbiAgICAgICAgJHRpcFxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhvcmdQbGFjZW1lbnQpXG4gICAgICAgICAgLmFkZENsYXNzKHBsYWNlbWVudClcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbGN1bGF0ZWRPZmZzZXQgPSB0aGlzLmdldENhbGN1bGF0ZWRPZmZzZXQocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpXG5cbiAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoY2FsY3VsYXRlZE9mZnNldCwgcGxhY2VtZW50KVxuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2SG92ZXJTdGF0ZSA9IHRoYXQuaG92ZXJTdGF0ZVxuICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ3Nob3duLmJzLicgKyB0aGF0LnR5cGUpXG4gICAgICAgIHRoYXQuaG92ZXJTdGF0ZSA9IG51bGxcblxuICAgICAgICBpZiAocHJldkhvdmVyU3RhdGUgPT0gJ291dCcpIHRoYXQubGVhdmUodGhhdClcbiAgICAgIH1cblxuICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kdGlwLmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgICAkdGlwXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY29tcGxldGUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRvb2x0aXAuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjb21wbGV0ZSgpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuYXBwbHlQbGFjZW1lbnQgPSBmdW5jdGlvbiAob2Zmc2V0LCBwbGFjZW1lbnQpIHtcbiAgICB2YXIgJHRpcCAgID0gdGhpcy50aXAoKVxuICAgIHZhciB3aWR0aCAgPSAkdGlwWzBdLm9mZnNldFdpZHRoXG4gICAgdmFyIGhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICAvLyBtYW51YWxseSByZWFkIG1hcmdpbnMgYmVjYXVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaW5jbHVkZXMgZGlmZmVyZW5jZVxuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUludCgkdGlwLmNzcygnbWFyZ2luLXRvcCcpLCAxMClcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlSW50KCR0aXAuY3NzKCdtYXJnaW4tbGVmdCcpLCAxMClcblxuICAgIC8vIHdlIG11c3QgY2hlY2sgZm9yIE5hTiBmb3IgaWUgOC85XG4gICAgaWYgKGlzTmFOKG1hcmdpblRvcCkpICBtYXJnaW5Ub3AgID0gMFxuICAgIGlmIChpc05hTihtYXJnaW5MZWZ0KSkgbWFyZ2luTGVmdCA9IDBcblxuICAgIG9mZnNldC50b3AgID0gb2Zmc2V0LnRvcCAgKyBtYXJnaW5Ub3BcbiAgICBvZmZzZXQubGVmdCA9IG9mZnNldC5sZWZ0ICsgbWFyZ2luTGVmdFxuXG4gICAgLy8gJC5mbi5vZmZzZXQgZG9lc24ndCByb3VuZCBwaXhlbCB2YWx1ZXNcbiAgICAvLyBzbyB3ZSB1c2Ugc2V0T2Zmc2V0IGRpcmVjdGx5IHdpdGggb3VyIG93biBmdW5jdGlvbiBCLTBcbiAgICAkLm9mZnNldC5zZXRPZmZzZXQoJHRpcFswXSwgJC5leHRlbmQoe1xuICAgICAgdXNpbmc6IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAkdGlwLmNzcyh7XG4gICAgICAgICAgdG9wOiBNYXRoLnJvdW5kKHByb3BzLnRvcCksXG4gICAgICAgICAgbGVmdDogTWF0aC5yb3VuZChwcm9wcy5sZWZ0KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sIG9mZnNldCksIDApXG5cbiAgICAkdGlwLmFkZENsYXNzKCdpbicpXG5cbiAgICAvLyBjaGVjayB0byBzZWUgaWYgcGxhY2luZyB0aXAgaW4gbmV3IG9mZnNldCBjYXVzZWQgdGhlIHRpcCB0byByZXNpemUgaXRzZWxmXG4gICAgdmFyIGFjdHVhbFdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICB2YXIgYWN0dWFsSGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgIGlmIChwbGFjZW1lbnQgPT0gJ3RvcCcgJiYgYWN0dWFsSGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgb2Zmc2V0LnRvcCA9IG9mZnNldC50b3AgKyBoZWlnaHQgLSBhY3R1YWxIZWlnaHRcbiAgICB9XG5cbiAgICB2YXIgZGVsdGEgPSB0aGlzLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YShwbGFjZW1lbnQsIG9mZnNldCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodClcblxuICAgIGlmIChkZWx0YS5sZWZ0KSBvZmZzZXQubGVmdCArPSBkZWx0YS5sZWZ0XG4gICAgZWxzZSBvZmZzZXQudG9wICs9IGRlbHRhLnRvcFxuXG4gICAgdmFyIGlzVmVydGljYWwgICAgICAgICAgPSAvdG9wfGJvdHRvbS8udGVzdChwbGFjZW1lbnQpXG4gICAgdmFyIGFycm93RGVsdGEgICAgICAgICAgPSBpc1ZlcnRpY2FsID8gZGVsdGEubGVmdCAqIDIgLSB3aWR0aCArIGFjdHVhbFdpZHRoIDogZGVsdGEudG9wICogMiAtIGhlaWdodCArIGFjdHVhbEhlaWdodFxuICAgIHZhciBhcnJvd09mZnNldFBvc2l0aW9uID0gaXNWZXJ0aWNhbCA/ICdvZmZzZXRXaWR0aCcgOiAnb2Zmc2V0SGVpZ2h0J1xuXG4gICAgJHRpcC5vZmZzZXQob2Zmc2V0KVxuICAgIHRoaXMucmVwbGFjZUFycm93KGFycm93RGVsdGEsICR0aXBbMF1bYXJyb3dPZmZzZXRQb3NpdGlvbl0sIGlzVmVydGljYWwpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5yZXBsYWNlQXJyb3cgPSBmdW5jdGlvbiAoZGVsdGEsIGRpbWVuc2lvbiwgaXNIb3Jpem9udGFsKSB7XG4gICAgdGhpcy5hcnJvdygpXG4gICAgICAuY3NzKGlzSG9yaXpvbnRhbCA/ICdsZWZ0JyA6ICd0b3AnLCA1MCAqICgxIC0gZGVsdGEgLyBkaW1lbnNpb24pICsgJyUnKVxuICAgICAgLmNzcyhpc0hvcml6b250YWwgPyAndG9wJyA6ICdsZWZ0JywgJycpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGlwICA9IHRoaXMudGlwKClcbiAgICB2YXIgdGl0bGUgPSB0aGlzLmdldFRpdGxlKClcblxuICAgICR0aXAuZmluZCgnLnRvb2x0aXAtaW5uZXInKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10odGl0bGUpXG4gICAgJHRpcC5yZW1vdmVDbGFzcygnZmFkZSBpbiB0b3AgYm90dG9tIGxlZnQgcmlnaHQnKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciAkdGlwID0gdGhpcy50aXAoKVxuICAgIHZhciBlICAgID0gJC5FdmVudCgnaGlkZS5icy4nICsgdGhpcy50eXBlKVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICBpZiAodGhhdC5ob3ZlclN0YXRlICE9ICdpbicpICR0aXAuZGV0YWNoKClcbiAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKVxuICAgICAgICAudHJpZ2dlcignaGlkZGVuLmJzLicgKyB0aGF0LnR5cGUpXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiR0aXAuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAkdGlwXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNvbXBsZXRlKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVG9vbHRpcC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICBjb21wbGV0ZSgpXG5cbiAgICB0aGlzLmhvdmVyU3RhdGUgPSBudWxsXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZml4VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIGlmICgkZS5hdHRyKCd0aXRsZScpIHx8IHR5cGVvZiAoJGUuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScpKSAhPSAnc3RyaW5nJykge1xuICAgICAgJGUuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScsICRlLmF0dHIoJ3RpdGxlJykgfHwgJycpLmF0dHIoJ3RpdGxlJywgJycpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaGFzQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgkZWxlbWVudCkge1xuICAgICRlbGVtZW50ICAgPSAkZWxlbWVudCB8fCB0aGlzLiRlbGVtZW50XG5cbiAgICB2YXIgZWwgICAgID0gJGVsZW1lbnRbMF1cbiAgICB2YXIgaXNCb2R5ID0gZWwudGFnTmFtZSA9PSAnQk9EWSdcblxuICAgIHZhciBlbFJlY3QgICAgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGlmIChlbFJlY3Qud2lkdGggPT0gbnVsbCkge1xuICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBhcmUgbWlzc2luZyBpbiBJRTgsIHNvIGNvbXB1dGUgdGhlbSBtYW51YWxseTsgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMTQwOTNcbiAgICAgIGVsUmVjdCA9ICQuZXh0ZW5kKHt9LCBlbFJlY3QsIHsgd2lkdGg6IGVsUmVjdC5yaWdodCAtIGVsUmVjdC5sZWZ0LCBoZWlnaHQ6IGVsUmVjdC5ib3R0b20gLSBlbFJlY3QudG9wIH0pXG4gICAgfVxuICAgIHZhciBlbE9mZnNldCAgPSBpc0JvZHkgPyB7IHRvcDogMCwgbGVmdDogMCB9IDogJGVsZW1lbnQub2Zmc2V0KClcbiAgICB2YXIgc2Nyb2xsICAgID0geyBzY3JvbGw6IGlzQm9keSA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgOiAkZWxlbWVudC5zY3JvbGxUb3AoKSB9XG4gICAgdmFyIG91dGVyRGltcyA9IGlzQm9keSA/IHsgd2lkdGg6ICQod2luZG93KS53aWR0aCgpLCBoZWlnaHQ6ICQod2luZG93KS5oZWlnaHQoKSB9IDogbnVsbFxuXG4gICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBlbFJlY3QsIHNjcm9sbCwgb3V0ZXJEaW1zLCBlbE9mZnNldClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldENhbGN1bGF0ZWRPZmZzZXQgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50ID09ICdib3R0b20nID8geyB0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0LCAgIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoIC8gMiAtIGFjdHVhbFdpZHRoIC8gMiAgfSA6XG4gICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICA/IHsgdG9wOiBwb3MudG9wIC0gYWN0dWFsSGVpZ2h0LCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDIgIH0gOlxuICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ2xlZnQnICAgPyB7IHRvcDogcG9zLnRvcCArIHBvcy5oZWlnaHQgLyAyIC0gYWN0dWFsSGVpZ2h0IC8gMiwgbGVmdDogcG9zLmxlZnQgLSBhY3R1YWxXaWR0aCB9IDpcbiAgICAgICAgLyogcGxhY2VtZW50ID09ICdyaWdodCcgKi8geyB0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoICAgfVxuXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRWaWV3cG9ydEFkanVzdGVkRGVsdGEgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICB2YXIgZGVsdGEgPSB7IHRvcDogMCwgbGVmdDogMCB9XG4gICAgaWYgKCF0aGlzLiR2aWV3cG9ydCkgcmV0dXJuIGRlbHRhXG5cbiAgICB2YXIgdmlld3BvcnRQYWRkaW5nID0gdGhpcy5vcHRpb25zLnZpZXdwb3J0ICYmIHRoaXMub3B0aW9ucy52aWV3cG9ydC5wYWRkaW5nIHx8IDBcbiAgICB2YXIgdmlld3BvcnREaW1lbnNpb25zID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLiR2aWV3cG9ydClcblxuICAgIGlmICgvcmlnaHR8bGVmdC8udGVzdChwbGFjZW1lbnQpKSB7XG4gICAgICB2YXIgdG9wRWRnZU9mZnNldCAgICA9IHBvcy50b3AgLSB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsXG4gICAgICB2YXIgYm90dG9tRWRnZU9mZnNldCA9IHBvcy50b3AgKyB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsICsgYWN0dWFsSGVpZ2h0XG4gICAgICBpZiAodG9wRWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy50b3ApIHsgLy8gdG9wIG92ZXJmbG93XG4gICAgICAgIGRlbHRhLnRvcCA9IHZpZXdwb3J0RGltZW5zaW9ucy50b3AgLSB0b3BFZGdlT2Zmc2V0XG4gICAgICB9IGVsc2UgaWYgKGJvdHRvbUVkZ2VPZmZzZXQgPiB2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCkgeyAvLyBib3R0b20gb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEudG9wID0gdmlld3BvcnREaW1lbnNpb25zLnRvcCArIHZpZXdwb3J0RGltZW5zaW9ucy5oZWlnaHQgLSBib3R0b21FZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZWZ0RWRnZU9mZnNldCAgPSBwb3MubGVmdCAtIHZpZXdwb3J0UGFkZGluZ1xuICAgICAgdmFyIHJpZ2h0RWRnZU9mZnNldCA9IHBvcy5sZWZ0ICsgdmlld3BvcnRQYWRkaW5nICsgYWN0dWFsV2lkdGhcbiAgICAgIGlmIChsZWZ0RWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0KSB7IC8vIGxlZnQgb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEubGVmdCA9IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0IC0gbGVmdEVkZ2VPZmZzZXRcbiAgICAgIH0gZWxzZSBpZiAocmlnaHRFZGdlT2Zmc2V0ID4gdmlld3BvcnREaW1lbnNpb25zLndpZHRoKSB7IC8vIHJpZ2h0IG92ZXJmbG93XG4gICAgICAgIGRlbHRhLmxlZnQgPSB2aWV3cG9ydERpbWVuc2lvbnMubGVmdCArIHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aCAtIHJpZ2h0RWRnZU9mZnNldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWx0YVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpdGxlXG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgdGl0bGUgPSAkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcbiAgICAgIHx8ICh0eXBlb2Ygby50aXRsZSA9PSAnZnVuY3Rpb24nID8gby50aXRsZS5jYWxsKCRlWzBdKSA6ICBvLnRpdGxlKVxuXG4gICAgcmV0dXJuIHRpdGxlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRVSUQgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgZG8gcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKVxuICAgIHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKVxuICAgIHJldHVybiBwcmVmaXhcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJHRpcCA9IHRoaXMuJHRpcCB8fCAkKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSkpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJGFycm93ID0gdGhpcy4kYXJyb3cgfHwgdGhpcy50aXAoKS5maW5kKCcudG9vbHRpcC1hcnJvdycpKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2VcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gIXRoaXMuZW5hYmxlZFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBpZiAoZSkge1xuICAgICAgc2VsZiA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuICAgICAgaWYgKCFzZWxmKSB7XG4gICAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihlLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYudGlwKCkuaGFzQ2xhc3MoJ2luJykgPyBzZWxmLmxlYXZlKHNlbGYpIDogc2VsZi5lbnRlcihzZWxmKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgIHRoaXMuaGlkZShmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRlbGVtZW50Lm9mZignLicgKyB0aGF0LnR5cGUpLnJlbW92ZURhdGEoJ2JzLicgKyB0aGF0LnR5cGUpXG4gICAgfSlcbiAgfVxuXG5cbiAgLy8gVE9PTFRJUCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgID0gJHRoaXMuZGF0YSgnYnMudG9vbHRpcCcpXG4gICAgICB2YXIgb3B0aW9ucyAgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuICAgICAgdmFyIHNlbGVjdG9yID0gb3B0aW9ucyAmJiBvcHRpb25zLnNlbGVjdG9yXG5cbiAgICAgIGlmICghZGF0YSAmJiBvcHRpb24gPT0gJ2Rlc3Ryb3knKSByZXR1cm5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnRvb2x0aXAnLCAoZGF0YSA9IHt9KSlcbiAgICAgICAgaWYgKCFkYXRhW3NlbGVjdG9yXSkgZGF0YVtzZWxlY3Rvcl0gPSBuZXcgVG9vbHRpcCh0aGlzLCBvcHRpb25zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy50b29sdGlwJywgKGRhdGEgPSBuZXcgVG9vbHRpcCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4udG9vbHRpcFxuXG4gICQuZm4udG9vbHRpcCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IgPSBUb29sdGlwXG5cblxuICAvLyBUT09MVElQIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLnRvb2x0aXAubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnRvb2x0aXAgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHBvcG92ZXIuanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNwb3BvdmVyc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFBPUE9WRVIgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBQb3BvdmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmluaXQoJ3BvcG92ZXInLCBlbGVtZW50LCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKCEkLmZuLnRvb2x0aXApIHRocm93IG5ldyBFcnJvcignUG9wb3ZlciByZXF1aXJlcyB0b29sdGlwLmpzJylcblxuICBQb3BvdmVyLlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIFBvcG92ZXIuREVGQVVMVFMgPSAkLmV4dGVuZCh7fSwgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yLkRFRkFVTFRTLCB7XG4gICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgY29udGVudDogJycsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+PGgzIGNsYXNzPVwicG9wb3Zlci10aXRsZVwiPjwvaDM+PGRpdiBjbGFzcz1cInBvcG92ZXItY29udGVudFwiPjwvZGl2PjwvZGl2PidcbiAgfSlcblxuXG4gIC8vIE5PVEU6IFBPUE9WRVIgRVhURU5EUyB0b29sdGlwLmpzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUgPSAkLmV4dGVuZCh7fSwgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yLnByb3RvdHlwZSlcblxuICBQb3BvdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvcG92ZXJcblxuICBQb3BvdmVyLnByb3RvdHlwZS5nZXREZWZhdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUG9wb3Zlci5ERUZBVUxUU1xuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRpcCAgICA9IHRoaXMudGlwKClcbiAgICB2YXIgdGl0bGUgICA9IHRoaXMuZ2V0VGl0bGUoKVxuICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KClcblxuICAgICR0aXAuZmluZCgnLnBvcG92ZXItdGl0bGUnKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10odGl0bGUpXG4gICAgJHRpcC5maW5kKCcucG9wb3Zlci1jb250ZW50JykuY2hpbGRyZW4oKS5kZXRhY2goKS5lbmQoKVsgLy8gd2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xuICAgICAgdGhpcy5vcHRpb25zLmh0bWwgPyAodHlwZW9mIGNvbnRlbnQgPT0gJ3N0cmluZycgPyAnaHRtbCcgOiAnYXBwZW5kJykgOiAndGV4dCdcbiAgICBdKGNvbnRlbnQpXG5cbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdmYWRlIHRvcCBib3R0b20gbGVmdCByaWdodCBpbicpXG5cbiAgICAvLyBJRTggZG9lc24ndCBhY2NlcHQgaGlkaW5nIHZpYSB0aGUgYDplbXB0eWAgcHNldWRvIHNlbGVjdG9yLCB3ZSBoYXZlIHRvIGRvXG4gICAgLy8gdGhpcyBtYW51YWxseSBieSBjaGVja2luZyB0aGUgY29udGVudHMuXG4gICAgaWYgKCEkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJykuaHRtbCgpKSAkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJykuaGlkZSgpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5oYXNDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCkgfHwgdGhpcy5nZXRDb250ZW50KClcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgcmV0dXJuICRlLmF0dHIoJ2RhdGEtY29udGVudCcpXG4gICAgICB8fCAodHlwZW9mIG8uY29udGVudCA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIG8uY29udGVudC5jYWxsKCRlWzBdKSA6XG4gICAgICAgICAgICBvLmNvbnRlbnQpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJGFycm93ID0gdGhpcy4kYXJyb3cgfHwgdGhpcy50aXAoKS5maW5kKCcuYXJyb3cnKSlcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLnRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuJHRpcCkgdGhpcy4kdGlwID0gJCh0aGlzLm9wdGlvbnMudGVtcGxhdGUpXG4gICAgcmV0dXJuIHRoaXMuJHRpcFxuICB9XG5cblxuICAvLyBQT1BPVkVSIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICAgPSAkdGhpcy5kYXRhKCdicy5wb3BvdmVyJylcbiAgICAgIHZhciBvcHRpb25zICA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG4gICAgICB2YXIgc2VsZWN0b3IgPSBvcHRpb25zICYmIG9wdGlvbnMuc2VsZWN0b3JcblxuICAgICAgaWYgKCFkYXRhICYmIG9wdGlvbiA9PSAnZGVzdHJveScpIHJldHVyblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMucG9wb3ZlcicsIChkYXRhID0ge30pKVxuICAgICAgICBpZiAoIWRhdGFbc2VsZWN0b3JdKSBkYXRhW3NlbGVjdG9yXSA9IG5ldyBQb3BvdmVyKHRoaXMsIG9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnBvcG92ZXInLCAoZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5wb3BvdmVyXG5cbiAgJC5mbi5wb3BvdmVyICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4ucG9wb3Zlci5Db25zdHJ1Y3RvciA9IFBvcG92ZXJcblxuXG4gIC8vIFBPUE9WRVIgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4ucG9wb3Zlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4ucG9wb3ZlciA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogc2Nyb2xsc3B5LmpzIHYzLjMuMFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jc2Nyb2xsc3B5XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gU0NST0xMU1BZIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBTY3JvbGxTcHkoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBwcm9jZXNzICA9ICQucHJveHkodGhpcy5wcm9jZXNzLCB0aGlzKVxuXG4gICAgdGhpcy4kYm9keSAgICAgICAgICA9ICQoJ2JvZHknKVxuICAgIHRoaXMuJHNjcm9sbEVsZW1lbnQgPSAkKGVsZW1lbnQpLmlzKCdib2R5JykgPyAkKHdpbmRvdykgOiAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgICAgICA9ICQuZXh0ZW5kKHt9LCBTY3JvbGxTcHkuREVGQVVMVFMsIG9wdGlvbnMpXG4gICAgdGhpcy5zZWxlY3RvciAgICAgICA9ICh0aGlzLm9wdGlvbnMudGFyZ2V0IHx8ICcnKSArICcgLm5hdiBsaSA+IGEnXG4gICAgdGhpcy5vZmZzZXRzICAgICAgICA9IFtdXG4gICAgdGhpcy50YXJnZXRzICAgICAgICA9IFtdXG4gICAgdGhpcy5hY3RpdmVUYXJnZXQgICA9IG51bGxcbiAgICB0aGlzLnNjcm9sbEhlaWdodCAgID0gMFxuXG4gICAgdGhpcy4kc2Nyb2xsRWxlbWVudC5vbignc2Nyb2xsLmJzLnNjcm9sbHNweScsIHByb2Nlc3MpXG4gICAgdGhpcy5yZWZyZXNoKClcbiAgICB0aGlzLnByb2Nlc3MoKVxuICB9XG5cbiAgU2Nyb2xsU3B5LlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIFNjcm9sbFNweS5ERUZBVUxUUyA9IHtcbiAgICBvZmZzZXQ6IDEwXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLmdldFNjcm9sbEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy4kc2Nyb2xsRWxlbWVudFswXS5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgodGhpcy4kYm9keVswXS5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9mZnNldE1ldGhvZCA9ICdvZmZzZXQnXG4gICAgdmFyIG9mZnNldEJhc2UgICA9IDBcblxuICAgIGlmICghJC5pc1dpbmRvdyh0aGlzLiRzY3JvbGxFbGVtZW50WzBdKSkge1xuICAgICAgb2Zmc2V0TWV0aG9kID0gJ3Bvc2l0aW9uJ1xuICAgICAgb2Zmc2V0QmFzZSAgID0gdGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKVxuICAgIH1cblxuICAgIHRoaXMub2Zmc2V0cyA9IFtdXG4gICAgdGhpcy50YXJnZXRzID0gW11cbiAgICB0aGlzLnNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KClcblxuICAgIHZhciBzZWxmICAgICA9IHRoaXNcblxuICAgIHRoaXMuJGJvZHlcbiAgICAgIC5maW5kKHRoaXMuc2VsZWN0b3IpXG4gICAgICAubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRlbCAgID0gJCh0aGlzKVxuICAgICAgICB2YXIgaHJlZiAgPSAkZWwuZGF0YSgndGFyZ2V0JykgfHwgJGVsLmF0dHIoJ2hyZWYnKVxuICAgICAgICB2YXIgJGhyZWYgPSAvXiMuLy50ZXN0KGhyZWYpICYmICQoaHJlZilcblxuICAgICAgICByZXR1cm4gKCRocmVmXG4gICAgICAgICAgJiYgJGhyZWYubGVuZ3RoXG4gICAgICAgICAgJiYgJGhyZWYuaXMoJzp2aXNpYmxlJylcbiAgICAgICAgICAmJiBbWyRocmVmW29mZnNldE1ldGhvZF0oKS50b3AgKyBvZmZzZXRCYXNlLCBocmVmXV0pIHx8IG51bGxcbiAgICAgIH0pXG4gICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF0gfSlcbiAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vZmZzZXRzLnB1c2godGhpc1swXSlcbiAgICAgICAgc2VsZi50YXJnZXRzLnB1c2godGhpc1sxXSlcbiAgICAgIH0pXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcm9sbFRvcCAgICA9IHRoaXMuJHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wKCkgKyB0aGlzLm9wdGlvbnMub2Zmc2V0XG4gICAgdmFyIHNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KClcbiAgICB2YXIgbWF4U2Nyb2xsICAgID0gdGhpcy5vcHRpb25zLm9mZnNldCArIHNjcm9sbEhlaWdodCAtIHRoaXMuJHNjcm9sbEVsZW1lbnQuaGVpZ2h0KClcbiAgICB2YXIgb2Zmc2V0cyAgICAgID0gdGhpcy5vZmZzZXRzXG4gICAgdmFyIHRhcmdldHMgICAgICA9IHRoaXMudGFyZ2V0c1xuICAgIHZhciBhY3RpdmVUYXJnZXQgPSB0aGlzLmFjdGl2ZVRhcmdldFxuICAgIHZhciBpXG5cbiAgICBpZiAodGhpcy5zY3JvbGxIZWlnaHQgIT0gc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlZnJlc2goKVxuICAgIH1cblxuICAgIGlmIChzY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XG4gICAgICByZXR1cm4gYWN0aXZlVGFyZ2V0ICE9IChpID0gdGFyZ2V0c1t0YXJnZXRzLmxlbmd0aCAtIDFdKSAmJiB0aGlzLmFjdGl2YXRlKGkpXG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZVRhcmdldCAmJiBzY3JvbGxUb3AgPCBvZmZzZXRzWzBdKSB7XG4gICAgICB0aGlzLmFjdGl2ZVRhcmdldCA9IG51bGxcbiAgICAgIHJldHVybiB0aGlzLmNsZWFyKClcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgYWN0aXZlVGFyZ2V0ICE9IHRhcmdldHNbaV1cbiAgICAgICAgJiYgc2Nyb2xsVG9wID49IG9mZnNldHNbaV1cbiAgICAgICAgJiYgKCFvZmZzZXRzW2kgKyAxXSB8fCBzY3JvbGxUb3AgPD0gb2Zmc2V0c1tpICsgMV0pXG4gICAgICAgICYmIHRoaXMuYWN0aXZhdGUodGFyZ2V0c1tpXSlcbiAgICB9XG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRoaXMuYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0XG5cbiAgICB0aGlzLmNsZWFyKClcblxuICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgK1xuICAgICAgICAnW2RhdGEtdGFyZ2V0PVwiJyArIHRhcmdldCArICdcIl0sJyArXG4gICAgICAgIHRoaXMuc2VsZWN0b3IgKyAnW2hyZWY9XCInICsgdGFyZ2V0ICsgJ1wiXSdcblxuICAgIHZhciBhY3RpdmUgPSAkKHNlbGVjdG9yKVxuICAgICAgLnBhcmVudHMoJ2xpJylcbiAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcblxuICAgIGlmIChhY3RpdmUucGFyZW50KCcuZHJvcGRvd24tbWVudScpLmxlbmd0aCkge1xuICAgICAgYWN0aXZlID0gYWN0aXZlXG4gICAgICAgIC5jbG9zZXN0KCdsaS5kcm9wZG93bicpXG4gICAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICB9XG5cbiAgICBhY3RpdmUudHJpZ2dlcignYWN0aXZhdGUuYnMuc2Nyb2xsc3B5JylcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgJCh0aGlzLnNlbGVjdG9yKVxuICAgICAgLnBhcmVudHNVbnRpbCh0aGlzLm9wdGlvbnMudGFyZ2V0LCAnLmFjdGl2ZScpXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gIH1cblxuXG4gIC8vIFNDUk9MTFNQWSBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuc2Nyb2xsc3B5JylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5zY3JvbGxzcHknLCAoZGF0YSA9IG5ldyBTY3JvbGxTcHkodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnNjcm9sbHNweVxuXG4gICQuZm4uc2Nyb2xsc3B5ICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uc2Nyb2xsc3B5LkNvbnN0cnVjdG9yID0gU2Nyb2xsU3B5XG5cblxuICAvLyBTQ1JPTExTUFkgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5zY3JvbGxzcHkubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnNjcm9sbHNweSA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIFNDUk9MTFNQWSBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT09PT1cblxuICAkKHdpbmRvdykub24oJ2xvYWQuYnMuc2Nyb2xsc3B5LmRhdGEtYXBpJywgZnVuY3Rpb24gKCkge1xuICAgICQoJ1tkYXRhLXNweT1cInNjcm9sbFwiXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRzcHkgPSAkKHRoaXMpXG4gICAgICBQbHVnaW4uY2FsbCgkc3B5LCAkc3B5LmRhdGEoKSlcbiAgICB9KVxuICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0YWIuanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0YWJzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVEFCIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgVGFiID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSAkKGVsZW1lbnQpXG4gIH1cblxuICBUYWIuVkVSU0lPTiA9ICczLjMuMCdcblxuICBUYWIuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIFRhYi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRoaXMgICAgPSB0aGlzLmVsZW1lbnRcbiAgICB2YXIgJHVsICAgICAgPSAkdGhpcy5jbG9zZXN0KCd1bDpub3QoLmRyb3Bkb3duLW1lbnUpJylcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5kYXRhKCd0YXJnZXQnKVxuXG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgJiYgc2VsZWN0b3IucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLywgJycpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB9XG5cbiAgICBpZiAoJHRoaXMucGFyZW50KCdsaScpLmhhc0NsYXNzKCdhY3RpdmUnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHByZXZpb3VzID0gJHVsLmZpbmQoJy5hY3RpdmU6bGFzdCBhJylcbiAgICB2YXIgaGlkZUV2ZW50ID0gJC5FdmVudCgnaGlkZS5icy50YWInLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiAkdGhpc1swXVxuICAgIH0pXG4gICAgdmFyIHNob3dFdmVudCA9ICQuRXZlbnQoJ3Nob3cuYnMudGFiJywge1xuICAgICAgcmVsYXRlZFRhcmdldDogJHByZXZpb3VzWzBdXG4gICAgfSlcblxuICAgICRwcmV2aW91cy50cmlnZ2VyKGhpZGVFdmVudClcbiAgICAkdGhpcy50cmlnZ2VyKHNob3dFdmVudClcblxuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHZhciAkdGFyZ2V0ID0gJChzZWxlY3RvcilcblxuICAgIHRoaXMuYWN0aXZhdGUoJHRoaXMuY2xvc2VzdCgnbGknKSwgJHVsKVxuICAgIHRoaXMuYWN0aXZhdGUoJHRhcmdldCwgJHRhcmdldC5wYXJlbnQoKSwgZnVuY3Rpb24gKCkge1xuICAgICAgJHByZXZpb3VzLnRyaWdnZXIoe1xuICAgICAgICB0eXBlOiAnaGlkZGVuLmJzLnRhYicsXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6ICR0aGlzWzBdXG4gICAgICB9KVxuICAgICAgJHRoaXMudHJpZ2dlcih7XG4gICAgICAgIHR5cGU6ICdzaG93bi5icy50YWInLFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiAkcHJldmlvdXNbMF1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIFRhYi5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHZhciAkYWN0aXZlICAgID0gY29udGFpbmVyLmZpbmQoJz4gLmFjdGl2ZScpXG4gICAgdmFyIHRyYW5zaXRpb24gPSBjYWxsYmFja1xuICAgICAgJiYgJC5zdXBwb3J0LnRyYW5zaXRpb25cbiAgICAgICYmICgoJGFjdGl2ZS5sZW5ndGggJiYgJGFjdGl2ZS5oYXNDbGFzcygnZmFkZScpKSB8fCAhIWNvbnRhaW5lci5maW5kKCc+IC5mYWRlJykubGVuZ3RoKVxuXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICRhY3RpdmVcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZmluZCgnPiAuZHJvcGRvd24tbWVudSA+IC5hY3RpdmUnKVxuICAgICAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICAgLmVuZCgpXG4gICAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICAgIGVsZW1lbnRcbiAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJylcbiAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gcmVmbG93IGZvciB0cmFuc2l0aW9uXG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2luJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2ZhZGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnQoJy5kcm9wZG93bi1tZW51JykpIHtcbiAgICAgICAgZWxlbWVudFxuICAgICAgICAgIC5jbG9zZXN0KCdsaS5kcm9wZG93bicpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgICAgLmVuZCgpXG4gICAgICAgICAgLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICAkYWN0aXZlLmxlbmd0aCAmJiB0cmFuc2l0aW9uID9cbiAgICAgICRhY3RpdmVcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgbmV4dClcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRhYi5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICBuZXh0KClcblxuICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2luJylcbiAgfVxuXG5cbiAgLy8gVEFCIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JzLnRhYicpXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMudGFiJywgKGRhdGEgPSBuZXcgVGFiKHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi50YWJcblxuICAkLmZuLnRhYiAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnRhYi5Db25zdHJ1Y3RvciA9IFRhYlxuXG5cbiAgLy8gVEFCIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PVxuXG4gICQuZm4udGFiLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi50YWIgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBUQUIgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09XG5cbiAgdmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgUGx1Z2luLmNhbGwoJCh0aGlzKSwgJ3Nob3cnKVxuICB9XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLnRhYi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nLCBjbGlja0hhbmRsZXIpXG4gICAgLm9uKCdjbGljay5icy50YWIuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwicGlsbFwiXScsIGNsaWNrSGFuZGxlcilcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogYWZmaXguanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNhZmZpeFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEFGRklYIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBBZmZpeCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIEFmZml4LkRFRkFVTFRTLCBvcHRpb25zKVxuXG4gICAgdGhpcy4kdGFyZ2V0ID0gJCh0aGlzLm9wdGlvbnMudGFyZ2V0KVxuICAgICAgLm9uKCdzY3JvbGwuYnMuYWZmaXguZGF0YS1hcGknLCAkLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbiwgdGhpcykpXG4gICAgICAub24oJ2NsaWNrLmJzLmFmZml4LmRhdGEtYXBpJywgICQucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uV2l0aEV2ZW50TG9vcCwgdGhpcykpXG5cbiAgICB0aGlzLiRlbGVtZW50ICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLmFmZml4ZWQgICAgICA9XG4gICAgdGhpcy51bnBpbiAgICAgICAgPVxuICAgIHRoaXMucGlubmVkT2Zmc2V0ID0gbnVsbFxuXG4gICAgdGhpcy5jaGVja1Bvc2l0aW9uKClcbiAgfVxuXG4gIEFmZml4LlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIEFmZml4LlJFU0VUICAgID0gJ2FmZml4IGFmZml4LXRvcCBhZmZpeC1ib3R0b20nXG5cbiAgQWZmaXguREVGQVVMVFMgPSB7XG4gICAgb2Zmc2V0OiAwLFxuICAgIHRhcmdldDogd2luZG93XG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoc2Nyb2xsSGVpZ2h0LCBoZWlnaHQsIG9mZnNldFRvcCwgb2Zmc2V0Qm90dG9tKSB7XG4gICAgdmFyIHNjcm9sbFRvcCAgICA9IHRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKVxuICAgIHZhciBwb3NpdGlvbiAgICAgPSB0aGlzLiRlbGVtZW50Lm9mZnNldCgpXG4gICAgdmFyIHRhcmdldEhlaWdodCA9IHRoaXMuJHRhcmdldC5oZWlnaHQoKVxuXG4gICAgaWYgKG9mZnNldFRvcCAhPSBudWxsICYmIHRoaXMuYWZmaXhlZCA9PSAndG9wJykgcmV0dXJuIHNjcm9sbFRvcCA8IG9mZnNldFRvcCA/ICd0b3AnIDogZmFsc2VcblxuICAgIGlmICh0aGlzLmFmZml4ZWQgPT0gJ2JvdHRvbScpIHtcbiAgICAgIGlmIChvZmZzZXRUb3AgIT0gbnVsbCkgcmV0dXJuIChzY3JvbGxUb3AgKyB0aGlzLnVucGluIDw9IHBvc2l0aW9uLnRvcCkgPyBmYWxzZSA6ICdib3R0b20nXG4gICAgICByZXR1cm4gKHNjcm9sbFRvcCArIHRhcmdldEhlaWdodCA8PSBzY3JvbGxIZWlnaHQgLSBvZmZzZXRCb3R0b20pID8gZmFsc2UgOiAnYm90dG9tJ1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsaXppbmcgICA9IHRoaXMuYWZmaXhlZCA9PSBudWxsXG4gICAgdmFyIGNvbGxpZGVyVG9wICAgID0gaW5pdGlhbGl6aW5nID8gc2Nyb2xsVG9wIDogcG9zaXRpb24udG9wXG4gICAgdmFyIGNvbGxpZGVySGVpZ2h0ID0gaW5pdGlhbGl6aW5nID8gdGFyZ2V0SGVpZ2h0IDogaGVpZ2h0XG5cbiAgICBpZiAob2Zmc2V0VG9wICE9IG51bGwgJiYgY29sbGlkZXJUb3AgPD0gb2Zmc2V0VG9wKSByZXR1cm4gJ3RvcCdcbiAgICBpZiAob2Zmc2V0Qm90dG9tICE9IG51bGwgJiYgKGNvbGxpZGVyVG9wICsgY29sbGlkZXJIZWlnaHQgPj0gc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0Qm90dG9tKSkgcmV0dXJuICdib3R0b20nXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIEFmZml4LnByb3RvdHlwZS5nZXRQaW5uZWRPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGlubmVkT2Zmc2V0KSByZXR1cm4gdGhpcy5waW5uZWRPZmZzZXRcbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKEFmZml4LlJFU0VUKS5hZGRDbGFzcygnYWZmaXgnKVxuICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLiR0YXJnZXQuc2Nyb2xsVG9wKClcbiAgICB2YXIgcG9zaXRpb24gID0gdGhpcy4kZWxlbWVudC5vZmZzZXQoKVxuICAgIHJldHVybiAodGhpcy5waW5uZWRPZmZzZXQgPSBwb3NpdGlvbi50b3AgLSBzY3JvbGxUb3ApXG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuY2hlY2tQb3NpdGlvbldpdGhFdmVudExvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dCgkLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbiwgdGhpcyksIDEpXG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuY2hlY2tQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHJldHVyblxuXG4gICAgdmFyIGhlaWdodCAgICAgICA9IHRoaXMuJGVsZW1lbnQuaGVpZ2h0KClcbiAgICB2YXIgb2Zmc2V0ICAgICAgID0gdGhpcy5vcHRpb25zLm9mZnNldFxuICAgIHZhciBvZmZzZXRUb3AgICAgPSBvZmZzZXQudG9wXG4gICAgdmFyIG9mZnNldEJvdHRvbSA9IG9mZnNldC5ib3R0b21cbiAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gJCgnYm9keScpLmhlaWdodCgpXG5cbiAgICBpZiAodHlwZW9mIG9mZnNldCAhPSAnb2JqZWN0JykgICAgICAgICBvZmZzZXRCb3R0b20gPSBvZmZzZXRUb3AgPSBvZmZzZXRcbiAgICBpZiAodHlwZW9mIG9mZnNldFRvcCA9PSAnZnVuY3Rpb24nKSAgICBvZmZzZXRUb3AgICAgPSBvZmZzZXQudG9wKHRoaXMuJGVsZW1lbnQpXG4gICAgaWYgKHR5cGVvZiBvZmZzZXRCb3R0b20gPT0gJ2Z1bmN0aW9uJykgb2Zmc2V0Qm90dG9tID0gb2Zmc2V0LmJvdHRvbSh0aGlzLiRlbGVtZW50KVxuXG4gICAgdmFyIGFmZml4ID0gdGhpcy5nZXRTdGF0ZShzY3JvbGxIZWlnaHQsIGhlaWdodCwgb2Zmc2V0VG9wLCBvZmZzZXRCb3R0b20pXG5cbiAgICBpZiAodGhpcy5hZmZpeGVkICE9IGFmZml4KSB7XG4gICAgICBpZiAodGhpcy51bnBpbiAhPSBudWxsKSB0aGlzLiRlbGVtZW50LmNzcygndG9wJywgJycpXG5cbiAgICAgIHZhciBhZmZpeFR5cGUgPSAnYWZmaXgnICsgKGFmZml4ID8gJy0nICsgYWZmaXggOiAnJylcbiAgICAgIHZhciBlICAgICAgICAgPSAkLkV2ZW50KGFmZml4VHlwZSArICcuYnMuYWZmaXgnKVxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgICB0aGlzLmFmZml4ZWQgPSBhZmZpeFxuICAgICAgdGhpcy51bnBpbiA9IGFmZml4ID09ICdib3R0b20nID8gdGhpcy5nZXRQaW5uZWRPZmZzZXQoKSA6IG51bGxcblxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQ2xhc3MoQWZmaXguUkVTRVQpXG4gICAgICAgIC5hZGRDbGFzcyhhZmZpeFR5cGUpXG4gICAgICAgIC50cmlnZ2VyKGFmZml4VHlwZS5yZXBsYWNlKCdhZmZpeCcsICdhZmZpeGVkJykgKyAnLmJzLmFmZml4JylcbiAgICB9XG5cbiAgICBpZiAoYWZmaXggPT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2Zmc2V0KHtcbiAgICAgICAgdG9wOiBzY3JvbGxIZWlnaHQgLSBoZWlnaHQgLSBvZmZzZXRCb3R0b21cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cblxuICAvLyBBRkZJWCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5hZmZpeCcpXG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuYWZmaXgnLCAoZGF0YSA9IG5ldyBBZmZpeCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uYWZmaXhcblxuICAkLmZuLmFmZml4ICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uYWZmaXguQ29uc3RydWN0b3IgPSBBZmZpeFxuXG5cbiAgLy8gQUZGSVggTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmFmZml4Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5hZmZpeCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEFGRklYIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgJCh3aW5kb3cpLm9uKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICQoJ1tkYXRhLXNweT1cImFmZml4XCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHNweSA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhID0gJHNweS5kYXRhKClcblxuICAgICAgZGF0YS5vZmZzZXQgPSBkYXRhLm9mZnNldCB8fCB7fVxuXG4gICAgICBpZiAoZGF0YS5vZmZzZXRCb3R0b20gIT0gbnVsbCkgZGF0YS5vZmZzZXQuYm90dG9tID0gZGF0YS5vZmZzZXRCb3R0b21cbiAgICAgIGlmIChkYXRhLm9mZnNldFRvcCAgICAhPSBudWxsKSBkYXRhLm9mZnNldC50b3AgICAgPSBkYXRhLm9mZnNldFRvcFxuXG4gICAgICBQbHVnaW4uY2FsbCgkc3B5LCBkYXRhKVxuICAgIH0pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgQ29yZSAxLjEwLjRcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vY2F0ZWdvcnkvdWktY29yZS9cbiAqL1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciB1dWlkID0gMCxcblx0cnVuaXF1ZUlkID0gL151aS1pZC1cXGQrJC87XG5cbi8vICQudWkgbWlnaHQgZXhpc3QgZnJvbSBjb21wb25lbnRzIHdpdGggbm8gZGVwZW5kZW5jaWVzLCBlLmcuLCAkLnVpLnBvc2l0aW9uXG4kLnVpID0gJC51aSB8fCB7fTtcblxuJC5leHRlbmQoICQudWksIHtcblx0dmVyc2lvbjogXCIxLjEwLjRcIixcblxuXHRrZXlDb2RlOiB7XG5cdFx0QkFDS1NQQUNFOiA4LFxuXHRcdENPTU1BOiAxODgsXG5cdFx0REVMRVRFOiA0Nixcblx0XHRET1dOOiA0MCxcblx0XHRFTkQ6IDM1LFxuXHRcdEVOVEVSOiAxMyxcblx0XHRFU0NBUEU6IDI3LFxuXHRcdEhPTUU6IDM2LFxuXHRcdExFRlQ6IDM3LFxuXHRcdE5VTVBBRF9BREQ6IDEwNyxcblx0XHROVU1QQURfREVDSU1BTDogMTEwLFxuXHRcdE5VTVBBRF9ESVZJREU6IDExMSxcblx0XHROVU1QQURfRU5URVI6IDEwOCxcblx0XHROVU1QQURfTVVMVElQTFk6IDEwNixcblx0XHROVU1QQURfU1VCVFJBQ1Q6IDEwOSxcblx0XHRQQUdFX0RPV046IDM0LFxuXHRcdFBBR0VfVVA6IDMzLFxuXHRcdFBFUklPRDogMTkwLFxuXHRcdFJJR0hUOiAzOSxcblx0XHRTUEFDRTogMzIsXG5cdFx0VEFCOiA5LFxuXHRcdFVQOiAzOFxuXHR9XG59KTtcblxuLy8gcGx1Z2luc1xuJC5mbi5leHRlbmQoe1xuXHRmb2N1czogKGZ1bmN0aW9uKCBvcmlnICkge1xuXHRcdHJldHVybiBmdW5jdGlvbiggZGVsYXksIGZuICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBkZWxheSA9PT0gXCJudW1iZXJcIiA/XG5cdFx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdCQoIGVsZW0gKS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0aWYgKCBmbiApIHtcblx0XHRcdFx0XHRcdFx0Zm4uY2FsbCggZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIGRlbGF5ICk7XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0b3JpZy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblx0fSkoICQuZm4uZm9jdXMgKSxcblxuXHRzY3JvbGxQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY3JvbGxQYXJlbnQ7XG5cdFx0aWYgKCgkLnVpLmllICYmICgvKHN0YXRpY3xyZWxhdGl2ZSkvKS50ZXN0KHRoaXMuY3NzKFwicG9zaXRpb25cIikpKSB8fCAoL2Fic29sdXRlLykudGVzdCh0aGlzLmNzcyhcInBvc2l0aW9uXCIpKSkge1xuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gKC8ocmVsYXRpdmV8YWJzb2x1dGV8Zml4ZWQpLykudGVzdCgkLmNzcyh0aGlzLFwicG9zaXRpb25cIikpICYmICgvKGF1dG98c2Nyb2xsKS8pLnRlc3QoJC5jc3ModGhpcyxcIm92ZXJmbG93XCIpKyQuY3NzKHRoaXMsXCJvdmVyZmxvdy15XCIpKyQuY3NzKHRoaXMsXCJvdmVyZmxvdy14XCIpKTtcblx0XHRcdH0pLmVxKDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0aGlzLnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KCQuY3NzKHRoaXMsXCJvdmVyZmxvd1wiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteVwiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteFwiKSk7XG5cdFx0XHR9KS5lcSgwKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKC9maXhlZC8pLnRlc3QodGhpcy5jc3MoXCJwb3NpdGlvblwiKSkgfHwgIXNjcm9sbFBhcmVudC5sZW5ndGggPyAkKGRvY3VtZW50KSA6IHNjcm9sbFBhcmVudDtcblx0fSxcblxuXHR6SW5kZXg6IGZ1bmN0aW9uKCB6SW5kZXggKSB7XG5cdFx0aWYgKCB6SW5kZXggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiB0aGlzLmNzcyggXCJ6SW5kZXhcIiwgekluZGV4ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdHZhciBlbGVtID0gJCggdGhpc1sgMCBdICksIHBvc2l0aW9uLCB2YWx1ZTtcblx0XHRcdHdoaWxlICggZWxlbS5sZW5ndGggJiYgZWxlbVsgMCBdICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0Ly8gSWdub3JlIHotaW5kZXggaWYgcG9zaXRpb24gaXMgc2V0IHRvIGEgdmFsdWUgd2hlcmUgei1pbmRleCBpcyBpZ25vcmVkIGJ5IHRoZSBicm93c2VyXG5cdFx0XHRcdC8vIFRoaXMgbWFrZXMgYmVoYXZpb3Igb2YgdGhpcyBmdW5jdGlvbiBjb25zaXN0ZW50IGFjcm9zcyBicm93c2Vyc1xuXHRcdFx0XHQvLyBXZWJLaXQgYWx3YXlzIHJldHVybnMgYXV0byBpZiB0aGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkXG5cdFx0XHRcdHBvc2l0aW9uID0gZWxlbS5jc3MoIFwicG9zaXRpb25cIiApO1xuXHRcdFx0XHRpZiAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwicmVsYXRpdmVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0XHRcdC8vIElFIHJldHVybnMgMCB3aGVuIHpJbmRleCBpcyBub3Qgc3BlY2lmaWVkXG5cdFx0XHRcdFx0Ly8gb3RoZXIgYnJvd3NlcnMgcmV0dXJuIGEgc3RyaW5nXG5cdFx0XHRcdFx0Ly8gd2UgaWdub3JlIHRoZSBjYXNlIG9mIG5lc3RlZCBlbGVtZW50cyB3aXRoIGFuIGV4cGxpY2l0IHZhbHVlIG9mIDBcblx0XHRcdFx0XHQvLyA8ZGl2IHN0eWxlPVwiei1pbmRleDogLTEwO1wiPjxkaXYgc3R5bGU9XCJ6LWluZGV4OiAwO1wiPjwvZGl2PjwvZGl2PlxuXHRcdFx0XHRcdHZhbHVlID0gcGFyc2VJbnQoIGVsZW0uY3NzKCBcInpJbmRleFwiICksIDEwICk7XG5cdFx0XHRcdFx0aWYgKCAhaXNOYU4oIHZhbHVlICkgJiYgdmFsdWUgIT09IDAgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW0gPSBlbGVtLnBhcmVudCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdHVuaXF1ZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhdGhpcy5pZCApIHtcblx0XHRcdFx0dGhpcy5pZCA9IFwidWktaWQtXCIgKyAoKyt1dWlkKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRyZW1vdmVVbmlxdWVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggcnVuaXF1ZUlkLnRlc3QoIHRoaXMuaWQgKSApIHtcblx0XHRcdFx0JCggdGhpcyApLnJlbW92ZUF0dHIoIFwiaWRcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxuLy8gc2VsZWN0b3JzXG5mdW5jdGlvbiBmb2N1c2FibGUoIGVsZW1lbnQsIGlzVGFiSW5kZXhOb3ROYU4gKSB7XG5cdHZhciBtYXAsIG1hcE5hbWUsIGltZyxcblx0XHRub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0aWYgKCBcImFyZWFcIiA9PT0gbm9kZU5hbWUgKSB7XG5cdFx0bWFwID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXHRcdG1hcE5hbWUgPSBtYXAubmFtZTtcblx0XHRpZiAoICFlbGVtZW50LmhyZWYgfHwgIW1hcE5hbWUgfHwgbWFwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwibWFwXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGltZyA9ICQoIFwiaW1nW3VzZW1hcD0jXCIgKyBtYXBOYW1lICsgXCJdXCIgKVswXTtcblx0XHRyZXR1cm4gISFpbWcgJiYgdmlzaWJsZSggaW1nICk7XG5cdH1cblx0cmV0dXJuICggL2lucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0Ly50ZXN0KCBub2RlTmFtZSApID9cblx0XHQhZWxlbWVudC5kaXNhYmxlZCA6XG5cdFx0XCJhXCIgPT09IG5vZGVOYW1lID9cblx0XHRcdGVsZW1lbnQuaHJlZiB8fCBpc1RhYkluZGV4Tm90TmFOIDpcblx0XHRcdGlzVGFiSW5kZXhOb3ROYU4pICYmXG5cdFx0Ly8gdGhlIGVsZW1lbnQgYW5kIGFsbCBvZiBpdHMgYW5jZXN0b3JzIG11c3QgYmUgdmlzaWJsZVxuXHRcdHZpc2libGUoIGVsZW1lbnQgKTtcbn1cblxuZnVuY3Rpb24gdmlzaWJsZSggZWxlbWVudCApIHtcblx0cmV0dXJuICQuZXhwci5maWx0ZXJzLnZpc2libGUoIGVsZW1lbnQgKSAmJlxuXHRcdCEkKCBlbGVtZW50ICkucGFyZW50cygpLmFkZEJhY2soKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJC5jc3MoIHRoaXMsIFwidmlzaWJpbGl0eVwiICkgPT09IFwiaGlkZGVuXCI7XG5cdFx0fSkubGVuZ3RoO1xufVxuXG4kLmV4dGVuZCggJC5leHByWyBcIjpcIiBdLCB7XG5cdGRhdGE6ICQuZXhwci5jcmVhdGVQc2V1ZG8gP1xuXHRcdCQuZXhwci5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24oIGRhdGFOYW1lICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGRhdGFOYW1lICk7XG5cdFx0XHR9O1xuXHRcdH0pIDpcblx0XHQvLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgbWF0Y2hbIDMgXSApO1xuXHRcdH0sXG5cblx0Zm9jdXNhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRyZXR1cm4gZm9jdXNhYmxlKCBlbGVtZW50LCAhaXNOYU4oICQuYXR0ciggZWxlbWVudCwgXCJ0YWJpbmRleFwiICkgKSApO1xuXHR9LFxuXG5cdHRhYmJhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgdGFiSW5kZXggPSAkLmF0dHIoIGVsZW1lbnQsIFwidGFiaW5kZXhcIiApLFxuXHRcdFx0aXNUYWJJbmRleE5hTiA9IGlzTmFOKCB0YWJJbmRleCApO1xuXHRcdHJldHVybiAoIGlzVGFiSW5kZXhOYU4gfHwgdGFiSW5kZXggPj0gMCApICYmIGZvY3VzYWJsZSggZWxlbWVudCwgIWlzVGFiSW5kZXhOYU4gKTtcblx0fVxufSk7XG5cbi8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XG5pZiAoICEkKCBcIjxhPlwiICkub3V0ZXJXaWR0aCggMSApLmpxdWVyeSApIHtcblx0JC5lYWNoKCBbIFwiV2lkdGhcIiwgXCJIZWlnaHRcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0XHR2YXIgc2lkZSA9IG5hbWUgPT09IFwiV2lkdGhcIiA/IFsgXCJMZWZ0XCIsIFwiUmlnaHRcIiBdIDogWyBcIlRvcFwiLCBcIkJvdHRvbVwiIF0sXG5cdFx0XHR0eXBlID0gbmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0b3JpZyA9IHtcblx0XHRcdFx0aW5uZXJXaWR0aDogJC5mbi5pbm5lcldpZHRoLFxuXHRcdFx0XHRpbm5lckhlaWdodDogJC5mbi5pbm5lckhlaWdodCxcblx0XHRcdFx0b3V0ZXJXaWR0aDogJC5mbi5vdXRlcldpZHRoLFxuXHRcdFx0XHRvdXRlckhlaWdodDogJC5mbi5vdXRlckhlaWdodFxuXHRcdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlZHVjZSggZWxlbSwgc2l6ZSwgYm9yZGVyLCBtYXJnaW4gKSB7XG5cdFx0XHQkLmVhY2goIHNpZGUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIHRoaXMgKSApIHx8IDA7XG5cdFx0XHRcdGlmICggYm9yZGVyICkge1xuXHRcdFx0XHRcdHNpemUgLT0gcGFyc2VGbG9hdCggJC5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyB0aGlzICsgXCJXaWR0aFwiICkgKSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWFyZ2luICkge1xuXHRcdFx0XHRcdHNpemUgLT0gcGFyc2VGbG9hdCggJC5jc3MoIGVsZW0sIFwibWFyZ2luXCIgKyB0aGlzICkgKSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzaXplO1xuXHRcdH1cblxuXHRcdCQuZm5bIFwiaW5uZXJcIiArIG5hbWUgXSA9IGZ1bmN0aW9uKCBzaXplICkge1xuXHRcdFx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBvcmlnWyBcImlubmVyXCIgKyBuYW1lIF0uY2FsbCggdGhpcyApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzICkuY3NzKCB0eXBlLCByZWR1Y2UoIHRoaXMsIHNpemUgKSArIFwicHhcIiApO1xuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdCQuZm5bIFwib3V0ZXJcIiArIG5hbWVdID0gZnVuY3Rpb24oIHNpemUsIG1hcmdpbiApIHtcblx0XHRcdGlmICggdHlwZW9mIHNpemUgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHJldHVybiBvcmlnWyBcIm91dGVyXCIgKyBuYW1lIF0uY2FsbCggdGhpcywgc2l6ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzKS5jc3MoIHR5cGUsIHJlZHVjZSggdGhpcywgc2l6ZSwgdHJ1ZSwgbWFyZ2luICkgKyBcInB4XCIgKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH0pO1xufVxuXG4vLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuaWYgKCAhJC5mbi5hZGRCYWNrICkge1xuXHQkLmZuLmFkZEJhY2sgPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9O1xufVxuXG4vLyBzdXBwb3J0OiBqUXVlcnkgMS42LjEsIDEuNi4yIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC85NDEzKVxuaWYgKCAkKCBcIjxhPlwiICkuZGF0YSggXCJhLWJcIiwgXCJhXCIgKS5yZW1vdmVEYXRhKCBcImEtYlwiICkuZGF0YSggXCJhLWJcIiApICkge1xuXHQkLmZuLnJlbW92ZURhdGEgPSAoZnVuY3Rpb24oIHJlbW92ZURhdGEgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVEYXRhLmNhbGwoIHRoaXMsICQuY2FtZWxDYXNlKCBrZXkgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHJlbW92ZURhdGEuY2FsbCggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pKCAkLmZuLnJlbW92ZURhdGEgKTtcbn1cblxuXG5cblxuXG4vLyBkZXByZWNhdGVkXG4kLnVpLmllID0gISEvbXNpZSBbXFx3Ll0rLy5leGVjKCBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkgKTtcblxuJC5zdXBwb3J0LnNlbGVjdHN0YXJ0ID0gXCJvbnNlbGVjdHN0YXJ0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuJC5mbi5leHRlbmQoe1xuXHRkaXNhYmxlU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5iaW5kKCAoICQuc3VwcG9ydC5zZWxlY3RzdGFydCA/IFwic2VsZWN0c3RhcnRcIiA6IFwibW91c2Vkb3duXCIgKSArXG5cdFx0XHRcIi51aS1kaXNhYmxlU2VsZWN0aW9uXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0pO1xuXHR9LFxuXG5cdGVuYWJsZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudW5iaW5kKCBcIi51aS1kaXNhYmxlU2VsZWN0aW9uXCIgKTtcblx0fVxufSk7XG5cbiQuZXh0ZW5kKCAkLnVpLCB7XG5cdC8vICQudWkucGx1Z2luIGlzIGRlcHJlY2F0ZWQuIFVzZSAkLndpZGdldCgpIGV4dGVuc2lvbnMgaW5zdGVhZC5cblx0cGx1Z2luOiB7XG5cdFx0YWRkOiBmdW5jdGlvbiggbW9kdWxlLCBvcHRpb24sIHNldCApIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRwcm90byA9ICQudWlbIG1vZHVsZSBdLnByb3RvdHlwZTtcblx0XHRcdGZvciAoIGkgaW4gc2V0ICkge1xuXHRcdFx0XHRwcm90by5wbHVnaW5zWyBpIF0gPSBwcm90by5wbHVnaW5zWyBpIF0gfHwgW107XG5cdFx0XHRcdHByb3RvLnBsdWdpbnNbIGkgXS5wdXNoKCBbIG9wdGlvbiwgc2V0WyBpIF0gXSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y2FsbDogZnVuY3Rpb24oIGluc3RhbmNlLCBuYW1lLCBhcmdzICkge1xuXHRcdFx0dmFyIGksXG5cdFx0XHRcdHNldCA9IGluc3RhbmNlLnBsdWdpbnNbIG5hbWUgXTtcblx0XHRcdGlmICggIXNldCB8fCAhaW5zdGFuY2UuZWxlbWVudFsgMCBdLnBhcmVudE5vZGUgfHwgaW5zdGFuY2UuZWxlbWVudFsgMCBdLnBhcmVudE5vZGUubm9kZVR5cGUgPT09IDExICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlLm9wdGlvbnNbIHNldFsgaSBdWyAwIF0gXSApIHtcblx0XHRcdFx0XHRzZXRbIGkgXVsgMSBdLmFwcGx5KCBpbnN0YW5jZS5lbGVtZW50LCBhcmdzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gb25seSB1c2VkIGJ5IHJlc2l6YWJsZVxuXHRoYXNTY3JvbGw6IGZ1bmN0aW9uKCBlbCwgYSApIHtcblxuXHRcdC8vSWYgb3ZlcmZsb3cgaXMgaGlkZGVuLCB0aGUgZWxlbWVudCBtaWdodCBoYXZlIGV4dHJhIGNvbnRlbnQsIGJ1dCB0aGUgdXNlciB3YW50cyB0byBoaWRlIGl0XG5cdFx0aWYgKCAkKCBlbCApLmNzcyggXCJvdmVyZmxvd1wiICkgPT09IFwiaGlkZGVuXCIpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgc2Nyb2xsID0gKCBhICYmIGEgPT09IFwibGVmdFwiICkgPyBcInNjcm9sbExlZnRcIiA6IFwic2Nyb2xsVG9wXCIsXG5cdFx0XHRoYXMgPSBmYWxzZTtcblxuXHRcdGlmICggZWxbIHNjcm9sbCBdID4gMCApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IGRldGVybWluZSB3aGljaCBjYXNlcyBhY3R1YWxseSBjYXVzZSB0aGlzIHRvIGhhcHBlblxuXHRcdC8vIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSB0aGUgc2Nyb2xsIHNldCwgc2VlIGlmIGl0J3MgcG9zc2libGUgdG9cblx0XHQvLyBzZXQgdGhlIHNjcm9sbFxuXHRcdGVsWyBzY3JvbGwgXSA9IDE7XG5cdFx0aGFzID0gKCBlbFsgc2Nyb2xsIF0gPiAwICk7XG5cdFx0ZWxbIHNjcm9sbCBdID0gMDtcblx0XHRyZXR1cm4gaGFzO1xuXHR9XG59KTtcblxufSkoIGpRdWVyeSApO1xuIiwidmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xucmVxdWlyZSgnLi9jb3JlJyk7XG5cbi8qIVxuICogalF1ZXJ5IFVJIERhdGVwaWNrZXIgMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2RhdGVwaWNrZXIvXG4gKlxuICogRGVwZW5kczpcbiAqXHRqcXVlcnkudWkuY29yZS5qc1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5leHRlbmQoJC51aSwgeyBkYXRlcGlja2VyOiB7IHZlcnNpb246IFwiMS4xMC40XCIgfSB9KTtcblxudmFyIFBST1BfTkFNRSA9IFwiZGF0ZXBpY2tlclwiLFxuXHRpbnN0QWN0aXZlO1xuXG4vKiBEYXRlIHBpY2tlciBtYW5hZ2VyLlxuICAgVXNlIHRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcywgJC5kYXRlcGlja2VyLCB0byBpbnRlcmFjdCB3aXRoIHRoZSBkYXRlIHBpY2tlci5cbiAgIFNldHRpbmdzIGZvciAoZ3JvdXBzIG9mKSBkYXRlIHBpY2tlcnMgYXJlIG1haW50YWluZWQgaW4gYW4gaW5zdGFuY2Ugb2JqZWN0LFxuICAgYWxsb3dpbmcgbXVsdGlwbGUgZGlmZmVyZW50IHNldHRpbmdzIG9uIHRoZSBzYW1lIHBhZ2UuICovXG5cbmZ1bmN0aW9uIERhdGVwaWNrZXIoKSB7XG5cdHRoaXMuX2N1ckluc3QgPSBudWxsOyAvLyBUaGUgY3VycmVudCBpbnN0YW5jZSBpbiB1c2Vcblx0dGhpcy5fa2V5RXZlbnQgPSBmYWxzZTsgLy8gSWYgdGhlIGxhc3QgZXZlbnQgd2FzIGEga2V5IGV2ZW50XG5cdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gW107IC8vIExpc3Qgb2YgZGF0ZSBwaWNrZXIgaW5wdXRzIHRoYXQgaGF2ZSBiZWVuIGRpc2FibGVkXG5cdHRoaXMuX2RhdGVwaWNrZXJTaG93aW5nID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIHBvcHVwIHBpY2tlciBpcyBzaG93aW5nICwgZmFsc2UgaWYgbm90XG5cdHRoaXMuX2luRGlhbG9nID0gZmFsc2U7IC8vIFRydWUgaWYgc2hvd2luZyB3aXRoaW4gYSBcImRpYWxvZ1wiLCBmYWxzZSBpZiBub3Rcblx0dGhpcy5fbWFpbkRpdklkID0gXCJ1aS1kYXRlcGlja2VyLWRpdlwiOyAvLyBUaGUgSUQgb2YgdGhlIG1haW4gZGF0ZXBpY2tlciBkaXZpc2lvblxuXHR0aGlzLl9pbmxpbmVDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1pbmxpbmVcIjsgLy8gVGhlIG5hbWUgb2YgdGhlIGlubGluZSBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fYXBwZW5kQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItYXBwZW5kXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBhcHBlbmQgbWFya2VyIGNsYXNzXG5cdHRoaXMuX3RyaWdnZXJDbGFzcyA9IFwidWktZGF0ZXBpY2tlci10cmlnZ2VyXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSB0cmlnZ2VyIG1hcmtlciBjbGFzc1xuXHR0aGlzLl9kaWFsb2dDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1kaWFsb2dcIjsgLy8gVGhlIG5hbWUgb2YgdGhlIGRpYWxvZyBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGlzYWJsZUNsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWRpc2FibGVkXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkaXNhYmxlZCBjb3ZlcmluZyBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItdW5zZWxlY3RhYmxlXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSB1bnNlbGVjdGFibGUgY2VsbCBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fY3VycmVudENsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWN1cnJlbnQtZGF5XCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGRheSBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGF5T3ZlckNsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWRheXMtY2VsbC1vdmVyXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkYXkgaG92ZXIgbWFya2VyIGNsYXNzXG5cdHRoaXMucmVnaW9uYWwgPSBbXTsgLy8gQXZhaWxhYmxlIHJlZ2lvbmFsIHNldHRpbmdzLCBpbmRleGVkIGJ5IGxhbmd1YWdlIGNvZGVcblx0dGhpcy5yZWdpb25hbFtcIlwiXSA9IHsgLy8gRGVmYXVsdCByZWdpb25hbCBzZXR0aW5nc1xuXHRcdGNsb3NlVGV4dDogXCJEb25lXCIsIC8vIERpc3BsYXkgdGV4dCBmb3IgY2xvc2UgbGlua1xuXHRcdHByZXZUZXh0OiBcIlByZXZcIiwgLy8gRGlzcGxheSB0ZXh0IGZvciBwcmV2aW91cyBtb250aCBsaW5rXG5cdFx0bmV4dFRleHQ6IFwiTmV4dFwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIG5leHQgbW9udGggbGlua1xuXHRcdGN1cnJlbnRUZXh0OiBcIlRvZGF5XCIsIC8vIERpc3BsYXkgdGV4dCBmb3IgY3VycmVudCBtb250aCBsaW5rXG5cdFx0bW9udGhOYW1lczogW1wiSmFudWFyeVwiLFwiRmVicnVhcnlcIixcIk1hcmNoXCIsXCJBcHJpbFwiLFwiTWF5XCIsXCJKdW5lXCIsXG5cdFx0XHRcIkp1bHlcIixcIkF1Z3VzdFwiLFwiU2VwdGVtYmVyXCIsXCJPY3RvYmVyXCIsXCJOb3ZlbWJlclwiLFwiRGVjZW1iZXJcIl0sIC8vIE5hbWVzIG9mIG1vbnRocyBmb3IgZHJvcC1kb3duIGFuZCBmb3JtYXR0aW5nXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLCAvLyBGb3IgZm9ybWF0dGluZ1xuXHRcdGRheU5hbWVzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSwgLy8gRm9yIGZvcm1hdHRpbmdcblx0XHRkYXlOYW1lc01pbjogW1wiU3VcIixcIk1vXCIsXCJUdVwiLFwiV2VcIixcIlRoXCIsXCJGclwiLFwiU2FcIl0sIC8vIENvbHVtbiBoZWFkaW5ncyBmb3IgZGF5cyBzdGFydGluZyBhdCBTdW5kYXlcblx0XHR3ZWVrSGVhZGVyOiBcIldrXCIsIC8vIENvbHVtbiBoZWFkZXIgZm9yIHdlZWsgb2YgdGhlIHllYXJcblx0XHRkYXRlRm9ybWF0OiBcIm1tL2RkL3l5XCIsIC8vIFNlZSBmb3JtYXQgb3B0aW9ucyBvbiBwYXJzZURhdGVcblx0XHRmaXJzdERheTogMCwgLy8gVGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaywgU3VuID0gMCwgTW9uID0gMSwgLi4uXG5cdFx0aXNSVEw6IGZhbHNlLCAvLyBUcnVlIGlmIHJpZ2h0LXRvLWxlZnQgbGFuZ3VhZ2UsIGZhbHNlIGlmIGxlZnQtdG8tcmlnaHRcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLCAvLyBUcnVlIGlmIHRoZSB5ZWFyIHNlbGVjdCBwcmVjZWRlcyBtb250aCwgZmFsc2UgZm9yIG1vbnRoIHRoZW4geWVhclxuXHRcdHllYXJTdWZmaXg6IFwiXCIgLy8gQWRkaXRpb25hbCB0ZXh0IHRvIGFwcGVuZCB0byB0aGUgeWVhciBpbiB0aGUgbW9udGggaGVhZGVyc1xuXHR9O1xuXHR0aGlzLl9kZWZhdWx0cyA9IHsgLy8gR2xvYmFsIGRlZmF1bHRzIGZvciBhbGwgdGhlIGRhdGUgcGlja2VyIGluc3RhbmNlc1xuXHRcdHNob3dPbjogXCJmb2N1c1wiLCAvLyBcImZvY3VzXCIgZm9yIHBvcHVwIG9uIGZvY3VzLFxuXHRcdFx0Ly8gXCJidXR0b25cIiBmb3IgdHJpZ2dlciBidXR0b24sIG9yIFwiYm90aFwiIGZvciBlaXRoZXJcblx0XHRzaG93QW5pbTogXCJmYWRlSW5cIiwgLy8gTmFtZSBvZiBqUXVlcnkgYW5pbWF0aW9uIGZvciBwb3B1cFxuXHRcdHNob3dPcHRpb25zOiB7fSwgLy8gT3B0aW9ucyBmb3IgZW5oYW5jZWQgYW5pbWF0aW9uc1xuXHRcdGRlZmF1bHREYXRlOiBudWxsLCAvLyBVc2VkIHdoZW4gZmllbGQgaXMgYmxhbms6IGFjdHVhbCBkYXRlLFxuXHRcdFx0Ly8gKy8tbnVtYmVyIGZvciBvZmZzZXQgZnJvbSB0b2RheSwgbnVsbCBmb3IgdG9kYXlcblx0XHRhcHBlbmRUZXh0OiBcIlwiLCAvLyBEaXNwbGF5IHRleHQgZm9sbG93aW5nIHRoZSBpbnB1dCBib3gsIGUuZy4gc2hvd2luZyB0aGUgZm9ybWF0XG5cdFx0YnV0dG9uVGV4dDogXCIuLi5cIiwgLy8gVGV4dCBmb3IgdHJpZ2dlciBidXR0b25cblx0XHRidXR0b25JbWFnZTogXCJcIiwgLy8gVVJMIGZvciB0cmlnZ2VyIGJ1dHRvbiBpbWFnZVxuXHRcdGJ1dHRvbkltYWdlT25seTogZmFsc2UsIC8vIFRydWUgaWYgdGhlIGltYWdlIGFwcGVhcnMgYWxvbmUsIGZhbHNlIGlmIGl0IGFwcGVhcnMgb24gYSBidXR0b25cblx0XHRoaWRlSWZOb1ByZXZOZXh0OiBmYWxzZSwgLy8gVHJ1ZSB0byBoaWRlIG5leHQvcHJldmlvdXMgbW9udGggbGlua3Ncblx0XHRcdC8vIGlmIG5vdCBhcHBsaWNhYmxlLCBmYWxzZSB0byBqdXN0IGRpc2FibGUgdGhlbVxuXHRcdG5hdmlnYXRpb25Bc0RhdGVGb3JtYXQ6IGZhbHNlLCAvLyBUcnVlIGlmIGRhdGUgZm9ybWF0dGluZyBhcHBsaWVkIHRvIHByZXYvdG9kYXkvbmV4dCBsaW5rc1xuXHRcdGdvdG9DdXJyZW50OiBmYWxzZSwgLy8gVHJ1ZSBpZiB0b2RheSBsaW5rIGdvZXMgYmFjayB0byBjdXJyZW50IHNlbGVjdGlvbiBpbnN0ZWFkXG5cdFx0Y2hhbmdlTW9udGg6IGZhbHNlLCAvLyBUcnVlIGlmIG1vbnRoIGNhbiBiZSBzZWxlY3RlZCBkaXJlY3RseSwgZmFsc2UgaWYgb25seSBwcmV2L25leHRcblx0XHRjaGFuZ2VZZWFyOiBmYWxzZSwgLy8gVHJ1ZSBpZiB5ZWFyIGNhbiBiZSBzZWxlY3RlZCBkaXJlY3RseSwgZmFsc2UgaWYgb25seSBwcmV2L25leHRcblx0XHR5ZWFyUmFuZ2U6IFwiYy0xMDpjKzEwXCIsIC8vIFJhbmdlIG9mIHllYXJzIHRvIGRpc3BsYXkgaW4gZHJvcC1kb3duLFxuXHRcdFx0Ly8gZWl0aGVyIHJlbGF0aXZlIHRvIHRvZGF5J3MgeWVhciAoLW5uOitubiksIHJlbGF0aXZlIHRvIGN1cnJlbnRseSBkaXNwbGF5ZWQgeWVhclxuXHRcdFx0Ly8gKGMtbm46YytubiksIGFic29sdXRlIChubm5uOm5ubm4pLCBvciBhIGNvbWJpbmF0aW9uIG9mIHRoZSBhYm92ZSAobm5ubjotbilcblx0XHRzaG93T3RoZXJNb250aHM6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgZGF0ZXMgaW4gb3RoZXIgbW9udGhzLCBmYWxzZSB0byBsZWF2ZSBibGFua1xuXHRcdHNlbGVjdE90aGVyTW9udGhzOiBmYWxzZSwgLy8gVHJ1ZSB0byBhbGxvdyBzZWxlY3Rpb24gb2YgZGF0ZXMgaW4gb3RoZXIgbW9udGhzLCBmYWxzZSBmb3IgdW5zZWxlY3RhYmxlXG5cdFx0c2hvd1dlZWs6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgd2VlayBvZiB0aGUgeWVhciwgZmFsc2UgdG8gbm90IHNob3cgaXRcblx0XHRjYWxjdWxhdGVXZWVrOiB0aGlzLmlzbzg2MDFXZWVrLCAvLyBIb3cgdG8gY2FsY3VsYXRlIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyLFxuXHRcdFx0Ly8gdGFrZXMgYSBEYXRlIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2YgdGhlIHdlZWsgZm9yIGl0XG5cdFx0c2hvcnRZZWFyQ3V0b2ZmOiBcIisxMFwiLCAvLyBTaG9ydCB5ZWFyIHZhbHVlcyA8IHRoaXMgYXJlIGluIHRoZSBjdXJyZW50IGNlbnR1cnksXG5cdFx0XHQvLyA+IHRoaXMgYXJlIGluIHRoZSBwcmV2aW91cyBjZW50dXJ5LFxuXHRcdFx0Ly8gc3RyaW5nIHZhbHVlIHN0YXJ0aW5nIHdpdGggXCIrXCIgZm9yIGN1cnJlbnQgeWVhciArIHZhbHVlXG5cdFx0bWluRGF0ZTogbnVsbCwgLy8gVGhlIGVhcmxpZXN0IHNlbGVjdGFibGUgZGF0ZSwgb3IgbnVsbCBmb3Igbm8gbGltaXRcblx0XHRtYXhEYXRlOiBudWxsLCAvLyBUaGUgbGF0ZXN0IHNlbGVjdGFibGUgZGF0ZSwgb3IgbnVsbCBmb3Igbm8gbGltaXRcblx0XHRkdXJhdGlvbjogXCJmYXN0XCIsIC8vIER1cmF0aW9uIG9mIGRpc3BsYXkvY2xvc3VyZVxuXHRcdGJlZm9yZVNob3dEYXk6IG51bGwsIC8vIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBkYXRlIGFuZCByZXR1cm5zIGFuIGFycmF5IHdpdGhcblx0XHRcdC8vIFswXSA9IHRydWUgaWYgc2VsZWN0YWJsZSwgZmFsc2UgaWYgbm90LCBbMV0gPSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUocykgb3IgXCJcIixcblx0XHRcdC8vIFsyXSA9IGNlbGwgdGl0bGUgKG9wdGlvbmFsKSwgZS5nLiAkLmRhdGVwaWNrZXIubm9XZWVrZW5kc1xuXHRcdGJlZm9yZVNob3c6IG51bGwsIC8vIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gaW5wdXQgZmllbGQgYW5kXG5cdFx0XHQvLyByZXR1cm5zIGEgc2V0IG9mIGN1c3RvbSBzZXR0aW5ncyBmb3IgdGhlIGRhdGUgcGlja2VyXG5cdFx0b25TZWxlY3Q6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkXG5cdFx0b25DaGFuZ2VNb250aFllYXI6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIG1vbnRoIG9yIHllYXIgaXMgY2hhbmdlZFxuXHRcdG9uQ2xvc2U6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGRhdGVwaWNrZXIgaXMgY2xvc2VkXG5cdFx0bnVtYmVyT2ZNb250aHM6IDEsIC8vIE51bWJlciBvZiBtb250aHMgdG8gc2hvdyBhdCBhIHRpbWVcblx0XHRzaG93Q3VycmVudEF0UG9zOiAwLCAvLyBUaGUgcG9zaXRpb24gaW4gbXVsdGlwZSBtb250aHMgYXQgd2hpY2ggdG8gc2hvdyB0aGUgY3VycmVudCBtb250aCAoc3RhcnRpbmcgYXQgMClcblx0XHRzdGVwTW9udGhzOiAxLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHN0ZXAgYmFjay9mb3J3YXJkXG5cdFx0c3RlcEJpZ01vbnRoczogMTIsIC8vIE51bWJlciBvZiBtb250aHMgdG8gc3RlcCBiYWNrL2ZvcndhcmQgZm9yIHRoZSBiaWcgbGlua3Ncblx0XHRhbHRGaWVsZDogXCJcIiwgLy8gU2VsZWN0b3IgZm9yIGFuIGFsdGVybmF0ZSBmaWVsZCB0byBzdG9yZSBzZWxlY3RlZCBkYXRlcyBpbnRvXG5cdFx0YWx0Rm9ybWF0OiBcIlwiLCAvLyBUaGUgZGF0ZSBmb3JtYXQgdG8gdXNlIGZvciB0aGUgYWx0ZXJuYXRlIGZpZWxkXG5cdFx0Y29uc3RyYWluSW5wdXQ6IHRydWUsIC8vIFRoZSBpbnB1dCBpcyBjb25zdHJhaW5lZCBieSB0aGUgY3VycmVudCBkYXRlIGZvcm1hdFxuXHRcdHNob3dCdXR0b25QYW5lbDogZmFsc2UsIC8vIFRydWUgdG8gc2hvdyBidXR0b24gcGFuZWwsIGZhbHNlIHRvIG5vdCBzaG93IGl0XG5cdFx0YXV0b1NpemU6IGZhbHNlLCAvLyBUcnVlIHRvIHNpemUgdGhlIGlucHV0IGZvciB0aGUgZGF0ZSBmb3JtYXQsIGZhbHNlIHRvIGxlYXZlIGFzIGlzXG5cdFx0ZGlzYWJsZWQ6IGZhbHNlIC8vIFRoZSBpbml0aWFsIGRpc2FibGVkIHN0YXRlXG5cdH07XG5cdCQuZXh0ZW5kKHRoaXMuX2RlZmF1bHRzLCB0aGlzLnJlZ2lvbmFsW1wiXCJdKTtcblx0dGhpcy5kcERpdiA9IGJpbmRIb3ZlcigkKFwiPGRpdiBpZD0nXCIgKyB0aGlzLl9tYWluRGl2SWQgKyBcIicgY2xhc3M9J3VpLWRhdGVwaWNrZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsJz48L2Rpdj5cIikpO1xufVxuXG4kLmV4dGVuZChEYXRlcGlja2VyLnByb3RvdHlwZSwge1xuXHQvKiBDbGFzcyBuYW1lIGFkZGVkIHRvIGVsZW1lbnRzIHRvIGluZGljYXRlIGFscmVhZHkgY29uZmlndXJlZCB3aXRoIGEgZGF0ZSBwaWNrZXIuICovXG5cdG1hcmtlckNsYXNzTmFtZTogXCJoYXNEYXRlcGlja2VyXCIsXG5cblx0Ly9LZWVwIHRyYWNrIG9mIHRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIGRpc3BsYXllZCAoc2VlICM3MDQzKVxuXHRtYXhSb3dzOiA0LFxuXG5cdC8vIFRPRE8gcmVuYW1lIHRvIFwid2lkZ2V0XCIgd2hlbiBzd2l0Y2hpbmcgdG8gd2lkZ2V0IGZhY3Rvcnlcblx0X3dpZGdldERhdGVwaWNrZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRwRGl2O1xuXHR9LFxuXG5cdC8qIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgaW5zdGFuY2VzIG9mIHRoZSBkYXRlIHBpY2tlci5cblx0ICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UgYXMgZGVmYXVsdHMgKGFub255bW91cyBvYmplY3QpXG5cdCAqIEByZXR1cm4gdGhlIG1hbmFnZXIgb2JqZWN0XG5cdCAqL1xuXHRzZXREZWZhdWx0czogZnVuY3Rpb24oc2V0dGluZ3MpIHtcblx0XHRleHRlbmRSZW1vdmUodGhpcy5fZGVmYXVsdHMsIHNldHRpbmdzIHx8IHt9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiBBdHRhY2ggdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UgZm9yIHRoaXMgZGF0ZSBwaWNrZXIgaW5zdGFuY2UgKGFub255bW91cylcblx0ICovXG5cdF9hdHRhY2hEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIHNldHRpbmdzKSB7XG5cdFx0dmFyIG5vZGVOYW1lLCBpbmxpbmUsIGluc3Q7XG5cdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpbmxpbmUgPSAobm9kZU5hbWUgPT09IFwiZGl2XCIgfHwgbm9kZU5hbWUgPT09IFwic3BhblwiKTtcblx0XHRpZiAoIXRhcmdldC5pZCkge1xuXHRcdFx0dGhpcy51dWlkICs9IDE7XG5cdFx0XHR0YXJnZXQuaWQgPSBcImRwXCIgKyB0aGlzLnV1aWQ7XG5cdFx0fVxuXHRcdGluc3QgPSB0aGlzLl9uZXdJbnN0KCQodGFyZ2V0KSwgaW5saW5lKTtcblx0XHRpbnN0LnNldHRpbmdzID0gJC5leHRlbmQoe30sIHNldHRpbmdzIHx8IHt9KTtcblx0XHRpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIikge1xuXHRcdFx0dGhpcy5fY29ubmVjdERhdGVwaWNrZXIodGFyZ2V0LCBpbnN0KTtcblx0XHR9IGVsc2UgaWYgKGlubGluZSkge1xuXHRcdFx0dGhpcy5faW5saW5lRGF0ZXBpY2tlcih0YXJnZXQsIGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2JqZWN0LiAqL1xuXHRfbmV3SW5zdDogZnVuY3Rpb24odGFyZ2V0LCBpbmxpbmUpIHtcblx0XHR2YXIgaWQgPSB0YXJnZXRbMF0uaWQucmVwbGFjZSgvKFteQS1aYS16MC05X1xcLV0pL2csIFwiXFxcXFxcXFwkMVwiKTsgLy8gZXNjYXBlIGpRdWVyeSBtZXRhIGNoYXJzXG5cdFx0cmV0dXJuIHtpZDogaWQsIGlucHV0OiB0YXJnZXQsIC8vIGFzc29jaWF0ZWQgdGFyZ2V0XG5cdFx0XHRzZWxlY3RlZERheTogMCwgc2VsZWN0ZWRNb250aDogMCwgc2VsZWN0ZWRZZWFyOiAwLCAvLyBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0ZHJhd01vbnRoOiAwLCBkcmF3WWVhcjogMCwgLy8gbW9udGggYmVpbmcgZHJhd25cblx0XHRcdGlubGluZTogaW5saW5lLCAvLyBpcyBkYXRlcGlja2VyIGlubGluZSBvciBub3Rcblx0XHRcdGRwRGl2OiAoIWlubGluZSA/IHRoaXMuZHBEaXYgOiAvLyBwcmVzZW50YXRpb24gZGl2XG5cdFx0XHRiaW5kSG92ZXIoJChcIjxkaXYgY2xhc3M9J1wiICsgdGhpcy5faW5saW5lQ2xhc3MgKyBcIiB1aS1kYXRlcGlja2VyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLWFsbCc+PC9kaXY+XCIpKSl9O1xuXHR9LFxuXG5cdC8qIEF0dGFjaCB0aGUgZGF0ZSBwaWNrZXIgdG8gYW4gaW5wdXQgZmllbGQuICovXG5cdF9jb25uZWN0RGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBpbnN0KSB7XG5cdFx0dmFyIGlucHV0ID0gJCh0YXJnZXQpO1xuXHRcdGluc3QuYXBwZW5kID0gJChbXSk7XG5cdFx0aW5zdC50cmlnZ2VyID0gJChbXSk7XG5cdFx0aWYgKGlucHV0Lmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9hdHRhY2htZW50cyhpbnB1dCwgaW5zdCk7XG5cdFx0aW5wdXQuYWRkQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpLmtleWRvd24odGhpcy5fZG9LZXlEb3duKS5cblx0XHRcdGtleXByZXNzKHRoaXMuX2RvS2V5UHJlc3MpLmtleXVwKHRoaXMuX2RvS2V5VXApO1xuXHRcdHRoaXMuX2F1dG9TaXplKGluc3QpO1xuXHRcdCQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSwgaW5zdCk7XG5cdFx0Ly9JZiBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZSwgZGlzYWJsZSB0aGUgZGF0ZXBpY2tlciBvbmNlIGl0IGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoZSBpbnB1dCAoc2VlIHRpY2tldCAjNTY2NSlcblx0XHRpZiggaW5zdC5zZXR0aW5ncy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX2Rpc2FibGVEYXRlcGlja2VyKCB0YXJnZXQgKTtcblx0XHR9XG5cdH0sXG5cblx0LyogTWFrZSBhdHRhY2htZW50cyBiYXNlZCBvbiBzZXR0aW5ncy4gKi9cblx0X2F0dGFjaG1lbnRzOiBmdW5jdGlvbihpbnB1dCwgaW5zdCkge1xuXHRcdHZhciBzaG93T24sIGJ1dHRvblRleHQsIGJ1dHRvbkltYWdlLFxuXHRcdFx0YXBwZW5kVGV4dCA9IHRoaXMuX2dldChpbnN0LCBcImFwcGVuZFRleHRcIiksXG5cdFx0XHRpc1JUTCA9IHRoaXMuX2dldChpbnN0LCBcImlzUlRMXCIpO1xuXG5cdFx0aWYgKGluc3QuYXBwZW5kKSB7XG5cdFx0XHRpbnN0LmFwcGVuZC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0aWYgKGFwcGVuZFRleHQpIHtcblx0XHRcdGluc3QuYXBwZW5kID0gJChcIjxzcGFuIGNsYXNzPSdcIiArIHRoaXMuX2FwcGVuZENsYXNzICsgXCInPlwiICsgYXBwZW5kVGV4dCArIFwiPC9zcGFuPlwiKTtcblx0XHRcdGlucHV0W2lzUlRMID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIl0oaW5zdC5hcHBlbmQpO1xuXHRcdH1cblxuXHRcdGlucHV0LnVuYmluZChcImZvY3VzXCIsIHRoaXMuX3Nob3dEYXRlcGlja2VyKTtcblxuXHRcdGlmIChpbnN0LnRyaWdnZXIpIHtcblx0XHRcdGluc3QudHJpZ2dlci5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRzaG93T24gPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG93T25cIik7XG5cdFx0aWYgKHNob3dPbiA9PT0gXCJmb2N1c1wiIHx8IHNob3dPbiA9PT0gXCJib3RoXCIpIHsgLy8gcG9wLXVwIGRhdGUgcGlja2VyIHdoZW4gaW4gdGhlIG1hcmtlZCBmaWVsZFxuXHRcdFx0aW5wdXQuZm9jdXModGhpcy5fc2hvd0RhdGVwaWNrZXIpO1xuXHRcdH1cblx0XHRpZiAoc2hvd09uID09PSBcImJ1dHRvblwiIHx8IHNob3dPbiA9PT0gXCJib3RoXCIpIHsgLy8gcG9wLXVwIGRhdGUgcGlja2VyIHdoZW4gYnV0dG9uIGNsaWNrZWRcblx0XHRcdGJ1dHRvblRleHQgPSB0aGlzLl9nZXQoaW5zdCwgXCJidXR0b25UZXh0XCIpO1xuXHRcdFx0YnV0dG9uSW1hZ2UgPSB0aGlzLl9nZXQoaW5zdCwgXCJidXR0b25JbWFnZVwiKTtcblx0XHRcdGluc3QudHJpZ2dlciA9ICQodGhpcy5fZ2V0KGluc3QsIFwiYnV0dG9uSW1hZ2VPbmx5XCIpID9cblx0XHRcdFx0JChcIjxpbWcvPlwiKS5hZGRDbGFzcyh0aGlzLl90cmlnZ2VyQ2xhc3MpLlxuXHRcdFx0XHRcdGF0dHIoeyBzcmM6IGJ1dHRvbkltYWdlLCBhbHQ6IGJ1dHRvblRleHQsIHRpdGxlOiBidXR0b25UZXh0IH0pIDpcblx0XHRcdFx0JChcIjxidXR0b24gdHlwZT0nYnV0dG9uJz48L2J1dHRvbj5cIikuYWRkQ2xhc3ModGhpcy5fdHJpZ2dlckNsYXNzKS5cblx0XHRcdFx0XHRodG1sKCFidXR0b25JbWFnZSA/IGJ1dHRvblRleHQgOiAkKFwiPGltZy8+XCIpLmF0dHIoXG5cdFx0XHRcdFx0eyBzcmM6YnV0dG9uSW1hZ2UsIGFsdDpidXR0b25UZXh0LCB0aXRsZTpidXR0b25UZXh0IH0pKSk7XG5cdFx0XHRpbnB1dFtpc1JUTCA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCJdKGluc3QudHJpZ2dlcik7XG5cdFx0XHRpbnN0LnRyaWdnZXIuY2xpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICgkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID09PSBpbnB1dFswXSkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0fSBlbHNlIGlmICgkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ICE9PSBpbnB1dFswXSkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKGlucHV0WzBdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKGlucHV0WzBdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyogQXBwbHkgdGhlIG1heGltdW0gbGVuZ3RoIGZvciB0aGUgZGF0ZSBmb3JtYXQuICovXG5cdF9hdXRvU2l6ZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdGlmICh0aGlzLl9nZXQoaW5zdCwgXCJhdXRvU2l6ZVwiKSAmJiAhaW5zdC5pbmxpbmUpIHtcblx0XHRcdHZhciBmaW5kTWF4LCBtYXgsIG1heEksIGksXG5cdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSgyMDA5LCAxMiAtIDEsIDIwKSwgLy8gRW5zdXJlIGRvdWJsZSBkaWdpdHNcblx0XHRcdFx0ZGF0ZUZvcm1hdCA9IHRoaXMuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIik7XG5cblx0XHRcdGlmIChkYXRlRm9ybWF0Lm1hdGNoKC9bRE1dLykpIHtcblx0XHRcdFx0ZmluZE1heCA9IGZ1bmN0aW9uKG5hbWVzKSB7XG5cdFx0XHRcdFx0bWF4ID0gMDtcblx0XHRcdFx0XHRtYXhJID0gMDtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChuYW1lc1tpXS5sZW5ndGggPiBtYXgpIHtcblx0XHRcdFx0XHRcdFx0bWF4ID0gbmFtZXNbaV0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRtYXhJID0gaTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1heEk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGRhdGUuc2V0TW9udGgoZmluZE1heCh0aGlzLl9nZXQoaW5zdCwgKGRhdGVGb3JtYXQubWF0Y2goL01NLykgP1xuXHRcdFx0XHRcdFwibW9udGhOYW1lc1wiIDogXCJtb250aE5hbWVzU2hvcnRcIikpKSk7XG5cdFx0XHRcdGRhdGUuc2V0RGF0ZShmaW5kTWF4KHRoaXMuX2dldChpbnN0LCAoZGF0ZUZvcm1hdC5tYXRjaCgvREQvKSA/XG5cdFx0XHRcdFx0XCJkYXlOYW1lc1wiIDogXCJkYXlOYW1lc1Nob3J0XCIpKSkgKyAyMCAtIGRhdGUuZ2V0RGF5KCkpO1xuXHRcdFx0fVxuXHRcdFx0aW5zdC5pbnB1dC5hdHRyKFwic2l6ZVwiLCB0aGlzLl9mb3JtYXREYXRlKGluc3QsIGRhdGUpLmxlbmd0aCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEF0dGFjaCBhbiBpbmxpbmUgZGF0ZSBwaWNrZXIgdG8gYSBkaXYuICovXG5cdF9pbmxpbmVEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIGluc3QpIHtcblx0XHR2YXIgZGl2U3BhbiA9ICQodGFyZ2V0KTtcblx0XHRpZiAoZGl2U3Bhbi5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZGl2U3Bhbi5hZGRDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuYXBwZW5kKGluc3QuZHBEaXYpO1xuXHRcdCQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSwgaW5zdCk7XG5cdFx0dGhpcy5fc2V0RGF0ZShpbnN0LCB0aGlzLl9nZXREZWZhdWx0RGF0ZShpbnN0KSwgdHJ1ZSk7XG5cdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XG5cdFx0Ly9JZiBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZSwgZGlzYWJsZSB0aGUgZGF0ZXBpY2tlciBiZWZvcmUgc2hvd2luZyBpdCAoc2VlIHRpY2tldCAjNTY2NSlcblx0XHRpZiggaW5zdC5zZXR0aW5ncy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX2Rpc2FibGVEYXRlcGlja2VyKCB0YXJnZXQgKTtcblx0XHR9XG5cdFx0Ly8gU2V0IGRpc3BsYXk6YmxvY2sgaW4gcGxhY2Ugb2YgaW5zdC5kcERpdi5zaG93KCkgd2hpY2ggd29uJ3Qgd29yayBvbiBkaXNjb25uZWN0ZWQgZWxlbWVudHNcblx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnl1aS5jb20vdGlja2V0Lzc1NTIgLSBBIERhdGVwaWNrZXIgY3JlYXRlZCBvbiBhIGRldGFjaGVkIGRpdiBoYXMgemVybyBoZWlnaHRcblx0XHRpbnN0LmRwRGl2LmNzcyggXCJkaXNwbGF5XCIsIFwiYmxvY2tcIiApO1xuXHR9LFxuXG5cdC8qIFBvcC11cCB0aGUgZGF0ZSBwaWNrZXIgaW4gYSBcImRpYWxvZ1wiIGJveC5cblx0ICogQHBhcmFtICBpbnB1dCBlbGVtZW50IC0gaWdub3JlZFxuXHQgKiBAcGFyYW0gIGRhdGVcdHN0cmluZyBvciBEYXRlIC0gdGhlIGluaXRpYWwgZGF0ZSB0byBkaXNwbGF5XG5cdCAqIEBwYXJhbSAgb25TZWxlY3QgIGZ1bmN0aW9uIC0gdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWRcblx0ICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdXBkYXRlIHRoZSBkaWFsb2cgZGF0ZSBwaWNrZXIgaW5zdGFuY2UncyBzZXR0aW5ncyAoYW5vbnltb3VzIG9iamVjdClcblx0ICogQHBhcmFtICBwb3MgaW50WzJdIC0gY29vcmRpbmF0ZXMgZm9yIHRoZSBkaWFsb2cncyBwb3NpdGlvbiB3aXRoaW4gdGhlIHNjcmVlbiBvclxuXHQgKlx0XHRcdFx0XHRldmVudCAtIHdpdGggeC95IGNvb3JkaW5hdGVzIG9yXG5cdCAqXHRcdFx0XHRcdGxlYXZlIGVtcHR5IGZvciBkZWZhdWx0IChzY3JlZW4gY2VudHJlKVxuXHQgKiBAcmV0dXJuIHRoZSBtYW5hZ2VyIG9iamVjdFxuXHQgKi9cblx0X2RpYWxvZ0RhdGVwaWNrZXI6IGZ1bmN0aW9uKGlucHV0LCBkYXRlLCBvblNlbGVjdCwgc2V0dGluZ3MsIHBvcykge1xuXHRcdHZhciBpZCwgYnJvd3NlcldpZHRoLCBicm93c2VySGVpZ2h0LCBzY3JvbGxYLCBzY3JvbGxZLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2RpYWxvZ0luc3Q7IC8vIGludGVybmFsIGluc3RhbmNlXG5cblx0XHRpZiAoIWluc3QpIHtcblx0XHRcdHRoaXMudXVpZCArPSAxO1xuXHRcdFx0aWQgPSBcImRwXCIgKyB0aGlzLnV1aWQ7XG5cdFx0XHR0aGlzLl9kaWFsb2dJbnB1dCA9ICQoXCI8aW5wdXQgdHlwZT0ndGV4dCcgaWQ9J1wiICsgaWQgK1xuXHRcdFx0XHRcIicgc3R5bGU9J3Bvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAtMTAwcHg7IHdpZHRoOiAwcHg7Jy8+XCIpO1xuXHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQua2V5ZG93bih0aGlzLl9kb0tleURvd24pO1xuXHRcdFx0JChcImJvZHlcIikuYXBwZW5kKHRoaXMuX2RpYWxvZ0lucHV0KTtcblx0XHRcdGluc3QgPSB0aGlzLl9kaWFsb2dJbnN0ID0gdGhpcy5fbmV3SW5zdCh0aGlzLl9kaWFsb2dJbnB1dCwgZmFsc2UpO1xuXHRcdFx0aW5zdC5zZXR0aW5ncyA9IHt9O1xuXHRcdFx0JC5kYXRhKHRoaXMuX2RpYWxvZ0lucHV0WzBdLCBQUk9QX05BTUUsIGluc3QpO1xuXHRcdH1cblx0XHRleHRlbmRSZW1vdmUoaW5zdC5zZXR0aW5ncywgc2V0dGluZ3MgfHwge30pO1xuXHRcdGRhdGUgPSAoZGF0ZSAmJiBkYXRlLmNvbnN0cnVjdG9yID09PSBEYXRlID8gdGhpcy5fZm9ybWF0RGF0ZShpbnN0LCBkYXRlKSA6IGRhdGUpO1xuXHRcdHRoaXMuX2RpYWxvZ0lucHV0LnZhbChkYXRlKTtcblxuXHRcdHRoaXMuX3BvcyA9IChwb3MgPyAocG9zLmxlbmd0aCA/IHBvcyA6IFtwb3MucGFnZVgsIHBvcy5wYWdlWV0pIDogbnVsbCk7XG5cdFx0aWYgKCF0aGlzLl9wb3MpIHtcblx0XHRcdGJyb3dzZXJXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcblx0XHRcdGJyb3dzZXJIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXHRcdFx0c2Nyb2xsWCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcblx0XHRcdHNjcm9sbFkgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuXHRcdFx0dGhpcy5fcG9zID0gLy8gc2hvdWxkIHVzZSBhY3R1YWwgd2lkdGgvaGVpZ2h0IGJlbG93XG5cdFx0XHRcdFsoYnJvd3NlcldpZHRoIC8gMikgLSAxMDAgKyBzY3JvbGxYLCAoYnJvd3NlckhlaWdodCAvIDIpIC0gMTUwICsgc2Nyb2xsWV07XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZSBpbnB1dCBvbiBzY3JlZW4gZm9yIGZvY3VzLCBidXQgaGlkZGVuIGJlaGluZCBkaWFsb2dcblx0XHR0aGlzLl9kaWFsb2dJbnB1dC5jc3MoXCJsZWZ0XCIsICh0aGlzLl9wb3NbMF0gKyAyMCkgKyBcInB4XCIpLmNzcyhcInRvcFwiLCB0aGlzLl9wb3NbMV0gKyBcInB4XCIpO1xuXHRcdGluc3Quc2V0dGluZ3Mub25TZWxlY3QgPSBvblNlbGVjdDtcblx0XHR0aGlzLl9pbkRpYWxvZyA9IHRydWU7XG5cdFx0dGhpcy5kcERpdi5hZGRDbGFzcyh0aGlzLl9kaWFsb2dDbGFzcyk7XG5cdFx0dGhpcy5fc2hvd0RhdGVwaWNrZXIodGhpcy5fZGlhbG9nSW5wdXRbMF0pO1xuXHRcdGlmICgkLmJsb2NrVUkpIHtcblx0XHRcdCQuYmxvY2tVSSh0aGlzLmRwRGl2KTtcblx0XHR9XG5cdFx0JC5kYXRhKHRoaXMuX2RpYWxvZ0lucHV0WzBdLCBQUk9QX05BTUUsIGluc3QpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qIERldGFjaCBhIGRhdGVwaWNrZXIgZnJvbSBpdHMgY29udHJvbC5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9kZXN0cm95RGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyIG5vZGVOYW1lLFxuXHRcdFx0JHRhcmdldCA9ICQodGFyZ2V0KSxcblx0XHRcdGluc3QgPSAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXG5cdFx0aWYgKCEkdGFyZ2V0Lmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0JC5yZW1vdmVEYXRhKHRhcmdldCwgUFJPUF9OQU1FKTtcblx0XHRpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIikge1xuXHRcdFx0aW5zdC5hcHBlbmQucmVtb3ZlKCk7XG5cdFx0XHRpbnN0LnRyaWdnZXIucmVtb3ZlKCk7XG5cdFx0XHQkdGFyZ2V0LnJlbW92ZUNsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKS5cblx0XHRcdFx0dW5iaW5kKFwiZm9jdXNcIiwgdGhpcy5fc2hvd0RhdGVwaWNrZXIpLlxuXHRcdFx0XHR1bmJpbmQoXCJrZXlkb3duXCIsIHRoaXMuX2RvS2V5RG93bikuXG5cdFx0XHRcdHVuYmluZChcImtleXByZXNzXCIsIHRoaXMuX2RvS2V5UHJlc3MpLlxuXHRcdFx0XHR1bmJpbmQoXCJrZXl1cFwiLCB0aGlzLl9kb0tleVVwKTtcblx0XHR9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIikge1xuXHRcdFx0JHRhcmdldC5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuZW1wdHkoKTtcblx0XHR9XG5cdH0sXG5cblx0LyogRW5hYmxlIHRoZSBkYXRlIHBpY2tlciB0byBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfZW5hYmxlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyIG5vZGVOYW1lLCBpbmxpbmUsXG5cdFx0XHQkdGFyZ2V0ID0gJCh0YXJnZXQpLFxuXHRcdFx0aW5zdCA9ICQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSk7XG5cblx0XHRpZiAoISR0YXJnZXQuaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIikge1xuXHRcdFx0dGFyZ2V0LmRpc2FibGVkID0gZmFsc2U7XG5cdFx0XHRpbnN0LnRyaWdnZXIuZmlsdGVyKFwiYnV0dG9uXCIpLlxuXHRcdFx0XHRlYWNoKGZ1bmN0aW9uKCkgeyB0aGlzLmRpc2FibGVkID0gZmFsc2U7IH0pLmVuZCgpLlxuXHRcdFx0XHRmaWx0ZXIoXCJpbWdcIikuY3NzKHtvcGFjaXR5OiBcIjEuMFwiLCBjdXJzb3I6IFwiXCJ9KTtcblx0XHR9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIikge1xuXHRcdFx0aW5saW5lID0gJHRhcmdldC5jaGlsZHJlbihcIi5cIiArIHRoaXMuX2lubGluZUNsYXNzKTtcblx0XHRcdGlubGluZS5jaGlsZHJlbigpLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtZGlzYWJsZWRcIik7XG5cdFx0XHRpbmxpbmUuZmluZChcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIpLlxuXHRcdFx0XHRwcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuXHRcdH1cblx0XHR0aGlzLl9kaXNhYmxlZElucHV0cyA9ICQubWFwKHRoaXMuX2Rpc2FibGVkSW5wdXRzLFxuXHRcdFx0ZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuICh2YWx1ZSA9PT0gdGFyZ2V0ID8gbnVsbCA6IHZhbHVlKTsgfSk7IC8vIGRlbGV0ZSBlbnRyeVxuXHR9LFxuXG5cdC8qIERpc2FibGUgdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9kaXNhYmxlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyIG5vZGVOYW1lLCBpbmxpbmUsXG5cdFx0XHQkdGFyZ2V0ID0gJCh0YXJnZXQpLFxuXHRcdFx0aW5zdCA9ICQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSk7XG5cblx0XHRpZiAoISR0YXJnZXQuaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIikge1xuXHRcdFx0dGFyZ2V0LmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGluc3QudHJpZ2dlci5maWx0ZXIoXCJidXR0b25cIikuXG5cdFx0XHRcdGVhY2goZnVuY3Rpb24oKSB7IHRoaXMuZGlzYWJsZWQgPSB0cnVlOyB9KS5lbmQoKS5cblx0XHRcdFx0ZmlsdGVyKFwiaW1nXCIpLmNzcyh7b3BhY2l0eTogXCIwLjVcIiwgY3Vyc29yOiBcImRlZmF1bHRcIn0pO1xuXHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgPT09IFwiZGl2XCIgfHwgbm9kZU5hbWUgPT09IFwic3BhblwiKSB7XG5cdFx0XHRpbmxpbmUgPSAkdGFyZ2V0LmNoaWxkcmVuKFwiLlwiICsgdGhpcy5faW5saW5lQ2xhc3MpO1xuXHRcdFx0aW5saW5lLmNoaWxkcmVuKCkuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiKTtcblx0XHRcdGlubGluZS5maW5kKFwic2VsZWN0LnVpLWRhdGVwaWNrZXItbW9udGgsIHNlbGVjdC51aS1kYXRlcGlja2VyLXllYXJcIikuXG5cdFx0XHRcdHByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcblx0XHR9XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHMgPSAkLm1hcCh0aGlzLl9kaXNhYmxlZElucHV0cyxcblx0XHRcdGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT09IHRhcmdldCA/IG51bGwgOiB2YWx1ZSk7IH0pOyAvLyBkZWxldGUgZW50cnlcblx0XHR0aGlzLl9kaXNhYmxlZElucHV0c1t0aGlzLl9kaXNhYmxlZElucHV0cy5sZW5ndGhdID0gdGFyZ2V0O1xuXHR9LFxuXG5cdC8qIElzIHRoZSBmaXJzdCBmaWVsZCBpbiBhIGpRdWVyeSBjb2xsZWN0aW9uIGRpc2FibGVkIGFzIGEgZGF0ZXBpY2tlcj9cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHJldHVybiBib29sZWFuIC0gdHJ1ZSBpZiBkaXNhYmxlZCwgZmFsc2UgaWYgZW5hYmxlZFxuXHQgKi9cblx0X2lzRGlzYWJsZWREYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRpZiAoIXRhcmdldCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2Rpc2FibGVkSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5fZGlzYWJsZWRJbnB1dHNbaV0gPT09IHRhcmdldCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qIFJldHJpZXZlIHRoZSBpbnN0YW5jZSBkYXRhIGZvciB0aGUgdGFyZ2V0IGNvbnRyb2wuXG5cdCAqIEBwYXJhbSAgdGFyZ2V0ICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEByZXR1cm4gIG9iamVjdCAtIHRoZSBhc3NvY2lhdGVkIGluc3RhbmNlIGRhdGFcblx0ICogQHRocm93cyAgZXJyb3IgaWYgYSBqUXVlcnkgcHJvYmxlbSBnZXR0aW5nIGRhdGFcblx0ICovXG5cdF9nZXRJbnN0OiBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuICQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSk7XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdHRocm93IFwiTWlzc2luZyBpbnN0YW5jZSBkYXRhIGZvciB0aGlzIGRhdGVwaWNrZXJcIjtcblx0XHR9XG5cdH0sXG5cblx0LyogVXBkYXRlIG9yIHJldHJpZXZlIHRoZSBzZXR0aW5ncyBmb3IgYSBkYXRlIHBpY2tlciBhdHRhY2hlZCB0byBhbiBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBuYW1lXHRvYmplY3QgLSB0aGUgbmV3IHNldHRpbmdzIHRvIHVwZGF0ZSBvclxuXHQgKlx0XHRcdFx0c3RyaW5nIC0gdGhlIG5hbWUgb2YgdGhlIHNldHRpbmcgdG8gY2hhbmdlIG9yIHJldHJpZXZlLFxuXHQgKlx0XHRcdFx0d2hlbiByZXRyaWV2aW5nIGFsc28gXCJhbGxcIiBmb3IgYWxsIGluc3RhbmNlIHNldHRpbmdzIG9yXG5cdCAqXHRcdFx0XHRcImRlZmF1bHRzXCIgZm9yIGFsbCBnbG9iYWwgZGVmYXVsdHNcblx0ICogQHBhcmFtICB2YWx1ZSAgIGFueSAtIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzZXR0aW5nXG5cdCAqXHRcdFx0XHQob21pdCBpZiBhYm92ZSBpcyBhbiBvYmplY3Qgb3IgdG8gcmV0cmlldmUgYSB2YWx1ZSlcblx0ICovXG5cdF9vcHRpb25EYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG5cdFx0dmFyIHNldHRpbmdzLCBkYXRlLCBtaW5EYXRlLCBtYXhEYXRlLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRyZXR1cm4gKG5hbWUgPT09IFwiZGVmYXVsdHNcIiA/ICQuZXh0ZW5kKHt9LCAkLmRhdGVwaWNrZXIuX2RlZmF1bHRzKSA6XG5cdFx0XHRcdChpbnN0ID8gKG5hbWUgPT09IFwiYWxsXCIgPyAkLmV4dGVuZCh7fSwgaW5zdC5zZXR0aW5ncykgOlxuXHRcdFx0XHR0aGlzLl9nZXQoaW5zdCwgbmFtZSkpIDogbnVsbCkpO1xuXHRcdH1cblxuXHRcdHNldHRpbmdzID0gbmFtZSB8fCB7fTtcblx0XHRpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHNldHRpbmdzID0ge307XG5cdFx0XHRzZXR0aW5nc1tuYW1lXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmIChpbnN0KSB7XG5cdFx0XHRpZiAodGhpcy5fY3VySW5zdCA9PT0gaW5zdCkge1xuXHRcdFx0XHR0aGlzLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0fVxuXG5cdFx0XHRkYXRlID0gdGhpcy5fZ2V0RGF0ZURhdGVwaWNrZXIodGFyZ2V0LCB0cnVlKTtcblx0XHRcdG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWluXCIpO1xuXHRcdFx0bWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXCJtYXhcIik7XG5cdFx0XHRleHRlbmRSZW1vdmUoaW5zdC5zZXR0aW5ncywgc2V0dGluZ3MpO1xuXHRcdFx0Ly8gcmVmb3JtYXQgdGhlIG9sZCBtaW5EYXRlL21heERhdGUgdmFsdWVzIGlmIGRhdGVGb3JtYXQgY2hhbmdlcyBhbmQgYSBuZXcgbWluRGF0ZS9tYXhEYXRlIGlzbid0IHByb3ZpZGVkXG5cdFx0XHRpZiAobWluRGF0ZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5kYXRlRm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MubWluRGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGluc3Quc2V0dGluZ3MubWluRGF0ZSA9IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgbWluRGF0ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobWF4RGF0ZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5kYXRlRm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MubWF4RGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGluc3Quc2V0dGluZ3MubWF4RGF0ZSA9IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgbWF4RGF0ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIFwiZGlzYWJsZWRcIiBpbiBzZXR0aW5ncyApIHtcblx0XHRcdFx0aWYgKCBzZXR0aW5ncy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHR0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlcih0YXJnZXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2VuYWJsZURhdGVwaWNrZXIodGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYXR0YWNobWVudHMoJCh0YXJnZXQpLCBpbnN0KTtcblx0XHRcdHRoaXMuX2F1dG9TaXplKGluc3QpO1xuXHRcdFx0dGhpcy5fc2V0RGF0ZShpbnN0LCBkYXRlKTtcblx0XHRcdHRoaXMuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNoYW5nZSBtZXRob2QgZGVwcmVjYXRlZFxuXHRfY2hhbmdlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMuX29wdGlvbkRhdGVwaWNrZXIodGFyZ2V0LCBuYW1lLCB2YWx1ZSk7XG5cdH0sXG5cblx0LyogUmVkcmF3IHRoZSBkYXRlIHBpY2tlciBhdHRhY2hlZCB0byBhbiBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9yZWZyZXNoRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cdFx0aWYgKGluc3QpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFNldCB0aGUgZGF0ZXMgZm9yIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKiBAcGFyYW0gIGRhdGVcdERhdGUgLSB0aGUgbmV3IGRhdGVcblx0ICovXG5cdF9zZXREYXRlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBkYXRlKSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cdFx0aWYgKGluc3QpIHtcblx0XHRcdHRoaXMuX3NldERhdGUoaW5zdCwgZGF0ZSk7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBHZXQgdGhlIGRhdGUocykgZm9yIHRoZSBmaXJzdCBlbnRyeSBpbiBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0IGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBub0RlZmF1bHQgYm9vbGVhbiAtIHRydWUgaWYgbm8gZGVmYXVsdCBkYXRlIGlzIHRvIGJlIHVzZWRcblx0ICogQHJldHVybiBEYXRlIC0gdGhlIGN1cnJlbnQgZGF0ZVxuXHQgKi9cblx0X2dldERhdGVEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIG5vRGVmYXVsdCkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmIChpbnN0ICYmICFpbnN0LmlubGluZSkge1xuXHRcdFx0dGhpcy5fc2V0RGF0ZUZyb21GaWVsZChpbnN0LCBub0RlZmF1bHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gKGluc3QgPyB0aGlzLl9nZXREYXRlKGluc3QpIDogbnVsbCk7XG5cdH0sXG5cblx0LyogSGFuZGxlIGtleXN0cm9rZXMuICovXG5cdF9kb0tleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIG9uU2VsZWN0LCBkYXRlU3RyLCBzZWwsXG5cdFx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KGV2ZW50LnRhcmdldCksXG5cdFx0XHRoYW5kbGVkID0gdHJ1ZSxcblx0XHRcdGlzUlRMID0gaW5zdC5kcERpdi5pcyhcIi51aS1kYXRlcGlja2VyLXJ0bFwiKTtcblxuXHRcdGluc3QuX2tleUV2ZW50ID0gdHJ1ZTtcblx0XHRpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZykge1xuXHRcdFx0c3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG5cdFx0XHRcdGNhc2UgOTogJC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGhpZGUgb24gdGFiIG91dFxuXHRcdFx0XHRjYXNlIDEzOiBzZWwgPSAkKFwidGQuXCIgKyAkLmRhdGVwaWNrZXIuX2RheU92ZXJDbGFzcyArIFwiOm5vdCguXCIgK1xuXHRcdFx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9jdXJyZW50Q2xhc3MgKyBcIilcIiwgaW5zdC5kcERpdik7XG5cdFx0XHRcdFx0XHRpZiAoc2VsWzBdKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2VsZWN0RGF5KGV2ZW50LnRhcmdldCwgaW5zdC5zZWxlY3RlZE1vbnRoLCBpbnN0LnNlbGVjdGVkWWVhciwgc2VsWzBdKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0b25TZWxlY3QgPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcIm9uU2VsZWN0XCIpO1xuXHRcdFx0XHRcdFx0aWYgKG9uU2VsZWN0KSB7XG5cdFx0XHRcdFx0XHRcdGRhdGVTdHIgPSAkLmRhdGVwaWNrZXIuX2Zvcm1hdERhdGUoaW5zdCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gdHJpZ2dlciBjdXN0b20gY2FsbGJhY2tcblx0XHRcdFx0XHRcdFx0b25TZWxlY3QuYXBwbHkoKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCksIFtkYXRlU3RyLCBpbnN0XSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gZG9uJ3Qgc3VibWl0IHRoZSBmb3JtXG5cdFx0XHRcdGNhc2UgMjc6ICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBoaWRlIG9uIGVzY2FwZVxuXHRcdFx0XHRjYXNlIDMzOiAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAoZXZlbnQuY3RybEtleSA/XG5cdFx0XHRcdFx0XHRcdC0kLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBCaWdNb250aHNcIikgOlxuXHRcdFx0XHRcdFx0XHQtJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwTW9udGhzXCIpKSwgXCJNXCIpO1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIHByZXZpb3VzIG1vbnRoL3llYXIgb24gcGFnZSB1cC8rIGN0cmxcblx0XHRcdFx0Y2FzZSAzNDogJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHQrJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIpIDpcblx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic3RlcE1vbnRoc1wiKSksIFwiTVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBuZXh0IG1vbnRoL3llYXIgb24gcGFnZSBkb3duLysgY3RybFxuXHRcdFx0XHRjYXNlIDM1OiBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fY2xlYXJEYXRlKGV2ZW50LnRhcmdldCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGNsZWFyIG9uIGN0cmwgb3IgY29tbWFuZCArZW5kXG5cdFx0XHRcdGNhc2UgMzY6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9nb3RvVG9kYXkoZXZlbnQudGFyZ2V0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gY3VycmVudCBvbiBjdHJsIG9yIGNvbW1hbmQgK2hvbWVcblx0XHRcdFx0Y2FzZSAzNzogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAoaXNSVEwgPyArMSA6IC0xKSwgXCJEXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdC8vIC0xIGRheSBvbiBjdHJsIG9yIGNvbW1hbmQgK2xlZnRcblx0XHRcdFx0XHRcdGlmIChldmVudC5vcmlnaW5hbEV2ZW50LmFsdEtleSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAoZXZlbnQuY3RybEtleSA/XG5cdFx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic3RlcEJpZ01vbnRoc1wiKSA6XG5cdFx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic3RlcE1vbnRoc1wiKSksIFwiTVwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIG5leHQgbW9udGgveWVhciBvbiBhbHQgK2xlZnQgb24gTWFjXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAzODogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAtNywgXCJEXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyAtMSB3ZWVrIG9uIGN0cmwgb3IgY29tbWFuZCArdXBcblx0XHRcdFx0Y2FzZSAzOTogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAoaXNSVEwgPyAtMSA6ICsxKSwgXCJEXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdC8vICsxIGRheSBvbiBjdHJsIG9yIGNvbW1hbmQgK3JpZ2h0XG5cdFx0XHRcdFx0XHRpZiAoZXZlbnQub3JpZ2luYWxFdmVudC5hbHRLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBCaWdNb250aHNcIikgOlxuXHRcdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBNb250aHNcIikpLCBcIk1cIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBuZXh0IG1vbnRoL3llYXIgb24gYWx0ICtyaWdodFxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNDA6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKzcsIFwiRFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gKzEgd2VlayBvbiBjdHJsIG9yIGNvbW1hbmQgK2Rvd25cblx0XHRcdFx0ZGVmYXVsdDogaGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMzYgJiYgZXZlbnQuY3RybEtleSkgeyAvLyBkaXNwbGF5IHRoZSBkYXRlIHBpY2tlciBvbiBjdHJsK2hvbWVcblx0XHRcdCQuZGF0ZXBpY2tlci5fc2hvd0RhdGVwaWNrZXIodGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhhbmRsZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoaGFuZGxlZCkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBGaWx0ZXIgZW50ZXJlZCBjaGFyYWN0ZXJzIC0gYmFzZWQgb24gZGF0ZSBmb3JtYXQuICovXG5cdF9kb0tleVByZXNzOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBjaGFycywgY2hyLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpO1xuXG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwiY29uc3RyYWluSW5wdXRcIikpIHtcblx0XHRcdGNoYXJzID0gJC5kYXRlcGlja2VyLl9wb3NzaWJsZUNoYXJzKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwiZGF0ZUZvcm1hdFwiKSk7XG5cdFx0XHRjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmNoYXJDb2RlID09IG51bGwgPyBldmVudC5rZXlDb2RlIDogZXZlbnQuY2hhckNvZGUpO1xuXHRcdFx0cmV0dXJuIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCAoY2hyIDwgXCIgXCIgfHwgIWNoYXJzIHx8IGNoYXJzLmluZGV4T2YoY2hyKSA+IC0xKTtcblx0XHR9XG5cdH0sXG5cblx0LyogU3luY2hyb25pc2UgbWFudWFsIGVudHJ5IGFuZCBmaWVsZC9hbHRlcm5hdGUgZmllbGQuICovXG5cdF9kb0tleVVwOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBkYXRlLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpO1xuXG5cdFx0aWYgKGluc3QuaW5wdXQudmFsKCkgIT09IGluc3QubGFzdFZhbCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0ZSA9ICQuZGF0ZXBpY2tlci5wYXJzZURhdGUoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJkYXRlRm9ybWF0XCIpLFxuXHRcdFx0XHRcdChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC52YWwoKSA6IG51bGwpLFxuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcblxuXHRcdFx0XHRpZiAoZGF0ZSkgeyAvLyBvbmx5IGlmIHZhbGlkXG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZXREYXRlRnJvbUZpZWxkKGluc3QpO1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKiBQb3AtdXAgdGhlIGRhdGUgcGlja2VyIGZvciBhIGdpdmVuIGlucHV0IGZpZWxkLlxuXHQgKiBJZiBmYWxzZSByZXR1cm5lZCBmcm9tIGJlZm9yZVNob3cgZXZlbnQgaGFuZGxlciBkbyBub3Qgc2hvdy5cblx0ICogQHBhcmFtICBpbnB1dCAgZWxlbWVudCAtIHRoZSBpbnB1dCBmaWVsZCBhdHRhY2hlZCB0byB0aGUgZGF0ZSBwaWNrZXIgb3Jcblx0ICpcdFx0XHRcdFx0ZXZlbnQgLSBpZiB0cmlnZ2VyZWQgYnkgZm9jdXNcblx0ICovXG5cdF9zaG93RGF0ZXBpY2tlcjogZnVuY3Rpb24oaW5wdXQpIHtcblx0XHRpbnB1dCA9IGlucHV0LnRhcmdldCB8fCBpbnB1dDtcblx0XHRpZiAoaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJpbnB1dFwiKSB7IC8vIGZpbmQgZnJvbSBidXR0b24vaW1hZ2UgdHJpZ2dlclxuXHRcdFx0aW5wdXQgPSAkKFwiaW5wdXRcIiwgaW5wdXQucGFyZW50Tm9kZSlbMF07XG5cdFx0fVxuXG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5faXNEaXNhYmxlZERhdGVwaWNrZXIoaW5wdXQpIHx8ICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID09PSBpbnB1dCkgeyAvLyBhbHJlYWR5IGhlcmVcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaW5zdCwgYmVmb3JlU2hvdywgYmVmb3JlU2hvd1NldHRpbmdzLCBpc0ZpeGVkLFxuXHRcdFx0b2Zmc2V0LCBzaG93QW5pbSwgZHVyYXRpb247XG5cblx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KGlucHV0KTtcblx0XHRpZiAoJC5kYXRlcGlja2VyLl9jdXJJbnN0ICYmICQuZGF0ZXBpY2tlci5fY3VySW5zdCAhPT0gaW5zdCkge1xuXHRcdFx0JC5kYXRlcGlja2VyLl9jdXJJbnN0LmRwRGl2LnN0b3AodHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRpZiAoIGluc3QgJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyApIHtcblx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlciggJC5kYXRlcGlja2VyLl9jdXJJbnN0LmlucHV0WzBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YmVmb3JlU2hvdyA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwiYmVmb3JlU2hvd1wiKTtcblx0XHRiZWZvcmVTaG93U2V0dGluZ3MgPSBiZWZvcmVTaG93ID8gYmVmb3JlU2hvdy5hcHBseShpbnB1dCwgW2lucHV0LCBpbnN0XSkgOiB7fTtcblx0XHRpZihiZWZvcmVTaG93U2V0dGluZ3MgPT09IGZhbHNlKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIGJlZm9yZVNob3dTZXR0aW5ncyk7XG5cblx0XHRpbnN0Lmxhc3RWYWwgPSBudWxsO1xuXHRcdCQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID0gaW5wdXQ7XG5cdFx0JC5kYXRlcGlja2VyLl9zZXREYXRlRnJvbUZpZWxkKGluc3QpO1xuXG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5faW5EaWFsb2cpIHsgLy8gaGlkZSBjdXJzb3Jcblx0XHRcdGlucHV0LnZhbHVlID0gXCJcIjtcblx0XHR9XG5cdFx0aWYgKCEkLmRhdGVwaWNrZXIuX3BvcykgeyAvLyBwb3NpdGlvbiBiZWxvdyBpbnB1dFxuXHRcdFx0JC5kYXRlcGlja2VyLl9wb3MgPSAkLmRhdGVwaWNrZXIuX2ZpbmRQb3MoaW5wdXQpO1xuXHRcdFx0JC5kYXRlcGlja2VyLl9wb3NbMV0gKz0gaW5wdXQub2Zmc2V0SGVpZ2h0OyAvLyBhZGQgdGhlIGhlaWdodFxuXHRcdH1cblxuXHRcdGlzRml4ZWQgPSBmYWxzZTtcblx0XHQkKGlucHV0KS5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlzRml4ZWQgfD0gJCh0aGlzKS5jc3MoXCJwb3NpdGlvblwiKSA9PT0gXCJmaXhlZFwiO1xuXHRcdFx0cmV0dXJuICFpc0ZpeGVkO1xuXHRcdH0pO1xuXG5cdFx0b2Zmc2V0ID0ge2xlZnQ6ICQuZGF0ZXBpY2tlci5fcG9zWzBdLCB0b3A6ICQuZGF0ZXBpY2tlci5fcG9zWzFdfTtcblx0XHQkLmRhdGVwaWNrZXIuX3BvcyA9IG51bGw7XG5cdFx0Ly90byBhdm9pZCBmbGFzaGVzIG9uIEZpcmVmb3hcblx0XHRpbnN0LmRwRGl2LmVtcHR5KCk7XG5cdFx0Ly8gZGV0ZXJtaW5lIHNpemluZyBvZmZzY3JlZW5cblx0XHRpbnN0LmRwRGl2LmNzcyh7cG9zaXRpb246IFwiYWJzb2x1dGVcIiwgZGlzcGxheTogXCJibG9ja1wiLCB0b3A6IFwiLTEwMDBweFwifSk7XG5cdFx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdC8vIGZpeCB3aWR0aCBmb3IgZHluYW1pYyBudW1iZXIgb2YgZGF0ZSBwaWNrZXJzXG5cdFx0Ly8gYW5kIGFkanVzdCBwb3NpdGlvbiBiZWZvcmUgc2hvd2luZ1xuXHRcdG9mZnNldCA9ICQuZGF0ZXBpY2tlci5fY2hlY2tPZmZzZXQoaW5zdCwgb2Zmc2V0LCBpc0ZpeGVkKTtcblx0XHRpbnN0LmRwRGl2LmNzcyh7cG9zaXRpb246ICgkLmRhdGVwaWNrZXIuX2luRGlhbG9nICYmICQuYmxvY2tVSSA/XG5cdFx0XHRcInN0YXRpY1wiIDogKGlzRml4ZWQgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCIpKSwgZGlzcGxheTogXCJub25lXCIsXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCArIFwicHhcIiwgdG9wOiBvZmZzZXQudG9wICsgXCJweFwifSk7XG5cblx0XHRpZiAoIWluc3QuaW5saW5lKSB7XG5cdFx0XHRzaG93QW5pbSA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic2hvd0FuaW1cIik7XG5cdFx0XHRkdXJhdGlvbiA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwiZHVyYXRpb25cIik7XG5cdFx0XHRpbnN0LmRwRGl2LnpJbmRleCgkKGlucHV0KS56SW5kZXgoKSsxKTtcblx0XHRcdCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgPSB0cnVlO1xuXG5cdFx0XHRpZiAoICQuZWZmZWN0cyAmJiAkLmVmZmVjdHMuZWZmZWN0WyBzaG93QW5pbSBdICkge1xuXHRcdFx0XHRpbnN0LmRwRGl2LnNob3coc2hvd0FuaW0sICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic2hvd09wdGlvbnNcIiksIGR1cmF0aW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluc3QuZHBEaXZbc2hvd0FuaW0gfHwgXCJzaG93XCJdKHNob3dBbmltID8gZHVyYXRpb24gOiBudWxsKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAkLmRhdGVwaWNrZXIuX3Nob3VsZEZvY3VzSW5wdXQoIGluc3QgKSApIHtcblx0XHRcdFx0aW5zdC5pbnB1dC5mb2N1cygpO1xuXHRcdFx0fVxuXG5cdFx0XHQkLmRhdGVwaWNrZXIuX2N1ckluc3QgPSBpbnN0O1xuXHRcdH1cblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgZGF0ZSBwaWNrZXIgY29udGVudC4gKi9cblx0X3VwZGF0ZURhdGVwaWNrZXI6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR0aGlzLm1heFJvd3MgPSA0OyAvL1Jlc2V0IHRoZSBtYXggbnVtYmVyIG9mIHJvd3MgYmVpbmcgZGlzcGxheWVkIChzZWUgIzcwNDMpXG5cdFx0aW5zdEFjdGl2ZSA9IGluc3Q7IC8vIGZvciBkZWxlZ2F0ZSBob3ZlciBldmVudHNcblx0XHRpbnN0LmRwRGl2LmVtcHR5KCkuYXBwZW5kKHRoaXMuX2dlbmVyYXRlSFRNTChpbnN0KSk7XG5cdFx0dGhpcy5fYXR0YWNoSGFuZGxlcnMoaW5zdCk7XG5cdFx0aW5zdC5kcERpdi5maW5kKFwiLlwiICsgdGhpcy5fZGF5T3ZlckNsYXNzICsgXCIgYVwiKS5tb3VzZW92ZXIoKTtcblxuXHRcdHZhciBvcmlneWVhcnNodG1sLFxuXHRcdFx0bnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoaW5zdCksXG5cdFx0XHRjb2xzID0gbnVtTW9udGhzWzFdLFxuXHRcdFx0d2lkdGggPSAxNztcblxuXHRcdGluc3QuZHBEaXYucmVtb3ZlQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLW11bHRpLTIgdWktZGF0ZXBpY2tlci1tdWx0aS0zIHVpLWRhdGVwaWNrZXItbXVsdGktNFwiKS53aWR0aChcIlwiKTtcblx0XHRpZiAoY29scyA+IDEpIHtcblx0XHRcdGluc3QuZHBEaXYuYWRkQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLW11bHRpLVwiICsgY29scykuY3NzKFwid2lkdGhcIiwgKHdpZHRoICogY29scykgKyBcImVtXCIpO1xuXHRcdH1cblx0XHRpbnN0LmRwRGl2WyhudW1Nb250aHNbMF0gIT09IDEgfHwgbnVtTW9udGhzWzFdICE9PSAxID8gXCJhZGRcIiA6IFwicmVtb3ZlXCIpICtcblx0XHRcdFwiQ2xhc3NcIl0oXCJ1aS1kYXRlcGlja2VyLW11bHRpXCIpO1xuXHRcdGluc3QuZHBEaXZbKHRoaXMuX2dldChpbnN0LCBcImlzUlRMXCIpID8gXCJhZGRcIiA6IFwicmVtb3ZlXCIpICtcblx0XHRcdFwiQ2xhc3NcIl0oXCJ1aS1kYXRlcGlja2VyLXJ0bFwiKTtcblxuXHRcdGlmIChpbnN0ID09PSAkLmRhdGVwaWNrZXIuX2N1ckluc3QgJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX3Nob3VsZEZvY3VzSW5wdXQoIGluc3QgKSApIHtcblx0XHRcdGluc3QuaW5wdXQuZm9jdXMoKTtcblx0XHR9XG5cblx0XHQvLyBkZWZmZXJlZCByZW5kZXIgb2YgdGhlIHllYXJzIHNlbGVjdCAodG8gYXZvaWQgZmxhc2hlcyBvbiBGaXJlZm94KVxuXHRcdGlmKCBpbnN0LnllYXJzaHRtbCApe1xuXHRcdFx0b3JpZ3llYXJzaHRtbCA9IGluc3QueWVhcnNodG1sO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHQvL2Fzc3VyZSB0aGF0IGluc3QueWVhcnNodG1sIGRpZG4ndCBjaGFuZ2UuXG5cdFx0XHRcdGlmKCBvcmlneWVhcnNodG1sID09PSBpbnN0LnllYXJzaHRtbCAmJiBpbnN0LnllYXJzaHRtbCApe1xuXHRcdFx0XHRcdGluc3QuZHBEaXYuZmluZChcInNlbGVjdC51aS1kYXRlcGlja2VyLXllYXI6Zmlyc3RcIikucmVwbGFjZVdpdGgoaW5zdC55ZWFyc2h0bWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9yaWd5ZWFyc2h0bWwgPSBpbnN0LnllYXJzaHRtbCA9IG51bGw7XG5cdFx0XHR9LCAwKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gIzY2OTQgLSBkb24ndCBmb2N1cyB0aGUgaW5wdXQgaWYgaXQncyBhbHJlYWR5IGZvY3VzZWRcblx0Ly8gdGhpcyBicmVha3MgdGhlIGNoYW5nZSBldmVudCBpbiBJRVxuXHQvLyBTdXBwb3J0OiBJRSBhbmQgalF1ZXJ5IDwxLjlcblx0X3Nob3VsZEZvY3VzSW5wdXQ6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHJldHVybiBpbnN0LmlucHV0ICYmIGluc3QuaW5wdXQuaXMoIFwiOnZpc2libGVcIiApICYmICFpbnN0LmlucHV0LmlzKCBcIjpkaXNhYmxlZFwiICkgJiYgIWluc3QuaW5wdXQuaXMoIFwiOmZvY3VzXCIgKTtcblx0fSxcblxuXHQvKiBDaGVjayBwb3NpdGlvbmluZyB0byByZW1haW4gb24gc2NyZWVuLiAqL1xuXHRfY2hlY2tPZmZzZXQ6IGZ1bmN0aW9uKGluc3QsIG9mZnNldCwgaXNGaXhlZCkge1xuXHRcdHZhciBkcFdpZHRoID0gaW5zdC5kcERpdi5vdXRlcldpZHRoKCksXG5cdFx0XHRkcEhlaWdodCA9IGluc3QuZHBEaXYub3V0ZXJIZWlnaHQoKSxcblx0XHRcdGlucHV0V2lkdGggPSBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC5vdXRlcldpZHRoKCkgOiAwLFxuXHRcdFx0aW5wdXRIZWlnaHQgPSBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC5vdXRlckhlaWdodCgpIDogMCxcblx0XHRcdHZpZXdXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCArIChpc0ZpeGVkID8gMCA6ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSksXG5cdFx0XHR2aWV3SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCArIChpc0ZpeGVkID8gMCA6ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpKTtcblxuXHRcdG9mZnNldC5sZWZ0IC09ICh0aGlzLl9nZXQoaW5zdCwgXCJpc1JUTFwiKSA/IChkcFdpZHRoIC0gaW5wdXRXaWR0aCkgOiAwKTtcblx0XHRvZmZzZXQubGVmdCAtPSAoaXNGaXhlZCAmJiBvZmZzZXQubGVmdCA9PT0gaW5zdC5pbnB1dC5vZmZzZXQoKS5sZWZ0KSA/ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSA6IDA7XG5cdFx0b2Zmc2V0LnRvcCAtPSAoaXNGaXhlZCAmJiBvZmZzZXQudG9wID09PSAoaW5zdC5pbnB1dC5vZmZzZXQoKS50b3AgKyBpbnB1dEhlaWdodCkpID8gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgOiAwO1xuXG5cdFx0Ly8gbm93IGNoZWNrIGlmIGRhdGVwaWNrZXIgaXMgc2hvd2luZyBvdXRzaWRlIHdpbmRvdyB2aWV3cG9ydCAtIG1vdmUgdG8gYSBiZXR0ZXIgcGxhY2UgaWYgc28uXG5cdFx0b2Zmc2V0LmxlZnQgLT0gTWF0aC5taW4ob2Zmc2V0LmxlZnQsIChvZmZzZXQubGVmdCArIGRwV2lkdGggPiB2aWV3V2lkdGggJiYgdmlld1dpZHRoID4gZHBXaWR0aCkgP1xuXHRcdFx0TWF0aC5hYnMob2Zmc2V0LmxlZnQgKyBkcFdpZHRoIC0gdmlld1dpZHRoKSA6IDApO1xuXHRcdG9mZnNldC50b3AgLT0gTWF0aC5taW4ob2Zmc2V0LnRvcCwgKG9mZnNldC50b3AgKyBkcEhlaWdodCA+IHZpZXdIZWlnaHQgJiYgdmlld0hlaWdodCA+IGRwSGVpZ2h0KSA/XG5cdFx0XHRNYXRoLmFicyhkcEhlaWdodCArIGlucHV0SGVpZ2h0KSA6IDApO1xuXG5cdFx0cmV0dXJuIG9mZnNldDtcblx0fSxcblxuXHQvKiBGaW5kIGFuIG9iamVjdCdzIHBvc2l0aW9uIG9uIHRoZSBzY3JlZW4uICovXG5cdF9maW5kUG9zOiBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIgcG9zaXRpb24sXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdChvYmopLFxuXHRcdFx0aXNSVEwgPSB0aGlzLl9nZXQoaW5zdCwgXCJpc1JUTFwiKTtcblxuXHRcdHdoaWxlIChvYmogJiYgKG9iai50eXBlID09PSBcImhpZGRlblwiIHx8IG9iai5ub2RlVHlwZSAhPT0gMSB8fCAkLmV4cHIuZmlsdGVycy5oaWRkZW4ob2JqKSkpIHtcblx0XHRcdG9iaiA9IG9ialtpc1JUTCA/IFwicHJldmlvdXNTaWJsaW5nXCIgOiBcIm5leHRTaWJsaW5nXCJdO1xuXHRcdH1cblxuXHRcdHBvc2l0aW9uID0gJChvYmopLm9mZnNldCgpO1xuXHRcdHJldHVybiBbcG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wXTtcblx0fSxcblxuXHQvKiBIaWRlIHRoZSBkYXRlIHBpY2tlciBmcm9tIHZpZXcuXG5cdCAqIEBwYXJhbSAgaW5wdXQgIGVsZW1lbnQgLSB0aGUgaW5wdXQgZmllbGQgYXR0YWNoZWQgdG8gdGhlIGRhdGUgcGlja2VyXG5cdCAqL1xuXHRfaGlkZURhdGVwaWNrZXI6IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0dmFyIHNob3dBbmltLCBkdXJhdGlvbiwgcG9zdFByb2Nlc3MsIG9uQ2xvc2UsXG5cdFx0XHRpbnN0ID0gdGhpcy5fY3VySW5zdDtcblxuXHRcdGlmICghaW5zdCB8fCAoaW5wdXQgJiYgaW5zdCAhPT0gJC5kYXRhKGlucHV0LCBQUk9QX05BTUUpKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9kYXRlcGlja2VyU2hvd2luZykge1xuXHRcdFx0c2hvd0FuaW0gPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG93QW5pbVwiKTtcblx0XHRcdGR1cmF0aW9uID0gdGhpcy5fZ2V0KGluc3QsIFwiZHVyYXRpb25cIik7XG5cdFx0XHRwb3N0UHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkLmRhdGVwaWNrZXIuX3RpZHlEaWFsb2coaW5zdCk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBERVBSRUNBVEVEOiBhZnRlciBCQyBmb3IgMS44LnggJC5lZmZlY3RzWyBzaG93QW5pbSBdIGlzIG5vdCBuZWVkZWRcblx0XHRcdGlmICggJC5lZmZlY3RzICYmICggJC5lZmZlY3RzLmVmZmVjdFsgc2hvd0FuaW0gXSB8fCAkLmVmZmVjdHNbIHNob3dBbmltIF0gKSApIHtcblx0XHRcdFx0aW5zdC5kcERpdi5oaWRlKHNob3dBbmltLCAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInNob3dPcHRpb25zXCIpLCBkdXJhdGlvbiwgcG9zdFByb2Nlc3MpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5zdC5kcERpdlsoc2hvd0FuaW0gPT09IFwic2xpZGVEb3duXCIgPyBcInNsaWRlVXBcIiA6XG5cdFx0XHRcdFx0KHNob3dBbmltID09PSBcImZhZGVJblwiID8gXCJmYWRlT3V0XCIgOiBcImhpZGVcIikpXSgoc2hvd0FuaW0gPyBkdXJhdGlvbiA6IG51bGwpLCBwb3N0UHJvY2Vzcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghc2hvd0FuaW0pIHtcblx0XHRcdFx0cG9zdFByb2Nlc3MoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RhdGVwaWNrZXJTaG93aW5nID0gZmFsc2U7XG5cblx0XHRcdG9uQ2xvc2UgPSB0aGlzLl9nZXQoaW5zdCwgXCJvbkNsb3NlXCIpO1xuXHRcdFx0aWYgKG9uQ2xvc2UpIHtcblx0XHRcdFx0b25DbG9zZS5hcHBseSgoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsKSwgWyhpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC52YWwoKSA6IFwiXCIpLCBpbnN0XSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xhc3RJbnB1dCA9IG51bGw7XG5cdFx0XHRpZiAodGhpcy5faW5EaWFsb2cpIHtcblx0XHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQuY3NzKHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgbGVmdDogXCIwXCIsIHRvcDogXCItMTAwcHhcIiB9KTtcblx0XHRcdFx0aWYgKCQuYmxvY2tVSSkge1xuXHRcdFx0XHRcdCQudW5ibG9ja1VJKCk7XG5cdFx0XHRcdFx0JChcImJvZHlcIikuYXBwZW5kKHRoaXMuZHBEaXYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9pbkRpYWxvZyA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHQvKiBUaWR5IHVwIGFmdGVyIGEgZGlhbG9nIGRpc3BsYXkuICovXG5cdF90aWR5RGlhbG9nOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0aW5zdC5kcERpdi5yZW1vdmVDbGFzcyh0aGlzLl9kaWFsb2dDbGFzcykudW5iaW5kKFwiLnVpLWRhdGVwaWNrZXItY2FsZW5kYXJcIik7XG5cdH0sXG5cblx0LyogQ2xvc2UgZGF0ZSBwaWNrZXIgaWYgY2xpY2tlZCBlbHNld2hlcmUuICovXG5cdF9jaGVja0V4dGVybmFsQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKCEkLmRhdGVwaWNrZXIuX2N1ckluc3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgJHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KSxcblx0XHRcdGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoJHRhcmdldFswXSk7XG5cblx0XHRpZiAoICggKCAkdGFyZ2V0WzBdLmlkICE9PSAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCAmJlxuXHRcdFx0XHQkdGFyZ2V0LnBhcmVudHMoXCIjXCIgKyAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCkubGVuZ3RoID09PSAwICYmXG5cdFx0XHRcdCEkdGFyZ2V0Lmhhc0NsYXNzKCQuZGF0ZXBpY2tlci5tYXJrZXJDbGFzc05hbWUpICYmXG5cdFx0XHRcdCEkdGFyZ2V0LmNsb3Nlc3QoXCIuXCIgKyAkLmRhdGVwaWNrZXIuX3RyaWdnZXJDbGFzcykubGVuZ3RoICYmXG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgISgkLmRhdGVwaWNrZXIuX2luRGlhbG9nICYmICQuYmxvY2tVSSkgKSApIHx8XG5cdFx0XHQoICR0YXJnZXQuaGFzQ2xhc3MoJC5kYXRlcGlja2VyLm1hcmtlckNsYXNzTmFtZSkgJiYgJC5kYXRlcGlja2VyLl9jdXJJbnN0ICE9PSBpbnN0ICkgKSB7XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHR9XG5cdH0sXG5cblx0LyogQWRqdXN0IG9uZSBvZiB0aGUgZGF0ZSBzdWItZmllbGRzLiAqL1xuXHRfYWRqdXN0RGF0ZTogZnVuY3Rpb24oaWQsIG9mZnNldCwgcGVyaW9kKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQoaWQpLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblxuXHRcdGlmICh0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlcih0YXJnZXRbMF0pKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX2FkanVzdEluc3REYXRlKGluc3QsIG9mZnNldCArXG5cdFx0XHQocGVyaW9kID09PSBcIk1cIiA/IHRoaXMuX2dldChpbnN0LCBcInNob3dDdXJyZW50QXRQb3NcIikgOiAwKSwgLy8gdW5kbyBwb3NpdGlvbmluZ1xuXHRcdFx0cGVyaW9kKTtcblx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHR9LFxuXG5cdC8qIEFjdGlvbiBmb3IgY3VycmVudCBsaW5rLiAqL1xuXHRfZ290b1RvZGF5OiBmdW5jdGlvbihpZCkge1xuXHRcdHZhciBkYXRlLFxuXHRcdFx0dGFyZ2V0ID0gJChpZCksXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXG5cdFx0aWYgKHRoaXMuX2dldChpbnN0LCBcImdvdG9DdXJyZW50XCIpICYmIGluc3QuY3VycmVudERheSkge1xuXHRcdFx0aW5zdC5zZWxlY3RlZERheSA9IGluc3QuY3VycmVudERheTtcblx0XHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gaW5zdC5jdXJyZW50TW9udGg7XG5cdFx0XHRpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBpbnN0LmN1cnJlbnRZZWFyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBkYXRlLmdldERhdGUoKTtcblx0XHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXHRcdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdH1cblx0XHR0aGlzLl9ub3RpZnlDaGFuZ2UoaW5zdCk7XG5cdFx0dGhpcy5fYWRqdXN0RGF0ZSh0YXJnZXQpO1xuXHR9LFxuXG5cdC8qIEFjdGlvbiBmb3Igc2VsZWN0aW5nIGEgbmV3IG1vbnRoL3llYXIuICovXG5cdF9zZWxlY3RNb250aFllYXI6IGZ1bmN0aW9uKGlkLCBzZWxlY3QsIHBlcmlvZCkge1xuXHRcdHZhciB0YXJnZXQgPSAkKGlkKSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldFswXSk7XG5cblx0XHRpbnN0W1wic2VsZWN0ZWRcIiArIChwZXJpb2QgPT09IFwiTVwiID8gXCJNb250aFwiIDogXCJZZWFyXCIpXSA9XG5cdFx0aW5zdFtcImRyYXdcIiArIChwZXJpb2QgPT09IFwiTVwiID8gXCJNb250aFwiIDogXCJZZWFyXCIpXSA9XG5cdFx0XHRwYXJzZUludChzZWxlY3Qub3B0aW9uc1tzZWxlY3Quc2VsZWN0ZWRJbmRleF0udmFsdWUsMTApO1xuXG5cdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHRcdHRoaXMuX2FkanVzdERhdGUodGFyZ2V0KTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIHNlbGVjdGluZyBhIGRheS4gKi9cblx0X3NlbGVjdERheTogZnVuY3Rpb24oaWQsIG1vbnRoLCB5ZWFyLCB0ZCkge1xuXHRcdHZhciBpbnN0LFxuXHRcdFx0dGFyZ2V0ID0gJChpZCk7XG5cblx0XHRpZiAoJCh0ZCkuaGFzQ2xhc3ModGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MpIHx8IHRoaXMuX2lzRGlzYWJsZWREYXRlcGlja2VyKHRhcmdldFswXSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXkgPSAkKFwiYVwiLCB0ZCkuaHRtbCgpO1xuXHRcdGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoID0gbW9udGg7XG5cdFx0aW5zdC5zZWxlY3RlZFllYXIgPSBpbnN0LmN1cnJlbnRZZWFyID0geWVhcjtcblx0XHR0aGlzLl9zZWxlY3REYXRlKGlkLCB0aGlzLl9mb3JtYXREYXRlKGluc3QsXG5cdFx0XHRpbnN0LmN1cnJlbnREYXksIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnRZZWFyKSk7XG5cdH0sXG5cblx0LyogRXJhc2UgdGhlIGlucHV0IGZpZWxkIGFuZCBoaWRlIHRoZSBkYXRlIHBpY2tlci4gKi9cblx0X2NsZWFyRGF0ZTogZnVuY3Rpb24oaWQpIHtcblx0XHR2YXIgdGFyZ2V0ID0gJChpZCk7XG5cdFx0dGhpcy5fc2VsZWN0RGF0ZSh0YXJnZXQsIFwiXCIpO1xuXHR9LFxuXG5cdC8qIFVwZGF0ZSB0aGUgaW5wdXQgZmllbGQgd2l0aCB0aGUgc2VsZWN0ZWQgZGF0ZS4gKi9cblx0X3NlbGVjdERhdGU6IGZ1bmN0aW9uKGlkLCBkYXRlU3RyKSB7XG5cdFx0dmFyIG9uU2VsZWN0LFxuXHRcdFx0dGFyZ2V0ID0gJChpZCksXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXG5cdFx0ZGF0ZVN0ciA9IChkYXRlU3RyICE9IG51bGwgPyBkYXRlU3RyIDogdGhpcy5fZm9ybWF0RGF0ZShpbnN0KSk7XG5cdFx0aWYgKGluc3QuaW5wdXQpIHtcblx0XHRcdGluc3QuaW5wdXQudmFsKGRhdGVTdHIpO1xuXHRcdH1cblx0XHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XG5cblx0XHRvblNlbGVjdCA9IHRoaXMuX2dldChpbnN0LCBcIm9uU2VsZWN0XCIpO1xuXHRcdGlmIChvblNlbGVjdCkge1xuXHRcdFx0b25TZWxlY3QuYXBwbHkoKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCksIFtkYXRlU3RyLCBpbnN0XSk7ICAvLyB0cmlnZ2VyIGN1c3RvbSBjYWxsYmFja1xuXHRcdH0gZWxzZSBpZiAoaW5zdC5pbnB1dCkge1xuXHRcdFx0aW5zdC5pbnB1dC50cmlnZ2VyKFwiY2hhbmdlXCIpOyAvLyBmaXJlIHRoZSBjaGFuZ2UgZXZlbnRcblx0XHR9XG5cblx0XHRpZiAoaW5zdC5pbmxpbmUpe1xuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdHRoaXMuX2xhc3RJbnB1dCA9IGluc3QuaW5wdXRbMF07XG5cdFx0XHRpZiAodHlwZW9mKGluc3QuaW5wdXRbMF0pICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdGluc3QuaW5wdXQuZm9jdXMoKTsgLy8gcmVzdG9yZSBmb2N1c1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fbGFzdElucHV0ID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyogVXBkYXRlIGFueSBhbHRlcm5hdGUgZmllbGQgdG8gc3luY2hyb25pc2Ugd2l0aCB0aGUgbWFpbiBmaWVsZC4gKi9cblx0X3VwZGF0ZUFsdGVybmF0ZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBhbHRGb3JtYXQsIGRhdGUsIGRhdGVTdHIsXG5cdFx0XHRhbHRGaWVsZCA9IHRoaXMuX2dldChpbnN0LCBcImFsdEZpZWxkXCIpO1xuXG5cdFx0aWYgKGFsdEZpZWxkKSB7IC8vIHVwZGF0ZSBhbHRlcm5hdGUgZmllbGQgdG9vXG5cdFx0XHRhbHRGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgXCJhbHRGb3JtYXRcIikgfHwgdGhpcy5fZ2V0KGluc3QsIFwiZGF0ZUZvcm1hdFwiKTtcblx0XHRcdGRhdGUgPSB0aGlzLl9nZXREYXRlKGluc3QpO1xuXHRcdFx0ZGF0ZVN0ciA9IHRoaXMuZm9ybWF0RGF0ZShhbHRGb3JtYXQsIGRhdGUsIHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XG5cdFx0XHQkKGFsdEZpZWxkKS5lYWNoKGZ1bmN0aW9uKCkgeyAkKHRoaXMpLnZhbChkYXRlU3RyKTsgfSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFNldCBhcyBiZWZvcmVTaG93RGF5IGZ1bmN0aW9uIHRvIHByZXZlbnQgc2VsZWN0aW9uIG9mIHdlZWtlbmRzLlxuXHQgKiBAcGFyYW0gIGRhdGUgIERhdGUgLSB0aGUgZGF0ZSB0byBjdXN0b21pc2Vcblx0ICogQHJldHVybiBbYm9vbGVhbiwgc3RyaW5nXSAtIGlzIHRoaXMgZGF0ZSBzZWxlY3RhYmxlPywgd2hhdCBpcyBpdHMgQ1NTIGNsYXNzP1xuXHQgKi9cblx0bm9XZWVrZW5kczogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuXHRcdHJldHVybiBbKGRheSA+IDAgJiYgZGF5IDwgNiksIFwiXCJdO1xuXHR9LFxuXG5cdC8qIFNldCBhcyBjYWxjdWxhdGVXZWVrIHRvIGRldGVybWluZSB0aGUgd2VlayBvZiB0aGUgeWVhciBiYXNlZCBvbiB0aGUgSVNPIDg2MDEgZGVmaW5pdGlvbi5cblx0ICogQHBhcmFtICBkYXRlICBEYXRlIC0gdGhlIGRhdGUgdG8gZ2V0IHRoZSB3ZWVrIGZvclxuXHQgKiBAcmV0dXJuICBudW1iZXIgLSB0aGUgbnVtYmVyIG9mIHRoZSB3ZWVrIHdpdGhpbiB0aGUgeWVhciB0aGF0IGNvbnRhaW5zIHRoaXMgZGF0ZVxuXHQgKi9cblx0aXNvODYwMVdlZWs6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgdGltZSxcblx0XHRcdGNoZWNrRGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcblxuXHRcdC8vIEZpbmQgVGh1cnNkYXkgb2YgdGhpcyB3ZWVrIHN0YXJ0aW5nIG9uIE1vbmRheVxuXHRcdGNoZWNrRGF0ZS5zZXREYXRlKGNoZWNrRGF0ZS5nZXREYXRlKCkgKyA0IC0gKGNoZWNrRGF0ZS5nZXREYXkoKSB8fCA3KSk7XG5cblx0XHR0aW1lID0gY2hlY2tEYXRlLmdldFRpbWUoKTtcblx0XHRjaGVja0RhdGUuc2V0TW9udGgoMCk7IC8vIENvbXBhcmUgd2l0aCBKYW4gMVxuXHRcdGNoZWNrRGF0ZS5zZXREYXRlKDEpO1xuXHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucm91bmQoKHRpbWUgLSBjaGVja0RhdGUpIC8gODY0MDAwMDApIC8gNykgKyAxO1xuXHR9LFxuXG5cdC8qIFBhcnNlIGEgc3RyaW5nIHZhbHVlIGludG8gYSBkYXRlIG9iamVjdC5cblx0ICogU2VlIGZvcm1hdERhdGUgYmVsb3cgZm9yIHRoZSBwb3NzaWJsZSBmb3JtYXRzLlxuXHQgKlxuXHQgKiBAcGFyYW0gIGZvcm1hdCBzdHJpbmcgLSB0aGUgZXhwZWN0ZWQgZm9ybWF0IG9mIHRoZSBkYXRlXG5cdCAqIEBwYXJhbSAgdmFsdWUgc3RyaW5nIC0gdGhlIGRhdGUgaW4gdGhlIGFib3ZlIGZvcm1hdFxuXHQgKiBAcGFyYW0gIHNldHRpbmdzIE9iamVjdCAtIGF0dHJpYnV0ZXMgaW5jbHVkZTpcblx0ICpcdFx0XHRcdFx0c2hvcnRZZWFyQ3V0b2ZmICBudW1iZXIgLSB0aGUgY3V0b2ZmIHllYXIgZm9yIGRldGVybWluaW5nIHRoZSBjZW50dXJ5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNTaG9ydFx0c3RyaW5nWzddIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRkYXlOYW1lc1x0XHRzdHJpbmdbN10gLSBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdG1vbnRoTmFtZXNTaG9ydCBzdHJpbmdbMTJdIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdG1vbnRoTmFtZXNcdFx0c3RyaW5nWzEyXSAtIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKiBAcmV0dXJuICBEYXRlIC0gdGhlIGV4dHJhY3RlZCBkYXRlIHZhbHVlIG9yIG51bGwgaWYgdmFsdWUgaXMgYmxhbmtcblx0ICovXG5cdHBhcnNlRGF0ZTogZnVuY3Rpb24gKGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzKSB7XG5cdFx0aWYgKGZvcm1hdCA9PSBudWxsIHx8IHZhbHVlID09IG51bGwpIHtcblx0XHRcdHRocm93IFwiSW52YWxpZCBhcmd1bWVudHNcIjtcblx0XHR9XG5cblx0XHR2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWUgKyBcIlwiKTtcblx0XHRpZiAodmFsdWUgPT09IFwiXCIpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBpRm9ybWF0LCBkaW0sIGV4dHJhLFxuXHRcdFx0aVZhbHVlID0gMCxcblx0XHRcdHNob3J0WWVhckN1dG9mZlRlbXAgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5zaG9ydFllYXJDdXRvZmYgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5zaG9ydFllYXJDdXRvZmYsXG5cdFx0XHRzaG9ydFllYXJDdXRvZmYgPSAodHlwZW9mIHNob3J0WWVhckN1dG9mZlRlbXAgIT09IFwic3RyaW5nXCIgPyBzaG9ydFllYXJDdXRvZmZUZW1wIDpcblx0XHRcdFx0bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgcGFyc2VJbnQoc2hvcnRZZWFyQ3V0b2ZmVGVtcCwgMTApKSxcblx0XHRcdGRheU5hbWVzU2hvcnQgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lc1Nob3J0IDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXNTaG9ydCxcblx0XHRcdGRheU5hbWVzID0gKHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXMgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lcyxcblx0XHRcdG1vbnRoTmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXNTaG9ydCxcblx0XHRcdG1vbnRoTmFtZXMgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMubW9udGhOYW1lcyxcblx0XHRcdHllYXIgPSAtMSxcblx0XHRcdG1vbnRoID0gLTEsXG5cdFx0XHRkYXkgPSAtMSxcblx0XHRcdGRveSA9IC0xLFxuXHRcdFx0bGl0ZXJhbCA9IGZhbHNlLFxuXHRcdFx0ZGF0ZSxcblx0XHRcdC8vIENoZWNrIHdoZXRoZXIgYSBmb3JtYXQgY2hhcmFjdGVyIGlzIGRvdWJsZWRcblx0XHRcdGxvb2tBaGVhZCA9IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVzID0gKGlGb3JtYXQgKyAxIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyAxKSA9PT0gbWF0Y2gpO1xuXHRcdFx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0XHRcdGlGb3JtYXQrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hlcztcblx0XHRcdH0sXG5cdFx0XHQvLyBFeHRyYWN0IGEgbnVtYmVyIGZyb20gdGhlIHN0cmluZyB2YWx1ZVxuXHRcdFx0Z2V0TnVtYmVyID0gZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0dmFyIGlzRG91YmxlZCA9IGxvb2tBaGVhZChtYXRjaCksXG5cdFx0XHRcdFx0c2l6ZSA9IChtYXRjaCA9PT0gXCJAXCIgPyAxNCA6IChtYXRjaCA9PT0gXCIhXCIgPyAyMCA6XG5cdFx0XHRcdFx0KG1hdGNoID09PSBcInlcIiAmJiBpc0RvdWJsZWQgPyA0IDogKG1hdGNoID09PSBcIm9cIiA/IDMgOiAyKSkpKSxcblx0XHRcdFx0XHRkaWdpdHMgPSBuZXcgUmVnRXhwKFwiXlxcXFxkezEsXCIgKyBzaXplICsgXCJ9XCIpLFxuXHRcdFx0XHRcdG51bSA9IHZhbHVlLnN1YnN0cmluZyhpVmFsdWUpLm1hdGNoKGRpZ2l0cyk7XG5cdFx0XHRcdGlmICghbnVtKSB7XG5cdFx0XHRcdFx0dGhyb3cgXCJNaXNzaW5nIG51bWJlciBhdCBwb3NpdGlvbiBcIiArIGlWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpVmFsdWUgKz0gbnVtWzBdLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KG51bVswXSwgMTApO1xuXHRcdFx0fSxcblx0XHRcdC8vIEV4dHJhY3QgYSBuYW1lIGZyb20gdGhlIHN0cmluZyB2YWx1ZSBhbmQgY29udmVydCB0byBhbiBpbmRleFxuXHRcdFx0Z2V0TmFtZSA9IGZ1bmN0aW9uKG1hdGNoLCBzaG9ydE5hbWVzLCBsb25nTmFtZXMpIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gLTEsXG5cdFx0XHRcdFx0bmFtZXMgPSAkLm1hcChsb29rQWhlYWQobWF0Y2gpID8gbG9uZ05hbWVzIDogc2hvcnROYW1lcywgZnVuY3Rpb24gKHYsIGspIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIFtrLCB2XSBdO1xuXHRcdFx0XHRcdH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0XHRcdHJldHVybiAtKGFbMV0ubGVuZ3RoIC0gYlsxXS5sZW5ndGgpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdCQuZWFjaChuYW1lcywgZnVuY3Rpb24gKGksIHBhaXIpIHtcblx0XHRcdFx0XHR2YXIgbmFtZSA9IHBhaXJbMV07XG5cdFx0XHRcdFx0aWYgKHZhbHVlLnN1YnN0cihpVmFsdWUsIG5hbWUubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gcGFpclswXTtcblx0XHRcdFx0XHRcdGlWYWx1ZSArPSBuYW1lLmxlbmd0aDtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGluZGV4ICsgMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBcIlVua25vd24gbmFtZSBhdCBwb3NpdGlvbiBcIiArIGlWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8vIENvbmZpcm0gdGhhdCBhIGxpdGVyYWwgY2hhcmFjdGVyIG1hdGNoZXMgdGhlIHN0cmluZyB2YWx1ZVxuXHRcdFx0Y2hlY2tMaXRlcmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICh2YWx1ZS5jaGFyQXQoaVZhbHVlKSAhPT0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdHRocm93IFwiVW5leHBlY3RlZCBsaXRlcmFsIGF0IHBvc2l0aW9uIFwiICsgaVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlWYWx1ZSsrO1xuXHRcdFx0fTtcblxuXHRcdGZvciAoaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcblx0XHRcdGlmIChsaXRlcmFsKSB7XG5cdFx0XHRcdGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09PSBcIidcIiAmJiAhbG9va0FoZWFkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3dpdGNoIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpKSB7XG5cdFx0XHRcdFx0Y2FzZSBcImRcIjpcblx0XHRcdFx0XHRcdGRheSA9IGdldE51bWJlcihcImRcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiRFwiOlxuXHRcdFx0XHRcdFx0Z2V0TmFtZShcIkRcIiwgZGF5TmFtZXNTaG9ydCwgZGF5TmFtZXMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIm9cIjpcblx0XHRcdFx0XHRcdGRveSA9IGdldE51bWJlcihcIm9cIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwibVwiOlxuXHRcdFx0XHRcdFx0bW9udGggPSBnZXROdW1iZXIoXCJtXCIpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIk1cIjpcblx0XHRcdFx0XHRcdG1vbnRoID0gZ2V0TmFtZShcIk1cIiwgbW9udGhOYW1lc1Nob3J0LCBtb250aE5hbWVzKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJ5XCI6XG5cdFx0XHRcdFx0XHR5ZWFyID0gZ2V0TnVtYmVyKFwieVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJAXCI6XG5cdFx0XHRcdFx0XHRkYXRlID0gbmV3IERhdGUoZ2V0TnVtYmVyKFwiQFwiKSk7XG5cdFx0XHRcdFx0XHR5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRcdFx0bW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuXHRcdFx0XHRcdFx0ZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiIVwiOlxuXHRcdFx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKChnZXROdW1iZXIoXCIhXCIpIC0gdGhpcy5fdGlja3NUbzE5NzApIC8gMTAwMDApO1xuXHRcdFx0XHRcdFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcblx0XHRcdFx0XHRcdGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdGlmIChsb29rQWhlYWQoXCInXCIpKXtcblx0XHRcdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpVmFsdWUgPCB2YWx1ZS5sZW5ndGgpe1xuXHRcdFx0ZXh0cmEgPSB2YWx1ZS5zdWJzdHIoaVZhbHVlKTtcblx0XHRcdGlmICghL15cXHMrLy50ZXN0KGV4dHJhKSkge1xuXHRcdFx0XHR0aHJvdyBcIkV4dHJhL3VucGFyc2VkIGNoYXJhY3RlcnMgZm91bmQgaW4gZGF0ZTogXCIgKyBleHRyYTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoeWVhciA9PT0gLTEpIHtcblx0XHRcdHllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cdFx0fSBlbHNlIGlmICh5ZWFyIDwgMTAwKSB7XG5cdFx0XHR5ZWFyICs9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAtIG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArXG5cdFx0XHRcdCh5ZWFyIDw9IHNob3J0WWVhckN1dG9mZiA/IDAgOiAtMTAwKTtcblx0XHR9XG5cblx0XHRpZiAoZG95ID4gLTEpIHtcblx0XHRcdG1vbnRoID0gMTtcblx0XHRcdGRheSA9IGRveTtcblx0XHRcdGRvIHtcblx0XHRcdFx0ZGltID0gdGhpcy5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGggLSAxKTtcblx0XHRcdFx0aWYgKGRheSA8PSBkaW0pIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRtb250aCsrO1xuXHRcdFx0XHRkYXkgLT0gZGltO1xuXHRcdFx0fSB3aGlsZSAodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0ZGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5KSk7XG5cdFx0aWYgKGRhdGUuZ2V0RnVsbFllYXIoKSAhPT0geWVhciB8fCBkYXRlLmdldE1vbnRoKCkgKyAxICE9PSBtb250aCB8fCBkYXRlLmdldERhdGUoKSAhPT0gZGF5KSB7XG5cdFx0XHR0aHJvdyBcIkludmFsaWQgZGF0ZVwiOyAvLyBFLmcuIDMxLzAyLzAwXG5cdFx0fVxuXHRcdHJldHVybiBkYXRlO1xuXHR9LFxuXG5cdC8qIFN0YW5kYXJkIGRhdGUgZm9ybWF0cy4gKi9cblx0QVRPTTogXCJ5eS1tbS1kZFwiLCAvLyBSRkMgMzMzOSAoSVNPIDg2MDEpXG5cdENPT0tJRTogXCJELCBkZCBNIHl5XCIsXG5cdElTT184NjAxOiBcInl5LW1tLWRkXCIsXG5cdFJGQ184MjI6IFwiRCwgZCBNIHlcIixcblx0UkZDXzg1MDogXCJERCwgZGQtTS15XCIsXG5cdFJGQ18xMDM2OiBcIkQsIGQgTSB5XCIsXG5cdFJGQ18xMTIzOiBcIkQsIGQgTSB5eVwiLFxuXHRSRkNfMjgyMjogXCJELCBkIE0geXlcIixcblx0UlNTOiBcIkQsIGQgTSB5XCIsIC8vIFJGQyA4MjJcblx0VElDS1M6IFwiIVwiLFxuXHRUSU1FU1RBTVA6IFwiQFwiLFxuXHRXM0M6IFwieXktbW0tZGRcIiwgLy8gSVNPIDg2MDFcblxuXHRfdGlja3NUbzE5NzA6ICgoKDE5NzAgLSAxKSAqIDM2NSArIE1hdGguZmxvb3IoMTk3MCAvIDQpIC0gTWF0aC5mbG9vcigxOTcwIC8gMTAwKSArXG5cdFx0TWF0aC5mbG9vcigxOTcwIC8gNDAwKSkgKiAyNCAqIDYwICogNjAgKiAxMDAwMDAwMCksXG5cblx0LyogRm9ybWF0IGEgZGF0ZSBvYmplY3QgaW50byBhIHN0cmluZyB2YWx1ZS5cblx0ICogVGhlIGZvcm1hdCBjYW4gYmUgY29tYmluYXRpb25zIG9mIHRoZSBmb2xsb3dpbmc6XG5cdCAqIGQgIC0gZGF5IG9mIG1vbnRoIChubyBsZWFkaW5nIHplcm8pXG5cdCAqIGRkIC0gZGF5IG9mIG1vbnRoICh0d28gZGlnaXQpXG5cdCAqIG8gIC0gZGF5IG9mIHllYXIgKG5vIGxlYWRpbmcgemVyb3MpXG5cdCAqIG9vIC0gZGF5IG9mIHllYXIgKHRocmVlIGRpZ2l0KVxuXHQgKiBEICAtIGRheSBuYW1lIHNob3J0XG5cdCAqIEREIC0gZGF5IG5hbWUgbG9uZ1xuXHQgKiBtICAtIG1vbnRoIG9mIHllYXIgKG5vIGxlYWRpbmcgemVybylcblx0ICogbW0gLSBtb250aCBvZiB5ZWFyICh0d28gZGlnaXQpXG5cdCAqIE0gIC0gbW9udGggbmFtZSBzaG9ydFxuXHQgKiBNTSAtIG1vbnRoIG5hbWUgbG9uZ1xuXHQgKiB5ICAtIHllYXIgKHR3byBkaWdpdClcblx0ICogeXkgLSB5ZWFyIChmb3VyIGRpZ2l0KVxuXHQgKiBAIC0gVW5peCB0aW1lc3RhbXAgKG1zIHNpbmNlIDAxLzAxLzE5NzApXG5cdCAqICEgLSBXaW5kb3dzIHRpY2tzICgxMDBucyBzaW5jZSAwMS8wMS8wMDAxKVxuXHQgKiBcIi4uLlwiIC0gbGl0ZXJhbCB0ZXh0XG5cdCAqICcnIC0gc2luZ2xlIHF1b3RlXG5cdCAqXG5cdCAqIEBwYXJhbSAgZm9ybWF0IHN0cmluZyAtIHRoZSBkZXNpcmVkIGZvcm1hdCBvZiB0aGUgZGF0ZVxuXHQgKiBAcGFyYW0gIGRhdGUgRGF0ZSAtIHRoZSBkYXRlIHZhbHVlIHRvIGZvcm1hdFxuXHQgKiBAcGFyYW0gIHNldHRpbmdzIE9iamVjdCAtIGF0dHJpYnV0ZXMgaW5jbHVkZTpcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNTaG9ydFx0c3RyaW5nWzddIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRkYXlOYW1lc1x0XHRzdHJpbmdbN10gLSBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdG1vbnRoTmFtZXNTaG9ydCBzdHJpbmdbMTJdIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdG1vbnRoTmFtZXNcdFx0c3RyaW5nWzEyXSAtIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKiBAcmV0dXJuICBzdHJpbmcgLSB0aGUgZGF0ZSBpbiB0aGUgYWJvdmUgZm9ybWF0XG5cdCAqL1xuXHRmb3JtYXREYXRlOiBmdW5jdGlvbiAoZm9ybWF0LCBkYXRlLCBzZXR0aW5ncykge1xuXHRcdGlmICghZGF0ZSkge1xuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGlGb3JtYXQsXG5cdFx0XHRkYXlOYW1lc1Nob3J0ID0gKHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzU2hvcnQsXG5cdFx0XHRkYXlOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXMsXG5cdFx0XHRtb250aE5hbWVzU2hvcnQgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzU2hvcnQsXG5cdFx0XHRtb250aE5hbWVzID0gKHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lcyA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXMsXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0XHRsb29rQWhlYWQgPSBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IChpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgMSkgPT09IG1hdGNoKTtcblx0XHRcdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdFx0XHRpRm9ybWF0Kys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gRm9ybWF0IGEgbnVtYmVyLCB3aXRoIGxlYWRpbmcgemVybyBpZiBuZWNlc3Nhcnlcblx0XHRcdGZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKG1hdGNoLCB2YWx1ZSwgbGVuKSB7XG5cdFx0XHRcdHZhciBudW0gPSBcIlwiICsgdmFsdWU7XG5cdFx0XHRcdGlmIChsb29rQWhlYWQobWF0Y2gpKSB7XG5cdFx0XHRcdFx0d2hpbGUgKG51bS5sZW5ndGggPCBsZW4pIHtcblx0XHRcdFx0XHRcdG51bSA9IFwiMFwiICsgbnVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVtO1xuXHRcdFx0fSxcblx0XHRcdC8vIEZvcm1hdCBhIG5hbWUsIHNob3J0IG9yIGxvbmcgYXMgcmVxdWVzdGVkXG5cdFx0XHRmb3JtYXROYW1lID0gZnVuY3Rpb24obWF0Y2gsIHZhbHVlLCBzaG9ydE5hbWVzLCBsb25nTmFtZXMpIHtcblx0XHRcdFx0cmV0dXJuIChsb29rQWhlYWQobWF0Y2gpID8gbG9uZ05hbWVzW3ZhbHVlXSA6IHNob3J0TmFtZXNbdmFsdWVdKTtcblx0XHRcdH0sXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXG5cdFx0aWYgKGRhdGUpIHtcblx0XHRcdGZvciAoaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcblx0XHRcdFx0aWYgKGxpdGVyYWwpIHtcblx0XHRcdFx0XHRpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PT0gXCInXCIgJiYgIWxvb2tBaGVhZChcIidcIikpIHtcblx0XHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdFx0Y2FzZSBcImRcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlcihcImRcIiwgZGF0ZS5nZXREYXRlKCksIDIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJEXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROYW1lKFwiRFwiLCBkYXRlLmdldERheSgpLCBkYXlOYW1lc1Nob3J0LCBkYXlOYW1lcyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIm9cIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlcihcIm9cIixcblx0XHRcdFx0XHRcdFx0XHRNYXRoLnJvdW5kKChuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMCkuZ2V0VGltZSgpKSAvIDg2NDAwMDAwKSwgMyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIm1cIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlcihcIm1cIiwgZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIk1cIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE5hbWUoXCJNXCIsIGRhdGUuZ2V0TW9udGgoKSwgbW9udGhOYW1lc1Nob3J0LCBtb250aE5hbWVzKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwieVwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gKGxvb2tBaGVhZChcInlcIikgPyBkYXRlLmdldEZ1bGxZZWFyKCkgOlxuXHRcdFx0XHRcdFx0XHRcdChkYXRlLmdldFllYXIoKSAlIDEwMCA8IDEwID8gXCIwXCIgOiBcIlwiKSArIGRhdGUuZ2V0WWVhcigpICUgMTAwKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiQFwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZGF0ZS5nZXRUaW1lKCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIiFcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGRhdGUuZ2V0VGltZSgpICogMTAwMDAgKyB0aGlzLl90aWNrc1RvMTk3MDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiJ1wiOlxuXHRcdFx0XHRcdFx0XHRpZiAobG9va0FoZWFkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdFx0XHRcdG91dHB1dCArPSBcIidcIjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9LFxuXG5cdC8qIEV4dHJhY3QgYWxsIHBvc3NpYmxlIGNoYXJhY3RlcnMgZnJvbSB0aGUgZGF0ZSBmb3JtYXQuICovXG5cdF9wb3NzaWJsZUNoYXJzOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdFx0dmFyIGlGb3JtYXQsXG5cdFx0XHRjaGFycyA9IFwiXCIsXG5cdFx0XHRsaXRlcmFsID0gZmFsc2UsXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0XHRsb29rQWhlYWQgPSBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IChpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgMSkgPT09IG1hdGNoKTtcblx0XHRcdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdFx0XHRpRm9ybWF0Kys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0XHR9O1xuXG5cdFx0Zm9yIChpRm9ybWF0ID0gMDsgaUZvcm1hdCA8IGZvcm1hdC5sZW5ndGg7IGlGb3JtYXQrKykge1xuXHRcdFx0aWYgKGxpdGVyYWwpIHtcblx0XHRcdFx0aWYgKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkgPT09IFwiJ1wiICYmICFsb29rQWhlYWQoXCInXCIpKSB7XG5cdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNoYXJzICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdGNhc2UgXCJkXCI6IGNhc2UgXCJtXCI6IGNhc2UgXCJ5XCI6IGNhc2UgXCJAXCI6XG5cdFx0XHRcdFx0XHRjaGFycyArPSBcIjAxMjM0NTY3ODlcIjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJEXCI6IGNhc2UgXCJNXCI6XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDsgLy8gQWNjZXB0IGFueXRoaW5nXG5cdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdGlmIChsb29rQWhlYWQoXCInXCIpKSB7XG5cdFx0XHRcdFx0XHRcdGNoYXJzICs9IFwiJ1wiO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y2hhcnMgKz0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2hhcnM7XG5cdH0sXG5cblx0LyogR2V0IGEgc2V0dGluZyB2YWx1ZSwgZGVmYXVsdGluZyBpZiBuZWNlc3NhcnkuICovXG5cdF9nZXQ6IGZ1bmN0aW9uKGluc3QsIG5hbWUpIHtcblx0XHRyZXR1cm4gaW5zdC5zZXR0aW5nc1tuYW1lXSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdGluc3Quc2V0dGluZ3NbbmFtZV0gOiB0aGlzLl9kZWZhdWx0c1tuYW1lXTtcblx0fSxcblxuXHQvKiBQYXJzZSBleGlzdGluZyBkYXRlIGFuZCBpbml0aWFsaXNlIGRhdGUgcGlja2VyLiAqL1xuXHRfc2V0RGF0ZUZyb21GaWVsZDogZnVuY3Rpb24oaW5zdCwgbm9EZWZhdWx0KSB7XG5cdFx0aWYgKGluc3QuaW5wdXQudmFsKCkgPT09IGluc3QubGFzdFZhbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBkYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KGluc3QsIFwiZGF0ZUZvcm1hdFwiKSxcblx0XHRcdGRhdGVzID0gaW5zdC5sYXN0VmFsID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBudWxsLFxuXHRcdFx0ZGVmYXVsdERhdGUgPSB0aGlzLl9nZXREZWZhdWx0RGF0ZShpbnN0KSxcblx0XHRcdGRhdGUgPSBkZWZhdWx0RGF0ZSxcblx0XHRcdHNldHRpbmdzID0gdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGRhdGUgPSB0aGlzLnBhcnNlRGF0ZShkYXRlRm9ybWF0LCBkYXRlcywgc2V0dGluZ3MpIHx8IGRlZmF1bHREYXRlO1xuXHRcdH0gY2F0Y2ggKGV2ZW50KSB7XG5cdFx0XHRkYXRlcyA9IChub0RlZmF1bHQgPyBcIlwiIDogZGF0ZXMpO1xuXHRcdH1cblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGluc3QuY3VycmVudERheSA9IChkYXRlcyA/IGRhdGUuZ2V0RGF0ZSgpIDogMCk7XG5cdFx0aW5zdC5jdXJyZW50TW9udGggPSAoZGF0ZXMgPyBkYXRlLmdldE1vbnRoKCkgOiAwKTtcblx0XHRpbnN0LmN1cnJlbnRZZWFyID0gKGRhdGVzID8gZGF0ZS5nZXRGdWxsWWVhcigpIDogMCk7XG5cdFx0dGhpcy5fYWRqdXN0SW5zdERhdGUoaW5zdCk7XG5cdH0sXG5cblx0LyogUmV0cmlldmUgdGhlIGRlZmF1bHQgZGF0ZSBzaG93biBvbiBvcGVuaW5nLiAqL1xuXHRfZ2V0RGVmYXVsdERhdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVzdHJpY3RNaW5NYXgoaW5zdCxcblx0XHRcdHRoaXMuX2RldGVybWluZURhdGUoaW5zdCwgdGhpcy5fZ2V0KGluc3QsIFwiZGVmYXVsdERhdGVcIiksIG5ldyBEYXRlKCkpKTtcblx0fSxcblxuXHQvKiBBIGRhdGUgbWF5IGJlIHNwZWNpZmllZCBhcyBhbiBleGFjdCB2YWx1ZSBvciBhIHJlbGF0aXZlIG9uZS4gKi9cblx0X2RldGVybWluZURhdGU6IGZ1bmN0aW9uKGluc3QsIGRhdGUsIGRlZmF1bHREYXRlKSB7XG5cdFx0dmFyIG9mZnNldE51bWVyaWMgPSBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBvZmZzZXQpO1xuXHRcdFx0XHRyZXR1cm4gZGF0ZTtcblx0XHRcdH0sXG5cdFx0XHRvZmZzZXRTdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4gJC5kYXRlcGlja2VyLnBhcnNlRGF0ZSgkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIiksXG5cdFx0XHRcdFx0XHRvZmZzZXQsICQuZGF0ZXBpY2tlci5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRcdC8vIElnbm9yZVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGRhdGUgPSAob2Zmc2V0LnRvTG93ZXJDYXNlKCkubWF0Y2goL15jLykgP1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ2V0RGF0ZShpbnN0KSA6IG51bGwpIHx8IG5ldyBEYXRlKCksXG5cdFx0XHRcdFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKSxcblx0XHRcdFx0XHRtb250aCA9IGRhdGUuZ2V0TW9udGgoKSxcblx0XHRcdFx0XHRkYXkgPSBkYXRlLmdldERhdGUoKSxcblx0XHRcdFx0XHRwYXR0ZXJuID0gLyhbK1xcLV0/WzAtOV0rKVxccyooZHxEfHd8V3xtfE18eXxZKT8vZyxcblx0XHRcdFx0XHRtYXRjaGVzID0gcGF0dGVybi5leGVjKG9mZnNldCk7XG5cblx0XHRcdFx0d2hpbGUgKG1hdGNoZXMpIHtcblx0XHRcdFx0XHRzd2l0Y2ggKG1hdGNoZXNbMl0gfHwgXCJkXCIpIHtcblx0XHRcdFx0XHRcdGNhc2UgXCJkXCIgOiBjYXNlIFwiRFwiIDpcblx0XHRcdFx0XHRcdFx0ZGF5ICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sMTApOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJ3XCIgOiBjYXNlIFwiV1wiIDpcblx0XHRcdFx0XHRcdFx0ZGF5ICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sMTApICogNzsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwibVwiIDogY2FzZSBcIk1cIiA6XG5cdFx0XHRcdFx0XHRcdG1vbnRoICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sMTApO1xuXHRcdFx0XHRcdFx0XHRkYXkgPSBNYXRoLm1pbihkYXksICQuZGF0ZXBpY2tlci5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwieVwiOiBjYXNlIFwiWVwiIDpcblx0XHRcdFx0XHRcdFx0eWVhciArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKTtcblx0XHRcdFx0XHRcdFx0ZGF5ID0gTWF0aC5taW4oZGF5LCAkLmRhdGVwaWNrZXIuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtYXRjaGVzID0gcGF0dGVybi5leGVjKG9mZnNldCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuXHRcdFx0fSxcblx0XHRcdG5ld0RhdGUgPSAoZGF0ZSA9PSBudWxsIHx8IGRhdGUgPT09IFwiXCIgPyBkZWZhdWx0RGF0ZSA6ICh0eXBlb2YgZGF0ZSA9PT0gXCJzdHJpbmdcIiA/IG9mZnNldFN0cmluZyhkYXRlKSA6XG5cdFx0XHRcdCh0eXBlb2YgZGF0ZSA9PT0gXCJudW1iZXJcIiA/IChpc05hTihkYXRlKSA/IGRlZmF1bHREYXRlIDogb2Zmc2V0TnVtZXJpYyhkYXRlKSkgOiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSkpKSk7XG5cblx0XHRuZXdEYXRlID0gKG5ld0RhdGUgJiYgbmV3RGF0ZS50b1N0cmluZygpID09PSBcIkludmFsaWQgRGF0ZVwiID8gZGVmYXVsdERhdGUgOiBuZXdEYXRlKTtcblx0XHRpZiAobmV3RGF0ZSkge1xuXHRcdFx0bmV3RGF0ZS5zZXRIb3VycygwKTtcblx0XHRcdG5ld0RhdGUuc2V0TWludXRlcygwKTtcblx0XHRcdG5ld0RhdGUuc2V0U2Vjb25kcygwKTtcblx0XHRcdG5ld0RhdGUuc2V0TWlsbGlzZWNvbmRzKDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3RGF0ZSk7XG5cdH0sXG5cblx0LyogSGFuZGxlIHN3aXRjaCB0by9mcm9tIGRheWxpZ2h0IHNhdmluZy5cblx0ICogSG91cnMgbWF5IGJlIG5vbi16ZXJvIG9uIGRheWxpZ2h0IHNhdmluZyBjdXQtb3Zlcjpcblx0ICogPiAxMiB3aGVuIG1pZG5pZ2h0IGNoYW5nZW92ZXIsIGJ1dCB0aGVuIGNhbm5vdCBnZW5lcmF0ZVxuXHQgKiBtaWRuaWdodCBkYXRldGltZSwgc28ganVtcCB0byAxQU0sIG90aGVyd2lzZSByZXNldC5cblx0ICogQHBhcmFtICBkYXRlICAoRGF0ZSkgdGhlIGRhdGUgdG8gY2hlY2tcblx0ICogQHJldHVybiAgKERhdGUpIHRoZSBjb3JyZWN0ZWQgZGF0ZVxuXHQgKi9cblx0X2RheWxpZ2h0U2F2aW5nQWRqdXN0OiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0aWYgKCFkYXRlKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0ZGF0ZS5zZXRIb3VycyhkYXRlLmdldEhvdXJzKCkgPiAxMiA/IGRhdGUuZ2V0SG91cnMoKSArIDIgOiAwKTtcblx0XHRyZXR1cm4gZGF0ZTtcblx0fSxcblxuXHQvKiBTZXQgdGhlIGRhdGUocykgZGlyZWN0bHkuICovXG5cdF9zZXREYXRlOiBmdW5jdGlvbihpbnN0LCBkYXRlLCBub0NoYW5nZSkge1xuXHRcdHZhciBjbGVhciA9ICFkYXRlLFxuXHRcdFx0b3JpZ01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoLFxuXHRcdFx0b3JpZ1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhcixcblx0XHRcdG5ld0RhdGUgPSB0aGlzLl9yZXN0cmljdE1pbk1heChpbnN0LCB0aGlzLl9kZXRlcm1pbmVEYXRlKGluc3QsIGRhdGUsIG5ldyBEYXRlKCkpKTtcblxuXHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXkgPSBuZXdEYXRlLmdldERhdGUoKTtcblx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoID0gbmV3RGF0ZS5nZXRNb250aCgpO1xuXHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXIgPSBuZXdEYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0aWYgKChvcmlnTW9udGggIT09IGluc3Quc2VsZWN0ZWRNb250aCB8fCBvcmlnWWVhciAhPT0gaW5zdC5zZWxlY3RlZFllYXIpICYmICFub0NoYW5nZSkge1xuXHRcdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHRcdH1cblx0XHR0aGlzLl9hZGp1c3RJbnN0RGF0ZShpbnN0KTtcblx0XHRpZiAoaW5zdC5pbnB1dCkge1xuXHRcdFx0aW5zdC5pbnB1dC52YWwoY2xlYXIgPyBcIlwiIDogdGhpcy5fZm9ybWF0RGF0ZShpbnN0KSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFJldHJpZXZlIHRoZSBkYXRlKHMpIGRpcmVjdGx5LiAqL1xuXHRfZ2V0RGF0ZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBzdGFydERhdGUgPSAoIWluc3QuY3VycmVudFllYXIgfHwgKGluc3QuaW5wdXQgJiYgaW5zdC5pbnB1dC52YWwoKSA9PT0gXCJcIikgPyBudWxsIDpcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKFxuXHRcdFx0aW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSkpKTtcblx0XHRcdHJldHVybiBzdGFydERhdGU7XG5cdH0sXG5cblx0LyogQXR0YWNoIHRoZSBvbnh4eCBoYW5kbGVycy4gIFRoZXNlIGFyZSBkZWNsYXJlZCBzdGF0aWNhbGx5IHNvXG5cdCAqIHRoZXkgd29yayB3aXRoIHN0YXRpYyBjb2RlIHRyYW5zZm9ybWVycyBsaWtlIENhamEuXG5cdCAqL1xuXHRfYXR0YWNoSGFuZGxlcnM6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgc3RlcE1vbnRocyA9IHRoaXMuX2dldChpbnN0LCBcInN0ZXBNb250aHNcIiksXG5cdFx0XHRpZCA9IFwiI1wiICsgaW5zdC5pZC5yZXBsYWNlKCAvXFxcXFxcXFwvZywgXCJcXFxcXCIgKTtcblx0XHRpbnN0LmRwRGl2LmZpbmQoXCJbZGF0YS1oYW5kbGVyXVwiKS5tYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSB7XG5cdFx0XHRcdHByZXY6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoaWQsIC1zdGVwTW9udGhzLCBcIk1cIik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5leHQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoaWQsICtzdGVwTW9udGhzLCBcIk1cIik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGhpZGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRvZGF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9nb3RvVG9kYXkoaWQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3REYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdERheShpZCwgK3RoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tb250aFwiKSwgK3RoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS15ZWFyXCIpLCB0aGlzKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdE1vbnRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZWxlY3RNb250aFllYXIoaWQsIHRoaXMsIFwiTVwiKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdFllYXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdE1vbnRoWWVhcihpZCwgdGhpcywgXCJZXCIpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdCQodGhpcykuYmluZCh0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtZXZlbnRcIiksIGhhbmRsZXJbdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhhbmRsZXJcIildKTtcblx0XHR9KTtcblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgSFRNTCBmb3IgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGRhdGUgcGlja2VyLiAqL1xuXHRfZ2VuZXJhdGVIVE1MOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIG1heERyYXcsIHByZXZUZXh0LCBwcmV2LCBuZXh0VGV4dCwgbmV4dCwgY3VycmVudFRleHQsIGdvdG9EYXRlLFxuXHRcdFx0Y29udHJvbHMsIGJ1dHRvblBhbmVsLCBmaXJzdERheSwgc2hvd1dlZWssIGRheU5hbWVzLCBkYXlOYW1lc01pbixcblx0XHRcdG1vbnRoTmFtZXMsIG1vbnRoTmFtZXNTaG9ydCwgYmVmb3JlU2hvd0RheSwgc2hvd090aGVyTW9udGhzLFxuXHRcdFx0c2VsZWN0T3RoZXJNb250aHMsIGRlZmF1bHREYXRlLCBodG1sLCBkb3csIHJvdywgZ3JvdXAsIGNvbCwgc2VsZWN0ZWREYXRlLFxuXHRcdFx0Y29ybmVyQ2xhc3MsIGNhbGVuZGVyLCB0aGVhZCwgZGF5LCBkYXlzSW5Nb250aCwgbGVhZERheXMsIGN1clJvd3MsIG51bVJvd3MsXG5cdFx0XHRwcmludERhdGUsIGRSb3csIHRib2R5LCBkYXlTZXR0aW5ncywgb3RoZXJNb250aCwgdW5zZWxlY3RhYmxlLFxuXHRcdFx0dGVtcERhdGUgPSBuZXcgRGF0ZSgpLFxuXHRcdFx0dG9kYXkgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChcblx0XHRcdFx0bmV3IERhdGUodGVtcERhdGUuZ2V0RnVsbFllYXIoKSwgdGVtcERhdGUuZ2V0TW9udGgoKSwgdGVtcERhdGUuZ2V0RGF0ZSgpKSksIC8vIGNsZWFyIHRpbWVcblx0XHRcdGlzUlRMID0gdGhpcy5fZ2V0KGluc3QsIFwiaXNSVExcIiksXG5cdFx0XHRzaG93QnV0dG9uUGFuZWwgPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG93QnV0dG9uUGFuZWxcIiksXG5cdFx0XHRoaWRlSWZOb1ByZXZOZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwiaGlkZUlmTm9QcmV2TmV4dFwiKSxcblx0XHRcdG5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgXCJuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0XCIpLFxuXHRcdFx0bnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoaW5zdCksXG5cdFx0XHRzaG93Q3VycmVudEF0UG9zID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd0N1cnJlbnRBdFBvc1wiKSxcblx0XHRcdHN0ZXBNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgXCJzdGVwTW9udGhzXCIpLFxuXHRcdFx0aXNNdWx0aU1vbnRoID0gKG51bU1vbnRoc1swXSAhPT0gMSB8fCBudW1Nb250aHNbMV0gIT09IDEpLFxuXHRcdFx0Y3VycmVudERhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCgoIWluc3QuY3VycmVudERheSA/IG5ldyBEYXRlKDk5OTksIDksIDkpIDpcblx0XHRcdFx0bmV3IERhdGUoaW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSkpKSxcblx0XHRcdG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWluXCIpLFxuXHRcdFx0bWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXCJtYXhcIiksXG5cdFx0XHRkcmF3TW9udGggPSBpbnN0LmRyYXdNb250aCAtIHNob3dDdXJyZW50QXRQb3MsXG5cdFx0XHRkcmF3WWVhciA9IGluc3QuZHJhd1llYXI7XG5cblx0XHRpZiAoZHJhd01vbnRoIDwgMCkge1xuXHRcdFx0ZHJhd01vbnRoICs9IDEyO1xuXHRcdFx0ZHJhd1llYXItLTtcblx0XHR9XG5cdFx0aWYgKG1heERhdGUpIHtcblx0XHRcdG1heERyYXcgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShtYXhEYXRlLmdldEZ1bGxZZWFyKCksXG5cdFx0XHRcdG1heERhdGUuZ2V0TW9udGgoKSAtIChudW1Nb250aHNbMF0gKiBudW1Nb250aHNbMV0pICsgMSwgbWF4RGF0ZS5nZXREYXRlKCkpKTtcblx0XHRcdG1heERyYXcgPSAobWluRGF0ZSAmJiBtYXhEcmF3IDwgbWluRGF0ZSA/IG1pbkRhdGUgOiBtYXhEcmF3KTtcblx0XHRcdHdoaWxlICh0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShkcmF3WWVhciwgZHJhd01vbnRoLCAxKSkgPiBtYXhEcmF3KSB7XG5cdFx0XHRcdGRyYXdNb250aC0tO1xuXHRcdFx0XHRpZiAoZHJhd01vbnRoIDwgMCkge1xuXHRcdFx0XHRcdGRyYXdNb250aCA9IDExO1xuXHRcdFx0XHRcdGRyYXdZZWFyLS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aW5zdC5kcmF3TW9udGggPSBkcmF3TW9udGg7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGRyYXdZZWFyO1xuXG5cdFx0cHJldlRleHQgPSB0aGlzLl9nZXQoaW5zdCwgXCJwcmV2VGV4dFwiKTtcblx0XHRwcmV2VGV4dCA9ICghbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA/IHByZXZUZXh0IDogdGhpcy5mb3JtYXREYXRlKHByZXZUZXh0LFxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCAtIHN0ZXBNb250aHMsIDEpKSxcblx0XHRcdHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSkpO1xuXG5cdFx0cHJldiA9ICh0aGlzLl9jYW5BZGp1c3RNb250aChpbnN0LCAtMSwgZHJhd1llYXIsIGRyYXdNb250aCkgP1xuXHRcdFx0XCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1wcmV2IHVpLWNvcm5lci1hbGwnIGRhdGEtaGFuZGxlcj0ncHJldicgZGF0YS1ldmVudD0nY2xpY2snXCIgK1xuXHRcdFx0XCIgdGl0bGU9J1wiICsgcHJldlRleHQgKyBcIic+PHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtXCIgKyAoIGlzUlRMID8gXCJlXCIgOiBcIndcIikgKyBcIic+XCIgKyBwcmV2VGV4dCArIFwiPC9zcGFuPjwvYT5cIiA6XG5cdFx0XHQoaGlkZUlmTm9QcmV2TmV4dCA/IFwiXCIgOiBcIjxhIGNsYXNzPSd1aS1kYXRlcGlja2VyLXByZXYgdWktY29ybmVyLWFsbCB1aS1zdGF0ZS1kaXNhYmxlZCcgdGl0bGU9J1wiKyBwcmV2VGV4dCArXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwiZVwiIDogXCJ3XCIpICsgXCInPlwiICsgcHJldlRleHQgKyBcIjwvc3Bhbj48L2E+XCIpKTtcblxuXHRcdG5leHRUZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwibmV4dFRleHRcIik7XG5cdFx0bmV4dFRleHQgPSAoIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBuZXh0VGV4dCA6IHRoaXMuZm9ybWF0RGF0ZShuZXh0VGV4dCxcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGggKyBzdGVwTW9udGhzLCAxKSksXG5cdFx0XHR0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpKTtcblxuXHRcdG5leHQgPSAodGhpcy5fY2FuQWRqdXN0TW9udGgoaW5zdCwgKzEsIGRyYXdZZWFyLCBkcmF3TW9udGgpID9cblx0XHRcdFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItbmV4dCB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J25leHQnIGRhdGEtZXZlbnQ9J2NsaWNrJ1wiICtcblx0XHRcdFwiIHRpdGxlPSdcIiArIG5leHRUZXh0ICsgXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwid1wiIDogXCJlXCIpICsgXCInPlwiICsgbmV4dFRleHQgKyBcIjwvc3Bhbj48L2E+XCIgOlxuXHRcdFx0KGhpZGVJZk5vUHJldk5leHQgPyBcIlwiIDogXCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1uZXh0IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGlzYWJsZWQnIHRpdGxlPSdcIisgbmV4dFRleHQgKyBcIic+PHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtXCIgKyAoIGlzUlRMID8gXCJ3XCIgOiBcImVcIikgKyBcIic+XCIgKyBuZXh0VGV4dCArIFwiPC9zcGFuPjwvYT5cIikpO1xuXG5cdFx0Y3VycmVudFRleHQgPSB0aGlzLl9nZXQoaW5zdCwgXCJjdXJyZW50VGV4dFwiKTtcblx0XHRnb3RvRGF0ZSA9ICh0aGlzLl9nZXQoaW5zdCwgXCJnb3RvQ3VycmVudFwiKSAmJiBpbnN0LmN1cnJlbnREYXkgPyBjdXJyZW50RGF0ZSA6IHRvZGF5KTtcblx0XHRjdXJyZW50VGV4dCA9ICghbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA/IGN1cnJlbnRUZXh0IDpcblx0XHRcdHRoaXMuZm9ybWF0RGF0ZShjdXJyZW50VGV4dCwgZ290b0RhdGUsIHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSkpO1xuXG5cdFx0Y29udHJvbHMgPSAoIWluc3QuaW5saW5lID8gXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3VpLWRhdGVwaWNrZXItY2xvc2UgdWktc3RhdGUtZGVmYXVsdCB1aS1wcmlvcml0eS1wcmltYXJ5IHVpLWNvcm5lci1hbGwnIGRhdGEtaGFuZGxlcj0naGlkZScgZGF0YS1ldmVudD0nY2xpY2snPlwiICtcblx0XHRcdHRoaXMuX2dldChpbnN0LCBcImNsb3NlVGV4dFwiKSArIFwiPC9idXR0b24+XCIgOiBcIlwiKTtcblxuXHRcdGJ1dHRvblBhbmVsID0gKHNob3dCdXR0b25QYW5lbCkgPyBcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItYnV0dG9ucGFuZSB1aS13aWRnZXQtY29udGVudCc+XCIgKyAoaXNSVEwgPyBjb250cm9scyA6IFwiXCIpICtcblx0XHRcdCh0aGlzLl9pc0luUmFuZ2UoaW5zdCwgZ290b0RhdGUpID8gXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3VpLWRhdGVwaWNrZXItY3VycmVudCB1aS1zdGF0ZS1kZWZhdWx0IHVpLXByaW9yaXR5LXNlY29uZGFyeSB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J3RvZGF5JyBkYXRhLWV2ZW50PSdjbGljaydcIiArXG5cdFx0XHRcIj5cIiArIGN1cnJlbnRUZXh0ICsgXCI8L2J1dHRvbj5cIiA6IFwiXCIpICsgKGlzUlRMID8gXCJcIiA6IGNvbnRyb2xzKSArIFwiPC9kaXY+XCIgOiBcIlwiO1xuXG5cdFx0Zmlyc3REYXkgPSBwYXJzZUludCh0aGlzLl9nZXQoaW5zdCwgXCJmaXJzdERheVwiKSwxMCk7XG5cdFx0Zmlyc3REYXkgPSAoaXNOYU4oZmlyc3REYXkpID8gMCA6IGZpcnN0RGF5KTtcblxuXHRcdHNob3dXZWVrID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd1dlZWtcIik7XG5cdFx0ZGF5TmFtZXMgPSB0aGlzLl9nZXQoaW5zdCwgXCJkYXlOYW1lc1wiKTtcblx0XHRkYXlOYW1lc01pbiA9IHRoaXMuX2dldChpbnN0LCBcImRheU5hbWVzTWluXCIpO1xuXHRcdG1vbnRoTmFtZXMgPSB0aGlzLl9nZXQoaW5zdCwgXCJtb250aE5hbWVzXCIpO1xuXHRcdG1vbnRoTmFtZXNTaG9ydCA9IHRoaXMuX2dldChpbnN0LCBcIm1vbnRoTmFtZXNTaG9ydFwiKTtcblx0XHRiZWZvcmVTaG93RGF5ID0gdGhpcy5fZ2V0KGluc3QsIFwiYmVmb3JlU2hvd0RheVwiKTtcblx0XHRzaG93T3RoZXJNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG93T3RoZXJNb250aHNcIik7XG5cdFx0c2VsZWN0T3RoZXJNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgXCJzZWxlY3RPdGhlck1vbnRoc1wiKTtcblx0XHRkZWZhdWx0RGF0ZSA9IHRoaXMuX2dldERlZmF1bHREYXRlKGluc3QpO1xuXHRcdGh0bWwgPSBcIlwiO1xuXHRcdGRvdztcblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IG51bU1vbnRoc1swXTsgcm93KyspIHtcblx0XHRcdGdyb3VwID0gXCJcIjtcblx0XHRcdHRoaXMubWF4Um93cyA9IDQ7XG5cdFx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IG51bU1vbnRoc1sxXTsgY29sKyspIHtcblx0XHRcdFx0c2VsZWN0ZWREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgaW5zdC5zZWxlY3RlZERheSkpO1xuXHRcdFx0XHRjb3JuZXJDbGFzcyA9IFwiIHVpLWNvcm5lci1hbGxcIjtcblx0XHRcdFx0Y2FsZW5kZXIgPSBcIlwiO1xuXHRcdFx0XHRpZiAoaXNNdWx0aU1vbnRoKSB7XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWdyb3VwXCI7XG5cdFx0XHRcdFx0aWYgKG51bU1vbnRoc1sxXSA+IDEpIHtcblx0XHRcdFx0XHRcdHN3aXRjaCAoY29sKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMDogY2FsZW5kZXIgKz0gXCIgdWktZGF0ZXBpY2tlci1ncm91cC1maXJzdFwiO1xuXHRcdFx0XHRcdFx0XHRcdGNvcm5lckNsYXNzID0gXCIgdWktY29ybmVyLVwiICsgKGlzUlRMID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpOyBicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBudW1Nb250aHNbMV0tMTogY2FsZW5kZXIgKz0gXCIgdWktZGF0ZXBpY2tlci1ncm91cC1sYXN0XCI7XG5cdFx0XHRcdFx0XHRcdFx0Y29ybmVyQ2xhc3MgPSBcIiB1aS1jb3JuZXItXCIgKyAoaXNSVEwgPyBcImxlZnRcIiA6IFwicmlnaHRcIik7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OiBjYWxlbmRlciArPSBcIiB1aS1kYXRlcGlja2VyLWdyb3VwLW1pZGRsZVwiOyBjb3JuZXJDbGFzcyA9IFwiXCI7IGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYWxlbmRlciArPSBcIic+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsZW5kZXIgKz0gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWhlYWRlciB1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeFwiICsgY29ybmVyQ2xhc3MgKyBcIic+XCIgK1xuXHRcdFx0XHRcdCgvYWxsfGxlZnQvLnRlc3QoY29ybmVyQ2xhc3MpICYmIHJvdyA9PT0gMCA/IChpc1JUTCA/IG5leHQgOiBwcmV2KSA6IFwiXCIpICtcblx0XHRcdFx0XHQoL2FsbHxyaWdodC8udGVzdChjb3JuZXJDbGFzcykgJiYgcm93ID09PSAwID8gKGlzUlRMID8gcHJldiA6IG5leHQpIDogXCJcIikgK1xuXHRcdFx0XHRcdHRoaXMuX2dlbmVyYXRlTW9udGhZZWFySGVhZGVyKGluc3QsIGRyYXdNb250aCwgZHJhd1llYXIsIG1pbkRhdGUsIG1heERhdGUsXG5cdFx0XHRcdFx0cm93ID4gMCB8fCBjb2wgPiAwLCBtb250aE5hbWVzLCBtb250aE5hbWVzU2hvcnQpICsgLy8gZHJhdyBtb250aCBoZWFkZXJzXG5cdFx0XHRcdFx0XCI8L2Rpdj48dGFibGUgY2xhc3M9J3VpLWRhdGVwaWNrZXItY2FsZW5kYXInPjx0aGVhZD5cIiArXG5cdFx0XHRcdFx0XCI8dHI+XCI7XG5cdFx0XHRcdHRoZWFkID0gKHNob3dXZWVrID8gXCI8dGggY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1jb2wnPlwiICsgdGhpcy5fZ2V0KGluc3QsIFwid2Vla0hlYWRlclwiKSArIFwiPC90aD5cIiA6IFwiXCIpO1xuXHRcdFx0XHRmb3IgKGRvdyA9IDA7IGRvdyA8IDc7IGRvdysrKSB7IC8vIGRheXMgb2YgdGhlIHdlZWtcblx0XHRcdFx0XHRkYXkgPSAoZG93ICsgZmlyc3REYXkpICUgNztcblx0XHRcdFx0XHR0aGVhZCArPSBcIjx0aFwiICsgKChkb3cgKyBmaXJzdERheSArIDYpICUgNyA+PSA1ID8gXCIgY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1lbmQnXCIgOiBcIlwiKSArIFwiPlwiICtcblx0XHRcdFx0XHRcdFwiPHNwYW4gdGl0bGU9J1wiICsgZGF5TmFtZXNbZGF5XSArIFwiJz5cIiArIGRheU5hbWVzTWluW2RheV0gKyBcIjwvc3Bhbj48L3RoPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGVuZGVyICs9IHRoZWFkICsgXCI8L3RyPjwvdGhlYWQ+PHRib2R5PlwiO1xuXHRcdFx0XHRkYXlzSW5Nb250aCA9IHRoaXMuX2dldERheXNJbk1vbnRoKGRyYXdZZWFyLCBkcmF3TW9udGgpO1xuXHRcdFx0XHRpZiAoZHJhd1llYXIgPT09IGluc3Quc2VsZWN0ZWRZZWFyICYmIGRyYXdNb250aCA9PT0gaW5zdC5zZWxlY3RlZE1vbnRoKSB7XG5cdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERheSA9IE1hdGgubWluKGluc3Quc2VsZWN0ZWREYXksIGRheXNJbk1vbnRoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZWFkRGF5cyA9ICh0aGlzLl9nZXRGaXJzdERheU9mTW9udGgoZHJhd1llYXIsIGRyYXdNb250aCkgLSBmaXJzdERheSArIDcpICUgNztcblx0XHRcdFx0Y3VyUm93cyA9IE1hdGguY2VpbCgobGVhZERheXMgKyBkYXlzSW5Nb250aCkgLyA3KTsgLy8gY2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygcm93cyB0byBnZW5lcmF0ZVxuXHRcdFx0XHRudW1Sb3dzID0gKGlzTXVsdGlNb250aCA/IHRoaXMubWF4Um93cyA+IGN1clJvd3MgPyB0aGlzLm1heFJvd3MgOiBjdXJSb3dzIDogY3VyUm93cyk7IC8vSWYgbXVsdGlwbGUgbW9udGhzLCB1c2UgdGhlIGhpZ2hlciBudW1iZXIgb2Ygcm93cyAoc2VlICM3MDQzKVxuXHRcdFx0XHR0aGlzLm1heFJvd3MgPSBudW1Sb3dzO1xuXHRcdFx0XHRwcmludERhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShkcmF3WWVhciwgZHJhd01vbnRoLCAxIC0gbGVhZERheXMpKTtcblx0XHRcdFx0Zm9yIChkUm93ID0gMDsgZFJvdyA8IG51bVJvd3M7IGRSb3crKykgeyAvLyBjcmVhdGUgZGF0ZSBwaWNrZXIgcm93c1xuXHRcdFx0XHRcdGNhbGVuZGVyICs9IFwiPHRyPlwiO1xuXHRcdFx0XHRcdHRib2R5ID0gKCFzaG93V2VlayA/IFwiXCIgOiBcIjx0ZCBjbGFzcz0ndWktZGF0ZXBpY2tlci13ZWVrLWNvbCc+XCIgK1xuXHRcdFx0XHRcdFx0dGhpcy5fZ2V0KGluc3QsIFwiY2FsY3VsYXRlV2Vla1wiKShwcmludERhdGUpICsgXCI8L3RkPlwiKTtcblx0XHRcdFx0XHRmb3IgKGRvdyA9IDA7IGRvdyA8IDc7IGRvdysrKSB7IC8vIGNyZWF0ZSBkYXRlIHBpY2tlciBkYXlzXG5cdFx0XHRcdFx0XHRkYXlTZXR0aW5ncyA9IChiZWZvcmVTaG93RGF5ID9cblx0XHRcdFx0XHRcdFx0YmVmb3JlU2hvd0RheS5hcHBseSgoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsKSwgW3ByaW50RGF0ZV0pIDogW3RydWUsIFwiXCJdKTtcblx0XHRcdFx0XHRcdG90aGVyTW9udGggPSAocHJpbnREYXRlLmdldE1vbnRoKCkgIT09IGRyYXdNb250aCk7XG5cdFx0XHRcdFx0XHR1bnNlbGVjdGFibGUgPSAob3RoZXJNb250aCAmJiAhc2VsZWN0T3RoZXJNb250aHMpIHx8ICFkYXlTZXR0aW5nc1swXSB8fFxuXHRcdFx0XHRcdFx0XHQobWluRGF0ZSAmJiBwcmludERhdGUgPCBtaW5EYXRlKSB8fCAobWF4RGF0ZSAmJiBwcmludERhdGUgPiBtYXhEYXRlKTtcblx0XHRcdFx0XHRcdHRib2R5ICs9IFwiPHRkIGNsYXNzPSdcIiArXG5cdFx0XHRcdFx0XHRcdCgoZG93ICsgZmlyc3REYXkgKyA2KSAlIDcgPj0gNSA/IFwiIHVpLWRhdGVwaWNrZXItd2Vlay1lbmRcIiA6IFwiXCIpICsgLy8gaGlnaGxpZ2h0IHdlZWtlbmRzXG5cdFx0XHRcdFx0XHRcdChvdGhlck1vbnRoID8gXCIgdWktZGF0ZXBpY2tlci1vdGhlci1tb250aFwiIDogXCJcIikgKyAvLyBoaWdobGlnaHQgZGF5cyBmcm9tIG90aGVyIG1vbnRoc1xuXHRcdFx0XHRcdFx0XHQoKHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IHNlbGVjdGVkRGF0ZS5nZXRUaW1lKCkgJiYgZHJhd01vbnRoID09PSBpbnN0LnNlbGVjdGVkTW9udGggJiYgaW5zdC5fa2V5RXZlbnQpIHx8IC8vIHVzZXIgcHJlc3NlZCBrZXlcblx0XHRcdFx0XHRcdFx0KGRlZmF1bHREYXRlLmdldFRpbWUoKSA9PT0gcHJpbnREYXRlLmdldFRpbWUoKSAmJiBkZWZhdWx0RGF0ZS5nZXRUaW1lKCkgPT09IHNlbGVjdGVkRGF0ZS5nZXRUaW1lKCkpID9cblx0XHRcdFx0XHRcdFx0Ly8gb3IgZGVmYXVsdERhdGUgaXMgY3VycmVudCBwcmludGVkRGF0ZSBhbmQgZGVmYXVsdERhdGUgaXMgc2VsZWN0ZWREYXRlXG5cdFx0XHRcdFx0XHRcdFwiIFwiICsgdGhpcy5fZGF5T3ZlckNsYXNzIDogXCJcIikgKyAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XG5cdFx0XHRcdFx0XHRcdCh1bnNlbGVjdGFibGUgPyBcIiBcIiArIHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzICsgXCIgdWktc3RhdGUtZGlzYWJsZWRcIjogXCJcIikgKyAgLy8gaGlnaGxpZ2h0IHVuc2VsZWN0YWJsZSBkYXlzXG5cdFx0XHRcdFx0XHRcdChvdGhlck1vbnRoICYmICFzaG93T3RoZXJNb250aHMgPyBcIlwiIDogXCIgXCIgKyBkYXlTZXR0aW5nc1sxXSArIC8vIGhpZ2hsaWdodCBjdXN0b20gZGF0ZXNcblx0XHRcdFx0XHRcdFx0KHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IGN1cnJlbnREYXRlLmdldFRpbWUoKSA/IFwiIFwiICsgdGhpcy5fY3VycmVudENsYXNzIDogXCJcIikgKyAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XG5cdFx0XHRcdFx0XHRcdChwcmludERhdGUuZ2V0VGltZSgpID09PSB0b2RheS5nZXRUaW1lKCkgPyBcIiB1aS1kYXRlcGlja2VyLXRvZGF5XCIgOiBcIlwiKSkgKyBcIidcIiArIC8vIGhpZ2hsaWdodCB0b2RheSAoaWYgZGlmZmVyZW50KVxuXHRcdFx0XHRcdFx0XHQoKCFvdGhlck1vbnRoIHx8IHNob3dPdGhlck1vbnRocykgJiYgZGF5U2V0dGluZ3NbMl0gPyBcIiB0aXRsZT0nXCIgKyBkYXlTZXR0aW5nc1syXS5yZXBsYWNlKC8nL2csIFwiJiMzOTtcIikgKyBcIidcIiA6IFwiXCIpICsgLy8gY2VsbCB0aXRsZVxuXHRcdFx0XHRcdFx0XHQodW5zZWxlY3RhYmxlID8gXCJcIiA6IFwiIGRhdGEtaGFuZGxlcj0nc2VsZWN0RGF5JyBkYXRhLWV2ZW50PSdjbGljaycgZGF0YS1tb250aD0nXCIgKyBwcmludERhdGUuZ2V0TW9udGgoKSArIFwiJyBkYXRhLXllYXI9J1wiICsgcHJpbnREYXRlLmdldEZ1bGxZZWFyKCkgKyBcIidcIikgKyBcIj5cIiArIC8vIGFjdGlvbnNcblx0XHRcdFx0XHRcdFx0KG90aGVyTW9udGggJiYgIXNob3dPdGhlck1vbnRocyA/IFwiJiN4YTA7XCIgOiAvLyBkaXNwbGF5IGZvciBvdGhlciBtb250aHNcblx0XHRcdFx0XHRcdFx0KHVuc2VsZWN0YWJsZSA/IFwiPHNwYW4gY2xhc3M9J3VpLXN0YXRlLWRlZmF1bHQnPlwiICsgcHJpbnREYXRlLmdldERhdGUoKSArIFwiPC9zcGFuPlwiIDogXCI8YSBjbGFzcz0ndWktc3RhdGUtZGVmYXVsdFwiICtcblx0XHRcdFx0XHRcdFx0KHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IHRvZGF5LmdldFRpbWUoKSA/IFwiIHVpLXN0YXRlLWhpZ2hsaWdodFwiIDogXCJcIikgK1xuXHRcdFx0XHRcdFx0XHQocHJpbnREYXRlLmdldFRpbWUoKSA9PT0gY3VycmVudERhdGUuZ2V0VGltZSgpID8gXCIgdWktc3RhdGUtYWN0aXZlXCIgOiBcIlwiKSArIC8vIGhpZ2hsaWdodCBzZWxlY3RlZCBkYXlcblx0XHRcdFx0XHRcdFx0KG90aGVyTW9udGggPyBcIiB1aS1wcmlvcml0eS1zZWNvbmRhcnlcIiA6IFwiXCIpICsgLy8gZGlzdGluZ3Vpc2ggZGF0ZXMgZnJvbSBvdGhlciBtb250aHNcblx0XHRcdFx0XHRcdFx0XCInIGhyZWY9JyMnPlwiICsgcHJpbnREYXRlLmdldERhdGUoKSArIFwiPC9hPlwiKSkgKyBcIjwvdGQ+XCI7IC8vIGRpc3BsYXkgc2VsZWN0YWJsZSBkYXRlXG5cdFx0XHRcdFx0XHRwcmludERhdGUuc2V0RGF0ZShwcmludERhdGUuZ2V0RGF0ZSgpICsgMSk7XG5cdFx0XHRcdFx0XHRwcmludERhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChwcmludERhdGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYWxlbmRlciArPSB0Ym9keSArIFwiPC90cj5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRkcmF3TW9udGgrKztcblx0XHRcdFx0aWYgKGRyYXdNb250aCA+IDExKSB7XG5cdFx0XHRcdFx0ZHJhd01vbnRoID0gMDtcblx0XHRcdFx0XHRkcmF3WWVhcisrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGVuZGVyICs9IFwiPC90Ym9keT48L3RhYmxlPlwiICsgKGlzTXVsdGlNb250aCA/IFwiPC9kaXY+XCIgK1xuXHRcdFx0XHRcdFx0XHQoKG51bU1vbnRoc1swXSA+IDAgJiYgY29sID09PSBudW1Nb250aHNbMV0tMSkgPyBcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItcm93LWJyZWFrJz48L2Rpdj5cIiA6IFwiXCIpIDogXCJcIik7XG5cdFx0XHRcdGdyb3VwICs9IGNhbGVuZGVyO1xuXHRcdFx0fVxuXHRcdFx0aHRtbCArPSBncm91cDtcblx0XHR9XG5cdFx0aHRtbCArPSBidXR0b25QYW5lbDtcblx0XHRpbnN0Ll9rZXlFdmVudCA9IGZhbHNlO1xuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdC8qIEdlbmVyYXRlIHRoZSBtb250aCBhbmQgeWVhciBoZWFkZXIuICovXG5cdF9nZW5lcmF0ZU1vbnRoWWVhckhlYWRlcjogZnVuY3Rpb24oaW5zdCwgZHJhd01vbnRoLCBkcmF3WWVhciwgbWluRGF0ZSwgbWF4RGF0ZSxcblx0XHRcdHNlY29uZGFyeSwgbW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0KSB7XG5cblx0XHR2YXIgaW5NaW5ZZWFyLCBpbk1heFllYXIsIG1vbnRoLCB5ZWFycywgdGhpc1llYXIsIGRldGVybWluZVllYXIsIHllYXIsIGVuZFllYXIsXG5cdFx0XHRjaGFuZ2VNb250aCA9IHRoaXMuX2dldChpbnN0LCBcImNoYW5nZU1vbnRoXCIpLFxuXHRcdFx0Y2hhbmdlWWVhciA9IHRoaXMuX2dldChpbnN0LCBcImNoYW5nZVllYXJcIiksXG5cdFx0XHRzaG93TW9udGhBZnRlclllYXIgPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG93TW9udGhBZnRlclllYXJcIiksXG5cdFx0XHRodG1sID0gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLXRpdGxlJz5cIixcblx0XHRcdG1vbnRoSHRtbCA9IFwiXCI7XG5cblx0XHQvLyBtb250aCBzZWxlY3Rpb25cblx0XHRpZiAoc2Vjb25kYXJ5IHx8ICFjaGFuZ2VNb250aCkge1xuXHRcdFx0bW9udGhIdG1sICs9IFwiPHNwYW4gY2xhc3M9J3VpLWRhdGVwaWNrZXItbW9udGgnPlwiICsgbW9udGhOYW1lc1tkcmF3TW9udGhdICsgXCI8L3NwYW4+XCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGluTWluWWVhciA9IChtaW5EYXRlICYmIG1pbkRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gZHJhd1llYXIpO1xuXHRcdFx0aW5NYXhZZWFyID0gKG1heERhdGUgJiYgbWF4RGF0ZS5nZXRGdWxsWWVhcigpID09PSBkcmF3WWVhcik7XG5cdFx0XHRtb250aEh0bWwgKz0gXCI8c2VsZWN0IGNsYXNzPSd1aS1kYXRlcGlja2VyLW1vbnRoJyBkYXRhLWhhbmRsZXI9J3NlbGVjdE1vbnRoJyBkYXRhLWV2ZW50PSdjaGFuZ2UnPlwiO1xuXHRcdFx0Zm9yICggbW9udGggPSAwOyBtb250aCA8IDEyOyBtb250aCsrKSB7XG5cdFx0XHRcdGlmICgoIWluTWluWWVhciB8fCBtb250aCA+PSBtaW5EYXRlLmdldE1vbnRoKCkpICYmICghaW5NYXhZZWFyIHx8IG1vbnRoIDw9IG1heERhdGUuZ2V0TW9udGgoKSkpIHtcblx0XHRcdFx0XHRtb250aEh0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIG1vbnRoICsgXCInXCIgK1xuXHRcdFx0XHRcdFx0KG1vbnRoID09PSBkcmF3TW9udGggPyBcIiBzZWxlY3RlZD0nc2VsZWN0ZWQnXCIgOiBcIlwiKSArXG5cdFx0XHRcdFx0XHRcIj5cIiArIG1vbnRoTmFtZXNTaG9ydFttb250aF0gKyBcIjwvb3B0aW9uPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtb250aEh0bWwgKz0gXCI8L3NlbGVjdD5cIjtcblx0XHR9XG5cblx0XHRpZiAoIXNob3dNb250aEFmdGVyWWVhcikge1xuXHRcdFx0aHRtbCArPSBtb250aEh0bWwgKyAoc2Vjb25kYXJ5IHx8ICEoY2hhbmdlTW9udGggJiYgY2hhbmdlWWVhcikgPyBcIiYjeGEwO1wiIDogXCJcIik7XG5cdFx0fVxuXG5cdFx0Ly8geWVhciBzZWxlY3Rpb25cblx0XHRpZiAoICFpbnN0LnllYXJzaHRtbCApIHtcblx0XHRcdGluc3QueWVhcnNodG1sID0gXCJcIjtcblx0XHRcdGlmIChzZWNvbmRhcnkgfHwgIWNoYW5nZVllYXIpIHtcblx0XHRcdFx0aHRtbCArPSBcIjxzcGFuIGNsYXNzPSd1aS1kYXRlcGlja2VyLXllYXInPlwiICsgZHJhd1llYXIgKyBcIjwvc3Bhbj5cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGRldGVybWluZSByYW5nZSBvZiB5ZWFycyB0byBkaXNwbGF5XG5cdFx0XHRcdHllYXJzID0gdGhpcy5fZ2V0KGluc3QsIFwieWVhclJhbmdlXCIpLnNwbGl0KFwiOlwiKTtcblx0XHRcdFx0dGhpc1llYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdGRldGVybWluZVllYXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdHZhciB5ZWFyID0gKHZhbHVlLm1hdGNoKC9jWytcXC1dLiovKSA/IGRyYXdZZWFyICsgcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKDEpLCAxMCkgOlxuXHRcdFx0XHRcdFx0KHZhbHVlLm1hdGNoKC9bK1xcLV0uKi8pID8gdGhpc1llYXIgKyBwYXJzZUludCh2YWx1ZSwgMTApIDpcblx0XHRcdFx0XHRcdHBhcnNlSW50KHZhbHVlLCAxMCkpKTtcblx0XHRcdFx0XHRyZXR1cm4gKGlzTmFOKHllYXIpID8gdGhpc1llYXIgOiB5ZWFyKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0eWVhciA9IGRldGVybWluZVllYXIoeWVhcnNbMF0pO1xuXHRcdFx0XHRlbmRZZWFyID0gTWF0aC5tYXgoeWVhciwgZGV0ZXJtaW5lWWVhcih5ZWFyc1sxXSB8fCBcIlwiKSk7XG5cdFx0XHRcdHllYXIgPSAobWluRGF0ZSA/IE1hdGgubWF4KHllYXIsIG1pbkRhdGUuZ2V0RnVsbFllYXIoKSkgOiB5ZWFyKTtcblx0XHRcdFx0ZW5kWWVhciA9IChtYXhEYXRlID8gTWF0aC5taW4oZW5kWWVhciwgbWF4RGF0ZS5nZXRGdWxsWWVhcigpKSA6IGVuZFllYXIpO1xuXHRcdFx0XHRpbnN0LnllYXJzaHRtbCArPSBcIjxzZWxlY3QgY2xhc3M9J3VpLWRhdGVwaWNrZXIteWVhcicgZGF0YS1oYW5kbGVyPSdzZWxlY3RZZWFyJyBkYXRhLWV2ZW50PSdjaGFuZ2UnPlwiO1xuXHRcdFx0XHRmb3IgKDsgeWVhciA8PSBlbmRZZWFyOyB5ZWFyKyspIHtcblx0XHRcdFx0XHRpbnN0LnllYXJzaHRtbCArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgeWVhciArIFwiJ1wiICtcblx0XHRcdFx0XHRcdCh5ZWFyID09PSBkcmF3WWVhciA/IFwiIHNlbGVjdGVkPSdzZWxlY3RlZCdcIiA6IFwiXCIpICtcblx0XHRcdFx0XHRcdFwiPlwiICsgeWVhciArIFwiPC9vcHRpb24+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gXCI8L3NlbGVjdD5cIjtcblxuXHRcdFx0XHRodG1sICs9IGluc3QueWVhcnNodG1sO1xuXHRcdFx0XHRpbnN0LnllYXJzaHRtbCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aHRtbCArPSB0aGlzLl9nZXQoaW5zdCwgXCJ5ZWFyU3VmZml4XCIpO1xuXHRcdGlmIChzaG93TW9udGhBZnRlclllYXIpIHtcblx0XHRcdGh0bWwgKz0gKHNlY29uZGFyeSB8fCAhKGNoYW5nZU1vbnRoICYmIGNoYW5nZVllYXIpID8gXCImI3hhMDtcIiA6IFwiXCIpICsgbW9udGhIdG1sO1xuXHRcdH1cblx0XHRodG1sICs9IFwiPC9kaXY+XCI7IC8vIENsb3NlIGRhdGVwaWNrZXJfaGVhZGVyXG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0LyogQWRqdXN0IG9uZSBvZiB0aGUgZGF0ZSBzdWItZmllbGRzLiAqL1xuXHRfYWRqdXN0SW5zdERhdGU6IGZ1bmN0aW9uKGluc3QsIG9mZnNldCwgcGVyaW9kKSB7XG5cdFx0dmFyIHllYXIgPSBpbnN0LmRyYXdZZWFyICsgKHBlcmlvZCA9PT0gXCJZXCIgPyBvZmZzZXQgOiAwKSxcblx0XHRcdG1vbnRoID0gaW5zdC5kcmF3TW9udGggKyAocGVyaW9kID09PSBcIk1cIiA/IG9mZnNldCA6IDApLFxuXHRcdFx0ZGF5ID0gTWF0aC5taW4oaW5zdC5zZWxlY3RlZERheSwgdGhpcy5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpKSArIChwZXJpb2QgPT09IFwiRFwiID8gb2Zmc2V0IDogMCksXG5cdFx0XHRkYXRlID0gdGhpcy5fcmVzdHJpY3RNaW5NYXgoaW5zdCwgdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoeWVhciwgbW9udGgsIGRheSkpKTtcblxuXHRcdGluc3Quc2VsZWN0ZWREYXkgPSBkYXRlLmdldERhdGUoKTtcblx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcblx0XHRpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0aWYgKHBlcmlvZCA9PT0gXCJNXCIgfHwgcGVyaW9kID09PSBcIllcIikge1xuXHRcdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBFbnN1cmUgYSBkYXRlIGlzIHdpdGhpbiBhbnkgbWluL21heCBib3VuZHMuICovXG5cdF9yZXN0cmljdE1pbk1heDogZnVuY3Rpb24oaW5zdCwgZGF0ZSkge1xuXHRcdHZhciBtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1pblwiKSxcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWF4XCIpLFxuXHRcdFx0bmV3RGF0ZSA9IChtaW5EYXRlICYmIGRhdGUgPCBtaW5EYXRlID8gbWluRGF0ZSA6IGRhdGUpO1xuXHRcdHJldHVybiAobWF4RGF0ZSAmJiBuZXdEYXRlID4gbWF4RGF0ZSA/IG1heERhdGUgOiBuZXdEYXRlKTtcblx0fSxcblxuXHQvKiBOb3RpZnkgY2hhbmdlIG9mIG1vbnRoL3llYXIuICovXG5cdF9ub3RpZnlDaGFuZ2U6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgb25DaGFuZ2UgPSB0aGlzLl9nZXQoaW5zdCwgXCJvbkNoYW5nZU1vbnRoWWVhclwiKTtcblx0XHRpZiAob25DaGFuZ2UpIHtcblx0XHRcdG9uQ2hhbmdlLmFwcGx5KChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwpLFxuXHRcdFx0XHRbaW5zdC5zZWxlY3RlZFllYXIsIGluc3Quc2VsZWN0ZWRNb250aCArIDEsIGluc3RdKTtcblx0XHR9XG5cdH0sXG5cblx0LyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgbW9udGhzIHRvIHNob3cuICovXG5cdF9nZXROdW1iZXJPZk1vbnRoczogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBudW1Nb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgXCJudW1iZXJPZk1vbnRoc1wiKTtcblx0XHRyZXR1cm4gKG51bU1vbnRocyA9PSBudWxsID8gWzEsIDFdIDogKHR5cGVvZiBudW1Nb250aHMgPT09IFwibnVtYmVyXCIgPyBbMSwgbnVtTW9udGhzXSA6IG51bU1vbnRocykpO1xuXHR9LFxuXG5cdC8qIERldGVybWluZSB0aGUgY3VycmVudCBtYXhpbXVtIGRhdGUgLSBlbnN1cmUgbm8gdGltZSBjb21wb25lbnRzIGFyZSBzZXQuICovXG5cdF9nZXRNaW5NYXhEYXRlOiBmdW5jdGlvbihpbnN0LCBtaW5NYXgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGV0ZXJtaW5lRGF0ZShpbnN0LCB0aGlzLl9nZXQoaW5zdCwgbWluTWF4ICsgXCJEYXRlXCIpLCBudWxsKTtcblx0fSxcblxuXHQvKiBGaW5kIHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIGdpdmVuIG1vbnRoLiAqL1xuXHRfZ2V0RGF5c0luTW9udGg6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG5cdFx0cmV0dXJuIDMyIC0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoeWVhciwgbW9udGgsIDMyKSkuZ2V0RGF0ZSgpO1xuXHR9LFxuXG5cdC8qIEZpbmQgdGhlIGRheSBvZiB0aGUgd2VlayBvZiB0aGUgZmlyc3Qgb2YgYSBtb250aC4gKi9cblx0X2dldEZpcnN0RGF5T2ZNb250aDogZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcblx0XHRyZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpLmdldERheSgpO1xuXHR9LFxuXG5cdC8qIERldGVybWluZXMgaWYgd2Ugc2hvdWxkIGFsbG93IGEgXCJuZXh0L3ByZXZcIiBtb250aCBkaXNwbGF5IGNoYW5nZS4gKi9cblx0X2NhbkFkanVzdE1vbnRoOiBmdW5jdGlvbihpbnN0LCBvZmZzZXQsIGN1clllYXIsIGN1ck1vbnRoKSB7XG5cdFx0dmFyIG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKGluc3QpLFxuXHRcdFx0ZGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGN1clllYXIsXG5cdFx0XHRjdXJNb250aCArIChvZmZzZXQgPCAwID8gb2Zmc2V0IDogbnVtTW9udGhzWzBdICogbnVtTW9udGhzWzFdKSwgMSkpO1xuXG5cdFx0aWYgKG9mZnNldCA8IDApIHtcblx0XHRcdGRhdGUuc2V0RGF0ZSh0aGlzLl9nZXREYXlzSW5Nb250aChkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5faXNJblJhbmdlKGluc3QsIGRhdGUpO1xuXHR9LFxuXG5cdC8qIElzIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBhY2NlcHRlZCByYW5nZT8gKi9cblx0X2lzSW5SYW5nZTogZnVuY3Rpb24oaW5zdCwgZGF0ZSkge1xuXHRcdHZhciB5ZWFyU3BsaXQsIGN1cnJlbnRZZWFyLFxuXHRcdFx0bWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXCJtaW5cIiksXG5cdFx0XHRtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1heFwiKSxcblx0XHRcdG1pblllYXIgPSBudWxsLFxuXHRcdFx0bWF4WWVhciA9IG51bGwsXG5cdFx0XHR5ZWFycyA9IHRoaXMuX2dldChpbnN0LCBcInllYXJSYW5nZVwiKTtcblx0XHRcdGlmICh5ZWFycyl7XG5cdFx0XHRcdHllYXJTcGxpdCA9IHllYXJzLnNwbGl0KFwiOlwiKTtcblx0XHRcdFx0Y3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdG1pblllYXIgPSBwYXJzZUludCh5ZWFyU3BsaXRbMF0sIDEwKTtcblx0XHRcdFx0bWF4WWVhciA9IHBhcnNlSW50KHllYXJTcGxpdFsxXSwgMTApO1xuXHRcdFx0XHRpZiAoIHllYXJTcGxpdFswXS5tYXRjaCgvWytcXC1dLiovKSApIHtcblx0XHRcdFx0XHRtaW5ZZWFyICs9IGN1cnJlbnRZZWFyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggeWVhclNwbGl0WzFdLm1hdGNoKC9bK1xcLV0uKi8pICkge1xuXHRcdFx0XHRcdG1heFllYXIgKz0gY3VycmVudFllYXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdHJldHVybiAoKCFtaW5EYXRlIHx8IGRhdGUuZ2V0VGltZSgpID49IG1pbkRhdGUuZ2V0VGltZSgpKSAmJlxuXHRcdFx0KCFtYXhEYXRlIHx8IGRhdGUuZ2V0VGltZSgpIDw9IG1heERhdGUuZ2V0VGltZSgpKSAmJlxuXHRcdFx0KCFtaW5ZZWFyIHx8IGRhdGUuZ2V0RnVsbFllYXIoKSA+PSBtaW5ZZWFyKSAmJlxuXHRcdFx0KCFtYXhZZWFyIHx8IGRhdGUuZ2V0RnVsbFllYXIoKSA8PSBtYXhZZWFyKSk7XG5cdH0sXG5cblx0LyogUHJvdmlkZSB0aGUgY29uZmlndXJhdGlvbiBzZXR0aW5ncyBmb3IgZm9ybWF0dGluZy9wYXJzaW5nLiAqL1xuXHRfZ2V0Rm9ybWF0Q29uZmlnOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIHNob3J0WWVhckN1dG9mZiA9IHRoaXMuX2dldChpbnN0LCBcInNob3J0WWVhckN1dG9mZlwiKTtcblx0XHRzaG9ydFllYXJDdXRvZmYgPSAodHlwZW9mIHNob3J0WWVhckN1dG9mZiAhPT0gXCJzdHJpbmdcIiA/IHNob3J0WWVhckN1dG9mZiA6XG5cdFx0XHRuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgKyBwYXJzZUludChzaG9ydFllYXJDdXRvZmYsIDEwKSk7XG5cdFx0cmV0dXJuIHtzaG9ydFllYXJDdXRvZmY6IHNob3J0WWVhckN1dG9mZixcblx0XHRcdGRheU5hbWVzU2hvcnQ6IHRoaXMuX2dldChpbnN0LCBcImRheU5hbWVzU2hvcnRcIiksIGRheU5hbWVzOiB0aGlzLl9nZXQoaW5zdCwgXCJkYXlOYW1lc1wiKSxcblx0XHRcdG1vbnRoTmFtZXNTaG9ydDogdGhpcy5fZ2V0KGluc3QsIFwibW9udGhOYW1lc1Nob3J0XCIpLCBtb250aE5hbWVzOiB0aGlzLl9nZXQoaW5zdCwgXCJtb250aE5hbWVzXCIpfTtcblx0fSxcblxuXHQvKiBGb3JtYXQgdGhlIGdpdmVuIGRhdGUgZm9yIGRpc3BsYXkuICovXG5cdF9mb3JtYXREYXRlOiBmdW5jdGlvbihpbnN0LCBkYXksIG1vbnRoLCB5ZWFyKSB7XG5cdFx0aWYgKCFkYXkpIHtcblx0XHRcdGluc3QuY3VycmVudERheSA9IGluc3Quc2VsZWN0ZWREYXk7XG5cdFx0XHRpbnN0LmN1cnJlbnRNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aDtcblx0XHRcdGluc3QuY3VycmVudFllYXIgPSBpbnN0LnNlbGVjdGVkWWVhcjtcblx0XHR9XG5cdFx0dmFyIGRhdGUgPSAoZGF5ID8gKHR5cGVvZiBkYXkgPT09IFwib2JqZWN0XCIgPyBkYXkgOlxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoeWVhciwgbW9udGgsIGRheSkpKSA6XG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShpbnN0LmN1cnJlbnRZZWFyLCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50RGF5KSkpO1xuXHRcdHJldHVybiB0aGlzLmZvcm1hdERhdGUodGhpcy5fZ2V0KGluc3QsIFwiZGF0ZUZvcm1hdFwiKSwgZGF0ZSwgdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcblx0fVxufSk7XG5cbi8qXG4gKiBCaW5kIGhvdmVyIGV2ZW50cyBmb3IgZGF0ZXBpY2tlciBlbGVtZW50cy5cbiAqIERvbmUgdmlhIGRlbGVnYXRlIHNvIHRoZSBiaW5kaW5nIG9ubHkgb2NjdXJzIG9uY2UgaW4gdGhlIGxpZmV0aW1lIG9mIHRoZSBwYXJlbnQgZGl2LlxuICogR2xvYmFsIGluc3RBY3RpdmUsIHNldCBieSBfdXBkYXRlRGF0ZXBpY2tlciBhbGxvd3MgdGhlIGhhbmRsZXJzIHRvIGZpbmQgdGhlaXIgd2F5IGJhY2sgdG8gdGhlIGFjdGl2ZSBwaWNrZXIuXG4gKi9cbmZ1bmN0aW9uIGJpbmRIb3ZlcihkcERpdikge1xuXHR2YXIgc2VsZWN0b3IgPSBcImJ1dHRvbiwgLnVpLWRhdGVwaWNrZXItcHJldiwgLnVpLWRhdGVwaWNrZXItbmV4dCwgLnVpLWRhdGVwaWNrZXItY2FsZW5kYXIgdGQgYVwiO1xuXHRyZXR1cm4gZHBEaXYuZGVsZWdhdGUoc2VsZWN0b3IsIFwibW91c2VvdXRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHQkKHRoaXMpLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtaG92ZXJcIik7XG5cdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcInVpLWRhdGVwaWNrZXItcHJldlwiKSAhPT0gLTEpIHtcblx0XHRcdFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLWRhdGVwaWNrZXItcHJldi1ob3ZlclwiKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmNsYXNzTmFtZS5pbmRleE9mKFwidWktZGF0ZXBpY2tlci1uZXh0XCIpICE9PSAtMSkge1xuXHRcdFx0XHQkKHRoaXMpLnJlbW92ZUNsYXNzKFwidWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyXCIpO1xuXHRcdFx0fVxuXHRcdH0pXG5cdFx0LmRlbGVnYXRlKHNlbGVjdG9yLCBcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKCEkLmRhdGVwaWNrZXIuX2lzRGlzYWJsZWREYXRlcGlja2VyKCBpbnN0QWN0aXZlLmlubGluZSA/IGRwRGl2LnBhcmVudCgpWzBdIDogaW5zdEFjdGl2ZS5pbnB1dFswXSkpIHtcblx0XHRcdFx0JCh0aGlzKS5wYXJlbnRzKFwiLnVpLWRhdGVwaWNrZXItY2FsZW5kYXJcIikuZmluZChcImFcIikucmVtb3ZlQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlclwiKTtcblx0XHRcdFx0JCh0aGlzKS5hZGRDbGFzcyhcInVpLXN0YXRlLWhvdmVyXCIpO1xuXHRcdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcInVpLWRhdGVwaWNrZXItcHJldlwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKFwidWktZGF0ZXBpY2tlci1wcmV2LWhvdmVyXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmNsYXNzTmFtZS5pbmRleE9mKFwidWktZGF0ZXBpY2tlci1uZXh0XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLW5leHQtaG92ZXJcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcbn1cblxuLyogalF1ZXJ5IGV4dGVuZCBub3cgaWdub3JlcyBudWxscyEgKi9cbmZ1bmN0aW9uIGV4dGVuZFJlbW92ZSh0YXJnZXQsIHByb3BzKSB7XG5cdCQuZXh0ZW5kKHRhcmdldCwgcHJvcHMpO1xuXHRmb3IgKHZhciBuYW1lIGluIHByb3BzKSB7XG5cdFx0aWYgKHByb3BzW25hbWVdID09IG51bGwpIHtcblx0XHRcdHRhcmdldFtuYW1lXSA9IHByb3BzW25hbWVdO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBJbnZva2UgdGhlIGRhdGVwaWNrZXIgZnVuY3Rpb25hbGl0eS5cbiAgIEBwYXJhbSAgb3B0aW9ucyAgc3RyaW5nIC0gYSBjb21tYW5kLCBvcHRpb25hbGx5IGZvbGxvd2VkIGJ5IGFkZGl0aW9uYWwgcGFyYW1ldGVycyBvclxuXHRcdFx0XHRcdE9iamVjdCAtIHNldHRpbmdzIGZvciBhdHRhY2hpbmcgbmV3IGRhdGVwaWNrZXIgZnVuY3Rpb25hbGl0eVxuICAgQHJldHVybiAgalF1ZXJ5IG9iamVjdCAqL1xuJC5mbi5kYXRlcGlja2VyID0gZnVuY3Rpb24ob3B0aW9ucyl7XG5cblx0LyogVmVyaWZ5IGFuIGVtcHR5IGNvbGxlY3Rpb24gd2Fzbid0IHBhc3NlZCAtIEZpeGVzICM2OTc2ICovXG5cdGlmICggIXRoaXMubGVuZ3RoICkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyogSW5pdGlhbGlzZSB0aGUgZGF0ZSBwaWNrZXIuICovXG5cdGlmICghJC5kYXRlcGlja2VyLmluaXRpYWxpemVkKSB7XG5cdFx0JChkb2N1bWVudCkubW91c2Vkb3duKCQuZGF0ZXBpY2tlci5fY2hlY2tFeHRlcm5hbENsaWNrKTtcblx0XHQkLmRhdGVwaWNrZXIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHR9XG5cblx0LyogQXBwZW5kIGRhdGVwaWNrZXIgbWFpbiBjb250YWluZXIgdG8gYm9keSBpZiBub3QgZXhpc3QuICovXG5cdGlmICgkKFwiI1wiKyQuZGF0ZXBpY2tlci5fbWFpbkRpdklkKS5sZW5ndGggPT09IDApIHtcblx0XHQkKFwiYm9keVwiKS5hcHBlbmQoJC5kYXRlcGlja2VyLmRwRGl2KTtcblx0fVxuXG5cdHZhciBvdGhlckFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgJiYgKG9wdGlvbnMgPT09IFwiaXNEaXNhYmxlZFwiIHx8IG9wdGlvbnMgPT09IFwiZ2V0RGF0ZVwiIHx8IG9wdGlvbnMgPT09IFwid2lkZ2V0XCIpKSB7XG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlcltcIl9cIiArIG9wdGlvbnMgKyBcIkRhdGVwaWNrZXJcIl0uXG5cdFx0XHRhcHBseSgkLmRhdGVwaWNrZXIsIFt0aGlzWzBdXS5jb25jYXQob3RoZXJBcmdzKSk7XG5cdH1cblx0aWYgKG9wdGlvbnMgPT09IFwib3B0aW9uXCIgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSBcInN0cmluZ1wiKSB7XG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlcltcIl9cIiArIG9wdGlvbnMgKyBcIkRhdGVwaWNrZXJcIl0uXG5cdFx0XHRhcHBseSgkLmRhdGVwaWNrZXIsIFt0aGlzWzBdXS5jb25jYXQob3RoZXJBcmdzKSk7XG5cdH1cblx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHR0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHQkLmRhdGVwaWNrZXJbXCJfXCIgKyBvcHRpb25zICsgXCJEYXRlcGlja2VyXCJdLlxuXHRcdFx0XHRhcHBseSgkLmRhdGVwaWNrZXIsIFt0aGlzXS5jb25jYXQob3RoZXJBcmdzKSkgOlxuXHRcdFx0JC5kYXRlcGlja2VyLl9hdHRhY2hEYXRlcGlja2VyKHRoaXMsIG9wdGlvbnMpO1xuXHR9KTtcbn07XG5cbiQuZGF0ZXBpY2tlciA9IG5ldyBEYXRlcGlja2VyKCk7IC8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuJC5kYXRlcGlja2VyLmluaXRpYWxpemVkID0gZmFsc2U7XG4kLmRhdGVwaWNrZXIudXVpZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuJC5kYXRlcGlja2VyLnZlcnNpb24gPSBcIjEuMTAuNFwiO1xuXG59KShqUXVlcnkpO1xuIiwidmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xucmVxdWlyZSgnLi9jb3JlJyk7XG5yZXF1aXJlKCcuL21vdXNlJyk7XG5yZXF1aXJlKCcuL3dpZGdldCcpO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBEcmFnZ2FibGUgMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2RyYWdnYWJsZS9cbiAqXG4gKiBEZXBlbmRzOlxuICpcdGpxdWVyeS51aS5jb3JlLmpzXG4gKlx0anF1ZXJ5LnVpLm1vdXNlLmpzXG4gKlx0anF1ZXJ5LnVpLndpZGdldC5qc1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoXCJ1aS5kcmFnZ2FibGVcIiwgJC51aS5tb3VzZSwge1xuXHR2ZXJzaW9uOiBcIjEuMTAuNFwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJkcmFnXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRhZGRDbGFzc2VzOiB0cnVlLFxuXHRcdGFwcGVuZFRvOiBcInBhcmVudFwiLFxuXHRcdGF4aXM6IGZhbHNlLFxuXHRcdGNvbm5lY3RUb1NvcnRhYmxlOiBmYWxzZSxcblx0XHRjb250YWlubWVudDogZmFsc2UsXG5cdFx0Y3Vyc29yOiBcImF1dG9cIixcblx0XHRjdXJzb3JBdDogZmFsc2UsXG5cdFx0Z3JpZDogZmFsc2UsXG5cdFx0aGFuZGxlOiBmYWxzZSxcblx0XHRoZWxwZXI6IFwib3JpZ2luYWxcIixcblx0XHRpZnJhbWVGaXg6IGZhbHNlLFxuXHRcdG9wYWNpdHk6IGZhbHNlLFxuXHRcdHJlZnJlc2hQb3NpdGlvbnM6IGZhbHNlLFxuXHRcdHJldmVydDogZmFsc2UsXG5cdFx0cmV2ZXJ0RHVyYXRpb246IDUwMCxcblx0XHRzY29wZTogXCJkZWZhdWx0XCIsXG5cdFx0c2Nyb2xsOiB0cnVlLFxuXHRcdHNjcm9sbFNlbnNpdGl2aXR5OiAyMCxcblx0XHRzY3JvbGxTcGVlZDogMjAsXG5cdFx0c25hcDogZmFsc2UsXG5cdFx0c25hcE1vZGU6IFwiYm90aFwiLFxuXHRcdHNuYXBUb2xlcmFuY2U6IDIwLFxuXHRcdHN0YWNrOiBmYWxzZSxcblx0XHR6SW5kZXg6IGZhbHNlLFxuXG5cdFx0Ly8gY2FsbGJhY2tzXG5cdFx0ZHJhZzogbnVsbCxcblx0XHRzdGFydDogbnVsbCxcblx0XHRzdG9wOiBudWxsXG5cdH0sXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5oZWxwZXIgPT09IFwib3JpZ2luYWxcIiAmJiAhKC9eKD86cnxhfGYpLykudGVzdCh0aGlzLmVsZW1lbnQuY3NzKFwicG9zaXRpb25cIikpKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnRbMF0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYWRkQ2xhc3Nlcyl7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1kcmFnZ2FibGVcIik7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQpe1xuXHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktZHJhZ2dhYmxlLWRpc2FibGVkXCIpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21vdXNlSW5pdCgpO1xuXG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyggXCJ1aS1kcmFnZ2FibGUgdWktZHJhZ2dhYmxlLWRyYWdnaW5nIHVpLWRyYWdnYWJsZS1kaXNhYmxlZFwiICk7XG5cdFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XG5cdH0sXG5cblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly8gYW1vbmcgb3RoZXJzLCBwcmV2ZW50IGEgZHJhZyBvbiBhIHJlc2l6YWJsZS1oYW5kbGVcblx0XHRpZiAodGhpcy5oZWxwZXIgfHwgby5kaXNhYmxlZCB8fCAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChcIi51aS1yZXNpemFibGUtaGFuZGxlXCIpLmxlbmd0aCA+IDApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvL1F1aXQgaWYgd2UncmUgbm90IG9uIGEgdmFsaWQgaGFuZGxlXG5cdFx0dGhpcy5oYW5kbGUgPSB0aGlzLl9nZXRIYW5kbGUoZXZlbnQpO1xuXHRcdGlmICghdGhpcy5oYW5kbGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQkKG8uaWZyYW1lRml4ID09PSB0cnVlID8gXCJpZnJhbWVcIiA6IG8uaWZyYW1lRml4KS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0JChcIjxkaXYgY2xhc3M9J3VpLWRyYWdnYWJsZS1pZnJhbWVGaXgnIHN0eWxlPSdiYWNrZ3JvdW5kOiAjZmZmOyc+PC9kaXY+XCIpXG5cdFx0XHQuY3NzKHtcblx0XHRcdFx0d2lkdGg6IHRoaXMub2Zmc2V0V2lkdGgrXCJweFwiLCBoZWlnaHQ6IHRoaXMub2Zmc2V0SGVpZ2h0K1wicHhcIixcblx0XHRcdFx0cG9zaXRpb246IFwiYWJzb2x1dGVcIiwgb3BhY2l0eTogXCIwLjAwMVwiLCB6SW5kZXg6IDEwMDBcblx0XHRcdH0pXG5cdFx0XHQuY3NzKCQodGhpcykub2Zmc2V0KCkpXG5cdFx0XHQuYXBwZW5kVG8oXCJib2R5XCIpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fSxcblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly9DcmVhdGUgYW5kIGFwcGVuZCB0aGUgdmlzaWJsZSBoZWxwZXJcblx0XHR0aGlzLmhlbHBlciA9IHRoaXMuX2NyZWF0ZUhlbHBlcihldmVudCk7XG5cblx0XHR0aGlzLmhlbHBlci5hZGRDbGFzcyhcInVpLWRyYWdnYWJsZS1kcmFnZ2luZ1wiKTtcblxuXHRcdC8vQ2FjaGUgdGhlIGhlbHBlciBzaXplXG5cdFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xuXG5cdFx0Ly9JZiBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgc2V0IHRoZSBnbG9iYWwgZHJhZ2dhYmxlXG5cdFx0aWYoJC51aS5kZG1hbmFnZXIpIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmN1cnJlbnQgPSB0aGlzO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0ICogLSBQb3NpdGlvbiBnZW5lcmF0aW9uIC1cblx0XHQgKiBUaGlzIGJsb2NrIGdlbmVyYXRlcyBldmVyeXRoaW5nIHBvc2l0aW9uIHJlbGF0ZWQgLSBpdCdzIHRoZSBjb3JlIG9mIGRyYWdnYWJsZXMuXG5cdFx0ICovXG5cblx0XHQvL0NhY2hlIHRoZSBtYXJnaW5zIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50XG5cdFx0dGhpcy5fY2FjaGVNYXJnaW5zKCk7XG5cblx0XHQvL1N0b3JlIHRoZSBoZWxwZXIncyBjc3MgcG9zaXRpb25cblx0XHR0aGlzLmNzc1Bvc2l0aW9uID0gdGhpcy5oZWxwZXIuY3NzKCBcInBvc2l0aW9uXCIgKTtcblx0XHR0aGlzLnNjcm9sbFBhcmVudCA9IHRoaXMuaGVscGVyLnNjcm9sbFBhcmVudCgpO1xuXHRcdHRoaXMub2Zmc2V0UGFyZW50ID0gdGhpcy5oZWxwZXIub2Zmc2V0UGFyZW50KCk7XG5cdFx0dGhpcy5vZmZzZXRQYXJlbnRDc3NQb3NpdGlvbiA9IHRoaXMub2Zmc2V0UGFyZW50LmNzcyggXCJwb3NpdGlvblwiICk7XG5cblx0XHQvL1RoZSBlbGVtZW50J3MgYWJzb2x1dGUgcG9zaXRpb24gb24gdGhlIHBhZ2UgbWludXMgbWFyZ2luc1xuXHRcdHRoaXMub2Zmc2V0ID0gdGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcblx0XHR0aGlzLm9mZnNldCA9IHtcblx0XHRcdHRvcDogdGhpcy5vZmZzZXQudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCxcblx0XHRcdGxlZnQ6IHRoaXMub2Zmc2V0LmxlZnQgLSB0aGlzLm1hcmdpbnMubGVmdFxuXHRcdH07XG5cblx0XHQvL1Jlc2V0IHNjcm9sbCBjYWNoZVxuXHRcdHRoaXMub2Zmc2V0LnNjcm9sbCA9IGZhbHNlO1xuXG5cdFx0JC5leHRlbmQodGhpcy5vZmZzZXQsIHtcblx0XHRcdGNsaWNrOiB7IC8vV2hlcmUgdGhlIGNsaWNrIGhhcHBlbmVkLCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudFxuXHRcdFx0XHRsZWZ0OiBldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdHRvcDogZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC50b3Bcblx0XHRcdH0sXG5cdFx0XHRwYXJlbnQ6IHRoaXMuX2dldFBhcmVudE9mZnNldCgpLFxuXHRcdFx0cmVsYXRpdmU6IHRoaXMuX2dldFJlbGF0aXZlT2Zmc2V0KCkgLy9UaGlzIGlzIGEgcmVsYXRpdmUgdG8gYWJzb2x1dGUgcG9zaXRpb24gbWludXMgdGhlIGFjdHVhbCBwb3NpdGlvbiBjYWxjdWxhdGlvbiAtIG9ubHkgdXNlZCBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBoZWxwZXJcblx0XHR9KTtcblxuXHRcdC8vR2VuZXJhdGUgdGhlIG9yaWdpbmFsIHBvc2l0aW9uXG5cdFx0dGhpcy5vcmlnaW5hbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpO1xuXHRcdHRoaXMub3JpZ2luYWxQYWdlWCA9IGV2ZW50LnBhZ2VYO1xuXHRcdHRoaXMub3JpZ2luYWxQYWdlWSA9IGV2ZW50LnBhZ2VZO1xuXG5cdFx0Ly9BZGp1c3QgdGhlIG1vdXNlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgaGVscGVyIGlmIFwiY3Vyc29yQXRcIiBpcyBzdXBwbGllZFxuXHRcdChvLmN1cnNvckF0ICYmIHRoaXMuX2FkanVzdE9mZnNldEZyb21IZWxwZXIoby5jdXJzb3JBdCkpO1xuXG5cdFx0Ly9TZXQgYSBjb250YWlubWVudCBpZiBnaXZlbiBpbiB0aGUgb3B0aW9uc1xuXHRcdHRoaXMuX3NldENvbnRhaW5tZW50KCk7XG5cblx0XHQvL1RyaWdnZXIgZXZlbnQgKyBjYWxsYmFja3Ncblx0XHRpZih0aGlzLl90cmlnZ2VyKFwic3RhcnRcIiwgZXZlbnQpID09PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5fY2xlYXIoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvL1JlY2FjaGUgdGhlIGhlbHBlciBzaXplXG5cdFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xuXG5cdFx0Ly9QcmVwYXJlIHRoZSBkcm9wcGFibGUgb2Zmc2V0c1xuXHRcdGlmICgkLnVpLmRkbWFuYWdlciAmJiAhby5kcm9wQmVoYXZpb3VyKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyh0aGlzLCBldmVudCk7XG5cdFx0fVxuXG5cblx0XHR0aGlzLl9tb3VzZURyYWcoZXZlbnQsIHRydWUpOyAvL0V4ZWN1dGUgdGhlIGRyYWcgb25jZSAtIHRoaXMgY2F1c2VzIHRoZSBoZWxwZXIgbm90IHRvIGJlIHZpc2libGUgYmVmb3JlIGdldHRpbmcgaXRzIGNvcnJlY3QgcG9zaXRpb25cblxuXHRcdC8vSWYgdGhlIGRkbWFuYWdlciBpcyB1c2VkIGZvciBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgdGhhdCBkcmFnZ2luZyBoYXMgc3RhcnRlZCAoc2VlICM1MDAzKVxuXHRcdGlmICggJC51aS5kZG1hbmFnZXIgKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5kcmFnU3RhcnQodGhpcywgZXZlbnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKGV2ZW50LCBub1Byb3BhZ2F0aW9uKSB7XG5cdFx0Ly8gcmVzZXQgYW55IG5lY2Vzc2FyeSBjYWNoZWQgcHJvcGVydGllcyAoc2VlICM1MDA5KVxuXHRcdGlmICggdGhpcy5vZmZzZXRQYXJlbnRDc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0dGhpcy5vZmZzZXQucGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50T2Zmc2V0KCk7XG5cdFx0fVxuXG5cdFx0Ly9Db21wdXRlIHRoZSBoZWxwZXJzIHBvc2l0aW9uXG5cdFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpO1xuXHRcdHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLl9jb252ZXJ0UG9zaXRpb25UbyhcImFic29sdXRlXCIpO1xuXG5cdFx0Ly9DYWxsIHBsdWdpbnMgYW5kIGNhbGxiYWNrcyBhbmQgdXNlIHRoZSByZXN1bHRpbmcgcG9zaXRpb24gaWYgc29tZXRoaW5nIGlzIHJldHVybmVkXG5cdFx0aWYgKCFub1Byb3BhZ2F0aW9uKSB7XG5cdFx0XHR2YXIgdWkgPSB0aGlzLl91aUhhc2goKTtcblx0XHRcdGlmKHRoaXMuX3RyaWdnZXIoXCJkcmFnXCIsIGV2ZW50LCB1aSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX21vdXNlVXAoe30pO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBvc2l0aW9uID0gdWkucG9zaXRpb247XG5cdFx0fVxuXG5cdFx0aWYoIXRoaXMub3B0aW9ucy5heGlzIHx8IHRoaXMub3B0aW9ucy5heGlzICE9PSBcInlcIikge1xuXHRcdFx0dGhpcy5oZWxwZXJbMF0uc3R5bGUubGVmdCA9IHRoaXMucG9zaXRpb24ubGVmdCtcInB4XCI7XG5cdFx0fVxuXHRcdGlmKCF0aGlzLm9wdGlvbnMuYXhpcyB8fCB0aGlzLm9wdGlvbnMuYXhpcyAhPT0gXCJ4XCIpIHtcblx0XHRcdHRoaXMuaGVscGVyWzBdLnN0eWxlLnRvcCA9IHRoaXMucG9zaXRpb24udG9wK1wicHhcIjtcblx0XHR9XG5cdFx0aWYoJC51aS5kZG1hbmFnZXIpIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmRyYWcodGhpcywgZXZlbnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VTdG9wOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly9JZiB3ZSBhcmUgdXNpbmcgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIGFib3V0IHRoZSBkcm9wXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0ZHJvcHBlZCA9IGZhbHNlO1xuXHRcdGlmICgkLnVpLmRkbWFuYWdlciAmJiAhdGhpcy5vcHRpb25zLmRyb3BCZWhhdmlvdXIpIHtcblx0XHRcdGRyb3BwZWQgPSAkLnVpLmRkbWFuYWdlci5kcm9wKHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHQvL2lmIGEgZHJvcCBjb21lcyBmcm9tIG91dHNpZGUgKGEgc29ydGFibGUpXG5cdFx0aWYodGhpcy5kcm9wcGVkKSB7XG5cdFx0XHRkcm9wcGVkID0gdGhpcy5kcm9wcGVkO1xuXHRcdFx0dGhpcy5kcm9wcGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9pZiB0aGUgb3JpZ2luYWwgZWxlbWVudCBpcyBubyBsb25nZXIgaW4gdGhlIERPTSBkb24ndCBib3RoZXIgdG8gY29udGludWUgKHNlZSAjODI2OSlcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5oZWxwZXIgPT09IFwib3JpZ2luYWxcIiAmJiAhJC5jb250YWlucyggdGhpcy5lbGVtZW50WyAwIF0ub3duZXJEb2N1bWVudCwgdGhpcy5lbGVtZW50WyAwIF0gKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZigodGhpcy5vcHRpb25zLnJldmVydCA9PT0gXCJpbnZhbGlkXCIgJiYgIWRyb3BwZWQpIHx8ICh0aGlzLm9wdGlvbnMucmV2ZXJ0ID09PSBcInZhbGlkXCIgJiYgZHJvcHBlZCkgfHwgdGhpcy5vcHRpb25zLnJldmVydCA9PT0gdHJ1ZSB8fCAoJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5yZXZlcnQpICYmIHRoaXMub3B0aW9ucy5yZXZlcnQuY2FsbCh0aGlzLmVsZW1lbnQsIGRyb3BwZWQpKSkge1xuXHRcdFx0JCh0aGlzLmhlbHBlcikuYW5pbWF0ZSh0aGlzLm9yaWdpbmFsUG9zaXRpb24sIHBhcnNlSW50KHRoaXMub3B0aW9ucy5yZXZlcnREdXJhdGlvbiwgMTApLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYodGhhdC5fdHJpZ2dlcihcInN0b3BcIiwgZXZlbnQpICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHRoYXQuX2NsZWFyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZih0aGlzLl90cmlnZ2VyKFwic3RvcFwiLCBldmVudCkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX2NsZWFyKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZVVwOiBmdW5jdGlvbihldmVudCkge1xuXHRcdC8vUmVtb3ZlIGZyYW1lIGhlbHBlcnNcblx0XHQkKFwiZGl2LnVpLWRyYWdnYWJsZS1pZnJhbWVGaXhcIikuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcblx0XHR9KTtcblxuXHRcdC8vSWYgdGhlIGRkbWFuYWdlciBpcyB1c2VkIGZvciBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgdGhhdCBkcmFnZ2luZyBoYXMgc3RvcHBlZCAoc2VlICM1MDAzKVxuXHRcdGlmKCAkLnVpLmRkbWFuYWdlciApIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmRyYWdTdG9wKHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJC51aS5tb3VzZS5wcm90b3R5cGUuX21vdXNlVXAuY2FsbCh0aGlzLCBldmVudCk7XG5cdH0sXG5cblx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblxuXHRcdGlmKHRoaXMuaGVscGVyLmlzKFwiLnVpLWRyYWdnYWJsZS1kcmFnZ2luZ1wiKSkge1xuXHRcdFx0dGhpcy5fbW91c2VVcCh7fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2NsZWFyKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRfZ2V0SGFuZGxlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaGFuZGxlID9cblx0XHRcdCEhJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggdGhpcy5lbGVtZW50LmZpbmQoIHRoaXMub3B0aW9ucy5oYW5kbGUgKSApLmxlbmd0aCA6XG5cdFx0XHR0cnVlO1xuXHR9LFxuXG5cdF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGhlbHBlciA9ICQuaXNGdW5jdGlvbihvLmhlbHBlcikgPyAkKG8uaGVscGVyLmFwcGx5KHRoaXMuZWxlbWVudFswXSwgW2V2ZW50XSkpIDogKG8uaGVscGVyID09PSBcImNsb25lXCIgPyB0aGlzLmVsZW1lbnQuY2xvbmUoKS5yZW1vdmVBdHRyKFwiaWRcIikgOiB0aGlzLmVsZW1lbnQpO1xuXG5cdFx0aWYoIWhlbHBlci5wYXJlbnRzKFwiYm9keVwiKS5sZW5ndGgpIHtcblx0XHRcdGhlbHBlci5hcHBlbmRUbygoby5hcHBlbmRUbyA9PT0gXCJwYXJlbnRcIiA/IHRoaXMuZWxlbWVudFswXS5wYXJlbnROb2RlIDogby5hcHBlbmRUbykpO1xuXHRcdH1cblxuXHRcdGlmKGhlbHBlclswXSAhPT0gdGhpcy5lbGVtZW50WzBdICYmICEoLyhmaXhlZHxhYnNvbHV0ZSkvKS50ZXN0KGhlbHBlci5jc3MoXCJwb3NpdGlvblwiKSkpIHtcblx0XHRcdGhlbHBlci5jc3MoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBoZWxwZXI7XG5cblx0fSxcblxuXHRfYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0aWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdG9iaiA9IG9iai5zcGxpdChcIiBcIik7XG5cdFx0fVxuXHRcdGlmICgkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0b2JqID0ge2xlZnQ6ICtvYmpbMF0sIHRvcDogK29ialsxXSB8fCAwfTtcblx0XHR9XG5cdFx0aWYgKFwibGVmdFwiIGluIG9iaikge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCA9IG9iai5sZWZ0ICsgdGhpcy5tYXJnaW5zLmxlZnQ7XG5cdFx0fVxuXHRcdGlmIChcInJpZ2h0XCIgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIG9iai5yaWdodCArIHRoaXMubWFyZ2lucy5sZWZ0O1xuXHRcdH1cblx0XHRpZiAoXCJ0b3BcIiBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IG9iai50b3AgKyB0aGlzLm1hcmdpbnMudG9wO1xuXHRcdH1cblx0XHRpZiAoXCJib3R0b21cIiBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gb2JqLmJvdHRvbSArIHRoaXMubWFyZ2lucy50b3A7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRQYXJlbnRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly9HZXQgdGhlIG9mZnNldFBhcmVudCBhbmQgY2FjaGUgaXRzIHBvc2l0aW9uXG5cdFx0dmFyIHBvID0gdGhpcy5vZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cblx0XHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gbW9kaWZ5IGEgb2Zmc2V0IGNhbGN1bGF0ZWQgb24gc3RhcnQsIHNpbmNlIHRoZSBmb2xsb3dpbmcgaGFwcGVuZWQ6XG5cdFx0Ly8gMS4gVGhlIHBvc2l0aW9uIG9mIHRoZSBoZWxwZXIgaXMgYWJzb2x1dGUsIHNvIGl0J3MgcG9zaXRpb24gaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgbmV4dCBwb3NpdGlvbmVkIHBhcmVudFxuXHRcdC8vIDIuIFRoZSBhY3R1YWwgb2Zmc2V0IHBhcmVudCBpcyBhIGNoaWxkIG9mIHRoZSBzY3JvbGwgcGFyZW50LCBhbmQgdGhlIHNjcm9sbCBwYXJlbnQgaXNuJ3QgdGhlIGRvY3VtZW50LCB3aGljaCBtZWFucyB0aGF0XG5cdFx0Ly8gICAgdGhlIHNjcm9sbCBpcyBpbmNsdWRlZCBpbiB0aGUgaW5pdGlhbCBjYWxjdWxhdGlvbiBvZiB0aGUgb2Zmc2V0IG9mIHRoZSBwYXJlbnQsIGFuZCBuZXZlciByZWNhbGN1bGF0ZWQgdXBvbiBkcmFnXG5cdFx0aWYodGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSBkb2N1bWVudCAmJiAkLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLCB0aGlzLm9mZnNldFBhcmVudFswXSkpIHtcblx0XHRcdHBvLmxlZnQgKz0gdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpO1xuXHRcdFx0cG8udG9wICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpO1xuXHRcdH1cblxuXHRcdC8vVGhpcyBuZWVkcyB0byBiZSBhY3R1YWxseSBkb25lIGZvciBhbGwgYnJvd3NlcnMsIHNpbmNlIHBhZ2VYL3BhZ2VZIGluY2x1ZGVzIHRoaXMgaW5mb3JtYXRpb25cblx0XHQvL1VnbHkgSUUgZml4XG5cdFx0aWYoKHRoaXMub2Zmc2V0UGFyZW50WzBdID09PSBkb2N1bWVudC5ib2R5KSB8fFxuXHRcdFx0KHRoaXMub2Zmc2V0UGFyZW50WzBdLnRhZ05hbWUgJiYgdGhpcy5vZmZzZXRQYXJlbnRbMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImh0bWxcIiAmJiAkLnVpLmllKSkge1xuXHRcdFx0cG8gPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHBvLnRvcCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwxMCkgfHwgMCksXG5cdFx0XHRsZWZ0OiBwby5sZWZ0ICsgKHBhcnNlSW50KHRoaXMub2Zmc2V0UGFyZW50LmNzcyhcImJvcmRlckxlZnRXaWR0aFwiKSwxMCkgfHwgMClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2dldFJlbGF0aXZlT2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdGlmKHRoaXMuY3NzUG9zaXRpb24gPT09IFwicmVsYXRpdmVcIikge1xuXHRcdFx0dmFyIHAgPSB0aGlzLmVsZW1lbnQucG9zaXRpb24oKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogcC50b3AgLSAocGFyc2VJbnQodGhpcy5oZWxwZXIuY3NzKFwidG9wXCIpLDEwKSB8fCAwKSArIHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0XHRsZWZ0OiBwLmxlZnQgLSAocGFyc2VJbnQodGhpcy5oZWxwZXIuY3NzKFwibGVmdFwiKSwxMCkgfHwgMCkgKyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KClcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHR9LFxuXG5cdF9jYWNoZU1hcmdpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubWFyZ2lucyA9IHtcblx0XHRcdGxlZnQ6IChwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFwibWFyZ2luTGVmdFwiKSwxMCkgfHwgMCksXG5cdFx0XHR0b3A6IChwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFwibWFyZ2luVG9wXCIpLDEwKSB8fCAwKSxcblx0XHRcdHJpZ2h0OiAocGFyc2VJbnQodGhpcy5lbGVtZW50LmNzcyhcIm1hcmdpblJpZ2h0XCIpLDEwKSB8fCAwKSxcblx0XHRcdGJvdHRvbTogKHBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXCJtYXJnaW5Cb3R0b21cIiksMTApIHx8IDApXG5cdFx0fTtcblx0fSxcblxuXHRfY2FjaGVIZWxwZXJQcm9wb3J0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oZWxwZXJQcm9wb3J0aW9ucyA9IHtcblx0XHRcdHdpZHRoOiB0aGlzLmhlbHBlci5vdXRlcldpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IHRoaXMuaGVscGVyLm91dGVySGVpZ2h0KClcblx0XHR9O1xuXHR9LFxuXG5cdF9zZXRDb250YWlubWVudDogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgb3ZlciwgYywgY2UsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCAhby5jb250YWlubWVudCApIHtcblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggby5jb250YWlubWVudCA9PT0gXCJ3aW5kb3dcIiApIHtcblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHRcdCQoIHdpbmRvdyApLnNjcm9sbExlZnQoKSAtIHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgLSB0aGlzLm9mZnNldC5wYXJlbnQubGVmdCxcblx0XHRcdFx0JCggd2luZG93ICkuc2Nyb2xsVG9wKCkgLSB0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgLSB0aGlzLm9mZnNldC5wYXJlbnQudG9wLFxuXHRcdFx0XHQkKCB3aW5kb3cgKS5zY3JvbGxMZWZ0KCkgKyAkKCB3aW5kb3cgKS53aWR0aCgpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0XHQkKCB3aW5kb3cgKS5zY3JvbGxUb3AoKSArICggJCggd2luZG93ICkuaGVpZ2h0KCkgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbEhlaWdodCApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XHRdO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggby5jb250YWlubWVudCA9PT0gXCJkb2N1bWVudFwiKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0XHQwLFxuXHRcdFx0XHQwLFxuXHRcdFx0XHQkKCBkb2N1bWVudCApLndpZHRoKCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gdGhpcy5tYXJnaW5zLmxlZnQsXG5cdFx0XHRcdCggJCggZG9jdW1lbnQgKS5oZWlnaHQoKSB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0ICkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIHRoaXMubWFyZ2lucy50b3Bcblx0XHRcdF07XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBvLmNvbnRhaW5tZW50LmNvbnN0cnVjdG9yID09PSBBcnJheSApIHtcblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBvLmNvbnRhaW5tZW50O1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggby5jb250YWlubWVudCA9PT0gXCJwYXJlbnRcIiApIHtcblx0XHRcdG8uY29udGFpbm1lbnQgPSB0aGlzLmhlbHBlclsgMCBdLnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0YyA9ICQoIG8uY29udGFpbm1lbnQgKTtcblx0XHRjZSA9IGNbIDAgXTtcblxuXHRcdGlmKCAhY2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0b3ZlciA9IGMuY3NzKCBcIm92ZXJmbG93XCIgKSAhPT0gXCJoaWRkZW5cIjtcblxuXHRcdHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHQoIHBhcnNlSW50KCBjLmNzcyggXCJib3JkZXJMZWZ0V2lkdGhcIiApLCAxMCApIHx8IDAgKSArICggcGFyc2VJbnQoIGMuY3NzKCBcInBhZGRpbmdMZWZ0XCIgKSwgMTAgKSB8fCAwICksXG5cdFx0XHQoIHBhcnNlSW50KCBjLmNzcyggXCJib3JkZXJUb3BXaWR0aFwiICksIDEwICkgfHwgMCApICsgKCBwYXJzZUludCggYy5jc3MoIFwicGFkZGluZ1RvcFwiICksIDEwICkgfHwgMCApICxcblx0XHRcdCggb3ZlciA/IE1hdGgubWF4KCBjZS5zY3JvbGxXaWR0aCwgY2Uub2Zmc2V0V2lkdGggKSA6IGNlLm9mZnNldFdpZHRoICkgLSAoIHBhcnNlSW50KCBjLmNzcyggXCJib3JkZXJSaWdodFdpZHRoXCIgKSwgMTAgKSB8fCAwICkgLSAoIHBhcnNlSW50KCBjLmNzcyggXCJwYWRkaW5nUmlnaHRcIiApLCAxMCApIHx8IDAgKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCAtIHRoaXMubWFyZ2lucy5yaWdodCxcblx0XHRcdCggb3ZlciA/IE1hdGgubWF4KCBjZS5zY3JvbGxIZWlnaHQsIGNlLm9mZnNldEhlaWdodCApIDogY2Uub2Zmc2V0SGVpZ2h0ICkgLSAoIHBhcnNlSW50KCBjLmNzcyggXCJib3JkZXJCb3R0b21XaWR0aFwiICksIDEwICkgfHwgMCApIC0gKCBwYXJzZUludCggYy5jc3MoIFwicGFkZGluZ0JvdHRvbVwiICksIDEwICkgfHwgMCApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wICAtIHRoaXMubWFyZ2lucy5ib3R0b21cblx0XHRdO1xuXHRcdHRoaXMucmVsYXRpdmVfY29udGFpbmVyID0gYztcblx0fSxcblxuXHRfY29udmVydFBvc2l0aW9uVG86IGZ1bmN0aW9uKGQsIHBvcykge1xuXG5cdFx0aWYoIXBvcykge1xuXHRcdFx0cG9zID0gdGhpcy5wb3NpdGlvbjtcblx0XHR9XG5cblx0XHR2YXIgbW9kID0gZCA9PT0gXCJhYnNvbHV0ZVwiID8gMSA6IC0xLFxuXHRcdFx0c2Nyb2xsID0gdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiICYmICEoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0gIT09IGRvY3VtZW50ICYmICQuY29udGFpbnMoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0sIHRoaXMub2Zmc2V0UGFyZW50WyAwIF0gKSApID8gdGhpcy5vZmZzZXRQYXJlbnQgOiB0aGlzLnNjcm9sbFBhcmVudDtcblxuXHRcdC8vQ2FjaGUgdGhlIHNjcm9sbFxuXHRcdGlmICghdGhpcy5vZmZzZXQuc2Nyb2xsKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5zY3JvbGwgPSB7dG9wIDogc2Nyb2xsLnNjcm9sbFRvcCgpLCBsZWZ0IDogc2Nyb2xsLnNjcm9sbExlZnQoKX07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogKFxuXHRcdFx0XHRwb3MudG9wXHQrXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUudG9wICogbW9kICtcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQudG9wICogbW9kIC1cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdCggKCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCkgOiB0aGlzLm9mZnNldC5zY3JvbGwudG9wICkgKiBtb2QgKVxuXHRcdFx0KSxcblx0XHRcdGxlZnQ6IChcblx0XHRcdFx0cG9zLmxlZnQgK1x0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgKiBtb2QgK1x0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0ICogbW9kXHQtXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQoICggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKSA6IHRoaXMub2Zmc2V0LnNjcm9sbC5sZWZ0ICkgKiBtb2QgKVxuXHRcdFx0KVxuXHRcdH07XG5cblx0fSxcblxuXHRfZ2VuZXJhdGVQb3NpdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBjb250YWlubWVudCwgY28sIHRvcCwgbGVmdCxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRzY3JvbGwgPSB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImFic29sdXRlXCIgJiYgISggdGhpcy5zY3JvbGxQYXJlbnRbIDAgXSAhPT0gZG9jdW1lbnQgJiYgJC5jb250YWlucyggdGhpcy5zY3JvbGxQYXJlbnRbIDAgXSwgdGhpcy5vZmZzZXRQYXJlbnRbIDAgXSApICkgPyB0aGlzLm9mZnNldFBhcmVudCA6IHRoaXMuc2Nyb2xsUGFyZW50LFxuXHRcdFx0cGFnZVggPSBldmVudC5wYWdlWCxcblx0XHRcdHBhZ2VZID0gZXZlbnQucGFnZVk7XG5cblx0XHQvL0NhY2hlIHRoZSBzY3JvbGxcblx0XHRpZiAoIXRoaXMub2Zmc2V0LnNjcm9sbCkge1xuXHRcdFx0dGhpcy5vZmZzZXQuc2Nyb2xsID0ge3RvcCA6IHNjcm9sbC5zY3JvbGxUb3AoKSwgbGVmdCA6IHNjcm9sbC5zY3JvbGxMZWZ0KCl9O1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0ICogLSBQb3NpdGlvbiBjb25zdHJhaW5pbmcgLVxuXHRcdCAqIENvbnN0cmFpbiB0aGUgcG9zaXRpb24gdG8gYSBtaXggb2YgZ3JpZCwgY29udGFpbm1lbnQuXG5cdFx0ICovXG5cblx0XHQvLyBJZiB3ZSBhcmUgbm90IGRyYWdnaW5nIHlldCwgd2Ugd29uJ3QgY2hlY2sgZm9yIG9wdGlvbnNcblx0XHRpZiAoIHRoaXMub3JpZ2luYWxQb3NpdGlvbiApIHtcblx0XHRcdGlmICggdGhpcy5jb250YWlubWVudCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbGF0aXZlX2NvbnRhaW5lciApe1xuXHRcdFx0XHRcdGNvID0gdGhpcy5yZWxhdGl2ZV9jb250YWluZXIub2Zmc2V0KCk7XG5cdFx0XHRcdFx0Y29udGFpbm1lbnQgPSBbXG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRhaW5tZW50WyAwIF0gKyBjby5sZWZ0LFxuXHRcdFx0XHRcdFx0dGhpcy5jb250YWlubWVudFsgMSBdICsgY28udG9wLFxuXHRcdFx0XHRcdFx0dGhpcy5jb250YWlubWVudFsgMiBdICsgY28ubGVmdCxcblx0XHRcdFx0XHRcdHRoaXMuY29udGFpbm1lbnRbIDMgXSArIGNvLnRvcFxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y29udGFpbm1lbnQgPSB0aGlzLmNvbnRhaW5tZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDwgY29udGFpbm1lbnRbMF0pIHtcblx0XHRcdFx0XHRwYWdlWCA9IGNvbnRhaW5tZW50WzBdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IGNvbnRhaW5tZW50WzFdKSB7XG5cdFx0XHRcdFx0cGFnZVkgPSBjb250YWlubWVudFsxXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPiBjb250YWlubWVudFsyXSkge1xuXHRcdFx0XHRcdHBhZ2VYID0gY29udGFpbm1lbnRbMl0gKyB0aGlzLm9mZnNldC5jbGljay5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID4gY29udGFpbm1lbnRbM10pIHtcblx0XHRcdFx0XHRwYWdlWSA9IGNvbnRhaW5tZW50WzNdICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKG8uZ3JpZCkge1xuXHRcdFx0XHQvL0NoZWNrIGZvciBncmlkIGVsZW1lbnRzIHNldCB0byAwIHRvIHByZXZlbnQgZGl2aWRlIGJ5IDAgZXJyb3IgY2F1c2luZyBpbnZhbGlkIGFyZ3VtZW50IGVycm9ycyBpbiBJRSAoc2VlIHRpY2tldCAjNjk1MClcblx0XHRcdFx0dG9wID0gby5ncmlkWzFdID8gdGhpcy5vcmlnaW5hbFBhZ2VZICsgTWF0aC5yb3VuZCgocGFnZVkgLSB0aGlzLm9yaWdpbmFsUGFnZVkpIC8gby5ncmlkWzFdKSAqIG8uZ3JpZFsxXSA6IHRoaXMub3JpZ2luYWxQYWdlWTtcblx0XHRcdFx0cGFnZVkgPSBjb250YWlubWVudCA/ICgodG9wIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID49IGNvbnRhaW5tZW50WzFdIHx8IHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+IGNvbnRhaW5tZW50WzNdKSA/IHRvcCA6ICgodG9wIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID49IGNvbnRhaW5tZW50WzFdKSA/IHRvcCAtIG8uZ3JpZFsxXSA6IHRvcCArIG8uZ3JpZFsxXSkpIDogdG9wO1xuXG5cdFx0XHRcdGxlZnQgPSBvLmdyaWRbMF0gPyB0aGlzLm9yaWdpbmFsUGFnZVggKyBNYXRoLnJvdW5kKChwYWdlWCAtIHRoaXMub3JpZ2luYWxQYWdlWCkgLyBvLmdyaWRbMF0pICogby5ncmlkWzBdIDogdGhpcy5vcmlnaW5hbFBhZ2VYO1xuXHRcdFx0XHRwYWdlWCA9IGNvbnRhaW5tZW50ID8gKChsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+PSBjb250YWlubWVudFswXSB8fCBsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+IGNvbnRhaW5tZW50WzJdKSA/IGxlZnQgOiAoKGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID49IGNvbnRhaW5tZW50WzBdKSA/IGxlZnQgLSBvLmdyaWRbMF0gOiBsZWZ0ICsgby5ncmlkWzBdKSkgOiBsZWZ0O1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogKFxuXHRcdFx0XHRwYWdlWSAtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3BcdC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQudG9wICtcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSA6IHRoaXMub2Zmc2V0LnNjcm9sbC50b3AgKVxuXHRcdFx0KSxcblx0XHRcdGxlZnQ6IChcblx0XHRcdFx0cGFnZVggLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCAtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2xpY2sgb2Zmc2V0IChyZWxhdGl2ZSB0byB0aGUgZWxlbWVudClcblx0XHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0ICtcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiB0aGlzLm9mZnNldC5zY3JvbGwubGVmdCApXG5cdFx0XHQpXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9jbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oZWxwZXIucmVtb3ZlQ2xhc3MoXCJ1aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIik7XG5cdFx0aWYodGhpcy5oZWxwZXJbMF0gIT09IHRoaXMuZWxlbWVudFswXSAmJiAhdGhpcy5jYW5jZWxIZWxwZXJSZW1vdmFsKSB7XG5cdFx0XHR0aGlzLmhlbHBlci5yZW1vdmUoKTtcblx0XHR9XG5cdFx0dGhpcy5oZWxwZXIgPSBudWxsO1xuXHRcdHRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlO1xuXHR9LFxuXG5cdC8vIEZyb20gbm93IG9uIGJ1bGsgc3R1ZmYgLSBtYWlubHkgaGVscGVyc1xuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbih0eXBlLCBldmVudCwgdWkpIHtcblx0XHR1aSA9IHVpIHx8IHRoaXMuX3VpSGFzaCgpO1xuXHRcdCQudWkucGx1Z2luLmNhbGwodGhpcywgdHlwZSwgW2V2ZW50LCB1aV0pO1xuXHRcdC8vVGhlIGFic29sdXRlIHBvc2l0aW9uIGhhcyB0byBiZSByZWNhbGN1bGF0ZWQgYWZ0ZXIgcGx1Z2luc1xuXHRcdGlmKHR5cGUgPT09IFwiZHJhZ1wiKSB7XG5cdFx0XHR0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5fY29udmVydFBvc2l0aW9uVG8oXCJhYnNvbHV0ZVwiKTtcblx0XHR9XG5cdFx0cmV0dXJuICQuV2lkZ2V0LnByb3RvdHlwZS5fdHJpZ2dlci5jYWxsKHRoaXMsIHR5cGUsIGV2ZW50LCB1aSk7XG5cdH0sXG5cblx0cGx1Z2luczoge30sXG5cblx0X3VpSGFzaDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGhlbHBlcjogdGhpcy5oZWxwZXIsXG5cdFx0XHRwb3NpdGlvbjogdGhpcy5wb3NpdGlvbixcblx0XHRcdG9yaWdpbmFsUG9zaXRpb246IHRoaXMub3JpZ2luYWxQb3NpdGlvbixcblx0XHRcdG9mZnNldDogdGhpcy5wb3NpdGlvbkFic1xuXHRcdH07XG5cdH1cblxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcImNvbm5lY3RUb1NvcnRhYmxlXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0dmFyIGluc3QgPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIiksIG8gPSBpbnN0Lm9wdGlvbnMsXG5cdFx0XHR1aVNvcnRhYmxlID0gJC5leHRlbmQoe30sIHVpLCB7IGl0ZW06IGluc3QuZWxlbWVudCB9KTtcblx0XHRpbnN0LnNvcnRhYmxlcyA9IFtdO1xuXHRcdCQoby5jb25uZWN0VG9Tb3J0YWJsZSkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzb3J0YWJsZSA9ICQuZGF0YSh0aGlzLCBcInVpLXNvcnRhYmxlXCIpO1xuXHRcdFx0aWYgKHNvcnRhYmxlICYmICFzb3J0YWJsZS5vcHRpb25zLmRpc2FibGVkKSB7XG5cdFx0XHRcdGluc3Quc29ydGFibGVzLnB1c2goe1xuXHRcdFx0XHRcdGluc3RhbmNlOiBzb3J0YWJsZSxcblx0XHRcdFx0XHRzaG91bGRSZXZlcnQ6IHNvcnRhYmxlLm9wdGlvbnMucmV2ZXJ0XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb3J0YWJsZS5yZWZyZXNoUG9zaXRpb25zKCk7XHQvLyBDYWxsIHRoZSBzb3J0YWJsZSdzIHJlZnJlc2hQb3NpdGlvbnMgYXQgZHJhZyBzdGFydCB0byByZWZyZXNoIHRoZSBjb250YWluZXJDYWNoZSBzaW5jZSB0aGUgc29ydGFibGUgY29udGFpbmVyIGNhY2hlIGlzIHVzZWQgaW4gZHJhZyBhbmQgbmVlZHMgdG8gYmUgdXAgdG8gZGF0ZSAodGhpcyB3aWxsIGVuc3VyZSBpdCdzIGluaXRpYWxpc2VkIGFzIHdlbGwgYXMgYmVpbmcga2VwdCBpbiBzdGVwIHdpdGggYW55IGNoYW5nZXMgdGhhdCBtaWdodCBoYXZlIGhhcHBlbmVkIG9uIHRoZSBwYWdlKS5cblx0XHRcdFx0c29ydGFibGUuX3RyaWdnZXIoXCJhY3RpdmF0ZVwiLCBldmVudCwgdWlTb3J0YWJsZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSxcblx0c3RvcDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cblx0XHQvL0lmIHdlIGFyZSBzdGlsbCBvdmVyIHRoZSBzb3J0YWJsZSwgd2UgZmFrZSB0aGUgc3RvcCBldmVudCBvZiB0aGUgc29ydGFibGUsIGJ1dCBhbHNvIHJlbW92ZSBoZWxwZXJcblx0XHR2YXIgaW5zdCA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKSxcblx0XHRcdHVpU29ydGFibGUgPSAkLmV4dGVuZCh7fSwgdWksIHsgaXRlbTogaW5zdC5lbGVtZW50IH0pO1xuXG5cdFx0JC5lYWNoKGluc3Quc29ydGFibGVzLCBmdW5jdGlvbigpIHtcblx0XHRcdGlmKHRoaXMuaW5zdGFuY2UuaXNPdmVyKSB7XG5cblx0XHRcdFx0dGhpcy5pbnN0YW5jZS5pc092ZXIgPSAwO1xuXG5cdFx0XHRcdGluc3QuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IHRydWU7IC8vRG9uJ3QgcmVtb3ZlIHRoZSBoZWxwZXIgaW4gdGhlIGRyYWdnYWJsZSBpbnN0YW5jZVxuXHRcdFx0XHR0aGlzLmluc3RhbmNlLmNhbmNlbEhlbHBlclJlbW92YWwgPSBmYWxzZTsgLy9SZW1vdmUgaXQgaW4gdGhlIHNvcnRhYmxlIGluc3RhbmNlIChzbyBzb3J0YWJsZSBwbHVnaW5zIGxpa2UgcmV2ZXJ0IHN0aWxsIHdvcmspXG5cblx0XHRcdFx0Ly9UaGUgc29ydGFibGUgcmV2ZXJ0IGlzIHN1cHBvcnRlZCwgYW5kIHdlIGhhdmUgdG8gc2V0IGEgdGVtcG9yYXJ5IGRyb3BwZWQgdmFyaWFibGUgb24gdGhlIGRyYWdnYWJsZSB0byBzdXBwb3J0IHJldmVydDogXCJ2YWxpZC9pbnZhbGlkXCJcblx0XHRcdFx0aWYodGhpcy5zaG91bGRSZXZlcnQpIHtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9wdGlvbnMucmV2ZXJ0ID0gdGhpcy5zaG91bGRSZXZlcnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1RyaWdnZXIgdGhlIHN0b3Agb2YgdGhlIHNvcnRhYmxlXG5cdFx0XHRcdHRoaXMuaW5zdGFuY2UuX21vdXNlU3RvcChldmVudCk7XG5cblx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vcHRpb25zLmhlbHBlciA9IHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5faGVscGVyO1xuXG5cdFx0XHRcdC8vSWYgdGhlIGhlbHBlciBoYXMgYmVlbiB0aGUgb3JpZ2luYWwgaXRlbSwgcmVzdG9yZSBwcm9wZXJ0aWVzIGluIHRoZSBzb3J0YWJsZVxuXHRcdFx0XHRpZihpbnN0Lm9wdGlvbnMuaGVscGVyID09PSBcIm9yaWdpbmFsXCIpIHtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmN1cnJlbnRJdGVtLmNzcyh7IHRvcDogXCJhdXRvXCIsIGxlZnQ6IFwiYXV0b1wiIH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuaW5zdGFuY2UuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlOyAvL1JlbW92ZSB0aGUgaGVscGVyIGluIHRoZSBzb3J0YWJsZSBpbnN0YW5jZVxuXHRcdFx0XHR0aGlzLmluc3RhbmNlLl90cmlnZ2VyKFwiZGVhY3RpdmF0ZVwiLCBldmVudCwgdWlTb3J0YWJsZSk7XG5cdFx0XHR9XG5cblx0XHR9KTtcblxuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLCB0aGF0ID0gdGhpcztcblxuXHRcdCQuZWFjaChpbnN0LnNvcnRhYmxlcywgZnVuY3Rpb24oKSB7XG5cblx0XHRcdHZhciBpbm5lcm1vc3RJbnRlcnNlY3RpbmcgPSBmYWxzZSxcblx0XHRcdFx0dGhpc1NvcnRhYmxlID0gdGhpcztcblxuXHRcdFx0Ly9Db3B5IG92ZXIgc29tZSB2YXJpYWJsZXMgdG8gYWxsb3cgY2FsbGluZyB0aGUgc29ydGFibGUncyBuYXRpdmUgX2ludGVyc2VjdHNXaXRoXG5cdFx0XHR0aGlzLmluc3RhbmNlLnBvc2l0aW9uQWJzID0gaW5zdC5wb3NpdGlvbkFicztcblx0XHRcdHRoaXMuaW5zdGFuY2UuaGVscGVyUHJvcG9ydGlvbnMgPSBpbnN0LmhlbHBlclByb3BvcnRpb25zO1xuXHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQuY2xpY2sgPSBpbnN0Lm9mZnNldC5jbGljaztcblxuXHRcdFx0aWYodGhpcy5pbnN0YW5jZS5faW50ZXJzZWN0c1dpdGgodGhpcy5pbnN0YW5jZS5jb250YWluZXJDYWNoZSkpIHtcblx0XHRcdFx0aW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gdHJ1ZTtcblx0XHRcdFx0JC5lYWNoKGluc3Quc29ydGFibGVzLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5wb3NpdGlvbkFicyA9IGluc3QucG9zaXRpb25BYnM7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5oZWxwZXJQcm9wb3J0aW9ucyA9IGluc3QuaGVscGVyUHJvcG9ydGlvbnM7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQuY2xpY2sgPSBpbnN0Lm9mZnNldC5jbGljaztcblx0XHRcdFx0XHRpZiAodGhpcyAhPT0gdGhpc1NvcnRhYmxlICYmXG5cdFx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLl9pbnRlcnNlY3RzV2l0aCh0aGlzLmluc3RhbmNlLmNvbnRhaW5lckNhY2hlKSAmJlxuXHRcdFx0XHRcdFx0JC5jb250YWlucyh0aGlzU29ydGFibGUuaW5zdGFuY2UuZWxlbWVudFswXSwgdGhpcy5pbnN0YW5jZS5lbGVtZW50WzBdKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0aW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpbm5lcm1vc3RJbnRlcnNlY3Rpbmc7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cblx0XHRcdGlmKGlubmVybW9zdEludGVyc2VjdGluZykge1xuXHRcdFx0XHQvL0lmIGl0IGludGVyc2VjdHMsIHdlIHVzZSBhIGxpdHRsZSBpc092ZXIgdmFyaWFibGUgYW5kIHNldCBpdCBvbmNlLCBzbyBvdXIgbW92ZS1pbiBzdHVmZiBnZXRzIGZpcmVkIG9ubHkgb25jZVxuXHRcdFx0XHRpZighdGhpcy5pbnN0YW5jZS5pc092ZXIpIHtcblxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuaXNPdmVyID0gMTtcblx0XHRcdFx0XHQvL05vdyB3ZSBmYWtlIHRoZSBzdGFydCBvZiBkcmFnZ2luZyBmb3IgdGhlIHNvcnRhYmxlIGluc3RhbmNlLFxuXHRcdFx0XHRcdC8vYnkgY2xvbmluZyB0aGUgbGlzdCBncm91cCBpdGVtLCBhcHBlbmRpbmcgaXQgdG8gdGhlIHNvcnRhYmxlIGFuZCB1c2luZyBpdCBhcyBpbnN0LmN1cnJlbnRJdGVtXG5cdFx0XHRcdFx0Ly9XZSBjYW4gdGhlbiBmaXJlIHRoZSBzdGFydCBldmVudCBvZiB0aGUgc29ydGFibGUgd2l0aCBvdXIgcGFzc2VkIGJyb3dzZXIgZXZlbnQsIGFuZCBvdXIgb3duIGhlbHBlciAoc28gaXQgZG9lc24ndCBjcmVhdGUgYSBuZXcgb25lKVxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW0gPSAkKHRoYXQpLmNsb25lKCkucmVtb3ZlQXR0cihcImlkXCIpLmFwcGVuZFRvKHRoaXMuaW5zdGFuY2UuZWxlbWVudCkuZGF0YShcInVpLXNvcnRhYmxlLWl0ZW1cIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vcHRpb25zLl9oZWxwZXIgPSB0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGVscGVyOyAvL1N0b3JlIGhlbHBlciBvcHRpb24gdG8gbGF0ZXIgcmVzdG9yZSBpdFxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5oZWxwZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHVpLmhlbHBlclswXTsgfTtcblxuXHRcdFx0XHRcdGV2ZW50LnRhcmdldCA9IHRoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW1bMF07XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fbW91c2VDYXB0dXJlKGV2ZW50LCB0cnVlKTtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLl9tb3VzZVN0YXJ0KGV2ZW50LCB0cnVlLCB0cnVlKTtcblxuXHRcdFx0XHRcdC8vQmVjYXVzZSB0aGUgYnJvd3NlciBldmVudCBpcyB3YXkgb2ZmIHRoZSBuZXcgYXBwZW5kZWQgcG9ydGxldCwgd2UgbW9kaWZ5IGEgY291cGxlIG9mIHZhcmlhYmxlcyB0byByZWZsZWN0IHRoZSBjaGFuZ2VzXG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQuY2xpY2sudG9wID0gaW5zdC5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LmNsaWNrLmxlZnQgPSBpbnN0Lm9mZnNldC5jbGljay5sZWZ0O1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LnBhcmVudC5sZWZ0IC09IGluc3Qub2Zmc2V0LnBhcmVudC5sZWZ0IC0gdGhpcy5pbnN0YW5jZS5vZmZzZXQucGFyZW50LmxlZnQ7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQucGFyZW50LnRvcCAtPSBpbnN0Lm9mZnNldC5wYXJlbnQudG9wIC0gdGhpcy5pbnN0YW5jZS5vZmZzZXQucGFyZW50LnRvcDtcblxuXHRcdFx0XHRcdGluc3QuX3RyaWdnZXIoXCJ0b1NvcnRhYmxlXCIsIGV2ZW50KTtcblx0XHRcdFx0XHRpbnN0LmRyb3BwZWQgPSB0aGlzLmluc3RhbmNlLmVsZW1lbnQ7IC8vZHJhZ2dhYmxlIHJldmVydCBuZWVkcyB0aGF0XG5cdFx0XHRcdFx0Ly9oYWNrIHNvIHJlY2VpdmUvdXBkYXRlIGNhbGxiYWNrcyB3b3JrIChtb3N0bHkpXG5cdFx0XHRcdFx0aW5zdC5jdXJyZW50SXRlbSA9IGluc3QuZWxlbWVudDtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmZyb21PdXRzaWRlID0gaW5zdDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9Qcm92aWRlZCB3ZSBkaWQgYWxsIHRoZSBwcmV2aW91cyBzdGVwcywgd2UgY2FuIGZpcmUgdGhlIGRyYWcgZXZlbnQgb2YgdGhlIHNvcnRhYmxlIG9uIGV2ZXJ5IGRyYWdnYWJsZSBkcmFnLCB3aGVuIGl0IGludGVyc2VjdHMgd2l0aCB0aGUgc29ydGFibGVcblx0XHRcdFx0aWYodGhpcy5pbnN0YW5jZS5jdXJyZW50SXRlbSkge1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuX21vdXNlRHJhZyhldmVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvL0lmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHdpdGggdGhlIHNvcnRhYmxlLCBhbmQgaXQgaW50ZXJzZWN0ZWQgYmVmb3JlLFxuXHRcdFx0XHQvL3dlIGZha2UgdGhlIGRyYWcgc3RvcCBvZiB0aGUgc29ydGFibGUsIGJ1dCBtYWtlIHN1cmUgaXQgZG9lc24ndCByZW1vdmUgdGhlIGhlbHBlciBieSB1c2luZyBjYW5jZWxIZWxwZXJSZW1vdmFsXG5cdFx0XHRcdGlmKHRoaXMuaW5zdGFuY2UuaXNPdmVyKSB7XG5cblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmlzT3ZlciA9IDA7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vUHJldmVudCByZXZlcnRpbmcgb24gdGhpcyBmb3JjZWQgc3RvcFxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5yZXZlcnQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIFRoZSBvdXQgZXZlbnQgbmVlZHMgdG8gYmUgdHJpZ2dlcmVkIGluZGVwZW5kZW50bHlcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLl90cmlnZ2VyKFwib3V0XCIsIGV2ZW50LCB0aGlzLmluc3RhbmNlLl91aUhhc2godGhpcy5pbnN0YW5jZSkpO1xuXG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fbW91c2VTdG9wKGV2ZW50LCB0cnVlKTtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGVscGVyID0gdGhpcy5pbnN0YW5jZS5vcHRpb25zLl9oZWxwZXI7XG5cblx0XHRcdFx0XHQvL05vdyB3ZSByZW1vdmUgb3VyIGN1cnJlbnRJdGVtLCB0aGUgbGlzdCBncm91cCBjbG9uZSBhZ2FpbiwgYW5kIHRoZSBwbGFjZWhvbGRlciwgYW5kIGFuaW1hdGUgdGhlIGhlbHBlciBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgc2l6ZVxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdFx0aWYodGhpcy5pbnN0YW5jZS5wbGFjZWhvbGRlcikge1xuXHRcdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5wbGFjZWhvbGRlci5yZW1vdmUoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbnN0Ll90cmlnZ2VyKFwiZnJvbVNvcnRhYmxlXCIsIGV2ZW50KTtcblx0XHRcdFx0XHRpbnN0LmRyb3BwZWQgPSBmYWxzZTsgLy9kcmFnZ2FibGUgcmV2ZXJ0IG5lZWRzIHRoYXRcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9KTtcblxuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsIFwiY3Vyc29yXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0ID0gJChcImJvZHlcIiksIG8gPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIikub3B0aW9ucztcblx0XHRpZiAodC5jc3MoXCJjdXJzb3JcIikpIHtcblx0XHRcdG8uX2N1cnNvciA9IHQuY3NzKFwiY3Vyc29yXCIpO1xuXHRcdH1cblx0XHR0LmNzcyhcImN1cnNvclwiLCBvLmN1cnNvcik7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLm9wdGlvbnM7XG5cdFx0aWYgKG8uX2N1cnNvcikge1xuXHRcdFx0JChcImJvZHlcIikuY3NzKFwiY3Vyc29yXCIsIG8uX2N1cnNvcik7XG5cdFx0fVxuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsIFwib3BhY2l0eVwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgdCA9ICQodWkuaGVscGVyKSwgbyA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKS5vcHRpb25zO1xuXHRcdGlmKHQuY3NzKFwib3BhY2l0eVwiKSkge1xuXHRcdFx0by5fb3BhY2l0eSA9IHQuY3NzKFwib3BhY2l0eVwiKTtcblx0XHR9XG5cdFx0dC5jc3MoXCJvcGFjaXR5XCIsIG8ub3BhY2l0eSk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXHRcdHZhciBvID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLm9wdGlvbnM7XG5cdFx0aWYoby5fb3BhY2l0eSkge1xuXHRcdFx0JCh1aS5oZWxwZXIpLmNzcyhcIm9wYWNpdHlcIiwgby5fb3BhY2l0eSk7XG5cdFx0fVxuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsIFwic2Nyb2xsXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpO1xuXHRcdGlmKGkuc2Nyb2xsUGFyZW50WzBdICE9PSBkb2N1bWVudCAmJiBpLnNjcm9sbFBhcmVudFswXS50YWdOYW1lICE9PSBcIkhUTUxcIikge1xuXHRcdFx0aS5vdmVyZmxvd09mZnNldCA9IGkuc2Nyb2xsUGFyZW50Lm9mZnNldCgpO1xuXHRcdH1cblx0fSxcblx0ZHJhZzogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0dmFyIGkgPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIiksIG8gPSBpLm9wdGlvbnMsIHNjcm9sbGVkID0gZmFsc2U7XG5cblx0XHRpZihpLnNjcm9sbFBhcmVudFswXSAhPT0gZG9jdW1lbnQgJiYgaS5zY3JvbGxQYXJlbnRbMF0udGFnTmFtZSAhPT0gXCJIVE1MXCIpIHtcblxuXHRcdFx0aWYoIW8uYXhpcyB8fCBvLmF4aXMgIT09IFwieFwiKSB7XG5cdFx0XHRcdGlmKChpLm92ZXJmbG93T2Zmc2V0LnRvcCArIGkuc2Nyb2xsUGFyZW50WzBdLm9mZnNldEhlaWdodCkgLSBldmVudC5wYWdlWSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCArIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH0gZWxzZSBpZihldmVudC5wYWdlWSAtIGkub3ZlcmZsb3dPZmZzZXQudG9wIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCA9IHNjcm9sbGVkID0gaS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wIC0gby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZighby5heGlzIHx8IG8uYXhpcyAhPT0gXCJ5XCIpIHtcblx0XHRcdFx0aWYoKGkub3ZlcmZsb3dPZmZzZXQubGVmdCArIGkuc2Nyb2xsUGFyZW50WzBdLm9mZnNldFdpZHRoKSAtIGV2ZW50LnBhZ2VYIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgKyBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9IGVsc2UgaWYoZXZlbnQucGFnZVggLSBpLm92ZXJmbG93T2Zmc2V0LmxlZnQgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0aS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gaS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCAtIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmKCFvLmF4aXMgfHwgby5heGlzICE9PSBcInhcIikge1xuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIC0gby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH0gZWxzZSBpZigkKHdpbmRvdykuaGVpZ2h0KCkgLSAoZXZlbnQucGFnZVkgLSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgKyBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZighby5heGlzIHx8IG8uYXhpcyAhPT0gXCJ5XCIpIHtcblx0XHRcdFx0aWYoZXZlbnQucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSAtIG8uc2Nyb2xsU3BlZWQpO1xuXHRcdFx0XHR9IGVsc2UgaWYoJCh3aW5kb3cpLndpZHRoKCkgLSAoZXZlbnQucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgKyBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYoc2Nyb2xsZWQgIT09IGZhbHNlICYmICQudWkuZGRtYW5hZ2VyICYmICFvLmRyb3BCZWhhdmlvdXIpIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKGksIGV2ZW50KTtcblx0XHR9XG5cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcInNuYXBcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaSA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKSxcblx0XHRcdG8gPSBpLm9wdGlvbnM7XG5cblx0XHRpLnNuYXBFbGVtZW50cyA9IFtdO1xuXG5cdFx0JChvLnNuYXAuY29uc3RydWN0b3IgIT09IFN0cmluZyA/ICggby5zbmFwLml0ZW1zIHx8IFwiOmRhdGEodWktZHJhZ2dhYmxlKVwiICkgOiBvLnNuYXApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgJHQgPSAkKHRoaXMpLFxuXHRcdFx0XHQkbyA9ICR0Lm9mZnNldCgpO1xuXHRcdFx0aWYodGhpcyAhPT0gaS5lbGVtZW50WzBdKSB7XG5cdFx0XHRcdGkuc25hcEVsZW1lbnRzLnB1c2goe1xuXHRcdFx0XHRcdGl0ZW06IHRoaXMsXG5cdFx0XHRcdFx0d2lkdGg6ICR0Lm91dGVyV2lkdGgoKSwgaGVpZ2h0OiAkdC5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHRcdHRvcDogJG8udG9wLCBsZWZ0OiAkby5sZWZ0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0sXG5cdGRyYWc6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0dmFyIHRzLCBicywgbHMsIHJzLCBsLCByLCB0LCBiLCBpLCBmaXJzdCxcblx0XHRcdGluc3QgPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIiksXG5cdFx0XHRvID0gaW5zdC5vcHRpb25zLFxuXHRcdFx0ZCA9IG8uc25hcFRvbGVyYW5jZSxcblx0XHRcdHgxID0gdWkub2Zmc2V0LmxlZnQsIHgyID0geDEgKyBpbnN0LmhlbHBlclByb3BvcnRpb25zLndpZHRoLFxuXHRcdFx0eTEgPSB1aS5vZmZzZXQudG9wLCB5MiA9IHkxICsgaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQ7XG5cblx0XHRmb3IgKGkgPSBpbnN0LnNuYXBFbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cblx0XHRcdGwgPSBpbnN0LnNuYXBFbGVtZW50c1tpXS5sZWZ0O1xuXHRcdFx0ciA9IGwgKyBpbnN0LnNuYXBFbGVtZW50c1tpXS53aWR0aDtcblx0XHRcdHQgPSBpbnN0LnNuYXBFbGVtZW50c1tpXS50b3A7XG5cdFx0XHRiID0gdCArIGluc3Quc25hcEVsZW1lbnRzW2ldLmhlaWdodDtcblxuXHRcdFx0aWYgKCB4MiA8IGwgLSBkIHx8IHgxID4gciArIGQgfHwgeTIgPCB0IC0gZCB8fCB5MSA+IGIgKyBkIHx8ICEkLmNvbnRhaW5zKCBpbnN0LnNuYXBFbGVtZW50c1sgaSBdLml0ZW0ub3duZXJEb2N1bWVudCwgaW5zdC5zbmFwRWxlbWVudHNbIGkgXS5pdGVtICkgKSB7XG5cdFx0XHRcdGlmKGluc3Quc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nKSB7XG5cdFx0XHRcdFx0KGluc3Qub3B0aW9ucy5zbmFwLnJlbGVhc2UgJiYgaW5zdC5vcHRpb25zLnNuYXAucmVsZWFzZS5jYWxsKGluc3QuZWxlbWVudCwgZXZlbnQsICQuZXh0ZW5kKGluc3QuX3VpSGFzaCgpLCB7IHNuYXBJdGVtOiBpbnN0LnNuYXBFbGVtZW50c1tpXS5pdGVtIH0pKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdC5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmcgPSBmYWxzZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmKG8uc25hcE1vZGUgIT09IFwiaW5uZXJcIikge1xuXHRcdFx0XHR0cyA9IE1hdGguYWJzKHQgLSB5MikgPD0gZDtcblx0XHRcdFx0YnMgPSBNYXRoLmFicyhiIC0geTEpIDw9IGQ7XG5cdFx0XHRcdGxzID0gTWF0aC5hYnMobCAtIHgyKSA8PSBkO1xuXHRcdFx0XHRycyA9IE1hdGguYWJzKHIgLSB4MSkgPD0gZDtcblx0XHRcdFx0aWYodHMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiB0IC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQsIGxlZnQ6IDAgfSkudG9wIC0gaW5zdC5tYXJnaW5zLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihicykge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IGIsIGxlZnQ6IDAgfSkudG9wIC0gaW5zdC5tYXJnaW5zLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihscykge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLmxlZnQgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiAwLCBsZWZ0OiBsIC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCB9KS5sZWZ0IC0gaW5zdC5tYXJnaW5zLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYocnMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogciB9KS5sZWZ0IC0gaW5zdC5tYXJnaW5zLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zmlyc3QgPSAodHMgfHwgYnMgfHwgbHMgfHwgcnMpO1xuXG5cdFx0XHRpZihvLnNuYXBNb2RlICE9PSBcIm91dGVyXCIpIHtcblx0XHRcdFx0dHMgPSBNYXRoLmFicyh0IC0geTEpIDw9IGQ7XG5cdFx0XHRcdGJzID0gTWF0aC5hYnMoYiAtIHkyKSA8PSBkO1xuXHRcdFx0XHRscyA9IE1hdGguYWJzKGwgLSB4MSkgPD0gZDtcblx0XHRcdFx0cnMgPSBNYXRoLmFicyhyIC0geDIpIDw9IGQ7XG5cdFx0XHRcdGlmKHRzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogdCwgbGVmdDogMCB9KS50b3AgLSBpbnN0Lm1hcmdpbnMudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGJzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogYiAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LCBsZWZ0OiAwIH0pLnRvcCAtIGluc3QubWFyZ2lucy50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYobHMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogbCB9KS5sZWZ0IC0gaW5zdC5tYXJnaW5zLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYocnMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogciAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggfSkubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKCFpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZyAmJiAodHMgfHwgYnMgfHwgbHMgfHwgcnMgfHwgZmlyc3QpKSB7XG5cdFx0XHRcdChpbnN0Lm9wdGlvbnMuc25hcC5zbmFwICYmIGluc3Qub3B0aW9ucy5zbmFwLnNuYXAuY2FsbChpbnN0LmVsZW1lbnQsIGV2ZW50LCAkLmV4dGVuZChpbnN0Ll91aUhhc2goKSwgeyBzbmFwSXRlbTogaW5zdC5zbmFwRWxlbWVudHNbaV0uaXRlbSB9KSkpO1xuXHRcdFx0fVxuXHRcdFx0aW5zdC5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmcgPSAodHMgfHwgYnMgfHwgbHMgfHwgcnMgfHwgZmlyc3QpO1xuXG5cdFx0fVxuXG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJzdGFja1wiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWluLFxuXHRcdFx0byA9IHRoaXMuZGF0YShcInVpLWRyYWdnYWJsZVwiKS5vcHRpb25zLFxuXHRcdFx0Z3JvdXAgPSAkLm1ha2VBcnJheSgkKG8uc3RhY2spKS5zb3J0KGZ1bmN0aW9uKGEsYikge1xuXHRcdFx0XHRyZXR1cm4gKHBhcnNlSW50KCQoYSkuY3NzKFwiekluZGV4XCIpLDEwKSB8fCAwKSAtIChwYXJzZUludCgkKGIpLmNzcyhcInpJbmRleFwiKSwxMCkgfHwgMCk7XG5cdFx0XHR9KTtcblxuXHRcdGlmICghZ3JvdXAubGVuZ3RoKSB7IHJldHVybjsgfVxuXG5cdFx0bWluID0gcGFyc2VJbnQoJChncm91cFswXSkuY3NzKFwiekluZGV4XCIpLCAxMCkgfHwgMDtcblx0XHQkKGdyb3VwKS5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdCQodGhpcykuY3NzKFwiekluZGV4XCIsIG1pbiArIGkpO1xuXHRcdH0pO1xuXHRcdHRoaXMuY3NzKFwiekluZGV4XCIsIChtaW4gKyBncm91cC5sZW5ndGgpKTtcblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcInpJbmRleFwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgdCA9ICQodWkuaGVscGVyKSwgbyA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKS5vcHRpb25zO1xuXHRcdGlmKHQuY3NzKFwiekluZGV4XCIpKSB7XG5cdFx0XHRvLl96SW5kZXggPSB0LmNzcyhcInpJbmRleFwiKTtcblx0XHR9XG5cdFx0dC5jc3MoXCJ6SW5kZXhcIiwgby56SW5kZXgpO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgbyA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKS5vcHRpb25zO1xuXHRcdGlmKG8uX3pJbmRleCkge1xuXHRcdFx0JCh1aS5oZWxwZXIpLmNzcyhcInpJbmRleFwiLCBvLl96SW5kZXgpO1xuXHRcdH1cblx0fVxufSk7XG5cbn0pKGpRdWVyeSk7XG4iLCJ2YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5yZXF1aXJlKCcuL3dpZGdldCcpO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBNb3VzZSAxLjEwLjRcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vbW91c2UvXG4gKlxuICogRGVwZW5kczpcbiAqXHRqcXVlcnkudWkud2lkZ2V0LmpzXG4gKi9cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgbW91c2VIYW5kbGVkID0gZmFsc2U7XG4kKCBkb2N1bWVudCApLm1vdXNldXAoIGZ1bmN0aW9uKCkge1xuXHRtb3VzZUhhbmRsZWQgPSBmYWxzZTtcbn0pO1xuXG4kLndpZGdldChcInVpLm1vdXNlXCIsIHtcblx0dmVyc2lvbjogXCIxLjEwLjRcIixcblx0b3B0aW9uczoge1xuXHRcdGNhbmNlbDogXCJpbnB1dCx0ZXh0YXJlYSxidXR0b24sc2VsZWN0LG9wdGlvblwiLFxuXHRcdGRpc3RhbmNlOiAxLFxuXHRcdGRlbGF5OiAwXG5cdH0sXG5cdF9tb3VzZUluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LmJpbmQoXCJtb3VzZWRvd24uXCIrdGhpcy53aWRnZXROYW1lLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRyZXR1cm4gdGhhdC5fbW91c2VEb3duKGV2ZW50KTtcblx0XHRcdH0pXG5cdFx0XHQuYmluZChcImNsaWNrLlwiK3RoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0aWYgKHRydWUgPT09ICQuZGF0YShldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIpKSB7XG5cdFx0XHRcdFx0JC5yZW1vdmVEYXRhKGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIik7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdC8vIFRPRE86IG1ha2Ugc3VyZSBkZXN0cm95aW5nIG9uZSBpbnN0YW5jZSBvZiBtb3VzZSBkb2Vzbid0IG1lc3Mgd2l0aFxuXHQvLyBvdGhlciBpbnN0YW5jZXMgb2YgbW91c2Vcblx0X21vdXNlRGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50LnVuYmluZChcIi5cIit0aGlzLndpZGdldE5hbWUpO1xuXHRcdGlmICggdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgKSB7XG5cdFx0XHQkKGRvY3VtZW50KVxuXHRcdFx0XHQudW5iaW5kKFwibW91c2Vtb3ZlLlwiK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUpXG5cdFx0XHRcdC51bmJpbmQoXCJtb3VzZXVwLlwiK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VVcERlbGVnYXRlKTtcblx0XHR9XG5cdH0sXG5cblx0X21vdXNlRG93bjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvLyBkb24ndCBsZXQgbW9yZSB0aGFuIG9uZSB3aWRnZXQgaGFuZGxlIG1vdXNlU3RhcnRcblx0XHRpZiggbW91c2VIYW5kbGVkICkgeyByZXR1cm47IH1cblxuXHRcdC8vIHdlIG1heSBoYXZlIG1pc3NlZCBtb3VzZXVwIChvdXQgb2Ygd2luZG93KVxuXHRcdCh0aGlzLl9tb3VzZVN0YXJ0ZWQgJiYgdGhpcy5fbW91c2VVcChldmVudCkpO1xuXG5cdFx0dGhpcy5fbW91c2VEb3duRXZlbnQgPSBldmVudDtcblxuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdGJ0bklzTGVmdCA9IChldmVudC53aGljaCA9PT0gMSksXG5cdFx0XHQvLyBldmVudC50YXJnZXQubm9kZU5hbWUgd29ya3MgYXJvdW5kIGEgYnVnIGluIElFIDggd2l0aFxuXHRcdFx0Ly8gZGlzYWJsZWQgaW5wdXRzICgjNzYyMClcblx0XHRcdGVsSXNDYW5jZWwgPSAodHlwZW9mIHRoaXMub3B0aW9ucy5jYW5jZWwgPT09IFwic3RyaW5nXCIgJiYgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID8gJChldmVudC50YXJnZXQpLmNsb3Nlc3QodGhpcy5vcHRpb25zLmNhbmNlbCkubGVuZ3RoIDogZmFsc2UpO1xuXHRcdGlmICghYnRuSXNMZWZ0IHx8IGVsSXNDYW5jZWwgfHwgIXRoaXMuX21vdXNlQ2FwdHVyZShldmVudCkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRoaXMubW91c2VEZWxheU1ldCA9ICF0aGlzLm9wdGlvbnMuZGVsYXk7XG5cdFx0aWYgKCF0aGlzLm1vdXNlRGVsYXlNZXQpIHtcblx0XHRcdHRoaXMuX21vdXNlRGVsYXlUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoYXQubW91c2VEZWxheU1ldCA9IHRydWU7XG5cdFx0XHR9LCB0aGlzLm9wdGlvbnMuZGVsYXkpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9tb3VzZURpc3RhbmNlTWV0KGV2ZW50KSAmJiB0aGlzLl9tb3VzZURlbGF5TWV0KGV2ZW50KSkge1xuXHRcdFx0dGhpcy5fbW91c2VTdGFydGVkID0gKHRoaXMuX21vdXNlU3RhcnQoZXZlbnQpICE9PSBmYWxzZSk7XG5cdFx0XHRpZiAoIXRoaXMuX21vdXNlU3RhcnRlZCkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDbGljayBldmVudCBtYXkgbmV2ZXIgaGF2ZSBmaXJlZCAoR2Vja28gJiBPcGVyYSlcblx0XHRpZiAodHJ1ZSA9PT0gJC5kYXRhKGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIikpIHtcblx0XHRcdCQucmVtb3ZlRGF0YShldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIpO1xuXHRcdH1cblxuXHRcdC8vIHRoZXNlIGRlbGVnYXRlcyBhcmUgcmVxdWlyZWQgdG8ga2VlcCBjb250ZXh0XG5cdFx0dGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlTW92ZShldmVudCk7XG5cdFx0fTtcblx0XHR0aGlzLl9tb3VzZVVwRGVsZWdhdGUgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlVXAoZXZlbnQpO1xuXHRcdH07XG5cdFx0JChkb2N1bWVudClcblx0XHRcdC5iaW5kKFwibW91c2Vtb3ZlLlwiK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUpXG5cdFx0XHQuYmluZChcIm1vdXNldXAuXCIrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUpO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdG1vdXNlSGFuZGxlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X21vdXNlTW92ZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvLyBJRSBtb3VzZXVwIGNoZWNrIC0gbW91c2V1cCBoYXBwZW5lZCB3aGVuIG1vdXNlIHdhcyBvdXQgb2Ygd2luZG93XG5cdFx0aWYgKCQudWkuaWUgJiYgKCAhZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDkgKSAmJiAhZXZlbnQuYnV0dG9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbW91c2VVcChldmVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX21vdXNlU3RhcnRlZCkge1xuXHRcdFx0dGhpcy5fbW91c2VEcmFnKGV2ZW50KTtcblx0XHRcdHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9tb3VzZURpc3RhbmNlTWV0KGV2ZW50KSAmJiB0aGlzLl9tb3VzZURlbGF5TWV0KGV2ZW50KSkge1xuXHRcdFx0dGhpcy5fbW91c2VTdGFydGVkID1cblx0XHRcdFx0KHRoaXMuX21vdXNlU3RhcnQodGhpcy5fbW91c2VEb3duRXZlbnQsIGV2ZW50KSAhPT0gZmFsc2UpO1xuXHRcdFx0KHRoaXMuX21vdXNlU3RhcnRlZCA/IHRoaXMuX21vdXNlRHJhZyhldmVudCkgOiB0aGlzLl9tb3VzZVVwKGV2ZW50KSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICF0aGlzLl9tb3VzZVN0YXJ0ZWQ7XG5cdH0sXG5cblx0X21vdXNlVXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0JChkb2N1bWVudClcblx0XHRcdC51bmJpbmQoXCJtb3VzZW1vdmUuXCIrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSlcblx0XHRcdC51bmJpbmQoXCJtb3VzZXVwLlwiK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VVcERlbGVnYXRlKTtcblxuXHRcdGlmICh0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLl9tb3VzZURvd25FdmVudC50YXJnZXQpIHtcblx0XHRcdFx0JC5kYXRhKGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIiwgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21vdXNlU3RvcChldmVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZURpc3RhbmNlTWV0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiAoTWF0aC5tYXgoXG5cdFx0XHRcdE1hdGguYWJzKHRoaXMuX21vdXNlRG93bkV2ZW50LnBhZ2VYIC0gZXZlbnQucGFnZVgpLFxuXHRcdFx0XHRNYXRoLmFicyh0aGlzLl9tb3VzZURvd25FdmVudC5wYWdlWSAtIGV2ZW50LnBhZ2VZKVxuXHRcdFx0KSA+PSB0aGlzLm9wdGlvbnMuZGlzdGFuY2Vcblx0XHQpO1xuXHR9LFxuXG5cdF9tb3VzZURlbGF5TWV0OiBmdW5jdGlvbigvKiBldmVudCAqLykge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlRGVsYXlNZXQ7XG5cdH0sXG5cblx0Ly8gVGhlc2UgYXJlIHBsYWNlaG9sZGVyIG1ldGhvZHMsIHRvIGJlIG92ZXJyaWRlbiBieSBleHRlbmRpbmcgcGx1Z2luXG5cdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbigvKiBldmVudCAqLykge30sXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKC8qIGV2ZW50ICovKSB7fSxcblx0X21vdXNlU3RvcDogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHt9LFxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbigvKiBldmVudCAqLykgeyByZXR1cm4gdHJ1ZTsgfVxufSk7XG5cbn0pKGpRdWVyeSk7XG4iLCJ2YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8qIVxuICogalF1ZXJ5IFVJIFdpZGdldCAxLjEwLjRcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LndpZGdldC9cbiAqL1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciB1dWlkID0gMCxcblx0c2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG5cdF9jbGVhbkRhdGEgPSAkLmNsZWFuRGF0YTtcbiQuY2xlYW5EYXRhID0gZnVuY3Rpb24oIGVsZW1zICkge1xuXHRmb3IgKCB2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHR0cnkge1xuXHRcdFx0JCggZWxlbSApLnRyaWdnZXJIYW5kbGVyKCBcInJlbW92ZVwiICk7XG5cdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODIzNVxuXHRcdH0gY2F0Y2goIGUgKSB7fVxuXHR9XG5cdF9jbGVhbkRhdGEoIGVsZW1zICk7XG59O1xuXG4kLndpZGdldCA9IGZ1bmN0aW9uKCBuYW1lLCBiYXNlLCBwcm90b3R5cGUgKSB7XG5cdHZhciBmdWxsTmFtZSwgZXhpc3RpbmdDb25zdHJ1Y3RvciwgY29uc3RydWN0b3IsIGJhc2VQcm90b3R5cGUsXG5cdFx0Ly8gcHJveGllZFByb3RvdHlwZSBhbGxvd3MgdGhlIHByb3ZpZGVkIHByb3RvdHlwZSB0byByZW1haW4gdW5tb2RpZmllZFxuXHRcdC8vIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgYSBtaXhpbiBmb3IgbXVsdGlwbGUgd2lkZ2V0cyAoIzg4NzYpXG5cdFx0cHJveGllZFByb3RvdHlwZSA9IHt9LFxuXHRcdG5hbWVzcGFjZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDAgXTtcblxuXHRuYW1lID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMSBdO1xuXHRmdWxsTmFtZSA9IG5hbWVzcGFjZSArIFwiLVwiICsgbmFtZTtcblxuXHRpZiAoICFwcm90b3R5cGUgKSB7XG5cdFx0cHJvdG90eXBlID0gYmFzZTtcblx0XHRiYXNlID0gJC5XaWRnZXQ7XG5cdH1cblxuXHQvLyBjcmVhdGUgc2VsZWN0b3IgZm9yIHBsdWdpblxuXHQkLmV4cHJbIFwiOlwiIF1bIGZ1bGxOYW1lLnRvTG93ZXJDYXNlKCkgXSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgZnVsbE5hbWUgKTtcblx0fTtcblxuXHQkWyBuYW1lc3BhY2UgXSA9ICRbIG5hbWVzcGFjZSBdIHx8IHt9O1xuXHRleGlzdGluZ0NvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXTtcblx0Y29uc3RydWN0b3IgPSAkWyBuYW1lc3BhY2UgXVsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0Ly8gYWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IFwibmV3XCIga2V5d29yZFxuXHRcdGlmICggIXRoaXMuX2NyZWF0ZVdpZGdldCApIHtcblx0XHRcdHJldHVybiBuZXcgY29uc3RydWN0b3IoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cblx0XHQvLyBhbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgaW5pdGlhbGl6aW5nIGZvciBzaW1wbGUgaW5oZXJpdGFuY2Vcblx0XHQvLyBtdXN0IHVzZSBcIm5ld1wiIGtleXdvcmQgKHRoZSBjb2RlIGFib3ZlIGFsd2F5cyBwYXNzZXMgYXJncylcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVXaWRnZXQoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cdH07XG5cdC8vIGV4dGVuZCB3aXRoIHRoZSBleGlzdGluZyBjb25zdHJ1Y3RvciB0byBjYXJyeSBvdmVyIGFueSBzdGF0aWMgcHJvcGVydGllc1xuXHQkLmV4dGVuZCggY29uc3RydWN0b3IsIGV4aXN0aW5nQ29uc3RydWN0b3IsIHtcblx0XHR2ZXJzaW9uOiBwcm90b3R5cGUudmVyc2lvbixcblx0XHQvLyBjb3B5IHRoZSBvYmplY3QgdXNlZCB0byBjcmVhdGUgdGhlIHByb3RvdHlwZSBpbiBjYXNlIHdlIG5lZWQgdG9cblx0XHQvLyByZWRlZmluZSB0aGUgd2lkZ2V0IGxhdGVyXG5cdFx0X3Byb3RvOiAkLmV4dGVuZCgge30sIHByb3RvdHlwZSApLFxuXHRcdC8vIHRyYWNrIHdpZGdldHMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyB3aWRnZXQgaW4gY2FzZSB0aGlzIHdpZGdldCBpc1xuXHRcdC8vIHJlZGVmaW5lZCBhZnRlciBhIHdpZGdldCBpbmhlcml0cyBmcm9tIGl0XG5cdFx0X2NoaWxkQ29uc3RydWN0b3JzOiBbXVxuXHR9KTtcblxuXHRiYXNlUHJvdG90eXBlID0gbmV3IGJhc2UoKTtcblx0Ly8gd2UgbmVlZCB0byBtYWtlIHRoZSBvcHRpb25zIGhhc2ggYSBwcm9wZXJ0eSBkaXJlY3RseSBvbiB0aGUgbmV3IGluc3RhbmNlXG5cdC8vIG90aGVyd2lzZSB3ZSdsbCBtb2RpZnkgdGhlIG9wdGlvbnMgaGFzaCBvbiB0aGUgcHJvdG90eXBlIHRoYXQgd2UncmVcblx0Ly8gaW5oZXJpdGluZyBmcm9tXG5cdGJhc2VQcm90b3R5cGUub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sIGJhc2VQcm90b3R5cGUub3B0aW9ucyApO1xuXHQkLmVhY2goIHByb3RvdHlwZSwgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdGlmICggISQuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHByb3hpZWRQcm90b3R5cGVbIHByb3AgXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgX3N1cGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRfc3VwZXJBcHBseSA9IGZ1bmN0aW9uKCBhcmdzICkge1xuXHRcdFx0XHRcdHJldHVybiBiYXNlLnByb3RvdHlwZVsgcHJvcCBdLmFwcGx5KCB0aGlzLCBhcmdzICk7XG5cdFx0XHRcdH07XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBfX3N1cGVyID0gdGhpcy5fc3VwZXIsXG5cdFx0XHRcdFx0X19zdXBlckFwcGx5ID0gdGhpcy5fc3VwZXJBcHBseSxcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZTtcblxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9zdXBlcjtcblx0XHRcdFx0dGhpcy5fc3VwZXJBcHBseSA9IF9zdXBlckFwcGx5O1xuXG5cdFx0XHRcdHJldHVyblZhbHVlID0gdmFsdWUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gX19zdXBlcjtcblx0XHRcdFx0dGhpcy5fc3VwZXJBcHBseSA9IF9fc3VwZXJBcHBseTtcblxuXHRcdFx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdFx0XHR9O1xuXHRcdH0pKCk7XG5cdH0pO1xuXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLndpZGdldC5leHRlbmQoIGJhc2VQcm90b3R5cGUsIHtcblx0XHQvLyBUT0RPOiByZW1vdmUgc3VwcG9ydCBmb3Igd2lkZ2V0RXZlbnRQcmVmaXhcblx0XHQvLyBhbHdheXMgdXNlIHRoZSBuYW1lICsgYSBjb2xvbiBhcyB0aGUgcHJlZml4LCBlLmcuLCBkcmFnZ2FibGU6c3RhcnRcblx0XHQvLyBkb24ndCBwcmVmaXggZm9yIHdpZGdldHMgdGhhdCBhcmVuJ3QgRE9NLWJhc2VkXG5cdFx0d2lkZ2V0RXZlbnRQcmVmaXg6IGV4aXN0aW5nQ29uc3RydWN0b3IgPyAoYmFzZVByb3RvdHlwZS53aWRnZXRFdmVudFByZWZpeCB8fCBuYW1lKSA6IG5hbWVcblx0fSwgcHJveGllZFByb3RvdHlwZSwge1xuXHRcdGNvbnN0cnVjdG9yOiBjb25zdHJ1Y3Rvcixcblx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZSxcblx0XHR3aWRnZXROYW1lOiBuYW1lLFxuXHRcdHdpZGdldEZ1bGxOYW1lOiBmdWxsTmFtZVxuXHR9KTtcblxuXHQvLyBJZiB0aGlzIHdpZGdldCBpcyBiZWluZyByZWRlZmluZWQgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgYWxsIHdpZGdldHMgdGhhdFxuXHQvLyBhcmUgaW5oZXJpdGluZyBmcm9tIGl0IGFuZCByZWRlZmluZSBhbGwgb2YgdGhlbSBzbyB0aGF0IHRoZXkgaW5oZXJpdCBmcm9tXG5cdC8vIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGlzIHdpZGdldC4gV2UncmUgZXNzZW50aWFsbHkgdHJ5aW5nIHRvIHJlcGxhY2Ugb25lXG5cdC8vIGxldmVsIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5cdGlmICggZXhpc3RpbmdDb25zdHJ1Y3RvciApIHtcblx0XHQkLmVhY2goIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzLCBmdW5jdGlvbiggaSwgY2hpbGQgKSB7XG5cdFx0XHR2YXIgY2hpbGRQcm90b3R5cGUgPSBjaGlsZC5wcm90b3R5cGU7XG5cblx0XHRcdC8vIHJlZGVmaW5lIHRoZSBjaGlsZCB3aWRnZXQgdXNpbmcgdGhlIHNhbWUgcHJvdG90eXBlIHRoYXQgd2FzXG5cdFx0XHQvLyBvcmlnaW5hbGx5IHVzZWQsIGJ1dCBpbmhlcml0IGZyb20gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBiYXNlXG5cdFx0XHQkLndpZGdldCggY2hpbGRQcm90b3R5cGUubmFtZXNwYWNlICsgXCIuXCIgKyBjaGlsZFByb3RvdHlwZS53aWRnZXROYW1lLCBjb25zdHJ1Y3RvciwgY2hpbGQuX3Byb3RvICk7XG5cdFx0fSk7XG5cdFx0Ly8gcmVtb3ZlIHRoZSBsaXN0IG9mIGV4aXN0aW5nIGNoaWxkIGNvbnN0cnVjdG9ycyBmcm9tIHRoZSBvbGQgY29uc3RydWN0b3Jcblx0XHQvLyBzbyB0aGUgb2xkIGNoaWxkIGNvbnN0cnVjdG9ycyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcblx0XHRkZWxldGUgZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnM7XG5cdH0gZWxzZSB7XG5cdFx0YmFzZS5fY2hpbGRDb25zdHJ1Y3RvcnMucHVzaCggY29uc3RydWN0b3IgKTtcblx0fVxuXG5cdCQud2lkZ2V0LmJyaWRnZSggbmFtZSwgY29uc3RydWN0b3IgKTtcbn07XG5cbiQud2lkZ2V0LmV4dGVuZCA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdHZhciBpbnB1dCA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLFxuXHRcdGlucHV0SW5kZXggPSAwLFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdGtleSxcblx0XHR2YWx1ZTtcblx0Zm9yICggOyBpbnB1dEluZGV4IDwgaW5wdXRMZW5ndGg7IGlucHV0SW5kZXgrKyApIHtcblx0XHRmb3IgKCBrZXkgaW4gaW5wdXRbIGlucHV0SW5kZXggXSApIHtcblx0XHRcdHZhbHVlID0gaW5wdXRbIGlucHV0SW5kZXggXVsga2V5IF07XG5cdFx0XHRpZiAoIGlucHV0WyBpbnB1dEluZGV4IF0uaGFzT3duUHJvcGVydHkoIGtleSApICYmIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIENsb25lIG9iamVjdHNcblx0XHRcdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9ICQuaXNQbGFpbk9iamVjdCggdGFyZ2V0WyBrZXkgXSApID9cblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHRhcmdldFsga2V5IF0sIHZhbHVlICkgOlxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgZXh0ZW5kIHN0cmluZ3MsIGFycmF5cywgZXRjLiB3aXRoIG9iamVjdHNcblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHZhbHVlICk7XG5cdFx0XHRcdC8vIENvcHkgZXZlcnl0aGluZyBlbHNlIGJ5IHJlZmVyZW5jZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxuJC53aWRnZXQuYnJpZGdlID0gZnVuY3Rpb24oIG5hbWUsIG9iamVjdCApIHtcblx0dmFyIGZ1bGxOYW1lID0gb2JqZWN0LnByb3RvdHlwZS53aWRnZXRGdWxsTmFtZSB8fCBuYW1lO1xuXHQkLmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIgaXNNZXRob2RDYWxsID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIsXG5cdFx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICksXG5cdFx0XHRyZXR1cm5WYWx1ZSA9IHRoaXM7XG5cblx0XHQvLyBhbGxvdyBtdWx0aXBsZSBoYXNoZXMgdG8gYmUgcGFzc2VkIG9uIGluaXRcblx0XHRvcHRpb25zID0gIWlzTWV0aG9kQ2FsbCAmJiBhcmdzLmxlbmd0aCA/XG5cdFx0XHQkLndpZGdldC5leHRlbmQuYXBwbHkoIG51bGwsIFsgb3B0aW9ucyBdLmNvbmNhdChhcmdzKSApIDpcblx0XHRcdG9wdGlvbnM7XG5cblx0XHRpZiAoIGlzTWV0aG9kQ2FsbCApIHtcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG1ldGhvZFZhbHVlLFxuXHRcdFx0XHRcdGluc3RhbmNlID0gJC5kYXRhKCB0aGlzLCBmdWxsTmFtZSApO1xuXHRcdFx0XHRpZiAoICFpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJjYW5ub3QgY2FsbCBtZXRob2RzIG9uIFwiICsgbmFtZSArIFwiIHByaW9yIHRvIGluaXRpYWxpemF0aW9uOyBcIiArXG5cdFx0XHRcdFx0XHRcImF0dGVtcHRlZCB0byBjYWxsIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICEkLmlzRnVuY3Rpb24oIGluc3RhbmNlW29wdGlvbnNdICkgfHwgb3B0aW9ucy5jaGFyQXQoIDAgKSA9PT0gXCJfXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwibm8gc3VjaCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJyBmb3IgXCIgKyBuYW1lICsgXCIgd2lkZ2V0IGluc3RhbmNlXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZXRob2RWYWx1ZSA9IGluc3RhbmNlWyBvcHRpb25zIF0uYXBwbHkoIGluc3RhbmNlLCBhcmdzICk7XG5cdFx0XHRcdGlmICggbWV0aG9kVmFsdWUgIT09IGluc3RhbmNlICYmIG1ldGhvZFZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBtZXRob2RWYWx1ZSAmJiBtZXRob2RWYWx1ZS5qcXVlcnkgP1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUucHVzaFN0YWNrKCBtZXRob2RWYWx1ZS5nZXQoKSApIDpcblx0XHRcdFx0XHRcdG1ldGhvZFZhbHVlO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGluc3RhbmNlID0gJC5kYXRhKCB0aGlzLCBmdWxsTmFtZSApO1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRcdGluc3RhbmNlLm9wdGlvbiggb3B0aW9ucyB8fCB7fSApLl9pbml0KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRhKCB0aGlzLCBmdWxsTmFtZSwgbmV3IG9iamVjdCggb3B0aW9ucywgdGhpcyApICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcbn07XG5cbiQuV2lkZ2V0ID0gZnVuY3Rpb24oIC8qIG9wdGlvbnMsIGVsZW1lbnQgKi8gKSB7fTtcbiQuV2lkZ2V0Ll9jaGlsZENvbnN0cnVjdG9ycyA9IFtdO1xuXG4kLldpZGdldC5wcm90b3R5cGUgPSB7XG5cdHdpZGdldE5hbWU6IFwid2lkZ2V0XCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcIlwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8ZGl2PlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0ZGlzYWJsZWQ6IGZhbHNlLFxuXG5cdFx0Ly8gY2FsbGJhY2tzXG5cdFx0Y3JlYXRlOiBudWxsXG5cdH0sXG5cdF9jcmVhdGVXaWRnZXQ6IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXHRcdGVsZW1lbnQgPSAkKCBlbGVtZW50IHx8IHRoaXMuZGVmYXVsdEVsZW1lbnQgfHwgdGhpcyApWyAwIF07XG5cdFx0dGhpcy5lbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdHRoaXMudXVpZCA9IHV1aWQrKztcblx0XHR0aGlzLmV2ZW50TmFtZXNwYWNlID0gXCIuXCIgKyB0aGlzLndpZGdldE5hbWUgKyB0aGlzLnV1aWQ7XG5cdFx0dGhpcy5vcHRpb25zID0gJC53aWRnZXQuZXh0ZW5kKCB7fSxcblx0XHRcdHRoaXMub3B0aW9ucyxcblx0XHRcdHRoaXMuX2dldENyZWF0ZU9wdGlvbnMoKSxcblx0XHRcdG9wdGlvbnMgKTtcblxuXHRcdHRoaXMuYmluZGluZ3MgPSAkKCk7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCk7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSAkKCk7XG5cblx0XHRpZiAoIGVsZW1lbnQgIT09IHRoaXMgKSB7XG5cdFx0XHQkLmRhdGEoIGVsZW1lbnQsIHRoaXMud2lkZ2V0RnVsbE5hbWUsIHRoaXMgKTtcblx0XHRcdHRoaXMuX29uKCB0cnVlLCB0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IGVsZW1lbnQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5kb2N1bWVudCA9ICQoIGVsZW1lbnQuc3R5bGUgP1xuXHRcdFx0XHQvLyBlbGVtZW50IHdpdGhpbiB0aGUgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5vd25lckRvY3VtZW50IDpcblx0XHRcdFx0Ly8gZWxlbWVudCBpcyB3aW5kb3cgb3IgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5kb2N1bWVudCB8fCBlbGVtZW50ICk7XG5cdFx0XHR0aGlzLndpbmRvdyA9ICQoIHRoaXMuZG9jdW1lbnRbMF0uZGVmYXVsdFZpZXcgfHwgdGhpcy5kb2N1bWVudFswXS5wYXJlbnRXaW5kb3cgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jcmVhdGUoKTtcblx0XHR0aGlzLl90cmlnZ2VyKCBcImNyZWF0ZVwiLCBudWxsLCB0aGlzLl9nZXRDcmVhdGVFdmVudERhdGEoKSApO1xuXHRcdHRoaXMuX2luaXQoKTtcblx0fSxcblx0X2dldENyZWF0ZU9wdGlvbnM6ICQubm9vcCxcblx0X2dldENyZWF0ZUV2ZW50RGF0YTogJC5ub29wLFxuXHRfY3JlYXRlOiAkLm5vb3AsXG5cdF9pbml0OiAkLm5vb3AsXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fZGVzdHJveSgpO1xuXHRcdC8vIHdlIGNhbiBwcm9iYWJseSByZW1vdmUgdGhlIHVuYmluZCBjYWxscyBpbiAyLjBcblx0XHQvLyBhbGwgZXZlbnQgYmluZGluZ3Mgc2hvdWxkIGdvIHRocm91Z2ggdGhpcy5fb24oKVxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnVuYmluZCggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQvLyAxLjkgQkMgZm9yICM3ODEwXG5cdFx0XHQvLyBUT0RPIHJlbW92ZSBkdWFsIHN0b3JhZ2Vcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldE5hbWUgKVxuXHRcdFx0LnJlbW92ZURhdGEoIHRoaXMud2lkZ2V0RnVsbE5hbWUgKVxuXHRcdFx0Ly8gc3VwcG9ydDoganF1ZXJ5IDwxLjYuM1xuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTQxM1xuXHRcdFx0LnJlbW92ZURhdGEoICQuY2FtZWxDYXNlKCB0aGlzLndpZGdldEZ1bGxOYW1lICkgKTtcblx0XHR0aGlzLndpZGdldCgpXG5cdFx0XHQudW5iaW5kKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtZGlzYWJsZWRcIiApXG5cdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcIi1kaXNhYmxlZCBcIiArXG5cdFx0XHRcdFwidWktc3RhdGUtZGlzYWJsZWRcIiApO1xuXG5cdFx0Ly8gY2xlYW4gdXAgZXZlbnRzIGFuZCBzdGF0ZXNcblx0XHR0aGlzLmJpbmRpbmdzLnVuYmluZCggdGhpcy5ldmVudE5hbWVzcGFjZSApO1xuXHRcdHRoaXMuaG92ZXJhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHR0aGlzLmZvY3VzYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdH0sXG5cdF9kZXN0cm95OiAkLm5vb3AsXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50O1xuXHR9LFxuXG5cdG9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBrZXksXG5cdFx0XHRwYXJ0cyxcblx0XHRcdGN1ck9wdGlvbixcblx0XHRcdGk7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHQvLyBkb24ndCByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGhhc2hcblx0XHRcdHJldHVybiAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHQvLyBoYW5kbGUgbmVzdGVkIGtleXMsIGUuZy4sIFwiZm9vLmJhclwiID0+IHsgZm9vOiB7IGJhcjogX19fIH0gfVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0cGFydHMgPSBrZXkuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHRrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0aWYgKCBwYXJ0cy5sZW5ndGggKSB7XG5cdFx0XHRcdGN1ck9wdGlvbiA9IG9wdGlvbnNbIGtleSBdID0gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zWyBrZXkgXSApO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKyApIHtcblx0XHRcdFx0XHRjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdIHx8IHt9O1xuXHRcdFx0XHRcdGN1ck9wdGlvbiA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleSA9IHBhcnRzLnBvcCgpO1xuXHRcdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGN1ck9wdGlvblsga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdXJPcHRpb25bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN1ck9wdGlvblsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHRoaXMub3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zZXRPcHRpb25zKCBvcHRpb25zICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBrZXk7XG5cblx0XHRmb3IgKCBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdHRoaXMuX3NldE9wdGlvbigga2V5LCBvcHRpb25zWyBrZXkgXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR0aGlzLm9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoIHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcIi1kaXNhYmxlZCB1aS1zdGF0ZS1kaXNhYmxlZFwiLCAhIXZhbHVlIClcblx0XHRcdFx0LmF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiLCB2YWx1ZSApO1xuXHRcdFx0dGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0dGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbiggXCJkaXNhYmxlZFwiLCBmYWxzZSApO1xuXHR9LFxuXHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCBcImRpc2FibGVkXCIsIHRydWUgKTtcblx0fSxcblxuXHRfb246IGZ1bmN0aW9uKCBzdXBwcmVzc0Rpc2FibGVkQ2hlY2ssIGVsZW1lbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBkZWxlZ2F0ZUVsZW1lbnQsXG5cdFx0XHRpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHQvLyBubyBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgZmxhZywgc2h1ZmZsZSBhcmd1bWVudHNcblx0XHRpZiAoIHR5cGVvZiBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgIT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0aGFuZGxlcnMgPSBlbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IHN1cHByZXNzRGlzYWJsZWRDaGVjaztcblx0XHRcdHN1cHByZXNzRGlzYWJsZWRDaGVjayA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIG5vIGVsZW1lbnQgYXJndW1lbnQsIHNodWZmbGUgYW5kIHVzZSB0aGlzLmVsZW1lbnRcblx0XHRpZiAoICFoYW5kbGVycyApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRkZWxlZ2F0ZUVsZW1lbnQgPSB0aGlzLndpZGdldCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBhY2NlcHQgc2VsZWN0b3JzLCBET00gZWxlbWVudHNcblx0XHRcdGVsZW1lbnQgPSBkZWxlZ2F0ZUVsZW1lbnQgPSAkKCBlbGVtZW50ICk7XG5cdFx0XHR0aGlzLmJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5hZGQoIGVsZW1lbnQgKTtcblx0XHR9XG5cblx0XHQkLmVhY2goIGhhbmRsZXJzLCBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXIgKSB7XG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVyUHJveHkoKSB7XG5cdFx0XHRcdC8vIGFsbG93IHdpZGdldHMgdG8gY3VzdG9taXplIHRoZSBkaXNhYmxlZCBoYW5kbGluZ1xuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGFzIGFuIGFycmF5IGluc3RlYWQgb2YgYm9vbGVhblxuXHRcdFx0XHQvLyAtIGRpc2FibGVkIGNsYXNzIGFzIG1ldGhvZCBmb3IgZGlzYWJsaW5nIGluZGl2aWR1YWwgcGFydHNcblx0XHRcdFx0aWYgKCAhc3VwcHJlc3NEaXNhYmxlZENoZWNrICYmXG5cdFx0XHRcdFx0XHQoIGluc3RhbmNlLm9wdGlvbnMuZGlzYWJsZWQgPT09IHRydWUgfHxcblx0XHRcdFx0XHRcdFx0JCggdGhpcyApLmhhc0NsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKSApICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJzdHJpbmdcIiA/IGluc3RhbmNlWyBoYW5kbGVyIF0gOiBoYW5kbGVyIClcblx0XHRcdFx0XHQuYXBwbHkoIGluc3RhbmNlLCBhcmd1bWVudHMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY29weSB0aGUgZ3VpZCBzbyBkaXJlY3QgdW5iaW5kaW5nIHdvcmtzXG5cdFx0XHRpZiAoIHR5cGVvZiBoYW5kbGVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRoYW5kbGVyUHJveHkuZ3VpZCA9IGhhbmRsZXIuZ3VpZCA9XG5cdFx0XHRcdFx0aGFuZGxlci5ndWlkIHx8IGhhbmRsZXJQcm94eS5ndWlkIHx8ICQuZ3VpZCsrO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWF0Y2ggPSBldmVudC5tYXRjaCggL14oXFx3KylcXHMqKC4qKSQvICksXG5cdFx0XHRcdGV2ZW50TmFtZSA9IG1hdGNoWzFdICsgaW5zdGFuY2UuZXZlbnROYW1lc3BhY2UsXG5cdFx0XHRcdHNlbGVjdG9yID0gbWF0Y2hbMl07XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRkZWxlZ2F0ZUVsZW1lbnQuZGVsZWdhdGUoIHNlbGVjdG9yLCBldmVudE5hbWUsIGhhbmRsZXJQcm94eSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudC5iaW5kKCBldmVudE5hbWUsIGhhbmRsZXJQcm94eSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9vZmY6IGZ1bmN0aW9uKCBlbGVtZW50LCBldmVudE5hbWUgKSB7XG5cdFx0ZXZlbnROYW1lID0gKGV2ZW50TmFtZSB8fCBcIlwiKS5zcGxpdCggXCIgXCIgKS5qb2luKCB0aGlzLmV2ZW50TmFtZXNwYWNlICsgXCIgXCIgKSArIHRoaXMuZXZlbnROYW1lc3BhY2U7XG5cdFx0ZWxlbWVudC51bmJpbmQoIGV2ZW50TmFtZSApLnVuZGVsZWdhdGUoIGV2ZW50TmFtZSApO1xuXHR9LFxuXG5cdF9kZWxheTogZnVuY3Rpb24oIGhhbmRsZXIsIGRlbGF5ICkge1xuXHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHQuYXBwbHkoIGluc3RhbmNlLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdFx0dmFyIGluc3RhbmNlID0gdGhpcztcblx0XHRyZXR1cm4gc2V0VGltZW91dCggaGFuZGxlclByb3h5LCBkZWxheSB8fCAwICk7XG5cdH0sXG5cblx0X2hvdmVyYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSB0aGlzLmhvdmVyYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0bW91c2VlbnRlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fSxcblx0XHRcdG1vdXNlbGVhdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfZm9jdXNhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmZvY3VzYWJsZSA9IHRoaXMuZm9jdXNhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRmb2N1c2luOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9LFxuXHRcdFx0Zm9jdXNvdXQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBkYXRhICkge1xuXHRcdHZhciBwcm9wLCBvcmlnLFxuXHRcdFx0Y2FsbGJhY2sgPSB0aGlzLm9wdGlvbnNbIHR5cGUgXTtcblxuXHRcdGRhdGEgPSBkYXRhIHx8IHt9O1xuXHRcdGV2ZW50ID0gJC5FdmVudCggZXZlbnQgKTtcblx0XHRldmVudC50eXBlID0gKCB0eXBlID09PSB0aGlzLndpZGdldEV2ZW50UHJlZml4ID9cblx0XHRcdHR5cGUgOlxuXHRcdFx0dGhpcy53aWRnZXRFdmVudFByZWZpeCArIHR5cGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdC8vIHRoZSBvcmlnaW5hbCBldmVudCBtYXkgY29tZSBmcm9tIGFueSBlbGVtZW50XG5cdFx0Ly8gc28gd2UgbmVlZCB0byByZXNldCB0aGUgdGFyZ2V0IG9uIHRoZSBuZXcgZXZlbnRcblx0XHRldmVudC50YXJnZXQgPSB0aGlzLmVsZW1lbnRbIDAgXTtcblxuXHRcdC8vIGNvcHkgb3JpZ2luYWwgZXZlbnQgcHJvcGVydGllcyBvdmVyIHRvIHRoZSBuZXcgZXZlbnRcblx0XHRvcmlnID0gZXZlbnQub3JpZ2luYWxFdmVudDtcblx0XHRpZiAoIG9yaWcgKSB7XG5cdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdGlmICggISggcHJvcCBpbiBldmVudCApICkge1xuXHRcdFx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlciggZXZlbnQsIGRhdGEgKTtcblx0XHRyZXR1cm4gISggJC5pc0Z1bmN0aW9uKCBjYWxsYmFjayApICYmXG5cdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcy5lbGVtZW50WzBdLCBbIGV2ZW50IF0uY29uY2F0KCBkYXRhICkgKSA9PT0gZmFsc2UgfHxcblx0XHRcdGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICk7XG5cdH1cbn07XG5cbiQuZWFjaCggeyBzaG93OiBcImZhZGVJblwiLCBoaWRlOiBcImZhZGVPdXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBkZWZhdWx0RWZmZWN0ICkge1xuXHQkLldpZGdldC5wcm90b3R5cGVbIFwiX1wiICsgbWV0aG9kIF0gPSBmdW5jdGlvbiggZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGVmZmVjdDogb3B0aW9ucyB9O1xuXHRcdH1cblx0XHR2YXIgaGFzT3B0aW9ucyxcblx0XHRcdGVmZmVjdE5hbWUgPSAhb3B0aW9ucyA/XG5cdFx0XHRcdG1ldGhvZCA6XG5cdFx0XHRcdG9wdGlvbnMgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0XHRcdGRlZmF1bHRFZmZlY3QgOlxuXHRcdFx0XHRcdG9wdGlvbnMuZWZmZWN0IHx8IGRlZmF1bHRFZmZlY3Q7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGR1cmF0aW9uOiBvcHRpb25zIH07XG5cdFx0fVxuXHRcdGhhc09wdGlvbnMgPSAhJC5pc0VtcHR5T2JqZWN0KCBvcHRpb25zICk7XG5cdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNhbGxiYWNrO1xuXHRcdGlmICggb3B0aW9ucy5kZWxheSApIHtcblx0XHRcdGVsZW1lbnQuZGVsYXkoIG9wdGlvbnMuZGVsYXkgKTtcblx0XHR9XG5cdFx0aWYgKCBoYXNPcHRpb25zICYmICQuZWZmZWN0cyAmJiAkLmVmZmVjdHMuZWZmZWN0WyBlZmZlY3ROYW1lIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBtZXRob2QgXSggb3B0aW9ucyApO1xuXHRcdH0gZWxzZSBpZiAoIGVmZmVjdE5hbWUgIT09IG1ldGhvZCAmJiBlbGVtZW50WyBlZmZlY3ROYW1lIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBlZmZlY3ROYW1lIF0oIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuZWFzaW5nLCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50LnF1ZXVlKGZ1bmN0aW9uKCBuZXh0ICkge1xuXHRcdFx0XHQkKCB0aGlzIClbIG1ldGhvZCBdKCk7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCggZWxlbWVudFsgMCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV4dCgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xufSk7XG5cbn0pKCBqUXVlcnkgKTtcbiIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbnZhciBHZW5lcmljRmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvZ2VuZXJpYy1maWx0ZXItbW9kZWwnKTtcbnZhciBPcmdSb2xlRmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvb3JnLXJvbGUtZmlsdGVyLW1vZGVsJyk7XG52YXIgWWVhcnNGaWx0ZXJNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy95ZWFycy1maWx0ZXItbW9kZWwnKTtcblxuXG4vL1RPRE86IG1vdmUgbW9zdCBjb2RlIGZyb20gZmlsdGVycy12aWV3IGhlcmUuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgdXJsOiAnL3Jlc3QvZmlsdGVycycsXG4gIF9sb2FkZWQ6IG51bGwsXG4gIF9hbGxEZWZlcnJlZHM6IFtdLFxuICBvcmdDb2xsZWN0aW9uOiBudWxsLFxuICBvcmdHcm91cENvbGxlY3Rpb246IG51bGwsXG4gIG9yZ1R5cGVDb2xsZWN0aW9uOiBudWxsLFxuICBjb21wb25lbnRDYWxsZXI6IG51bGwsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obW9kZWxzLG9wdGlvbnMpIHtcbiAgICB0aGlzLm9uKCdhZGQnLCB0aGlzLl9jbGVhblVwQWZ0ZXJBZGQpO1xuICAgIHRoaXMubG9hZCgpO1xuICAgIGlmIChvcHRpb25zLmNhbGxlcikge1xuICAgIFx0Y29tcG9uZW50Q2FsbGVyID0gb3B0aW9ucy5jYWxsZXI7XG4gICAgfVxuICB9LFxuXG4gIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmKCF0aGlzLl9sb2FkZWQpe1xuICAgICAgdGhpcy5fbG9hZGVkID0gbmV3ICQuRGVmZXJyZWQoKTtcbiAgICAgIHRoaXMuX2FsbERlZmVycmVkcy5wdXNoKHRoaXMuX2NyZWF0ZU9yZ0ZpbHRlcnMoKSk7XG5cbiAgICAgIHRoaXMuZmV0Y2goe3JlbW92ZTogZmFsc2V9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB3aGVuIGFsbCBjaGlsZCBjYWxscyBhcmUgZG9uZSByZXNvbHZlLlxuICAgICAgICAkLndoZW4uYXBwbHkoJCwgc2VsZi5fYWxsRGVmZXJyZWRzKVxuICAgICAgICAgIC5kb25lKHNlbGYuX2xvYWRlZC5yZXNvbHZlKVxuICAgICAgICAgIC5mYWlsKHNlbGYuX2xvYWRlZC5yZWplY3QpO1xuICAgICAgfSkuZmFpbChzZWxmLl9sb2FkZWQucmVqZWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbG9hZGVkO1xuICB9LFxuXG4gIF9jbGVhblVwQWZ0ZXJBZGQ6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIHJlbW92ZSBpZiB1aSBmYWxzZSBhbHNvIGNhdGNoZXMgZW1wdHkgZHVtbXkgZmlsdGVycyB3ZSBhZGQgaW4gJ21vZGVsJyBmdW5jdGlvbiBiZWxvdy5cbiAgICBpZiAoIW1vZGVsLmdldCgndWknKSkge1xuICAgICAgc2VsZi5yZW1vdmUobW9kZWwpO1xuICAgIH1cbiAgICAvL3JlbW92ZSBpZiB0aGUgZW5kcG9pbnQgcmV0dXJucyB0aGUgZmlsdGVyIHR5cGUgKGRhc2hib2FyZCx0YWJzLHJlcG9ydHMgYW5kL29yIEdJUykgZm9yIHdoaWNoXG4gICAgLy90aGUgbW9kZWwgc2hvdWxkIGJlIHZpc2libGUgYW5kIHRoZSBjYWxsZXIgaXMgbm90IG9mIHRoZSBzYW1lIHRwZVxuICAgIFxuICAgIGlmIChtb2RlbC5nZXQoJ2ZpbHRlclR5cGUnKSkge1xuICAgIFx0Ly8gQ09OU1RBTlRJTjogaGVyZSBmaWx0ZXJpbmcgaXJyZWxldmFudCBjb2x1bW5zIGZvciB0aGUgc2V0IGZpbHRlciB0eXBlIGFyZSBmaWx0ZXJlZCBvdXRcbiAgICBcdHZhciBpc09mUmVxdWlyZWRUeXBlID0gXy5zb21lKCBtb2RlbC5nZXQoJ2ZpbHRlclR5cGUnKSwgZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgXHQgICAgcmV0dXJuIHR5cGUgPT09IGNvbXBvbmVudENhbGxlciB8fCB0eXBlID09PSBcIkFMTFwiO1xuICAgIFx0fSk7XG4gICAgXHQvL2NvbnNvbGUubG9nKFwiZGVjaWRlZCB3aGV0aGVyIHRvIHNob3cgY29sdW1uIFwiICsgbW9kZWwuZ2V0KFwibmFtZVwiKSArIFwiOiBcIiArIGlzT2ZSZXF1aXJlZFR5cGUpXG4gICAgXHRpZiAoIWlzT2ZSZXF1aXJlZFR5cGUpIHtcbiAgICBcdFx0c2VsZi5yZW1vdmUgKG1vZGVsKTtcbiAgICBcdH1cbiAgICB9XG4gICAgLy8gRXhwb3NlIHRoaXMgZmllbGQgZm9yIGxhdGVyIHVzYWdlLlxuICAgIHRoaXMuY29tcG9uZW50Q2FsbGVyID0gY29tcG9uZW50Q2FsbGVyO1xuICB9LFxuXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAvL29ubHkga2VlcCBmaWx0ZXJzIHdpdGggdWkgPT0gdHJ1ZTtcbiAgICBkYXRhID0gXy5maWx0ZXIoZGF0YSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLnVpO1xuICAgIH0pO1xuXG4gICAgLy9yZW1vdmUgb3JncywgZ3JvdXBzLCBhbmQgdHlwZXMsIGJlY2F1c2UgdGhleSBhcmUgbm90IGZpbHRlcnMgb24gdGhlaXIgb3duLlxuICAgIC8vIFdlIHVzZSB0aGVtIGRvd24gYmVsb3cuXG4gICAgZGF0YSA9IF8uZmlsdGVyKGRhdGEsIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIChvYmouZW5kcG9pbnQgIT09ICcvcmVzdC9maWx0ZXJzL29yZy1ncm91cHMnICYmXG4gICAgICAgIG9iai5lbmRwb2ludCAhPT0gJy9yZXN0L2ZpbHRlcnMvb3JnLXR5cGVzJyAmJlxuICAgICAgICBvYmouZW5kcG9pbnQgIT09ICcvcmVzdC9maWx0ZXJzL29yZy1yb2xlcycgJiZcbiAgICAgICAgb2JqLmVuZHBvaW50ICE9PSAnL3Jlc3QvZmlsdGVycy9vcmdzJyk7XG4gICAgfSk7XG5cblxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG5cbiAgbW9kZWw6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgdmFyIHRtcE1vZGVsID0gbnVsbDtcblxuICAgIC8vIHNsaWdodGx5IHVuY29udmVudGlvbmFsLCBidXQgbW9kZWwgaXMgc3BlY2lhbCBjYXNlIHNpbmNlIGl0J3MgY2FsbGVkIHdpdGhcbiAgICAvLyBuZXcgc28gJ3RoaXMnIHdvbnQgYmUgdGhlIGNvbGxlY3Rpb24uXG4gICAgdmFyIHNlbGYgPSBvcHRpb25zLmNvbGxlY3Rpb247XG5cbiAgICAvLyBzd2l0Y2ggZm9yIG1vZGVsIHBvbHltb3JwaGlzbS5cbiAgICBzd2l0Y2ggKGF0dHJzLmlkKSB7XG4gICAgICBjYXNlICdQcm9ncmFtcyc6XG4gICAgICBjYXNlICdTZWN0b3JzJzpcbiAgICAgICAgc2VsZi5fYWxsRGVmZXJyZWRzLnB1c2goc2VsZi5fZ29PbmVEZWVwZXIoc2VsZiwgYXR0cnMpKTtcbiAgICAgICAgLy90bXAgaGFjayBiZWNhdXNlIHdlIG5lZWQgdG8gcmV0dXJuIHNvbWV0aGluZy5cbiAgICAgICAgdG1wTW9kZWwgPSBuZXcgQmFja2JvbmUuTW9kZWwoe3VpOmZhbHNlfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBcbiAgICAgIGRlZmF1bHQ6XG4gICAgXHQgIGlmIChhdHRycy5pZCA9PSAnRGF0ZXMnIHx8IChhdHRycy5pZC5sZW5ndGggPiA0ICYmIGF0dHJzLmlkLnN1YnN0cmluZyhhdHRycy5pZC5sZW5ndGggLSA0KSA9PSAnRGF0ZScpKSB7XG4gICAgXHRcdCAgdG1wTW9kZWwgPSBuZXcgWWVhcnNGaWx0ZXJNb2RlbChhdHRycyk7ICAvLyBoYWNreSBidXQgbGVzcyBoYWNreSB0aGFuIGVudW1lcmF0aW5nIHRoZW0uIExvbmcgdGVybSBzb2x1dGlvbiAtPiB0aGUgZW5kcG9pbnQgc2hvdWxkIHJldHVybiBhIGZpZWxkIHRlbGxpbmcgdGhlIHR5cGUgb2YgYSBmaWVsZFxuICAgIFx0ICB9IGVsc2Uge1xuICAgIFx0XHQgIHRtcE1vZGVsID0gbmV3IEdlbmVyaWNGaWx0ZXJNb2RlbChhdHRycyk7XG4gICAgXHRcdCAgc2VsZi5fYWxsRGVmZXJyZWRzLnB1c2godG1wTW9kZWwuZ2V0VHJlZSgpKTtcbiAgICBcdCAgfVxuICAgIH1cblxuICAgIHJldHVybiB0bXBNb2RlbDtcbiAgfSxcblxuICAvLyBnZXQgZW5kcG9pbnQncyBjaGlsZHJlbiBhbmQgbG9hZCB0aGVtIGludG8gc2VsZi4uLlxuICBfZ29PbmVEZWVwZXI6IGZ1bmN0aW9uKHNlbGYsIGF0dHJzKSB7XG4gICAgdmFyIHVybCA9IGF0dHJzLmVuZHBvaW50O1xuICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcbiAgICB2YXIgdG1wRGVmZXJyZWRzID0gW107XG5cbiAgICB2YXIgdG1wQ29sbGVjdGlvbiA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKCk7XG4gICAgdG1wQ29sbGVjdGlvbi51cmwgPSB1cmw7XG4gICAgdG1wQ29sbGVjdGlvbi5mZXRjaCgpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgXy5lYWNoKGRhdGEsIGZ1bmN0aW9uKEFQSUZpbHRlcikge1xuICAgICAgICB2YXIgdG1wTW9kZWwgPSBuZXcgR2VuZXJpY0ZpbHRlck1vZGVsKHtcbiAgICAgICAgICB1cmw6IHVybCArICcvJyArIEFQSUZpbHRlci5pZCxcbiAgICAgICAgICBuYW1lOiBBUElGaWx0ZXIubmFtZSxcbiAgICAgICAgICB1aTogdHJ1ZSxcbiAgICAgICAgICBncm91cDogYXR0cnMuaWQsXG4gICAgICAgICAgZW1wdHk6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLmFkZCh0bXBNb2RlbCk7XG4gICAgICAgIHRtcERlZmVycmVkcy5wdXNoKHRtcE1vZGVsLmdldFRyZWUoKSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKF8uaXNFbXB0eShkYXRhKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZpbHRlcnMgQVBJIHJldHVybmVkIGVtcHR5JywgdXJsKTtcbiAgICAgICAgLy8gQ3JlYXRlIGVtcHR5IG1vZGVsIHNvIHRoZSB2aWV3IGRvZXNudCBmYWlsLlxuICAgICAgICB2YXIgdG1wTW9kZWwgPSBuZXcgR2VuZXJpY0ZpbHRlck1vZGVsKHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgbmFtZTogYXR0cnMubmFtZSxcbiAgICAgICAgICAgIHVpOiB0cnVlLFxuICAgICAgICAgICAgZ3JvdXA6IGF0dHJzLmlkLFxuICAgICAgICAgICAgZW1wdHk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmFkZCh0bXBNb2RlbCk7XG4gICAgICAgICAgdG1wRGVmZXJyZWRzLnB1c2godG1wTW9kZWwuZ2V0VHJlZSgpKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgJC53aGVuLmFwcGx5KCQsIHRtcERlZmVycmVkcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH0sXG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTcGVjaWFsIG9yZyBhbmQgZG9ub3Igc3BlY2lmaWMgY29kZSBzaW5jZSBpdCBoYXMgc3BlY2lhbCBiZWhhdmlvdXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIF9jcmVhdGVPcmdGaWx0ZXJzOmZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIENyZWF0ZSAnam9pbnMnIGZvciBlYWNoIHR5cGUgYWRkIHJlZiB0byBncm91cHMsIGFuZCBmb3IgZWFjaCBncm91cCBhZGQgcmVmcyB0byBvcmdzLlxuICAgIHJldHVybiB0aGlzLl9mZXRjaE9yZ0NvbGxlY3Rpb25zKCkudGhlbihmdW5jdGlvbigpIHtcblxuICAgICAgLy8ganNvbmlmeSBvcmdzIGFuZCBzZXQgdGhlbSBhcyBjaGlsZHJlbiBpbiBncm91cHMuXG4gICAgICBzZWxmLm1ha2VUcmVlSGVscGVyKHNlbGYub3JnR3JvdXBDb2xsZWN0aW9uLCBzZWxmLm9yZ0NvbGxlY3Rpb24sICdvcmdJZHMnLCAnY2hpbGRyZW4nKTtcblxuXG4gICAgICAvLyBGb3IgZWFjaCByb2xlIGNyZWF0ZSBhIGZpbHRlciB3aXRoIGNvbGxlY3Rpb24gb2YganVzdCBvcmdzIHRoYXQgbWF0Y2guXG4gICAgICBzZWxmLm9yZ1JvbGVzQ29sbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKHJvbGUpIHtcbiAgICAgICAgdmFyIHRtcEpTT04gPSByb2xlLnRvSlNPTigpO1xuXG4gICAgICAgIC8vIHRyZWF0IGRvbm9yIGRpZmZlcmVudGx5Li4uXG4gICAgICAgIGlmIChyb2xlLmdldCgnbmFtZScpID09PSAnRG9ub3InKSB7XG4gICAgICAgICAgc2VsZi5tYWtlVHJlZUhlbHBlcihzZWxmLm9yZ1R5cGVDb2xsZWN0aW9uLCBzZWxmLm9yZ0dyb3VwQ29sbGVjdGlvbiwgJ2dyb3VwSWRzJywgJ2NoaWxkcmVuJyk7XG4gICAgICAgICAgLy8gQ3JlYXRlIHRyZWUgcm9vdE5vZGUgYW5kIHJhdyBKU09OLlxuICAgICAgICAgIF8uZXh0ZW5kKHRtcEpTT04sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHVpOiB0cnVlLFxuICAgICAgICAgICAgICBncm91cDogJ0Rvbm9yJyxcbiAgICAgICAgICAgICAgZGF0YTogc2VsZi5vcmdUeXBlQ29sbGVjdGlvbi50b0pTT04oKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBmaWx0ZXIgb3Jncy4uLlxuICAgICAgICAgIHRtcEpTT04uZGF0YSA9IHNlbGYuX2ZpbHRlckRvbm9yT3Jncyh0bXBKU09OLmRhdGEsIHJvbGUuaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENyZWF0ZSB0cmVlIHJvb3ROb2RlIGFuZCByYXcgSlNPTi5cbiAgICAgICAgICBfLmV4dGVuZCh0bXBKU09OLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB1aTogdHJ1ZSxcbiAgICAgICAgICAgICAgZ3JvdXA6ICdSb2xlJywgLy9UT0RPOiA/c2hvdWxkIHRoaXMgYmUgJ1JvbGUnIG9yIHJvbGUuaWQgb3Igcm9sZS5nZXQoJ25hbWUnKT9cbiAgICAgICAgICAgICAgZGF0YTogc2VsZi5vcmdHcm91cENvbGxlY3Rpb24udG9KU09OKClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy9yZW1vdmUgYWxsIG9yZ3MgdGhhdCBkb24ndCBiZWxvbmcgaW4gdGhpcyByb2xlXG4gICAgICAgICAgdG1wSlNPTi5kYXRhID0gc2VsZi5fZmlsdGVyT3Jncyh0bXBKU09OLmRhdGEsIHJvbGUuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRtcEpTT04uZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRGaWx0ZXJJZCA9IHJvbGUuZ2V0KCduYW1lJykgKyBcIiBJZFwiO1xuICAgICAgICAgIHRtcEpTT04uZGF0YSA9IHNlbGYuX3NldEZpbHRlcklkKHRtcEpTT04uZGF0YSwgY3VycmVudEZpbHRlcklkKTtcbiAgICAgICAgICBzZWxmLmFkZChuZXcgT3JnUm9sZUZpbHRlck1vZGVsKHRtcEpTT04pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vb25seSBuZWVkZWQgZm9yIGRvbm9yIGlmIHdlIHdhbnQgdG8gZG8gc3BlY2lhbCBsaXN0ZW5pbmcuLi4uOlxuICAgICAgLy8gc2VsZi5qb2luSGVscGVyKHNlbGYub3JnVHlwZUNvbGxlY3Rpb24sIHNlbGYub3JnR3JvdXBDb2xsZWN0aW9uLCAnZ3JvdXBJZHMnLCAnZ3JvdXBzJyk7XG4gICAgICAvLyBzZWxmLmpvaW5IZWxwZXIoc2VsZi5vcmdHcm91cENvbGxlY3Rpb24sIHNlbGYub3JnQ29sbGVjdGlvbiwgJ29yZ0lkcycsICdvcmdzJyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gZXhwbGljaXRseSBzZXRzIHRoZSBmaWx0ZXIgaWQgb24gYWxsIHRoZSBvcmdzLlxuICBfc2V0RmlsdGVySWQ6IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGZpbHRlcklkKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXy5lYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKG9yZykge1xuICAgICAgLy9vbmx5IHNldCBmaWx0ZXJJZCBvbiBvcmdzLCBub3QgZ3JvdXAgb3IgdHlwZSwgb3IgaXQgd2lsbCBjYXVzZSBidWdzLlxuICAgICAgaWYob3JnLnJvbGVzSWRzKXtcbiAgICAgICAgb3JnLmZpbHRlcklkID0gZmlsdGVySWQ7XG4gICAgICB9XG4gICAgICBpZihvcmcuY2hpbGRyZW4pe1xuICAgICAgICBvcmcuY2hpbGRyZW4gPSBzZWxmLl9zZXRGaWx0ZXJJZChvcmcuY2hpbGRyZW4sIGZpbHRlcklkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9LFxuXG5cblxuICAvLyBmaWx0ZXIgb3JncyB0cmVlIHRvIG9ubHkgb3JncyB0aGF0IGFwcGVhciBhcyB0aGUgZ2l2ZW4gcm9sZUlEXG4gIF9maWx0ZXJPcmdzOiBmdW5jdGlvbihvcmdHcm91cHNKU09OLCByb2xlSUQpIHtcbiAgICBvcmdHcm91cHNKU09OID0gXy5maWx0ZXIob3JnR3JvdXBzSlNPTiwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgIGdyb3VwLmNoaWxkcmVuID0gXy5maWx0ZXIoZ3JvdXAuY2hpbGRyZW4sIGZ1bmN0aW9uKG9yZykge1xuICAgICAgICByZXR1cm4gKG9yZy5yb2xlc0lkcy5pbmRleE9mKHJvbGVJRCkgPiAtMSk7XG4gICAgICB9KTtcbiAgICAgIGdyb3VwLmlzU2VsZWN0YWJsZSA9IGZhbHNlOyAvL3N0b3BzIHRyZWUgZnJvbSBjcmVhdGluZyAndW5rb3duJyBjaGlsZHJlbi5cbiAgICAgIHJldHVybiAoZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoID4gMCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9yZ0dyb3Vwc0pTT047XG4gIH0sXG5cblxuXHQgIC8vIHNwZWNpYWwgY2FzZSBmb3IgZG9ub3IgdHJlZSwgc2luY2UgaXQgaGFzIHR5cGVcblx0X2ZpbHRlckRvbm9yT3JncyA6IGZ1bmN0aW9uKG9yZ1R5cGVzSlNPTiwgcm9sZUlEKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdG9yZ1R5cGVzSlNPTiA9IF8uZmlsdGVyKG9yZ1R5cGVzSlNPTiwgZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dHlwZS5jaGlsZHJlbiA9IHNlbGYuX2ZpbHRlck9yZ3ModHlwZS5jaGlsZHJlbiwgcm9sZUlEKTtcblxuXHRcdFx0Ly8gVGhlIGxpc3Qgb2YgXCJEb25vclwiIGhhcyBzb21lIHNwZWNpYWwgcnVsZXM6XG5cdFx0XHQvLyAxKSBJdCBuZWVkcyB0byBiZSBwcmVzZW50IGluIHRoZSBhbXBfZnVuZGluZyB0YWJsZSBldmVuIGlmIHRoZSBvcmcgaGFzbnQgdGhlIHJvbGUgXCJETlwiIChhbXBfb3JnX3JvbGVcblx0XHRcdC8vIHRhYmxlKS5cblx0XHRcdC8vIEZhaWxpbmcgdG8gZW5mb3JjZSB0aGlzIHJ1bGUgd2lsbCBjYXVzZSBzb21lIG9yZ3MgdG8gYmUgbWlzc2luZyAoaWU6IE1BWU9SQUxJVElFUykgYW5kIG90aGVycyB0byBhcHBlYXJcblx0XHRcdC8vIGJ5XG5cdFx0XHQvLyBtaXN0YWtlIChpZTogV09STEQgRElBQkVURVMgRk9VTkRBVElPTiksIGJvdGggaW4gTW9sZG92YSBkYi5cblx0XHRcdC8vIFNvIGhlcmUgd2UgZmlsdGVyIG91dCB0aG9zZSBvcmdzIHRoYXQgZG9udCBoYXZlIGZ1bmRpbmcuIE5vdGljZSB3ZSBuZWVkIHRvIGRvIGl0IGhlcmUgYmVjYXVzZSB0aGUgYWxsXG5cdFx0XHQvLyBmaWx0ZXJcblx0XHRcdC8vIGJ5IG9yZyBzaGFyZSB0aGUgc2FtZSBkYXRhIGNvbGxlY3Rpb25zLlxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdHlwZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0eXBlLmNoaWxkcmVuW2ldLmNoaWxkcmVuID0gXy5maWx0ZXIodHlwZS5jaGlsZHJlbltpXS5jaGlsZHJlbiwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRcdHJldHVybiAoaXRlbVsnaGFzRnVuZGluZ3MnXSA9PT0gdHJ1ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRfLmVhY2godHlwZS5jaGlsZHJlbiwgZnVuY3Rpb24oZ3JvdXApIHtcblx0XHRcdFx0Z3JvdXAuZmlsdGVySWQgPSAnRG9ub3IgR3JvdXAnO1xuXHRcdFx0fSk7XG5cblx0XHRcdHR5cGUuZmlsdGVySWQgPSAnRG9ub3IgVHlwZSc7XG5cdFx0XHR0eXBlLmlzU2VsZWN0YWJsZSA9IGZhbHNlOyAvLyBzdG9wcyB0cmVlIGZyb20gY3JlYXRpbmcgJ3Vua293bicgY2hpbGRyZW4uXG5cdFx0XHRyZXR1cm4gKHR5cGUuY2hpbGRyZW4ubGVuZ3RoID4gMCk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIG9yZ1R5cGVzSlNPTjtcblx0fSxcblxuICAgIC8vIDEuIGdldCBhbGwgb3JncywgZ3JvdXBzLCB0eXBlcywgYW5kIHJvbGVzXG4gIF9mZXRjaE9yZ0NvbGxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmlsdGVyRGVmZXJyZWRzID0gW107XG5cbiAgICB0aGlzLm9yZ0NvbGxlY3Rpb24gPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbigpO1xuICAgIHRoaXMub3JnQ29sbGVjdGlvbi51cmwgPSAnL3Jlc3QvZmlsdGVycy9vcmdzJztcbiAgICBmaWx0ZXJEZWZlcnJlZHMucHVzaCh0aGlzLm9yZ0NvbGxlY3Rpb24uZmV0Y2goKSk7XG5cbiAgICB0aGlzLm9yZ0dyb3VwQ29sbGVjdGlvbiA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKCk7XG4gICAgdGhpcy5vcmdHcm91cENvbGxlY3Rpb24udXJsID0gJy9yZXN0L2ZpbHRlcnMvb3JnLWdyb3Vwcyc7XG4gICAgZmlsdGVyRGVmZXJyZWRzLnB1c2godGhpcy5vcmdHcm91cENvbGxlY3Rpb24uZmV0Y2goKSk7XG5cbiAgICB0aGlzLm9yZ1R5cGVDb2xsZWN0aW9uID0gbmV3IEJhY2tib25lLkNvbGxlY3Rpb24oKTtcbiAgICB0aGlzLm9yZ1R5cGVDb2xsZWN0aW9uLnVybCA9ICcvcmVzdC9maWx0ZXJzL29yZy10eXBlcyc7XG4gICAgZmlsdGVyRGVmZXJyZWRzLnB1c2godGhpcy5vcmdUeXBlQ29sbGVjdGlvbi5mZXRjaCgpKTtcblxuICAgIHRoaXMub3JnUm9sZXNDb2xsZWN0aW9uID0gbmV3IEJhY2tib25lLkNvbGxlY3Rpb24oKTtcbiAgICB0aGlzLm9yZ1JvbGVzQ29sbGVjdGlvbi51cmwgPSAnL3Jlc3QvZmlsdGVycy9vcmctcm9sZXMnO1xuICAgIGZpbHRlckRlZmVycmVkcy5wdXNoKHRoaXMub3JnUm9sZXNDb2xsZWN0aW9uLmZldGNoKHt9KSk7XG5cbiAgICByZXR1cm4gJC53aGVuLmFwcGx5KCQsIGZpbHRlckRlZmVycmVkcyk7XG4gIH0sXG5cblxuICAvLyBBZGRzIHJlZmVyZW5jZXMgdG8gY29sbGVjdGlvbkIgaW50byBjb2xsZWN0aW9uQSBqb2luaW5nIG9uIGdpdmVuIGZvcmVpZ24ga2V5XG4gIC8vIFRPRE86IG9wdGlvbiB0byBhZGQgYmktZGlyZWN0aW9uYWwgcmVmZXJlbmNlLlxuICBqb2luSGVscGVyOiBmdW5jdGlvbihjb2xsZWN0aW9uQSwgY29sbGVjdGlvbkIsIGtleUZvckZvcmVpZ25JRCwga2V5Rm9yQ29sbGVjdGlvbkRlc3RpbmF0aW9uKSB7XG4gICAgY29sbGVjdGlvbkEuZWFjaChmdW5jdGlvbihtb2RlbEEpIHtcbiAgICAgIHZhciBpZHNUb0pvaW4gPSBtb2RlbEEuZ2V0KGtleUZvckZvcmVpZ25JRCk7XG4gICAgICB2YXIgdGVtcENvbGxlY3Rpb24gPSBjb2xsZWN0aW9uQi5maWx0ZXIoZnVuY3Rpb24obW9kZWxCKSB7XG4gICAgICAgIHJldHVybiBfLmluZGV4T2YoaWRzVG9Kb2luLCBtb2RlbEIuZ2V0KCdpZCcpKSA+PSAwO1xuICAgICAgfSk7XG5cbiAgICAgIG1vZGVsQS5zZXQoa2V5Rm9yQ29sbGVjdGlvbkRlc3RpbmF0aW9uLCB0ZW1wQ29sbGVjdGlvbik7XG4gICAgfSk7XG4gIH0sXG5cblx0ICBtYWtlVHJlZUhlbHBlciA6IGZ1bmN0aW9uKHBhcmVudENvbGxlY3Rpb24sIGNoaWxkQ29sbGVjdGlvbiwga2V5Rm9yRm9yZWlnbklELCBrZXlGb3JDb2xsZWN0aW9uRGVzdGluYXRpb24pIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIGRvbm9yUm9sZSA9IF8uZmlsdGVyKHNlbGYub3JnUm9sZXNDb2xsZWN0aW9uLm1vZGVscywgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuIGl0ZW0uZ2V0KCduYW1lJykgPT09ICdEb25vcidcblx0XHR9KVswXTtcblx0XHRwYXJlbnRDb2xsZWN0aW9uLmVhY2goZnVuY3Rpb24ocGFyZW50KSB7XG5cdFx0XHR2YXIgaWRzVG9Kb2luID0gcGFyZW50LmdldChrZXlGb3JGb3JlaWduSUQpO1xuXHRcdFx0dmFyIHRlbXBDb2xsZWN0aW9uID0gW107XG5cdFx0XHRfLmVhY2goaWRzVG9Kb2luLCBmdW5jdGlvbihpZCkge1xuXHRcdFx0XHQvLyBpZCA9PSAwIGNoZWNrIHNob3VsZCBiZSByZWR1bmRlbnQgd2hlbiBKdWxpYW4gY29tbWl0cyB1cGRhdGUuXG5cdFx0XHRcdGlmIChpZCAhPT0gMCkge1xuXHRcdFx0XHRcdHZhciBsZWFmID0gY2hpbGRDb2xsZWN0aW9uLmdldCh7XG5cdFx0XHRcdFx0XHRpZCA6IGlkXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0aWYgKGxlYWYpIHtcblx0XHRcdFx0XHRcdGlmIChsZWFmLmdldCgnaGFzRnVuZGluZ3MnKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHQvLyBCZWNhdXNlIG9mIHRoZSBidXNpbmVzcyBsb2dpYyBvZiBvbGQgZmlsdGVycywgaWYgYW4gb3JnYW5pemF0aW9uIGhhcyBiZWVuIHVzZWQgYXMgYSBmdW5kaW5nIG9yZ1xuXHRcdFx0XHRcdFx0XHQvLyAocHJlc2VudCBpbiBhbXBfZnVuZGluZykgdGhlbiB3ZSBuZWVkIHRvXG5cdFx0XHRcdFx0XHRcdC8vIGFkZCBpdCB0byB0aGUgbGlzdCBvZiAnRG9ub3JzJyBubyBtYXR0ZXIgd2hpY2ggaXMgdGhlICdyb2xlJyBvZiB0aGF0IG9yZ2FuaXphdGlvbiwgc28gaW4gb3JkZXIgdG9cblx0XHRcdFx0XHRcdFx0Ly8gbWFrZSBpdCBhcHBlYXIgaW4gdGhlIHRyZWUgd2UgYWxzbyBuZWVkIHRvXG5cdFx0XHRcdFx0XHRcdC8vIGFkZCB0aGUgJ0ROJyByb2wgdG8gaXQsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGlnbm9yZWQgZXZlbiBpZiBpdHMgaW4gdGVtcENvbGxlY3Rpb24uXG5cdFx0XHRcdFx0XHRcdHZhciByb2xlcyA9IGxlYWYuZ2V0KCdyb2xlc0lkcycpO1xuXHRcdFx0XHRcdFx0XHRpZiAocm9sZXMgIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0cm9sZXMucHVzaChkb25vclJvbGUuZ2V0KCdpZCcpKTtcblx0XHRcdFx0XHRcdFx0XHRsZWFmLnNldCgncm9sZXNJZHMnLCByb2xlcyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRlbXBDb2xsZWN0aW9uLnB1c2gobGVhZi50b0pTT04oKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUud2FybignbWlzc2luZyBpZCcsIGNoaWxkQ29sbGVjdGlvbiwgJyBkb2VzIG5vdCBoYXZlIGFuIGlkIG9mICcsIGlkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cGFyZW50LnNldChrZXlGb3JDb2xsZWN0aW9uRGVzdGluYXRpb24sIHRlbXBDb2xsZWN0aW9uKTtcblx0XHR9KTtcblx0fVxufSk7XG4iLCIvKlxuXG4kLkxpbmsgKHBhcnQgb2Ygbm9VaVNsaWRlcikgLSBXVEZQTCAqL1xuKGZ1bmN0aW9uKGMpe2Z1bmN0aW9uIG0oYSxjLGQpe2lmKChhW2NdfHxhW2RdKSYmYVtjXT09PWFbZF0pdGhyb3cgRXJyb3IoXCIoTGluaykgJ1wiK2MrXCInIGNhbid0IG1hdGNoICdcIitkK1wiJy4nXCIpO31mdW5jdGlvbiByKGEpe3ZvaWQgMD09PWEmJihhPXt9KTtpZihcIm9iamVjdFwiIT09dHlwZW9mIGEpdGhyb3cgRXJyb3IoXCIoRm9ybWF0KSAnZm9ybWF0JyBvcHRpb24gbXVzdCBiZSBhbiBvYmplY3QuXCIpO3ZhciBoPXt9O2ModSkuZWFjaChmdW5jdGlvbihjLG4pe2lmKHZvaWQgMD09PWFbbl0paFtuXT1BW2NdO2Vsc2UgaWYodHlwZW9mIGFbbl09PT10eXBlb2YgQVtjXSl7aWYoXCJkZWNpbWFsc1wiPT09biYmKDA+YVtuXXx8NzxhW25dKSl0aHJvdyBFcnJvcihcIihGb3JtYXQpICdmb3JtYXQuZGVjaW1hbHMnIG9wdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNy5cIik7aFtuXT1hW25dfWVsc2UgdGhyb3cgRXJyb3IoXCIoRm9ybWF0KSAnZm9ybWF0LlwiK24rXCInIG11c3QgYmUgYSBcIit0eXBlb2YgQVtjXStcblwiLlwiKTt9KTttKGgsXCJtYXJrXCIsXCJ0aG91c2FuZFwiKTttKGgsXCJwcmVmaXhcIixcIm5lZ2F0aXZlXCIpO20oaCxcInByZWZpeFwiLFwibmVnYXRpdmVCZWZvcmVcIik7dGhpcy5yPWh9ZnVuY3Rpb24gayhhLGgpe1wib2JqZWN0XCIhPT10eXBlb2YgYSYmYy5lcnJvcihcIihMaW5rKSBJbml0aWFsaXplIHdpdGggYW4gb2JqZWN0LlwiKTtyZXR1cm4gbmV3IGsucHJvdG90eXBlLnAoYS50YXJnZXR8fGZ1bmN0aW9uKCl7fSxhLm1ldGhvZCxhLmZvcm1hdHx8e30saCl9dmFyIHU9XCJkZWNpbWFscyBtYXJrIHRob3VzYW5kIHByZWZpeCBwb3N0Zml4IGVuY29kZXIgZGVjb2RlciBuZWdhdGl2ZSBuZWdhdGl2ZUJlZm9yZSB0byBmcm9tXCIuc3BsaXQoXCIgXCIpLEE9WzIsXCIuXCIsXCJcIixcIlwiLFwiXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGF9LGZ1bmN0aW9uKGEpe3JldHVybiBhfSxcIi1cIixcIlwiLGZ1bmN0aW9uKGEpe3JldHVybiBhfSxmdW5jdGlvbihhKXtyZXR1cm4gYX1dO3IucHJvdG90eXBlLmE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuclthXX07XG5yLnByb3RvdHlwZS5MPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIGEuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIil9YT10aGlzLmEoXCJlbmNvZGVyXCIpKGEpO3ZhciBkPXRoaXMuYShcImRlY2ltYWxzXCIpLG49XCJcIixrPVwiXCIsbT1cIlwiLHI9XCJcIjswPT09cGFyc2VGbG9hdChhLnRvRml4ZWQoZCkpJiYoYT1cIjBcIik7MD5hJiYobj10aGlzLmEoXCJuZWdhdGl2ZVwiKSxrPXRoaXMuYShcIm5lZ2F0aXZlQmVmb3JlXCIpKTthPU1hdGguYWJzKGEpLnRvRml4ZWQoZCkudG9TdHJpbmcoKTthPWEuc3BsaXQoXCIuXCIpO3RoaXMuYShcInRob3VzYW5kXCIpPyhtPWMoYVswXSkubWF0Y2goLy57MSwzfS9nKSxtPWMobS5qb2luKGModGhpcy5hKFwidGhvdXNhbmRcIikpKSkpOm09YVswXTt0aGlzLmEoXCJtYXJrXCIpJiYxPGEubGVuZ3RoJiYocj10aGlzLmEoXCJtYXJrXCIpK2FbMV0pO3JldHVybiB0aGlzLmEoXCJ0b1wiKShrK3RoaXMuYShcInByZWZpeFwiKStuK20rcit0aGlzLmEoXCJwb3N0Zml4XCIpKX07ci5wcm90b3R5cGUudz1cbmZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIGEucmVwbGFjZSgvW1xcLVxcL1xcXFxcXF4kKis/LigpfFxcW1xcXXt9XS9nLFwiXFxcXCQmXCIpfXZhciBkO2lmKG51bGw9PT1hfHx2b2lkIDA9PT1hKXJldHVybiExO2E9dGhpcy5hKFwiZnJvbVwiKShhKTthPWEudG9TdHJpbmcoKTtkPWEucmVwbGFjZShSZWdFeHAoXCJeXCIrYyh0aGlzLmEoXCJuZWdhdGl2ZUJlZm9yZVwiKSkpLFwiXCIpO2EhPT1kPyhhPWQsZD1cIi1cIik6ZD1cIlwiO2E9YS5yZXBsYWNlKFJlZ0V4cChcIl5cIitjKHRoaXMuYShcInByZWZpeFwiKSkpLFwiXCIpO3RoaXMuYShcIm5lZ2F0aXZlXCIpJiYoZD1cIlwiLGE9YS5yZXBsYWNlKFJlZ0V4cChcIl5cIitjKHRoaXMuYShcIm5lZ2F0aXZlXCIpKSksXCItXCIpKTthPWEucmVwbGFjZShSZWdFeHAoYyh0aGlzLmEoXCJwb3N0Zml4XCIpKStcIiRcIiksXCJcIikucmVwbGFjZShSZWdFeHAoYyh0aGlzLmEoXCJ0aG91c2FuZFwiKSksXCJnXCIpLFwiXCIpLnJlcGxhY2UodGhpcy5hKFwibWFya1wiKSxcIi5cIik7YT10aGlzLmEoXCJkZWNvZGVyXCIpKHBhcnNlRmxvYXQoZCtcbmEpKTtyZXR1cm4gaXNOYU4oYSk/ITE6YX07ay5wcm90b3R5cGUuSz1mdW5jdGlvbihhLGgpe3RoaXMubWV0aG9kPWh8fFwiaHRtbFwiO3RoaXMuaj1jKGEucmVwbGFjZShcIi10b29sdGlwLVwiLFwiXCIpfHxcIjxkaXYvPlwiKVswXX07ay5wcm90b3R5cGUuSD1mdW5jdGlvbihhKXt0aGlzLm1ldGhvZD1cInZhbFwiO3RoaXMuaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7dGhpcy5qLm5hbWU9YTt0aGlzLmoudHlwZT1cImhpZGRlblwifTtrLnByb3RvdHlwZS5HPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGgoYSxjKXtyZXR1cm5bYz9udWxsOmEsYz9hOm51bGxdfXZhciBkPXRoaXM7dGhpcy5tZXRob2Q9XCJ2YWxcIjt0aGlzLnRhcmdldD1hLm9uKFwiY2hhbmdlXCIsZnVuY3Rpb24oYSl7ZC5CLnZhbChoKGMoYS50YXJnZXQpLnZhbCgpLGQudCkse2xpbms6ZCxzZXQ6ITB9KX0pfTtrLnByb3RvdHlwZS5wPWZ1bmN0aW9uKGEsaCxkLGspe3RoaXMuZz1kO3RoaXMudXBkYXRlPSFrO2lmKFwic3RyaW5nXCI9PT1cbnR5cGVvZiBhJiYwPT09YS5pbmRleE9mKFwiLXRvb2x0aXAtXCIpKXRoaXMuSyhhLGgpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhJiYwIT09YS5pbmRleE9mKFwiLVwiKSl0aGlzLkgoYSk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSl0aGlzLnRhcmdldD0hMSx0aGlzLm1ldGhvZD1hO2Vsc2V7aWYoYSBpbnN0YW5jZW9mIGN8fGMuemVwdG8mJmMuemVwdG8uaXNaKGEpKXtpZighaCl7aWYoYS5pcyhcImlucHV0LCBzZWxlY3QsIHRleHRhcmVhXCIpKXt0aGlzLkcoYSk7cmV0dXJufWg9XCJodG1sXCJ9aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGh8fFwic3RyaW5nXCI9PT10eXBlb2YgaCYmYVtoXSl7dGhpcy5tZXRob2Q9aDt0aGlzLnRhcmdldD1hO3JldHVybn19dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCIoTGluaykgSW52YWxpZCBMaW5rLlwiKTt9fTtrLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihhLGMsZCxrKXtpZighdGhpcy51cGRhdGV8fCExIT09aylpZih0aGlzLnU9YSx0aGlzLkY9YT1cbnRoaXMuZm9ybWF0KGEpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiB0aGlzLm1ldGhvZCl0aGlzLm1ldGhvZC5jYWxsKHRoaXMudGFyZ2V0WzBdfHxkWzBdLGEsYyxkKTtlbHNlIHRoaXMudGFyZ2V0W3RoaXMubWV0aG9kXShhLGMsZCl9O2sucHJvdG90eXBlLnE9ZnVuY3Rpb24oYSl7dGhpcy5nPW5ldyByKGMuZXh0ZW5kKHt9LGEsdGhpcy5nIGluc3RhbmNlb2Ygcj90aGlzLmcucjp0aGlzLmcpKX07ay5wcm90b3R5cGUuSj1mdW5jdGlvbihhKXt0aGlzLkI9YX07ay5wcm90b3R5cGUuST1mdW5jdGlvbihhKXt0aGlzLnQ9YX07ay5wcm90b3R5cGUuZm9ybWF0PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmcuTChhKX07ay5wcm90b3R5cGUuQT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nLncoYSl9O2sucHJvdG90eXBlLnAucHJvdG90eXBlPWsucHJvdG90eXBlO2MuTGluaz1rfSkod2luZG93LmpRdWVyeXx8d2luZG93LlplcHRvKTsvKlxuXG4kLmZuLm5vVWlTbGlkZXIgLSBXVEZQTCAtIHJlZnJlc2hsZXNzLmNvbS9ub3Vpc2xpZGVyLyAqL1xuKGZ1bmN0aW9uKGMpe2Z1bmN0aW9uIG0oZSl7cmV0dXJuXCJudW1iZXJcIj09PXR5cGVvZiBlJiYhaXNOYU4oZSkmJmlzRmluaXRlKGUpfWZ1bmN0aW9uIHIoZSl7cmV0dXJuIGMuaXNBcnJheShlKT9lOltlXX1mdW5jdGlvbiBrKGUsYil7ZS5hZGRDbGFzcyhiKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5yZW1vdmVDbGFzcyhiKX0sMzAwKX1mdW5jdGlvbiB1KGUsYil7cmV0dXJuIDEwMCpiLyhlWzFdLWVbMF0pfWZ1bmN0aW9uIEEoZSxiKXtpZihiPj1lLmQuc2xpY2UoLTEpWzBdKXJldHVybiAxMDA7Zm9yKHZhciBhPTEsYyxmLGQ7Yj49ZS5kW2FdOylhKys7Yz1lLmRbYS0xXTtmPWUuZFthXTtkPWUuY1thLTFdO2M9W2MsZl07cmV0dXJuIGQrdShjLDA+Y1swXT9iK01hdGguYWJzKGNbMF0pOmItY1swXSkvKDEwMC8oZS5jW2FdLWQpKX1mdW5jdGlvbiBhKGUsYil7aWYoMTAwPD1iKXJldHVybiBlLmQuc2xpY2UoLTEpWzBdO2Zvcih2YXIgYT0xLGMsZixkO2I+PWUuY1thXTspYSsrO2M9XG5lLmRbYS0xXTtmPWUuZFthXTtkPWUuY1thLTFdO2M9W2MsZl07cmV0dXJuIDEwMC8oZS5jW2FdLWQpKihiLWQpKihjWzFdLWNbMF0pLzEwMCtjWzBdfWZ1bmN0aW9uIGgoYSxiKXtmb3IodmFyIGM9MSxnOyhhLmRpcj8xMDAtYjpiKT49YS5jW2NdOyljKys7aWYoYS5tKXJldHVybiBnPWEuY1tjLTFdLGM9YS5jW2NdLGItZz4oYy1nKS8yP2M6ZzthLmhbYy0xXT8oZz1hLmhbYy0xXSxjPWEuY1tjLTFdK01hdGgucm91bmQoKGItYS5jW2MtMV0pL2cpKmcpOmM9YjtyZXR1cm4gY31mdW5jdGlvbiBkKGEsYil7aWYoIW0oYikpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnc3RlcCcgaXMgbm90IG51bWVyaWMuXCIpO2EuaFswXT1ifWZ1bmN0aW9uIG4oYSxiKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGJ8fGMuaXNBcnJheShiKSl0aHJvdyBFcnJvcihcIm5vVWlTbGlkZXI6ICdyYW5nZScgaXMgbm90IGFuIG9iamVjdC5cIik7aWYodm9pZCAwPT09Yi5taW58fHZvaWQgMD09PWIubWF4KXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogTWlzc2luZyAnbWluJyBvciAnbWF4JyBpbiAncmFuZ2UnLlwiKTtcbmMuZWFjaChiLGZ1bmN0aW9uKGIsZyl7dmFyIGQ7XCJudW1iZXJcIj09PXR5cGVvZiBnJiYoZz1bZ10pO2lmKCFjLmlzQXJyYXkoZykpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAncmFuZ2UnIGNvbnRhaW5zIGludmFsaWQgdmFsdWUuXCIpO2Q9XCJtaW5cIj09PWI/MDpcIm1heFwiPT09Yj8xMDA6cGFyc2VGbG9hdChiKTtpZighbShkKXx8IW0oZ1swXSkpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAncmFuZ2UnIHZhbHVlIGlzbid0IG51bWVyaWMuXCIpO2EuYy5wdXNoKGQpO2EuZC5wdXNoKGdbMF0pO2Q/YS5oLnB1c2goaXNOYU4oZ1sxXSk/ITE6Z1sxXSk6aXNOYU4oZ1sxXSl8fChhLmhbMF09Z1sxXSl9KTtjLmVhY2goYS5oLGZ1bmN0aW9uKGIsYyl7aWYoIWMpcmV0dXJuITA7YS5oW2JdPXUoW2EuZFtiXSxhLmRbYisxXV0sYykvKDEwMC8oYS5jW2IrMV0tYS5jW2JdKSl9KX1mdW5jdGlvbiBFKGEsYil7XCJudW1iZXJcIj09PXR5cGVvZiBiJiYoYj1bYl0pO2lmKCFjLmlzQXJyYXkoYil8fCFiLmxlbmd0aHx8XG4yPGIubGVuZ3RoKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ3N0YXJ0JyBvcHRpb24gaXMgaW5jb3JyZWN0LlwiKTthLmI9Yi5sZW5ndGg7YS5zdGFydD1ifWZ1bmN0aW9uIEkoYSxiKXthLm09YjtpZihcImJvb2xlYW5cIiE9PXR5cGVvZiBiKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ3NuYXAnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7fWZ1bmN0aW9uIEooYSxiKXtpZihcImxvd2VyXCI9PT1iJiYxPT09YS5iKWEuaT0xO2Vsc2UgaWYoXCJ1cHBlclwiPT09YiYmMT09PWEuYilhLmk9MjtlbHNlIGlmKCEwPT09YiYmMj09PWEuYilhLmk9MztlbHNlIGlmKCExPT09YilhLmk9MDtlbHNlIHRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ2Nvbm5lY3QnIG9wdGlvbiBkb2Vzbid0IG1hdGNoIGhhbmRsZSBjb3VudC5cIik7fWZ1bmN0aW9uIEQoYSxiKXtzd2l0Y2goYil7Y2FzZSBcImhvcml6b250YWxcIjphLms9MDticmVhaztjYXNlIFwidmVydGljYWxcIjphLms9MTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ29yaWVudGF0aW9uJyBvcHRpb24gaXMgaW52YWxpZC5cIik7XG59fWZ1bmN0aW9uIEsoYSxiKXtpZigyPGEuYy5sZW5ndGgpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnbWFyZ2luJyBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgb24gbGluZWFyIHNsaWRlcnMuXCIpO2EubWFyZ2luPXUoYS5kLGIpO2lmKCFtKGIpKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ21hcmdpbicgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7fWZ1bmN0aW9uIEwoYSxiKXtzd2l0Y2goYil7Y2FzZSBcImx0clwiOmEuZGlyPTA7YnJlYWs7Y2FzZSBcInJ0bFwiOmEuZGlyPTE7YS5pPVswLDIsMSwzXVthLmldO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnZGlyZWN0aW9uJyBvcHRpb24gd2FzIG5vdCByZWNvZ25pemVkLlwiKTt9fWZ1bmN0aW9uIE0oYSxiKXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGIpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnYmVoYXZpb3VyJyBtdXN0IGJlIGEgc3RyaW5nIGNvbnRhaW5pbmcgb3B0aW9ucy5cIik7dmFyIGM9MDw9Yi5pbmRleE9mKFwic25hcFwiKTtcbmEubj17czowPD1iLmluZGV4T2YoXCJ0YXBcIil8fGMsZXh0ZW5kOjA8PWIuaW5kZXhPZihcImV4dGVuZFwiKSx2OjA8PWIuaW5kZXhPZihcImRyYWdcIiksZml4ZWQ6MDw9Yi5pbmRleE9mKFwiZml4ZWRcIiksbTpjfX1mdW5jdGlvbiBOKGEsYixkKXthLm89W2IubG93ZXIsYi51cHBlcl07YS5nPWIuZm9ybWF0O2MuZWFjaChhLm8sZnVuY3Rpb24oYSxlKXtpZighYy5pc0FycmF5KGUpKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ3NlcmlhbGl6YXRpb24uXCIrKGE/XCJ1cHBlclwiOlwibG93ZXJcIikrXCInIG11c3QgYmUgYW4gYXJyYXkuXCIpO2MuZWFjaChlLGZ1bmN0aW9uKCl7aWYoISh0aGlzIGluc3RhbmNlb2YgYy5MaW5rKSl0aHJvdyBFcnJvcihcIm5vVWlTbGlkZXI6ICdzZXJpYWxpemF0aW9uLlwiKyhhP1widXBwZXJcIjpcImxvd2VyXCIpK1wiJyBjYW4gb25seSBjb250YWluIExpbmsgaW5zdGFuY2VzLlwiKTt0aGlzLkkoYSk7dGhpcy5KKGQpO3RoaXMucShiLmZvcm1hdCl9KX0pO2EuZGlyJiYxPGEuYiYmYS5vLnJldmVyc2UoKX1cbmZ1bmN0aW9uIE8oYSxiKXt2YXIgZj17YzpbXSxkOltdLGg6WyExXSxtYXJnaW46MH0sZztnPXtzdGVwOntlOiExLGY6ZH0sc3RhcnQ6e2U6ITAsZjpFfSxjb25uZWN0OntlOiEwLGY6Sn0sZGlyZWN0aW9uOntlOiEwLGY6TH0scmFuZ2U6e2U6ITAsZjpufSxzbmFwOntlOiExLGY6SX0sb3JpZW50YXRpb246e2U6ITEsZjpEfSxtYXJnaW46e2U6ITEsZjpLfSxiZWhhdmlvdXI6e2U6ITAsZjpNfSxzZXJpYWxpemF0aW9uOntlOiEwLGY6Tn19O2E9Yy5leHRlbmQoe2Nvbm5lY3Q6ITEsZGlyZWN0aW9uOlwibHRyXCIsYmVoYXZpb3VyOlwidGFwXCIsb3JpZW50YXRpb246XCJob3Jpem9udGFsXCJ9LGEpO2Euc2VyaWFsaXphdGlvbj1jLmV4dGVuZCh7bG93ZXI6W10sdXBwZXI6W10sZm9ybWF0Ont9fSxhLnNlcmlhbGl6YXRpb24pO2MuZWFjaChnLGZ1bmN0aW9uKGMsZCl7aWYodm9pZCAwPT09YVtjXSl7aWYoZC5lKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ1wiK2MrXCInIGlzIHJlcXVpcmVkLlwiKTtcbnJldHVybiEwfWQuZihmLGFbY10sYil9KTtmLnN0eWxlPWYuaz9cInRvcFwiOlwibGVmdFwiO3JldHVybiBmfWZ1bmN0aW9uIFAoYSxiKXt2YXIgZD1jKFwiPGRpdj48ZGl2Lz48L2Rpdj5cIikuYWRkQ2xhc3MoZlsyXSksZz1bXCItbG93ZXJcIixcIi11cHBlclwiXTthLmRpciYmZy5yZXZlcnNlKCk7ZC5jaGlsZHJlbigpLmFkZENsYXNzKGZbM10rXCIgXCIrZlszXStnW2JdKTtyZXR1cm4gZH1mdW5jdGlvbiBRKGEsYil7Yi5qJiYoYj1uZXcgYy5MaW5rKHt0YXJnZXQ6YyhiLmopLmNsb25lKCkuYXBwZW5kVG8oYSksbWV0aG9kOmIubWV0aG9kLGZvcm1hdDpiLmd9LCEwKSk7cmV0dXJuIGJ9ZnVuY3Rpb24gUihhLGIpe3ZhciBkLGY9W107Zm9yKGQ9MDtkPGEuYjtkKyspe3ZhciBrPWYsaD1kLG09YS5vW2RdLG49YltkXS5jaGlsZHJlbigpLHI9YS5nLHM9dm9pZCAwLHY9W10scz1uZXcgYy5MaW5rKHt9LCEwKTtzLnEocik7di5wdXNoKHMpO2ZvcihzPTA7czxtLmxlbmd0aDtzKyspdi5wdXNoKFEobixtW3NdKSk7XG5rW2hdPXZ9cmV0dXJuIGZ9ZnVuY3Rpb24gUyhhLGIsYyl7c3dpdGNoKGEpe2Nhc2UgMTpiLmFkZENsYXNzKGZbN10pO2NbMF0uYWRkQ2xhc3MoZls2XSk7YnJlYWs7Y2FzZSAzOmNbMV0uYWRkQ2xhc3MoZls2XSk7Y2FzZSAyOmNbMF0uYWRkQ2xhc3MoZls3XSk7Y2FzZSAwOmIuYWRkQ2xhc3MoZls2XSl9fWZ1bmN0aW9uIFQoYSxiKXt2YXIgYyxkPVtdO2ZvcihjPTA7YzxhLmI7YysrKWQucHVzaChQKGEsYykuYXBwZW5kVG8oYikpO3JldHVybiBkfWZ1bmN0aW9uIFUoYSxiKXtiLmFkZENsYXNzKFtmWzBdLGZbOCthLmRpcl0sZls0K2Eua11dLmpvaW4oXCIgXCIpKTtyZXR1cm4gYyhcIjxkaXYvPlwiKS5hcHBlbmRUbyhiKS5hZGRDbGFzcyhmWzFdKX1mdW5jdGlvbiBWKGQsYixtKXtmdW5jdGlvbiBnKCl7cmV0dXJuIHRbW1wid2lkdGhcIixcImhlaWdodFwiXVtiLmtdXSgpfWZ1bmN0aW9uIG4oYSl7dmFyIGIsYz1bcS52YWwoKV07Zm9yKGI9MDtiPGEubGVuZ3RoO2IrKylxLnRyaWdnZXIoYVtiXSxcbmMpfWZ1bmN0aW9uIHUoZCxwLGUpe3ZhciBnPWRbMF0hPT1sWzBdWzBdPzE6MCxIPXhbMF0rYi5tYXJnaW4saz14WzFdLWIubWFyZ2luO2UmJjE8bC5sZW5ndGgmJihwPWc/TWF0aC5tYXgocCxIKTpNYXRoLm1pbihwLGspKTsxMDA+cCYmKHA9aChiLHApKTtwPU1hdGgubWF4KE1hdGgubWluKHBhcnNlRmxvYXQocC50b0ZpeGVkKDcpKSwxMDApLDApO2lmKHA9PT14W2ddKXJldHVybiAxPT09bC5sZW5ndGg/ITE6cD09PUh8fHA9PT1rPzA6ITE7ZC5jc3MoYi5zdHlsZSxwK1wiJVwiKTtkLmlzKFwiOmZpcnN0LWNoaWxkXCIpJiZkLnRvZ2dsZUNsYXNzKGZbMTddLDUwPHApO3hbZ109cDtiLmRpciYmKHA9MTAwLXApO2MoeVtnXSkuZWFjaChmdW5jdGlvbigpe3RoaXMud3JpdGUoYShiLHApLGQuY2hpbGRyZW4oKSxxKX0pO3JldHVybiEwfWZ1bmN0aW9uIEIoYSxiLGMpe2N8fGsocSxmWzE0XSk7dShhLGIsITEpO24oW1wic2xpZGVcIixcInNldFwiLFwiY2hhbmdlXCJdKX1mdW5jdGlvbiB3KGEsYyxkLGUpe2E9XG5hLnJlcGxhY2UoL1xccy9nLFwiLm51aSBcIikrXCIubnVpXCI7Yy5vbihhLGZ1bmN0aW9uKGEpe3ZhciBjPXEuYXR0cihcImRpc2FibGVkXCIpO2lmKHEuaGFzQ2xhc3MoZlsxNF0pfHx2b2lkIDAhPT1jJiZudWxsIT09YylyZXR1cm4hMTthLnByZXZlbnREZWZhdWx0KCk7dmFyIGM9MD09PWEudHlwZS5pbmRleE9mKFwidG91Y2hcIikscD0wPT09YS50eXBlLmluZGV4T2YoXCJtb3VzZVwiKSxGPTA9PT1hLnR5cGUuaW5kZXhPZihcInBvaW50ZXJcIiksZyxrLGw9YTswPT09YS50eXBlLmluZGV4T2YoXCJNU1BvaW50ZXJcIikmJihGPSEwKTthLm9yaWdpbmFsRXZlbnQmJihhPWEub3JpZ2luYWxFdmVudCk7YyYmKGc9YS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCxrPWEuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkpO2lmKHB8fEYpRnx8dm9pZCAwIT09d2luZG93LnBhZ2VYT2Zmc2V0fHwod2luZG93LnBhZ2VYT2Zmc2V0PWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LHdpbmRvdy5wYWdlWU9mZnNldD1cbmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApLGc9YS5jbGllbnRYK3dpbmRvdy5wYWdlWE9mZnNldCxrPWEuY2xpZW50WSt3aW5kb3cucGFnZVlPZmZzZXQ7bC5DPVtnLGtdO2wuY3Vyc29yPXA7YT1sO2EubD1hLkNbYi5rXTtkKGEsZSl9KX1mdW5jdGlvbiBDKGEsYyl7dmFyIGI9Yy5ifHxsLGQsZT0hMSxlPTEwMCooYS5sLWMuc3RhcnQpL2coKSxmPWJbMF1bMF0hPT1sWzBdWzBdPzE6MDt2YXIgaz1jLkQ7ZD1lK2tbMF07ZSs9a1sxXTsxPGIubGVuZ3RoPygwPmQmJihlKz1NYXRoLmFicyhkKSksMTAwPGUmJihkLT1lLTEwMCksZD1bTWF0aC5tYXgoTWF0aC5taW4oZCwxMDApLDApLE1hdGgubWF4KE1hdGgubWluKGUsMTAwKSwwKV0pOmQ9W2QsZV07ZT11KGJbMF0sZFtmXSwxPT09Yi5sZW5ndGgpOzE8Yi5sZW5ndGgmJihlPXUoYlsxXSxkW2Y/MDoxXSwhMSl8fGUpO2UmJm4oW1wic2xpZGVcIl0pfWZ1bmN0aW9uIHMoYSl7YyhcIi5cIitmWzE1XSkucmVtb3ZlQ2xhc3MoZlsxNV0pO1xuYS5jdXJzb3ImJmMoXCJib2R5XCIpLmNzcyhcImN1cnNvclwiLFwiXCIpLm9mZihcIi5udWlcIik7Ry5vZmYoXCIubnVpXCIpO3EucmVtb3ZlQ2xhc3MoZlsxMl0pO24oW1wic2V0XCIsXCJjaGFuZ2VcIl0pfWZ1bmN0aW9uIHYoYSxiKXsxPT09Yi5iLmxlbmd0aCYmYi5iWzBdLmNoaWxkcmVuKCkuYWRkQ2xhc3MoZlsxNV0pO2Euc3RvcFByb3BhZ2F0aW9uKCk7dyh6Lm1vdmUsRyxDLHtzdGFydDphLmwsYjpiLmIsRDpbeFswXSx4W2wubGVuZ3RoLTFdXX0pO3coei5lbmQsRyxzLG51bGwpO2EuY3Vyc29yJiYoYyhcImJvZHlcIikuY3NzKFwiY3Vyc29yXCIsYyhhLnRhcmdldCkuY3NzKFwiY3Vyc29yXCIpKSwxPGwubGVuZ3RoJiZxLmFkZENsYXNzKGZbMTJdKSxjKFwiYm9keVwiKS5vbihcInNlbGVjdHN0YXJ0Lm51aVwiLCExKSl9ZnVuY3Rpb24gRChhKXt2YXIgZD1hLmwsZT0wO2Euc3RvcFByb3BhZ2F0aW9uKCk7Yy5lYWNoKGwsZnVuY3Rpb24oKXtlKz10aGlzLm9mZnNldCgpW2Iuc3R5bGVdfSk7ZT1kPGUvMnx8MT09PWwubGVuZ3RoP1xuMDoxO2QtPXQub2Zmc2V0KClbYi5zdHlsZV07ZD0xMDAqZC9nKCk7QihsW2VdLGQsYi5uLm0pO2Iubi5tJiZ2KGEse2I6W2xbZV1dfSl9ZnVuY3Rpb24gRShhKXt2YXIgYz0oYT1hLmw8dC5vZmZzZXQoKVtiLnN0eWxlXSk/MDoxMDA7YT1hPzA6bC5sZW5ndGgtMTtCKGxbYV0sYywhMSl9dmFyIHE9YyhkKSx4PVstMSwtMV0sdCx5LGw7aWYocS5oYXNDbGFzcyhmWzBdKSl0aHJvdyBFcnJvcihcIlNsaWRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC5cIik7dD1VKGIscSk7bD1UKGIsdCk7eT1SKGIsbCk7UyhiLmkscSxsKTsoZnVuY3Rpb24oYSl7dmFyIGI7aWYoIWEuZml4ZWQpZm9yKGI9MDtiPGwubGVuZ3RoO2IrKyl3KHouc3RhcnQsbFtiXS5jaGlsZHJlbigpLHYse2I6W2xbYl1dfSk7YS5zJiZ3KHouc3RhcnQsdCxELHtiOmx9KTthLmV4dGVuZCYmKHEuYWRkQ2xhc3MoZlsxNl0pLGEucyYmdyh6LnN0YXJ0LHEsRSx7YjpsfSkpO2EudiYmKGI9dC5maW5kKFwiLlwiK2ZbN10pLmFkZENsYXNzKGZbMTBdKSxcbmEuZml4ZWQmJihiPWIuYWRkKHQuY2hpbGRyZW4oKS5ub3QoYikuY2hpbGRyZW4oKSkpLHcoei5zdGFydCxiLHYse2I6bH0pKX0pKGIubik7ZC52U2V0PWZ1bmN0aW9uKCl7dmFyIGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApLGQsZSxnLGgsbSxzLHQ9cihhWzBdKTtcIm9iamVjdFwiPT09dHlwZW9mIGFbMV0/KGQ9YVsxXS5zZXQsZT1hWzFdLmxpbmssZz1hWzFdLnVwZGF0ZSxoPWFbMV0uYW5pbWF0ZSk6ITA9PT1hWzFdJiYoZD0hMCk7Yi5kaXImJjE8Yi5iJiZ0LnJldmVyc2UoKTtoJiZrKHEsZlsxNF0pO2E9MTxsLmxlbmd0aD8zOjE7MT09PXQubGVuZ3RoJiYoYT0xKTtmb3IobT0wO208YTttKyspaD1lfHx5W20lMl1bMF0saD1oLkEodFttJTJdKSwhMSE9PWgmJihoPUEoYixoKSxiLmRpciYmKGg9MTAwLWgpLCEwIT09dShsW20lMl0saCwhMCkmJmMoeVttJTJdKS5lYWNoKGZ1bmN0aW9uKGEpe2lmKCFhKXJldHVybiBzPXRoaXMudSwhMDt0aGlzLndyaXRlKHMsXG5sW20lMl0uY2hpbGRyZW4oKSxxLGcpfSkpOyEwPT09ZCYmbihbXCJzZXRcIl0pO3JldHVybiB0aGlzfTtkLnZHZXQ9ZnVuY3Rpb24oKXt2YXIgYSxjPVtdO2ZvcihhPTA7YTxiLmI7YSsrKWNbYV09eVthXVswXS5GO3JldHVybiAxPT09Yy5sZW5ndGg/Y1swXTpiLmRpcj9jLnJldmVyc2UoKTpjfTtkLmRlc3Ryb3k9ZnVuY3Rpb24oKXtjLmVhY2goeSxmdW5jdGlvbigpe2MuZWFjaCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy50YXJnZXQmJnRoaXMudGFyZ2V0Lm9mZihcIi5udWlcIil9KX0pO2ModGhpcykub2ZmKFwiLm51aVwiKS5yZW1vdmVDbGFzcyhmLmpvaW4oXCIgXCIpKS5lbXB0eSgpO3JldHVybiBtfTtxLnZhbChiLnN0YXJ0KX1mdW5jdGlvbiBXKGEpe2lmKCF0aGlzLmxlbmd0aCl0aHJvdyBFcnJvcihcIm5vVWlTbGlkZXI6IENhbid0IGluaXRpYWxpemUgc2xpZGVyIG9uIGVtcHR5IHNlbGVjdGlvbi5cIik7dmFyIGI9TyhhLHRoaXMpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtWKHRoaXMsXG5iLGEpfSl9ZnVuY3Rpb24gWChhKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGI9Yyh0aGlzKS52YWwoKSxkPXRoaXMuZGVzdHJveSgpLGY9Yy5leHRlbmQoe30sZCxhKTtjKHRoaXMpLm5vVWlTbGlkZXIoZik7ZC5zdGFydD09PWYuc3RhcnQmJmModGhpcykudmFsKGIpfSl9ZnVuY3Rpb24gQigpe3JldHVybiB0aGlzWzBdW2FyZ3VtZW50cy5sZW5ndGg/XCJ2U2V0XCI6XCJ2R2V0XCJdLmFwcGx5KHRoaXNbMF0sYXJndW1lbnRzKX12YXIgRz1jKGRvY3VtZW50KSxDPWMuZm4udmFsLHo9d2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZD97c3RhcnQ6XCJwb2ludGVyZG93blwiLG1vdmU6XCJwb2ludGVybW92ZVwiLGVuZDpcInBvaW50ZXJ1cFwifTp3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ/e3N0YXJ0OlwiTVNQb2ludGVyRG93blwiLG1vdmU6XCJNU1BvaW50ZXJNb3ZlXCIsZW5kOlwiTVNQb2ludGVyVXBcIn06e3N0YXJ0OlwibW91c2Vkb3duIHRvdWNoc3RhcnRcIixtb3ZlOlwibW91c2Vtb3ZlIHRvdWNobW92ZVwiLFxuZW5kOlwibW91c2V1cCB0b3VjaGVuZFwifSxmPVwibm9VaS10YXJnZXQgbm9VaS1iYXNlIG5vVWktb3JpZ2luIG5vVWktaGFuZGxlIG5vVWktaG9yaXpvbnRhbCBub1VpLXZlcnRpY2FsIG5vVWktYmFja2dyb3VuZCBub1VpLWNvbm5lY3Qgbm9VaS1sdHIgbm9VaS1ydGwgbm9VaS1kcmFnYWJsZSAgbm9VaS1zdGF0ZS1kcmFnICBub1VpLXN0YXRlLXRhcCBub1VpLWFjdGl2ZSBub1VpLWV4dGVuZGVkIG5vVWktc3RhY2tpbmdcIi5zcGxpdChcIiBcIik7Yy5mbi52YWw9ZnVuY3Rpb24oKXt2YXIgYT1hcmd1bWVudHMsYj1jKHRoaXNbMF0pO3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMuZWFjaChmdW5jdGlvbigpeyhjKHRoaXMpLmhhc0NsYXNzKGZbMF0pP0I6QykuYXBwbHkoYyh0aGlzKSxhKX0pOihiLmhhc0NsYXNzKGZbMF0pP0I6QykuY2FsbChiKX07Yy5ub1VpU2xpZGVyPXtMaW5rOmMuTGlua307Yy5mbi5ub1VpU2xpZGVyPWZ1bmN0aW9uKGEsYil7cmV0dXJuKGI/WDpXKS5jYWxsKHRoaXMsXG5hKX19KSh3aW5kb3cualF1ZXJ5fHx3aW5kb3cuWmVwdG8pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG4vLyBsb2FkaW5nIGhhY2tzXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG53aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBCYWNrYm9uZS4kID0galF1ZXJ5O1xucmVxdWlyZSgnanF1ZXJ5LXVpL2RyYWdnYWJsZScpO1xucmVxdWlyZSgnYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwJyk7XG5cblxudmFyIEZpbHRlclZpZXcgPSByZXF1aXJlKCcuL3ZpZXdzL2ZpbHRlcnMtdmlldycpO1xuXG4vLyBzZWUgUkVBRE1FLm1kIGZvciBkb2N1bWVudGF0aW9uIG9uIHVzaW5nIHdpZGdldC5cblxuXG5mdW5jdGlvbiBXaWRnZXQoKSB7XG4gIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5fLmV4dGVuZChXaWRnZXQucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMsIHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHsgZHJhZ2dhYmxlOiB0cnVlIH0pO1xuICAgIGlmIChfLmhhcyhvcHRpb25zLCAnc3luYycpKSB7XG4gICAgICBCYWNrYm9uZS5zeW5jID0gb3B0aW9ucy5zeW5jO1xuICAgIH1cbiAgICB0aGlzLnZpZXcgPSBuZXcgRmlsdGVyVmlldyhvcHRpb25zKTtcblxuICAgIC8vIHVzZWQgdG8gbWFrZSBhbGwgZmlsdGVycyByZXF1ZXN0IGZhc3Rlci5cbiAgICB0aGlzLl9jYWNoZWRBbGxGaWx0ZXJzID0gbnVsbDtcblxuICAgIC8vIGxvYWRlZCBkZWZlcnJlZCB0byBhbGxvdyBmb3Igb3RoZXIgY29kZSB0byB3YWl0IGZvciBmaWx0ZXJzIHRvIGZpbmlzaCBsb2FkaW5nLlxuICAgIHRoaXMubG9hZGVkID0gdGhpcy52aWV3Ll9sb2FkZWQucHJvbWlzZSgpO1xuXG4gICAgLy8gcHJveHkgYWxsIGZpbHRlciBldmVudHMgdGhyb3VnaCBoZXJlXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnZpZXcsICdhbGwnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIHB1dCB0aGUgZmlsdGVycyBpbnRvIHRoZSBET00gdHJlZSBwb3N0LWluaXRpYWxpemF0aW9uXG4gIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudmlldy5zZXRFbGVtZW50KGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgLy8gdGhpcyB3aWxsIHN0YXNoIGN1cnJlbnQgZmlsdGVyIHN0YXRlLCBzbyBpdCBjYW4gYmUgcmVzdG9yZWQgb24gY2FuY2VsLlxuICBzaG93RmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy52aWV3LnNob3dGaWx0ZXJzKCk7XG4gIH0sXG5cblxuICAvLyByZXR1cm4gbW9kZWxzIG9mIGFsbCBmaWx0ZXJzLCBldmVuIHVuc2VsZWN0ZWQgb25lcy4uXG4gIGdldEFsbEZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5sb2FkZWQudGhlbihmdW5jdGlvbigpe1xuICAgICAgLy8gY2FjaGUsIGJlY2F1c2Ugd29uJ3QgY2hhbmdlLiBhdm9pZHMgY2FsbGluZyBzZXJpYWxpemUgZXZlcnl0aW1lLlxuICAgICAgaWYoIXRoaXMuX2NhY2hlZEFsbEZpbHRlcnMpe1xuICAgICAgICB0aGlzLl9jYWNoZWRBbGxGaWx0ZXJzID0gc2VsZi52aWV3LnNlcmlhbGl6ZSh7aW5jbHVkZVVuc2VsZWN0ZWQ6IHRydWUsIHdob2xlTW9kZWw6IHRydWV9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRBbGxGaWx0ZXJzO1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIHJldHVybiBtb2RlbHMgb2Ygc2VyaWFsaXplZCBmaWx0ZXIgc3RhdGUsIGhhcyBlbnRpcmUgbW9kZWxzIGluc3RlYWQgb2YganVzdCBpZHMuXG4gIHNlcmlhbGl6ZVRvTW9kZWxzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnNlcmlhbGl6ZSh7d2hvbGVNb2RlbDogdHJ1ZX0pO1xuICB9LFxuXG4gIC8vIHJldHVybiBqc29uIGJsb2Igb2Ygc2VyaWFsaXplZCBmaWx0ZXIgc3RhdGUsIGlkcyBvbmx5LlxuICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuc2VyaWFsaXplKHt9KTtcbiAgfSxcblxuICAvLyByZXN0b3JlcyBmaWx0ZXIgc3RhdGUgZ2l2ZW4gYSBqc29uIGJsb2IsIGlkcyBvbmx5LlxuICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24oc3RhdGVCbG9iLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5kZXNlcmlhbGl6ZShzdGF0ZUJsb2IsIG9wdGlvbnMpO1xuICB9LFxuXG4gIC8vIHJlc2V0IGZpbHRlcnMgdG8gZW1wdHkgc3RhdGVcbiAgcmVzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZpZXcucmVzZXRGaWx0ZXJzKCk7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnNpbGVudCkge1xuICAgICAgdGhpcy52aWV3LmFwcGx5RmlsdGVycygpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBzZWFyY2hlcyB0aGUgc2V0dGluZ3MgYXJyYXkgb2YgbW9kZWxzIGZvciB0aGUgb25lcyB3aGljaCBob2xkIHRoZSBtaW4vbWF4IHZhbHVlcyBpbnN0cnVjdGVkIHRvIGFuZCwgaWYgZm91bmQsXG4gICAqIHdyaXRlcyB0aGVtIGluIGZpbHRlcnNPdXQub3RoZXJGaWx0ZXJzLmRhdGUue3N0YXJ0fXtlbmR9XG4gICAqIFxuICAgKiB1c2UgaXQgYXMgYW4gdXRpbGl0eSBmdW5jdGlvbiAoaXQgZG9lcyBub3QgcmVmZXJlbmNlICd0aGlzJywgc28gXG4gICAqIGl0IGlzIHNhZmUgdG8gdXNlIGl0IGF0IGFueSBwb2ludCBpbiB0aGUgbGlmZWN5Y2xlIG9mIHRoZSB3aWRnZXRcbiAgICovXG4gIGV4dHJhY3REYXRlczogZnVuY3Rpb24oc2V0dGluZ3MsIGZpbHRlcnNPdXQsIG1pbk5hbWUsIG1heE5hbWUpIHtcblx0ICBmaWx0ZXJzT3V0Lm90aGVyRmlsdGVycyA9IGZpbHRlcnNPdXQub3RoZXJGaWx0ZXJzIHx8IHt9O1xuXHQgIGZpbHRlcnNPdXQub3RoZXJGaWx0ZXJzLmRhdGUgPSBmaWx0ZXJzT3V0Lm90aGVyRmlsdGVycy5kYXRlIHx8IFxuXHQgIFx0e1xuICAgIFx0XHRzdGFydDogJycsXG4gICAgXHRcdGVuZDogJydcblx0XHR9XG5cbiAgXHR2YXIgZGVmYXVsdE1pbkRhdGUgPSBfLmZpbmQoc2V0dGluZ3MsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS5nZXQoJ2lkJykgPT09IG1pbk5hbWU7XG5cdH0pO1xuXHRpZiAoZGVmYXVsdE1pbkRhdGUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0TWluRGF0ZS5nZXQoJ25hbWUnKSAhPT0gJycpIHtcblx0XHRmaWx0ZXJzT3V0Lm90aGVyRmlsdGVycy5kYXRlLnN0YXJ0ID0gZGVmYXVsdE1pbkRhdGUuZ2V0KCduYW1lJyk7XG5cdH1cblx0dmFyIGRlZmF1bHRNYXhEYXRlID0gXy5maW5kKHNldHRpbmdzLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0uZ2V0KCdpZCcpID09PSBtYXhOYW1lO1xuXHR9KTtcblx0aWYgKGRlZmF1bHRNYXhEYXRlICE9PSB1bmRlZmluZWQgJiYgZGVmYXVsdE1heERhdGUuZ2V0KCduYW1lJykgIT09ICcnKSB7XG5cdFx0ZmlsdGVyc091dC5vdGhlckZpbHRlcnMuZGF0ZS5lbmQgPSBkZWZhdWx0TWF4RGF0ZS5nZXQoJ25hbWUnKTtcblx0fVxuICB9LFxuXG59KTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0O1xuIiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuICAvLyBQYXJlbnQgbW9kZWwgZm9yIGZpbHRlcnMuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gIGRlZmF1bHRzOiB7XG4gICAgbmFtZTogJ0ZpbHRlciBOYW1lJyxcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHRvdGFsQ291bnQ6IDAsXG4gICAgYWN0aXZlQ291bnQ6IDAsXG4gICAgX2xvYWRlZDogZmFsc2UsXG4gICAgZW1wdHk6IGZhbHNlXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5zZXQoJ25hbWUnLCBvcHRpb25zLm5hbWUpO1xuICAgIHRoaXMuc2V0KCdncm91cCcsIG9wdGlvbnMuZ3JvdXAgfHwgb3B0aW9ucy5pZCk7XG4gICAgdGhpcy5zZXQoJ21ldGhvZCcsIG9wdGlvbnMubWV0aG9kKTtcbiAgICB0aGlzLnNldCgnY29sdW1uJywgb3B0aW9ucy5jb2x1bW4pOyBcbiAgICB0aGlzLnNldCgnZW1wdHknLCBvcHRpb25zLmVtcHR5IHx8IGZhbHNlKTtcbiAgICB0aGlzLnVybCA9ICBvcHRpb25zLnVybCB8fCBvcHRpb25zLmVuZHBvaW50O1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbnZhciBCYXNlRmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvYmFzZS1maWx0ZXItbW9kZWwnKTtcbnZhciBUcmVlTm9kZU1vZGVsID0gcmVxdWlyZSgnLi4vdHJlZS90cmVlLW5vZGUtbW9kZWwnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VGaWx0ZXJNb2RlbC5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6ZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIEJhc2VGaWx0ZXJNb2RlbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgIHRoaXMuZ2V0VHJlZSgpOyAvLyBzdGFydHMgZ2V0VHJlZSBjYWxsc1xuICB9LFxuXG4gIC8vIGxvYWQgdHJlZSBpZiBuZWVkZWQsIGVsc2UgcmV0dXJuIHdoYXQgd2UgYWxyZWFkeSBoYXZlLi5cbiAgZ2V0VHJlZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsb2FkZWQgPSB0aGlzLmdldCgnX2xvYWRlZCcpO1xuXG4gICAgaWYgKCFsb2FkZWQpIHtcbiAgICAgIHNlbGYuc2V0KCdfbG9hZGVkJywgdGhpcy5fY3JlYXRlVHJlZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gdHJpY2tsZSB1cCBudW1TZWxlY3RlZC5cbiAgICBcdCAgaWYoc2VsZi5nZXQoJ3RyZWUnKSE9IHVuZGVmaW5lZCl7XG4gICAgICAgIHNlbGYuZ2V0KCd0cmVlJykub24oJ2NoYW5nZTpudW1TZWxlY3RlZCcsIGZ1bmN0aW9uKG1vZGVsLCB2YWx1ZSkge1xuICAgICAgICAgIHNlbGYuc2V0KCdudW1TZWxlY3RlZCcsIHZhbHVlKTtcbiAgICAgICAgICBzZWxmLnNldCgnbnVtUG9zc2libGUnLCBzZWxmLmdldCgndHJlZScpLmdldCgnbnVtUG9zc2libGUnKSk7XG4gICAgICAgIH0pO1xuICAgIFx0ICB9XG4gICAgICAgIHJldHVybiBzZWxmLmdldCgndHJlZScpO1xuICAgICAgfSkpO1xuICAgICAgXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdfbG9hZGVkJyk7XG4gIH0sXG5cbiAgZ2V0TnVtU2VsZWN0ZWQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG51bVNlbGVjdGVkID0gdGhpcy5nZXQoJ251bVNlbGVjdGVkJyk7XG4gICAgLy8gaWYgbm9uZSBzZWxlY3RlZCwgb3IgYWxsIHNlbGVjdGVkLCB0cmVhdCB0aGUgc2FtZS5cbiAgICBpZiAoIW51bVNlbGVjdGVkIHx8IHRoaXMuZ2V0KCdudW1TZWxlY3RlZCcpID09PSB0aGlzLmdldCgnbnVtUG9zc2libGUnKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudW1TZWxlY3RlZDtcbiAgICB9XG4gIH0sXG5cbiAgc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHRyZWUgPSB0aGlzLmdldCgndHJlZScpO1xuICAgIGlmICghdHJlZSkge1xuICAgICAgLy9jb25zb2xlLndhcm4oJ25vIHRyZWUgZm91bmQnLCB0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHt9OyAvL25vIHRyZWUsIG5vdGhpbmcgdG8gc2VyaWFsaXplLlxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdG1wQXJ5ID0gdHJlZS5zZXJpYWxpemUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdG1wQXJ5O1xuICAgIH1cbiAgfSxcblxuICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24obGlzdE9mU2VsZWN0ZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRyZWUgPSB0aGlzLmdldCgndHJlZScpO1xuICAgIGlmIChsaXN0T2ZTZWxlY3RlZCkge1xuICAgICAgaWYgKCF0cmVlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZGVzZXJpYWxpemUgbm8gdHJlZSBmb3VuZCcsIHNlbGYpO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vbm8gdHJlZSwgbm90aGluZyB0byBzZXJpYWxpemUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmVlLmRlc2VyaWFsaXplKGxpc3RPZlNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmVlID0gdGhpcy5nZXQoJ3RyZWUnKTtcbiAgICBpZiAodHJlZSkge1xuICAgICAgLy8gVE9ETzogYWRkIGEgdGhpcmQgdHlwZSBmb3Igc2VtaS1maWxsZWRcbiAgICAgIC8vIGZvcmNlIHRyaWdnZXIsIGJlY2F1c2Ugb3RoZXJ3aXNlIG5vZGVzIHRoYXQgYXJlICdoYWxmLWZpbGxlZCcgYnV0IGZhbHNlIHdvbid0IHJlZnJlc2guXG4gICAgICB0cmVlLnNldCgnc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgIHRyZWUuc2V0KCdzZWxlY3RlZCcsIGZhbHNlKTtcblxuICAgIH1cbiAgfSxcblxuICBfY3JlYXRlVHJlZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnVybCkge1xuICAgICAgdGhpcy51cmwgPSB0aGlzLmdldCgnZW5kcG9pbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mZXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmdldCgnbWV0aG9kJyksXG4gICAgICBkYXRhOid7fSdcbiAgICB9KVxuICAgIC5mYWlsKGZ1bmN0aW9uKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgY29uc29sZS5lcnJvcignZmFpbGVkIHRvIGdldCBmaWx0ZXIgJywganFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICB9KTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpczsgICAgXG5cbiAgICAvL2lmIGl0J3MgYW4gb2JqLCBqYW0gaXQgaW50byBhbiBhcnJheSBmaXJzdCwgaGVscHMgc29sdmUgaW5jb25zaXN0YW5jeSBpbiBBUEkgZm9ybWF0LlxuICAgIGlmICghXy5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBkYXRhID0gW2RhdGFdO1xuICAgIH1cblxuICAgIGlmIChfLmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgcm9vdE5vZGVPYmogPSBudWxsO1xuICAgICAgLy8gQnVpbGRzIHRyZWUgb2Ygdmlld3MgZnJvbSByZXR1cm5lZCBkYXRhXG4gICAgICAvLyBJZiBkYXRhIGlzIGEgc2luZ2xlIGVsZW1lbnQsIGp1c3QgbWFrZSBpdCB0aGUgcm9vdC4uXG4gICAgICBcbiAgICAgIC8qIFRPRE8tQ09OU1RBTlRJTjogdGVtcG9yYXJ5IGNvbW1lbnQgdW50aWwgSSBmaW5pc2ggbGVhcm5pbmcgRmlsdGVycyBmcm9udGVuZFxuICAgICAgY29uc29sZS5sb2coXCJpdGVyYXRpbmcgXCIgKyBkYXRhLmxlbmd0aCArIFwiIGVsZW1zLi4uXCIpO1xuICAgICAgXy5lYWNoKGRhdGEsIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICBcdCAgY29uc29sZS5sb2coXCJcXHRuYW1lID0gXCIgKyBlbGVtLm5hbWUgKyBcIiwgaWQgPSBcIiArIGVsZW0uaWQpO1xuICAgICAgfSk7XG4gICAgICAqL1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgXHRpZihkYXRhWzBdLmZpbHRlcklkICYmICFkYXRhWzBdLm5hbWUpIHtcbiAgICAgICAgICBkYXRhWzBdLm5hbWUgPSAgZGF0YVswXS5maWx0ZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZihkYXRhWzBdLnZhbHVlcyl7XG4gICAgICAgICAgZGF0YVswXS5jaGlsZHJlbiA9ICBkYXRhWzBdLnZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbMF0uaXNTZWxlY3RhYmxlID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICAvL2RhdGFbMF0uZmlsdGVyTmFtZSA9IGRhdGFbMF0uZGlzcGxheU5hbWU7XG5cbiAgICAgICAgcm9vdE5vZGVPYmogPSBkYXRhWzBdO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290Tm9kZU9iaiA9IHtcbiAgICAgICAgICBpZDogLTEsXG4gICAgICAgICAgY29kZTogJy0xJyxcbiAgICAgICAgICBuYW1lOiBzZWxmLmdldCgnbmFtZScpLFxuICAgICAgICAgIGNoaWxkcmVuOiBkYXRhLFxuICAgICAgICAgIHNlbGVjdGVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgZXhwYW5kZWQ6IGZhbHNlLFxuICAgICAgICAgIGlzU2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICAgICAgY3JlYXRlVW5rb3duczogdHJ1ZS8qLFxuICAgICAgICAgIGZpbHRlck5hbWU6IHNlbGYuZ2V0KCdkaXNwbGF5TmFtZScpKi9cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyZWVNb2RlbCA9IG5ldyBUcmVlTm9kZU1vZGVsKHJvb3ROb2RlT2JqKTtcbiAgICAgIHNlbGYuc2V0KCd0cmVlJywgdHJlZU1vZGVsKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxufSk7XG5cbiIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbnZhciBHZW5lcmljRmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvZ2VuZXJpYy1maWx0ZXItbW9kZWwnKTtcbnZhciBUcmVlTm9kZU1vZGVsID0gcmVxdWlyZSgnLi4vdHJlZS90cmVlLW5vZGUtbW9kZWwnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyaWNGaWx0ZXJNb2RlbC5leHRlbmQoe1xuXG5cbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5sb2FkZWQgPSAkLkRlZmVycmVkKCk7XG4gICAgdGhpcy5fY3JlYXRlVHJlZShvcHRpb25zLmRhdGEpO1xuICAgIEdlbmVyaWNGaWx0ZXJNb2RlbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICB9LFxuXG4gIC8vb3JnIGRvZXNuJ3QgaGF2ZSBhc3luYyBwYXJ0LCBidXQgc3RpbGwgdXNlIGRlZmVycmVkLCBzbyBiZWhhdmVzIHNhbWUgYXMgZ2VuZXJpYyBmaWx0ZXIgbW9kZWxcbiAgZ2V0VHJlZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGVkO1xuICB9LFxuXG4gIF9jcmVhdGVUcmVlOmZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJvb3ROb2RlT2JqID0ge307XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICByb290Tm9kZU9iaiA9IGRhdGFbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3ROb2RlT2JqID0ge1xuICAgICAgICBpZDogLTEsXG4gICAgICAgIGNvZGU6ICctMScsXG4gICAgICAgIG5hbWU6IHNlbGYuZ2V0KCdkaXNwbGF5TmFtZScpLFxuICAgICAgICBmaWx0ZXJJZDogc2VsZi5nZXQoJ2ZpbHRlcklkJyksXG4gICAgICAgIGNoaWxkcmVuOiBkYXRhLFxuICAgICAgICBzZWxlY3RlZDogdW5kZWZpbmVkLFxuICAgICAgICBleHBhbmRlZDogZmFsc2UsXG4gICAgICAgIGlzU2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIGNyZWF0ZVVua293bnM6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciB0cmVlTW9kZWwgPSBuZXcgVHJlZU5vZGVNb2RlbChyb290Tm9kZU9iaik7XG4gICAgdGhpcy5zZXQoJ3RyZWUnLCB0cmVlTW9kZWwpO1xuXG4gICAgLy8gdHJpY2tsZSB1cCBudW1TZWxlY3RlZC5cbiAgICBzZWxmLmdldCgndHJlZScpLm9uKCdjaGFuZ2U6bnVtU2VsZWN0ZWQnLCBmdW5jdGlvbihtb2RlbCwgdmFsdWUpIHtcbiAgICAgIHNlbGYuc2V0KCdudW1TZWxlY3RlZCcsIHZhbHVlKTtcbiAgICAgIHNlbGYuc2V0KCdudW1Qb3NzaWJsZScsIHNlbGYuZ2V0KCd0cmVlJykuZ2V0KCdudW1Qb3NzaWJsZScpKTtcbiAgICB9KTtcblxuICAgIHRoaXMubG9hZGVkLnJlc29sdmUodHJlZU1vZGVsKTtcbiAgfVxuXG59KTtcblxuIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBCYXNlRmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvYmFzZS1maWx0ZXItbW9kZWwnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VGaWx0ZXJNb2RlbC5leHRlbmQoe1xuXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBzZWxlY3RlZFN0YXJ0OiBudWxsLFxuICAgIHNlbGVjdGVkRW5kOiBudWxsLFxuICAgIC8vIHJhbmdlIGlzIHByb3ZpZGVkIGJ5IGFwaSwgYnV0IHdpbGwgZmFsbGJhY2sgdG8gdGhpcyBpZiBub3QgcHJvdmlkZWQsIG9yIHNldCB0byAtMVxuICAgIHN0YXJ0WWVhcjogJycsXG4gICAgZW5kWWVhcjogJydcbiAgfSxcbiAgXG4gIHN5bmM6IGZ1bmN0aW9uICgpIHtcblx0ICAvKipcblx0ICAgKiBoYWNraXNoOiB0aGUgZGF0YSBjb21pbmcgb2ZmIHRoZSAvZGF0ZXMgZW5kcG9pbnQgc2hvdWxkIGJlIGlnbm9yZWQgYXQgYWxsIG1vbWVudHMsIGJlY2F1c2Vcblx0ICAgKiAxLiBmb3IgdGFicy9zYWlrdSwgaXQgc2hvdWxkIGFsd2F5cyBiZSBlbXB0eVxuXHQgICAqIDIuIGZvciBnaXMvZGFzaGJvYXJkcywgaXQgaXMgY29taW5nIG9mZiB0aGUgL3NldHRpbmcgZW5kcG9pbnRcblx0ICAgKiBcblx0ICAgKiBBbGwgdGhlIG90aGVyIHllYXJzLWZpbHRlci1tb2RlbCBzaG91bGQgYnkgc3BlYyBiZSBhbHdheXMgZW1wdHkgYXQgdGhpcyBwb2ludC4gSW4gY2FzZSB0aGlzIHdvdWxkIGNlYXNlIHRvIGJlIHRydWUgaW4gdGhlIGZ1dHVyZSxcblx0ICAgKiBqdXN0IGZpbHRlciBieSBcIm5hbWVcIlxuXHQgICAqLyBcblx0ICBcdFxuXHQgIC8vY29uc29sZS5lcnJvcignU1lOQ0lORyBZRUFSUyBNT0RFTDogJyArIHRoaXMuZ2V0KCduYW1lJykpO1xuXHQgIHJldHVybiAkLndoZW4odHJ1ZSk7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIEJhc2VGaWx0ZXJNb2RlbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgIHRoaXMudXJsID0gb3B0aW9ucy5lbmRwb2ludDtcbiAgICB0aGlzLnNldCgnX2xvYWRlZCcsICQuRGVmZXJyZWQoKSk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGRhdGEpIHtcblx0ICBjb25zb2xlLmxvZygneWVhcnMtZmlsdGVyLW1vZGVsLnBhcnNlOiBkYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICBpZiAoIWRhdGEuc3RhcnRZZWFyIHx8IGRhdGEuc3RhcnRZZWFyID09PSAtMSkge1xuICAgICAgZGF0YS5zdGFydFllYXIgPSB0aGlzLmRlZmF1bHRzLnN0YXJ0WWVhcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5zdGFydFllYXIgPSBkYXRhLnN0YXJ0WWVhciArICctMDEtMDEnO1xuICAgIH1cbiAgICBpZiAoIWRhdGEuZW5kWWVhciB8fCBkYXRhLmVuZFllYXIgPT09IC0xKSB7XG4gICAgICBkYXRhLmVuZFllYXIgPSB0aGlzLmRlZmF1bHRzLmVuZFllYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuZW5kWWVhciA9IGRhdGEuZW5kWWVhciArICctMTItMzEnO1xuICAgIH1cblxuICAgIGlmICghZGF0YS5zZWxlY3RlZFN0YXJ0KSB7XG4gICAgXHQvLyBnb29kIG9sZScgcGFydGlhbCBjb3B5LXBhc3RlIG9mZiBwb3N0cHJvY2VzcygpXG4gICAgXHRkYXRhLnNlbGVjdGVkU3RhcnQgPSBkYXRhLnN0YXJ0WWVhcjtcbiAgICBcdGRhdGEuc2VsZWN0ZWRFbmQgPSBkYXRhLmVuZFllYXI7XG4gICAgfVxuICAgIHRoaXMuZ2V0KCdfbG9hZGVkJykucmVzb2x2ZSgpO1xuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZ2V0KCdzZWxlY3RlZFN0YXJ0JykpIHtcbiAgICBcdCAgdmFyIGtleSA9IHRoaXMuZ2V0KCdjb2x1bW4nKSE9J04vQScgPyB0aGlzLmdldCgnY29sdW1uJyk6J2RhdGUnO1xuICAgIFx0ICBjb25zb2xlLmxvZygnc2VyaWFsaXppbmcgeWVhcnMtZmlsdGVyLW1vZGVsIGZvciAnICsga2V5ICsgJywgc3RhcnQgPSAnICsgdGhpcy5nZXQoJ3NlbGVjdGVkU3RhcnQnKSArICcsIGVuZCA9ICcgKyB0aGlzLmdldCgnc2VsZWN0ZWRFbmQnKSk7ICAgIFx0ICBcbiAgICBcdCAgdmFyIG9iaiA9IHt9O1xuICAgIFx0ICBvYmpba2V5XSA9IHtcblx0XHRcdFx0ICAvL3N0YXJ0OiB0aGlzLl9kYXRlQ29udmVydCh0aGlzLmdldCgnc2VsZWN0ZWRTdGFydCcpKSxcblx0XHRcdFx0ICAvL2VuZDogdGhpcy5fZGF0ZUNvbnZlcnQodGhpcy5nZXQoJ3NlbGVjdGVkRW5kJykpXG5cdFx0XHRcdCAgc3RhcnQ6IHRoaXMuZ2V0KCdzZWxlY3RlZFN0YXJ0JyksXG5cdFx0XHRcdCAgZW5kOiB0aGlzLmdldCgnc2VsZWN0ZWRFbmQnKVxuXHRcdFx0IH07XG4gICAgXHQgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogcG9zdHByb2Nlc3MgbW9kZWwgYWZ0ZXIgaGF2aW5nIGZldGNoZWQgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICovXG4gIHBvc3Rwcm9jZXNzOiBmdW5jdGlvbigpIHtcblx0ICAvLyBvbmx5IHNldCBpZiBub3Qgc2V0IGJ5IGRlc2VyaWFsaXplXG5cdCAgaWYgKCF0aGlzLmdldCgnc2VsZWN0ZWRTdGFydCcpKSB7XG5cdCAgXHQgIHRoaXMuc2V0KCdzZWxlY3RlZFN0YXJ0JywgdGhpcy5nZXQoJ3N0YXJ0WWVhcicpKTtcblx0ICAgXHQgIHRoaXMuc2V0KCdzZWxlY3RlZEVuZCcsIHRoaXMuZ2V0KCdlbmRZZWFyJykpO1xuXHQgIH1cbiAgfSxcbiAgXG4gIGRlc2VyaWFsaXplOiBmdW5jdGlvbihvYmopIHtcblx0dmFyIGtleSA9IHRoaXMuZ2V0KCdjb2x1bW4nKSAhPSAnTi9BJyA/IHRoaXMuZ2V0KCdjb2x1bW4nKSA6ICdkYXRlJztcblx0aWYgKG9iaiAmJiBvYmpba2V5XSkge1xuXHQgIHRoaXMuc2V0KCdzZWxlY3RlZFN0YXJ0JywgdGhpcy5fZGF0ZUNvbnZlcnQob2JqW2tleV0uc3RhcnQpKTtcblx0ICB0aGlzLnNldCgnc2VsZWN0ZWRFbmQnLCB0aGlzLl9kYXRlQ29udmVydChvYmpba2V5XS5lbmQpKTtcbiAgICAgIHRoaXMucG9zdHByb2Nlc3MoKTtcblx0fVxuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldCgnc2VsZWN0ZWRTdGFydCcsIHRoaXMuZ2V0KCdzdGFydFllYXInKSk7XG4gICAgdGhpcy5zZXQoJ3NlbGVjdGVkRW5kJywgdGhpcy5nZXQoJ2VuZFllYXInKSk7XG4gIH0sXG5cbiAgLy8gY29udmVydHM6IDAzLzAxLzE5NjEgPT0+IDE5NjEtMDEtMDEgSUYgTkVFREVELlxuICAvLyBET0VTIE5PVCBDT05WRVJUIGZyb20gdGhlIFwiLVwiIGZvcm1hdCB0byBcIi9cIiBmb3JtYXQgYW55bW9yZVxuICAvLyBcbiAgLy8gYW1wIGV4cGVjdHMgd2l0aCAnLScgYW5kIGpRdWVyeSB3YW50cyB3aXRoICcvJ1xuICBfZGF0ZUNvbnZlcnQ6IGZ1bmN0aW9uKGlucHV0KXtcblx0ICBjb25zb2xlLmxvZygnYXNrZWQgdG8gY29udmVydCBpbnB1dDogJyArIGlucHV0KTtcbiAgICB2YXIgb3V0cHV0ID0gbnVsbDtcbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5pbmRleE9mKCcvJyk+LTEpe1xuICAgICAgICBpbnB1dCA9IGlucHV0LnNwbGl0KCcvJyk7XG4gICAgICAgIG91dHB1dCA9IGlucHV0WzJdICsgJy0nICsgaW5wdXRbMV0gKyAnLScgKyBpbnB1dFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgXHQgIG91dHB1dCA9IGlucHV0O1xuICAgICAgfVxuICAgICAgLyogZWxzZSBpZihpbnB1dC5pbmRleE9mKCctJyk+LTEpe1xuICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0LnNwbGl0KCctJyk7XG4gICAgICAgIG91dHB1dCA9IGlucHV0WzJdICsgJy8nICsgaW5wdXRbMV0gKyAnLycgKyBpbnB1dFswXTtcbiAgICAgIH0qL1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIFRyZWVOb2RlTW9kZWw7IC8vIGRlY2xhcmUgaGVyZSB0byBoZWxwIHdpdGggcmVmIGxvb3Agb2YgY29sbGVjdGlvbiBhbmQgbW9kZWxcbnZhciBUcmVlTm9kZUNvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7ICBtb2RlbDpUcmVlTm9kZU1vZGVsIH0pO1xuXG4vL1RPRE86IHByb3BhZ2F0aW9uIGJ1ZyBpZiBtaWQgbGV2ZWwgbm9kZSBpcyBoYWxmIGZpbGxlZCBhbmQgeW91ICdkZXNlbGVjdCBhbGwnIGl0IHdvbid0IHByb3BvZ2F0ZSB0byBjaGlsZHJlbi5cblxuVHJlZU5vZGVNb2RlbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gIGRlZmF1bHRzOntcbiAgICBzZWxlY3RlZDogdW5kZWZpbmVkLCAgLy8gZGVmYXVsdCBpcyBzZWxlY3RlZC4gY2hhbmdlIHRvIHN0cmluZyAvIHRlcm5hcnksIGZvciBvZmYsIHNlbWksIGFuZCBvblxuICAgIGV4cGFuZGVkOiB0cnVlLFxuICAgIHZpc2libGU6IHRydWUsXG4gICAgbnVtU2VsZWN0ZWQ6IDAsXG4gICAgbnVtUG9zc2libGU6IDAsXG4gICAgY2hpbGRyZW46IG51bGwsICAgICAvLyB0eXBlIFRyZWVOb2RlQ29sbGVjdGlvblxuICAgIGlzU2VsZWN0YWJsZTogZmFsc2UgIC8vIGlzIHRoaXMgbm9kZSBpdHNlbGYgc2VsZWN0YWJsZSAoaWUuIHNob3VsZCBpdCBoYXZlIGFuICd1bmtvd24nIGNoaWxkKVxuICB9LFxuXG4gIGluaXRpYWxpemU6ZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGlsZHJlbkNvbGxlY3Rpb24gPSBuZXcgVHJlZU5vZGVDb2xsZWN0aW9uKCk7XG4gICAgdGhpcy5zZXQoJ2NoaWxkcmVuJywgY2hpbGRyZW5Db2xsZWN0aW9uKTtcbiAgICBcbiAgICAvKiBUT0RPLUNPTlNUQU5USU46IHRlbXBvcmFyeSBjb21tZW50IHVudGlsIEkgYW0gZmluaXNoZWQgbGVhcm5pbmcgRmlsdGVycyBmcm9udGVuZCBcbiAgICAgY29uc29sZS5sb2coXCJidWlsZGluZyBhIHRyZWUgbm9kZSBtb2RlbCBmb3I6IFwiICsgSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgICovXG4gICAgXG4gICAgLy9pdGVyYXRlIG92ZXIgY2hpbGRyZW5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmouY2hpbGRyZW4pKSB7XG4gICAgICBfLmVhY2gob2JqLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgbmV3Q2hpbGQgPSBuZXcgVHJlZU5vZGVNb2RlbChjaGlsZCk7XG4gICAgICAgIGNoaWxkcmVuQ29sbGVjdGlvbi5hZGQobmV3Q2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBjaGlsZHJlbiwgdGhlbiBhZGQgc2VsZiBhcyBhIGxlYWYgbm9kZSwgJ3Vua293bidcbiAgICBpZiAoIWNoaWxkcmVuQ29sbGVjdGlvbi5pc0VtcHR5KCkgJiYgIHRoaXMuZ2V0KCdpc1NlbGVjdGFibGUnKSkge1xuICAgICAgdmFyIHVua293bk5vZGUgPSBuZXcgVHJlZU5vZGVNb2RlbChzZWxmLnRvSlNPTigpKTtcbiAgICAgIHVua293bk5vZGUuc2V0KCduYW1lJywgJ3Vua293bjogJyArIHRoaXMuZ2V0KCduYW1lJykpO1xuICAgICAgY2hpbGRyZW5Db2xsZWN0aW9uLmFkZCh1bmtvd25Ob2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hZGRMaXN0ZW5lcnNUb0NoaWxkcmVuKCk7XG5cbiAgICB0aGlzLm9uKCdjaGFuZ2U6c2VsZWN0ZWQnLCBzZWxmLl9vblNlbGVjdENoYW5nZSk7XG5cbiAgICB0aGlzLl91cGRhdGVDb3VudCgpO1xuICB9LFxuXG5cbiAgLy8gbWVyZ2UgYmFzZWQgb24gZmlsdGVySWQgYXMgd2Ugc2VyaWFsaXplLi4uLlxuICAvLyBvcHRpb25zLndob2xlTW9kZWwgcmV0dXJucyB3aG9sZSBNb2RlbHMgaW5zdGVhZCBvZiBqdXN0IGlkc1xuICAvLyBvcHRpb25zLmluY2x1ZGVVbnNlbGVjdGVkIHJldHVybnMgZnVsbCB0cmVlLCBldmVuIGlmIG5vZGVzIGFyZSBub3Qgc2VsZWN0ZWQuXG4gIC8vIENvZGUgZXhwbGljaXRseSBpZ25vcmVzIERvbm9yIEdyb3VwIGFuZCBEb25vciBUeXBlLlxuICAvLyAgIHRoZXkgb25seSBoYXZlIEZpbHRlcklkcyBmb3IgZGVzZXJpYWxpemUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAvLyBUT0RPOiBjb25zaWRlciBwdWxsaW5nIG91dCBvcHRpb25zLmluY2x1ZGVVbnNlbGVjdGVkIGludG8gaXRzIG93biBmdW5jdGlvbiBnZXRBbGxGaWx0ZXJzKClcbiAgc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHRtcFNlcmlhbGl6ZWQgPSB7fTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldCgnY2hpbGRyZW4nKTtcblxuICAgIC8qKlxuICAgICAgICBcbiAgICAgXG4gICstLV4tLS0tLS0tLS0tLC0tLS0tLS0tLC0tLS0tLC0tLS0tLS0tXi0sXG4gIHwgfHx8fHx8fHx8ICAgYC0tLS0tLS0tJyAgICAgfCAgICAgICAgICBPXG4gIGArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXi0tLS0tLS0tLS18XG4gICAgYFxcXywtLS0tLS0tLS0sLS0tLS0tLS0tLC0tLS0tLS0tLS0tLS0tJ1xuICAgICAgLyBYWFhYWFggLyd8ICAgICAgIC8nXG4gICAgIC8gWFhYWFhYIC8gIGBcXCAgICAvJyAgICAgICAgICAgICAgICAgICAgICBUTyBJTlZFU1RJR0FURTogd2h5IGlzIHRoaXMgZnVuY3Rpb24gY2FsbGVkIGZvciA0IHRpbWVzICghISEpIHBlciBlYWNoIGl0ZW0gd2hlbiBwcmVzc2luZyBcImFwcGx5XCI/XG4gICAgLyBYWFhYWFggL2AtLS0tLS0tJ1xuICAgLyBYWFhYWFggL1xuICAvIFhYWFhYWCAvXG4gKF9fX19fX19fKCAgICAgICAgICAgICAgICBcbiAgIFxuICAgIFxuLy8gXG4vLyAgICBpZiAoKHRoaXMuZ2V0KCduYW1lJyk9PSAnWWVzJykgfHwgKHRoaXMuZ2V0KCduYW1lJykgPT0gJ05vJykgfHwgKHRoaXMuZ2V0KCduYW1lJykgPT0gJ0FsbCcpIHx8IHRoaXMuZ2V0KCduYW1lJykgPT0gJ0h1bWFuaXRhcmlhbiBBaWQnIHx8IHRoaXMuZ2V0KCduYW1lJykgPT0gJ0Rpc2FzdGVyIFJlc3BvbnNlIE1hcmtlcicpIHtcbi8vICAgIFx0Y29uc29sZS5sb2coJ3NlcmlhbGl6aW5nIG5vZGUgd2l0aCBuYW1lICcgKyB0aGlzLmdldCgnbmFtZScpICsgXCIsIHNlbGVjdGVkOiBcIiArIHRoaXMuZ2V0KCdzZWxlY3RlZCcpKTtcbi8vXG4vLyAgICBcdGRlYnVnZ2VyO1xuLy8gICAgfVxuKi9cbiAgICBcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlVW5zZWxlY3RlZCkge1xuICAgICAgaWYodGhpcy5nZXQoJ2ZpbHRlcklkJykgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgIT09ICdEb25vciBHcm91cCcgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgIT09ICdEb25vciBUeXBlJyl7XG4gICAgICAgIHRtcFNlcmlhbGl6ZWRbdGhpcy5nZXQoJ2ZpbHRlcklkJyldID0gKG9wdGlvbnMud2hvbGVNb2RlbD8gW3RoaXNdOlt0aGlzLmlkXSk7XG4gICAgICB9IGVsc2V7XG4gICAgICAgIHRtcFNlcmlhbGl6ZWQudW5hc3NpZ25lZCA9IChvcHRpb25zLndob2xlTW9kZWw/IFt0aGlzXTpbdGhpcy5pZF0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2VyaWFsaXplQ2hpbGRyZW4odG1wU2VyaWFsaXplZCwgY2hpbGRyZW4sIG9wdGlvbnMpO1xuICAgIH0gZWxzZXtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgLy8gSWYgYWxsIGNoaWxkcmVuIGFyZSBzZWxlY3RlZCwgYW5kIHdlIGhhdmUgb3VyIG93biBmaWx0ZXJJZCwgdGhlbiBqdXN0IHVzZSBvdXIgaWQsIGRvbid0IHJlY3Vyc2UuXG4gICAgICAgIGlmKHRoaXMuZ2V0KCdudW1TZWxlY3RlZCcpID49IHRoaXMuZ2V0KCdudW1Qb3NzaWJsZScpICYmIHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICYmIHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICE9PSAnRG9ub3IgR3JvdXAnICYmIHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICE9PSAnRG9ub3IgVHlwZScpe1xuICAgICAgICAgIHRtcFNlcmlhbGl6ZWRbdGhpcy5nZXQoJ2ZpbHRlcklkJyldID0gKG9wdGlvbnMud2hvbGVNb2RlbD8gW3RoaXNdOlt0aGlzLmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2VyaWFsaXplQ2hpbGRyZW4odG1wU2VyaWFsaXplZCwgY2hpbGRyZW4sIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vbm8gY2hpbGRyZW4gc28ganVzdCByZXR1cm4gc2VsZi5cbiAgICAgICAgaWYgKHRoaXMuZ2V0KCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgaWYodGhpcy5nZXQoJ2ZpbHRlcklkJykgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgIT09ICdEb25vciBHcm91cCcgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgIT09ICdEb25vciBUeXBlJyl7XG4gICAgICAgICAgICB0bXBTZXJpYWxpemVkW3RoaXMuZ2V0KCdmaWx0ZXJJZCcpXSA9IChvcHRpb25zLndob2xlTW9kZWw/IFt0aGlzXTpbdGhpcy5pZF0pO1xuICAgICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgIHRtcFNlcmlhbGl6ZWQudW5hc3NpZ25lZCA9IChvcHRpb25zLndob2xlTW9kZWw/IFt0aGlzXTpbdGhpcy5pZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21lcmdlVW5hc3NpZ25lZCh0bXBTZXJpYWxpemVkKTtcbiAgICByZXR1cm4gdG1wU2VyaWFsaXplZDtcbiAgfSxcblxuICBfc2VyaWFsaXplQ2hpbGRyZW46IGZ1bmN0aW9uKHRtcFNlcmlhbGl6ZWQsIGNoaWxkcmVuLCBvcHRpb25zKXtcbiAgICBjaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICB2YXIgc2VyaWFsaXplZENoaWxkID0gY2hpbGQuc2VyaWFsaXplKG9wdGlvbnMpO1xuICAgICAgXy5lYWNoKHNlcmlhbGl6ZWRDaGlsZCwgZnVuY3Rpb24odixrKXtcbiAgICAgICAgaWYodil7XG4gICAgICAgICAgLy9tZXJnZSBpZiBrZXkgZXhpc3RzXG4gICAgICAgICAgaWYgKHRtcFNlcmlhbGl6ZWRba10pIHtcbiAgICAgICAgICAgIHRtcFNlcmlhbGl6ZWRba10gPSB0bXBTZXJpYWxpemVkW2tdLmNvbmNhdCh2KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG1wU2VyaWFsaXplZFtrXSA9IHY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICBfbWVyZ2VVbmFzc2lnbmVkOiBmdW5jdGlvbih0bXBTZXJpYWxpemVkKXtcbiAgICAvLyBpZiBjdXJyZW50IG5vZGUgaGFzIGEgZmlsdGVySWQgcHV0IGFsbCAndW5hc3NpZ25lZCcgZWxlbWVudHMgdW5kZXIgdGhpcy5cbiAgICBpZih0aGlzLmdldCgnZmlsdGVySWQnKSl7XG4gICAgICB2YXIgZmlsdGVySWQgPSB0aGlzLmdldCgnZmlsdGVySWQnKTtcbiAgICAgIGlmKHRtcFNlcmlhbGl6ZWRbZmlsdGVySWRdICYmIHRtcFNlcmlhbGl6ZWQudW5hc3NpZ25lZCl7XG4gICAgICAgIHRtcFNlcmlhbGl6ZWRbZmlsdGVySWRdID0gdG1wU2VyaWFsaXplZFtmaWx0ZXJJZF0uY29uY2F0KHRtcFNlcmlhbGl6ZWQudW5hc3NpZ25lZCk7XG4gICAgICAgIGRlbGV0ZSB0bXBTZXJpYWxpemVkLnVuYXNzaWduZWQ7XG4gICAgICB9IGVsc2UgaWYgKHRtcFNlcmlhbGl6ZWQudW5hc3NpZ25lZCl7XG4gICAgICAgIHRtcFNlcmlhbGl6ZWRbZmlsdGVySWRdID0gdG1wU2VyaWFsaXplZC51bmFzc2lnbmVkO1xuICAgICAgICBkZWxldGUgdG1wU2VyaWFsaXplZC51bmFzc2lnbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24oYmxvYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldCgnY2hpbGRyZW4nKTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBpZighY2hpbGQuZ2V0KCdmaWx0ZXJJZCcpICYmIHNlbGYuZ2V0KCdmaWx0ZXJJZCcpKXtcbiAgICAgICAgICBjaGlsZC5zZXQoJ2ZpbHRlcklkJywgc2VsZi5nZXQoJ2ZpbHRlcklkJykpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkLmRlc2VyaWFsaXplKGJsb2IpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYoYmxvYlt0aGlzLmdldCgnZmlsdGVySWQnKV0pe1xuICAgICAgaWYgKF8oYmxvYlt0aGlzLmdldCgnZmlsdGVySWQnKV0pLmluZGV4T2YodGhpcy5pZCkgPiAtMSkge1xuICAgICAgICB0aGlzLnNldCgnc2VsZWN0ZWQnLCB0cnVlLCB7cHJvcGFnYXRpb246IHRydWV9KTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0KCdzZWxlY3RlZCcsIGZhbHNlLCB7cHJvcGFnYXRpb246IHRydWV9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cblxuICBfb25TZWxlY3RDaGFuZ2U6ZnVuY3Rpb24obW9kZWwsIGFyZ3VtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuXG4gICAgaWYgKHRoaXMuZ2V0KCdzZWxlY3RlZCcpKSB7XG4gICAgICB0aGlzLnNldCgnbnVtU2VsZWN0ZWQnLCB0aGlzLmdldCgnbnVtUG9zc2libGUnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0KCdudW1TZWxlY3RlZCcsIDApO1xuICAgIH1cblxuICAgIGlmICghY2hpbGRyZW4uaXNFbXB0eSgpKSB7XG4gICAgICBzZWxmLl91cGRhdGVDaGlsZE5vZGVzKG9wdGlvbnMucHJvcGFnYXRpb24pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnByb3BhZ2F0aW9uKSB7XG4gICAgICBzZWxmLnRyaWdnZXIoJ3VwZGF0ZUNvdW50Jyk7XG4gICAgfVxuICB9LFxuXG5cbiAgX2FkZExpc3RlbmVyc1RvQ2hpbGRyZW46ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuICAgIGNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGNoaWxkLm9uKCdjaGFuZ2U6dmlzaWJsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJZiBubyBjaGlsZHJlbiBhcmUgdmlzaWJsZSwgdGhlbiBoaWRlIHNlbGYuXG4gICAgICAgIGlmICghY2hpbGRyZW4uZmluZFdoZXJlKHt2aXNpYmxlOiB0cnVlfSkpIHtcbiAgICAgICAgICBzZWxmLnNldCh7dmlzaWJsZTogZmFsc2V9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnNldCh7dmlzaWJsZTogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNoaWxkLm9uKCd1cGRhdGVDb3VudCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl91cGRhdGVDb3VudCgpO1xuICAgICAgICBzZWxmLnRyaWdnZXIoJ3VwZGF0ZUNvdW50Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICBfdXBkYXRlQ291bnQ6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgdmFyIGNvdW50VG90YWwgPSB7XG4gICAgICBzZWxlY3RlZDogMCxcbiAgICAgIHBvc3NpYmxlOjBcbiAgICB9O1xuXG4gICAgaWYgKCFjaGlsZHJlbi5pc0VtcHR5KCkpIHtcbiAgICAgIGNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgY291bnRUb3RhbC5zZWxlY3RlZCArPSBjaGlsZC5nZXQoJ251bVNlbGVjdGVkJyk7XG4gICAgICAgIGNvdW50VG90YWwucG9zc2libGUgKz0gY2hpbGQuZ2V0KCdudW1Qb3NzaWJsZScpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50VG90YWwgPSB7XG4gICAgICAgIHNlbGVjdGVkOiAodGhpcy5nZXQoJ3NlbGVjdGVkJykgPyAxIDogMCksXG4gICAgICAgIHBvc3NpYmxlOiAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuc2V0KCdudW1TZWxlY3RlZCcsIGNvdW50VG90YWwuc2VsZWN0ZWQpO1xuICAgIHRoaXMuc2V0KCdudW1Qb3NzaWJsZScsIGNvdW50VG90YWwucG9zc2libGUpO1xuICB9LFxuXG4gIF91cGRhdGVDaGlsZE5vZGVzOmZ1bmN0aW9uKHByb3BhZ2F0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuXG4gICAgaWYgKCFjaGlsZHJlbi5pc0VtcHR5KCkpIHtcbiAgICAgIGNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuc2V0KCdzZWxlY3RlZCcsIHNlbGYuZ2V0KCdzZWxlY3RlZCcpLCB7cHJvcGFnYXRpb246IHByb3BhZ2F0aW9ufSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgZmlsdGVyVGV4dDogZnVuY3Rpb24odHh0KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXQoJ2NoaWxkcmVuJyk7XG5cbiAgICBpZiAoIWNoaWxkcmVuLmlzRW1wdHkoKSkge1xuICAgICAgLy8gaWYgdGhlIG5vZGUgaXRzZWxmIG1hdGNoZXMsIHR1cm4gaXQgb24sIGV2ZW4gaWYgbm8gY2hpbGRyZW4gYXJlIHZpc2libGUuXG4gICAgICBpZiAodGhpcy5nZXQoJ25hbWUnKSAmJiB0aGlzLmdldCgnbmFtZScpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0eHQpID4gLTEpIHtcbiAgICAgICAgdGhpcy5zZXQoJ3Zpc2libGUnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gRllJOiBwdXR0aW5nIGluc2lkZSBhbiBlbHNlIGFib3ZlIGtlZXBzIGNoaWxkcmVuIHZpc2libGUgaWYgcGFyZW50IG1hdGNoZXMuXG4gICAgICBjaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLmZpbHRlclRleHQodHh0KTtcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmdldCgnbmFtZScpICYmIHRoaXMuZ2V0KCduYW1lJykudG9Mb3dlckNhc2UoKS5pbmRleE9mKHR4dCkgPiAtMSkge1xuICAgICAgICB0aGlzLnNldCgndmlzaWJsZScsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXQoJ3Zpc2libGUnLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJlZU5vZGVNb2RlbDtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIFRlbXBsYXRlID0gXCI8ZGl2IGNsYXNzPVxcXCJub2RlIHNtYWxsXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcInNlbGVjdGFibGVcXFwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwidG9nZ2xlLW5hdlxcXCI+XFxuICAgIDwlIGlmKG5hbWUubGVuZ3RoID4gNjMpeyAlPlxcbiAgICAgIDxzcGFuIHRpdGxlPVxcXCI8JT0gbmFtZSAlPlxcXCI+PCU9IG5hbWUuc3Vic3RyaW5nKDAsNjApICU+Li4uPC9zcGFuPlxcbiAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgIDwlPSBuYW1lICU+XFxuICAgIDwlIH0gJT5cXG5cXG5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImNvdW50XFxcIj4oPCU9IG51bVNlbGVjdGVkICU+IC8gPCU9IG51bVBvc3NpYmxlICU+KTwvc3Bhbj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImV4cGFuZGVkXFxcIj4rPC9zcGFuPlxcbiAgPC9kaXY+XFxuXFxuICA8JSAvKlRPRE86IGZpeCBoYXJkY29kZSBvZiAndW5rb3duJyAqL1xcbiAgaWYgKG9iai5uYW1lICYmIG9iai5uYW1lLmluZGV4T2YoXFxcInVua293blxcXCIpPi0xKSB7ICU+XFxuICAgICZuYnNwOzxhIGhyZWY9XFxcIiNcXFwiXFxuICAgICAgZGF0YS10b2dnbGU9XFxcInBvcG92ZXJcXFwiXFxuICAgICAgZGF0YS1jb250YWluZXI9XFxcImJvZHlcXFwiXFxuICAgICAgZGF0YS1wbGFjZW1lbnQ9XFxcInJpZ2h0XFxcIlxcbiAgICAgIGRhdGEtdHJpZ2dlcj1cXFwiY2xpY2tcXFwiXFxuICAgICAgZGF0YS1jb250ZW50PVxcXCJwcm9qZWN0cyB0aGF0IGFyZW4ndCB0YWdnZWQgdG8gYSBzcGVjaWZpYyBjaGlsZC5cXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWluZm8tc2lnblxcXCI+PC9zcGFuPlxcbiAgICA8L2E+XFxuICA8JX0lPlxcbjwvZGl2PlxcblwiO1xuXG5cbnZhciBUcmVlTm9kZVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG5cbiAgdGFnTmFtZTogJ2xpJyxcbiAgY2xhc3NOYW1lOiAncGFyZW50X2xpJyxcblxuICAvL1RPRE86IGRlYnVnIGFmdGVyIHVzYWJpbGl0eSB0ZXN0aW5nLCBjdXJyZW50bHkgc2V0dGluZyBpbiBhZGRVSUxpc3RlbmVyc1xuICAvLyB3b24ndCB3b3JrIG9uIHNlY29uZCB1c2Ugb2Ygd2lkZ2V0LlxuICAvLyBldmVudHM6IHtcbiAgLy8gICAnY2xpY2sgLnNlbGVjdGFibGUnOiAnc2VsZWN0JyxcbiAgLy8gICAnY2xpY2sgIC50b2dnbGUtbmF2JzogJ2NsaWNrTmFtZSdcbiAgLy8gfSxcblxuICB0ZW1wbGF0ZTogXy50ZW1wbGF0ZShUZW1wbGF0ZSksXG5cbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbigpIHtcbiAgfSxcblxuXG4gIHJlbmRlcjpmdW5jdGlvbihtb2RlbCkge1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZShtb2RlbC50b0pTT04oKSkpO1xuICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbmRlckNoaWxkcmVuOmZ1bmN0aW9uKCkge1xuICAgIHZhciB1bCA9ICQoJzx1bD4nKTtcbiAgICB0aGlzLiRlbC5hcHBlbmQodWwpO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5tb2RlbC5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5pc0VtcHR5KCkpIHtcbiAgICAgIGNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgdmFyIHRtcFZpZXcgPSBuZXcgVHJlZU5vZGVWaWV3KCk7XG4gICAgICAgIHVsLmFwcGVuZCh0bXBWaWV3LnJlbmRlcihjaGlsZCkuJGVsKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiQoJy5leHBhbmRlZCcpLnJlbW92ZSgpO1xuICAgICAgdGhpcy4kKCc+IC5ub2RlID4gLnRvZ2dsZS1uYXYgPiAuY291bnQnKS50ZXh0KCcnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hZGRNb2RlbExpc3RlbmVycygpO1xuICAgIHRoaXMuX2FkZFVJTGlzdGVuZXJzKCk7XG5cbiAgICB0aGlzLl91cGRhdGVTZWxlY3Rpb24oKTtcbiAgICB0aGlzLl91cGRhdGVFeHBhbmRlZCh1bCk7XG4gIH0sXG5cbiAgX2FkZE1vZGVsTGlzdGVuZXJzOmZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vQWRkIG1vZGVsIGxpc3RlbmVyZXNcbiAgICB0aGlzLm1vZGVsLm9uKCdjaGFuZ2U6c2VsZWN0ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX3VwZGF0ZVNlbGVjdGlvbigpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tb2RlbC5vbignY2hhbmdlOmV4cGFuZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl91cGRhdGVFeHBhbmRlZCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tb2RlbC5vbignY2hhbmdlOm51bVNlbGVjdGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl91cGRhdGVDb3VudFVJKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1vZGVsLm9uKCdjaGFuZ2U6dmlzaWJsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fdXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIF9hZGRVSUxpc3RlbmVyczpmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy4kKCc+IC5ub2RlID4gLnNlbGVjdGFibGUnKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuY2xpY2tCb3goKTtcblxuICAgIH0pO1xuICAgIHRoaXMuJCgnPiAubm9kZSA+IC50b2dnbGUtbmF2Jykub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmNsaWNrTmFtZSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIF91cGRhdGVTZWxlY3Rpb246ZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdXBkYXRlQ2hlY2tib3hGaWxsKCk7XG4gIH0sXG5cbiAgX3VwZGF0ZUNvdW50VUk6ZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm1vZGVsLmdldCgnY2hpbGRyZW4nKS5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuJCgnPiAubm9kZSA+IC50b2dnbGUtbmF2ID4gLmNvdW50JykudGV4dChcbiAgICAgICAgJygnICsgdGhpcy5tb2RlbC5nZXQoJ251bVNlbGVjdGVkJykgKyAnIC8gJyArIHRoaXMubW9kZWwuZ2V0KCdudW1Qb3NzaWJsZScpICsgJyknKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNoZWNrYm94RmlsbCgpO1xuICAgIH1cbiAgfSxcblxuICBfdXBkYXRlVmlzaWJpbGl0eTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCd2aXNpYmxlJykpIHtcbiAgICAgIHRoaXMuJGVsLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWwuaGlkZSgpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIEZvciB1cGRhdGluZyBub24tbGVhZiBub2Rlc1xuICBfdXBkYXRlQ2hlY2tib3hGaWxsOmZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5tb2RlbC5nZXQoJ2NoaWxkcmVuJykuaXNFbXB0eSgpKSB7XG4gICAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ251bVNlbGVjdGVkJykgPiAwKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmdldCgnbnVtU2VsZWN0ZWQnKSA8IHRoaXMubW9kZWwuZ2V0KCdudW1Qb3NzaWJsZScpKSB7XG4gICAgICAgICAgdGhpcy4kKCc+IC5ub2RlID4gLnNlbGVjdGFibGUnKS5hZGRDbGFzcygnaGFsZi1maWxsJyk7XG4gICAgICAgICAgdGhpcy4kKCc+IC5ub2RlID4gLnNlbGVjdGFibGUnKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiQoJz4gLm5vZGUgPiAuc2VsZWN0YWJsZScpLnJlbW92ZUNsYXNzKCdoYWxmLWZpbGwnKTtcbiAgICAgICAgICB0aGlzLiQoJz4gLm5vZGUgPiAuc2VsZWN0YWJsZScpLmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZWwuZ2V0KCdudW1TZWxlY3RlZCcpID09PSAwKSB7XG4gICAgICAgIHRoaXMuJCgnPiAubm9kZSA+IC5zZWxlY3RhYmxlJykucmVtb3ZlQ2xhc3MoJ2hhbGYtZmlsbCcpO1xuICAgICAgICB0aGlzLiQoJz4gLm5vZGUgPiAuc2VsZWN0YWJsZScpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIGVsc2UgbGVhZiBub2RlXG4gICAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgdGhpcy4kKCc+IC5ub2RlID4gLnNlbGVjdGFibGUnKS5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJCgnPiAubm9kZSA+IC5zZWxlY3RhYmxlJykucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF91cGRhdGVFeHBhbmRlZDpmdW5jdGlvbih1bCkge1xuICAgIHZhciBpRWxlbWVudCA9IHRoaXMuJCgnPiAubm9kZSA+IC50b2dnbGUtbmF2ID4gLmV4cGFuZGVkJyk7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdleHBhbmRlZCcpKSB7XG4gICAgICB0aGlzLmV4cGFuZCgpO1xuICAgICAgaUVsZW1lbnQudGV4dCgnLScpO1xuICAgICAgaUVsZW1lbnQuYWRkQ2xhc3MoJ29wZW4nKS5yZW1vdmVDbGFzcygnY2xvc2VkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29sbGFwc2UoKTtcblxuICAgICAgLy8gdG8gcnVuIG9uIGZpcnN0IHRpbWUuLi5uZWVkIHRvIHVzZSB1bCwgc2luY2UgZWwgaXMgbm90IG9uIERPTSB5ZXRcbiAgICAgIGlmICh1bCkge1xuICAgICAgICB1bC5maW5kKCc+IGxpJykuaGlkZSgpO1xuICAgICAgfVxuXG4gICAgICBpRWxlbWVudC50ZXh0KCcrJyk7XG4gICAgICBpRWxlbWVudC5hZGRDbGFzcygnY2xvc2VkJykucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcbiAgICB9XG4gIH0sXG5cblxuICBjbGlja0JveDpmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1vZGVsLnNldCgnc2VsZWN0ZWQnLCAhdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkJyksIHtwcm9wYWdhdGlvbjogdHJ1ZX0pO1xuICB9LFxuXG5cbiAgY2xpY2tOYW1lOmZ1bmN0aW9uKCkge1xuICAgIC8vIGlmIHdlIGhhdmUgY2hpbGRyZW4gZXhwYW5kXG4gICAgaWYgKCF0aGlzLm1vZGVsLmdldCgnY2hpbGRyZW4nKS5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMubW9kZWwuc2V0KCdleHBhbmRlZCcsICF0aGlzLm1vZGVsLmdldCgnZXhwYW5kZWQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxlYWYgbm9kZSwgc28gcHJldGVuZCB0aGUgY2xpY2tlZCBvbiB0aGUgYm94XG4gICAgICB0aGlzLmNsaWNrQm94KCk7XG4gICAgfVxuICB9LFxuXG5cbiAgY29sbGFwc2U6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kZWwuZmluZCgnID4gdWwgPiBsaScpO1xuICAgIGNoaWxkcmVuLmhpZGUoJ2Zhc3QnKTtcblxuICB9LFxuXG4gIGV4cGFuZDpmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRlbC5maW5kKCcgPiB1bCA+IGxpJyk7XG4gICAgY2hpbGRyZW4uc2hvdygnZmFzdCcpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyZWVOb2RlVmlldztcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIFRpdGxlVGVtcGxhdGUgPSBcIjxsaT5cXG5cXHQ8YSBocmVmPVxcXCIjXFxcIj5cXG5cXHRcXHQ8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLTwlPSBuYW1lLnJlcGxhY2UoLyAvZywnJykgJT5cXFwiPlxcblxcdFxcdFxcdDwlPSBuYW1lICU+XFxuXFx0XFx0PC9zcGFuPiAgIFxcblxcdFxcdDxzcGFuIGNsYXNzPSdmaWx0ZXItY291bnQgc21hbGwgcHVsbC1yaWdodCc+PC9zcGFuPlxcblxcdDwvYT5cXG48L2xpPlwiO1xudmFyIENvbnRlbnRUZW1wbGF0ZSA9IFwiPCVcXG4gIC8vIHRoaXMgcmVuZGVycyB0aGUgXFxcImJpZ1xcXCIgZmlsdGVyIGxpc3QgKHRoZSB0YWJzKVxcbiU+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuICA8YSB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZSBjYW5jZWxcXFwiICBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvYT5cXG4gIDxoMyBkYXRhLWkxOG49XFxcImFtcC5naXM6dGl0bGUtZmlsdGVyc1xcXCIgY2xhc3M9XFxcInBhbmVsLXRpdGxlXFxcIj5GaWx0ZXJzPC9oMz5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5IGZpbHRlci1ib2R5XFxcIj5cXG5cXG4gIDx1bCBjbGFzcz1cXFwibmF2IG5hdi10YWJzIGZpbHRlci10aXRsZXNcXFwiIHJvbGU9XFxcInRhYmxpc3RcXFwiPlxcbiAgPC91bD5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50IGZpbHRlci1vcHRpb25zXFxcIj5cXG4gICAgPGltZyBzcmM9XFxcImltZ18yL2xvYWRpbmctaWNvbi5naWZcXFwiIC8+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1mb290ZXJcXFwiPlxcbiAgJm5ic3A7XFxuICA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIiBzdHlsZT1cXFwiZGlzcGxheTogaW5saW5lLWJsb2NrOyBtYXJnaW4tYm90dG9tOiA1cHg7XFxcIj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1kYW5nZXIgcmVzZXRcXFwiICBkYXRhLWkxOG49XFxcImFtcC5naXM6YnV0dG9uLXJlc2V0XFxcIiAgdGl0bGU9XFxcIlR1cm4gb2ZmIGFsbCBmaWx0ZXJzLlxcXCI+UmVzZXQ8L2J1dHRvbj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi13YXJuaW5nIGNhbmNlbFxcXCIgIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpidXR0b24tY2FuY2VsXFxcIiAgdGl0bGU9XFxcIlJldmVydCBmaWx0ZXJzIHRvIHN0YXRlIHdoZW4gb3BlbmVkLlxcXCI+Q2FuY2VsPC9idXR0b24+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tc3VjY2VzcyBhcHBseVxcXCIgIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpidXR0b24tYXBwbHlcXFwiID5BcHBseTwvYnV0dG9uPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG5cbi8vIFBhcmVudCBiYXNlIHZpZXcgZm9yIGZpbHRlcnMuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdmaWx0ZXItdHlwZScsXG5cbiAgdGl0bGVUZW1wbGF0ZTogXy50ZW1wbGF0ZShUaXRsZVRlbXBsYXRlKSxcbiAgY29udGVudFRlbXBsYXRlOiBfLnRlbXBsYXRlKENvbnRlbnRUZW1wbGF0ZSksXG5cbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgfSxcblxuICByZW5kZXJGaWx0ZXJzOiBmdW5jdGlvbigpIHtcblxuICB9LFxuXG4gIHJlbmRlclRpdGxlOiBmdW5jdGlvbigpIHtcdCAgXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMudGl0bGVFbCA9IHRoaXMudGl0bGVUZW1wbGF0ZSh0aGlzLm1vZGVsLnRvSlNPTigpKTtcbiAgICB0aGlzLiR0aXRsZUVsID0gJCh0aGlzLnRpdGxlRWwpO1xuICAgIHRoaXMuJHRpdGxlRWwub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnaGFuZGxpbmcgdGhlIGNsaWNrIG9uIGxvdy1sZXZlbCB0aXRsZUVsLi4uJyk7IENPTlNUQU5USU4gVEVNUCBDT01NRU5UIFdISUxFIExFQVJOSU5HIEZJTFRFUlNcbiAgICAgICQodGhpcykuc2libGluZ3MoKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAkKHRoaXMpLmFkZENsYXNzKCdhY3RpdmUnKTtcblxuICAgICAgc2VsZi4kZWwuaHRtbCgnJyk7XG4gICAgICBzZWxmLnJlbmRlckZpbHRlcnMoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn0pO1xuIiwiLyoqXG4gKiB0aGlzIGlzIHRoZSB2aWV3IHdoaWNoIHJlbmRlcnMgdGhlIGJpZyBGaWx0ZXIgY29udGVudHMgKHRoZSB0YWJzKVxuICovXG5cbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbnZhciBUcmFuc2xhdG9yID0gcmVxdWlyZSgnYW1wLXRyYW5zbGF0ZScpO1xuXG52YXIgVG9wTGV2ZWxGaWx0ZXJWaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvdG9wLWxldmVsLWZpbHRlci12aWV3Jyk7XG52YXIgQWxsRmlsdGVyQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL2FsbC1maWx0ZXJzLWNvbGxlY3Rpb24nKTtcblxuXG52YXIgVGVtcGxhdGUgPSBcIjwlXFxuICAvLyB0aGlzIHJlbmRlcnMgdGhlIFxcXCJiaWdcXFwiIGZpbHRlciBsaXN0ICh0aGUgdGFicylcXG4lPlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiPlxcbiAgPGEgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiY2xvc2UgY2FuY2VsXFxcIiAgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPiZ0aW1lczs8L2E+XFxuICA8aDMgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOnRpdGxlLWZpbHRlcnNcXFwiIGNsYXNzPVxcXCJwYW5lbC10aXRsZVxcXCI+RmlsdGVyczwvaDM+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keSBmaWx0ZXItYm9keVxcXCI+XFxuXFxuICA8dWwgY2xhc3M9XFxcIm5hdiBuYXYtdGFicyBmaWx0ZXItdGl0bGVzXFxcIiByb2xlPVxcXCJ0YWJsaXN0XFxcIj5cXG4gIDwvdWw+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudCBmaWx0ZXItb3B0aW9uc1xcXCI+XFxuICAgIDxpbWcgc3JjPVxcXCJpbWdfMi9sb2FkaW5nLWljb24uZ2lmXFxcIiAvPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtZm9vdGVyXFxcIj5cXG4gICZuYnNwO1xcbiAgPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IGlubGluZS1ibG9jazsgbWFyZ2luLWJvdHRvbTogNXB4O1xcXCI+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tZGFuZ2VyIHJlc2V0XFxcIiAgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOmJ1dHRvbi1yZXNldFxcXCIgIHRpdGxlPVxcXCJUdXJuIG9mZiBhbGwgZmlsdGVycy5cXFwiPlJlc2V0PC9idXR0b24+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4td2FybmluZyBjYW5jZWxcXFwiICBkYXRhLWkxOG49XFxcImFtcC5naXM6YnV0dG9uLWNhbmNlbFxcXCIgIHRpdGxlPVxcXCJSZXZlcnQgZmlsdGVycyB0byBzdGF0ZSB3aGVuIG9wZW5lZC5cXFwiPkNhbmNlbDwvYnV0dG9uPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLXN1Y2Nlc3MgYXBwbHlcXFwiICBkYXRhLWkxOG49XFxcImFtcC5naXM6YnV0dG9uLWFwcGx5XFxcIiA+QXBwbHk8L2J1dHRvbj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xudmFyIFRpdGxlVGVtcGxhdGUgPSBcIjwlXFxuLy8gcmVuZGVycyB0aGUgdGl0bGUgb2YgYSB0YWIgXFxuJT5cXG48bGkgY2xhc3M9XFxcIlxcXCI+PGEgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy08JT0gbmFtZS5yZXBsYWNlKC8gL2csJycpICU+XFxcIiBocmVmPVxcXCIjZmlsdGVyLXBhbmUtPCU9IG5hbWUucmVwbGFjZSgvIC9nLCcnKSAlPlxcXCIgcm9sZT1cXFwidGFiXFxcIiBkYXRhLXRvZ2dsZT1cXFwidGFiXFxcIj48JT0gbmFtZSAlPjwvYT48L2xpPlxcblwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgaWQ6ICd0b29sLWZpbHRlcnMnLFxuICBuYW1lOiAnRmlsdGVycycsXG4gIGFwaVVSTDogJy9yZXN0L2ZpbHRlcnMnLFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuYXBwbHknOiAnYXBwbHlGaWx0ZXJzJyxcbiAgICAnY2xpY2sgLmNhbmNlbCc6ICdjYW5jZWwnLFxuICAgICdjbGljayAucmVzZXQnOiAncmVzZXRGaWx0ZXJzJ1xuICB9LFxuXG4gIC8vIGNvbGxlY3Rpb24gb2YgdG9wLWxldmVsLWZpbHRlciB2aWV3cy4uXG4gIGZpbHRlclZpZXdzSW5zdGFuY2VzOnt9LFxuXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKFRlbXBsYXRlKSxcbiAgdGl0bGVUZW1wbGF0ZTogXy50ZW1wbGF0ZShUaXRsZVRlbXBsYXRlKSxcblxuICBpbml0aWFsaXplOmZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kcmFnZ2FibGUgPSBvcHRpb25zLmRyYWdnYWJsZTtcbiAgICBcbiAgICBpZihvcHRpb25zLnRyYW5zbGF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgIFx0dGhpcy5jcmVhdGVUcmFuc2xhdG9yKCk7XG4gICAgfSBlbHNlIHtcbiAgICBcdHRoaXMudHJhbnNsYXRvciA9IG9wdGlvbnMudHJhbnNsYXRvcjtcbiAgICB9XG5cbiAgICB0aGlzLmZpcnN0UmVuZGVyID0gdHJ1ZTtcblxuICAgIC8vIENyZWF0ZSB0b3AgbGV2ZWwgdmlld3NcbiAgICB0aGlzLl9jcmVhdGVUb3BMZXZlbEZpbHRlclZpZXdzKCk7XG5cbiAgICB0aGlzLmFsbEZpbHRlcnMgPSBuZXcgQWxsRmlsdGVyQ29sbGVjdGlvbihbXSxvcHRpb25zKTtcbiAgICB0aGlzLl9sb2FkZWQgPSAgdGhpcy5hbGxGaWx0ZXJzLl9sb2FkZWQ7XG4gICAgdGhpcy5fZ2V0RmlsdGVyTGlzdCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmFsbEZpbHRlcnMuZWFjaChmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICBzZWxmLl9jcmVhdGVGaWx0ZXJWaWV3cyhtb2RlbCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gIH0sXG5cbiAgX2NyZWF0ZVRvcExldmVsRmlsdGVyVmlld3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMgPSB7XG4gICAgICBkb25vcnM6IG5ldyBUb3BMZXZlbEZpbHRlclZpZXcoe25hbWU6J0Z1bmRpbmcgT3JnYW5pemF0aW9ucycsIHRyYW5zbGF0b3I6IHRoaXMudHJhbnNsYXRvciwgdHJhbnNsYXRlOiB0aGlzLnRyYW5zbGF0ZX0pLFxuICAgICAgc2VjdG9yczogbmV3IFRvcExldmVsRmlsdGVyVmlldyh7bmFtZTonU2VjdG9yJywgdHJhbnNsYXRvcjogdGhpcy50cmFuc2xhdG9yLCB0cmFuc2xhdGU6IHRoaXMudHJhbnNsYXRlfSksXG4gICAgICBwcm9ncmFtczogbmV3IFRvcExldmVsRmlsdGVyVmlldyh7bmFtZTonUHJvZ3JhbXMnLCB0cmFuc2xhdG9yOiB0aGlzLnRyYW5zbGF0b3IsIHRyYW5zbGF0ZTogdGhpcy50cmFuc2xhdGV9KSxcbiAgICAgIGFjdGl2aXR5OiBuZXcgVG9wTGV2ZWxGaWx0ZXJWaWV3KHtuYW1lOidBY3Rpdml0eScsIHRyYW5zbGF0b3I6IHRoaXMudHJhbnNsYXRvciwgdHJhbnNsYXRlOiB0aGlzLnRyYW5zbGF0ZX0pLFxuICAgICAgYWxsQWdlbmNpZXM6IG5ldyBUb3BMZXZlbEZpbHRlclZpZXcoe25hbWU6J0FsbCBBZ2VuY2llcycsIHRyYW5zbGF0b3I6IHRoaXMudHJhbnNsYXRvciwgdHJhbnNsYXRlOiB0aGlzLnRyYW5zbGF0ZX0pLFxuICAgICAgZmluYW5jaWFsczogbmV3IFRvcExldmVsRmlsdGVyVmlldyh7bmFtZTonRmluYW5jaWFsJywgdHJhbnNsYXRvcjogdGhpcy50cmFuc2xhdG9yLCB0cmFuc2xhdGU6IHRoaXMudHJhbnNsYXRlfSksXG4gICAgICBsb2NhdGlvbnM6IG5ldyBUb3BMZXZlbEZpbHRlclZpZXcoe25hbWU6J0xvY2F0aW9uJywgdHJhbnNsYXRvcjogdGhpcy50cmFuc2xhdG9yLCB0cmFuc2xhdGU6IHRoaXMudHJhbnNsYXRlfSksXG4gICAgICBvdGhlcnM6IG5ldyBUb3BMZXZlbEZpbHRlclZpZXcoe25hbWU6J090aGVyJywgdHJhbnNsYXRvcjogdGhpcy50cmFuc2xhdG9yLCB0cmFuc2xhdGU6IHRoaXMudHJhbnNsYXRlfSlcbiAgICB9O1xuICB9LFxuXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ3BhbmVsIHBhbmVsLXByaW1hcnknKTtcbiAgICBpZiAodGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuJGVsLmRyYWdnYWJsZSh7IGNhbmNlbDogJy5wYW5lbC1ib2R5LCAucGFuZWwtZm9vdGVyJywgY3Vyc29yOiAnbW92ZScgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpcnN0UmVuZGVyKSB7XG4gICAgICB0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUoe30pKTtcbiAgICAgIHRoaXMuJGVsLnNob3coKTtcblxuICAgICAgdGhpcy5fZ2V0RmlsdGVyTGlzdCgpLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgXHQgIHNlbGYucmVuZGVyRmlsdGVycygpO1xuICAgIFx0ICBzZWxmLnRyYW5zbGF0ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vZGVidWdnZXI7IC8vIHd0aCBkb2VzIHRoaW5nIG5vdCB3b3JrIGluIHNhaWt1P1xuICAgICAgLy8gaGFuZGxlIGNsaWNrIG9uIGEgVGFiJ3MgdGl0bGU6IGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3RhYnMtZXZlbnRzXG4gICAgICAkKGRvY3VtZW50KS5vbignc2hvd24uYnMudGFiIGNsaWNrJywgXCJ1bC5uYXYuZmlsdGVyLXRpdGxlcz5saT5hW2RhdGEtdG9nZ2xlPSd0YWInXVwiLCBmdW5jdGlvbiAoZSkgeyAgLy8gPC0gdGhpcyBsaW5lIG1ha2VzIGxpdHRsZSBzZW5zZSBidXQgd29ya3MgaW4gU2Fpa3UvVGFicyBhbHNvXG4gICAgICAvL3RoaXMuJGVsLmZpbmQoXCJ1bC5uYXYuZmlsdGVyLXRpdGxlcz5saT5hW2RhdGEtdG9nZ2xlPSd0YWInXVwiKS5vbignc2hvd24uYnMudGFiJywgZnVuY3Rpb24gKGUpIHsgICAvLyA8LSB0aGlzIGxpbmUgd29ya3MgaW4gYW55dGhpbmcgZXhjZXB0IFNhaWt1L1RhYnNcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogdGhlICdjbGljaycgZXZlbnQgYWRkZWQgYmVjYXVzZSAod2VpcmRseSkgdGhlIHNob3duLmJzLnRhYiBldmVudCBub3QgYmVpbmcgZmlyZWQgQVQgQUxMIHVuZGVyIFNhaWt1L1RhYnMuIFVudGlsIHRoaXMgaXMgaW52ZXN0aWdhdGVkXG4gICAgICAgICAgKiBvbiBHSVMvRGFzaGJvYXJkIHRhYnMgdGhpcyBzZWNvbmQgZXZlbnQgaXMgc3VwZXJmbHVvdXNcbiAgICAgICAgICAqLyBcbiAgICAgIFx0XG4gICAgIFx0ICAgLy9lLnRhcmdldCAvLyBuZXdseSBhY3RpdmF0ZWQgdGFiXG4gICAgIFx0ICAgLy9lLnJlbGF0ZWRUYXJnZXQgLy8gcHJldmlvdXMgYWN0aXZlIHRhYlxuICAgICAgXHRcbiAgICAgXHQgICB2YXIgYWN0aXZlVGFiID0gJChlLnRhcmdldC5wYXJlbnRFbGVtZW50KS5pbmRleCgpOyAvLyBzaGFtZWZ1bCBoYWNrLCBidXQgaGF2ZW4ndCBiZWVuIGFibGUgdG8gZmluZCBhIGNsZWFuZXIgc29sdXRpb25cbiAgICAgXHQgICB2YXIgb2xkVGFiTnIgPSBlLnJlbGF0ZWRUYXJnZXQgPyAkKGUucmVsYXRlZFRhcmdldC5wYXJlbnRFbGVtZW50KS5pbmRleCgpIDogLTE7XG4gICAgIFx0ICAgY29uc29sZS5sb2coJ3N3aXRjaGluZyBmcm9tIGZpbHRlcnMgdGFiICcgKyBvbGRUYWJOciArICcgdG8gdGFiICcgKyBhY3RpdmVUYWIpO1xuICAgICBcdCAgICQoZS50YXJnZXQpLmNsb3Nlc3QoJ3VsLmZpbHRlci10aXRsZXMnKS5hdHRyKCdhY3RpdmUtdGFiLW51bWJlcicsIGFjdGl2ZVRhYik7IC8vIG5vdCB1c2VkIGluIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoZSBjb2RlXG4gICAgIFx0ICAgXG4gICAgIFx0ICAgLy8gcmVuZGVyIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSB0YWJcbiAgICAgXHQgICB2YXIgdGFiSWQgPSAkKGUudGFyZ2V0KS5hdHRyKCdocmVmJyk7XG4gICAgIFx0ICAgdmFyIHRhYkZpcnN0Q2hpbGQgPSAkKHRhYklkKS5maW5kKCd1bC5zdWItZmlsdGVycy10aXRsZXM+bGk6Zmlyc3QgYScpO1xuICAgICBcdCAgIGlmICh0YWJGaXJzdENoaWxkKVxuICAgICBcdFx0ICAgdGFiRmlyc3RDaGlsZC5jbGljaygpO1xuICAgICAgICB9KTtcblxuICAgICAgdGhpcy5maXJzdFJlbmRlciA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgXHRzZWxmLnRyYW5zbGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBcbiAgY3JlYXRlVHJhbnNsYXRvcjogZnVuY3Rpb24oZm9yY2UpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdmFyIGZpbHRlclRyYW5zbGF0ZUtleXMgPSBKU09OLnBhcnNlKFwie1xcbiAgXFxcImFtcC5naXM6dGl0bGUtQ291bnRyeVxcXCI6IFxcXCJDb3VudHJ5XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnRpdGxlLVJlZ2lvblxcXCI6IFxcXCJSZWdpb25cXFwiLFxcbiAgXFxcImFtcC5naXM6dGl0bGUtWm9uZVxcXCI6IFxcXCJab25lXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnRpdGxlLURpc3RyaWN0XFxcIjogXFxcIkRpc3RyaWN0XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnRpdGxlLWZpbHRlcnNcXFwiOiBcXFwiRmlsdGVyXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnRpdGxlLWZpbHRlcnNcXFwiOiBcXFwiRmlsdGVyXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1zZWFyY2hcXFwiOiBcXFwiR29cXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLXNlbGVjdFxcXCI6IFxcXCJzZWxlY3QgYWxsXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1kZXNlbGVjdFxcXCI6IFxcXCJkZXNlbGVjdCBhbGxcXFwiLFxcbiAgXFxcIltwbGFjZWhvbGRlcl1hbXAuZ2lzOnBhbmUtZmlsdGVycy1zZWFyY2gtcGxhY2Vob2xkZXJcXFwiOiBcXFwiU2VhcmNoLi4uXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1GdW5kaW5nT3JnYW5pemF0aW9uc1xcXCI6IFxcXCJGdW5kaW5nIE9yZ2FuaXphdGlvbnNcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLVNlY3RvclxcXCI6IFxcXCJTZWN0b3JcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLVByb2dyYW1zXFxcIjogXFxcIlByb2dyYW1zXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1BY3Rpdml0eVxcXCI6IFxcXCJBY3Rpdml0eVxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtQWxsQWdlbmNpZXNcXFwiOiBcXFwiQWxsIEFnZW5jaWVzXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1GaW5hbmNpYWxcXFwiOiBcXFwiRmluYW5jaWFsXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1Mb2NhdGlvblxcXCI6IFxcXCJMb2NhdGlvblxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtT3RoZXJcXFwiOiBcXFwiT3RoZXJcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLURvbm9yXFxcIjogXFxcIkRvbm9yXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1QcmltYXJ5XFxcIjogXFxcIlByaW1hcnlcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLVNlY29uZGFyeVxcXCI6IFxcXCJTZWNvbmRhcnlcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLU5hdGlvbmFsUGxhbk9iamVjdGl2ZVxcXCI6IFxcXCJOYXRpb25hbCBQbGFuIE9iamVjdGl2ZVxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtQWN0aXZpdHlTdGF0dXNcXFwiOiBcXFwiQWN0aXZpdHkgU3RhdHVzXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1BcHByb3ZhbFN0YXR1c1xcXCI6IFxcXCJBcHByb3ZhbCBTdGF0dXNcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLUltcGxlbWVudGluZ0FnZW5jeVxcXCI6IFxcXCJJbXBsZW1lbnRpbmcgQWdlbmN5XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1FeGVjdXRpbmdBZ2VuY3lcXFwiOiBcXFwiRXhlY3V0aW5nIEFnZW5jeVxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtQmVuZWZpY2lhcnlBZ2VuY3lcXFwiOiBcXFwiQmVuZWZpY2lhcnkgQWdlbmN5XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1Db250cmFjdGluZ0FnZW5jeVxcXCI6IFxcXCJDb250cmFjdGluZyBBZ2VuY3lcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLUFpZE1vZGFsaXR5XFxcIjogXFxcIkFpZCBNb2RhbGl0eVxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtVHlwZU9mQXNzaXN0YW5jZVxcXCI6IFxcXCJUeXBlIE9mIEFzc2lzdGFuY2VcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLVJlc3BvbnNpYmxlT3JnYW5pemF0aW9uXFxcIjogXFxcIlJlc3BvbnNpYmxlIE9yZ2FuaXphdGlvblxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtRGF0ZXNcXFwiOiBcXFwiRGF0ZXNcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLVJlZ2lvbmFsR3JvdXBcXFwiOiBcXFwiUmVnaW9uYWwgR3JvdXBcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLVNlY3Rvckdyb3VwXFxcIjogXFxcIlNlY3RvciBHcm91cFxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtYWxsXFxcIjogXFxcImFsbFxcXCIsXFxuICBcXFwiYW1wLmdpczpidXR0b24tcmVzZXRcXFwiOiBcXFwiUmVzZXRcXFwiLFxcbiAgXFxcImFtcC5naXM6YnV0dG9uLWNhbmNlbFxcXCI6IFxcXCJDYW5jZWxcXFwiLFxcbiAgXFxcImFtcC5naXM6YnV0dG9uLWFwcGx5XFxcIjogXFxcIkFwcGx5XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1zdGFydGRhdGVcXFwiOiBcXFwiU3RhcnQgRGF0ZTpcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLWVuZGRhdGVcXFwiOiBcXFwiRW5kIERhdGU6XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1lbXB0eVxcXCI6IFxcXCJObyBkYXRhIGZvciB0aGlzIGZpbHRlclxcXCJcXG59XFxuXCIpO1xuXHQgIC8vIHNldHVwIGFueSBwb3BvdmVycyBhcyBuZWVkZWQuLi5cblx0ICBzZWxmLnBvcG92ZXJzID0gc2VsZi4kKCdbZGF0YS10b2dnbGU9XCJwb3BvdmVyXCJdJyk7XG5cdCAgc2VsZi5wb3BvdmVycy5wb3BvdmVyKCk7XG5cdCAgaWYgKGZvcmNlID09PSB0cnVlIHx8IHNlbGYudHJhbnNsYXRvciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICBjb25zb2xlLmxvZygnQ3JlYXRlIHRyYW5zbGF0b3IgZm9yIGZpbHRlcnMuJyk7XG5cdFx0ICBzZWxmLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcih7ZGVmYXVsdEtleXM6IGZpbHRlclRyYW5zbGF0ZUtleXN9KTtcblx0ICB9XG4gIH0sXG4gIFxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHQgIHZhciBlbGVtZW50ID0gdGhpcztcblx0ICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQgIGVsZW1lbnQgPSB0YXJnZXQ7XG5cdCAgfVxuXHQgIGlmIChlbGVtZW50LmVsICE9PSB1bmRlZmluZWQpIHtcblx0XHQgIHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVET00oZWxlbWVudC5lbCk7XG5cdCAgfSBlbHNlIHtcblx0XHQgIHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVET00oZWxlbWVudCk7XG5cdCAgfVx0ICBcbiAgfSxcblxuICAvKipcbiAgICogcmVuZGVycyB0aGUgdGFicyB3aXRoaW4gdGhlIGZpbHRlcnMsIG9ubHkgcmVuZGVyaW5nIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSBhY3RpdmUgdGFiICh0aGUgb3RoZXJzIGRvbid0IGhhdmUgdGhlaXIgZmlyc3QgaXRlbSdzIGNvbnRlbnRzIHJlbmRlcmVkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zKVxuICAgKi9cbiAgcmVuZGVyRmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kKCcuZmlsdGVyLW9wdGlvbnMnKS5odG1sKCcnKTtcblxuICAgIHZhciByZW5kZXJpbmdUaXRsZU51bWJlciA9IC0xO1xuICAgIHZhciBhY3RpdmVUaXRsZU51bWJlciA9IHRoaXMuJCgnLmZpbHRlci10aXRsZXMnKS5hdHRyKCdhY3RpdmUtdGFiLW51bWJlcicpIHx8IDA7XG4gICAgXG4gICAgZm9yICh2YXIgZmlsdGVyVmlldyBpbiB0aGlzLmZpbHRlclZpZXdzSW5zdGFuY2VzKSB7XG4gICAgICBpZiAodGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShmaWx0ZXJWaWV3KSkge1xuICAgICAgICB2YXIgdG1wRmlsdGVyVmlldyA9IHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXNbZmlsdGVyVmlld107XG4gICAgICAgIHJlbmRlcmluZ1RpdGxlTnVtYmVyID0gcmVuZGVyaW5nVGl0bGVOdW1iZXIgKyAxO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygncmVuZGVyaW5nIHRvcC1sZXZlbC1maWx0ZXItdmlldyAnICsgdG1wRmlsdGVyVmlldy5uYW1lKTsgQ09OU1RBTlRJTiAtIGNvbW1lbnQgdG8gYmUgcmVtb3ZlZCBvbmNlIGZpbHRlcnMgc2FuaXRpc2F0aW9uIGlzIGRvbmVcbiAgICAgICAgdGhpcy4kKCcuZmlsdGVyLXRpdGxlcycpLmFwcGVuZCh0bXBGaWx0ZXJWaWV3LnJlbmRlclRpdGxlKCkudGl0bGVFbCk7XG4gICAgICAgIHZhciBhY3RpdmUgPSByZW5kZXJpbmdUaXRsZU51bWJlciA9PSBhY3RpdmVUaXRsZU51bWJlcjtcbiAgICAgICAgdGhpcy4kKCcuZmlsdGVyLW9wdGlvbnMnKS5hcHBlbmQodG1wRmlsdGVyVmlldy5yZW5kZXJGaWx0ZXJzKGFjdGl2ZSkuZWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9wZW5zIHRoZSBmaXJzdCB0YWIgaW4gdGhlIGZpbHRlclxuICAgIHRoaXMuJCgnLmZpbHRlci10aXRsZXMgYTpmaXJzdCcpLnRhYignc2hvdycpO1xuICB9LFxuXG5cbiAgX2dldEZpbHRlckxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFsbEZpbHRlcnMubG9hZCgpO1xuICB9LFxuXG4gIF9jcmVhdGVGaWx0ZXJWaWV3czogZnVuY3Rpb24odG1wTW9kZWwpIHtcbiAgICAvLyBUT0RPOiBtYWdpYyBzdHJpbmdzIGFyZSBkYW5nZXJvdXMsIGNvbmZpZyBzb21ld2hlcmUuLi5cbiAgICBzd2l0Y2ggKHRtcE1vZGVsLmdldCgnZ3JvdXAnKSkge1xuICAgICAgY2FzZSAnQWN0aXZpdHlCdWRnZXRMaXN0JzpcbiAgICAgIGNhc2UgJ1R5cGVPZkFzc2lzdGFuY2VMaXN0JzpcbiAgICAgIGNhc2UgJ01vZGVPZlBheW1lbnRMaXN0JzpcbiAgICAgIGNhc2UgJ0ZpbmFuY2luZ0luc3RydW1lbnRzTGlzdCc6XG4gICAgICAgIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMuZmluYW5jaWFscy5maWx0ZXJDb2xsZWN0aW9uLmFkZCh0bXBNb2RlbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQWN0aXZpdHlTdGF0dXNMaXN0JzpcbiAgICAgIGNhc2UgJ0FjdGl2aXR5QXBwcm92YWxTdGF0dXMnOlxuICAgICAgICB0aGlzLmZpbHRlclZpZXdzSW5zdGFuY2VzLmFjdGl2aXR5LmZpbHRlckNvbGxlY3Rpb24uYWRkKHRtcE1vZGVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdQcm9ncmFtcyc6XG4gICAgICAgIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMucHJvZ3JhbXMuZmlsdGVyQ29sbGVjdGlvbi5hZGQodG1wTW9kZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1NlY3RvcnMnOlxuICAgICAgICB0aGlzLmZpbHRlclZpZXdzSW5zdGFuY2VzLnNlY3RvcnMuZmlsdGVyQ29sbGVjdGlvbi5hZGQodG1wTW9kZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Rvbm9yJzpcbiAgICAgICAgdGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlcy5kb25vcnMuZmlsdGVyQ29sbGVjdGlvbi5hZGQodG1wTW9kZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1JvbGUnOlxuICAgICAgICB0aGlzLmZpbHRlclZpZXdzSW5zdGFuY2VzLmFsbEFnZW5jaWVzLmZpbHRlckNvbGxlY3Rpb24uYWRkKHRtcE1vZGVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMb2NhdGlvbkxpc3QnOlxuICAgICAgICAgIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMubG9jYXRpb25zLmZpbHRlckNvbGxlY3Rpb24uYWRkKHRtcE1vZGVsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMub3RoZXJzLmZpbHRlckNvbGxlY3Rpb24uYWRkKHRtcE1vZGVsKTtcbiAgICB9XG5cbiAgfSxcblxuXG4gIC8vVE9ETzogbW92ZSBmcm9tIHZpZXcgdG8gYWxsLWNvbGxlY3Rpb25cbiAgc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzZXJpYWxpemVkRmlsdGVycyA9IHsnY29sdW1uRmlsdGVycyc6e30sICdvdGhlckZpbHRlcnMnOnt9IH07XG5cblx0dGhpcy5hbGxGaWx0ZXJzLmVhY2goZnVuY3Rpb24oZmlsdGVyKSB7XG5cdFx0Ly8gVE9ETzogYnVpbGQgYSB1dGlsIGZvciBiZXR0ZXJtZXJnZSB0aGF0IGNvbmNhdCdzIGFycmF5IGlmXG5cdFx0Ly8gZHVwbGljYXRlIGtleXMgaW4gb2JqZWN0cy4uLlxuXHRcdGlmIChmaWx0ZXIuZ2V0KCdpZCcpIHx8IGZpbHRlci51cmwpIHtcblx0XHRcdGlmIChmaWx0ZXIuZ2V0KCduYW1lJykuaW5kZXhPZignRGF0ZScpICE9IC0xIFxuXHRcdFx0XHRcdHx8IChmaWx0ZXIuZ2V0KCdjb2x1bW4nKSAhPSB1bmRlZmluZWQgJiYgZmlsdGVyLmdldCgnY29sdW1uJykuaW5kZXhPZignRGF0ZScpICE9IC0xKSkge1xuXHRcdFx0XHRfLmV4dGVuZChzZXJpYWxpemVkRmlsdGVycy5vdGhlckZpbHRlcnMsIGZpbHRlci5zZXJpYWxpemUob3B0aW9ucykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNlcmlhbGl6ZWQgPSBmaWx0ZXIuc2VyaWFsaXplKG9wdGlvbnMpO1xuXHRcdFx0XHRpZiAob3B0aW9ucy53aG9sZU1vZGVsID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0dmFyIGtleXMgPSBbXTtcblx0XHRcdFx0XHRmb3IodmFyIGsgaW4gc2VyaWFsaXplZCkga2V5cy5wdXNoKGspO1x0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoa2V5c1swXSAhPT0gdW5kZWZpbmVkICYmIHNlcmlhbGl6ZWRba2V5c1swXV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0c2VyaWFsaXplZFtrZXlzWzBdXS5maWx0ZXJOYW1lID0gKGZpbHRlci5nZXQoJ2Rpc3BsYXlOYW1lJykgfHwgZmlsdGVyLmdldCgnbmFtZScpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHQgICAgfVx0XHRcdFx0XG5cdFx0XHRcdF8uZXh0ZW5kKHNlcmlhbGl6ZWRGaWx0ZXJzLmNvbHVtbkZpbHRlcnMsIHNlcmlhbGl6ZWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cbiAgICAvL3JlbW92ZSBlbXB0eSAvIGZhbHNlIHZhbHVlcy5cbiAgICBfLmVhY2goc2VyaWFsaXplZEZpbHRlcnMsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgIGlmKCF2IHx8IF8uaXNFbXB0eSh2KSkge1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZEZpbHRlcnNba107XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2VyaWFsaXplZEZpbHRlcnM7XG4gIH0sXG5cbiAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uKGJsb2IsIG9wdGlvbnMpIHtcbiAgICBpZiAoYmxvYikge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdGhhdC5hbGxGaWx0ZXJzLmVhY2goZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgXHQgIGlmIChmaWx0ZXIuZ2V0KCdpZCcpIHx8IGZpbHRlci51cmwpIHtcbiAgICBcdFx0ICBpZihmaWx0ZXIuZ2V0KCduYW1lJykuaW5kZXhPZignRGF0ZScpIT0tMSB8fCAoZmlsdGVyLmdldCgnY29sdW1uJykgIT0gdW5kZWZpbmVkICYmIGZpbHRlci5nZXQoJ2NvbHVtbicpLmluZGV4T2YoJ0RhdGUnKSAhPSAtMSkpIHsgXG5cdFx0ICAgICAgICAgIGZpbHRlci5kZXNlcmlhbGl6ZShibG9iLm90aGVyRmlsdGVycyk7XG5cdCAgICAgICAgIH0gZWxzZXtcblx0XHQgICAgICAgICAgZmlsdGVyLmRlc2VyaWFsaXplKGJsb2IuY29sdW1uRmlsdGVycyk7XG5cdFx0ICAgICAgICB9XG5cdCAgICBcdH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2NvdWxkIG5vdCBkZXNlcmlhbGl6ZSBibG9iOicsIGJsb2IpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICB0aGlzLmFwcGx5RmlsdGVycygpOyAgLy8gdHJpZ2dlcnMgdGhlIFwiYXBwbHlcIiBldmVudFxuICAgIH1cbiAgfSxcblxuICBzaG93RmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgICB0aGlzLmZpbHRlclN0YXNoID0gbnVsbDsgIC8vIGluIGNhc2UgdGhleSBoYXZlbid0IGxvYWRlZCB5ZXQsIGRvbid0IHRyeSB0byAuc2VyaWFsaXplKClcbiAgICB0aGlzLl9sb2FkZWQuZG9uZShfLmJpbmQoZnVuY3Rpb24oKSB7IHRoaXMuZmlsdGVyU3Rhc2ggPSB0aGlzLnNlcmlhbGl6ZSh7fSk7IH0sIHRoaXMpKTtcbiAgfSxcblxuICByZXNldEZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYWxsRmlsdGVycy5lYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgZmlsdGVyLnJlc2V0KCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9sb2FkZWQuZG9uZShfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnNlcmlhbGl6ZSh7fSk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2FwcGx5Jywgc3RhdGUpO1xuICAgIH0sIHRoaXMpKTtcbiAgfSxcblxuICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuZmlsdGVyU3Rhc2gpe1xuICAgICAgdGhpcy5kZXNlcmlhbGl6ZSh0aGlzLmZpbHRlclN0YXNoLCB7c2lsZW50OiB0cnVlfSk7XG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcignY2FuY2VsJywgdGhpcy5maWx0ZXJTdGFzaCk7XG4gIH1cbn0pO1xuXG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG4vLyB2YXIgR2VuZXJpY0ZpbHRlck1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL2dlbmVyaWMtZmlsdGVyLW1vZGVsJyk7XG52YXIgVHJlZU5vZGVWaWV3ID0gcmVxdWlyZSgnLi4vdHJlZS90cmVlLW5vZGUtdmlldycpO1xudmFyIEJhc2VGaWx0ZXJWaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvYmFzZS1maWx0ZXItdmlldycpO1xudmFyIFRlbXBsYXRlID0gXCI8JSBpZiAoIWVtcHR5KSB7ICU+XFxuXFx0PGRpdiBjbGFzcz1cXFwic2VhcmNoLWZvcm1cXFwiPlxcblxcdCAgPGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAgZm9ybS1ncm91cFxcXCI+XFxuXFx0ICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBkYXRhLWkxOG49XFxcIltwbGFjZWhvbGRlcl1hbXAuZ2lzOnBhbmUtZmlsdGVycy1zZWFyY2gtcGxhY2Vob2xkZXJcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgc2VhcmNoLXRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJTZWFyY2guLi5cXFwiPlxcblxcdCAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuXFxcIj5cXG5cXHQgICAgICA8YnV0dG9uIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtc2VhcmNoXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zdWNjZXNzXFxcIj5HbzwvYnV0dG9uPlxcblxcdCAgICA8L3NwYW4+XFxuXFx0ICA8L2Rpdj48IS0tIC9pbnB1dC1ncm91cCAtLT5cXG5cXHQ8L2Rpdj5cXG5cXHQ8ZGl2IGNsYXNzPVxcXCJ0b2dnbGUtYWxsXFxcIj5cXG5cXHQgIDxlbT5cXG5cXHQgICAgPGEgaHJlZj1cXFwiI1xcXCIgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1zZWxlY3RcXFwiIGNsYXNzPVxcXCJzZWxlY3QtYWxsXFxcIiA+c2VsZWN0IGFsbDwvYT4gL1xcblxcdCAgICA8YSBocmVmPVxcXCIjXFxcIiAgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1kZXNlbGVjdFxcXCIgY2xhc3M9XFxcInNlbGVjdC1ub25lXFxcIiA+ZGVzZWxlY3QgYWxsPC9hPlxcblxcdCAgPC9lbT5cXG5cXHQ8L2Rpdj5cXG5cXHRcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJ0cmVlIHRyZWUtY29udGFpbmVyXFxcIiBzdHlsZT1cXFwiXFxcIj48L2Rpdj48IS0tZGlzcGxheTpub25lOy0tPlxcbjwlIH0gZWxzZSB7ICU+XFxuXFx0PHNwYW4gZGF0YS1pMThuPSdhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1lbXB0eSc+PC9zcGFuPlxcbjwlIH0gJT5cXG5cIjtcblxuXG4vLyBUaGlzIGlzIGEgZ2VuZXJpYyBtb2RlbCBmb3IgZmlsdGVycy4gSXQgYXNzdW1lcyBhIHRyZWUgc3RydWN0dXJlLlxuLy8gSWYgeW91IGRvbid0IHdhbnQgYSB0cmVlIHN0cnVjdHVyZSBqdXN0IGV4dGVuZCBiYXNlLWZpbHRlclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRmlsdGVyVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogQmFzZUZpbHRlclZpZXcucHJvdG90eXBlLmNsYXNzTmFtZSArICcgZmlsdGVyLWdlbmVyaWMnLFxuICB0ZW1wbGF0ZTogXy50ZW1wbGF0ZShUZW1wbGF0ZSksXG4gIF9sb2FkZWQ6IG51bGwsXG5cbiAgZXZlbnRzOntcbiAgICAvLyBhdHRhY2ggaW4gZmlsdGVyIHJlbmRlciBpbnN0ZWFkIHNpbmNlIHRoZXNlIGV2ZW50cyBhcmUgYXR0YWNoZWQgdG8gdGhlIGVsIG9iamVjdFxuICAgIC8vIGFuZCB0aGVuIG5hbWVzcGFjZWQuIHRoaXMgbWVhbnMgdGhhdCB0aGUgd2F5IHdlIHJlLXVzZVxuICAgIC8vIERPTSBlbGVtZW50cyB3aWxsIGFjY2lkZW50YWxseSB0cmlnZ2VyIG11bHRpcGxlIGV2ZW50cy5cbiAgICAvLyAnY2xpY2sgIC5zZWxlY3QtYWxsJzogJ19zZWxlY3RBbGwnLFxuICAgIC8vICdjbGljayAgLnNlbGVjdC1ub25lJzogJ19zZWxlY3ROb25lJyxcbiAgICAvLydrZXl1cCBpbnB1dC5zZWFyY2gtdGV4dCc6ICdzZWFyY2hLZXlVcCdcbiAgfSxcblxuICBpbml0aWFsaXplOmZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgQmFzZUZpbHRlclZpZXcucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcblxuICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG9wdGlvbnMudHJhbnNsYXRvcjtcbiAgICB0aGlzLnRyYW5zbGF0ZSA9IG9wdGlvbnMudHJhbnNsYXRlO1xuICAgIHRoaXMudHJlZVZpZXcgPSBuZXcgVHJlZU5vZGVWaWV3KCk7XG5cbiAgICAvLyBDcmVhdGUgdHJlZSB2aWV3XG4gICAgLy8gVE9ETzogbWFrZSB0cmVlIGxvYWRpbmcgY29udGVudCByZXNwb25zaWJpbGl0eSBvZiBtb2RlbCwgbm90IHZpZXcuLi5cbiAgICB0aGlzLm1vZGVsLmdldFRyZWUoKS50aGVuKGZ1bmN0aW9uKHRyZWVNb2RlbCkge1xuICAgICAgaWYgKHRyZWVNb2RlbCkge1xuICAgICAgICBzZWxmLl91cGRhdGVDb3VudEluTWVudSgpO1xuICAgICAgICB0cmVlTW9kZWwub24oJ2NoYW5nZTpudW1TZWxlY3RlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuX3VwZGF0ZUNvdW50SW5NZW51KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdubyB0cmVlIGZvcjogJywgc2VsZi5tb2RlbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgc2VhcmNoS2V5VXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzIHx8IC8vIFByZXNzZWQgJ2VudGVyJ1xuICAgICAgdGhpcy4kKCcuc2VhcmNoLXRleHQnKS52YWwoKSA9PT0gJycgfHxcbiAgICAgIHRoaXMuJCgnLnNlYXJjaC10ZXh0JykudmFsKCkubGVuZ3RoID4gMVxuICAgICAgKSB7XG4gICAgICB0aGlzLm1vZGVsLmdldCgndHJlZScpLmZpbHRlclRleHQodGhpcy4kKCcuc2VhcmNoLXRleHQnKS52YWwoKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gIH0sXG5cblxuICBfdXBkYXRlQ291bnRJbk1lbnU6ZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuJHRpdGxlRWwgJiYgdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKSkge1xuICAgICAgaWYgKHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuZ2V0KCdudW1TZWxlY3RlZCcpID09PSB0aGlzLm1vZGVsLmdldCgndHJlZScpLmdldCgnbnVtUG9zc2libGUnKSB8fFxuICAgICAgICAgIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuZ2V0KCdudW1TZWxlY3RlZCcpID09PSAwKSB7XG4gICAgXHQgIHRoaXMuJHRpdGxlRWwuZmluZCgnLmZpbHRlci1jb3VudCcpLmF0dHIoJ2RhdGEtaTE4bicsJ2FtcC5naXM6cGFuZS1maWx0ZXJzLWFsbCcpO1xuICAgIFx0ICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7ICAgIFx0ICBcbiAgICBcdCAgdGhpcy50cmFuc2xhdGUoJCh0aGlzLmVsKS5wYXJlbnQoKS5maW5kKCd1bCAuYWN0aXZlJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kdGl0bGVFbC5maW5kKCcuZmlsdGVyLWNvdW50JykudGV4dCh0aGlzLm1vZGVsLmdldCgndHJlZScpLmdldCgnbnVtU2VsZWN0ZWQnKSArXG4gICAgICAgICAgJy8nICtcbiAgICAgICAgICB0aGlzLm1vZGVsLmdldCgndHJlZScpLmdldCgnbnVtUG9zc2libGUnKSk7XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgdGhpcy4kdGl0bGVFbC5maW5kKCcuZmlsdGVyLWNvdW50JykuYXR0cignZGF0YS1pMThuJywnJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXHRcbiAgcmVuZGVyVGl0bGUgOiBmdW5jdGlvbigpIHtcblx0ICBCYXNlRmlsdGVyVmlldy5wcm90b3R5cGUucmVuZGVyVGl0bGUuYXBwbHkodGhpcyk7XG5cdCAgdGhpcy5fdXBkYXRlQ291bnRJbk1lbnUoKTtcblx0ICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW5kZXJGaWx0ZXJzOmZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBCYXNlRmlsdGVyVmlldy5wcm90b3R5cGUucmVuZGVyRmlsdGVycy5hcHBseSh0aGlzKTtcblxuICAgIHRoaXMubW9kZWwuZ2V0VHJlZSgpLnRoZW4oZnVuY3Rpb24odHJlZU1vZGVsKSB7XG4gICAgICBzZWxmLiRlbC5odG1sKHNlbGYudGVtcGxhdGUoc2VsZi5tb2RlbC50b0pTT04oKSkpO1xuXG4gICAgICAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICBzZWxmLiQoJy5zZWxlY3Qtbm9uZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge3NlbGYuX3NlbGVjdE5vbmUoKTsgcmV0dXJuIGZhbHNlO30pOyAvL3JldHVybiBmYWxzZSB0byBzdG9wIHBhZ2UgcmVmcmVzaC5cbiAgICAgIHNlbGYuJCgnLnNlbGVjdC1hbGwnKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtzZWxmLl9zZWxlY3RBbGwoKTsgcmV0dXJuIGZhbHNlO30pOyAvL3JldHVybiBmYWxzZSB0byBzdG9wIHBhZ2UgcmVmcmVzaC5cbiAgICAgIHNlbGYuJCgnaW5wdXQuc2VhcmNoLXRleHQnKS5vbigna2V5dXAnLCBmdW5jdGlvbihldmVudCkge3NlbGYuc2VhcmNoS2V5VXAoZXZlbnQpO30pO1xuXG4gICAgICBpZiAodHJlZU1vZGVsKSB7XG4gICAgICAgIHNlbGYuJCgnLnRyZWUtY29udGFpbmVyJykuYXBwZW5kKHNlbGYudHJlZVZpZXcucmVuZGVyKHNlbGYubW9kZWwuZ2V0KCd0cmVlJykpLiRlbCk7XG4gICAgICAgIHRyZWVNb2RlbC5zZXQoJ2V4cGFuZGVkJywgdHJ1ZSk7XG4gICAgICAgIHRyZWVNb2RlbC5maWx0ZXJUZXh0KCcnKTsvL2RlZmF1bHQgbm8gZmlsdGVyLlxuICAgICAgfSBlbHNle1xuICAgICAgICBzZWxmLiQoJy50cmVlLWNvbnRhaW5lcicpLmFwcGVuZChcIlwiKTtcbiAgICAgIH1cbiAgICB9KVxuICAgIC5kb25lKGZ1bmN0aW9uKCkge1xuICAgIFx0c2VsZi50cmFuc2xhdGUoc2VsZik7XG4gICAgfSlcbiAgICAuZmFpbChmdW5jdGlvbigpe1xuICAgICAgY29uc29sZS5lcnJvcigncmVuZGVyRmlsdGVycyBmYWlsZWQgOignKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9zZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgIC8vIGZvcmNlIHRyaWdnZXIgZXZlbiBpZiBhbHJlYWR5IHRoaXMgc3RhdGUgKGltcG9ydGFudCBmb3IgaGFsZi1maWxsIHVpXG4gICAgdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5zZXQoJ3NlbGVjdGVkJywgZmFsc2UpO1xuICAgIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuc2V0KCdzZWxlY3RlZCcsIHRydWUpO1xuICAgIC8vdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5zZXQoJ3NlbGVjdGVkJywgdHJ1ZSwge3NpbGVudDogdHJ1ZSB9KTtcbiAgICAvLy5tb2RlbC5nZXQoJ3RyZWUnKS50cmlnZ2VyKCdjaGFuZ2U6c2VsZWN0ZWQnLCB0aGlzLm1vZGVsLmdldCgndHJlZScpLCBudWxsLCB7cHJvcG9nYXRpb246ZmFsc2V9KTtcbiAgfSxcblxuICBfc2VsZWN0Tm9uZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gZm9yY2UgdHJpZ2dlciBldmVuIGlmIGFscmVhZHkgdGhpcyBzdGF0ZSAoaW1wb3J0YW50IGZvciBoYWxmLWZpbGwgdWkpXG4gICAgdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5zZXQoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5zZXQoJ3NlbGVjdGVkJywgZmFsc2UpO1xuICAgIC8vIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuc2V0KCdzZWxlY3RlZCcsIGZhbHNlLCB7c2lsZW50OiB0cnVlIH0pO1xuICAgIC8vIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykudHJpZ2dlcignY2hhbmdlOnNlbGVjdGVkJywgdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKSwgbnVsbCwge3Byb3BvZ2F0aW9uOmZhbHNlfSk7XG4gIH1cblxufSk7XG5cbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIFRpdGxlVGVtcGxhdGUgPSBcIjwlXFxuLy8gcmVuZGVycyB0aGUgdGl0bGUgb2YgYSB0YWIgXFxuJT5cXG48bGkgY2xhc3M9XFxcIlxcXCI+PGEgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy08JT0gbmFtZS5yZXBsYWNlKC8gL2csJycpICU+XFxcIiBocmVmPVxcXCIjZmlsdGVyLXBhbmUtPCU9IG5hbWUucmVwbGFjZSgvIC9nLCcnKSAlPlxcXCIgcm9sZT1cXFwidGFiXFxcIiBkYXRhLXRvZ2dsZT1cXFwidGFiXFxcIj48JT0gbmFtZSAlPjwvYT48L2xpPlxcblwiO1xudmFyIENvbnRlbnRUZW1wbGF0ZSA9IFwiPCVcXG4gLy8gcmVuZGVycyB0aGUgY29udGVudHMgb2YgYSBmaWx0ZXIncyB0YWIgKGUuZy4gZm9yIGV4YW1wbGUgdGhlIFxcXCJDb250cmFjdGluZyAvIEltcGxlbWVudGluZyAvIEV4ZWN1dGluZyAvIFByaW1hcnkgQmVuZWZpY2lhcnkgLyBTZWNvbmRhcnkgQmVuZWZpY2lhcnkgQWdlbmN5XFxcIiBsaXN0IG9mIHRoZSBcXFwiQWxsIEFnZW5jaWVzXFxcIiB0YWIpXFxuIC8vIDxoNj5tZGUgICUtIE1hdGgucmFuZG9tKCkgPC9oNj5cXG4lPlxcbjx1bCBjbGFzcz1cXFwic3ViLWZpbHRlcnMtdGl0bGVzIG5hdiBuYXYtcGlsbHMgbmF2LXN0YWNrZWRcXFwiPlxcbjwvdWw+XFxuPGRpdiBjbGFzcz1cXFwic3ViLWZpbHRlcnMtY29udGVudFxcXCI+XFxuICA8aW1nIHNyYz1cXFwiaW1nXzIvbG9hZGluZy1pY29uLmdpZlxcXCIgLz5cXG48L2Rpdj5cXG5cIjtcblxudmFyIEdlbmVyaWNGaWx0ZXJWaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvZ2VuZXJpYy1maWx0ZXItdmlldycpO1xudmFyIFllYXJzRmlsdGVyVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL3llYXJzLWZpbHRlci12aWV3Jyk7XG5cbnZhciBZZWFyc0ZpbHRlck1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL3llYXJzLWZpbHRlci1tb2RlbCcpO1xuXG5cbi8vVE9ETzogcmVuYW1lIHRvICdncm91cCcgdG8gYmUgY29uc2lzdGVudFxuLy8gUGFyZW50IGJhc2UgdmlldyBmb3IgZmlsdGVycy5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICBjbGFzc05hbWU6ICAndGFiLXBhbmUnLFxuICB0aXRsZVRlbXBsYXRlOiBfLnRlbXBsYXRlKFRpdGxlVGVtcGxhdGUpLFxuICBjb250ZW50VGVtcGxhdGU6IF8udGVtcGxhdGUoQ29udGVudFRlbXBsYXRlKSxcbiAgZmlsdGVyQ29sbGVjdGlvbjogbnVsbCxcbiAgdmlld0xpc3Q6W10sXG4gIG5hbWU6ICd0YmQnLFxuXG4gIGluaXRpYWxpemU6ZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gb3B0aW9ucy50cmFuc2xhdG9yO1xuICAgIHRoaXMudHJhbnNsYXRlID0gb3B0aW9ucy50cmFuc2xhdGU7XG4gICAgdGhpcy5maWx0ZXJDb2xsZWN0aW9uID0gbmV3IEJhY2tib25lLkNvbGxlY3Rpb24oKTtcbiAgICB0aGlzLmZpbHRlckNvbGxlY3Rpb24ub24oJ2NoYW5nZTpudW1TZWxlY3RlZCcsIGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLl9yZWZyZXNoVGl0bGUoKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogcmVuZGVycyB0aGUgaXRlbXMgaW4gYSB0YWJcbiAgICogdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHRhYidzIGNvbnRlbnRzIHdpbGwgYmUgcmVuZGVyZWQgSUZGIG9wdGlvbnMucmVuZGVyRmlyc3RFbGVtZW50IGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKi9cbiAgcmVuZGVyRmlsdGVyczogZnVuY3Rpb24ocmVuZGVyRmlyc3RFbGVtZW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3ID0gbnVsbDtcbiAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgIHRoaXMuJGVsLmF0dHIoJ2lkJywgJ2ZpbHRlci1wYW5lLScgKyB0aGlzLm5hbWUucmVwbGFjZSgvIC9nLCcnKSk7XG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLmNvbnRlbnRUZW1wbGF0ZSgpKTtcbiAgICAvLyByZW5kZXJzIHRoZSB0YWJzIG9mIHRoZSBmaWx0ZXIgKG9uZSB0YWIgZm9yIGVhY2ggZmlsdGVyQ29sbGVjdGlvbiBlbGVtZW50KVxuICAgIHRoaXMuZmlsdGVyQ29sbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIFx0Ly9jb25zb2xlLmxvZygnXFx0cmVuZGVyaW5nIGZpbHRlciAnICsgZmlsdGVyLmdldCgnbmFtZScpICsgJy4uLicpOyAvLyBDb25zdGFudGluOiBoYXJtbGVzcyBkZWJ1ZyBtZXNzYWdlIHRvIGJlIHJlbW92ZWQgb25jZSB0aGUgZmlsdGVycyBzYW5pdGlzYXRpb24gaXMgZG9uZVxuICAgIFx0aWYgKGZpbHRlciBpbnN0YW5jZW9mIFllYXJzRmlsdGVyTW9kZWwpIHtcbiAgICBcdFx0dmlldyA9IG5ldyBZZWFyc0ZpbHRlclZpZXcoe1xuICAgIFx0XHRcdG1vZGVsOmZpbHRlcixcbiAgICBcdFx0XHRlbDogc2VsZi4kKCcuc3ViLWZpbHRlcnMtY29udGVudCcpLFxuICAgIFx0XHRcdHRyYW5zbGF0b3I6IHNlbGYudHJhbnNsYXRvcixcbiAgICBcdFx0XHR0cmFuc2xhdGU6IHNlbGYudHJhbnNsYXRlXG4gICAgXHRcdH0pO1xuICAgIFx0XHRzZWxmLnZpZXdMaXN0LnB1c2godmlldyk7XG4gICAgXHR9IGVsc2Uge1xuICAgIFx0XHR2aWV3ID0gbmV3IEdlbmVyaWNGaWx0ZXJWaWV3KHtcbiAgICBcdFx0XHRtb2RlbDpmaWx0ZXIsXG4gICAgXHRcdFx0ZWw6IHNlbGYuJCgnLnN1Yi1maWx0ZXJzLWNvbnRlbnQnKSxcbiAgICBcdFx0XHR0cmFuc2xhdG9yOiBzZWxmLnRyYW5zbGF0b3IsXG4gICAgXHRcdFx0dHJhbnNsYXRlOiBzZWxmLnRyYW5zbGF0ZVxuICAgIFx0XHR9KTtcbiAgICBcdFx0c2VsZi52aWV3TGlzdC5wdXNoKHZpZXcpO1xuICAgIFx0fVxuXG4gICAgXHR2YXIgdGl0bGVFbGVtID0gdmlldy5yZW5kZXJUaXRsZSgpLiR0aXRsZUVsO1xuICAgIFx0c2VsZi4kKCcuc3ViLWZpbHRlcnMtdGl0bGVzJykuYXBwZW5kKHRpdGxlRWxlbSk7XG5cbiAgICBcdC8vIGhhY2t5IHdheSB0byBvcGVuIGZpcnN0IG9uZSBmb3Igbm93LlxuICAgIFx0aWYgKGZpcnN0ICYmIHJlbmRlckZpcnN0RWxlbWVudCkge1xuICAgIFx0XHRmaXJzdCA9IGZhbHNlO1xuICAgIFx0XHR2aWV3LnJlbmRlckZpbHRlcnMoKTtcbiAgICBcdFx0c2VsZi4kKCcuc3ViLWZpbHRlcnMtdGl0bGVzIGxpOmZpcnN0JykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIFx0fVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFdlIG5lZWQgdG8gcmUtdHJhbnNsYXRlIHNvbWUgc3RyaW5ncyBmcm9tIHRoZSByaWdodCBwYW5lbC5cblx0c2VsZi50cmFuc2xhdGUodGhpcyk7XG5cbiAgIFx0cmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3JlZnJlc2hUaXRsZTogZnVuY3Rpb24oKXtcbiAgICB2YXIgdG90YWxTZWxlY3RlZCA9IDA7XG4gICAgdmFyIGNvdW50U3RyID0nJztcblxuICAgIHRoaXMuZmlsdGVyQ29sbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgaWYoZmlsdGVyLmdldE51bVNlbGVjdGVkKXtcbiAgICAgICAgdG90YWxTZWxlY3RlZCArPSBmaWx0ZXIuZ2V0TnVtU2VsZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmKCB0b3RhbFNlbGVjdGVkICE9PSAwKSB7XG4gICAgICBjb3VudFN0ciA9IHRvdGFsU2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogc2hvdWxkIGJlIGxvY2FsbHkgc2NvcGVkLCBub3QgZ2xvYmFsIGpxdWVyeS5cbiAgICAkKCcjJyt0aGlzLm5hbWUucmVwbGFjZSgvIC9nLCcnKSArICcgLnRpdGxlLWNvdW50JykudGV4dChjb3VudFN0cik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlbmRlcnMgdGhlIHRpdGxlIG9mIGEgdGFiXG4gICAqL1xuICByZW5kZXJUaXRsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50aXRsZUVsID0gdGhpcy50aXRsZVRlbXBsYXRlKHtuYW1lOiB0aGlzLm5hbWV9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhc2VGaWx0ZXJWaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvYmFzZS1maWx0ZXItdmlldycpO1xuXG5yZXF1aXJlKCcuLi9saWIvanF1ZXJ5Lm5vdWlzbGlkZXIubWluLmpzJyk7XG5yZXF1aXJlKCdqcXVlcnktdWkvZGF0ZXBpY2tlcicpO1xuXG52YXIgVGVtcGxhdGUgPSBcIlxcbiAgPGgzIGNsYXNzPVxcXCJ0aXRsZSB0ZXh0LWNlbnRlclxcXCI+PHNwYW4gY2xhc3M9XFxcInN0YXJ0LXllYXJcXFwiPmR1bW15PC9zcGFuPiA8c3Ryb25nPi08L3N0cm9uZz4gPHNwYW4gY2xhc3M9XFxcImVuZC15ZWFyXFxcIj5kdW1teTwvc3Bhbj48L2gzPlxcbiAgIDxkaXYgY2xhc3M9XFxcInllYXItc2xpZGVyXFxcIj48L2Rpdj5cXG5cXG4gICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLXN0YXJ0ZGF0ZVxcXCI+U3RhcnQgRGF0ZTo8L3NwYW4+Jm5ic3A8cD48aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcInN0YXJ0LWRhdGVcXFwiIGNsYXNzPVxcXCJkYXRlLXBpY2tlclxcXCI+PC9wPlxcbiAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtZW5kZGF0ZVxcXCI+RW5kIERhdGU6PC9zcGFuPiZuYnNwPHA+PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGlkPVxcXCJlbmQtZGF0ZVxcXCIgY2xhc3M9XFxcImRhdGUtcGlja2VyXFxcIj48L3A+XFxuXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZUZpbHRlclZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6IEJhc2VGaWx0ZXJWaWV3LnByb3RvdHlwZS5jbGFzc05hbWUgKyAnIGZpbHRlci15ZWFycycsXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKFRlbXBsYXRlKSxcbiAgX2xvYWRlZDogbnVsbCxcblxuICBpbml0aWFsaXplOmZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgQmFzZUZpbHRlclZpZXcucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcblxuICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG9wdGlvbnMudHJhbnNsYXRvcjtcbiAgICB0aGlzLnRyYW5zbGF0ZSA9IG9wdGlvbnMudHJhbnNsYXRlO1xuLy8gICAgY29uc29sZS5sb2coXCJqdXN0IGJ1aWx0IGEgeWVhcnMtZmlsdGVyLXZpZXcgZm9yIFwiICsgc2VsZi5tb2RlbC5nZXQoJ25hbWUnKSk7XG4gICAgdGhpcy5fbG9hZGVkID0gdGhpcy5tb2RlbC5mZXRjaCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgXHQvL2NvbnNvbGUubG9nKFwianVzdCBsb2FkZWQgYSB5ZWFycy1maWx0ZXItdmlldyBmb3I6IFwiICsgSlNPTi5zdHJpbmdpZnkoe25hbWU6IHNlbGYubW9kZWwuZ2V0KCduYW1lJyksIHN0YXJ0OiBzZWxmLm1vZGVsLmdldCgnc2VsZWN0ZWRTdGFydCcpLCBlbmQ6IHNlbGYubW9kZWwuZ2V0KCdzZWxlY3RlZEVuZCcpfSkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlJywgdGhpcy5fdXBkYXRlVGl0bGUpO1xuICB9LFxuXG5cbiAgcmVuZGVyRmlsdGVyczpmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgQmFzZUZpbHRlclZpZXcucHJvdG90eXBlLnJlbmRlckZpbHRlcnMuYXBwbHkodGhpcyk7XG5cbiAgICB0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUodGhpcy5tb2RlbC50b0pTT04oKSkpO1xuXG4gICAgdGhpcy5fbG9hZGVkLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAvL3NlbGYuX3JlbmRlclNsaWRlcigpO1xuICAgICAgc2VsZi5fcmVuZGVyRGF0ZVBpY2tlcnMoKTtcbiAgICAgIHNlbGYuX3VwZGF0ZVRpdGxlKCk7XG4gICAgICBcbiAgICAgIC8vIFdlIG5lZWQgdG8gcmUtdHJhbnNsYXRlIHNvbWUgc3RyaW5ncyBmcm9tIHRoZSByaWdodCBwYW5lbC5cbiAgICAgIHNlbGYudHJhbnNsYXRlKHNlbGYpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3JlbmRlckRhdGVQaWNrZXJzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBUT0RPOiBmb3JtYXQgYmFzZWQgb24gYWRtaW4gc2V0dGluZy4uLi5tYXliZSBnZXQgZnJvbSB5ZWFyIGFwaS4uXG4gICAgLy8gVE9ETzogYWJzdHJhY3QgY29tbW9uIHByb3BlcnRpZXMgZnJvbSBvYmplY3QgaW5pdHMgYmVsb3cuLi5cbiAgICAvLyB2YXIgY29tbW9uT2JqID0ge307XG5cbiAgICB0aGlzLiQoJyNzdGFydC1kYXRlJykuZGF0ZXBpY2tlcih7XG4gICAgICBkZWZhdWx0RGF0ZTogdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkU3RhcnQnKSxcbiAgICAgIC8vbWluRGF0ZTogdGhpcy5tb2RlbC5nZXQoJ3N0YXJ0WWVhcicpLFxuICAgICAgLy9tYXhEYXRlOiB0aGlzLm1vZGVsLmdldCgnZW5kWWVhcicpLFxuICAgICAgZGF0ZUZvcm1hdDogJ3l5LW1tLWRkJyxcbiAgICAgIGNoYW5nZU1vbnRoOiB0cnVlLFxuICAgICAgY2hhbmdlWWVhcjogdHJ1ZSxcbiAgICAgIG51bWJlck9mTW9udGhzOiAxLFxuICAgICAgeWVhclJhbmdlOiAnYy02MDpjKzYwJyxcbiAgICAgIG9uQ2xvc2U6IGZ1bmN0aW9uKHNlbGVjdGVkRGF0ZSkge1xuICAgICAgICBzZWxmLiQoJyNlbmQtZGF0ZScpLmRhdGVwaWNrZXIoJ29wdGlvbicsICdtaW5EYXRlJywgc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoJ3NlbGVjdGVkU3RhcnQnLCBzZWxlY3RlZERhdGUpO1xuICAgICAgICAvLyBzZWxmLl91cGRhdGVUaXRsZSgpO1xuICAgICAgfVxuICAgIH0pOyAgICBcblxuICAgIHRoaXMuJCgnI2VuZC1kYXRlJykuZGF0ZXBpY2tlcih7XG4gICAgICBkZWZhdWx0RGF0ZTogdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkRW5kJyksXG4gICAgICAvL21pbkRhdGU6IHRoaXMubW9kZWwuZ2V0KCdzdGFydFllYXInKSxcbiAgICAgIC8vbWF4RGF0ZTogdGhpcy5tb2RlbC5nZXQoJ2VuZFllYXInKSxcbiAgICAgIGRhdGVGb3JtYXQ6ICd5eS1tbS1kZCcsXG4gICAgICBjaGFuZ2VNb250aDogdHJ1ZSxcbiAgICAgIGNoYW5nZVllYXI6IHRydWUsXG4gICAgICBudW1iZXJPZk1vbnRoczogMSxcbiAgICAgIHllYXJSYW5nZTogJ2MtNjA6Yys2MCcsXG4gICAgICBvbkNsb3NlOiBmdW5jdGlvbihzZWxlY3RlZERhdGUpIHtcbiAgICAgICAgc2VsZi4kKCcjc3RhcnQtZGF0ZScpLmRhdGVwaWNrZXIoJ29wdGlvbicsICdtYXhEYXRlJywgc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoJ3NlbGVjdGVkRW5kJywgc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgLy8gc2VsZi5fdXBkYXRlVGl0bGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuJCgnI3N0YXJ0LWRhdGUnKS52YWwodGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkU3RhcnQnKSk7XG4gICAgdGhpcy4kKCcjZW5kLWRhdGUnKS52YWwodGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkRW5kJykpO1xuICB9LFxuXG4gIHJlbmRlclRpdGxlOmZ1bmN0aW9uKCkge1xuICAgIEJhc2VGaWx0ZXJWaWV3LnByb3RvdHlwZS5yZW5kZXJUaXRsZS5hcHBseSh0aGlzKTtcbiAgICB0aGlzLl91cGRhdGVUaXRsZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy9UT0RPOiBkbyBtb3JlIGluIHRlbXBsYXRlLlxuICBfdXBkYXRlVGl0bGU6ZnVuY3Rpb24oKSB7XHRcbiAgICB0aGlzLiR0aXRsZUVsLmZpbmQoJy5maWx0ZXItY291bnQnKS50ZXh0KHRoaXMubW9kZWwuZ2V0KCdzZWxlY3RlZFN0YXJ0JykgK1xuICAgICAgICAnIC0gJyArXG4gICAgICB0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWRFbmQnKSk7XG5cbiAgICAvL2NvbnNvbGUubG9nKCd1cGRhdGluZyB5ZWFycyB0aXRsZSBmb3IgJyArIHRoaXMubW9kZWwuZ2V0KCduYW1lJykgKyAnLCBzdGFydC15ZWFyOiAnICsgdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkU3RhcnQnKSArICcsIGVuZC15ZWFyOiAnICsgdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkRW5kJykpO1xuICAgIHRoaXMuJCgnLnN0YXJ0LXllYXInKS50ZXh0KHRoaXMubW9kZWwuZ2V0KCdzZWxlY3RlZFN0YXJ0JykpO1xuICAgIHRoaXMuJCgnLmVuZC15ZWFyJykudGV4dCh0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWRFbmQnKSk7XG4gIH0sXG5cblxuXG4gIF9yZW5kZXJTbGlkZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIHVzZXMgd2luZG93LmpRdWVyeSBiZWNhdXNlIHRoYXQgd2FzIHRoZSBvbmx5IHdheSBJIGhhZCBsdWNrIHdpdGggYnJvd3NlcmlmeSBzaGltLi4uXG4gICAgLy8gdXNlcyBodHRwczovL2dpdGh1Yi5jb20vbGVvbmdlcnNlbi9ub1VpU2xpZGVyXG4gICAgdGhpcy5zbGlkZXIgPSB3aW5kb3cualF1ZXJ5KHRoaXMuJCgnLnllYXItc2xpZGVyJykpLm5vVWlTbGlkZXIoe1xuICAgICAgc3RhcnQ6IFtzZWxmLm1vZGVsLmdldCgnc2VsZWN0ZWRTdGFydCcpLCBzZWxmLm1vZGVsLmdldCgnc2VsZWN0ZWRFbmQnKV0sXG4gICAgICBzdGVwOiAxLFxuICAgICAgY29ubmVjdDogdHJ1ZSxcbiAgICAgIHJhbmdlOiB7bWluOiBzZWxmLm1vZGVsLmdldCgnc3RhcnRZZWFyJyksIG1heDpzZWxmLm1vZGVsLmdldCgnZW5kWWVhcicpfSxcbiAgICAgIHNlcmlhbGl6YXRpb246IHtcbiAgICAgICAgbG93ZXI6IFtcbiAgICAgICAgICB3aW5kb3cualF1ZXJ5Lkxpbmsoe1xuICAgICAgICAgICAgdGFyZ2V0OiB3aW5kb3cualF1ZXJ5KCcuc3RhcnQteWVhcicpXG4gICAgICAgICAgfSlcbiAgICAgICAgXSxcbiAgICAgICAgdXBwZXI6IFtcbiAgICAgICAgICB3aW5kb3cualF1ZXJ5Lkxpbmsoe1xuICAgICAgICAgICAgdGFyZ2V0OiB3aW5kb3cualF1ZXJ5KCcuZW5kLXllYXInKVxuICAgICAgICAgIH0pXG4gICAgICAgIF0sXG4gICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgIGRlY2ltYWxzOiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vdWdseSwgdG9vIG11Y2ggZGF0YSBpbiB0aGUgZG9tLi4uYnV0IGl0J3MgaG93IHRoZSBleGFtcGxlIGdvZXMuXG4gICAgdGhpcy5zbGlkZXIub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5tb2RlbC5zZXQoJ3NlbGVjdGVkU3RhcnQnLCBwYXJzZUludChzZWxmLiQoJy5zdGFydC15ZWFyJykudGV4dCgpLCAxMCkpO1xuICAgIH0pO1xuXG4gICAgLy91Z2x5LCB0b28gbXVjaCBkYXRhIGluIHRoZSBkb20uLi5idXQgaXQncyBob3cgdGhlIGV4YW1wbGUgZ29lcy5cbiAgICB0aGlzLnNsaWRlci5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm1vZGVsLnNldCgnc2VsZWN0ZWRFbmQnLCAgcGFyc2VJbnQoc2VsZi4kKCcuZW5kLXllYXInKS50ZXh0KCksIDEwKSk7XG4gICAgfSk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cblxuZnVuY3Rpb24gU3RhdGVMb2FkRXJyb3IobWVzc2FnZSwgb3JpZ2luYWwpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0YXRlTG9hZEVycm9yKSkgeyByZXR1cm4gbmV3IFNhdGVMb2FkRXJyb3IobWVzc2FnZSwgb3JpZ2luYWwpOyB9XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMub3JpZ2luYWwgPSBvcmlnaW5hbDtcblxuICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZSgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlIG5lZWRzIHRvIGJlIGNyZWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nKTtcbiAgfVxuXG4gIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5cbl8uZXh0ZW5kKFN0YXRlLnByb3RvdHlwZSwgQmFja2JvbmUuRXZlbnRzLCB7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuc2F2ZWQgPSBvcHRpb25zLnNhdmVkO1xuICAgIC8vIEFueXRoaW5nIHRoYXQgc3RhdGUgbXVzdCByZWdpc3RlciBpdHNlbGYuIFNlZSBgU3RhdGUucmVnaXN0ZXJgLlxuICAgIHRoaXMuX3N0YXRlUmVnaXN0cnkgPSB7fTtcbiAgICAvLyBXaGVuIGxvYWRpbmcgc3RhdGUsIHNvbWUgdGhpbmdzIG1pZ2h0IG5vdCBoYXZlIHJlZ2lzdGVyZWQgeWV0LlxuICAgIC8vIEl0IGdldHMgbWFya2VkIGFzIHVuY2xhaW1lZCwgYW5kIHN0b3JlZCBoZXJlLlxuICAgIHRoaXMuX3VuY2xhaW1lZCA9IHt9O1xuICAgIC8vIHVzZSB0aGUgdXJsLCBpZiB3ZSBoYXZlIGl0XG4gICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICB0aGlzLmxpc3RlblRvVVJMKF8ob3B0aW9ucykucGljaygndXJsJywgJ3ByZWZpeCcsICdhdXRvaW5pdCcpKTtcbiAgICB9XG4gIH0sXG5cbiAgbGlzdGVuVG9VUkw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl91cmwgPSBvcHRpb25zLnVybDtcbiAgICB0aGlzLl91cmxQcmVmaXhlcyA9IG9wdGlvbnMucHJlZml4IHx8IFsnc2F2ZWQvJ107XG5cbiAgICAvLyB3cmFwIHByZWZpeGVzIGluIGFycmF5IHRvIG1ha2UgYmFja3dhcmQgY29tcGF0OlxuICAgIGlmICh0aGlzLl91cmxQcmVmaXhlcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpe1xuICAgICAgdGhpcy5fdXJsUHJlZml4ZXMgPSBbdGhpcy5fdXJsUHJlZml4ZXNdO1xuICAgIH1cblxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5fdXJsLCAnY2hhbmdlJywgdGhpcy51cmxNYXliZUxvYWQpO1xuICAgIGlmIChvcHRpb25zLmF1dG9pbml0ICYmIHRoaXMuX3VybC5oYXNoKCkpIHtcbiAgICAgIHRoaXMudXJsTWF5YmVMb2FkKHRoaXMuX3VybC5oYXNoKCkpO1xuICAgIH0gIC8vIGluaXRpYWwgc3RhdGVcbiAgfSxcblxuICB1cmxNYXliZUxvYWQ6IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1hdGNoRm91bmQgPSBmYWxzZTtcbiAgICBoYXNoID0gaGFzaCB8fCB0aGlzLl91cmwuaGFzaCgpO1xuXG4gICAgLy8gc2VlIGlmIGFueSBwcmVmaXhlcyBtYXRjaCB0aGUgaGFzaC5cbiAgICBfLmVhY2godGhpcy5fdXJsUHJlZml4ZXMsIGZ1bmN0aW9uKHByZWZpeCl7XG4gICAgICAvLyBsb2FkIGEgc3RhdGUgaWYgd2UgZ2V0IHRoZSBVUkwgaGFzaCBmb3Igb25lXG4gICAgICBpZiAoaGFzaC5pbmRleE9mKHByZWZpeCkgPT09IDApIHtcbiAgICAgICAgdmFyIHN0YXRlX29yX2lkID0gaGFzaC5zcGxpdChwcmVmaXgpWzFdO1xuICAgICAgICBpZiAoc3RhdGVfb3JfaWQpIHtcbiAgICAgICAgICBtYXRjaEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmW3NlbGYuc2F2ZWQgPyAnbG9hZEJ5SWQnIDogJ2xvYWQnXShzdGF0ZV9vcl9pZCwgcHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghbWF0Y2hGb3VuZCAmJiBoYXNoID09PSAnJykge1xuICAgICAgc2VsZi5yZXNldCgpO1xuICAgIH1cbiAgfSxcblxuICB0b0hhc2g6IGZ1bmN0aW9uKHN0YXRlX29yX2lkKSB7XG4gICAgaWYgKCFfKHRoaXMpLmhhcygnX3VybCcpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgZ2VuZXJhdGUgVVJMIGhhc2ggd2l0aG91dCBiZWluZyBpbml0aWFsaXplZCB3aXRoIFVSTCBpbnN0YW5jZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXJsUHJlZml4ZXNbMF0gKyBzdGF0ZV9vcl9pZDtcbiAgICB9XG4gIH0sXG5cbiAgbG9hZEJ5SWQ6IGZ1bmN0aW9uKGlkLCBtYXRjaGVkUHJlZml4KSB7XG4gICAgdGhpcy5sb2FkUHJvbWlzZSA9IHRoaXMuc2F2ZWQubG9hZChpZCwgbWF0Y2hlZFByZWZpeCAgKTsvLyBUT0RPOiBkcnM6IGFuZCBwYXNzIG1hdGNoaW5nIHByZWZpeC4uXG4gICAgdGhpcy5sb2FkUHJvbWlzZVxuICAgICAgLmRvbmUoXyhmdW5jdGlvbihzdGF0ZU1vZGVsKSB7XG4gICAgICAgIHRoaXMubG9hZChzdGF0ZU1vZGVsLmdldCgnc3RhdGVCbG9iJykpO1xuICAgICAgfSkuYmluZCh0aGlzKSlcbiAgICAgIC5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgU3RhdGVMb2FkRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIHN0YXRlIGJ5IGlkOiAnICsgaWQpO1xuICAgICAgfSk7XG4gIH0sXG5cbiAgbG9hZDogZnVuY3Rpb24oc3RhdGVzQmxvYikge1xuICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlKHN0YXRlc0Jsb2IpO1xuXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICBfLmVhY2gocGFyc2VkLCBmdW5jdGlvbihzdGF0ZVRvU2V0LCBpZCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9zdGF0ZVJlZ2lzdHJ5W2lkXTtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGN1cnJlbnQpKSB7XG4gICAgICAgIHRoaXMuX3VuY2xhaW1lZFtpZF0gPSBzdGF0ZVRvU2V0O1xuICAgICAgfSBlbHNlIGlmICghXy5pc0VxdWFsKGN1cnJlbnQuZ2V0KCksIHN0YXRlVG9TZXQpKSB7XG4gICAgICAgIGN1cnJlbnQuc2V0KHN0YXRlVG9TZXQpO1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMudHJpZ2dlcignbG9hZCcpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oc3RhdGVzQmxvYikge1xuICAgIC8vIGJyZWFrIG91dCB0aGUgY2FsbCB0byBKU09OLnBhcnNlIHNvIHRoYXQgbG9hZCBjYW4gc3RpbGwgYmUgb3B0aW1pemVkXG4gICAgdmFyIHBhcnNlZDtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShzdGF0ZXNCbG9iKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBTdGF0ZUxvYWRFcnJvcignQ291bGQgbm90IHBhcnNlIHN0YXRlJywgZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAvLyBSZXN0b3JlIGFsbCBzdGF0ZXMgdG8gdGhlaXIgZGVmYXVsdHMgKHNwZWNpZmllZCBhdCByZWdpc3RyYXRpb24pXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICBfLmVhY2godGhpcy5fc3RhdGVSZWdpc3RyeSwgZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBzdGF0ZS5nZXQoKTtcbiAgICAgIGlmICghXy5pc0VxdWFsKGN1cnJlbnRTdGF0ZSwgc3RhdGUuZW1wdHkpKSB7XG4gICAgICAgIC8vIG9ubHkgY2FsbCAuc2V0IGlmIHJlc2V0dGluZyB3aWxsIGFjdHVhbGx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgIHN0YXRlLnNldChzdGF0ZS5lbXB0eSk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdyZXNldCcpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSxcblxuICBmcmVlemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgc3RhdGVTbmFwc2hvdCA9IHt9O1xuICAgIF8uZWFjaCh0aGlzLl9zdGF0ZVJlZ2lzdHJ5LCBmdW5jdGlvbihzdGF0ZSwgaWQpIHtcbiAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBzdGF0ZS5nZXQoKTtcbiAgICAgIHN0YXRlU25hcHNob3RbaWRdID0gXy5jbG9uZShjdXJyZW50U3RhdGUpOyAgLy8gVE9ETzogZGVlcCBjbG9uZSghISlcbiAgICB9KTtcbiAgICB2YXIgc3RhdGVzQmxvYiA9IEpTT04uc3RyaW5naWZ5KHN0YXRlU25hcHNob3QpO1xuICAgIGlmIChvcHRpb25zLnRvVVJMKSB7XG4gICAgICBpZiAoIXRoaXMuX3VybCkgeyBjb25zb2xlLmVycm9yKCdTdGF0ZSBjYW5ub3QgY2hhbmdlIFVSTCBpZiBpdCBkb2VzIGhhdmUgYSByZWYgdG8gaXQnKTsgfVxuICAgICAgdGhpcy5fdXJsLmhhc2godGhpcy5fdXJsUHJlZml4ZXNbMF0gKyBlbmNvZGVVUklDb21wb25lbnQoc3RhdGVzQmxvYikpO1xuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIoJ2ZyZWV6ZScsIHN0YXRlc0Jsb2IpO1xuICAgIHJldHVybiBzdGF0ZXNCbG9iO1xuICB9LFxuXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbihyZWdpc3RyYWJsZSwgaWQsIG9wdGlvbnMpIHtcbiAgICBpZiAoaWQgaW4gdGhpcy5fc3RhdGVSZWdpc3RyeSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgcmVnaXN0cmF0aW9uIG9mIGR1cGxpY2F0ZSBzdGF0ZSBpZCAnICsgaWQpO1xuICAgIH1cblxuICAgIC8vIHJlZ2lzdGVyIHRoZSBzdGF0ZVxuICAgIHRoaXMuX3N0YXRlUmVnaXN0cnlbaWRdID0ge1xuICAgICAgZ2V0OiBfLmJpbmQob3B0aW9ucy5nZXQsIHJlZ2lzdHJhYmxlKSxcbiAgICAgIHNldDogXy5iaW5kKG9wdGlvbnMuc2V0LCByZWdpc3RyYWJsZSksXG4gICAgICBlbXB0eTogb3B0aW9ucy5lbXB0eVxuICAgIH07XG5cbiAgICAvLyBzZXQgdG8gdGhlIGN1cnJlbnRseSBsb2FkZWQgc3RhdGUsIG9yIGl0cyBkZWZhdWx0IGVtcHR5IHN0YXRlXG4gICAgaWYgKGlkIGluIHRoaXMuX3VuY2xhaW1lZCkge1xuICAgICAgdGhpcy5fc3RhdGVSZWdpc3RyeVtpZF0uc2V0KHRoaXMuX3VuY2xhaW1lZFtpZF0pO1xuICAgICAgZGVsZXRlIHRoaXMuX3VuY2xhaW1lZFtpZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YXRlUmVnaXN0cnlbaWRdLnNldChvcHRpb25zLmVtcHR5KTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3JlZ2lzdGVyJyk7XG4gIH1cbn0pO1xuXG5cblN0YXRlLlN0YXRlTG9hZEVycm9yID0gU3RhdGVMb2FkRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlO1xuIiwiLy8gVE9ETzogbW92ZSB0aGlzIHVwIGEgZGlyLCBhbmQgaW5zdGFudGlhdGUgYW5kIGF0dGFjaCB0byB0aGUgYXBwXG5cblxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuZnVuY3Rpb24gVHJhbnNsYXRvcihvcHRpb25zKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNsYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zbGF0b3IgbmVlZHMgdG8gYmUgY3JlYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLicpO1xuICB9XG5cbiAgLy8gdGhpcyBpcyB0aGUgb2JqZWN0IHRoYXQgaGFzIGFsbCAgdGhlIGtleSB2YWx1ZSBwYWlycyBmb3IgdGhlIHdpZGdldC5cbiAgdmFyIHRyYW5zbGF0b3JEZWZhdWx0cyA9IHtcbiAgICBkZWZhdWx0S2V5czoge30sXG4gICAgYXZhaWxhYmxlTGFuZ3VhZ2VzOiBudWxsLC8vIGJhY2tib25lIGNvbGxlY3Rpb25cbiAgICB0cmFuc2xhdGlvbnM6IHtcbiAgICAgIGxvY2FsZXM6IHtcbiAgICAgICAgZW46bnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgYWpheDogJC5hamF4XG4gIH07XG5cbiAgLyogR2F0aGVyIG9wdGlvbnMgKi9cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvKiBFc3BlY2lhbGx5IHVzZWZ1bCBmb3Igb3ZlcndyaXRpbmcgZGVmYXVsdEtleXMsIGF2YWlsYWJsZUxhbmd1YWdlcyBhbmQgdHJhbnNsYXRpb25zICovXG4gICAgXy5kZWZhdWx0cyh0aGlzLCBvcHRpb25zLCB0cmFuc2xhdG9yRGVmYXVsdHMpO1xuICB9XG5cbiAgdGhpcy5fcHJvbWlzZSA9IG51bGw7XG4gIHRoaXMuX2N1cnJlbnRMbmcgPSAndG1wJztcbiAgdGhpcy5fZmlyc3RHZXQgPSBudWxsO1xuXG4gIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBsb2NhbCBzdG9yYWdlIHdpdGggdGltZXN0YW1wXG4gIHRoaXMuaW5pdFRyYW5zbGF0aW9ucyA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cblxuICAgIC8vIHRyeSB3ZWJcbiAgICB0aGlzLl9wcm9taXNlID0gdGhpcy5fZ2V0VHJhbnNsYXRpb25zRnJvbUFQSShzZWxmLmRlZmF1bHRLZXlzKVxuICAgICAgLmZhaWwoZnVuY3Rpb24oanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCAnLCBqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgfSk7XG4gICAgdGhpcy5wcm9taXNlID0gdGhpcy5fcHJvbWlzZS5wcm9taXNlKCk7XG4gIH07XG5cbiAgLyogVXNlIHRoaXMgZm9yIGFkZGluZyBtb3JlIGRlZmF1bHRLZXlzIG9yIHRyYW5zbGF0aW9ucyBieSBtb2R1bGVcbiAgICogaWYgdHJhbnNsYXRvciBoYXMgYWxyZWFkeSBiZWVuIGluc3RhbnRpYXRlZFxuICAgKi9cbiAgdGhpcy5hZGRUcmFuc2xhdG9yT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAvKiBmb3JjZSBhIHJlcXVlc3QgZnJvbSBBUEkgbmV4dCB0aW1lICovXG4gICAgXy5kZWZhdWx0cyh0aGlzLmRlZmF1bHRLZXlzLCBvcHRpb25zLmRlZmF1bHRLZXlzKTtcbiAgICB0aGlzLl9maXJzdEdldCA9IG51bGw7XG4gIH07XG5cblxuICB0aGlzLmdldEF2YWlsYWJsZUxhbmd1YWdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcblxuICAgIGlmICh0aGlzLmF2YWlsYWJsZUxhbmd1YWdlcykge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0aGlzLmF2YWlsYWJsZUxhbmd1YWdlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2luaXRBdmFpbGFibGVMYW5ndWFnZXMoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMuYXZhaWxhYmxlTGFuZ3VhZ2VzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfTtcblxuICB0aGlzLl9pbml0QXZhaWxhYmxlTGFuZ3VhZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hdmFpbGFibGVMYW5ndWFnZXMgPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbihbXSk7XG4gICAgdGhpcy5hdmFpbGFibGVMYW5ndWFnZXMudXJsID0gJy9yZXN0L3RyYW5zbGF0aW9ucy9sYW5ndWFnZXMnO1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZUxhbmd1YWdlcy5mZXRjaCgpO1xuICB9O1xuXG5cbiAgLy8gaW1wb3J0YW50IHRvIGxldCB0aGUgYXBpIGtub3csIHNvIGFsbCByZXNwb25zZXMgYXJlIHRyYW5zbGF0ZWQuXG4gIHRoaXMuc2V0TGFuZ3VhZ2UgPSBmdW5jdGlvbihsbmcpIHtcbiAgICB0aGlzLl9jdXJyZW50TG5nID0gbG5nO1xuICAgIHJldHVybiB0aGlzLl9hcGlDYWxsKCcvcmVzdC90cmFuc2xhdGlvbnMvbGFuZ3VhZ2VzLycgKyBsbmcsIG51bGwsICdHRVQnKTtcbiAgfTtcblxuXG4gIHRoaXMudHJhbnNsYXRlRE9NID0gZnVuY3Rpb24oZWwpIHtcblxuICAgIHZhciAkbmV3RWwgPSAkKGVsKTtcblxuICAgIC8qIFRPRE8gaGFuZGxlIFt0aXRsZV1naXMuYXBwOm1lbnUtaXRlbS10b29sdGlwICovXG5cbiAgICAvKiBUT0RPKHRkayk6IFdlIGlkZW50aWZpZWQgYSBtYWpvciBidWcgaGVyZSB3aGVyZSByb290IGltbWVkaWF0ZSBjaGlsZFxuICAgICAqICB0ZW1wbGF0ZSBlbGVtZW50cyB3aXRoIHRyYW5zbGF0aW9ucyBhcmUgbm90IGJlaW5nIGNhdWdodCBieSB0aGlzXG4gICAgICogIHNlbGVjdG9yLlxuICAgICAqXG4gICAgICogIFRvIHdvcmthcm91bmQsIHdlIHNob3VsZCBjbG9uZSwgd3JhcCwgcnVuIHRoZSBzZWxlY3RvciBhbmQgdW53cmFwIHRoZSBET00uXG4gICAgICpcbiAgICAgKiAgUmVtZW1iZXIgdGhpcyBoYXMgdG8gd29yayBmb3IgZWwncyBhcm91bmQgdGhlIGFwcCB0aGF0IGFyZSBib3VuZFxuICAgICAqICBhbmQgbm90IGJvdW5kLlxuICAgICAqL1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNsYXRpb25zKCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAkLmVhY2goZGF0YSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAvKmlmICgkKCdbZGF0YS1pMThuPVwiJyArIGtleSArICdcIl0nLCAkbmV3RWwpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhrZXksICctPicsIHZhbHVlLCcgJCBmb3VuZC0+JywgJG5ld0VsLmZpbmQoJ1tkYXRhLWkxOG49XCInICsga2V5ICsgJ1wiXScpLnRleHQoKSk7XG4gICAgICAgIH0qL1xuICAgIFx0XG4gICAgXHQvLyBXZSBuZWVkIGEgd2F5IHRvIGlkZW50aWZ5IGNvbnRyb2xzIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBuZWVkcyB0byBiZSB0cmFuc2xhdGVkIGluc3RlYWQgb2YgdGhlIHRleHQuXG5cdCBcdGlmIChrZXkuaW5kZXhPZignW3BsYWNlaG9sZGVyXScpID4gLTEpIHtcblx0IFx0XHQkKCdbZGF0YS1pMThuPVwiJyArIGtleSArICdcIl0nLCAkbmV3RWwpLmF0dHIoJ3BsYWNlaG9sZGVyJywgdmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkKCdbZGF0YS1pMThuPVwiJyArIGtleSArICdcIl0nLCAkbmV3RWwpLnRleHQodmFsdWUpO1xuXHRcdH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICRuZXdFbDtcbiAgICB9KTtcbiAgfTtcblxuXG4gIC8qXG4gICAqIFBhc3MgaW4gYSB7XCJhbXAuZ2lzOmRhdGEtaTE4bi1jb2RlXCI6IFwiYmFzZSBsYW5nIHdvcmRzXCIsIC4uLn0gb2JqZWN0IGZvclxuICAgKiB0cmFuc2xhdGlvbiBlLmcuIHBhZ2UgdGl0bGVcbiAgICogKi9cbiAgIC8vIFRPRE86IGRvbid0IGNhbGwgaXQgYSBsaXN0IGlmIGl0J3MgYW4gb2JqZWN0ID8hXG4gIHRoaXMudHJhbnNsYXRlTGlzdCA9IGZ1bmN0aW9uKGxpc3QpIHtcblxuICAgIC8vIHVwZGF0ZSB0cmFuc2xhdGVhYmxlIGVsZW1lbnRzIGluIHRoaXMga2V5LXZhbHVlIHNldFxuICAgIHZhciBfdXBkYXRlTGlzdCA9IGZ1bmN0aW9uKGxpc3QsIGkxOG5EYXRhKSB7XG4gICAgICBfLmVhY2gobGlzdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgbGlzdCkge1xuICAgICAgICBpZiAoaTE4bkRhdGFba2V5XSkge1xuICAgICAgICAgIGxpc3Rba2V5XSA9IGkxOG5EYXRhW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdFtrZXldID0ga2V5W3ZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNsYXRpb25zKCkudGhlbihmdW5jdGlvbihpMThuRGF0YSkge1xuICAgICAgdmFyIG91dExpc3QgPSBfdXBkYXRlTGlzdChsaXN0LCBpMThuRGF0YSk7XG4gICAgICByZXR1cm4gb3V0TGlzdDtcbiAgICB9KTtcbiAgfTtcblxuXG4gIC8qXG4gICAqIFN5bmNocm9ub3VzbHkgZ2V0IGEgKGFscmVhZHktbG9hZGVkKSB0cmFuc2xhdGlvblxuICAgKi9cbiAgdGhpcy50cmFuc2xhdGVTeW5jID0gZnVuY3Rpb24oa2V5LCBhbHQpIHtcbiAgICBpZiAodGhpcy5nZXRUcmFuc2xhdGlvbnMoKS5zdGF0ZSgpICE9PSAncmVzb2x2ZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCd0cmFuc2xhdGVTeW5jIHdhcyBjYWxsZWQgd2hlbiBnZXRUcmFuc2xhdGlvbnMgaXMgbm90IHN1Y2Nlc3NmdWxseSByZXNvbHZlZCcpO1xuICAgIH1cbiAgICB2YXIgdHJhbnNsYXRlZCA9IHRoaXMudHJhbnNsYXRpb25zLmxvY2FsZXNbdGhpcy5fY3VycmVudExuZ11ba2V5XTtcbiAgICBpZiAodHJhbnNsYXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIHRyYW5zbGF0aW9uIGhhcyBiZWVuIGxvYWRlZCBmb3InLCBrZXkpO1xuICAgICAgdHJhbnNsYXRlZCA9IGFsdCB8fCBrZXk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2xhdGVkO1xuICB9O1xuXG5cbiAgLy8gT25seSBkbyBzaW5nbGUgcmVxdWVzdCBvbiBsYXVuY2guXG4gIHRoaXMuZ2V0VHJhbnNsYXRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdGhpcyB3YXkgd29uJ3Qgd29yayB3aXRoIGNoYW5nZSBsYW5ndWFnZXMgbWlkIHdheSB0aG91Z2guXG4gICAgaWYgKCF0aGlzLl9maXJzdEdldCkge1xuICAgICAgdGhpcy5fZmlyc3RHZXQgPSB0aGlzLl9nZXRUcmFuc2xhdGlvbnNGcm9tQVBJKHRoaXMuZGVmYXVsdEtleXMsIHRoaXMuX2N1cnJlbnRMbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmlyc3RHZXQ7XG4gIH07XG5cblxuICB0aGlzLl9nZXRUcmFuc2xhdGlvbnNGcm9tQVBJID0gZnVuY3Rpb24odHJhbnNsYXRlYWJsZXMsIGxuZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdXJsID0gJy9yZXN0L3RyYW5zbGF0aW9ucy9sYWJlbC10cmFuc2xhdGlvbnMnO1xuXG4gICAgcmV0dXJuIHRoaXMuX2FwaUNhbGwodXJsLCB0cmFuc2xhdGVhYmxlcywgJ1BPU1QnKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIC8vY2FjaGUgaWYgd2Uga25vdyB0aGUgbG5nLiBUT0RPOiBnZXQgYXBpIHRvIGFsd2F5cyByZXR1cm4gdGhlIGxuZy5cbiAgICAgIGlmIChsbmcpIHtcbiAgICAgICAgc2VsZi50cmFuc2xhdGlvbnMubG9jYWxlc1tsbmddID0gZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRlbXAgaGFjayB0byBkbyBjYWNoaW5nIGlmIEFQSSBkb2Vzbid0IHJldHVybiBjdXJyZW50IGxuZ1xuICAgICAgICBsbmcgPSB0aGlzLl9jdXJyZW50TG5nO1xuICAgICAgICBzZWxmLnRyYW5zbGF0aW9ucy5sb2NhbGVzW2xuZ10gPSBkYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbiAgfTtcblxuXG4gIC8vIGhlbHBlciB0byB3cmFwIGFwaSBjYWxsXG4gIHRoaXMuX2FwaUNhbGwgPSBmdW5jdGlvbih1cmwsIGRhdGEsIHR5cGUpIHtcbiAgICB2YXIgYWpheE9wdGlvbnMgPSB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC8vIGpzY3M6ZGlzYWJsZSBkaXNhbGxvd1F1b3RlZEtleXNJbk9iamVjdHNcbiAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAvLyBqc2NzOmVuYWJsZSBkaXNhbGxvd1F1b3RlZEtleXNJbk9iamVjdHNcbiAgICAgIH0sXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgfTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgYWpheE9wdGlvbnMuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFqYXgoYWpheE9wdGlvbnMpO1xuICB9O1xuXG4gIHRoaXMuaW5pdFRyYW5zbGF0aW9ucygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zbGF0b3I7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cblxuZnVuY3Rpb24gVVJMKCkge1xuICAndXNlIHN0cmljdCc7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVUkwgbmVlZHMgdG8gYmUgY3JlYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLicpO1xuICB9XG4gIGlmICh3aW5kb3cuX2FtcFVybGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbm90aGVyIGluc3RhbmNlIG9mIFVSTCBpcyBhbHJlYWR5IG1hbmFnaW5nIHdpbmRvdy5sb2NhdGlvbicpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5fYW1wVXJsZXIgPSB0cnVlO1xuICB9XG4gIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5cbl8uZXh0ZW5kKFVSTC5wcm90b3R5cGUsIEJhY2tib25lLkV2ZW50cywge1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgXy5iaW5kQWxsKHRoaXMsICdjaGFuZ2UnKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuY2hhbmdlKTsgIC8vIElFIDgrXG4gIH0sXG5cbiAgaGFzaDogZnVuY3Rpb24obmV3SGFzaCwgb3B0aW9ucykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpOyAgLy8gcmVtb3ZlICcjJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHsgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoYW5nZSk7IH0gIC8vIElFIDkrXG4gICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IG5ld0hhc2g7XG4gICAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHsgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoYW5nZSk7IH1cbiAgICB9XG4gIH0sXG5cbiAgZnVsbDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgd2luZG93LmxvY2F0aW9uO1xuICB9LFxuXG4gIGNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzLmhhc2goKSk7XG4gIH1cblxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBVUkw7XG4iXX0=
