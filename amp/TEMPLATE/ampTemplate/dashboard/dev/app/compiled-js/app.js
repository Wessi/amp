(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./app/js/app.js":[function(require,module,exports){
require('./ugly/lib-load-hacks');
var jquery = require('jquery');
var _ = require('underscore');
var UserModel = require('./app/models/amp-user.js');
var App = require('./app/app-class');
var app = new App({ el: '#amp-dashboard' });
window.app = app;  // for debugging convenience

//Force call to the EP that sends the saved filters if any.
app.state.saved.load();
//app.render();

},{"./app/app-class":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\app-class.js","./app/models/amp-user.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\amp-user.js","./ugly/lib-load-hacks":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\lib-load-hacks.js","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\app-class.js":[function(require,module,exports){
var _ = require('underscore');
var Deferred = require('jquery').Deferred;
var BackboneDash = require('./backbone-dash');
var supportCheck = require('./check-support');

var URLService = require('amp-url/index');
var State = require('amp-state/index');
var StateLoadError = require('amp-state/index').StateLoadError;

var Translator = require('amp-translate');
var Filter = require('amp-filter/src/main');
var Settings = require('./models/settings-collection');
var UserModel = require('./models/amp-user.js');
var SavedDashes = require('./models/saved-dashes-collection.js');

var MainView = require('./views/main');
var FailView = require('./views/fail');


function App() {
  if (!(this instanceof App)) {
    throw new Error('App needs to be instantiated with the `new` keyword.');
  }
  this.initialize.apply(this, arguments);
}


_.extend(App.prototype, BackboneDash.Events, {
	
  rendered: false,

  initialize: function(options) {
    var _initDefer = new Deferred(),
        missingFeatures;
    this.initialized = _initDefer.promise();

    try {
    	this.settings = new Settings([], { app: this });
    	this.user = new UserModel()

      // check our support level
      this.browserIssues = supportCheck();
      _(this.browserIssues).chain()
        .groupBy('severity')
        .each(function(severityGroup, severity) {
          missingFeatures = _(severityGroup).pluck('feature').join(', ');
          if (severity === 'critical') {
            throw {
              name: 'Incompatible Web Browser',
              message: 'Dashboards cannot work without these features, which are ' +
                       'not supported by your web browser: ' + missingFeatures + '. ' +
                       'Any <a href="http://browsehappy.com/">modern browser</a> will work.',
              toString: function() { return this.name + ': ' + this.message; }
            };
          } else if (severity === 'major') {
            this.report('Limited support for old web browsers', [
              'Your browser does not provide some features used by Dashboards: ' +
              missingFeatures + '.',
              'Some features may not work correctly, however any ' +
              '<a href="http://browsehappy.com/">modern browser</a> will provide ' +
              'a better experience.']);
          } else if (severity === 'minor') {
            console.warn('This browser is missing support for', missingFeatures);
          }
        }, this);

      // inject downloadify if we have no download but have flash (IE)
      if (this.hasIssue('download') && !this.hasIssue('flash')) {
        var swfObj = document.createElement('script'),
            downloadify = document.createElement('script');
        swfObj.src = '/TEMPLATE/ampTemplate/commonJs/swfobject-2.2.js';
        downloadify.src = '/TEMPLATE/ampTemplate/commonJs/downloadify-0.2.js';
        document.body.appendChild(swfObj);
        document.body.appendChild(downloadify);
      }

      // initialize app services
      this.url = new URLService();
      this.savedDashes = new SavedDashes([], { app: this });
      this.state = new State({
        url: this.url,
        saved: this.savedDashes
      });
      
      // try to load an initial state from the url
      try {
    	  this.state.urlMaybeLoad();
      } catch (e) {
          if (e instanceof StateLoadError) {
        	  this.report('Could not load saved dashboard', ['If you are trying to load a shared link, please make sure the entire URL was copied']);
        	  this.url.hash('');  // clear the bad saved-state hash
          } else {
        	  throw e;
          }
      }

      var dashboardTranslateKeys = JSON.parse("{\n\"amp.common:footer\": \"Developed in partnership with OECD, UNDP, WB, Government of Ethiopia and DGF\",\n\n\"amp.common:title\": \"AMP\",\n\"amp.common:title-desktop\": \"Desktop\",\n\"amp.common:subtitle-my-desktop\": \"My Desktop\",\n\"amp.common:subtitle-add-tab\": \"Add Tab\",\n\"amp.common:subtitle-tab-manager\": \"Tab Manager\",\n\"amp.common:title-reports\": \"Reports\",\n\"amp.common:subtitle-all-reports\": \"All Reports\",\n\"amp.common:subtitle-fav-reports\": \"Favourite Reports\",\n\"amp.common:subtitle-report-generator\": \"Report Generator\",\n\"amp.common:subtitle-saiku\": \"Saiku\",\n\"amp.common:title-documents\": \"Documents\",\n\"amp.common:title-dashboards\": \"Dashboards\",\n\"amp.common:subtitle-gis\": \"New GIS (BETA)\",\n\"amp.common:subtitle-dashboards\": \"New Dashboard (BETA)\",\n\"amp.common:subtitle-dashboard-generator\": \"Dashboard Generator\",\n\"amp.common:subtitle-donor-profile\": \"Donor Profile\",\n\"amp.common:subtitle-region-profile\": \"Region Profile\",\n\"amp.common:subtitle-sector-profile\": \"Sector Profile\",\n\"amp.common:subtitle-executing-profile\": \"Executing Agency Profile\",\n\"amp.common:subtitle-beneficiary-profile\": \"Beneficiary Ministry Profile\",\n\"amp.common:title-tools\": \"Tools\",\n\"amp.common:subtitle-workspace-setup\": \"Workspace Setup\",\n\"amp.common:subtitle-advanced-mode\": \"Advanced Mode\",\n\"amp.common:subtitle-search\": \"Search\",\n\"amp.common:subtitle-addressbook\": \"Address Book\",\n\"amp.common:title-help\": \"Help\",\n\"amp.common:subtitle-amp-help\": \"AMP Help\",\n\"amp.common:subtitle-glossary\": \"Glossary\",\n\"amp.common:subtitle-email-support-team\": \"Email Support Team\",\n\"amp.common:title-logout\": \"Logout\",\n\"amp.common:filters-loading\": \"Loading...\",\n\"amp.dashboard:page-title\":\"AMP Dashboards\",\n\"amp.dashboard:loading\": \"Loading...\",\n\"amp.dashboard:title-projectdata\": \"Project Data\",\n\"amp.dashboard:sub-title-projectdata\": \"View where projects are being implemented throughout the country.\",\n\"amp.dashboard:title-Country\": \"Country\",\n\"amp.dashboard:title-Region\": \"Region\",\n\"amp.dashboard:title-Zone\": \"Zone\",\n\"amp.dashboard:title-District\": \"District\",\n\"amp.dashboard:chart-reset\": \"reset others\",\n\"amp.dashboard:chart-radioui-commitments\": \"Commitments\",\n\"amp.dashboard:chart-radioui-disbursements\": \"Disbursements\",\n\"amp.dashboard:filters-none-applied\": \"No filters applied\",\n\"amp.dashboard:close\": \"Close\",\n\"amp.dashboard:modal-sorry\": \"Sorry for any inconvenience\",\n\"amp.dashboard:share-dashboard-top\": \"Share dashboard\",\n\"amp.dashboard:share-dashboard\": \"Share this dashboard view\",\n\"amp.dashboard:share-link\": \"Link\",\n\"amp.dashboard:of\": \"of\",\n\"amp.dashboard:tooltip-predict-otherseries\": \"TRANSLATEME\",\n\"amp.dashboard:total\": \"total\",\n\"amp.common:title\": \"AMP Toolbar\",\n\"amp.common:title-filters\": \"Filters\",\n\"amp.dashboard:chart-TopDonorAgencies\": \"Top Donor Agencies\",\n\"amp.dashboard:chart-TopDonorGroups\": \"Top Donor Groups\",\n\"amp.dashboard:chart-TopRegions\": \"Top Regions\",\n\"amp.dashboard:chart-TopSectors\": \"Top Sectors\",\n\"amp.dashboard:chart-AidPredictability\": \"Aid Predictability\",\n\"amp.dashboard:chart-FundingType\": \"Funding Type\",\n\"amp.dashboard:chart-ResponsibleOrganizations\": \"Responsible Organizations\",\n\"amp.dashboard:chart-BeneficiaryAgencies\": \"Beneficiary Agencies\",\n\"amp.dashboard:chart-ExecutingAgencies\": \"Executing Agencies\",\n\"amp.dashboard:chart-ImplementingAgencies\": \"Implementing Agencies\",\n\"amp.dashboard:chart-Peace-buildingandState-buildingGoals\": \"Peace-building and State-building Goals\",\n\"amp.dashboard:predictability-planned\": \"Planned\",\n\"amp.dashboard:predictability-actual\": \"Actual\",\n\"amp.dashboard:chart-FundingType-Grant\": \"Grant\",\n\"amp.dashboard:chart-FundingType-Loan\": \"Loan\",\n\"amp.dashboard:chart-FundingType-others\": \"Others\",\n\"amp.dashboard:chart-TopRegions-DistrictUndefined\": \"District: U\",\n\"amp.dashboard:chart-TopRegions-others\": \"Others\",\n\"amp.dashboard:chart-TopSectors-others\": \"Others\",\n\"amp.dashboard:chart-TopDonorAgencies-others\": \"Others\",\n\"amp.dashboard:chart-TopDonorGroups-others\": \"Others\",\n\"amp.dashboard:chart-ResponsibleOrganizations-others\": \"Others\",\n\"amp.dashboard:chart-BeneficiaryAgencies-others\": \"Others\",\n\"amp.dashboard:chart-ExecutingAgencies-others\": \"Others\",\n\"amp.dashboard:chart-ImplementingAgencies-others\": \"Others\",\n\"amp.dashboard:chart-Peace-buildingandState-buildingGoals-others\":\"Others\",\n\"amp.dashboard:filters-edit\":\"edit filters\",\n\"amp.dashboard:dashboard-settings\":\"Settings\",\n\"amp.dashboard:settings-edit\":\"edit settings\",\n\"amp.dashboard:download-amount\":\"Amount\",\n\"amp.dashboard:download-preview\":\"Preview:\",\n\"amp.dashboard:download-rendering\":\"Rendering...\",\n\"amp.dashboard:download-download-chart\":\"Download chart\",\n\"amp.dashboard:download-download-data\":\"Download data\",\n\"amp.dashboard:chart-no-data-available\":\"No Data Available\",\n\"amp.dashboard:chart-loading-saved-settings\":\"Loading saved settings...\",\n\"amp.dashboard:filters-show-settings\":\"Show filter settings\",\n\"amp.dashboard:filters-chart-legends-Grouped\":\"Grouped\",\n\"amp.dashboard:filters-chart-legends-Stacked\":\"Stacked\",\n\"amp.dashboard:of-total\": \"of total\",\n\"amp.dashboard:aid-predictability-actual-disbursements\": \"Actual Disbursements\",\n\"amp.dashboard:aid-predictability-planned-disbursements\": \"Planned Disbursements\",\n\"amp.dashboard:filters-hide-details\": \"Hide filter details\",\n\"amp.dashboard:saving-state\": \"Saving dashboard state, please wait...\",\n\"amp.dashboard:date-range\": \"Date Range\",\n\"amp.dashboard:currency\" : \"Currency\",\n\"amp.dashboard:type\" : \"Type\",\n\"amp.dashboard:year\" : \"Year\",\n\"amp.dashboard:ftype-actual-commitment\": \"Actual Commitments\",\n\"amp.dashboard:ftype-actual-disbursement\": \"Actual Disbursements\",\n\"amp.dashboard:ftype-actual-expenditure\": \"Actual Expenditures\",\n\"amp.dashboard:ftype-planned-commitment\": \"Planned Commitments\" ,\n\"amp.dashboard:ftype-planned-disbursement\":\t\"Planned Disbursements\" ,\n\"amp.dashboard:ftype-planned-expenditures\":\t\"Planned Expenditures\",  \t\t\t\n\"amp.dashboard:dashboard-chart-tops-info-modal\": \"Category Detail\",\n\"amp.dashboard:chart-tops-table-projecttitle\": \"Project Title\",\n\"amp.dashboard:chart-tops-inunits\": \"In units\",\n\"amp.dashboard:chart-tops-inthousands\": \"In thousands\",\n\"amp.dashboard:chart-tops-inmillions\": \"In millions\",\n\"amp.dashboard:chart-thousand\": \"k\",\n\"amp.dashboard:chart-million\": \"M\",\n\"amp.dashboard:chart-billion\": \"B\",\n\"amp.dashboard:chart-trillion\": \"T\",\n\"amp.dashboard:chart-peta\": \"P\",\n\"amp.dashboard:chart-exa\": \"E\",\n\"amp.dashboard:chart-swap-axes\": \"Swap Axes\",\n\"amp.dashboard:chart-HeatMapbySectorandDonorGroup\":\"Sector Fragmentation\",\n\"amp.dashboard:chart-HeatMapbyLocationandDonorGroup\":\"Location Fragmentation\",\n\"amp.dashboard:chart-HeatMapbyProgramandDonorGroup\":\"Program Fragmentation\",\n\"amp.dashboard:chart-heatmap-reset-others\":\"Reset Others\",\n\"amp.dashboard:negatives-values\":\"Negative values are not represented in this chart.\",\n\"amp.dashboard:negatives-values-parag\":\"Please switch to bar chart or table view to view all values.\",\n\"amp.dashboard:chart-heatmap-legends\":\"LEGENDS\",\n\"amp.dashboard:chart-heatmap-totals\":\"TOTALS\",\n\"amp.dashboard:chart-heatmap-legend-less-than\":\"Less than\",\n\"amp.dashboard:chart-heatmap-legend-between\":\"Between\",\n\"amp.dashboard:chart-heatmap-legend-and\":\"and\",\n\"amp.dashboard:chart-heatmap-legend-more-than\":\"More than\",\n\"amp.dashboard:chart-heatmap-others\":\"Others\",\n\"amp.dashboard:percentage\": \"Percentage\",\n\"amp.dashboard:chart-heatmap-help-text-location\":\"Each cell represents an intersection between a donor group and a location and represents how much that funder contributes to the total funding received by that location.\",\n\"amp.dashboard:chart-heatmap-help-text-sector\":\"Each cell represents an intersection between a donor group and a sector and represents how much that funder contributes to the total funding received by that sector.\",\n\"amp.dashboard:chart-heatmap-help-text-program\":\"Each cell represents an intersection between a donor group and a program and represents how much that funder contributes to the total funding received by that program.\"\n}");
      this.translator = new Translator({
        defaultKeys: dashboardTranslateKeys,
        ajax: BackboneDash.wrappedAjax
      });
      // TODO: handle translations load failure      ​
      this.filter = new Filter({
          draggable: true,
          sync: options.sync || BackboneDash.sync,
          caller: 'DASHBOARD'
        });
 
  	  // initialize app components
      this.view = new MainView({ app: this, el: options.el });

      _initDefer.resolve(this);
    } catch (e) {
      _.defer(function() { throw e; });
      this.view = new FailView({ app: this, el: options.el, err: e});
      this.err = e;
      _initDefer.reject(this);
    }
  },

  render: function() {
    // TODO: fix some parts of the app so we can load translations async
    this.tryAfter(this.translator.promise, this.view.render, this.view);
    // this.tryTo(this.view.render, this.view);

    /* ensure entire page--header and footer, not just this view is translated */
    // TODO: if possible, move this out of app-class
    // or at least make it more targeted than document
    this.translator.translateDOM(document);
  },

  hasIssue: function(featureName) {
    return !!_(this.browserIssues).findWhere({feature: featureName});
  },

  viewFail: function(view, err) {
    view.$el.html(new FailView({ app: this, err: err }).render().el);
  },

  tryTo: function(fn, view) {
    try {
      return fn.call(view);
    } catch (e) {
      _.defer(function() { throw e; });
      this.viewFail(view, e);
    }
  },

  tryAfter: function(promise, fn, view) {
    promise
      .done(_(function() {
        this.tryTo(fn, view);
      }).bind(this))
      .fail(_(function() {
        this.viewFail(view, 'failed to load');
      }).bind(this));
  },

  report: function(title, messages) {
    this.initialized
      .done(function(app) {
        app.modal(title, {messages: messages, tone: 'warning'});
      })
      .fail(function() {
        console.warn('REPORT:', title, messages);
      });
  },

  modal: function(title, options) {
    options = _({}).extend(options, {tone: 'primary'});
    var modalReady = new Deferred();
    this.initialized
      .done(function(app) {
        var modalEl = app.view.modal(title, options);
        modalReady.resolve(modalEl);
      })
      .fail(function() {
        console.warn('failed to show modal because the app views did not initialize', title);
        modalReady.reject('app views did not init');
      });
    return modalReady.promise();
  }

});


module.exports = App;

},{"./backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","./check-support":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\check-support.js","./models/amp-user.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\amp-user.js","./models/saved-dashes-collection.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\saved-dashes-collection.js","./models/settings-collection":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\settings-collection.js","./views/fail":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\fail.js","./views/main":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\main.js","amp-filter/src/main":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\main.js","amp-state/index":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-state\\index.js","amp-translate":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-translate\\index.js","amp-url/index":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-url\\index.js","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


// TODO: ... ... ...
var IS_PHILS_CORS = window && (window.location.host === 'localhost:3000');


var CACHE = ['/rest/dashboard'];


function InitError(instance) {
  this.instance = instance;
  this.toString = function() { return 'Module initialization error'; };
}


var ajaxOptionWrap = function(options) {
  options = _({}).extend(options, {
    // maybe use phil's DRC CORS dev server
    url: (IS_PHILS_CORS ? 'http://localhost:8080' : '') + options.url,
    headers: {
      // jscs:disable disallowQuotedKeysInObjects
      'Accept': 'application/json',
      'Content-Type': 'application/json'
      // jscs:enable disallowQuotedKeysInObjects
    }
  });
  return options;
};


var syncOverride = (function(bs) {
  var cache = {};

  function _doSync(url, method, model, options) {
    options = _({}).extend(options, { url: url });
    options = ajaxOptionWrap(options);
    return bs.call(this, method, model, options);
  }

  function _cacheSync(url, method, model, options) {
    var key = url + '+POST:' + options.data;
    if (cache[key]) { return cache[key](); }

    var xhr = _doSync(url, method, model, options);

    cache[key] = function() {
      // calling this function will make the xhr re-call its callbacks
      return xhr
        .done(options.success)
        .always(options.complete);
    };

    // do not cache failed requests
    xhr.fail(function() { delete cache[key]; });

    return xhr;
  }

  return function(method, model, options) {
    var url = options.url || _(model).result('url') || Backbone.Model.prototype.url.call(model),
        cacheable = false;
    if (options.type === 'POST' &&
      _.some(CACHE, function(i) { return url.indexOf(i) === 0; })) {
      cacheable = true;
    }
    return (cacheable ? _cacheSync : _doSync)(url, method, model, options);
  };
})(Backbone.sync);


// mixed into all models, collections and views to ensure we have a convenient
// reference to the app instance everywhere.
function mixDash(Class) {
  return Class.extend({

    constructor: function() {
      var constructed = Class.apply(this, arguments);
      if (!this.app) {
        throw new InitError(this);
      }
      return constructed;
    },

    sync: syncOverride

  });
}


module.exports = _({}).extend(Backbone, {
  // errors
  InitError: InitError,

  Model: mixDash(Backbone.Model),
  Collection: mixDash(Backbone.Collection),
  View: mixDash(Backbone.View),

  sync: syncOverride,
  wrappedAjax: function(o) { return Backbone.ajax(ajaxOptionWrap(o)); }
});

},{"backbone":"backbone","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\_bar.js":[function(require,module,exports){
/*
 * Drawing a bar chart in AMP? Please use ./chart.js instead.
 */

var barDebug = require('../../../../../../../reamp/tools/log')("amp:dashboards:charts:bar");

var nv = window.nv;  // nvd3 is a pain
var d3 = require('d3');
var util = require('../../ugly/util');


function dataToNv(data) {
  return data;
}


function countCategories(data) {
  // note: this takes regular data, not dataToNv data.
  return data[0].values.length - 1;  // 1 for others...?
}


function chart(options, data) {
  //this check is needed because I need strictly either 300 or 400 px, and sometimes, when the chart overflows, it
  //will give me >400 px height
  var height = options.height < 400 ? 300 : 400;
  var calculatedHeight = util.calculateChartHeight(data[0].values.length, false, options.model);
  if (calculatedHeight !== null) {
	  height = calculatedHeight; 
  }
   
  barDebug.log("Setting height to", height);
  var _chart = nv.models.discreteBarChart()
    .valueFormat(options.shortFormatter)
    .showValues(true)
    .showYAxis(false)
    .showXAxis(false)
    .height(height)
    .margin({ top: 5, right: 10, bottom: 10, left: 10 });
  return _chart;
}


function addLegend(svg, chart, nvData, trimLabels, width) {
  var legendHeight;

  var legend = nv.models.legend()
    .width(width || svg.clientWidth)
    .margin({left: 20, right: 20})
    .rightAlign(false)
    .color(util.categoryColours(nvData[0].values.length))
    .key(function(d) { return trimLabels ? util.formatShortText(12)(d.x) : util.formatShortText(85)(d.x); });

  d3.select(svg)
    .datum(nvData)
    .append('g')
      .attr('class', 'legend')
      .datum(nvData[0].values)
      .call(legend);

  legendHeight = svg.querySelector('.legend').getBBox().height;
  chart.margin({top: legendHeight + 15});
}


module.exports = {
  dispatchName: 'discretebar',
  countCategories: countCategories,
  addLegend: addLegend,
  dataToNv: dataToNv,
  chart: chart
};

},{"../../../../../../../reamp/tools/log":"C:\\Git\\amp\\TEMPLATE\\reamp\\tools\\log\\index.js","../../ugly/util":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\util.js","d3":"d3"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\_heatmap.js":[function(require,module,exports){
/*
 * Drawing a bar chart in AMP? Please use ./chart.js instead.
 */

var barDebug = require('../../../../../../../reamp/tools/log')("amp:dashboards:charts:bar");

var nv = window.nv;  // nvd3 is a pain
var d3 = require('d3');
var util = require('../../ugly/util');
var heatMapChart = require('./customized/heatMapChart');
var _ = require('underscore');

function dataToNv(data) {
  return data;
}


function countCategories(data) {
  // note: this takes regular data, not dataToNv data.
  return data[0].values.length - 1;  // 1 for others...?
}


function chart(options, data) {
  //this check is needed because I need strictly either 300 or 400 px, and sometimes, when the chart overflows, it
  //will give me >400 px height
  var height = options.height < 400 ? 300 : 400;
  var calculatedHeight = util.calculateChartHeight(data[0].values.length, false, options.model);
  if (calculatedHeight !== null) {
	  height = calculatedHeight; 
  }
   
  var _chart = nv.models.heatMapChart().height(900);
  return _chart;
}


function addLegend(svg, chart, nvData, trimLabels, width) {
}


module.exports = {
  dispatchName: 'heatmap',
  countCategories: countCategories,
  addLegend: addLegend,
  dataToNv: dataToNv,
  chart: chart
};

},{"../../../../../../../reamp/tools/log":"C:\\Git\\amp\\TEMPLATE\\reamp\\tools\\log\\index.js","../../ugly/util":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\util.js","./customized/heatMapChart":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\customized\\heatMapChart.js","d3":"d3","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\_multibar.js":[function(require,module,exports){
/*
 * Drawing a multibar chart in AMP? Please use ./chart.js instead.
 */

var multibarDebug = require('../../../../../../../reamp/tools/log')("amp:dashboards:charts:multibar");

var nv = window.nv;  // nvd3 is a pain
var customizedMultiBarChart = require('./customized/multiBarChart.js');
// var d3 = require('d3-browserify');


function dataToNv(data) {
  return data;
}


function countCategories(data) {
  // note: this takes regular data, not dataToNv data.
  return data.length;
}


function chart(options) {
  var maxValue = 10;
  //this check is needed because I need strictly either 300 or 400 px, and sometimes, when the chart overflows, it
  //will give me >400 px height
  var height = options.height < 400 ? 300 : 400;
  multibarDebug.log("Setting multibar height", height);
  var _chart = nv.models.customizedMultiBarChart()  
    .forceY([0, maxValue])  // ensures yAxis is showing at least 0 and 10, but won't restrict the domain
                            // (meaning if the are values falling outside the range it will show then).
    .reduceXTicks(false)
    .height(height)
    .margin({ top: 5, right: 10, bottom: 20, left: 50 });

  if (!options.nvControls) {
    _chart.showControls(false);
  }
  
  if(options.stacked){
	  _chart.multibar.stacked(true); 
  }else{
	  _chart.multibar.stacked(false);
  }

  _chart.yAxis
    .tickFormat(options.shortFormatter)
    .showMaxMin(false);

  return _chart;
}


module.exports = {
  dispatchName: 'multibar',
  countCategories: countCategories,
  dataToNv: dataToNv,
  chart: chart
};

},{"../../../../../../../reamp/tools/log":"C:\\Git\\amp\\TEMPLATE\\reamp\\tools\\log\\index.js","./customized/multiBarChart.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\customized\\multiBarChart.js"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\_pie.js":[function(require,module,exports){
/*
 * Drawing a pie chart in AMP? Please use ./chart.js instead.
 */

var nv = window.nv;  // nvd3 is a pain
// var d3 = require('d3-browserify');

var _ = require('underscore');
var common = require('./common');
var util = require('../../ugly/util');
var customizedPieChart = require('./customized/pieChart.js');


function dataToNv(data) {
  if (data.length !== 1) {
    common.fail('Pie charts can only show one series of data. got', data.length);
  }
  if (!_.isArray(data[0].values)) {
    common.fail('Data series did not have a "values" array. Instead', data[0].values);
  }
  return getPositiveValues(data[0].values);
}

function getPositiveValues(values) {
  return _.filter(values, function(e) {
    return e.y>0;
  });
}

function countCategories(data) {
  // note: this takes regular data, not dataToNv data.
  return getPositiveValues(data[0].values).length;
}


function chart(options, data) {
	var height = options.height < 400 ? 300 : 400;
	  var calculatedHeight = util.calculateChartHeight(data[0].values.length, false, options.model);
	  if (calculatedHeight !== null) {
		  height = calculatedHeight; 
	  }

  var _chart = nv.models.customizedPieChart()
    .valueFormat(options.shortFormatter)
    .labelType('percent')
    .showLegend(false)
    .donut(true)
    .height(height)
    .margin({ top: 5, right: 5, bottom: 5, left: 5 })
    .donutRatio(0.35);
  return _chart;
}

function addLegend(svg, chart, nvData, trimLabels, width) {
	  var legendHeight;

	  var legend = nv.models.legend()
	    .width(width || svg.clientWidth)
	    .margin({left: 20, right: 20})
	    .rightAlign(false)
	    .color(util.categoryColours(nvData.length))
	    .key(function(d) { return trimLabels ? util.formatShortText(12)(d.x) : util.formatShortText(85)(d.x); });

	  d3.select(svg)
	    .datum(nvData)
	    .append('g')
	      .attr('class', 'legend')
	      .datum(nvData)
	      .call(legend);

	  legendHeight = svg.querySelector('.legend').getBBox().height;
	  chart.margin({top: legendHeight + 15});
}


function removeLegend(chart) {
  chart.showLegend(false);
}


function normalizeNvTTArgs(fmtX, fmtY, raw) {
  // nv pie charts drop the seriesName as first arg
  return [void 0, fmtX, fmtY, raw];
}


module.exports = {
  dispatchName: 'pie',
  normalizeNvTTArgs: normalizeNvTTArgs,
  countCategories: countCategories,
  addLegend: addLegend,
  removeLegend: removeLegend,
  dataToNv: dataToNv,
  chart: chart
};

},{"../../ugly/util":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\util.js","./common":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\common.js","./customized/pieChart.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\customized\\pieChart.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\_table.js":[function(require,module,exports){

var _ = require('underscore');
var util = require('../../ugly/util');
var common = require('./common');
var tableTemplate = _.template("<div class=\"table-responsive\">\n  <table class=\"table table-striped table-condensed\">\n\n    <% if (_(keys).some()) { %>\n      <thead>\n        <tr>\n          <td></td>\n          <% _(keys).each(function(key, colIndex) { %>\n            <th data-series-index=\"<%= colIndex %>\">\n              <%= key %>\n            </th>\n          <% }); %>\n        </tr>\n      </thead>\n    <% } %>\n\n    <tbody>\n      <% _(values).each(function(row, rowIndex) { %>\n        <tr>\n          <th data-x-index=\"<%= rowIndex %>\">\n            <%= row[0].x %>\n          </th>\n          <% _(row).each(function(datum, colIndex) { %>\n            <td data-x-index=\"<%= rowIndex %>\" data-series-index=\"<%= colIndex %>\">\n              <%= moneyFormat(datum.y) %>\n            </td>\n          <% }) %>\n        </tr>\n      <% }) %>\n    </tbody>\n\n  </table>\n</div>\n");
var heatmapTableTemplate = _.template("<div class=\"heatmap-table-responsive\">\n\t<table class=\"table table-striped table-condensed\">\n\t\t<% if (_(keys).some()) { %>\n\t    \t<thead>\n\t        \t<tr>\n\t          \t\t<% _(keys).each(function(key, colIndex) { %>\n\t            \t\t<th data-series-index=\"0\">\n\t              \t\t\t<%= key %>\n\t            \t\t</th>\n\t          \t\t<% }); %>\n\t        \t</tr>\n\t      \t</thead>\n\t    <% } %>\n\t\t<tbody>\n\t\t\t<% _(matrix).each(function(row, i) { %>\n\t\t\t\t<% _(row).each(function(col, j) { %>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td data-x-index=\"<%= i %>\" data-series-index=\"0\">\n\t\t\t\t\t\t\t<%= matrix[i][j].y %>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td data-x-index=\"<%= i %>\" data-series-index=\"0\">\n\t\t\t\t\t\t\t<%= matrix[i][j].x %>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td data-x-index=\"<%= i %>\" data-series-index=\"0\">\n\t\t\t\t\t\t\t<%= matrix[i][j].value.dv %>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td data-x-index=\"<%= i %>\" data-series-index=\"0\">\n\t\t\t\t\t\t\t<%= matrix[i][j].value.p %>\n\t\t\t\t\t\t</td>\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t</tr>\n\t\t\t\t<% }) %>\n\t\t\t<% }) %>\n\t\t</tbody>\n\t</table>\n</div>");


function fakeRawContext(e, data) {
  // transform a table-click event into something that looks like it came from
  // an nvd3 handler
  var t = e.target,
      seriesIndex = parseInt(util.data(t, 'seriesIndex'), 10) || 0,
      xIndex = parseInt(util.data(t, 'xIndex'), 10);
  // This check is for heatmaps because they dont use the same data structure.
  if (!isNaN(xIndex)) {
	  return {
	    label: data[seriesIndex].values[xIndex].x || xIndex,
	    seriesIndex: seriesIndex,
	    pointIndex: xIndex,
	    point: data[seriesIndex].values[xIndex] || xIndex
	  };
  } else {
	  return {
		  label: '',
		  point: ''
	  };
  }
}


function bindClickHandler(el, data, options) {
  el.addEventListener('click', function(e) {
    var fakeRaw = fakeRawContext(e, data),  // so we can use the shared context transformer
        context = common.getNiceContext(fakeRaw, data, e.target.innerText);
    options.clickHandler(context);
  });
}


function charter(data, options) {
	if (options.model.get('chartType') === 'fragmentation') {
		return heatmapCharter(data, options);
	} else {
		return commonCharter(data, options);
	}	
}

function commonCharter(data, options) {
	var keys = _(data).pluck('key');

	var values = _(data).chain().map(function(datum) {
		return datum.values;
	}).transpose().value();

	var html = tableTemplate({
		keys : keys,
		values : values,
		moneyFormat : options.shortFormatter
	});

	var chartEl = document.createElement('div');
	chartEl.innerHTML = html;

	bindClickHandler(chartEl, data, options);

	return chartEl;
}

function heatmapCharter(data, options) {
	// For AMP-23582: we dont want the name from "summary" because thats the origName and not always the same name than the X axis combo selector. 
	var firstColumnName = _.find(options.model.get('heatmap_config').models[0].get('columns'), function(item) {
		return item.origName === options.model.get('summary')[0];
	}).name; 
	var secondColumnName = _.find(options.model.get('heatmap_config').models[0].get('columns'), function(item) {
		return item.origName === options.model.get('summary')[1];
	}).name;
	var keys = [firstColumnName, 
	            secondColumnName, 
	            this.app.translator.translateSync('amp.dashboard:download-amount', 'Amount'), 
	            this.app.translator.translateSync('amp.dashboard:percentage', 'Percentage')];

	var matrix = _.map(options.model.get("matrix"), function(itemY, i) {
		return _.map(itemY, function(itemX, j) {
			return {
				y : options.model.get("yDataSet")[i],
				x : options.model.get("xDataSet")[j],
				value : (options.model.get("matrix")[i][j] ? options.model.get("matrix")[i][j] : {
					'dv' : '',
					'p' : ''
				})
			}
		})
	});

	var html = heatmapTableTemplate({
		keys : keys,
		matrix : matrix,
		moneyFormat : options.shortFormatter
	});

	var chartEl = document.createElement('div');
	chartEl.innerHTML = html;
	
	bindClickHandler(chartEl, data, options);

	return chartEl;
}


module.exports = {
  charter: charter
};
},{"../../ugly/util":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\util.js","./common":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\common.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\chart.js":[function(require,module,exports){

var _ = require('underscore');
var d3 = require('d3');
var util = require('../../ugly/util');
var common = require('./common');
var barSpecific = require('./_bar');
var multibarSpecific = require('./_multibar');
var pieSpecific = require('./_pie');
var table = require('./_table');
var heatmap = require('./_heatmap');
var defaultTTTemplate = _.template("<div class=\"panel panel-primary panel-popover\">\n  <% if (tt.heading) { %>\n    <div class=\"panel-heading\"><%= tt.heading %></div>\n  <% } %>\n  <div class=\"panel-body\">\n    <span class=\"dollaz\">\n      <% if (tt.bodyText) { %>\n        <%= tt.bodyText %>\n      <% } %>\n      <% if (tt.bodyList) { %>\n        <ul class=\"list-unstyled\">\n          <% _(tt.bodyList).each(function(item) { %>\n            <li><b><%= item.k %></b> <%= item.v %></li>\n          <% }) %>\n        </ul>\n      <% } %>\n    </span>\n  </div>\n  <% if (tt.footerText) { %>\n    <div class=\"panel-footer\">\n      <%= tt.footerText %>\n    </div>\n  <% } %>\n</div>\n");


var charters = {
  bar: common.nvCharter(barSpecific),
  pie: common.nvCharter(pieSpecific),
  multibar: common.nvCharter(multibarSpecific),
  heatmap: common.nvCharter(heatmap),
  table: table.charter
};


function chart(type, data, options) {
  /*
   * @param type: 'bar' (default), 'pie', or 'multibar'
   * @param data: [{key: 'serisName', values: [{x:NN, y:NN}]}]
   * @param options: optional extra stuff
   */

  options = options || {};

  // settings defaults
  options = _(_(options).clone()).defaults({
    height: void 0,  // should fill container in most cases by default
    width: void 0,
    numberFormatter: d3.format(','),
    shortFormatter: options.numberFormatter || util.formatKMB(3, app.settings.numberFormatSettings.decimalSeparator),
    addLegend: true,
    trimLabels: true,
    getTTContent: common.defaultGetTTContent,
    ttTemplate: defaultTTTemplate,
    clickHandler: common.defaultClickHandler,
    nvControls: true
  });

  var charter = charters[type] || common.fail('unrecognized chart type', type);

  return {
    el: charter(data, options)
  };
}


module.exports = chart;

},{"../../ugly/util":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\util.js","./_bar":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\_bar.js","./_heatmap":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\_heatmap.js","./_multibar":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\_multibar.js","./_pie":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\_pie.js","./_table":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\_table.js","./common":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\common.js","d3":"d3","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\common.js":[function(require,module,exports){
var nv = window.nv;  // nvd3 is a pain
var d3 = require('d3');
var util = require('../../ugly/util');
var Numeral = require('numeral');
var _ = require('underscore');


// hack nvd3's calcApproxTextWidth because it is terrrrrrrrrrible
// this solution is just as bad :(
// nvd3 makes me so sad :(
(function(unfortunateLib) {
  var sadWayOfCalculatingTextWidth = unfortunateLib.utils.calcApproxTextWidth;
  unfortunateLib.utils.calcApproxTextWidth = function(svgTextEl) {
    var originalText = svgTextEl.text(),
        spacePaddedText = originalText,
        numberOfDots = (originalText.match(/\./g) || []).length,
        poorlyCalculatedWidth;

    if (originalText.toUpperCase() === originalText) {
      for (var i = 0; i < originalText.length / 5; i++) { spacePaddedText += ' '; }
      svgTextEl.text(spacePaddedText);
      poorlyCalculatedWidth = sadWayOfCalculatingTextWidth(svgTextEl);
      svgTextEl.text(originalText);
    } else {
      poorlyCalculatedWidth = sadWayOfCalculatingTextWidth(svgTextEl);
    }

    // ♪ do you believe in maaaagic ♫
    poorlyCalculatedWidth -=
      (poorlyCalculatedWidth / spacePaddedText.length) * (numberOfDots / 3);
    // ♪ magic magic magic ♫
    poorlyCalculatedWidth += 6;

    return poorlyCalculatedWidth;
  };
})(nv);


function fail(/* arguments */) {
  throw {
    name: 'Chart Error',
    message: Array.prototype.join.call(arguments, ', '),
    toString: function() { return this.name + ': ' + this.message; }
  };
}


function nvChartCommon(nvChart, maxCategories) {
  return nvChart
    .x(function(d) { return util.formatShortText(19)(d.x); })  // fix overflows in legends
    .color(util.categoryColours(maxCategories));
}


function getSecretRenderArea(height, width) {
  var secretArea = document.getElementById('super-secret-render-area-shh');
  if (!secretArea) {
    secretArea = document.createElement('div');
    secretArea.id = 'super-secret-render-area-shh';
    secretArea.style.position = 'absolute';
    secretArea.style.left = '-9999em';
    secretArea.style.top = '-9999em';  // for IE :(
    document.body.appendChild(secretArea);
  }
  if (height) { secretArea.style.height = height + 'px'; }
  if (width) { secretArea.style.width = width + 'px'; }
  return secretArea;
}


function mkChartSVG(height, width) {
  var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('class', 'dash-chart');
  // put it in the dom but out of the way, so we can compute styles n stuff
  getSecretRenderArea(height, width).appendChild(svg);
  return svg;
}


function nvBoiler(nvData, chart, svg, specific, trimLabels, addLegend, width) {
  if (trimLabels) {
    chart.x(function(d) { return util.formatShortText(50)(d.x); });
  }
  if (addLegend && specific.addLegend) {
    specific.addLegend(svg, chart, nvData, trimLabels, width);
  } else if (!addLegend && specific.removeLegend) {
    specific.removeLegend(chart);
  }
  d3.select(svg)
    .datum(nvData)
    .call(chart);
  nv.utils.windowResize(chart.update);  // uuuuuguggggh
  nv.addGraph(function() { return chart; });  // uuuuugly is nvd3
  return svg;
}


function nvColorifyCategories(chart, data, specific) {
  var numberOfCategories = specific.countCategories(data);
  chart.color(util.categoryColours(numberOfCategories));
  return chart;
}


function defaultGetTTContent(context) {
  return {tt: {
    heading: context.x.raw,
    bodyText: context.y.raw,
    formattedAmount: context.z.raw
  }};
}


function getNiceContext(raw, data, fmtY) {
  var seriesIndex = raw.seriesIndex || 0;
  return {
    data: data,
    series: {
      key: data[seriesIndex].key,
      index: seriesIndex,
      values: data[seriesIndex].values
    },
    x: {
      raw: raw.point.x,
      fmt: raw.label,
      index: raw.pointIndex || raw.index || 0
    },
    y: {
      raw: raw.point.y,
      fmt: raw.point.z || fmtY
    }
  };
}


function nvBindTooltip(chart, data, specific, template, getTTContent) {
  var nvTTHandler = function(seriesName, fmtX, fmtY, raw) {
    return template(getTTContent(getNiceContext(raw, data, fmtY)));
  };

  if (specific.normalizeNvTTArgs) { // we might have to fix nv's inconsistent TT args
    nvTTHandler = util.transformArgs(specific.normalizeNvTTArgs, nvTTHandler);
  }
  chart.tooltipContent(nvTTHandler);
}


function defaultClickHandler(/* context */) {
  // does nothing
}


function nvBindOthersCb(chart, data, specific, clickHandler) {
  if (chart[specific.dispatchName] !== undefined) {
	  chart[specific.dispatchName].dispatch.on('elementClick', function(raw) {
		  clickHandler(getNiceContext(raw, data));
	  });
  }	else {
	  console.warn("Cant find " + specific.dispatchName);
  }
}


function nvCharter(specific) {
  return function(data, options) {
    var svg = mkChartSVG(options.height, options.width),
        nvChart = specific.chart(options, data),
        nvData = specific.dataToNv(data);
    nvColorifyCategories(nvChart, data, specific);
    nvBindTooltip(nvChart, data, specific, options.ttTemplate, options.getTTContent);
    nvBoiler(nvData, nvChart, svg, specific, options.trimLabels, options.addLegend, options.width);
    nvBindOthersCb(nvChart, data, specific, options.clickHandler);
    return svg;
  };
}

function formatNumber(number) {
	var format = "";
	if (app.settings.numberFormatSettings.groupSeparator.length > 0) {
		format = "0,0";
	} else {
		format = "0";
	}
	if (app.settings.numberFormatSettings.numberFormat.indexOf('.') > 0) {
		var decimalDigits = app.settings.numberFormatSettings.numberFormat.length
			- app.settings.numberFormatSettings.numberFormat.indexOf('.');
		format = format + "." + new Array(decimalDigits).join("0");
	}

	// Define a new "language" for Numeral where we can change the default
	// delimiters.
	var ampLang = {
		delimiters : {
			thousands : app.settings.numberFormatSettings.groupSeparator,
			decimal : app.settings.numberFormatSettings.decimalSeparator
		},
		abbreviations : {
			thousand : app.translator.translateSync('amp.dashboard:chart-thousand'),
			million : app.translator.translateSync('amp.dashboard:chart-million'),
			billion : app.translator.translateSync('amp.dashboard:chart-billion'),
			trillion : app.translator.translateSync('amp.dashboard:chart-trillion')
		},
		ordinal : function(number) {
			return number === 1 ? 'st' : 'rds';
		},
		currency : {
			symbol : '$'
		}
	};
	Numeral.language('amp', ampLang);
	// Apply new language.
	Numeral.language('amp');
	// Apply the format.
	var stringNumber = new Numeral(number).format(format);
	return stringNumber;
}

var ampLang =


module.exports = {
  fail: fail,
  nvChartCommon: nvChartCommon,
  getNiceContext: getNiceContext,
  defaultGetTTContent: defaultGetTTContent,
  defaultClickHandler: defaultClickHandler,
  mkChartSVG: mkChartSVG,
  nvBoiler: nvBoiler,
  nvCharter: nvCharter,
  formatNumber: formatNumber
};

},{"../../ugly/util":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\util.js","d3":"d3","numeral":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\node_modules\\numeral\\numeral.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\customized\\heatMapChart.js":[function(require,module,exports){
nv.models.heatmap = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 500
        , height = 500
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , duration = 250
        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
        ;


    //============================================================
    // chart function
    //------------------------------------------------------------

    var renderWatch = nv.utils.renderWatch(dispatch);

    function chart(selection) {
        renderWatch.reset();
        renderWatch.renderEnd('heatmap immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        x:          {get: function(){return getX;}, set: function(_){getX=_;}},
        id:         {get: function(){return id;}, set: function(_){id=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
            margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
            margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
            margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
        }},
        y: {get: function(){return getY;}, set: function(_){
            getY=d3.functor(_);
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};

nv.models.heatMapChart = function() {
	"use strict";

	//============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------	

    var heatmap = nv.models.heatmap();

    var margin = {top: 30, right: 20, bottom: 20, left: 20}
    var width = null;
	var height = null;
    var showLegend = false;
    var color = nv.utils.defaultColor();
    var	state = nv.utils.state();
    var defaultState = null;
    var noData = "No Data Available.";
    var duration = 250;
    var dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState','renderEnd');
    var shortTextLength = 17;
    var innerMargin = {
    		top : 120,
			right : 0,
			bottom : 100,
			left : 150
    };
    
    const initialWidth = 960;
    const initialHeight = 400;
    const containerWidth = 1024;

    //============================================================
    // Private Variables
    //------------------------------------------------------------
    var renderWatch = nv.utils.renderWatch(dispatch);

    var stateGetter = function(data) {
    	return function(){
    		return {
    			active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined) {
                data.forEach(function (series, i) {
                    series.disabled = !state.active[i];
                });
            }
        }
    };
  
    var shortenText = function(text, length) {
    	if (text.length > length) {
    		text = text.substring(0, length) + '...';
    	}
    	return text;
    };

    //============================================================
    // Chart function
    //------------------------------------------------------------

    function chart(selection) {
    	var _self = this;
    	this.rendered = false;
    	var _ = require('underscore'); // This doesnt works on top of the file :(((

        renderWatch.reset();
        renderWatch.models(heatmap);

        selection.each(function(data) {
        	// Get currency for later.
        	var currencySettings = _.find(app.settings.models, function(item) {return item.get('id') === '1'});
        	var selectedCurrency = _.find(currencySettings.get('options'), function(item) {return item.selected === true}).value;
        	var newShortTextLength = !data[0].values.model.get('showFullLegends') ? shortTextLength : 100;
        	
        	var container = d3.select(this);
            nv.utils.initSVG(container);

            var availableWidth = (width || parseInt(container.style('width'), 10) || initialWidth)
                    - margin.left - margin.right;
            var availableHeight = (height || parseInt(container.style('height'), 10) || initialHeight)
                    - margin.top - margin.bottom;

            chart.container = this;

            state.setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            //set state.disabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

        	var cubeSize = 30;
        	var width = containerWidth - innerMargin.left - innerMargin.right;
        	var topSectionHeight = 180;
        	var legendSectionHeight = 20;
        	var height = topSectionHeight + (cubeSize * data[0].values.y.length) + legendSectionHeight;
        	var legendElementHeight = 22;
        	const noColor = '#FFFFFF';
        	var categories = getCategoriesByThreshold(noColor, data[0].values.model);
        	
        	$(container[0]).css('height', height + 'px').attr('class', 'dash-chart nvd3-svg heatmap-chart');
        	
        	var svg = container
        		.append("g")
        		.attr("transform", "translate(" + innerMargin.left + "," + innerMargin.top + ")")
        		.attr("class", "heatmap-main-container");
        	
        	// Add SVG filter for cell highlight.
        	// For more info about these filters see: http://www.svgbasics.com/filters4.html // http://apike.ca/prog_svg_filter_feColorMatrix.html // http://alistapart.com/article/finessing-fecolormatrix
        	svg.append("defs").append("filter").attr("id", "filterSaturate").append("feColorMatrix").attr("in", "SourceGraphic").attr("type", "saturate").attr("values", "5");
        	svg.append("defs").append("filter").attr("id", "filterLuminanceToAlpha").append("feColorMatrix").attr("in", "SourceGraphic").attr("type", "luminanceToAlpha");
        	svg.append("defs").append("filter").attr("id", "filterBlur").append("feGaussianBlur").attr("in", "SourceGraphic").attr("stdDeviation", "2");
        	svg.append("defs").append("filter").attr("id", "filterDarken").append("feColorMatrix").attr("type", "matrix").attr("values", "0.5 0 0 0 0 0 0.5 0 0 0 0 0 0.5 0 0 0 0 0 1 0");

        	// Rows container.
        	var yAxisLabelsContainer = svg        	
				.append("g")
				.attr("class", "heatmap-yAxis-container");
        	
        	// Rows.
        	var yAxisLabels = yAxisLabelsContainer
        		.selectAll(".yLabel")
        		.data(data[0].values.y)
        		.enter()
        		.append("text")
        		.text(function(d) {
        			return shortenText(d, newShortTextLength);
        		})
        		.attr("x", 0)
        		.attr("y", function(d, i) {
        			return i * cubeSize;
        		})
        		.style("text-anchor", "end")
        		.attr("transform", "translate(-6," + cubeSize / 1.5 + ")")
        		.attr("class", function(d, i) {
        							return "yLabel mono axis nv-series";
        		})
        		.attr('data-title', function(d) {
        			return d;
        		});
        	
        		// Format "Others" special row if needed.
        		if (data[0].values.yCount < data[0].values.yTotalCount) {
        			var self = this;
        			var data2 = data;
        			var textElement = $(container[0]).find('.yLabel').last();
        			$(textElement).attr("class", function(d, i) {
        				return $(textElement).attr('class') + ' legend-others';
        			});
        		}
        	
        		// Add Totals special row.
        		yAxisLabelsContainer.append("text")
        			.text("TOTALS")
        			.attr("x", 0)
        			.attr("y", (data[0].values.y.length * cubeSize))
        			.attr("class", "yLabel mono axis nv-series heatmap-totals")
        			.style("text-anchor", "end")
        			.style("font-weight", "bold")
            		.attr("transform", "translate(-6," + cubeSize / 1.5 + ")")
            		.attr('data-i18n', 'amp.dashboard:chart-heatmap-totals');

        		// Columns container.
        		var xAxisLabelsContainer = svg
        			.append("g")
        			.attr("transform", "translate(18.5, -5)")
        			.attr("class", "heatmap-xAxis-container");

        		// Columns
        		// Notice in transform functions the order is very important if you have to apply more than one, like translate and rotate.
        		// cubeSize is where we define how big are the cubes so if we change it in the future the chart will resize correctly.
        		var xAxisLabels = xAxisLabelsContainer
        			.selectAll(".xLabel")
        			.data(data[0].values.x)
        			.enter()
        			.append("text")
        			.text(function(d) {
        				return shortenText(d, newShortTextLength);
        			})
        			.attr("x", function(d, i) {
        				return i * cubeSize;
        			})
        			.attr("y", 0)
        			.attr("transform", function(d, i) {
        				return "rotate(270, " + (cubeSize * i) + ", 0)";
        			})
        			.attr("class", function(d, i) {
        							return "xLabel mono axis nv-series";
        			})
        			.attr('data-title', function(d) {
        				return d;
        			});
        		
        		// Add Totals special column.
        		xAxisLabelsContainer.append("text")
        			.text("TOTALS")
        			.attr("x", cubeSize * data[0].values.x.length)
        			.attr("y", 0)
        			.attr("class", "xLabel mono axis nv-series heatmap-totals")
        			.style("font-weight", "bold")
            		.attr("transform", function(d, i) {
        				return "rotate(270, " + (cubeSize * data[0].values.x.length) + ", 0)";
        			})
        			.attr('data-i18n', 'amp.dashboard:chart-heatmap-totals');

        		// Cubes
        		var cubesContainer = svg
    				.append("g")
    				.attr("class", "heatmap-cubes-container");
        		for (var i = 0; i < data[0].values.length; i++) {
        			createCube(cubesContainer, $.extend(data[0].values[i], {tooltip: selectedCurrency + ' ' + data[0].values[i].amount}), cubeSize, noColor, categories);        			    				
        		}        
        		// Add total's row in the end.        		
        		for (var i = 0; i < data[0].values.x.length; i++) {
        			createCube(cubesContainer, {x: i + 1, y: data[0].values.y.length + 1, value: data[0].values.xPTotals[i], tooltip: selectedCurrency + ' ' + data[0].values.xTotals[i]}, cubeSize, noColor, categories);
        		}
        		// Add total's column on the right side.
        		for (var j = 0; j < data[0].values.y.length; j++) {
        			createCube(cubesContainer, {x: data[0].values.x.length + 1 , y: j + 1, value: data[0].values.yPTotals[j], tooltip: selectedCurrency + ' ' + data[0].values.yTotals[j]}, cubeSize, noColor, categories);
        		}
        		
        		// Add percentage legends.
        		createLegends(svg, data, cubeSize, categories, legendElementHeight);
        		
        		app.translator.translateDOM(svg[0]);
        		
        		// Recalculate margins if we are showing the full legends.
            	if (data[0].values.model.get('showFullLegends')) {        		
            		var top = svg.select('.heatmap-xAxis-container').node().getBBox().height;
            		var left = svg.select('.heatmap-yAxis-container').node().getBBox().width + 25;
            		svg.attr("transform", "translate(" + left + "," + top + ")");
            	}
        });
        
        renderWatch.renderEnd('heatmap immediate');
        return chart;
    }
    
    function getCategoriesByThreshold(noColor, model) {
    	var categories = new Array();
    	categories.push({min: -1, max: 0, color: noColor});
    	var colors = model.get('heatmap_config').models[0].get('amountColors');
    	var i = 1;
    	for (var property in colors) {
    	    if (colors.hasOwnProperty(property)) {
    	    	categories.push({min: parseInt(property), color: colors[property], max: null});
    	    	if (i > 1) {
    	    		categories[i - 1].max = parseInt(property);
    	    	}
    	    	i++;
    	    }
    	}
    	categories[i - 1].max = 101;
    	return categories;
    }
    
    function createLegends(svg, data, cubeSize, categories, legendElementHeight) {
    	var legendsContainer = svg
			.append("g")
			.attr("transform", "translate(0, " + (((data[0].values.y.length + 1) * cubeSize) + 10) + ")")
			.attr("class", "heatmap-legends-container");
    	var legendsPool = [app.translator.translateSync("amp.dashboard:chart-heatmap-legend-less-than") + " " + categories[1].max + "%",
    	                   app.translator.translateSync("amp.dashboard:chart-heatmap-legend-between") + " " + categories[2].min + "% " + app.translator.translateSync("amp.dashboard:chart-heatmap-legend-and") + " <" + categories[2].max + "% ",
    	                   app.translator.translateSync("amp.dashboard:chart-heatmap-legend-between") + " " + categories[3].min + "% " + app.translator.translateSync("amp.dashboard:chart-heatmap-legend-and") + " <" + categories[3].max + "% ",
    	                   app.translator.translateSync("amp.dashboard:chart-heatmap-legend-between") + " " + categories[4].min + "% " + app.translator.translateSync("amp.dashboard:chart-heatmap-legend-and") + " <" + categories[4].max + "% ",
    	                   app.translator.translateSync("amp.dashboard:chart-heatmap-legend-between") + " " + categories[5].min + "% " + app.translator.translateSync("amp.dashboard:chart-heatmap-legend-and") + " <" + categories[5].max + "% ",
    	                   app.translator.translateSync("amp.dashboard:chart-heatmap-legend-more-than") + " " + categories[6].min + "%"];
    	var maxLegendTextWidth = 0;
    	for (var i = 0; i < legendsPool.length; i++) {
    		var auxWidth = calculateTextWidth(legendsPool[i]);
    		if (auxWidth > maxLegendTextWidth) {
    			maxLegendTextWidth = auxWidth;
    		}
    		$("#tempSpan").remove();
    	}
    	maxLegendTextWidth += 20;
    	
    	for (var i = 0; i < legendsPool.length; i++) {
    		var legends = legendsContainer
				.append("rect")
				.attr("x", (i * maxLegendTextWidth))
				.attr("width", maxLegendTextWidth)
				.attr("height", legendElementHeight)
				.attr("class", "bordered")
				.style("fill", categories[i + 1].color);
		
			var text = legendsContainer.append("text"); 
			text.attr('font-family', 'Arial')
				.attr('font-size', '11px')
				.attr("y", 15)
				.attr("x", ((i * maxLegendTextWidth) + ((maxLegendTextWidth - calculateTextWidth(legendsPool[i])) / 2)))
				.text(legendsPool[i]); // Why "text" instead of "html", because it doesnt work on IE.
    	}
    	
    	legendsContainer.append("text")
			.text("LEGENDS")
			.attr("x", -6)
			.attr("y", 15)
			.attr("class", "yLabel mono axis nv-series heatmap-totals")
			.style("text-anchor", "end")
			.style("font-weight", "bold")
			.attr('data-i18n', 'amp.dashboard:chart-heatmap-legends');
    }
    
    function createCube(cubesContainer, data, cubeSize, noColor, categories) {
    	var selfData = data;
    	var cube = cubesContainer
			.append("rect")
			.attr("x", ((data.x - 1) * cubeSize))
			.attr("y", ((data.y - 1) * cubeSize))
			.attr("rx", 4)
			.attr("ry", 4)
			.attr("class", "bordered")
			.attr("width", cubeSize)
			.attr("height", cubeSize)
			.style("fill", noColor)
			.attr("data-x", data.x - 1)
			.attr("data-y", data.y - 1);
		
		cube.transition()
			.duration(1000)
			.style("fill", calculateColorFromCategories(data.value, categories, noColor));
		
		var text = cubesContainer.append("text"); 
		text.attr('font-family', 'Arial')
			.attr('font-size', '11px')
			.attr("x", ((data.y - 1) * cubeSize))
			.attr("y", ((data.y - 1) * cubeSize) + 19)
			.attr("class", "heatmap-cell")
			.attr("x", function() {
				// The "offsets" we add on each return call are tied to the current font family and size, so if we change them we might need to change the offsets too.
				var d = data;
				var auxVal = d.value;
				if (auxVal > 0 && auxVal < 1) {
					return ((d.x - 1) * cubeSize) + 4;
				} else if (auxVal < 10) {
					return ((d.x - 1) * cubeSize) + 8;
				} else if (auxVal == 100) {
					return ((d.x - 1) * cubeSize) + 1;	
				} else {
					return ((d.x - 1) * cubeSize) + 5;
				}					
			}).text(function() {
				// Cant use "html" function on IE.
				var d = data;
				var auxVal = d.value;
				if (auxVal > -1) {
					if (auxVal > 0 && auxVal < 1) {
						return '<1%';
					} else {
						return auxVal + '%';
					}
				} else {
					return '';
				}
			})
			.on("click", function(obj) {				
				// Remove all filters applied.
				$($(cubesContainer[0]).find("rect")).removeAttr("filter");
				// Apply "darken" to the row and column.		
				$($(cubesContainer[0]).find("[data-x='"+ (selfData.x - 1) + "']")).attr("filter", "url(#filterDarken)");
				$($(cubesContainer[0]).find("[data-y='"+ (selfData.y - 1) + "']")).attr("filter", "url(#filterDarken)");
				// Highlight this cell.
				$($(cubesContainer[0]).find("[data-y='"+ (selfData.y - 1) + "']" + "[data-x='"+ (selfData.x - 1) + "']")).removeAttr("filter");
			});
		
		if (data.tooltip) {
			text.attr('data-title', data.tooltip)
				.attr("class", "nv-series heatmap-cell");
		}
    }
       
    function calculateColorFromCategories(value, categories, noColor) {
    	var color = noColor;
    	for (var i = 0; i < categories.length; i++) {
    		if ((value >= categories[i].min) && (value < categories[i].max)) {
    			color = categories[i].color;
    			break;
    		}
    	}
    	return color;
    }
    
    function calculateTextWidth(text) {
    	$("body").append("<span id='tempSpan' class='invisible'>" + text + "</span>");
    	var auxWidth = $("#tempSpan").width();
    	$("#tempSpan").remove();
    	return auxWidth;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.legend = {};
    chart.dispatch = dispatch;
    chart.heatmap = heatmap;
    chart.options = nv.utils.optionsFunc.bind(chart);
    chart.shortTextLength = function(_) {
        return shortTextLength;
    };

    // use Object get/set functionality to map between vars and chart functions
    chart._options = Object.create({}, {    	
        // simple options, just get/set the necessary values
        noData:         {get: function(){return noData;},         set: function(_){noData=_;}},
        defaultState:   {get: function(){return defaultState;},   set: function(_){defaultState=_;}},
        // options that require extra logic in the setter
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }},
        color: {},
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        tooltipContent: {}
    });
    
    chart.height = function(_) {
        if (!arguments.length) return height;
        height = _;
        return chart;
    };
    
    nv.utils.inheritOptions(chart, heatmap);
    nv.utils.initOptions(chart);
    return chart;
};
},{"underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\customized\\multiBarChart.js":[function(require,module,exports){

nv.models.customizedMultiBarChart = function() {
  "use strict";
  //============================================================
  // Public Variables with Default Settings
  //------------------------------------------------------------

  var multibar = nv.models.multiBar()
    , xAxis = nv.models.axis()
    , yAxis = nv.models.axis()
    , legend = nv.models.legend()
    , controls = nv.models.legend() //this isn't exposed by default :(
    ;

  var margin = {top: 30, right: 20, bottom: 50, left: 60}
    , width = null
    , height = null
    , color = nv.utils.defaultColor()
    , showControls = true
    , showLegend = true
    , showXAxis = true
    , showYAxis = true
    , rightAlignYAxis = false
    , reduceXTicks = true // if false a tick will show for every data point
    , staggerLabels = false
    , rotateLabels = 0
    , tooltips = true
    , tooltip = function(key, x, y, e, graph) {
      return '<h3>' + key + '</h3>' +
        '<p>' +  y + ' on ' + x + '</p>'
    }
    , x //can be accessed via chart.xScale()
    , y //can be accessed via chart.yScale()
    , state = { stacked: false }
    , defaultState = null
    , noData = "No Data Available."
    , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState')
    , controlWidth = function() { return showControls ? 300 : 0 } /*Increased from 180 in original file.*/
    , transitionDuration = 250
    ;

  multibar
    .stacked(false)
  ;
  xAxis
    .orient('bottom')
    .tickPadding(7)
    .highlightZero(true)
    .showMaxMin(false)
    .tickFormat(function(d) { return d })
  ;
  yAxis
    .orient((rightAlignYAxis) ? 'right' : 'left')
    .tickFormat(d3.format(',.1f'))
  ;

  controls.updateState(false);
  //============================================================


  //============================================================
  // Private Variables
  //------------------------------------------------------------

  var showTooltip = function(e, offsetElement) {
    var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
      top = e.pos[1] + ( offsetElement.offsetTop || 0),
      x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)),
      y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)),
      content = tooltip(e.series.key, x, y, e, chart);

    nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
  };

  //============================================================


  function chart(selection) {
    selection.each(function(data) {
      var container = d3.select(this),
        that = this;

      var availableWidth = (width  || parseInt(container.style('width')) || 960)
          - margin.left - margin.right,
        availableHeight = (height || parseInt(container.style('height')) || 400)
          - margin.top - margin.bottom;

      try{
        if(data[0].values[0].x.length > 4){
        	//margin.bottom += 130;
        	margin.bottom = 130;
        }
      }catch(e){}

      chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
      chart.container = this;

      //set state.disabled
      state.disabled = data.map(function(d) { return !!d.disabled });

      if (!defaultState) {
        var key;
        defaultState = {};
        for (key in state) {
          if (state[key] instanceof Array)
            defaultState[key] = state[key].slice(0);
          else
            defaultState[key] = state[key];
        }
      }
      //------------------------------------------------------------
      // Display noData message if there's nothing to show.

      if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
        var noDataText = container.selectAll('.nv-noData').data([noData]);

        noDataText.enter().append('text')
          .attr('class', 'nvd3 nv-noData')
          .attr('dy', '-.7em')
          .style('text-anchor', 'middle');

        noDataText
          .attr('x', margin.left + availableWidth / 2)
          .attr('y', margin.top + availableHeight / 2)
          .text(function(d) { return d });

        return chart;
      } else {
        container.selectAll('.nv-noData').remove();
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Scales

      x = multibar.xScale();
      y = multibar.yScale();

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup containers and skeleton of chart

      var wrap = container.selectAll('g.nv-wrap.nv-multiBarWithLegend').data([data]);
      var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarWithLegend').append('g');
      var g = wrap.select('g');

      gEnter.append('g').attr('class', 'nv-x nv-axis');
      gEnter.append('g').attr('class', 'nv-y nv-axis');
      gEnter.append('g').attr('class', 'nv-barsWrap');
      gEnter.append('g').attr('class', 'nv-legendWrap');
      gEnter.append('g').attr('class', 'nv-controlsWrap');

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Legend

      if (showLegend) {
        legend.width(availableWidth - controlWidth());

        if (multibar.barColor())
          data.forEach(function(series,i) {
            series.color = d3.rgb('#ccc').darker(i * 1.5).toString();
          })

        g.select('.nv-legendWrap')
          .datum(data)
          .call(legend);

        if ( margin.top != legend.height()) {
          margin.top = legend.height();
          availableHeight = (height || parseInt(container.style('height')) || 400)
            - margin.top - margin.bottom;
        }

        g.select('.nv-legendWrap')
          .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');
      }

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Controls

      var groupedLegendTrn = app.translator.translateSync("amp.dashboard:filters-chart-legends-Grouped","Grouped");
      var stackedLegendTrn = app.translator.translateSync("amp.dashboard:filters-chart-legends-Stacked","Stacked");
      if (showControls) {
        var controlsData = [
          { key: groupedLegendTrn, disabled: multibar.stacked() },
          { key: stackedLegendTrn, disabled: !multibar.stacked() }
        ];

        controls.width(controlWidth()).color(['#444', '#444', '#444']);
        g.select('.nv-controlsWrap')
          .datum(controlsData)
          .attr('transform', 'translate(0,' + (-margin.top) +')')
          .call(controls);
      }

      //------------------------------------------------------------


      wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      if (rightAlignYAxis) {
        g.select(".nv-y.nv-axis")
          .attr("transform", "translate(" + availableWidth + ",0)");
      }

      //------------------------------------------------------------
      // Main Chart Component(s)

      multibar
        .disabled(data.map(function(series) { return series.disabled }))
        .width(availableWidth)
        .height(availableHeight)
        .color(data.map(function(d,i) {
          return d.color || color(d, i);
        }).filter(function(d,i) { return !data[i].disabled }))


      var barsWrap = g.select('.nv-barsWrap')
        .datum(data.filter(function(d) { return !d.disabled }))

      barsWrap.transition().call(multibar);

      //------------------------------------------------------------


      //------------------------------------------------------------
      // Setup Axes

      if (showXAxis) {
        xAxis
          .scale(x)
          .ticks( availableWidth / 100 )
          .tickSize(-availableHeight, 0);

        g.select('.nv-x.nv-axis')
          .attr('transform', 'translate(0,' + y.range()[0] + ')');
        g.select('.nv-x.nv-axis').transition()
          .call(xAxis);

        var xTicks = g.select('.nv-x.nv-axis > g').selectAll('g');

        xTicks
          .selectAll('line, text')
          .style('opacity', 1);

        try{
          if(data[0].values[0].x.length > 4){
            g.selectAll(".nv-x.nv-axis .nv-wrap g g text")
              .style("text-anchor", "end")
              .attr("dx", "-.8em")
              .attr("dy", ".15em")
              .attr("transform", "rotate(-65)" );
          }
        }catch(e){}

        if (staggerLabels) {
          var getTranslate = function(x,y) {
            return "translate(" + x + "," + y + ")";
          };

          var staggerUp = 5, staggerDown = 17;  //pixels to stagger by
          // Issue #140
          xTicks
            .selectAll("text")
            .attr('transform', function(d,i,j) {
              return  getTranslate(0, (j % 2 == 0 ? staggerUp : staggerDown));
            });

          var totalInBetweenTicks = d3.selectAll(".nv-x.nv-axis .nv-wrap g g text")[0].length;
          g.selectAll(".nv-x.nv-axis .nv-axisMaxMin text")
            .attr("transform", function(d,i) {
              return getTranslate(0, (i === 0 || totalInBetweenTicks % 2 !== 0) ? staggerDown : staggerUp);
            });
        }

        if (reduceXTicks)
          xTicks
            .filter(function(d,i) {
              return i % Math.ceil(data[0].values.length / (availableWidth / 100)) !== 0;
            })
            .selectAll('text, line')
            .style('opacity', 0);

        if(rotateLabels)
          xTicks
            .selectAll('.tick text')
            .attr('transform', 'rotate(' + rotateLabels + ' 0,0)')
            .style('text-anchor', rotateLabels > 0 ? 'start' : 'end');

        g.select('.nv-x.nv-axis').selectAll('g.nv-axisMaxMin text')
          .style('opacity', 1);
      }


      if (showYAxis) {
        yAxis
          .scale(y)
          .ticks( availableHeight / 36 )
          .tickSize( -availableWidth, 0);

        g.select('.nv-y.nv-axis').transition()
          .call(yAxis);
      }


      //------------------------------------------------------------



      //============================================================
      // Event Handling/Dispatching (in chart's scope)
      //------------------------------------------------------------

      legend.dispatch.on('stateChange', function(newState) {
        state = newState;
        dispatch.stateChange(state);
        chart.update();
      });

      controls.dispatch.on('legendClick', function(d,i) {
        if (!d.disabled) return;
        controlsData = controlsData.map(function(s) {
          s.disabled = true;
          return s;
        });
        d.disabled = false;

        switch (d.key) {
          case groupedLegendTrn:
            multibar.stacked(false);
            break;
          case stackedLegendTrn:
            multibar.stacked(true);
            break;
        }

        state.stacked = multibar.stacked();
        dispatch.stateChange(state);

        chart.update();
      });

      dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e, that.parentNode)
      });

      // Update chart from a state object passed to event handler
      dispatch.on('changeState', function(e) {

        if (typeof e.disabled !== 'undefined') {
          data.forEach(function(series,i) {
            series.disabled = e.disabled[i];
          });

          state.disabled = e.disabled;
        }

        if (typeof e.stacked !== 'undefined') {
          multibar.stacked(e.stacked);
          state.stacked = e.stacked;
        }

        chart.update();
      });

      //============================================================


    });

    return chart;
  }


  //============================================================
  // Event Handling/Dispatching (out of chart's scope)
  //------------------------------------------------------------

  multibar.dispatch.on('elementMouseover.tooltip', function(e) {
    e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
    dispatch.tooltipShow(e);
  });

  multibar.dispatch.on('elementMouseout.tooltip', function(e) {
    dispatch.tooltipHide(e);
  });
  dispatch.on('tooltipHide', function() {
    if (tooltips) nv.tooltip.cleanup();
  });

  //============================================================


  //============================================================
  // Expose Public Variables
  //------------------------------------------------------------

  // expose chart's sub-components
  chart.dispatch = dispatch;
  chart.multibar = multibar;
  chart.legend = legend;
  chart.controls = controls;
  chart.xAxis = xAxis;
  chart.yAxis = yAxis;

  d3.rebind(chart, multibar, 'x', 'y', 'xDomain', 'yDomain', 'xRange', 'yRange', 'forceX', 'forceY', 'clipEdge',
    'id', 'stacked', 'stackOffset', 'delay', 'barColor','groupSpacing');

  chart.options = nv.utils.optionsFunc.bind(chart);

  chart.margin = function(_) {
    if (!arguments.length) return margin;
    margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
    margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
    margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
    margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
    return chart;
  };

  chart.width = function(_) {
    if (!arguments.length) return width;
    width = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    height = _;
    return chart;
  };

  chart.color = function(_) {
    if (!arguments.length) return color;
    color = nv.utils.getColor(_);
    legend.color(color);
    return chart;
  };

  chart.showControls = function(_) {
    if (!arguments.length) return showControls;
    showControls = _;
    return chart;
  };

  chart.showLegend = function(_) {
    if (!arguments.length) return showLegend;
    showLegend = _;
    return chart;
  };

  chart.showXAxis = function(_) {
    if (!arguments.length) return showXAxis;
    showXAxis = _;
    return chart;
  };

  chart.showYAxis = function(_) {
    if (!arguments.length) return showYAxis;
    showYAxis = _;
    return chart;
  };

  chart.rightAlignYAxis = function(_) {
    if(!arguments.length) return rightAlignYAxis;
    rightAlignYAxis = _;
    yAxis.orient( (_) ? 'right' : 'left');
    return chart;
  };

  chart.reduceXTicks= function(_) {
    if (!arguments.length) return reduceXTicks;
    reduceXTicks = _;
    return chart;
  };

  chart.rotateLabels = function(_) {
    if (!arguments.length) return rotateLabels;
    rotateLabels = _;
    return chart;
  }

  chart.staggerLabels = function(_) {
    if (!arguments.length) return staggerLabels;
    staggerLabels = _;
    return chart;
  };

  chart.tooltip = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.tooltips = function(_) {
    if (!arguments.length) return tooltips;
    tooltips = _;
    return chart;
  };

  chart.tooltipContent = function(_) {
    if (!arguments.length) return tooltip;
    tooltip = _;
    return chart;
  };

  chart.state = function(_) {
    if (!arguments.length) return state;
    state = _;
    return chart;
  };

  chart.defaultState = function(_) {
    if (!arguments.length) return defaultState;
    defaultState = _;
    return chart;
  };

  chart.noData = function(_) {
    if (!arguments.length) return noData;
    noData = _;
    return chart;
  };

  chart.transitionDuration = function(_) {
    if (!arguments.length) return transitionDuration;
    transitionDuration = _;
    return chart;
  };

  //============================================================


  return chart;
}
},{}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\customized\\pieChart.js":[function(require,module,exports){

nv.models.customizedPieChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var pie = nv.models.pie();
    var legend = nv.models.legend().margin({top: 0, right: 0, bottom: 0, left: 0});

    var margin = {top: 30, right: 20, bottom: 20, left: 20}
    //var legendMargin = {top: 30, right: 20, bottom: 20, left: 20}
        , width = null
        , height = null
        , showLegend = true
        , color = nv.utils.defaultColor()
        , tooltips = true
        , tooltip = function(key, y, e, graph) {
            return '<h3 style="background-color: '
                + e.color + '">' + key + '</h3>'
                + '<p>' +  y + '</p>';
        }
        , state = nv.utils.state()
        , defaultState = null
        , noData = "No Data Available."
        , duration = 250
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState','renderEnd')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var tooltipLabel = pie.x()(e.point);
        var left = e.pos[0] + ( (offsetElement && offsetElement.offsetLeft) || 0 ),
            top = e.pos[1] + ( (offsetElement && offsetElement.offsetTop) || 0),
            y = pie.valueFormat()(pie.y()(e.point)),
            content = tooltip(tooltipLabel, y, e, chart)
            ;
        nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var renderWatch = nv.utils.renderWatch(dispatch);

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined) {
                data.forEach(function (series, i) {
                    series.disabled = !state.active[i];
                });
            }
        }
    };

    //============================================================
    // Chart function
    //------------------------------------------------------------

    function chart(selection) {
    	
        renderWatch.reset();
        renderWatch.models(pie);

        selection.each(function(data) {
            var container = d3.select(this);
            nv.utils.initSVG(container);

            var that = this;
            var availableWidth = (width || parseInt(container.style('width'), 10) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height'), 10) || 400)
                    - margin.top - margin.bottom
                ;

            chart.update = function() { container.transition().call(chart); };
            chart.container = this;

            state.setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            //set state.disabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-pieChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-pieChart').append('g');
            var g = wrap.select('g');

            var heightOffset = $($(container[0])[0]).find(".legend.nvd3-svg")[0].getBoundingClientRect().height;
            gEnter.append('g').attr('class', 'nv-pieWrap').attr('transform', 'translate(0,' + heightOffset + ')');
            gEnter.append('g').attr('class', 'nv-legendWrap');

            // Legend
            if (showLegend) {
                legend.width( availableWidth ).key(pie.x());

                wrap.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);
            }
            //wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Main Chart Component(s)
            pie.width(availableWidth).height(availableHeight);
            var pieWrap = g.select('.nv-pieWrap').datum([data]);
            d3.transition(pieWrap).call(pie);

            // Event Handling/Dispatching (in chart's scope)
            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState) {
                    state[key] = newState[key];
                }
                dispatch.stateChange(state);
                chart.update();
            });

            pie.dispatch.on('elementMouseout.tooltip', function(e) {
                dispatch.tooltipHide(e);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {
                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });
                    state.disabled = e.disabled;
                }
                chart.update();
            });

        });

        renderWatch.renderEnd('pieChart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    pie.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.legend = legend;
    chart.dispatch = dispatch;
    chart.pie = pie;
    chart.options = nv.utils.optionsFunc.bind(chart);

    // use Object get/set functionality to map between vars and chart functions
    chart._options = Object.create({}, {    	
        // simple options, just get/set the necessary values
        noData:         {get: function(){return noData;},         set: function(_){noData=_;}},
        tooltipContent: {get: function(){return tooltip;},        set: function(_){tooltip=_;}},
        tooltips:       {get: function(){return tooltips;},       set: function(_){tooltips=_;}},
        showLegend:     {get: function(){return showLegend;},     set: function(_){showLegend=_;}},
        defaultState:   {get: function(){return defaultState;},   set: function(_){defaultState=_;}},
        // options that require extra logic in the setter
        color: {get: function(){return color;}, set: function(_){
            color = _;
            legend.color(color);
            pie.color(color);
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }},
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        /*legendMargin: {get: function(){return legendMargin;}, set: function(_){
        	legendMargin.top    = _.top    !== undefined ? _.top    : legendMargin.top;
        	legendMargin.right  = _.right  !== undefined ? _.right  : legendMargin.right;
        	legendMargin.bottom = _.bottom !== undefined ? _.bottom : legendMargin.bottom;
        	legendMargin.left   = _.left   !== undefined ? _.left   : legendMargin.left;
        }},*/
    });
    
    nv.utils.inheritOptions(chart, pie);
    nv.utils.initOptions(chart);
    return chart;
};
},{}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\check-support.js":[function(require,module,exports){
function queryselector() {
  return !!document.querySelector;  // fails on oooooooooold IE
}


function svg() {
  try {
    document.createElementNS('http://w3.org/2000/svg', 'svg');
    return true;
  } catch (err) { return false; }
}


function canvas() {
  return !!document.createElement('canvas').getContext;
}


function canvasText() {
  if (!canvas()) { return false; }
  var textFn = document.createElement('canvas').getContext('2d').fillText;
  return (typeof textFn === 'function');
}


var isIE = (function() {
  // http://stackoverflow.com/a/2401861/1299695
  // Magic. Do not touch.
  var yesItIs = !!(function() {
    var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (/trident/i.test(M[1])) {
      tem =  /\brv[ :]+(\d+)/g.exec(ua) || [];
      return 'MSIE ' + (tem[1] || '');
    }
    if (M[1] === 'Chrome') {
      tem = ua.match(/\bOPR\/(\d+)/);
      if (!!tem) { return 'Opera ' + tem[1]; }
    }
    M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
    if ((tem = !!ua.match(/version\/(\d+)/i))) { M.splice(1, 1, tem[1]); }
    return M.join(' ');
  })().match(/^MSIE/);

  return function() { return yesItIs; };
})();


function dataURLHref() {
  // I don't know how to feature-detect this :(
  // we will be optimisitic an only say "no" if we see IE.
  return !isIE();
}


function flash() {
  // http://stackoverflow.com/a/20095467/1299695
  // gross...
  try {
    return !!(new ActiveXObject('ShockwaveFlash.ShockwaveFlash')); // jshint ignore:line
  } catch (e) {
    return navigator.mimeTypes &&
      navigator.mimeTypes['application/x-shockwave-flash'] !== void 0 &&
      navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin;
  }
}


module.exports = function() {
  var missingFeatures = [];  // an empty array will cast to bool false. handy!

  if (!queryselector()) {
    missingFeatures.push({
      feature: 'querySelector',
      severity: 'critical'
    });
  }

  if (!svg()) {
    missingFeatures.push({
      feature: 'SVG',
      severity: 'critical'
    });
  }

  if (!canvasText()) {
    missingFeatures.push({
      feature: 'canvas',
      severity: 'major'
    });
  }

  if (!dataURLHref()) {
    missingFeatures.push({
      feature: 'download',
      severity: flash() ? 'minor' : 'major'
    });
  }

  if (!flash()) {
    missingFeatures.push({
      feature: 'flash',
      severity: isIE() ? 'major' : 'minor'
    });
  }

  return missingFeatures;
};

},{}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\amp-user.js":[function(require,module,exports){
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
  url: '/rest/security/layout',

  /************
   * email is null from server when not logged in or when workspace not set yet.
   * Before it is fetched, default to undefined.
   */
  defaults: {
    email: undefined
  },
  fetch: function(options) {
    options = options || {};
    options.cache = false;
    return Backbone.Model.prototype.fetch.call(this, options);
  }


});

},{"backbone":"backbone"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-aid-predictability.js":[function(require,module,exports){
var _ = require('underscore');
var ChartModel = require('./chart-model-base');


module.exports = ChartModel.extend({
	

	defaults : {
		title : '',
		showPlannedDisbursements: true,
		showActualDisbursements: true,
		chartType: 'aidPredictability'
	},

  _prepareTranslations: function() {
    var self = this;
    var predictabilityBaseLanguage = {};

    /* Prepare the translations for the chart */
    predictabilityBaseLanguage['amp.dashboard:aid-predictability-planned-disbursements'] = 'Planned Disbursements';
    predictabilityBaseLanguage['amp.dashboard:aid-predictability-actual-disbursements'] = 'Actual Disbursements';

    this.localizedPredictability = this.app.translator.translateList(predictabilityBaseLanguage).then(
      function(localizedPredictabilityList) {
        self.localizedPredictabilityList = localizedPredictabilityList;
      });
  },

  parse: function(data) {
	this.set('title', data.title);	
	if(!_.isUndefined(data.showPlannedDisbursements)){
		this.set('showPlannedDisbursements', data.showPlannedDisbursements);
	}
	if(!_.isUndefined(data.showActualDisbursements)){
		this.set('showActualDisbursements', data.showActualDisbursements);
	}	
	
    function pick(which) {
      return function(d) {
        return {
          x: d.year,
          y: d[which]['amount'],
          z: d[which]['formattedAmount']
        };
      };
    }
    /* returns from map() like [{amp.gis:title-Region: 'Region'}, ... ]*/

    data.processed = [
      {
        key: this.localizedPredictabilityList['amp.dashboard:aid-predictability-planned-disbursements'],
        originalKey: 'planned',
        values: _(data.years).map(pick('planned disbursements')),
        disabled: !this.get('showPlannedDisbursements')
      },
      {
        key: this.localizedPredictabilityList['amp.dashboard:aid-predictability-actual-disbursements'],
        originalKey: 'actual',
        values: _(data.years).map(pick('actual disbursements')),
        disabled: !this.get('showActualDisbursements')
      }
    ];
    return data;
  }

});

},{"./chart-model-base":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-model-base.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-funding-type.js":[function(require,module,exports){
var _ = require('underscore');
var ChartModel = require('./chart-model-base');
var common = require('../charts/common');

module.exports = ChartModel.extend({

  defaults: {
    typed: true,
    limit: 3,
    title: '',
    stacked: false,
    seriesToExclude: [],
    yearTotals:{},
    chartType: 'fundingType'
  },

  _prepareTranslations: function() {
    var self = this;
    var ftypeBaseLanguage = {};

    /* Prepare the translations for the chart */
    var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');

    /*
     * TODO: load all the localizations in this chart's namespace to this array
     * from initial-translation-request.json -- For now just hardcode the two sorts.
     */
    if (this.get('name') === 'Funding Type') {
      ftypeBaseLanguage[chartName + 'Grant'] = 'Grant';
      ftypeBaseLanguage[chartName + 'Loan'] = 'Loan';
      ftypeBaseLanguage[chartName + 'others'] = 'Others';
    }

    this.localizedFType = this.app.translator.translateList(ftypeBaseLanguage).then(
      function(localizedKeyVal) {
        self.localizedLookup = localizedKeyVal;
      });
  },

  parse: function(data) {
	this.set('title', data.title);
	
    var self = this;
    var years;
    if (data.values.length > 0 && !isNaN(parseInt((data.values)[0].Year, 10))) {
      years = _.sortBy(data.values, function(obj) { return parseInt(obj.Year, 10); });
    } else {
      years = _(data.values).sortBy('Year');
    }

    var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');
    var localizedOthers = self.localizedLookup[chartName + 'others'];

    // reformat the data for nvd3
    data.processed = _(years)
      .chain()
      .reduce(function(series, year) {
        series.push.apply(series, _(year.values).pluck('type'));
        return series;
      }, [])
      .uniq()
      .map(function(s) {
        var cleanName = s.replace(/[ :.]/g, '');
        var localizedName = s;
        if (self.localizedLookup[chartName + cleanName]) {
          localizedName = self.localizedLookup[chartName + cleanName];
        }
        return {
          key: localizedName,
          values: _(years).map(function(y) {
            var yearValue = _(y.values).findWhere({type: s});
            return {
              x: y.Year,
              y: yearValue && yearValue.amount || 0,
              z: yearValue && yearValue.formattedAmount || 0,
            };
          }),
          disabled: (_.indexOf(self.get('seriesToExclude'),localizedName) != -1)
        };
      })
      .value();
    
 
	
    // group smallest contributors as "other"s
    if (this.get('limit') < data.processed.length) {
    	// Summarize each funding type and sort by total descending, create a new array only with funding types names.
    	var othersNames = _(data.processed)
	        .chain()
	        .map(function(series) {
	        	return {
	        		key: series.key,
		        	total: _(series.values).reduce(function(t, v) { return t + v.y; }, 0)
		        };
	        })
	        .sortBy('total')
	        .reverse()
	        .rest(this.get('limit'))
	        .pluck('key')
	        .value();

    	// Create a new array from the original data but only with the funding types from 'Others' category.
    	var othersSeriesValues = _(data.processed).filter(function(series) { return _(othersNames).contains(series.key); })
    	var sortedOthersSeriesValues = [];
    	
    	// Sort 'othersSeriesValues' by the values from 'othersNames' 
    	// (if we dont do this step then we will 'extract' the wrong funding type when clicking 'Others').
    	othersNames.forEach(function(key) {
    		var found = false;
    		othersSeriesValues = othersSeriesValues.filter(function(item) {
    	        if(!found && item.key === key) {
    	        	sortedOthersSeriesValues.push(item);
    	            found = true;
    	            return false;
    	        } else 
    	            return true;
    	    })
    	});
    	
    	// Summarize all funding types (from 'Others') by year.
    	othersSeriesValues = _(sortedOthersSeriesValues)
	    	.chain()
	    	.map(function(series) { return series.values; })
	        .transpose()
	        .map(function(othersYear) {
	            return {
	            	x: othersYear[0].x,
	            	y: _(othersYear).reduce(function(t, s) { return t + s.y; }, 0),
	            	z: ''
	            };
	        })
	        .map(function(item) {
	        	return {
	        		x: item.x,
	        		y: item.y,
	        		z: common.formatNumber(item.y /** parseFloat(app.settings.numberMultiplier.name)*/)
	        	};
	        })
	        .value()
	    
	    var othersSeries = { 
	        key: localizedOthers,
	        color: '#777',
	        special: 'others',
	        disabled: (_.indexOf(self.get('seriesToExclude'), localizedOthers) != -1),
	        values: othersSeriesValues
	    };
    	    	// Remove from the original data the funding types we grouped in 'Others' (cant use slice because the sorting in 'data.processed' is different).
    	data.processed = _(data.processed).filter(function(item) {return !_(othersNames).contains(item.key)});
    	data.processed.push(othersSeries);
    }
    
    var yearTotals = {};
	_.each(data.processed, function(d){
		_.each(d.values, function(value){
			yearTotals[value.x] = (yearTotals[value.x] || 0) + value.y;
		});    		
	});
	
	this.set('yearTotals', yearTotals);

    return data;
  }

});

},{"../charts/common":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\common.js","./chart-model-base":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-model-base.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-heatmaps.js":[function(require,module,exports){
var param = require('jquery').param;
var _ = require('underscore');
var ChartModel = require('./chart-model-base');
var common = require('../charts/common');

module.exports = ChartModel.extend({

	defaults: {
	    xLimit: 30, //This is the max number of elements we will see in the x axis.
	    yLimit: 10, //This is the max number of elements we will see in the y axis.  
	    originalYLimit: 10, //This is the original max number of elements for the y axis (used to revert "others").
	    title: '',
	    name: '',
	    bigN: 0,
	    alternativeContainerClass: 'heatmap-chart-wrap',
	    values: [],
	    chartType: 'fragmentation',
	    swapAxes: false,
	    heatmap_type: null,
	    showResetButton: false,
	    showFullLegends: false
	},

	_prepareTranslations: function() {
		var topBaseLanguage = {};

	    /* Prepare the translations for the chart */
	    var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');
	
	    this.localizedTopChart = this.app.translator.translateList(topBaseLanguage)
	    	.done(_(function(localizedTopChartKeyVal) {
	    		this.localizedLookup = localizedTopChartKeyVal;
	    	}).bind(this));
	},

	parse: function (data) {
		var self = this;
		self.values = new Array();
		if (_.isUndefined(data.xDataSet) || _.isUndefined(data.yDataSet)) {
			// The EP for heatmaps is different than the other charts because it returns an empty object, so we set explicitly some fields to empty value. 
			data.yDataSet = [];
			data.xDataSet = [];
			data.matrix = [];
			data.xTotals = 0;
			data.yTotals = 0;
			data.xCount = 0;
			data.yCount = 0;
			data.xTotalCount = 0;
			data.yTotalCount = 0;
		}		
		self.values.x = data.xDataSet;
		self.values.y = data.yDataSet;
		for (var i = 0; i < data.yDataSet.length; i++) {
			for (var j = 0; j < data.xDataSet.length; j++) {
				if (data.matrix[i] !== null) {
					var value = data.matrix[i][j] !== null ? data.matrix[i][j] : {p: -1, amount: '0'};
					var row = {y: i + 1, x: j + 1, value: value.p, amount: value.dv/*, yname: data.yDataSet[i], xname: data.xDataSet[i]*/}; //name is for tooltip
					self.values.push(row);
				} else {
					self.values.push({y: i + 1, x: j + 1, value: -1, amount: "0"});
				}
			}
		}
				
		// Normalize values.
		self.values = this.normalizeValues(self.values);
		
		// Add totals data.
		self.values.xPTotals = this.normalizeValues(data.xPTotals);
		self.values.yPTotals = this.normalizeValues(data.yPTotals);
		self.values.xTotals = data.xTotals;
		self.values.yTotals = data.yTotals;
		self.values.xCount = data.xCount;
		self.values.yCount = data.yCount;
		self.values.xTotalCount = data.xTotalCount;
		self.values.yTotalCount = data.yTotalCount;	
		self.values.model = this;

		if (!this.localizedLookup) {
			// we can't procede if we don't have translations yet :(
			// this code should now be unreachable, but y'never know...
			this.app.report('Loading error', ['Translations for the application were not loaded before rendering']);
		}
		var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');

		data.processed = [{values: this.values}];
		data.values = this.values;
		
		if (data.yCount > this.get('originalYLimit') + 1) {
			this.set('showResetButton', true);
		} else {
			this.set('showResetButton', false);
		}
		
		return data;
	},
	
	normalizeValues: function(values) {
		if (_.isUndefined(values) === false) {
			for (var i = 0; i < values.length; i++) {
				var auxValue = values[i].value !== undefined ? values[i].value : values[i];
				if (auxValue > 0 && auxValue < 1) {
					//Do nothing;
				} else {
					if (values[i].value !== undefined) {
						values[i].value = Math.floor(auxValue);
					} else {
						values[i] = Math.floor(auxValue);
					}
				}
			}
		}
		return values;
	},

	fetch: function(options) {
		var self = this;
		options = _.defaults(options || {}, { url: this.url });
		
		// Process params from heat-map/configs, in that EP we have defined each heatmap.
		var configs = this.get('heatmap_config').models[0];
		var thisChart = _.find(configs.get('charts'), function(item) {return item.name === self.get('name')});
		var xColumn = self.get('xAxisColumn') !== '' ? self.get('xAxisColumn') : configs.get('columns')[thisChart.xColumns[0]].origName; // First column is default.
		var yColumn = configs.get('columns')[thisChart.yColumns[0]].origName; // First column is default.
		
		// Check if we need to switch axis.
		if (self.get('swapAxes') === true) {
			var auxAxis = yColumn;
			yColumn = xColumn;
			xColumn = auxAxis;
		}
		
		var paramsForHeatMap = {xCount: self.get('xLimit'), xColumn: xColumn, yColumn: yColumn, yCount: self.get('yLimit')}; 		
		paramsForHeatMap.filters =  JSON.parse(options.data);
		options.data = JSON.stringify(paramsForHeatMap);

		return ChartModel.prototype.fetch.call(this, options);
	}
});
},{"../charts/common":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\common.js","./chart-model-base":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-model-base.js","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-model-base.js":[function(require,module,exports){
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');


module.exports = BackboneDash.Model.extend({

  defaults: {},

  initialize: function(attrs, options) {
    this.app = options.app;
    this.url = options.url;
    this._prepareTranslations();  // TODO: refactor this implementation into here
  },

  hasData: function() {
    return _(this.get('processed'))
      .chain()
      .pluck('values')
      .reduce(function(result, values) {
        return values.length && true || result;
      }, false)
      .value();
  },

  fetch: function(options) {
    var data = JSON.parse(options.data);
    data.settings = this.app.settings.toAPI();

    if (this.get('adjtype')) {
      // TODO adjtype hard-coding key for now, should get from settings...
      data.settings = _({}).extend(data.settings, {0: this.get('adjtype')});
    }

    options.data = JSON.stringify(data);
    return BackboneDash.Model.prototype.fetch.call(this, options);
  }

});

},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-tops.js":[function(require,module,exports){
var param = require('jquery').param;
var _ = require('underscore');
var ChartModel = require('./chart-model-base');
var common = require('../charts/common');


module.exports = ChartModel.extend({

  defaults: {
    limit: 5,
    title: '',
    bigN: 0,
    chartType: 'top'
  },

  _prepareTranslations: function() {
    var topBaseLanguage = {};

    /* Prepare the translations for the chart */
    var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');

    /*
     * TODO: load all the localizations in this chart's namespace to this array
     * from initial-translation-request.json -- For now just hardcode the two sorts.
     */
    if (this.get('name') === 'Top Regions') {
      topBaseLanguage[chartName + 'DistrictUndefined'] = 'Districts: Undefined';
    }
    topBaseLanguage[chartName + 'others'] = 'Others';

    this.localizedTopChart = this.app.translator.translateList(topBaseLanguage)
      .done(_(function(localizedTopChartKeyVal) {
        this.localizedLookup = localizedTopChartKeyVal;
      }).bind(this));
  },

  parse: function(data) {
	this.set('title', data.title);
	  
    if (!this.localizedLookup) {
      // we can't procede if we don't have translations yet :(
      // this code should now be unreachable, but y'never know...
      this.app.report('Loading error', [
      'Translations for the application were not loaded before rendering']);
    }

    var chartName = ['amp.dashboard:chart-', this.get('name').replace(/ /g, ''), '-'].join('');
    this.localizedOthers = this.localizedLookup[chartName + 'others'];
    if (this.localizedOthers === undefined) {
    	console.error('missing translation in .json file: ' + chartName + 'others');
    }

    var values = _(data.values.slice()).map(function(v) {
      var cleanName = v.name.replace(/[ :.]/g, '');
      var localizedName = v.name;
      if (this.localizedLookup[chartName + cleanName]) {
        localizedName = this.localizedLookup[chartName + cleanName];
      }

      return {
        x: localizedName,
        y: v.amount,
        z: v.formattedAmount,
        id: v.id
      };
    }, this);

    // make sure we don't have any duplicate keys... nvd3 pukes on those
    if (_(_(values).pluck('x')).uniq().length < values.length) {
      this.app.report('Data Error',
        ['The data for ' + this.get('name') + ' was inconsistent due to duplicate keys',
        'The chart will be shown, but it may have errors or other issues as a result.']);
    }

    if (data.maxLimit > values.length) {
    	var other = {
    			x: this.localizedOthers,
    			y: data.total -  // total minus the sum of what we have
                _.chain(values).pluck('y').reduce(function(l, r) { return l + r; }, 0).value(),
                color: '#777',
                special: 'others'
        };
        //AMP-18740: We changed the EP to send raw numbers expressed in units so we need to apply the GS here.
    	other.z = common.formatNumber(other.y * parseFloat(app.settings.numberMultiplier.name));
        values.push(other);
    }

    data.processed = [{values: values}];
    return data;
  },

  fetch: function(options) {
    options = _.defaults(
      options || {},
      { url: this.url + '?' + param(this.pick('limit')) });
    return ChartModel.prototype.fetch.call(this, options);
  }

});

},{"../charts/common":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\common.js","./chart-model-base":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-model-base.js","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\charts-collection.js":[function(require,module,exports){
var BackboneDash = require('../backbone-dash');


module.exports = BackboneDash.Collection.extend({
  initialize: function(models, options) {
    this.app = options.app;
  }
});

},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\enabled-charts-collection.js":[function(require,module,exports){
var Backbone = require('backbone');
var _ = require('underscore');

var EnabledChartModel = Backbone.Model.extend({

});

var EnabledChartsCollection = Backbone.Collection.extend({
	model : EnabledChartModel,
	url : '/rest/common/fm',
	fetchData : function() {
		var params = {
			"detail-modules" : [ "DASHBOARDS" ]
		};
		this.fetch({
			type : 'POST',
			async : false,
			processData : false,
			mimeType : 'application/json',
			traditional : true,
			headers : {
				'Content-Type' : 'application/json',
				'Cache-Control' : 'no-cache'
			},
			data : JSON.stringify(params), // This is necessary due to
											// incompatibilities with Jersey
											// when receiving the params.
			error : function(collection, response) {
				console.error('error loading charts.');
			},
			success : function(collection, response) {
				// console.log(response);
			}
		});
	}
});

module.exports = EnabledChartsCollection;
},{"backbone":"backbone","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\heatmaps-config-collection.js":[function(require,module,exports){
var Backbone = require('backbone');
var _ = require('underscore');

var HeatmapsConfigModel = Backbone.Model.extend({

});

var HeatmapsConfigCollection = Backbone.Collection.extend({
	model : HeatmapsConfigModel,
	url : '/rest/dashboard/heat-map/configs',
	fetchData : function() {
		this.fetch({
			type : 'GET',
			async : false,
			processData : false,
			mimeType : 'application/json',
			traditional : true,
			headers : {
				'Content-Type' : 'application/json',
				'Cache-Control' : 'no-cache'
			},
			data : JSON.stringify(), // This is necessary due to
											// incompatibilities with Jersey
											// when receiving the params.
			error : function(collection, response) {
				console.error('error loading heatmap configs.');
			},
			success : function(collection, response) {
				//console.log(response);
			}
		});
	}
});

module.exports = HeatmapsConfigCollection;
},{"backbone":"backbone","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\saved-dash.js":[function(require,module,exports){
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');


var API_ID_KEY = 'mapId';


module.exports = BackboneDash.Model.extend({

  defaults: {
    name: undefined,
    description: undefined,
    stateBlob: undefined
  },

  // parse and toJSON map the id field to mapId for the API.
  parse: function(obj) {
    if (_(obj).has(API_ID_KEY)) {
      obj.id = obj[API_ID_KEY];
      delete obj[API_ID_KEY];
    }
    return obj;
  },

  initialize: function(attrs, options) {
    this.app = options.app;
    this.url = options.url;
  },

  toJSON: function() {
    var copy = BackboneDash.Model.prototype.toJSON.apply(this, arguments);
    if (_(copy).has('id')) {
      copy[API_ID_KEY] = copy.id;
      delete copy.id;
    }
    return copy;
  }

}, {
  fromId: function(id, options) {
    return new this({ id: id }, options);
  }
});

},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\saved-dashes-collection.js":[function(require,module,exports){
var _ = require('underscore');
var Deferred = require('jquery').Deferred;
var BackboneDash = require('../backbone-dash');
var SavedChart = require('./saved-dash');


module.exports = BackboneDash.Collection.extend({

  url: '/rest/dashboard/saved-charts',

  model: SavedChart,
  timer: undefined,
  initializedOnce: false,

  initialize: function(models, options) {
    this.app = options.app;
  },

  load: function(stateId) {
	var self = this;
	if (self.initializedOnce !== false) { return; }
	self.initializedOnce = true;
	 
    var deferred = new Deferred();
    var loaded = this.get(stateId);
    if (loaded) {
      deferred.resolve(loaded);
    } else {
      var model = this.model.fromId(stateId, { app: this.app });
      this.add(model);  // sets up collection so the model can find a URL
      model.fetch().done(function() {
          deferred.resolve(model);
          
          // AMP-19803 and AMP-20206: Here we wait until the filter widget has been loaded to trigger the 'apply' event and force each chart to redraw with the saved filters.
	      // Tried to do something similar before we reach this stage (ie: in app-class.js, chart-view-base.js, charts.js, etc) but without luck because the render is triggered automatically.
	      // TODO: We need more time to evaluate a solution using this.app.filter.loaded promise but that didnt work consistently on IE.          
          if (self.timer === undefined) {
        	  self.timer = setInterval(function() {
		    	  if (this.app !== undefined && this.app.filter !== undefined && this.app.filter.finishedFirstLoad === true) {
		    		  clearInterval(self.timer);
		    		  this.app.filter.trigger('apply');			    		  
		    		  // Only make 1 render call to the main app view, this will prevent other bugs (ie: the double and triple chart rendering).
		    		  if (this.app.rendered === false) {
		    			  this.app.rendered = true;
		    			  app.render();
		    		  }
		    	  }
		      }, 100);
          }
        }).fail(_(function() {
          this.app.report('Failed to load saved dashboard', ['Could not retrieve the saved state.']);
          deferred.reject();
        }).bind(this));
    }

    return deferred.promise();
   }
});
},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","./saved-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\saved-dash.js","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\setting.js":[function(require,module,exports){
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');


module.exports = BackboneDash.Model.extend({

  initialize: function(attrs, options) {
    this.app = options.app;
    this.url = options.url;    
    var _self = this;
    // In "currencies" collection we add another field with the complete copy for future use. 
    if (this.originalAllCurrencies === undefined && attrs.id === '1') {
    	this.set('originalAllCurrencies', []);
    	_.each(attrs.options, function(item) {
    		// Need to copy one by one or this list will lose elements when changing calendars.
    		_self.get('originalAllCurrencies').push(item);
    	});
    }
  },

  select: function(optionId, triggerChange) {
	var self = this;
    // unselect old
    var old = _(this.attributes.options).findWhere({selected: true});
	if(old !== null && old !== undefined) {
		delete old.selected;
	}    
    // select new
    var newOpt = _(this.attributes.options).findWhere({id: optionId});
    if(newOpt !== undefined) {
    	newOpt.selected = true;
    } else {
    	// This can happen if we are loading a saved dashboard and the currency is loaded before the calendar.
    	if (this.attributes.id === "1") {
	    	newOpt = _(this.attributes.originalAllCurrencies).findWhere({id: optionId});
	    	if (newOpt !== undefined) {
	    		newOpt.selected = true;
	    	} else {
	    		console.info('Saved currency was deleted.');
	    		// Select default currency.
	    		newOpt = _(this.attributes.originalAllCurrencies).findWhere({id: _.find(self.app.settings.models, function(item) {return item.id === "1";}).get('defaultId')});
	    		newOpt.selected = true;
	    	}
    	}
    }

    // If we are changing the calendar --> Update list of currencies.
    if (this.attributes.id === "2") {
    	var currenciesForThisCalendar = _.find(_.find(self.app.settings.models, function(item) {return item.id === "calendarCurrencies";}).get('options'), function(item2) {return item2.id === optionId}).value.split(',');
    	var allCurrencies = _.find(self.app.settings.models, function(item) {return item.id === '1'});
    	// 'options' is linked to the calendar select, now we clean it one by one (assigning to [] will break the view).
    	for (var i = allCurrencies.get('options').length - 1; i >= 0; i--) {
    		allCurrencies.get('options').splice(i, 1);
    	}
    	// Match the currencies for this calendar with the list of all currencies.
    	_.each(currenciesForThisCalendar, function(item) {
    		var auxCurrency = _.find(allCurrencies.get('originalAllCurrencies'), function(item2) {
    			return item2.id === item;
    		});
    		if(auxCurrency !== undefined) {
    			allCurrencies.get('options').push(auxCurrency);
    		}
    	});
    	// Check if currently selected currency is still valid for the current calendar and make sure we always have a selected currency.
    	var selectedCurrency = _.find(allCurrencies.get('options'), function(item) {return item.selected === true});
    	if (selectedCurrency !== undefined) {
    		if (_.find(allCurrencies.get('originalAllCurrencies'), function(item) {return item.id === selectedCurrency.id}) === undefined) {
    			selectedCurrency.selected = false;
    			allCurrencies.get('options')[0].selected = true;
    		}
    	} else {
    		allCurrencies.get('options')[0].selected = true;
    	}
    }
    
    // Before linking calendar with currencies triggering 'change' was the default behavior.
    if (triggerChange === true) {
    	this.trigger('change');  // sort of a hack to do this manually...
    }
  },
  
  apply: function() {
	  this.trigger('change');
  }

});

},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\settings-collection.js":[function(require,module,exports){
var Deferred = require('jquery').Deferred;
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var Setting = require('./setting');


function isIntStr(n) {
  // test whether a string starts with is a base-10 int
  return !isNaN(parseInt(n, 10))
}


function tagIf(test, tag) {
  return function(setting) {
    if (test(setting)) {
      setting[tag] = true;
    }
    return setting;
  }
}


module.exports = BackboneDash.Collection.extend({

  url: '/rest/amp/settings',

  model: Setting,

  comparator: 'id',
  
  firstTime: true,

  initialize: function(models, options) {
    this.app = options.app;
    this._loaded = new Deferred();
    _.bindAll(this, 'toAPI', 'fromState');
  },

  parse: function(settings) {
	this.extractNumberFormatSettings(settings);
    return _(settings).chain()
      // mark weird options with non-int keys hidden
      .map(tagIf(function(setting) { return !isIntStr(setting.id); }, 'ignore'))
      // mark funding type setting hidden, since it's set per-chart...
      .map(tagIf(function(setting) { return setting.id === '0'; }, 'ignore'))
      // ...but also flag it so the charts can see the the funding type options
      .map(tagIf(function(setting) { return setting.id === '0'; }, 'ftype'))
      // mark all options as selected per the defaults provided
      .map(function(setting) {
        return _(setting).extend({
          options: _(setting.options).map(tagIf(function(option) {
            return option.id === setting.defaultId;
          }, 'selected'))
        })
      })
      .value();
  },

  load: function() {
	if(this.firstTime) {
		this.firstTime = false;
		
		if (this._loaded.state() !== 'pending') { return this._loaded.promise(); }

	    this.fetch({app: this.app })
	      .then(_(function() {
	        this._loaded.resolve();
	      }).bind(this))
	      .fail(_(function() {
	        this.app.report('Failed to load dashboard settings',
	          ['Could not connect to the server.']);
	        this._loaded.reject();
	      }).bind(this));
	}    
    return this._loaded.promise();
  },

  toAPI: function(overrides) {
    // format selected filter options the way the api wants
    // ignored filters are skipped (overrides are never removed though)
    // overrides should be in the {settingId: settingOptionId} format the api expects
    if (this.length === 0) { return {}; }  // cop out early if we don't have settings yet
    return this.chain()
      .map(function(model) { return model.toJSON(); })
      .filter(function(setting) { return !setting.ignore; })
      .reduce(function(apiFormatted, setting) {
        apiFormatted[setting.id] = _(setting.options)
          .findWhere({selected: true}).id;
        return apiFormatted;
      }, {})
      .extend(overrides || {})
      .value();
  },

  fromState: function(state) {
	  // Check if the saved calendar still exists.
	  if (state !== undefined) {
		  var savedCalendarId = _.find(state, function(item, key) {return key === "2"});  
		  var savedCalendar = _.find(_.find(this.models, function(item) {return item.id === "2"}).get("options"), function(item2) {return item2.id === savedCalendarId});
		  if (savedCalendar === undefined) {
			  // This calendar was deleted, select another.
			  state["2"] = _.find(this.models, function(item) {return item.id === "2"}).get("options")[0].id;
		  }
	  }
		  
	  // select options from an array with the same format we send to the api
	  _(state).each(function(optId, settingId) {
		  this.get(settingId).select(optId, true);
	  }, this);
  },

  getVisible: function() {
    return this.filter(function(setting) { return !setting.get('ignore'); });
  },
  
  extractNumberFormatSettings: function(settings) {
	  var numberFormat = {}; 
	  var foundNF =_.find(settings, function(item) {return item.id === 'number-format'});
	  numberFormat.numberFormat = _.find(foundNF.options, function(item) { return item.id === foundNF.defaultId}).name || '#,#.#';

	  // If the format pattern doesnt have thousands grouping then ignore 'number-group-separator' param or it will 
	  // be used by JS to group by thousands (ie: in the 'Others' columns).
	  if(numberFormat.numberFormat.indexOf(',') !== -1) {
		  var foundNGS =_.find(settings, function(item) {return item.id === 'number-group-separator'});
		  numberFormat.groupSeparator = _.find(foundNGS.options, function(item) { return item.id === foundNGS.defaultId}).name || ',';
	  } else {
		  numberFormat.groupSeparator = '';
	  }
	  var foundDS =_.find(settings, function(item) {return item.id === 'number-decimal-separator'});
	  numberFormat.decimalSeparator = _.find(foundDS.options, function(item) { return item.id === foundDS.defaultId}).name || '.';
	  this.app.settings.numberFormatSettings = numberFormat;
	  
	  var foundNM =_.find(settings, function(item) {return item.id === 'number-multiplier'});
	  this.app.settings.numberMultiplier = _.find(foundNM.options, function(item) { return item.id === foundNM.defaultId});
	  if (this.app.settings.numberMultiplier.name === '1.0') {
		  this.app.settings.numberMultiplierDescription = 'amp.dashboard:chart-tops-inunits';
	  } else if(this.app.settings.numberMultiplier.name === '0.001') {
		  this.app.settings.numberMultiplierDescription = 'amp.dashboard:chart-tops-inthousands';
	  } else {
		  this.app.settings.numberMultiplierDescription = 'amp.dashboard:chart-tops-inmillions';
	  }
  }

});
},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","./setting":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\setting.js","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-aid-predictability.js":[function(require,module,exports){
var d3 = require('d3');
var ChartViewBase = require('./chart-view-base');
var _ = require('underscore');


module.exports = ChartViewBase.extend({

  uiDefaults: {
    big: false,
    view: 'multibar',
    showTotal: true,
    showMeasuresSelector: true,
    showTopLegends: true,
    showCommonChartArea: true
  },
  events: function(){
      return _.extend({},ChartViewBase.prototype.events,{
          'click .nv-series' : 'changeChartColumns'
      });
  },  
  changeChartColumns: function(e){
	  var key = $(e.currentTarget).find('.nv-legend-text').text();
	  var plannedDisbursementTrn = app.translator.translateSync("amp.dashboard:aid-predictability-planned-disbursements","Planned Disbursements");
	  var actualDisbursementTrn = app.translator.translateSync("amp.dashboard:aid-predictability-actual-disbursements","Actual Disbursements");
	  if(key == plannedDisbursementTrn){
		  this.model.set('showPlannedDisbursements', !this.model.get('showPlannedDisbursements'));	
	  }else if(key == actualDisbursementTrn){
		  this.model.set('showActualDisbursements', !this.model.get('showActualDisbursements'));	
	  }	
  },
  chartViews: [
    'multibar',
    'table'
  ],

  chartOptions: {
    nvControls: false
  },

  downloadChartOptions: {
    nvControls: false,
    trimLabels: false
  },

  getTTContent: function(context) {
    var app = this.app;
    var of = app.translator.translateSync('amp.dashboard:of','of');
    var total = app.translator.translateSync('amp.dashboard:total','total');
    var units = app.translator.translateSync(app.settings.numberMultiplierDescription);

    // IMPORTANT: We assume this chart will ALWAYS show 2 data series.
    /* modify to be like chart-funding-type if adding more series */
    var index = -1;
    if (context.data[0].disabled === true) {
      index = 1;
    } else {
      index = context.series.index;
    }

    var header = context.x.raw + ' ' +
          app.translator.translateSync('amp.dashboard:aid-predictability-' +
          context.data[index].originalKey + '-' + this.model.get('measure'), '');

    var otherSeries = context.data[1 - index];  // WARNING: assumes only 2 series
    var otherHere = otherSeries.values[context.x.index];
    var line2Amount = 0;
    if (otherHere.y > 0) {
      line2Amount = context.y.raw / otherHere.y;
    }
    var line2 = '<b>' + d3.format('%')(line2Amount) +
        '</b>&nbsp<span>' + of + '</span>&nbsp' + context.x.raw +
        '&nbsp<span>' + total + '</span>';
    var self = this;
    var currencyName = _.find(app.settings.get('1').get('options'), function(item) {return item.id === self.model.get('currency')}).value;
    return {tt: {
      heading: header,
      bodyText: '<b>' + context.y.fmt + '</b> ' + currencyName + ' (' + units + ')',
      footerText: line2
    }};
  }

});

},{"./chart-view-base":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-view-base.js","d3":"d3","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-funding-type.js":[function(require,module,exports){
var d3 = require('d3');
var ChartViewBase = require('./chart-view-base');
var _ = require('underscore');


module.exports = ChartViewBase.extend({

  uiDefaults: {
    big: true,
    adjtype: 'FAKE',
    view: 'multibar',
    showTotal: true,
    showMeasuresSelector: true,
    showTopLegends: true,
    showCommonChartArea: true
  },
  events: function(){
      return _.extend({},ChartViewBase.prototype.events,{
          'click .nv-series' : 'changeChartColumns'
      });
  },   
  changeChartColumns: function(e){	  
	  var key = $(e.currentTarget).find('.nv-legend-text').text();	 
	  var stackedLegendTrn = app.translator.translateSync("amp.dashboard:filters-chart-legends-Stacked","Stacked");
	  var groupedLegendTrn = app.translator.translateSync("amp.dashboard:filters-chart-legends-Grouped","Grouped");
	  if(key == stackedLegendTrn || key == groupedLegendTrn){
		  this.model.set('stacked', (key == stackedLegendTrn ));	
	  }else{
		  var seriesToExclude = this.model.get('seriesToExclude') ? this.model.get('seriesToExclude') : [];
		  var indexOfKeyInExclusionList = _.indexOf(seriesToExclude, key);
		  if($(e.currentTarget).attr('class').indexOf('disabled') != -1){
			  if(indexOfKeyInExclusionList == -1){
				  seriesToExclude.push(key);
			  }			  
		  }else{
			  if(indexOfKeyInExclusionList != -1){
				  seriesToExclude.splice(indexOfKeyInExclusionList, 1);
			  }
		  }
		  this.model.set('seriesToExclude',seriesToExclude);
	  }	 
  },
  chartViews: [
    'multibar',
    'table'
  ],

  downloadChartOptions: {
    trimLabels: false
  },

  getTTContent: function(context) {
    var app = this.app;
    var of = app.translator.translateSync('amp.dashboard:of','of');
    var total = app.translator.translateSync('amp.dashboard:total','total');
    var units = app.translator.translateSync(app.settings.numberMultiplierDescription);

    var activeTooltipTitles = _.filter(context.data, function(series) {
      return series.disabled !== true;
    });
    
    var totalForYear = this.model.get('yearTotals') ? this.model.get('yearTotals')[context.x.raw ] : null;
    var d3FormatTotal = '', totalSpan = '';
    if(totalForYear && totalForYear != 0){
    	d3FormatTotal = d3.format('%')(context.y.raw / totalForYear);
        totalSpan = '&nbsp<span>' + total + '</span>';
    }
    var self = this;
    var currencyName = _.find(app.settings.get('1').get('options'), function(item) {return item.id === self.model.get('currency')}).value;  
    return {tt: {
      heading: context.x.raw + ' ' + activeTooltipTitles[context.series.index].key,
      bodyText: '<b>' + context.y.fmt + '</b> ' + currencyName + ' (' + units + ')',
      footerText: '<b>' + d3FormatTotal + '</b>&nbsp<span>' + of + '</span>&nbsp' + context.x.raw + totalSpan
    }};
  },

  chartClickHandler: function(context) {
    // clicking on the "others" bar loads five more.
    if (context.data[context.series.index].special === 'others') {
      this.model.set('limit', this.model.get('limit') + 1);
    }
  }

});

},{"./chart-view-base":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-view-base.js","d3":"d3","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-heatmaps.js":[function(require,module,exports){
var d3 = require('d3');
var ChartViewBase = require('./chart-view-base');
var ModalView = require('./chart-tops-info-modal');
var _ = require('underscore');

module.exports = ChartViewBase.extend({

  uiDefaults: {
	adjtype: 'FAKE',
	xAxisColumn: '',
    showTotal: false,
    showMeasuresSelector: true,
    showTopLegends: false,
    showCommonChartArea: false,
    disableResize: true
  },
  
  chartViews: [
    'heatmap',
    'table'    
  ],
  
  modalView: undefined,
  
  chartClickHandler : function(context) {
	  if (context.y.fmt === app.translator.translateSync('amp.dashboard:chart-heatmap-others')) {
		  this.model.set('yLimit', this.model.get('yLimit') + 10);
		  this.updateData();
	  }
  },
  
  downloadChartOptions: {
    trimLabels: false
  }

});
},{"./chart-tops-info-modal":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-tops-info-modal.js","./chart-view-base":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-view-base.js","d3":"d3","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-tops-info-modal.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<script type=\"text/javascript\">\r\n\tfunction openPreviewActivity(id) {\r\n\t\twindow.open('/aim/viewActivityPreview.do~public=true~pageId=2~activityId=' + id, '_blank');\r\n\t}\r\n</script>\r\n\r\n<div class='chart-tops-info-category'>\r\n\t<span>\r\n\t\t<b><%= (context.x.fmt || context.x.raw) %></b> - <%= model.get('adjtype')%> -  \t\t\r\n\t\t<span data-i18n=\"<%= app.settings.numberMultiplierDescription %>\"></span>\r\n\t\t<%= model.get('currency') %>\r\n\t</span>\r\n</div>\r\n<div class=\"chart-tops-info-container\">\r\n\t<div class=\"chart-tops-info-content\">\r\n\t\t<% if(error) { %>\r\n\t\t\t<div class=\"alert alert-danger\" role=\"alert\">\r\n\t\t\t\t<strong><span data-i18n=\"amp.dashboard:error\">Error</span></strong>\r\n\t\t\t\t<span data-i18n=\"amp.dashboard:error-detail\">The Aid Management Platform has temporarily encountered an issue. We apologize for any inconvenience.</span>\r\n\t\t\t</div>\r\n\t\t<% } else if(values === undefined) { %>\r\n\t\t\t<img alt=\"\" src=\"/TEMPLATE/ampTemplate/dashboard/build/img/loading-icon.gif\">\r\n\t\t\t<span data-i18n=\"amp.dashboard:download-rendering\">Rendering...</span>\r\n\t\t<% } else { %>\r\n\t\t\t<% var rowClass = ''; %>\r\n\t\t\t<table>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<th><span data-i18n=\"amp.dashboard:chart-tops-table-projecttitle\">Project Title</span></th>\r\n\t\t\t\t\t<th><span data-i18n=\"amp.dashboard:chart-tops-table-amount\">Amount</span></th>\r\n\t\t\t\t</tr>\t\t\t\r\n\t\t\t<% _(values).each(function(row, i) { %>\r\n          \t\t<% \tif (i % 2 === 0) rowClass = 'odd_row';\r\n    \t\t\t\telse rowClass = ''; %>\r\n    \t\t\t<tr class=\"<%=rowClass%>\">\r\n    \t\t\t\t<td>\r\n    \t\t\t\t\t<span class='pointer' onclick='openPreviewActivity(<%=row.id%>)'><%=row.name%></span>\r\n    \t\t\t\t</td>\r\n    \t\t\t\t<td><%=row.formattedAmount%></td>\r\n    \t\t\t</tr>\r\n        \t<% }) %>\r\n        \t</table>\r\n\t\t<% } %>\r\n\t</div>\r\n</div>");

module.exports = BackboneDash.View.extend({

	initialize: function(options) {
		this.app = options.app;
		this.context = options.context;
		this.model = options.model;
		this.numberMultiplier = app.settings.find(function(item) {return item.id === 'number-multiplier'});
	},

	render: function() {
		var self = this;
		this.$el.html(template({
			error: undefined,
			model: this.model,
			context: this.context,
			values: undefined,
			numberMultiplier: this.numberMultiplier
		}));
		app.translator.translateDOM($(".dash-settings-modal"));
		
		//TODO: move this code to a new model so the API call is made automatically.
    	var config = this.app.filter.serialize();
    	config.settings = this.app.settings.toAPI();
    	config.settings['0'] = this.model.get('adjtype');
    	$.ajax({
    		method: 'POST',
    		url: self.model.url + '/' + this.context.data[0].values[this.context.x.index].id,
    		dataType: 'json',
    		contentType: 'application/json',
    		processData: false,
    		data: JSON.stringify(config)
    	}).done(function(data) {
    		//TODO: Can we avoid re-calling the template by binding the changes in the 'values' field? 
    		self.$el.html(template({
				error: undefined,
    			model: self.model,
    			context: self.context,
    			values: data.values,
    			numberMultiplier: self.numberMultiplier
    		}));
    		app.translator.translateDOM($(".dash-settings-modal"));
    	}).fail(function(xhr, err) {
			var msg = JSON.parse(xhr.responseText).error;
			console.error("Error Getting chart-tops-info-modal from EP", msg);
			self.$el.html(template({
				model: self.model,
				context: self.context,
				error: err,
				numberMultiplier: self.numberMultiplier
			}));
		});
    	
		return this;
	},

});
},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-tops.js":[function(require,module,exports){
var d3 = require('d3');
var ChartViewBase = require('./chart-view-base');
var ModalView = require('./chart-tops-info-modal');
var _ = require('underscore');

module.exports = ChartViewBase.extend({

  uiDefaults: {
    adjtype: 'FAKE',
    showTotal: true,
    showMeasuresSelector: true,
    showTopLegends: true,
    showCommonChartArea: true    
  },
  
  chartViews: [
	'bar',
    'pie',
    'table'    
  ],
  
  modalView: undefined,
  
  //Dont try to call initialize here because it throws a 'Module initialization error' :((
  /*initialize: function(options) {
	  this.modalView = new ModalView({ app: options.app, collection: this.model.collection });
  },*/

  downloadChartOptions: {
    trimLabels: false
  },

  getTTContent: function(context) {
	var ofTotal = app.translator.translateSync("amp.dashboard:of-total","of total");
	var units = app.translator.translateSync(app.settings.numberMultiplierDescription);
    var self = this;
    var currencyName = _.find(app.settings.get('1').get('options'), function(item) {return item.id === self.model.get('currency')}).value;
    var percentage = context.y.raw > 0 ?
        d3.format('%')(context.y.raw / this.model.get('totalPositive')) + '</b>&nbsp<span>' + ofTotal:
        "";
    return {tt: {
      heading: context.x.raw,
      bodyText: '<b>' + context.y.fmt + '</b> ' + currencyName + ' (' + units + ')',
      footerText: '<b>' + percentage + '</span>'
    }};
  },

  chartClickHandler: function(context) {	  
    // clicking on the "others" bar loads five more.
    if (context.data[context.series.index]
               .values[context.x.index].special === 'others') {
      this.model.set('limit', this.model.get('limit') + 5);      
        this.model.set('big', true);      
    } else if (this.model.get('showCategoriesInfo') === true) {    	
    	this.modalView = new ModalView({ app: app, context: context, model: this.model });
    	this.openInfoWindow();    	    	
    }
  },
  
  openInfoWindow: function() {
	  var specialClass = 'dash-settings-modal';
	  this.app.modal('Category Detail', {
		  specialClass: specialClass,
	      bodyEl: this.modalView.render().el,
	      i18nTitle: 'amp.dashboard:dashboard-chart-tops-info-modal'
	  });	    
	  // Translate modal popup.
	  app.translator.translateDOM($("." + specialClass));
  }

});

},{"./chart-tops-info-modal":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-tops-info-modal.js","./chart-view-base":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-view-base.js","d3":"d3","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-view-base.js":[function(require,module,exports){

var Deferred = require('jquery').Deferred;
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var getChart = require('../charts/chart');
var util = require('../../ugly/util');
var DownloadView = require('./download');
var template = _.template("<div class=\"col-xs-12 <% if (!model.get('big')) { %>col-md-6<% } else { %> big-chart-<%= model.get('bigN')%> <% } %>\">\n\n  <div class=\"panel panel-chart\">\n    <div class=\"panel-heading fix-title-height\">\n      <% if (model.get('showTotal') === true) { %>\n\t      <span class=\"pull-right big-number\">\n\t        <b class=\"chart-total\"></b>\n\t        <span class=\"chart-currency\"></span>\n\t      </span>\n      <% } %>\n      <div>\n\t      <h2 data-i18n=\"amp.dashboard:chart-<%= model.get('name').replace(/ /g,'') %>\"><%= model.get('title') %></h2>\n\t      <% if (model.get('chartType') === 'fragmentation') { %>\n\t      \t<% var help_icon_text = app.translator.translateSync('amp.dashboard:chart-heatmap-help-text-' + model.get('heatmap_type'));%>\n\t      \t<img src=\"/TEMPLATE/ampTemplate/dashboard/build/img/questionmark1.png\" class=\"question_mark nv-series\" data-title=\"<%= help_icon_text %>\">\n\t      <% } %>\n      </div>\n    </div>\n\t\n    <div class=\"panel-body\">\n      <div class=\"chart-container\">\n        <h3 class=\"dash-chart-diagnostic text-center\"></h3>\n        <div class=\"dash-chart-wrap <%= (model.get('alternativeContainerClass') !== undefined ? model.get('alternativeContainerClass') : '')%>\">\n        </div>\n        <button type=\"button\" class=\"btn btn-link btn-xs pull-right reset\" style=\"display:none\" data-i18n=\"amp.dashboard:chart-reset\">reset others</button>\n      </div>\n      <div class=\"alert alert-warning negative-values-message\" role=\"alert\">\n          <strong data-i18n=\"amp.dashboard:negatives-values\">Negative values are not represented in this chart.</strong><br>\n          <span data-i18n=\"amp.dashboard:negatives-values-parag\">Please switch to bar chart or table view to view all values.</span>\n      </div>\n    </div>\n\n    <div class=\"panel-footer clearfix\">\n\n      <div class=\"pull-right\">\n\n        <div class=\"btn-group\">\n          <% _(views).each(function(view) { %>\n            <button type=\"button\" data-view=\"<%= view %>\"\n                class=\"chart-view btn btn-sm btn-<%= (view === model.get('view')) ? 'primary' : 'default' %>\">\n              <span class=\"glyphicon glyphicon-<%= {\n                bar: 'signal',\n                multibar: 'signal',\n                heatmap: 'stats',\n                pie: 'adjust',\n                table: 'th-list'\n              }[view] %>\"></span>\n            </button>\n          <% }) %>\n        </div>\n\n        <div class=\"btn-group\">\n          <a\n            class=\"btn btn-sm btn-default download\"\n            download=\"AMP <%= model.get('title') %> - <%= (new Date()).toISOString().split('T')[0] %>.png\"\n            target=\"_blank\">\n            <span class=\"glyphicon glyphicon-cloud-download\"></span>\n          </a>\n          <button type=\"button\" class=\"btn btn-sm btn-<%= model.get('big') ? 'primary' : 'default' %> expand hidden-xs hidden-sm\" <%= model.get('disableResize') ? 'disabled' : ''%>>\n            <span class=\"glyphicon glyphicon-fullscreen\"></span>\n          </button>\n        </div>\n\n      </div><!-- buttons in .pull-right -->\n\n      <% if (model.get('adjtype') && model.get('showMeasuresSelector') === true) { %>\n        <form class=\"form-inline dash-form dash-adj-type\" role=\"form\">\n          <select class=\"form-control like-btn-sm ftype-options\">\n            <option>...</option>\n            <!-- gets populated after settings load -->\n          </select>\n          <span class=\"cheat-lineheight\"></span>\n        </form>\n      <% } %>\n      \n      <% if (model.get('chartType') === 'fragmentation') { %>\n\t\t<form class=\"form-inline dash-form dash-xaxis-options\" role=\"form\">\n        \t<select class=\"form-control like-btn-sm xaxis-options\">\n            \t<option>...</option>\n            \t<!-- gets populated after settings load -->\n          \t</select>\n          \t<span class=\"cheat-lineheight\"></span>\n        </form>\n        <button type=\"button\" class=\"btn btn-sm btn-default heatmap-switch\">\n            <span data-i18n=\"amp.dashboard:chart-swap-axes\">Swap Axes</span>\n        </button>\n\t <% } %>\n\n    </div>\n  </div>\n\n  <div class=\"export-modal\"></div>\n</div>");


var adjOptTemplate = _.template('<option value="<%=opt.id%>" ' +
  '<%= current ? selected="selected" : \'\' %>><%=opt.name%></option>');


module.exports = BackboneDash.View.extend({

  uiDefaults: {
    big: false,
    view: 'bar'
  },

  events: {
    'change .dash-adj-type select': 'changeAdjType',
    'change .dash-xaxis-options select': 'changeXAxis',
    'click .reset': 'resetLimit',
    'click .chart-view': 'changeChartView',
    'click .download': 'download',
    'click .expand': 'big',
    'click .retry': 'render',
    'click .heatmap-switch': 'heatmapSwitchAxis'
  },

  chartViews: [
    'bar',
    'pie',
    'heatmap',
    'table'    
  ],  
  
  initialize: function(options) {
    this.app = options.app;
    this.model.set(this.uiDefaults);
    this.rendered = false;
    this._stateWait = new Deferred();
    this.message = null;
    this.showChartPromise = new Deferred();
    this.renderedPromise = new Deferred();

    if (this.app.savedDashes.length) {
      // a bit sketch....
      this.app.state.loadPromise.always(this._stateWait.resolve);
    } else {
      this._stateWait.resolve();
    }

    this.listenTo(this.app.filter, 'apply', this.updateData);
    this.listenTo(this.app.settings, 'change', this.updateData);
    this.listenTo(this.model, 'change:adjtype', this.render);
    this.listenTo(this.model, 'change:xAxisColumn', this.render);
    this.listenTo(this.model, 'change:limit', this.updateData);
    this.listenTo(this.model, 'change:view', this.render);

    this.app.state.register(this, 'chart:' + this.model.url, {
      get: _.partial(_(this.model.pick).bind(this.model), 'limit', 'adjtype', 'xAxisColumn', 'view', 'big','stacked','showPlannedDisbursements','showActualDisbursements','seriesToExclude', 'xLimit', 'yLimit', 'swapAxes'),
      set: _(this.model.set).bind(this.model),
      empty: null
    });

    _.bindAll(this, 'showChart', 'failLoading','hideExportInPublicView');
    if (this.getTTContent) { _.bindAll(this, 'getTTContent'); }
    if (this.chartClickHandler) { _.bindAll(this, 'chartClickHandler'); }
  },

  render: function() {
	var self = this;
	this.renderedPromise = new Deferred();
    var renderOptions = {
      views: this.chartViews,
      model: this.model,
      chart: this.chartEl,
      util: util
    };
    
    $.when(this._stateWait, this.app.filter.loaded, this.app.translator.promise).done(function() {
    	self.$el.html(template(renderOptions));
    	self.hideExportInPublicView();
    	self.message = self.$('.dash-chart-diagnostic');
    	self.chartContainer = self.$('.dash-chart-wrap');
	
	    if (self.model.get('adjtype') !== void 0) {  // this chart has adj settings
	    	self.app.settings.load().done(_(function() {
	    	self.rendered = true;
	        var adjSettings = self.app.settings.get('0');  // id for Funding Type
	        if (!adjSettings) { 
	        	self.app.report('Could not find Funding Type settings'); 
	        } else {
	        	if (self.model.get('adjtype') === 'FAKE') {
	        		self.model.set('adjtype', adjSettings.get('defaultId'));
	        	}
	        }
	        self.$('.ftype-options').html(
	          _(adjSettings.get('options')).map(function(opt) {
	            return adjOptTemplate({
	              opt: opt,
	              current: (opt.id === this.model.get('adjtype'))
	            });
	          }, self)
	        );
	      }).bind(self));
	    } else {
	    	self.rendered = true;
	    }
	    
	    // For heatmaps add some extra combos.
	    if (self.model.get('chartType') === 'fragmentation') {
	    	var heatMapConfigs = self.model.get('heatmap_config').models[0];
	    	var thisHeatMapChart = _.find(heatMapConfigs.get('charts'), function(item) {return item.name === self.model.get('name')});
	    	self.$('.xaxis-options').html(
	    		_(thisHeatMapChart.xColumns).map(function(colId) {
	    			var item = _.find(heatMapConfigs.get('columns'), function(item, i) { return i === colId});
	    			var opt = {id: item.origName, name: item.name, selected: false, value: item.origName};
	    			return adjOptTemplate({
	    				opt: opt,
	    	            current: (opt.id === this.model.get('xAxisColumn'))
	    	        });
	    	    }, self)
	    	);
	    }
	
	    if (self._stateWait.state() !== 'pending') {
	    	self.updateData();
	    }
	
	    self.app.translator.translateDOM(self.el);
	    self.renderedPromise.resolve();
    });
    return this;
  },

  updateData: function() {
	if(this.app.rendered !== true) { return; }  
    if (!this.rendered) { return; }  // short-circuit on early filters apply event
    if (this._stateWait.state() === 'pending') {  // short-circuit until we have state
      this.message.html('Loading...').attr('data-i18n', 'amp.dashboard:chart-loading-saved-settings');
      app.translator.translateDOM($('.chart-container'));
      //this.message.fadeIn(100);
      return;
    }

    this.showChartPromise = new Deferred(); // We need to reinitialize this promise.
    this.chartContainer.empty();
    this.message.html('<span data-i18n="amp.dashboard:loading">Loading...</span>').fadeIn(100);

    this.app.translator.getTranslations()
      .done(_(function() {  // defer here to prevent a race with translations loading

        /* TODO: Do we really want to localize this and slow things?*/
        //this.app.translator.translateDOM(this.el);

        this.model.fetch({
          type: 'POST',  // TODO: move fetch options to model?
          data: JSON.stringify(this.app.filter.serialize())
        })
        .always(_(function() {  }).bind(this))
        .done(this.showChart)
        .fail(this.failLoading);
      }).bind(this))
      .fail(_(function() {
        this.app.report('Could not load translations', [
          'Refreshing the page may fix the issue.']);
      }).bind(this));

  },

  showChart: function() {
	  this.showNegativeAlert();
	  
    // TODO: why are we triggering twice on load???
    if (!this.model.hasData()) {
      this.message.html('No Data Available').attr('data-i18n','amp.dashboard:chart-no-data-available');
      app.translator.translateDOM($('.chart-container'));
      this.resetNumbers();
      return;
    }    
    var chart = getChart(this.model.get('view'), this.model.get('processed'), this.getChartOptions(), this.model);
    this.chartContainer.html(chart.el);

    if (this.model.get('chartType') !== 'fragmentation') {
    	this.renderNumbers();
    }
    
    if (this.model.get('chartType') !== 'fragmentation') {
	    var limit = this.model.get('limit');
	    if (limit) {
	      this.$('.reset')[limit === this.model.defaults.limit ? 'hide' : 'show']();
	    }
    } else {
        if (this.model.get('showResetButton')) {
        	this.$('.reset').show();
        } else {
        	this.$('.reset').hide();
        }
    }
    this.message.stop().fadeOut(200);
    
    this.beautifyLegends(this);
    
    if (this.model.get('view') === 'heatmap') {
    	this.handleHeatmapClicks();
    }
        
    this.showChartPromise.resolve();
  },
  
  handleHeatmapClicks: function() {
	  var self = this;
	  var others = this.$(".legend-others");
	  if (others) {
		  $(others).on('click', function(evt) {
			  self.model.set('yLimit', self.model.get('yLimit') + self.model.get('originalYLimit'));
			  self.updateData();
		  });
	  }
  },
  
  showNegativeAlert: function() {
    if(this.model.get('view') === 'pie' && _.find(this.model.get('processed')[0].values, function(item) { return item.y < 0;})) {
      this.$('.negative-values-message').show();
    } else {
      this.$('.negative-values-message').hide();
    }
  },

  getChartOptions: function() {	  
    var co = _(_(this.chartOptions).clone() || {}).defaults({
      trimLabels: !this.model.get('big'),
      getTTContent: this.getTTContent,
      clickHandler: this.chartClickHandler,
      width: this.$('.panel-body').width(),
      height: this.$('.panel-body').height()
      
    });
    if(this.model.get('view') == 'multibar'){
  	  co.stacked = this.model.get('stacked');
  	}
    co.model = this.model;
    return co;
  },

  failLoading: function() {
    this.message.html('Failed to load data <small>' + arguments[2] +
      ' <button type="button" class="retry btn btn-warning btn-sm">' +
      '<span class="glyphicon glyphicon-refresh"></span> Retry</button></small>').show();
    console.error('failed loading chart :(', arguments);
  },

  renderNumbers: function() {
    if (this.model.get('total')) {
    	this.$('.chart-total').html(util.translateLanguage(this.model.get('sumarizedTotal'))); // this shall use the format from the server and translate it in the front end
    }
    var self = this;
    var currencyName = _.find(app.settings.get('1').get('options'), function(item) {return item.id === self.model.get('currency')}).value;
    this.$('.chart-currency').html(currencyName);
  },

  resetNumbers: function() {
    this.$('.chart-total').html('');
    this.$('.chart-currency').html('');
  },

  resetLimit: function() {
	  if (this.model.get('chartType') === 'fragmentation') {
		  this.model.set('yLimit', this.model.get('originalYLimit'));
		  this.updateData();
	  } else {
		  this.model.set('limit', this.model.defaults.limit);
	  }
  },

  changeAdjType: function(e) {
    var newType = e.currentTarget.value;
    this.model.set('adjtype', newType);
  },
  
  changeXAxis: function(e) {
	  var newType = e.currentTarget.value;
	  this.model.set('xAxisColumn', newType);
  },  

  changeChartView: function(e) {
    var view = util.data(e.currentTarget, 'view');
    this.model.set('view', view);
    this.hideExportInPublicView();
  },
  hideExportInPublicView: function(){
	  var editableDataExportSetting = this.app.settings.get('hide-editable-export-formats-public-view');
	  if(this.model.get('view') === 'table' && editableDataExportSetting && editableDataExportSetting.get('defaultId') == "true" && this.app.user.get('logged') == false ){
		  this.$el.find('.download').hide();
	  }else{
		  this.$el.find('.download').show();
	  }  
  },  
  big: function() {
    // toggle big/small charts on large screens
    this.model.set('big', !this.model.get('big'));
  },
  setClear: function(shouldBreak) {
    // layout hints, should only be called by ./charts.js
    this.$el[shouldBreak ? 'addClass' : 'removeClass']('clearfix');
  },

  download: function() {     
	var chartOptions = _(this.getChartOptions()).omit('height', 'width');	
    var downloadView = new DownloadView({
      app: this.app,
      model: this.model,
      chartOptions: chartOptions
    });
    var specialClass = 'dash-download-modal';
    this.app.modal('Download chart', {
      bodyEl: downloadView.render().el,
      specialClass: specialClass,
      i18nTitle: 'amp.dashboard:download-download-chart'
    });
    
    // Translate modal popup.	
   	app.translator.translateDOM($("." + specialClass));
  },
  
  heatmapSwitchAxis: function () {
	  if (this.model.get('swapAxes') === true) {
		  this.model.set('swapAxes', false);
	  } else {
		  this.model.set('swapAxes', true);
	  }  
	  this.updateData();
  },

  //AMP-18630: Here we setup a simple tooltip for each legend element.
  beautifyLegends : function(self) {	  
	  var hasValues = false;
	  var hasProcessed = false;
	  if(self.model !== undefined && self.model.get('values') !== undefined && self.model.get('values').length > 0) {
		  hasValues = true;
	  }
	  if(self.model !== undefined && self.model.get('processed') !== undefined && self.model.get('processed').length > 1) {
		  hasProcessed = true;
	  }
	  
	  // Iterate the list of legend elements in DOM (only for this chart) and set a data element called 'data-title' that
	  // will be then used when a hover event is fired.
	  $(this.$el).find(".nv-series").each(function(i, elem) {
		  // Heatmaps dont need a special reprocessing.
		  if (self.model.get('view') !== 'heatmap') {
			  if(hasValues && !hasProcessed) {
				  // Top charts.
				  if(self.model.get('values')[i] !== undefined) {
					  $(elem).data('data-title', self.model.get('values')[i].name);
				  } else {
					// This the last legend "Others" (doesnt come in the data).
			    	$(elem).data('data-title', app.translator.translateSync("amp.dashboard:chart-FundingType-others", "Others"));
				  }
			  } else if(hasProcessed) {
				  // Aid Predictability charts and Funding Type charts.
				  if(self.model.get('processed')[i] !== undefined) {
					  // The extra check is for FT charts that have more legends (grouped, stacked, etc).
					  $(elem).data('data-title', self.model.get('processed')[i].key);
				  }
			  }
		  }
	    
		  // Now bind NV tooltip mechanism to hover event for each legend.
		  if($(elem).data('data-title') || $(elem).data('title')) {
			  $(elem).hover(function() {
	    		var offset = $(this).offset();	    		
	    		//TODO: Check the generation of heatMapChart.js and see if we can set the 'data' field the same way than other charts.
	    		var title = $(elem).data('data-title') ? $(elem).data('data-title') : $(elem).data('title');
	    		//TODO: Remove hardcoded html and use a template.
	    	    nv.tooltip.show([offset.left, offset.top], "<div class='panel panel-primary panel-popover'><div class='panel-heading'>" + title + "</div></div>");
	    	        
	    	    // TODO: Find a way to trigger the mouseover on the bar.
	    	    // $($(this).closest('svg').find(".nv-groups").find(".nv-bar")[i]).trigger('hover');
	    	   }, function() {
	    		   nv.tooltip.cleanup();
	    	   });
		  }
	  });
  }

});

},{"../../ugly/util":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\util.js","../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","../charts/chart":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\chart.js","./download":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\download.js","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\charts.js":[function(require,module,exports){
var _ = require('underscore');
var BackboneDash = require('../backbone-dash');

var Tops = require('../models/chart-tops');
var Predictability = require('../models/chart-aid-predictability');
var FundingType = require('../models/chart-funding-type');
var HeatMapChart = require('../models/chart-heatmaps');

var TopsChartView = require('./chart-tops');
var HeatMapChartView = require('./chart-heatmaps');
var PredictabilityChartView = require('./chart-aid-predictability');
var FundingTypeChartView = require('./chart-funding-type');


module.exports = BackboneDash.View.extend({

  className: 'row',

  initialize: function(options) {
    this.app = options.app;
    this.chartViews = this.collection.map(function(chart) {
      var ChartView = chart instanceof Tops ? TopsChartView
                    : chart instanceof Predictability ? PredictabilityChartView
                    : chart instanceof FundingType ? FundingTypeChartView
                    : chart instanceof HeatMapChart ? HeatMapChartView
                    : null;
      return new ChartView({ model: chart, app: this.app });
    }, this);
    this.listenToOnce(this.app.filter, 'apply', this.applyFilter);
    this.listenTo(this.collection, 'change:big', this.injectBreaks);
    this.listenTo(this.collection, 'change:bigN', this.redrawContainer);
  },

  render: function() {
    this.$el.html(_(this.chartViews).map(function(view) {
      return view.render().el;
    }));
    this.injectBreaks();
    return this;
  },

  injectBreaks: function(chartModel) {
    _(this.chartViews).reduce(function(breakAfter, thisView) {
      thisView.setClear(breakAfter);
      if (!breakAfter) {
        return thisView.model.get('big') ? false : true;
      } else {
        return false;
      }
    }, false);

    if (chartModel) {
      var chartView = _(this.chartViews).find(function(v) {
        return v.model === chartModel;
      });
      if (chartView) { chartView.render(); }
    }
  },
  
  redrawContainer: function(chartModel) {
	  if (chartModel) {
		  var chartView = _(this.chartViews).find(function(v) {
			  return v.model === chartModel;
	      });
	      if (chartView) { 
	    	  chartView.render(); 
	      }
	  } 
  }

});

},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","../models/chart-aid-predictability":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-aid-predictability.js","../models/chart-funding-type":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-funding-type.js","../models/chart-heatmaps":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-heatmaps.js","../models/chart-tops":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-tops.js","./chart-aid-predictability":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-aid-predictability.js","./chart-funding-type":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-funding-type.js","./chart-heatmaps":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-heatmaps.js","./chart-tops":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\chart-tops.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\controls.js":[function(require,module,exports){
var BackboneDash = require('../backbone-dash');
var Filters = require('./filters');
var Settings = require('./settings');
var Share = require('./share');


module.exports = BackboneDash.View.extend({

  className: 'row',

  initialize: function(options) {
    this.app = options.app;    
    this.settings = new Settings({ app: this.app });
    this.filters = new Filters({ app: this.app });
    this.share = new Share({ app: this.app });
  },

  render: function() {
    this.$el.html([
      this.filters.render().el,
      this.settings.render().el,
      this.share.render().el
    ]);
    return this;
  }

});

},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","./filters":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\filters.js","./settings":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\settings.js","./share":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\share.js"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\download.js":[function(require,module,exports){
var _ = require('underscore');
var baby = require('babyparse');
var canvg = require('../../ugly/lib-load-hacks').canvg;
var util = require('../../ugly/util');


var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var getChart = require('../charts/chart');
var util = require('../../ugly/util');
var template = _.template("<h4 data-i18n=\"amp.dashboard:download-preview\">Preview:</h4>\n\n<!-- This 'modal' div fixes AMP-19525: In FF when the chart is drawn (for less than a second) in 'svg-wrap', sometimes the mouse cursor is over one of the bars and triggers the tooltip,\nthat process is not fully performed thus resulting in incomplete html which is rejected by the browser :(  -->\n<div class=\"modal-preview-area\">\n</div>\n<div class=\"preview-area\">\n\t<div class=\"svg-wrap hidden\">\n  \t</div>\n  \t<div class=\"canvas-wrap hidden\">\n  \t</div>\n  \t<div class=\"table-wrap hidden\">\n  \t</div>\n</div>\n\n<div class=\"text-center\">\n  <a class=\"btn btn-success download-chart disabled\">\n    <span class=\"glyphicon glyphicon-download\"></span>\n    <span data-i18n=\"amp.dashboard:download-rendering\" class=\"word\">Rendering...</span>\n  </a>\n</div>\n");

var previousXLimit = null;
var previousYLimit = null;

module.exports = BackboneDash.View.extend({

  initialize: function(options) {
	var self = this;
    this.app = options.app;
    var valuesLength = this.model.get('values') ? this.model.get('values').length : 0;
    var height = util.calculateChartHeight(valuesLength, true);
    this.dashChartOptions = _({}).extend(options.chartOptions, {
      height: height, //450,  // sync with css!!!
      width: $('.container').width(),	// sync with css!!!
      trimLabels: false,
      nvControls: false      
    });
    
    // Heatmaps export need to show all data at once so we force the x/y limits and re-render the chart.
    if (this.model.get('chartType') === 'fragmentation') {
	    previousXLimit = this.model.get('xLimit');
	    previousYLimit = this.model.get('yLimit');
	    this.model.set('yLimit', -1);
	    this.model.set('xLimit', -1);
	    this.model.set('showFullLegends', true);
	    var chart = _.find(this.app.view.charts.chartViews, function(item) {return item.model.get('name') === self.model.get('name')});
	    chart.render();
    }
  },

  render: function() {
	var self = this;
    this.$el.html(template());   
    this.chart = _.find(self.app.view.charts.chartViews, function(item) {return item.model.get('name') === self.model.get('name')});
    
	// Here we will define an interval that will check periodically if the bootstrap modal is fully rendered.
	// In that moment the interval is finished and the chart is rendered.
	var rendered = false; // This flag is used to avoid triggering the render process twice in case the browser mess up the interval.	    	
	var interval = window.setInterval(function() {
		if ($('.dash-download-modal').closest('.in').length > 0) {
			window.clearInterval(interval);
			// Wait for the chart in the dashboard page to be fully rendered, this has impact only on heatmap charts, on the rest is transparent.
			$.when(self.chart.renderedPromise, self.chart.showChartPromise).done(function() {
	    		if (self.model.get('chartType') === 'fragmentation') {
	    			// We add an event for heatmaps to re-draw the original chart.
	    		    $('.dash-download-modal').closest('.in').on('hide.bs.modal', function() {
	    		    	self.model.set('yLimit', previousYLimit);
	    		    	self.model.set('xLimit', previousXLimit);
	    		    	self.model.set('showFullLegends', false);
						self.chart.render();
	    		    });
	    		}
			    if (self.model.get('view') === 'table') {
			    	self.renderCSV(self.$('.preview-area .table-wrap').removeClass('hidden'));
			    } else {
			        nv.tooltip.cleanup();
			        if (rendered === false) {
			        	rendered = true;
			        	self.renderChart(self.$('.preview-area .svg-wrap').removeClass('hidden'),
			        		self.$('.preview-area .canvas-wrap'), self.chart);
			        }
			    }
			});
		}
    }, 100);
    
    return this;
  },

  renderChart: function(svgContainer, canvasContainer, chart) {
	var self = this;
    if (_(this.app.browserIssues).findWhere({feature: 'canvas'})) {
      this.app.viewFail(this, 'Chart export requires a modern web browser');
    }
    
    if (self.model.get('chartType') === 'fragmentation') {
    	var svg = $($($(chart)[0].el).find("svg"))[0].getBBox();
	    this.dashChartOptions.height = svg.height + 100;
	    this.dashChartOptions.width = svg.width + 80;
    }
        
    var view = this.model.get('view'),
        data = this.model.get('processed'),
        canvas = document.createElement('canvas'),
        chartEl = getChart(view, data,
          _({}).extend(this.dashChartOptions, { height: this.dashChartOptions.height - 42 })).el;

    svgContainer.html(chartEl);

    this.prepareCanvas(canvas, this.dashChartOptions.height, this.dashChartOptions.width);

    this.chartToCanvas(chartEl, canvas, function() {
      svgContainer.hide();
      var img = new Image();
      img.src = canvas.toDataURL('image/png');
      canvasContainer.html(img);
      $(canvasContainer).removeClass('hidden');
      $('.modal-preview-area').remove();
      this.makeDownloadable(img.src, 'chart', '.png');
    });
    
    // Scale the modal correctly for heatmaps.
    if (self.model.get('chartType') === 'fragmentation') {
    	var modal = $('.dash-download-modal').closest('.in').find('.dash-download-modal');
    	if ($(svgContainer).width() > $(modal).width()) {
    		$(modal).find('.preview-area').css('max-width','90%');
        	$(modal).closest('.in').find('.preview-area').css('overflow','auto');
    	}
    	if ($(svgContainer).height() > $(window).height()) {
    		$(modal).find('.preview-area').css('max-height', ($(window).height() - 270) + 'px');
        	$(modal).closest('.in').find('.preview-area').css('overflow','auto');
    	}
    }
  },

  prepareCanvas: function(canvas, h, w) {
	var self = this;
	var currency = _.find(app.settings.get('1').get('options'), function(item) {return item.id === self.model.get('currency')});
    var currencyName = currency !== undefined ? currency.value : '';
    var ctx = canvas.getContext('2d'),
    	moneyContext = (this.model.get('sumarizedTotal') !== undefined ? ': ' + util.translateLanguage(this.model.get('sumarizedTotal')) + ' ': ' ') + currencyName,
        adjType = this.model.get('adjtype');    
    if (adjType) {
        var trnAdjType = this.chart.$el.find('.ftype-options option:selected').text();
        moneyContext = trnAdjType + moneyContext;
    }

    // size the canvas
    canvas.setAttribute('width', w);
    canvas.setAttribute('height', h);

    // make the background opaque white
    ctx.beginPath();
    ctx.rect(0, 0, w, h);
    ctx.fillStyle = '#fff';
    ctx.fill();

    // Add the chart title
    ctx.fillStyle = '#163f66';
    ctx.font = 'bold 22px "Open Sans"';
    ctx.fillText(this.model.get('title').toUpperCase(), 10, 10 + 22);
    // what money are we talking about?
    ctx.fillStyle = '#333';
    if (self.model.get('chartType') === 'fragmentation') {
    	ctx.font = 'normal 14px "Open Sans"';
    	ctx.textAlign = 'left';
    	ctx.fillText(trnAdjType, 10, 50);	    
    } else {    
    	ctx.textAlign = 'right';
	    ctx.fillText(moneyContext, w - 10, 10 + 22);
	    ctx.textAlign = 'left';  // reset it
    }    
    // reset font to something normal (nvd3 uses css ugh...)
    ctx.font = 'normal 12px "sans-serif"';
    
    $('.modal.in .modal-dialog').width(w + 60);
  },

  chartToCanvas: function(svg, canvas, cb) {
	var self = this;
	
	if (this.model.get('chartType') === 'fragmentation') {
		// This is what applies the necessary styles to the chart´s SVG.
		var css = "rect.bordered {stroke: #E6E6E6;stroke-width: 2px;} text.mono {font-size: 9pt;font-family: Arial;fill: #000;}";
	    var s = document.createElement('style');
	    s.setAttribute('type', 'text/css');
	    s.innerHTML = "<![CDATA[\n" + css + "\n]]>";
	    svg.getElementsByTagName("defs")[0].appendChild(s);
	}
	
    var boundCB = _(cb).bind(this);
    window.setTimeout(function() {
      this.app.tryTo(function() {
        canvg(canvas, svg.parentNode.innerHTML, { // note: svg.outerHTML breaks IE
          offsetY: ((self.model.get('chartType') !== 'fragmentation') ? 42 : 65),
          ignoreDimensions: true,
          ignoreClear: true,
          ignoreMouse: true,
          renderCallback: boundCB
        });
      }, this);
    }.bind(this), 1500);  // we have to wait for stupid nvd3...
  },

  renderCSV: function(csvContainer) {
	var self = this;
	var currencyName = _.find(app.settings.get('1').get('options'), function(item) {return item.id === self.model.get('currency')}).value;
    var data = this.model.get('processed'),
        currency = currencyName,
        adjtype = this.model.get('adjtype') || false,
        csvTransformed,
        headerRow,
        textContent,
        preview;

    var self = this;
    var keys = _(data).pluck('key');
    
    if (self.model.get('chartType') !== 'fragmentation') {
	    // table of all the data
	    csvTransformed = _(data)
	      .chain()
	      .pluck('values')
	      .transpose()
	      .map(function(row) {
	        return _(row).reduce(function(csvRow, cell) {
	          csvRow.push(cell.y);
	          return csvRow;
	        }, [row[0].x]);
	      })
	      .map(function(row) {
	        row.push(currency || '');
	        if (adjtype) {
				var trnAdjType = self.chart.$el.find('.ftype-options option:selected').text();
	            row.push(trnAdjType);
	        }
	        return row;
	      })
	      .value();
    } else {
        csvTransformed = _.map(self.model.get("matrix"), function(itemY, i) {
			return _.map(itemY, function(itemX, j) {
				return [self.model.get("yDataSet")[i],
					self.model.get("xDataSet")[j],
					self.model.get("matrix")[i][j] ? self.model.get("matrix")[i][j].dv : '',
					self.model.get("matrix")[i][j] ? self.model.get("matrix")[i][j].p : ''
				]
			})
		});
	    csvTransformed = [].concat.apply([], csvTransformed);
	    csvTransformed = _.each(csvTransformed, function(item) { 
	        item.push(currency);
	        if (adjtype) {
				var trnAdjType = self.chart.$el.find('.ftype-options option:selected').text();
	            item.push(trnAdjType);
	        }	        
	    });
    }

    // prepend a header row
    headerRow = [];
    var amountTrn = this.app.translator.translateSync('amp.dashboard:download-amount', 'Amount');
    var currencyTrn = this.app.translator.translateSync('amp.dashboard:currency', 'Currency');
    var percentageTrn = this.app.translator.translateSync('amp.dashboard:percentage', 'Percentage');
    var typeTrn = this.app.translator.translateSync('amp.dashboard:type', 'Type');
    var yearTrn = this.app.translator.translateSync('amp.dashboard:year', 'Year');

	if (this.model.url.indexOf('/tops') > -1) {
	    headerRow.push(this.model.get('title'));
	    headerRow.push(amountTrn);
	    headerRow.push(currencyTrn);
	    headerRow.push(typeTrn);
	} else if (this.model.url.indexOf('/aid-predictability') > -1) {
	    headerRow.push(yearTrn);
	    _.each(keys, function(item) {
	    	headerRow.push(item);
	    });
	    headerRow.push(currencyTrn);
	} else if (this.model.url.indexOf('/ftype') > -1) {
		headerRow.push(yearTrn);
	    _.each(keys, function(item) {
	    	headerRow.push(item);
	    });
	    headerRow.push(currencyTrn);
	    headerRow.push(typeTrn);
	} else if (this.model.get('chartType') === 'fragmentation') {
		// For AMP-23582: we dont want the name from "summary" because thats the origName and not always the same name than the X axis combo selector. 
		var firstColumnName = _.find(self.model.get('heatmap_config').models[0].get('columns'), function(item) {
			return item.origName === self.model.get('summary')[0];
		}).name; 
		var secondColumnName = _.find(self.model.get('heatmap_config').models[0].get('columns'), function(item) {
			return item.origName === self.model.get('summary')[1];
		}).name;
		headerRow.push(firstColumnName);
		headerRow.push(secondColumnName);
	    headerRow.push(amountTrn);
	    headerRow.push(percentageTrn);
	    headerRow.push(currencyTrn);
	    headerRow.push(typeTrn);
	}

    csvTransformed.unshift(headerRow);
    /* Add sep=, for automatic Excel support at the very top of the file works but breaks BOM unicode.
     * Let us use tab-delimited instead.
     *  This website shows a csv with Tab-delimited, utf16le with a BOM has best Excel support (via StackOverflow):
     *  http://wiki.scn.sap.com/wiki/display/ABAP/CSV+tests+of+encoding+and+column+separator
     */

    textContent = baby.unparse(csvTransformed, {
      delimiter: ';',
      encoding: 'utf-16',
    	quotes: true
    });

    preview = document.createElement('textarea');
    preview.setAttribute('class', 'csv-preview');
    preview.value = textContent;
    csvContainer.html(preview);

    if (!this.app.hasIssue('download')) {
      textContent = util.textAsDataURL(textContent);
    }

    window.setTimeout(_(function() {  // stupid bootstrap modals...
      // this setTimeout is needed for the flash fallback :(
      this.makeDownloadable(textContent, 'data', '.csv');
    }).bind(this), 100);
  },

  makeDownloadable: function(stuff, what, ext) {
	var messageKey = ['amp.dashboard:chart-', this.model.get('name').replace(/ /g, '')].join('')
	var translatedName = app.translator.translateSync(messageKey, this.model.get('name'));
    var fileName = translatedName + ext,
        dlButton = this.$('.download-chart').removeClass('disabled');
    dlButton.find('.word').text('Download ' + what).attr('data-i18n', 'amp.dashboard:download-download-' + what);
    app.translator.translateDOM(dlButton);

    if (this.app.hasIssue('download')) {
      if (this.app.hasIssue('flash')) {
        this.app.report('Your browser is missing features to initiate the download', [
          'You might be able to save this chart manually by right-clicking the ' +
          'preview and selecting "Save Picture As...']);
      } else {
        // bad browser, but has flash! fallback to downloadify
        this.app.tryTo(function() {
          window.Downloadify.create(dlButton[0], {
            swf: '/TEMPLATE/ampTemplate/commonMedia/downloadify.swf',
            downloadImage: '/TEMPLATE/ampTemplate/commonMedia/download-button-states.png?rev=4',
            transparent: true,
            width: 176,
            height: 34,
            filename: fileName,
            data: stuff
              .replace('data:text/plain;base64,//', '')
              .replace('data:image/png;base64,', ''),
            dataType: ext === '.csv' ? 'string' : 'base64',
            append: true,
            onError: function() {
              this.app.report('Could not download the file.');
            }
          });
        }, this);
      }
    } else {
      this.$('.download-chart')
        .attr('href', stuff)
        .attr('download', fileName);
    }

    // AMP-19813
    if (ext.indexOf('csv') !== -1) {
    	$('.modal-preview-area').remove();
    }
  }

});

},{"../../ugly/lib-load-hacks":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\lib-load-hacks.js","../../ugly/util":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\util.js","../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","../charts/chart":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\charts\\chart.js","babyparse":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\node_modules\\babyparse\\babyparse.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\fail.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<div class=\"container\">\n  <header class=\"spaced text-center\">\n    <h2>\n      The application encountered an\n      <span class=\"text-danger\">error</span>\n      <small>:(</small>\n    </h2>\n    <p><%= err %></p>\n  </header>\n</div>\n");


module.exports = BackboneDash.View.extend({

  initialize: function(options) {
    this.app = options.app;
    this.err = options.err;
  },

  render: function() {
    this.$el.html(template({ err: this.err }));
    return this;
  }

});


},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\filters.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<div class=\"col-xs-12 col-md-5\">\n  <div class=\"panel\">\n    <div class=\"panel-body\">\n      <button type=\"button\" class=\"btn btn-sm btn-default pull-right show-filters\">\n        <span class=\"glyphicon glyphicon-edit\"></span>\n        <span data-i18n=\"amp.dashboard:filters-edit\">Edit filters</span>\n      </button>\n      <h3 class=\"inline-heading\" data-i18n=\"amp.common:title-filters\">Filters</h3>\n      <div class=\"applied-filters\">\n        <em data-i18n=\"amp.common:filters-loading\">Loading...</em>\n      </div>\n    </div>\n  </div>\n</div>\n<div id=\"filter-popup\"></div>\n");
var summaryTemplate = _.template("<% if (!countApplied) { %>\n  <em data-i18n=\"amp.dashboard:filters-none-applied\">No filters applied</em>\n<% } else { %>\n  <span>\n    <button class=\"btn btn-default btn-sm show-filter-details\">\n      <span class=\"glyphicon glyphicon-eye-open\"></span>\n      <span data-i18n=\"amp.dashboard:filters-show-settings\">Show filter settings</span>\n      (<b><%= countApplied %></b>)\n    </button>\n  </span>\n<% } %>\n");
var detailsTemplate = _.template("<div>\n  <h4 class=\"inline-heading\" data-i18n=\"amp.dashboard:filters-active\">Active Filters</h4>\n  <button type=\"button\" class=\"btn btn-sm btn-default hide-filter-details\">\n    <span class=\"glyphicon glyphicon-eye-close\"></span>\n    <span data-i18n=\"amp.dashboard:filters-hide-details\">Hide filter details</span>\n  </button>\n</div>\n<% _(applied).each(function(filter) { %>\n  <h5>\n    <a href=\"#filter-detail-<%= filter.id %>\" data-toggle=\"collapse\" aria-expanded=\"false\"><%= filter.name %></a>\n    (<%= filter.detail.length %>)\n  </h5>\n  <ul id=\"filter-detail-<%= filter.id %>\" class=\"collapse\">\n    <% _(filter.detail).each(function(detail) { %>\n      <li><%= detail %></li>\n    <% }) %>\n  </ul>\n<% }) %>");
var filtersViewLog = require('../../../../../../../reamp/tools/log')('amp:dashboards:filters:view');


module.exports = BackboneDash.View.extend({

  events: {
    'click .show-filters': 'showFilter',
    'click .show-filter-details': 'showFilterDetails',
    'click .hide-filter-details': 'hideFilterDetails'
  },

  initialize: function(options) {
    this.finishedFirstLoad = false;
    this.app = options.app;
    this.listenTo(this.app.filter, 'cancel', this.hideFilter);
    this.listenTo(this.app.filter, 'apply', this.applyFilter);
    this.app.settings.load().done(_(function() {
      // Extract default dates from Global Settings.
      var blob = {};
      // AMP-19254, AMP-20537: override the "date" range with the Dashboards-specific one from the settings blob (a hack...)
      this.app.filter.extractDates(this.app.settings.models, blob, 'dashboard-default-min-date', 'dashboard-default-max-date');

      this.app.filter.loaded.done(_(function() {
        console.info('filters loaded');
        this.app.state.register(this, 'filters', {
          // namespace serialized filters so we can hook in extra state to store
          // later if desired (anything dashboards-ui related, for example)
          get: _(function() {
            return {
              filter: this.app.filter.serialize()
            };
          }).bind(this),
          set: _(function(state) {
            if (_.isEmpty(state.filter)){            
              filtersViewLog.log('Using default filter dates.');
              // AMP-21118: Dont override all filters, just dates section.
              state.filter.otherFilters = blob.otherFilters;
            }
            this.app.filter.deserialize(state.filter);
            this.app.filter.finishedFirstLoad = true;
          }).bind(this),
          empty: {
            filter: {}
          }
        });
      }).bind(this));
    }).bind(this));
  },
  render: function() {
    this.$el.html(template());
    this.app.filter.setElement(this.el.querySelector('#filter-popup'));
    this.hideFilter();
    this.app.filter.loaded
      .done(_(this.renderApplied).bind(this))
      .fail(_(function() {
        this.$('.applied-filters').html('<strong class="text-danger filters-err">' +
          'Failed to load filters</strong> <a href="" class="btn btn-warning btn-sm">' +
          '<span class="glyphicon glyphicon-refresh"></span> Refresh page</a>');
        this.$('button').addClass('disabled');
      }).bind(this));
    return this;
  },

  renderApplied: function() {
    var filters = this.app.filter.serializeToModels();
    var countApplied = _(filters.columnFilters).keys().length;
    countApplied += _(filters.otherFilters).keys().length;
    this.$('.applied-filters').html(summaryTemplate({ countApplied: countApplied }));
    this.app.translator.translateDOM(this.el);
  },

  showFilter: function() {
    this.app.filter.showFilters();
    this.$('#filter-popup').show();
  },

  hideFilter: function() {
    this.$('#filter-popup').hide();
  },

  applyFilter: function() {
    // todo: actually do an effect for changed filters...
    this.hideFilter();
    this.renderApplied();
  },

  showFilterDetails: function() {
    var filters = this.app.filter.serializeToModels();
    var applied = _(filters.columnFilters).map(function(filter, key) {
      return {
        name: filter.filterName || key,
        id: key.replace(/[^\w]/g, ''), // remove anything non-alphanum
        detail: _(filter).map(function(value) {
          if (value.attributes !== undefined) {
            return value.get('name');
          } else {
            // To fix problem with dates.
            if (value !== key && value !== filter.filterName) {
              return value;
            }
          }
        })
      };
    });
    if (filters.otherFilters) {
      _.each(Object.keys(filters.otherFilters), function (filterKey) {
          var filterField = filters.otherFilters[filterKey];
          var dateRangeText = '';
          if(filterKey === 'date') {
            dateRangeText = app.translator.translateSync("amp.dashboard:date-range", "Date Range");
          } else if(filterKey === 'computedYear') {
            dateRangeText = app.translator.translateSync("amp.dashboard:computedYear", "Computed Year");
          } else {
            dateRangeText = app.translator.translateSync("amp.dashboard:" + filterKey.replace(/[^\w]/g, '-'), filterKey);
          }
          var detail = filterField.modelType === 'YEAR-SINGLE-VALUE'? filterField.year: this.app.filter.formatDate(filterField.start) + '&mdash;' + this.app.filter.formatDate(filterField.end)
          applied.push({
            id: filterKey.replace(/[^\w]/g, '-'),
            name: dateRangeText,
            detail: [detail]
          });
      });
    }
    this.$('.applied-filters').html(detailsTemplate({ applied: applied }));
    this.app.translator.translateDOM(this.el);
  },

  hideFilterDetails: function() {
    this.renderApplied();
  }

});

},{"../../../../../../../reamp/tools/log":"C:\\Git\\amp\\TEMPLATE\\reamp\\tools\\log\\index.js","../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\main.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');

var StateLoadError = require('amp-state/index').StateLoadError;

var Controls = require('./controls');
var ChartsView = require('./charts');
var Charts = require('../models/charts-collection');
var boilerplate = require('amp-boilerplate');
var HeatMapChart = require('../models/chart-heatmaps');
var TopsChart = require('../models/chart-tops');
var PredictabilityChart = require('../models/chart-aid-predictability');
var FundingTypeChart = require('../models/chart-funding-type');

var template = _.template("<div class=\"container\">\n</div>\n");
var modalTemplate = _.template("<div class=\"modal fade\" id=\"<%= m.id %>\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\n  <div class=\"modal-dialog <%= m.specialClass %>\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\"><span aria-hidden=\"true\">&times;</span><span data-i18n=\"amp.dashboard:close\" class=\"sr-only\">Close</span></button>\n        <h4 class=\"modal-title text-<%= m.tone %>\" data-i18n=\"<%= m.i18nTitle %>\"><%= m.title %></h4>\n      </div>\n      <div class=\"modal-body\">\n        <% if (m.content) { %>\n          <%= m.content %>\n        <% } %>\n        <% if (m.messages) { %>\n          <% _(m.messages).each(function(message) { %>\n            <p><%= message %></p>\n          <% }) %>\n        <% } %>\n      </div>      \n    </div>\n  </div>\n</div>\n");

var EnabledChartsCollection = require('../models/enabled-charts-collection');
var HeatmapsConfigCollection = require('../models/heatmaps-config-collection');

module.exports = BackboneDash.View.extend({

  initialize: function(options) {
    this.app = options.app;
        
    this.app.settings.load();  // maybe should go in render or something
                               // but we already do other fetches on init so...
    this.app.user.fetch();
    this.controls = new Controls({ app: this.app });

    // AMP-19545: We instantiate the collection of enabled charts (from FM) and use it to enable or not each chart.
    var enabledChartsFM = new EnabledChartsCollection();
    enabledChartsFM.fetchData();
    
    // Get config of all heatmaps from backend.
    var heatmapsConfigs = new HeatmapsConfigCollection();
    heatmapsConfigs.fetchData();
    
    if(enabledChartsFM.models[0].get('error') !== undefined) {
        // The same endpoint will send an error if 'DASHBOARDS' is not active in the Feature Manager.
        window.location = '/';
    }
    
    var col = [];
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Top Donors'})) {
    	col.push(new TopsChart(
  	          { name: 'Top Donor Agencies', big: false, view: 'bar' },
  	          { app: this.app, url: '/rest/dashboard/tops/do' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Top Donor Group'})) {
    	col.push(new TopsChart(
  	          { name: 'Top Donor Groups', big: false, view: 'bar' },
  	          { app: this.app, url: '/rest/dashboard/tops/dg' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Top Regions'})) {
    	col.push(new TopsChart(
  	          { name: 'Top Regions', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/re' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Top Sectors'})) {
    	col.push(new TopsChart(
  	          { name: 'Top Sectors', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ps' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Aid Predictability'})) {
    	col.push(new PredictabilityChart(
  	          { name: 'Aid Predictability' },
	          { app: this.app, url: '/rest/dashboard/aid-predictability' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Funding Type'})) {
    	col.push(new FundingTypeChart(
  	          { name: 'Funding Type' },
	          { app: this.app, url: '/rest/dashboard/ftype' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Responsible Organizations'})) {
    	col.push(new TopsChart(
  	          { name: 'Responsible Organizations', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ro' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Beneficiary Agencies'})) {
    	col.push(new TopsChart(
  	          { name: 'Beneficiary Agencies', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ba' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Executing Agencies'})) {
    	col.push(new TopsChart(
  	          { name: 'Executing Agencies', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ea' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Implementing Agencies'})) {
    	col.push(new TopsChart(
  	          { name: 'Implementing Agencies', big: false, view: 'bar' },
	          { app: this.app, url: '/rest/dashboard/tops/ia' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Peace-building and State-building Goals'})) {
    	col.push(new TopsChart(
    			{ name: 'Peace-building and State-building Goals', big: true, showCategoriesInfo: true, view: 'pie' },
    			{ app: this.app, url: '/rest/dashboard/tops/ndd' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Sector Fragmentation'})) {
    	col.push(new HeatMapChart(
  	          { name: 'HeatMap by Sector and Donor Group', title: 'Sector Fragmentation', big: true, view: 'heatmap', heatmap_config: heatmapsConfigs, heatmap_type: 'sector' },
  	          { app: this.app, url: '/rest/dashboard/heat-map/sec' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Location Fragmentation'})) {
    	col.push(new HeatMapChart(
  	          { name: 'HeatMap by Location and Donor Group', title: 'Location Fragmentation', big: true, view: 'heatmap', heatmap_config: heatmapsConfigs, heatmap_type: 'location' },
  	          { app: this.app, url: '/rest/dashboard/heat-map/loc' }));
    }
    if(_.find(enabledChartsFM.models[0].get('DASHBOARDS'), function(item) {return item ===  'Program Fragmentation'})) {
    	col.push(new HeatMapChart(
  	          { name: 'HeatMap by Program and Donor Group', title: 'Program Fragmentation', big: true, view: 'heatmap', heatmap_config: heatmapsConfigs, heatmap_type: 'program' },
  	          { app: this.app, url: '/rest/dashboard/heat-map/prg' }));
    }
       
    var chartsCollection = new Charts(col, { app: this.app });
    this.charts = new ChartsView({
      app: this.app,
      collection: chartsCollection
    });
    
    //auto-renders the layout
    this.headerWidget = new boilerplate.layout(
      {
        caller: 'DASHBOARD'
	  });
  },

  render: function() {
    this.$el.html(template());
    this.$('.container').html([
      this.controls.render().el,
      this.charts.render().el,
    ]);
    return this;
  },

  modal: function(title, options) {
    options = _({
      title: title,
      id: _.uniqueId('modal')
    }).extend(options);
    this.$el.parent().append(modalTemplate({m: options}));
    var thisModal = this.$el.parent().find('#' + options.id);
    if (options.bodyEl) { thisModal.find('.modal-body').html(options.bodyEl); }
    thisModal.modal();
    return thisModal[0];  // the actual DOM element
  }

});

},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","../models/chart-aid-predictability":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-aid-predictability.js","../models/chart-funding-type":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-funding-type.js","../models/chart-heatmaps":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-heatmaps.js","../models/chart-tops":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\chart-tops.js","../models/charts-collection":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\charts-collection.js","../models/enabled-charts-collection":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\enabled-charts-collection.js","../models/heatmaps-config-collection":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\models\\heatmaps-config-collection.js","./charts":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\charts.js","./controls":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\controls.js","amp-boilerplate":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\index.js","amp-state/index":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-state\\index.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\settings-modal.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var logger = require('../../../../../../../reamp/tools/log')('amp:dashboards:settings:modal');
var template = _.template("<div class=\"tab-content filter-options\">\n  <div class=\"tab-pane active\">\n    <ul class=\"sub-filters-titles nav nav-pills nav-stacked\">\n      <% _(settings.getVisible()).each(function(setting) { %>\n        <li <%= setting.id === current.id ? 'class=\"active\"' : '' %>>\n          <a class=\"setting-select\" href=\"#<%= setting.id %>\"><span><%= setting.get('name') %></span></a>\n        </li>\n      <% }) %>\n    </ul>\n    <div class=\"sub-filters-content\">\n      <select class=\"form-control setting-value\">\n        <% _(current.get('options')).each(function(option) { %>\n          <option value=\"<%= option.id %>\" <%= option.selected ? 'selected=\"selected\"' : '' %>><%= option.name %></option>\n        <% }) %>\n      </select>\n    </div>\n  </div>\n</div>\n<div class=\"modal-footer\">\n\t<button type=\"button\" class=\"btn btn-success apply\" data-i18n=\"amp.dashboard:apply\" data-dismiss=\"modal\">Apply</button>\n    <button type=\"button\" class=\"btn btn-primary\" data-i18n=\"amp.dashboard:close\" data-dismiss=\"modal\">Close</button>\n</div>\n");


module.exports = BackboneDash.View.extend({

  events: {
    'click .setting-select': 'selectSetting',
    'change .setting-value': 'changeSetting',
    'click .apply': 'applySettings'
  },

  initialize: function(options) {
    this.app = options.app;
    logger.log("Initialized with", options);
  },

  render: function() {
    if (!this.current) {
      this.current = this.app.settings.getVisible()[0];
      logger.log("Render requested, but there's no  current setting. Trying to guess it");
    }
    this.$el.html(template({
      settings: this.app.settings,
      current: this.current
    }));
    var that = this;
    logger.onDebug(function(){
      logger.log("Rendered width current=", that.current.toJSON());
    });
    return this;
  },

  selectSetting: function(e) {
    e.preventDefault();  // don't change URL
    var settingId = e.currentTarget.hash.slice(1);  // removes '#'
    this.current = this.app.settings.get(settingId);
    var that = this;
    logger.onDebug(function(){
      logger.log("Current setting changed to", that.current.toJSON());
    });
    this.render();
  },

  changeSetting: function(e) {
    var optionId = e.currentTarget.value;
    logger.log("Changing", optionId, "setting"); 
    this.current.select(optionId, false);
  },
  
  applySettings: function(e) {
	  this.current.apply();
  }
});

},{"../../../../../../../reamp/tools/log":"C:\\Git\\amp\\TEMPLATE\\reamp\\tools\\log\\index.js","../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\settings.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var ModalView = require('./settings-modal');
var template = _.template("<div class=\"col-xs-12 col-sm-6 col-md-3\">\n  <div class=\"panel\">\n    <div class=\"panel-body\">\n      <h3 data-i18n=\"amp.dashboard:dashboard-settings\" class=\"inline-heading\" style=\"max-width: 50px;overflow-x: visible\">Settings</h3>\n      <button type=\"button\" class=\"btn btn-sm btn-default pull-right dash-settings-button\">\n        <span class=\"glyphicon glyphicon-edit\"></span>\n        <span data-i18n=\"amp.dashboard:settings-edit\">edit settings</span>\n      </button>\n    </div>\n  </div>\n</div>\n");


module.exports = BackboneDash.View.extend({

  events: {
    'click .dash-settings-button': 'editSettings'
  },

  initialize: function(options) {
    this.app = options.app;
    this.modalView = new ModalView({ app: this.app, collection: this.collection });

    this.app.settings._loaded.done(_(function() {
      this.app.state.register(this, 'settings', {
        get: this.app.settings.toAPI,
        set: this.app.settings.fromState
      });
    }).bind(this));
  },

  render: function() {
    this.$el.html(template());  
    return this;
  },

  editSettings: function() {
	var specialClass = 'dash-settings-modal';
    this.app.modal('Settings', {
      specialClass: specialClass,
      bodyEl: this.modalView.render().el,
      i18nTitle: 'amp.dashboard:dashboard-settings'
    });
    
    // Translate modal popup.
    app.translator.translateDOM($("." + specialClass));
  }

});

},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","./settings-modal":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\settings-modal.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\views\\share.js":[function(require,module,exports){

var _ = require('underscore');
var BackboneDash = require('../backbone-dash');
var template = _.template("<div class=\"col-xs-12 col-sm-6 col-md-4\">\n  <div class=\"panel\">\n    <div class=\"panel-body\">\n      <h3 data-i18n=\"amp.dashboard:share-dashboard-top\" class=\"inline-heading\">Share</h3>\n      <button type=\"button\" class=\"btn btn-sm btn-default pull-right dash-share-button\">\n        <span class=\"glyphicon glyphicon-link\"></span>\n        <span data-i18n=\"amp.dashboard:share-link\">link</span>\n      </button>\n    </div>\n  </div>\n</div>\n\n<div class=\"dash-share-modal modal fade\" id=\"<%= details.id %>\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\n  <div class=\"modal-dialog\">\n    <div class=\"panel panel-primary\">\n      <div class=\"panel-heading fix-title-height\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\"><span aria-hidden=\"true\">&times;</span><span data-i18n=\"amp.dashboard:close\" class=\"sr-only\">Close</span></button>\n        <span data-i18n=\"amp.dashboard:share-dashboard\">Share this dashboard view</span>\n      </div>\n      <div class=\"panel-body\">\n        <form role=\"form\">\n          <label data-i18n=\"amp.dashboard:share-link\" for=\"dash-share-url\">Link</label>\n          <input type=\"url\" class=\"form-control\" id=\"dash-share-url\" />\n        </form>\n      </div>\n      <div class=\"panel-footer\">\n        <button type=\"button\" class=\"btn btn-primary\" data-i18n=\"amp.dashboard:close\" data-dismiss=\"modal\">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n");


module.exports = BackboneDash.View.extend({

  events: {
    'click .dash-share-button': 'share'
  },

  initialize: function(options) {
    this.app = options.app;
  },

  render: function() {
    this.$el.html(template({ details: {} }));
    return this;
  },

  share: function() {
    var saving = app.translator.translateSync("amp.dashboard:saving-state","Saving dashboard state, please wait...");
	  
    this.$('#dash-share-url')
      .attr('disabled', 'disabled')
      .val(saving);

    var stateBlob = this.app.state.freeze();

    this.listenToOnce(this.app.savedDashes, 'request', function(model, xhr) {
      // this has to be set up before .create, so we don't miss it
      xhr
        .done(_(function() {
          var id = model.get('id');
          this.app.url.hash(this.app.state.toHash(id), { silent: true });
          this.$('#dash-share-url')
            .removeAttr('disabled')
            .val(this.app.url.full());
        }).bind(this))
        .fail(_(function() {
          this.$('#dash-share-url').val('Error: could not save dashboard for sharing.');
        }).bind(this));
    });

    this.app.savedDashes.create({  // create does POST
      title: 'Dashboard',
      description: 'Saved dashboard',
      stateBlob: stateBlob
    }, { app: this.app });

    this.$('.dash-share-modal').modal();
  }

});

},{"../backbone-dash":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\app\\backbone-dash.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\lib-load-hacks.js":[function(require,module,exports){
// nvd3 goes global sigh... make sure d3 is already global
/* TODO: in this version of nvd3 v1.7.1, main is not specified in package.json,
 if we ever upgrade to 1.8+, change this back to just require(nvd3) */
require('../../../node_modules/nvd3/build/nv.d3');

// load underscore mixins
require('./underscore-transpose');

// load canvg stuff
window.RGBColor = require('./lib-src/rgbcolor');
require('./lib-src/canvg');


module.exports = {
  canvg: window.canvg
};

},{"../../../node_modules/nvd3/build/nv.d3":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\node_modules\\nvd3\\build\\nv.d3.js","./lib-src/canvg":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\lib-src\\canvg.js","./lib-src/rgbcolor":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\lib-src\\rgbcolor.js","./underscore-transpose":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\underscore-transpose.js"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\lib-src\\canvg.js":[function(require,module,exports){
/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed 
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */
(function(){
    // canvg(target, s)
    // empty parameters: replace all 'svg' elements on page with 'canvas' elements
    // target: canvas element or the id of a canvas element
    // s: svg string, url to svg file, or xml document
    // opts: optional hash of options
    //       ignoreMouse: true => ignore mouse events
    //       ignoreAnimation: true => ignore animations
    //       ignoreDimensions: true => does not try to resize canvas
    //       ignoreClear: true => does not clear canvas
    //       offsetX: int => draws at a x offset
    //       offsetY: int => draws at a y offset
    //       scaleWidth: int => scales horizontally to width
    //       scaleHeight: int => scales vertically to height
    //       renderCallback: function => will call the function after the first render is completed
    //       forceRedraw: function => will call the function on every frame, if it returns true, will redraw
    this.canvg = function (target, s, opts) {
        // no parameters
        if (target == null && s == null && opts == null) {
            var svgTags = document.querySelectorAll('svg');
            for (var i=0; i<svgTags.length; i++) {
                var svgTag = svgTags[i];
                var c = document.createElement('canvas');
                c.width = svgTag.clientWidth;
                c.height = svgTag.clientHeight;
                svgTag.parentNode.insertBefore(c, svgTag);
                svgTag.parentNode.removeChild(svgTag);
                var div = document.createElement('div');
                div.appendChild(svgTag);
                canvg(c, div.innerHTML);
            }
            return;
        }
    
        if (typeof target == 'string') {
            target = document.getElementById(target);
        }
        
        // store class on canvas
        if (target.svg != null) target.svg.stop();
        var svg = build(opts || {});
        // on i.e. 8 for flash canvas, we can't assign the property so check for it
        if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;
        
        var ctx = target.getContext('2d');
        if (typeof(s.documentElement) != 'undefined') {
            // load from xml doc
            svg.loadXmlDoc(ctx, s);
        }
        else if (s.substr(0,1) == '<') {
            // load from xml string
            svg.loadXml(ctx, s);
        }
        else {
            // load from url
            svg.load(ctx, s);
        }
    }

    function build(opts) {
        var svg = { opts: opts };
        
        svg.FRAMERATE = 30;
        svg.MAX_VIRTUAL_PIXELS = 30000;
        
        svg.log = function(msg) {};
        if (svg.opts['log'] == true && typeof(console) != 'undefined') {
            svg.log = function(msg) { console.log(msg); };
        };
        
        // globals
        svg.init = function(ctx) {
            var uniqueId = 0;
            svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId; };
            svg.Definitions = {};
            svg.Styles = {};
            svg.Animations = [];
            svg.Images = [];
            svg.ctx = ctx;
            svg.ViewPort = new (function () {
                this.viewPorts = [];
                this.Clear = function() { this.viewPorts = []; }
                this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }
                this.RemoveCurrent = function() { this.viewPorts.pop(); }
                this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }
                this.width = function() { return this.Current().width; }
                this.height = function() { return this.Current().height; }
                this.ComputeSize = function(d) {
                    if (d != null && typeof(d) == 'number') return d;
                    if (d == 'x') return this.width();
                    if (d == 'y') return this.height();
                    return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);            
                }
            });
        }
        svg.init();
        
        // images loaded
        svg.ImagesLoaded = function() { 
            for (var i=0; i<svg.Images.length; i++) {
                if (!svg.Images[i].loaded) return false;
            }
            return true;
        }

        // trim
        svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }
        
        // compress spaces
        svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }
        
        // ajax
        svg.ajax = function(url) {
            var AJAX;
            if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
            else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
            if(AJAX){
               AJAX.open('GET',url,false);
               AJAX.send(null);
               return AJAX.responseText;
            }
            return null;
        } 
        
        // parse xml
        svg.parseXml = function(xml) {
            if (typeof(Windows) != 'undefined' && typeof(Windows.Data) != 'undefined' && typeof(Windows.Data.Xml) != 'undefined') {
                var xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();
                var settings = new Windows.Data.Xml.Dom.XmlLoadSettings();
                settings.prohibitDtd = false;
                xmlDoc.loadXml(xml, settings);
                return xmlDoc;
            }
            else if (window.DOMParser)
            {
                var parser = new DOMParser();
                return parser.parseFromString(xml, 'text/xml');
            }
            else 
            {
                xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
                var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
                xmlDoc.async = 'false';
                xmlDoc.loadXML(xml); 
                return xmlDoc;
            }       
        }
        
        svg.Property = function(name, value) {
            this.name = name;
            this.value = value;
        }   
            svg.Property.prototype.getValue = function() {
                return this.value;
            }
        
            svg.Property.prototype.hasValue = function() {
                return (this.value != null && this.value !== '');
            }
                            
            // return the numerical value of the property
            svg.Property.prototype.numValue = function() {
                if (!this.hasValue()) return 0;
                
                var n = parseFloat(this.value);
                if ((this.value + '').match(/%$/)) {
                    n = n / 100.0;
                }
                return n;
            }
            
            svg.Property.prototype.valueOrDefault = function(def) {
                if (this.hasValue()) return this.value;
                return def;
            }
            
            svg.Property.prototype.numValueOrDefault = function(def) {
                if (this.hasValue()) return this.numValue();
                return def;
            }
            
            // color extensions
                // augment the current color value with the opacity
                svg.Property.prototype.addOpacity = function(opacityProp) {
                    var newValue = this.value;
                    if (opacityProp.value != null && opacityProp.value != '' && typeof(this.value)=='string') { // can only add opacity to colors, not patterns
                        var color = new RGBColor(this.value);
                        if (color.ok) {
                            newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';
                        }
                    }
                    return new svg.Property(this.name, newValue);
                }
            
            // definition extensions
                // get the definition from the definitions table
                svg.Property.prototype.getDefinition = function() {
                    var name = this.value.match(/#([^\)'"]+)/);
                    if (name) { name = name[1]; }
                    if (!name) { name = this.value; }
                    return svg.Definitions[name];
                }
                
                svg.Property.prototype.isUrlDefinition = function() {
                    return this.value.indexOf('url(') == 0
                }
                
                svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
                    var def = this.getDefinition();
                    
                    // gradient
                    if (def != null && def.createGradient) {
                        return def.createGradient(svg.ctx, e, opacityProp);
                    }
                    
                    // pattern
                    if (def != null && def.createPattern) {
                        if (def.getHrefAttribute().hasValue()) {
                            var pt = def.attribute('patternTransform');
                            def = def.getHrefAttribute().getDefinition();
                            if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
                        }
                        return def.createPattern(svg.ctx, e);
                    }
                    
                    return null;
                }
            
            // length extensions
                svg.Property.prototype.getDPI = function(viewPort) {
                    return 96.0; // TODO: compute?
                }
                
                svg.Property.prototype.getEM = function(viewPort) {
                    var em = 12;
                    
                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);
                    
                    return em;
                }
                
                svg.Property.prototype.getUnits = function() {
                    var s = this.value+'';
                    return s.replace(/[0-9\.\-]/g,'');
                }
            
                // get the length as pixels
                svg.Property.prototype.toPixels = function(viewPort, processPercent) {
                    if (!this.hasValue()) return 0;
                    var s = this.value+'';
                    if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
                    if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
                    if (s.match(/px$/)) return this.numValue();
                    if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
                    if (s.match(/pc$/)) return this.numValue() * 15;
                    if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
                    if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
                    if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
                    if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
                    var n = this.numValue();
                    if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
                    return n;
                }

            // time extensions
                // get the time as milliseconds
                svg.Property.prototype.toMilliseconds = function() {
                    if (!this.hasValue()) return 0;
                    var s = this.value+'';
                    if (s.match(/s$/)) return this.numValue() * 1000;
                    if (s.match(/ms$/)) return this.numValue();
                    return this.numValue();
                }
            
            // angle extensions
                // get the angle as radians
                svg.Property.prototype.toRadians = function() {
                    if (!this.hasValue()) return 0;
                    var s = this.value+'';
                    if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
                    if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
                    if (s.match(/rad$/)) return this.numValue();
                    return this.numValue() * (Math.PI / 180.0);
                }
        
            // text extensions
                // get the text baseline
                var textBaselineMapping = {
                    'baseline': 'alphabetic',
                    'before-edge': 'top',
                    'text-before-edge': 'top',
                    'middle': 'middle',
                    'central': 'middle',
                    'after-edge': 'bottom',
                    'text-after-edge': 'bottom',
                    'ideographic': 'ideographic',
                    'alphabetic': 'alphabetic',
                    'hanging': 'hanging',
                    'mathematical': 'alphabetic'
                };
                svg.Property.prototype.toTextBaseline = function () {
                    if (!this.hasValue()) return null;
                    return textBaselineMapping[this.value];
                }
                
        // fonts
        svg.Font = new (function() {
            this.Styles = 'normal|italic|oblique|inherit';
            this.Variants = 'normal|small-caps|inherit';
            this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';
            
            this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
                var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
                return { 
                    fontFamily: fontFamily || f.fontFamily, 
                    fontSize: fontSize || f.fontSize, 
                    fontStyle: fontStyle || f.fontStyle, 
                    fontWeight: fontWeight || f.fontWeight, 
                    fontVariant: fontVariant || f.fontVariant,
                    toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') } 
                } 
            }
            
            var that = this;
            this.Parse = function(s) {
                var f = {};
                var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
                var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
                var ff = '';
                for (var i=0; i<d.length; i++) {
                    if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
                    else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;  }
                    else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
                    else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
                    else { if (d[i] != 'inherit') ff += d[i]; }
                } if (ff != '') f.fontFamily = ff;
                return f;
            }
        });
        
        // points and paths
        svg.ToNumberArray = function(s) {
            var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
            for (var i=0; i<a.length; i++) {
                a[i] = parseFloat(a[i]);
            }
            return a;
        }       
        svg.Point = function(x, y) {
            this.x = x;
            this.y = y;
        }   
            svg.Point.prototype.angleTo = function(p) {
                return Math.atan2(p.y - this.y, p.x - this.x);
            }
            
            svg.Point.prototype.applyTransform = function(v) {
                var xp = this.x * v[0] + this.y * v[2] + v[4];
                var yp = this.x * v[1] + this.y * v[3] + v[5];
                this.x = xp;
                this.y = yp;
            }

        svg.CreatePoint = function(s) {
            var a = svg.ToNumberArray(s);
            return new svg.Point(a[0], a[1]);
        }
        svg.CreatePath = function(s) {
            var a = svg.ToNumberArray(s);
            var path = [];
            for (var i=0; i<a.length; i+=2) {
                path.push(new svg.Point(a[i], a[i+1]));
            }
            return path;
        }
        
        // bounding box
        svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
            this.x1 = Number.NaN;
            this.y1 = Number.NaN;
            this.x2 = Number.NaN;
            this.y2 = Number.NaN;
            
            this.x = function() { return this.x1; }
            this.y = function() { return this.y1; }
            this.width = function() { return this.x2 - this.x1; }
            this.height = function() { return this.y2 - this.y1; }
            
            this.addPoint = function(x, y) {    
                if (x != null) {
                    if (isNaN(this.x1) || isNaN(this.x2)) {
                        this.x1 = x;
                        this.x2 = x;
                    }
                    if (x < this.x1) this.x1 = x;
                    if (x > this.x2) this.x2 = x;
                }
            
                if (y != null) {
                    if (isNaN(this.y1) || isNaN(this.y2)) {
                        this.y1 = y;
                        this.y2 = y;
                    }
                    if (y < this.y1) this.y1 = y;
                    if (y > this.y2) this.y2 = y;
                }
            }           
            this.addX = function(x) { this.addPoint(x, null); }
            this.addY = function(y) { this.addPoint(null, y); }
            
            this.addBoundingBox = function(bb) {
                this.addPoint(bb.x1, bb.y1);
                this.addPoint(bb.x2, bb.y2);
            }
            
            this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
                var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
                var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
                var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
                var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
                this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
            }
            
            this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
                // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
                var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
                this.addPoint(p0[0], p0[1]);
                this.addPoint(p3[0], p3[1]);
                
                for (i=0; i<=1; i++) {
                    var f = function(t) { 
                        return Math.pow(1-t, 3) * p0[i]
                        + 3 * Math.pow(1-t, 2) * t * p1[i]
                        + 3 * (1-t) * Math.pow(t, 2) * p2[i]
                        + Math.pow(t, 3) * p3[i];
                    }
                    
                    var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                    var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                    var c = 3 * p1[i] - 3 * p0[i];
                    
                    if (a == 0) {
                        if (b == 0) continue;
                        var t = -c / b;
                        if (0 < t && t < 1) {
                            if (i == 0) this.addX(f(t));
                            if (i == 1) this.addY(f(t));
                        }
                        continue;
                    }
                    
                    var b2ac = Math.pow(b, 2) - 4 * c * a;
                    if (b2ac < 0) continue;
                    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                        if (i == 0) this.addX(f(t1));
                        if (i == 1) this.addY(f(t1));
                    }
                    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t2 && t2 < 1) {
                        if (i == 0) this.addX(f(t2));
                        if (i == 1) this.addY(f(t2));
                    }
                }
            }
            
            this.isPointInBox = function(x, y) {
                return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
            }
            
            this.addPoint(x1, y1);
            this.addPoint(x2, y2);
        }
        
        // transforms
        svg.Transform = function(v) {   
            var that = this;
            this.Type = {}
        
            // translate
            this.Type.translate = function(s) {
                this.p = svg.CreatePoint(s);            
                this.apply = function(ctx) {
                    ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
                }
                this.unapply = function(ctx) {
                    ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                }
            }
            
            // rotate
            this.Type.rotate = function(s) {
                var a = svg.ToNumberArray(s);
                this.angle = new svg.Property('angle', a[0]);
                this.cx = a[1] || 0;
                this.cy = a[2] || 0;
                this.apply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                }
                this.unapply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(-1.0 * this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                }
                this.applyToPoint = function(p) {
                    var a = this.angle.toRadians();
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                    p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
                    p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
                }           
            }
            
            this.Type.scale = function(s) {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx) {
                    ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
                }
                this.unapply = function(ctx) {
                    ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
                }               
            }
            
            this.Type.matrix = function(s) {
                this.m = svg.ToNumberArray(s);
                this.apply = function(ctx) {
                    ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
                }
                this.unapply = function(ctx) {
                    var a = this.m[0];
                    var b = this.m[2];
                    var c = this.m[4];
                    var d = this.m[1];
                    var e = this.m[3];
                    var f = this.m[5];
                    var g = 0.0;
                    var h = 0.0;
                    var i = 1.0;
                    var det = 1 / (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g));
                    ctx.transform(
                        det*(e*i-f*h),
                        det*(f*g-d*i),
                        det*(c*h-b*i),
                        det*(a*i-c*g),
                        det*(b*f-c*e),
                        det*(c*d-a*f)
                    );
                }
                this.applyToPoint = function(p) {
                    p.applyTransform(this.m);
                }                   
            }
            
            this.Type.SkewBase = function(s) {
                this.base = that.Type.matrix;
                this.base(s);
                this.angle = new svg.Property('angle', s);
            }
            this.Type.SkewBase.prototype = new this.Type.matrix;
            
            this.Type.skewX = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
            }
            this.Type.skewX.prototype = new this.Type.SkewBase;
            
            this.Type.skewY = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
            }
            this.Type.skewY.prototype = new this.Type.SkewBase;
        
            this.transforms = [];
            
            this.apply = function(ctx) {
                for (var i=0; i<this.transforms.length; i++) {
                    this.transforms[i].apply(ctx);
                }
            }
            
            this.unapply = function(ctx) {
                for (var i=this.transforms.length-1; i>=0; i--) {
                    this.transforms[i].unapply(ctx);
                }
            }
            
            this.applyToPoint = function(p) {
                for (var i=0; i<this.transforms.length; i++) {
                    this.transforms[i].applyToPoint(p);
                }
            }
            
            var data = svg.trim(svg.compressSpaces(v)).replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
            for (var i=0; i<data.length; i++) {
                var type = svg.trim(data[i].split('(')[0]);
                var s = data[i].split('(')[1].replace(')','');
                var transform = new this.Type[type](s);
                transform.type = type;
                this.transforms.push(transform);
            }
        }
        
        // aspect ratio
        svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
            // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
            aspectRatio = svg.compressSpaces(aspectRatio);
            aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
            var align = aspectRatio.split(' ')[0] || 'xMidYMid';
            var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';                  
    
            // calculate scale
            var scaleX = width / desiredWidth;
            var scaleY = height / desiredHeight;
            var scaleMin = Math.min(scaleX, scaleY);
            var scaleMax = Math.max(scaleX, scaleY);
            if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
            if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }    
            
            refX = new svg.Property('refX', refX);
            refY = new svg.Property('refY', refY);
            if (refX.hasValue() && refY.hasValue()) {               
                ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
            } 
            else {                  
                // align
                if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0); 
                if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0); 
                if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0); 
                if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight); 
            }
            
            // scale
            if (align == 'none') ctx.scale(scaleX, scaleY);
            else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin); 
            else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);     
            
            // translate
            ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);          
        }
        
        // elements
        svg.Element = {}
        
        svg.EmptyProperty = new svg.Property('EMPTY', '');
        
        svg.Element.ElementBase = function(node) {  
            this.attributes = {};
            this.styles = {};
            this.children = [];
            
            // get or create attribute
            this.attribute = function(name, createIfNotExists) {
                var a = this.attributes[name];
                if (a != null) return a;
                            
                if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
                return a || svg.EmptyProperty;
            }
            
            this.getHrefAttribute = function() {
                for (var a in this.attributes) { 
                    if (a.match(/:href$/)) { 
                        return this.attributes[a]; 
                    } 
                }
                return svg.EmptyProperty;
            }
            
            // get or create style, crawls up node tree
            this.style = function(name, createIfNotExists, skipAncestors) {
                var s = this.styles[name];
                if (s != null) return s;
                
                var a = this.attribute(name);
                if (a != null && a.hasValue()) {
                    this.styles[name] = a; // move up to me to cache
                    return a;
                }
                
                if (skipAncestors != true) {
                    var p = this.parent;
                    if (p != null) {
                        var ps = p.style(name);
                        if (ps != null && ps.hasValue()) {
                            return ps;
                        }
                    }
                }
                    
                if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
                return s || svg.EmptyProperty;
            }
            
            // base render
            this.render = function(ctx) {
                // don't render display=none
                if (this.style('display').value == 'none') return;
                
                // don't render visibility=hidden
                if (this.style('visibility').value == 'hidden') return;
            
                ctx.save();
                if (this.attribute('mask').hasValue()) { // mask
                    var mask = this.attribute('mask').getDefinition();
                    if (mask != null) mask.apply(ctx, this);
                }
                else if (this.style('filter').hasValue()) { // filter
                    var filter = this.style('filter').getDefinition();
                    if (filter != null) filter.apply(ctx, this);
                }
                else {  
                    this.setContext(ctx);
                    this.renderChildren(ctx);   
                    this.clearContext(ctx);                         
                }
                ctx.restore();
            }
            
            // base set context
            this.setContext = function(ctx) {
                // OVERRIDE ME!
            }
            
            // base clear context
            this.clearContext = function(ctx) {
                // OVERRIDE ME!
            }           
            
            // base render children
            this.renderChildren = function(ctx) {
                for (var i=0; i<this.children.length; i++) {
                    this.children[i].render(ctx);
                }
            }
            
            this.addChild = function(childNode, create) {
                var child = childNode;
                if (create) child = svg.CreateElement(childNode);
                child.parent = this;
                if (child.type != 'title') { this.children.push(child); }
            }
                
            if (node != null && node.nodeType == 1) { //ELEMENT_NODE
                // add attributes
                for (var i=0; i<node.attributes.length; i++) {
                    var attribute = node.attributes[i];
                    this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.nodeValue);
                }
                                        
                // add tag styles
                var styles = svg.Styles[node.nodeName];
                if (styles != null) {
                    for (var name in styles) {
                        this.styles[name] = styles[name];
                    }
                }                   
                
                // add class styles
                if (this.attribute('class').hasValue()) {
                    var classes = svg.compressSpaces(this.attribute('class').value).split(' ');
                    for (var j=0; j<classes.length; j++) {
                        styles = svg.Styles['.'+classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name];
                            }
                        }
                        styles = svg.Styles[node.nodeName+'.'+classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name];
                            }
                        }
                    }
                }
                
                // add id styles
                if (this.attribute('id').hasValue()) {
                    var styles = svg.Styles['#' + this.attribute('id').value];
                    if (styles != null) {
                        for (var name in styles) {
                            this.styles[name] = styles[name];
                        }
                    }
                }
                
                // add inline styles
                if (this.attribute('style').hasValue()) {
                    var styles = this.attribute('style').value.split(';');
                    for (var i=0; i<styles.length; i++) {
                        if (svg.trim(styles[i]) != '') {
                            var style = styles[i].split(':');
                            var name = svg.trim(style[0]);
                            var value = svg.trim(style[1]);
                            this.styles[name] = new svg.Property(name, value);
                        }
                    }
                }   

                // add id
                if (this.attribute('id').hasValue()) {
                    if (svg.Definitions[this.attribute('id').value] == null) {
                        svg.Definitions[this.attribute('id').value] = this;
                    }
                }
                
                // add children
                for (var i=0; i<node.childNodes.length; i++) {
                    var childNode = node.childNodes[i];
                    if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
                    if (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {
                        var text = childNode.nodeValue || childNode.text || '';
                        if (svg.trim(svg.compressSpaces(text)) != '') {
                            this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
                        }
                    }
                }
            }
        }
        
        svg.Element.RenderedElementBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.setContext = function(ctx) {
                // fill
                if (this.style('fill').isUrlDefinition()) {
                    var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
                    if (fs != null) ctx.fillStyle = fs;
                }
                else if (this.style('fill').hasValue()) {
                    var fillStyle = this.style('fill');
                    if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
                    ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
                }
                if (this.style('fill-opacity').hasValue()) {
                    var fillStyle = new svg.Property('fill', ctx.fillStyle);
                    fillStyle = fillStyle.addOpacity(this.style('fill-opacity'));
                    ctx.fillStyle = fillStyle.value;
                }
                                    
                // stroke
                if (this.style('stroke').isUrlDefinition()) {
                    var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
                    if (fs != null) ctx.strokeStyle = fs;
                }
                else if (this.style('stroke').hasValue()) {
                    var strokeStyle = this.style('stroke');
                    if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
                    ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
                }
                if (this.style('stroke-opacity').hasValue()) {
                    var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
                    strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));
                    ctx.strokeStyle = strokeStyle.value;
                }
                if (this.style('stroke-width').hasValue()) {
                    var newLineWidth = this.style('stroke-width').toPixels();
                    ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
                }
                if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
                if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
                if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
                if (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {
                    var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
                    if (typeof(ctx.setLineDash) != 'undefined') { ctx.setLineDash(gaps); }
                    else if (typeof(ctx.webkitLineDash) != 'undefined') { ctx.webkitLineDash = gaps; }
                    else if (typeof(ctx.mozDash) != 'undefined' && !(gaps.length==1 && gaps[0]==0)) { ctx.mozDash = gaps; }
                    
                    var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
                    if (typeof(ctx.lineDashOffset) != 'undefined') { ctx.lineDashOffset = offset; }
                    else if (typeof(ctx.webkitLineDashOffset) != 'undefined') { ctx.webkitLineDashOffset = offset; }
                    else if (typeof(ctx.mozDashOffset) != 'undefined') { ctx.mozDashOffset = offset; }
                }

                // font
                if (typeof(ctx.font) != 'undefined') {
                    ctx.font = svg.Font.CreateFont( 
                        this.style('font-style').value, 
                        this.style('font-variant').value, 
                        this.style('font-weight').value, 
                        this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '', 
                        this.style('font-family').value).toString();
                }
                
                // transform
                if (this.attribute('transform').hasValue()) { 
                    var transform = new svg.Transform(this.attribute('transform').value);
                    transform.apply(ctx);
                }
                
                // clip
                if (this.style('clip-path', false, true).hasValue()) {
                    var clip = this.style('clip-path', false, true).getDefinition();
                    if (clip != null) clip.apply(ctx);
                }
                
                // opacity
                if (this.style('opacity').hasValue()) {
                    ctx.globalAlpha = this.style('opacity').numValue();
                }
            }       
        }
        svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;
        
        svg.Element.PathElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                if (ctx != null) ctx.beginPath();
                return new svg.BoundingBox();
            }
            
            this.renderChildren = function(ctx) {
                this.path(ctx);
                svg.Mouse.checkPath(this, ctx);
                if (ctx.fillStyle != '') {
                    if (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') { ctx.fill(this.style('fill-rule').value); }
                    else { ctx.fill(); }
                }
                if (ctx.strokeStyle != '') ctx.stroke();
                
                var markers = this.getMarkers();
                if (markers != null) {
                    if (this.style('marker-start').isUrlDefinition()) {
                        var marker = this.style('marker-start').getDefinition();
                        marker.render(ctx, markers[0][0], markers[0][1]);
                    }
                    if (this.style('marker-mid').isUrlDefinition()) {
                        var marker = this.style('marker-mid').getDefinition();
                        for (var i=1;i<markers.length-1;i++) {
                            marker.render(ctx, markers[i][0], markers[i][1]);
                        }
                    }
                    if (this.style('marker-end').isUrlDefinition()) {
                        var marker = this.style('marker-end').getDefinition();
                        marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
                    }
                }                   
            }
            
            this.getBoundingBox = function() {
                return this.path();
            }
            
            this.getMarkers = function() {
                return null;
            }
        }
        svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;
        
        // svg element
        svg.Element.svg = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseClearContext = this.clearContext;
            this.clearContext = function(ctx) {
                this.baseClearContext(ctx);
                svg.ViewPort.RemoveCurrent();
            }
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                // initial values and defaults
                ctx.strokeStyle = 'rgba(0,0,0,0)';
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'miter';
                ctx.miterLimit = 4; 
                if (typeof(ctx.font) != 'undefined' && typeof(window.getComputedStyle) != 'undefined') {
                    ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');
                }
            
                this.baseSetContext(ctx);
                
                // create new view port
                if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
                if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
                ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));
                
                var width = svg.ViewPort.width();
                var height = svg.ViewPort.height();
                
                if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
                if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
                if (typeof(this.root) == 'undefined') {
                    width = this.attribute('width').toPixels('x');
                    height = this.attribute('height').toPixels('y');
                    
                    var x = 0;
                    var y = 0;
                    if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
                        x = -this.attribute('refX').toPixels('x');
                        y = -this.attribute('refY').toPixels('y');
                    }
                    
                    if (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(width, y);
                        ctx.lineTo(width, height);
                        ctx.lineTo(x, height);
                        ctx.closePath();
                        ctx.clip();
                    }
                }
                svg.ViewPort.SetCurrent(width, height); 
                        
                // viewbox
                if (this.attribute('viewBox').hasValue()) {             
                    var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
                    var minX = viewBox[0];
                    var minY = viewBox[1];
                    width = viewBox[2];
                    height = viewBox[3];
                    
                    svg.AspectRatio(ctx,
                                    this.attribute('preserveAspectRatio').value, 
                                    svg.ViewPort.width(), 
                                    width,
                                    svg.ViewPort.height(),
                                    height,
                                    minX,
                                    minY,
                                    this.attribute('refX').value,
                                    this.attribute('refY').value);
                    
                    svg.ViewPort.RemoveCurrent();
                    svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
                }               
            }
        }
        svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

        // rect element
        svg.Element.rect = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                var rx = this.attribute('rx').toPixels('x');
                var ry = this.attribute('ry').toPixels('y');
                if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
                if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
                rx = Math.min(rx, width / 2.0);
                ry = Math.min(ry, height / 2.0);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(x + rx, y);
                    ctx.lineTo(x + width - rx, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
                    ctx.lineTo(x + width, y + height - ry);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
                    ctx.lineTo(x + rx, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
                    ctx.lineTo(x, y + ry);
                    ctx.quadraticCurveTo(x, y, x + rx, y)
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        }
        svg.Element.rect.prototype = new svg.Element.PathElementBase;
        
        // circle element
        svg.Element.circle = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var cx = this.attribute('cx').toPixels('x');
                var cy = this.attribute('cy').toPixels('y');
                var r = this.attribute('r').toPixels();
            
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2, true); 
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
            }
        }
        svg.Element.circle.prototype = new svg.Element.PathElementBase; 

        // ellipse element
        svg.Element.ellipse = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
                var rx = this.attribute('rx').toPixels('x');
                var ry = this.attribute('ry').toPixels('y');
                var cx = this.attribute('cx').toPixels('x');
                var cy = this.attribute('cy').toPixels('y');
                
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - ry);
                    ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
                    ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
                    ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
                    ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
            }
        }
        svg.Element.ellipse.prototype = new svg.Element.PathElementBase;            
        
        // line element
        svg.Element.line = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.getPoints = function() {
                return [
                    new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
                    new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
            }
                                
            this.path = function(ctx) {
                var points = this.getPoints();
                
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                }
                
                return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
            }
            
            this.getMarkers = function() {
                var points = this.getPoints();  
                var a = points[0].angleTo(points[1]);
                return [[points[0], a], [points[1], a]];
            }
        }
        svg.Element.line.prototype = new svg.Element.PathElementBase;       
                
        // polyline element
        svg.Element.polyline = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.points = svg.CreatePath(this.attribute('points').value);
            this.path = function(ctx) {
                var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                }
                for (var i=1; i<this.points.length; i++) {
                    bb.addPoint(this.points[i].x, this.points[i].y);
                    if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                return bb;
            }
            
            this.getMarkers = function() {
                var markers = [];
                for (var i=0; i<this.points.length - 1; i++) {
                    markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
                }
                markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
                return markers;
            }           
        }
        svg.Element.polyline.prototype = new svg.Element.PathElementBase;               
                
        // polygon element
        svg.Element.polygon = function(node) {
            this.base = svg.Element.polyline;
            this.base(node);
            
            this.basePath = this.path;
            this.path = function(ctx) {
                var bb = this.basePath(ctx);
                if (ctx != null) {
                    ctx.lineTo(this.points[0].x, this.points[0].y);
                    ctx.closePath();
                }
                return bb;
            }
        }
        svg.Element.polygon.prototype = new svg.Element.polyline;

        // path element
        svg.Element.path = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
                    
            var d = this.attribute('d').value;
            // TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
            d = d.replace(/,/gm,' '); // get rid of all commas
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // separate commands from points
            d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from points
            d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits when no comma
            d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when no comma
            d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
            d = svg.compressSpaces(d); // compress multiple spaces
            d = svg.trim(d);
            this.PathParser = new (function(d) {
                this.tokens = d.split(' ');
                
                this.reset = function() {
                    this.i = -1;
                    this.command = '';
                    this.previousCommand = '';
                    this.start = new svg.Point(0, 0);
                    this.control = new svg.Point(0, 0);
                    this.current = new svg.Point(0, 0);
                    this.points = [];
                    this.angles = [];
                }
                                
                this.isEnd = function() {
                    return this.i >= this.tokens.length - 1;
                }
                
                this.isCommandOrEnd = function() {
                    if (this.isEnd()) return true;
                    return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
                }
                
                this.isRelativeCommand = function() {
                    switch(this.command)
                    {
                        case 'm':
                        case 'l':
                        case 'h':
                        case 'v':
                        case 'c':
                        case 's':
                        case 'q':
                        case 't':
                        case 'a':
                        case 'z':
                            return true;
                            break;
                    }
                    return false;
                }
                            
                this.getToken = function() {
                    this.i++;
                    return this.tokens[this.i];
                }
                
                this.getScalar = function() {
                    return parseFloat(this.getToken());
                }
                
                this.nextCommand = function() {
                    this.previousCommand = this.command;
                    this.command = this.getToken();
                }               
                
                this.getPoint = function() {
                    var p = new svg.Point(this.getScalar(), this.getScalar());
                    return this.makeAbsolute(p);
                }
                
                this.getAsControlPoint = function() {
                    var p = this.getPoint();
                    this.control = p;
                    return p;
                }
                
                this.getAsCurrentPoint = function() {
                    var p = this.getPoint();
                    this.current = p;
                    return p;   
                }
                
                this.getReflectedControlPoint = function() {
                    if (this.previousCommand.toLowerCase() != 'c' && 
                        this.previousCommand.toLowerCase() != 's' &&
                        this.previousCommand.toLowerCase() != 'q' && 
                        this.previousCommand.toLowerCase() != 't' ){
                        return this.current;
                    }
                    
                    // reflect point
                    var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);                    
                    return p;
                }
                
                this.makeAbsolute = function(p) {
                    if (this.isRelativeCommand()) {
                        p.x += this.current.x;
                        p.y += this.current.y;
                    }
                    return p;
                }
                
                this.addMarker = function(p, from, priorTo) {
                    // if the last angle isn't filled in because we didn't have this point yet ...
                    if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
                        this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
                    }
                    this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
                }
                
                this.addMarkerAngle = function(p, a) {
                    this.points.push(p);
                    this.angles.push(a);
                }               
                
                this.getMarkerPoints = function() { return this.points; }
                this.getMarkerAngles = function() {
                    for (var i=0; i<this.angles.length; i++) {
                        if (this.angles[i] == null) {
                            for (var j=i+1; j<this.angles.length; j++) {
                                if (this.angles[j] != null) {
                                    this.angles[i] = this.angles[j];
                                    break;
                                }
                            }
                        }
                    }
                    return this.angles;
                }
            })(d);

            this.path = function(ctx) {
                var pp = this.PathParser;
                pp.reset();

                var bb = new svg.BoundingBox();
                if (ctx != null) ctx.beginPath();
                while (!pp.isEnd()) {
                    pp.nextCommand();
                    switch (pp.command) {
                    case 'M':
                    case 'm':
                        var p = pp.getAsCurrentPoint();
                        pp.addMarker(p);
                        bb.addPoint(p.x, p.y);
                        if (ctx != null) ctx.moveTo(p.x, p.y);
                        pp.start = pp.current;
                        while (!pp.isCommandOrEnd()) {
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p, pp.start);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null) ctx.lineTo(p.x, p.y);
                        }
                        break;
                    case 'L':
                    case 'l':
                        while (!pp.isCommandOrEnd()) {
                            var c = pp.current;
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p, c);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null) ctx.lineTo(p.x, p.y);
                        }
                        break;
                    case 'H':
                    case 'h':
                        while (!pp.isCommandOrEnd()) {
                            var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
                            pp.addMarker(newP, pp.current);
                            pp.current = newP;
                            bb.addPoint(pp.current.x, pp.current.y);
                            if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                        }
                        break;
                    case 'V':
                    case 'v':
                        while (!pp.isCommandOrEnd()) {
                            var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
                            pp.addMarker(newP, pp.current);
                            pp.current = newP;
                            bb.addPoint(pp.current.x, pp.current.y);
                            if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                        }
                        break;
                    case 'C':
                    case 'c':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var p1 = pp.getPoint();
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, p1);
                            bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'S':
                    case 's':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var p1 = pp.getReflectedControlPoint();
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, p1);
                            bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'Q':
                    case 'q':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, cntrl);
                            bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'T':
                    case 't':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var cntrl = pp.getReflectedControlPoint();
                            pp.control = cntrl;
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, cntrl);
                            bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'A':
                    case 'a':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var rx = pp.getScalar();
                            var ry = pp.getScalar();
                            var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
                            var largeArcFlag = pp.getScalar();
                            var sweepFlag = pp.getScalar();
                            var cp = pp.getAsCurrentPoint();

                            // Conversion from endpoint to center parameterization
                            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                            // x1', y1'
                            var currp = new svg.Point(
                                Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
                                -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
                            );
                            // adjust radii
                            var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
                            if (l > 1) {
                                rx *= Math.sqrt(l);
                                ry *= Math.sqrt(l);
                            }
                            // cx', cy'
                            var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
                                ((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
                                (Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
                            );
                            if (isNaN(s)) s = 0;
                            var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
                            // cx, cy
                            var centp = new svg.Point(
                                (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
                                (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
                            );
                            // vector magnitude
                            var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
                            // ratio between two vectors
                            var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
                            // angle between two vectors
                            var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
                            // initial angle
                            var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
                            // angle delta
                            var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
                            var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
                            var ad = a(u, v);
                            if (r(u,v) <= -1) ad = Math.PI;
                            if (r(u,v) >= 1) ad = 0;

                            // for markers
                            var dir = 1 - sweepFlag ? 1.0 : -1.0;
                            var ah = a1 + dir * (ad / 2.0);
                            var halfWay = new svg.Point(
                                centp.x + rx * Math.cos(ah),
                                centp.y + ry * Math.sin(ah)
                            );
                            pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
                            pp.addMarkerAngle(cp, ah - dir * Math.PI);

                            bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
                            if (ctx != null) {
                                var r = rx > ry ? rx : ry;
                                var sx = rx > ry ? 1 : rx / ry;
                                var sy = rx > ry ? ry / rx : 1;

                                ctx.translate(centp.x, centp.y);
                                ctx.rotate(xAxisRotation);
                                ctx.scale(sx, sy);
                                ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                                ctx.scale(1/sx, 1/sy);
                                ctx.rotate(-xAxisRotation);
                                ctx.translate(-centp.x, -centp.y);
                            }
                        }
                        break;
                    case 'Z':
                    case 'z':
                        if (ctx != null) ctx.closePath();
                        pp.current = pp.start;
                    }
                }

                return bb;
            }

            this.getMarkers = function() {
                var points = this.PathParser.getMarkerPoints();
                var angles = this.PathParser.getMarkerAngles();
                
                var markers = [];
                for (var i=0; i<points.length; i++) {
                    markers.push([points[i], angles[i]]);
                }
                return markers;
            }
        }
        svg.Element.path.prototype = new svg.Element.PathElementBase;
        
        // pattern element
        svg.Element.pattern = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.createPattern = function(ctx, element) {
                var width = this.attribute('width').toPixels('x', true);
                var height = this.attribute('height').toPixels('y', true);
            
                // render me using a temporary svg element
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
                tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
                tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
                tempSvg.children = this.children;
                
                var c = document.createElement('canvas');
                c.width = width;
                c.height = height;
                var cctx = c.getContext('2d');
                if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
                    cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
                }
                // render 3x3 grid so when we transform there's no white space on edges
                for (var x=-1; x<=1; x++) {
                    for (var y=-1; y<=1; y++) {
                        cctx.save();
                        cctx.translate(x * c.width, y * c.height);
                        tempSvg.render(cctx);
                        cctx.restore();
                    }
                }
                var pattern = ctx.createPattern(c, 'repeat');
                return pattern;
            }
        }
        svg.Element.pattern.prototype = new svg.Element.ElementBase;
        
        // marker element
        svg.Element.marker = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.baseRender = this.render;
            this.render = function(ctx, point, angle) {
                ctx.translate(point.x, point.y);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
                ctx.save();
                            
                // render me using a temporary svg element
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
                tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
                tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
                tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
                tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
                tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
                tempSvg.children = this.children;
                tempSvg.render(ctx);
                
                ctx.restore();
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
                ctx.translate(-point.x, -point.y);
            }
        }
        svg.Element.marker.prototype = new svg.Element.ElementBase;
        
        // definitions element
        svg.Element.defs = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);    
            
            this.render = function(ctx) {
                // NOOP
            }
        }
        svg.Element.defs.prototype = new svg.Element.ElementBase;
        
        // base for gradients
        svg.Element.GradientBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.gradientUnits = this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
            
            this.stops = [];            
            for (var i=0; i<this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'stop') this.stops.push(child);
            }   
            
            this.getGradient = function() {
                // OVERRIDE ME!
            }           

            this.createGradient = function(ctx, element, parentOpacityProp) {
                var stopsContainer = this;
                if (this.getHrefAttribute().hasValue()) {
                    stopsContainer = this.getHrefAttribute().getDefinition();
                }
                
                var addParentOpacity = function (color) {
                    if (parentOpacityProp.hasValue()) {
                        var p = new svg.Property('color', color);
                        return p.addOpacity(parentOpacityProp).value;
                    }
                    return color;
                };
            
                var g = this.getGradient(ctx, element);
                if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
                for (var i=0; i<stopsContainer.stops.length; i++) {
                    g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
                }
                
                if (this.attribute('gradientTransform').hasValue()) {
                    // render as transformed pattern on temporary canvas
                    var rootView = svg.ViewPort.viewPorts[0];
                    
                    var rect = new svg.Element.rect();
                    rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
                    rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
                    rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
                    rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);
                    
                    var group = new svg.Element.g();
                    group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
                    group.children = [ rect ];
                    
                    var tempSvg = new svg.Element.svg();
                    tempSvg.attributes['x'] = new svg.Property('x', 0);
                    tempSvg.attributes['y'] = new svg.Property('y', 0);
                    tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
                    tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
                    tempSvg.children = [ group ];
                    
                    var c = document.createElement('canvas');
                    c.width = rootView.width;
                    c.height = rootView.height;
                    var tempCtx = c.getContext('2d');
                    tempCtx.fillStyle = g;
                    tempSvg.render(tempCtx);        
                    return tempCtx.createPattern(c, 'no-repeat');
                }
                
                return g;               
            }
        }
        svg.Element.GradientBase.prototype = new svg.Element.ElementBase;
        
        // linear gradient element
        svg.Element.linearGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            
            this.getGradient = function(ctx, element) {
                var bb = this.gradientUnits == 'objectBoundingBox' ? element.getBoundingBox() : null;
                
                if (!this.attribute('x1').hasValue()
                 && !this.attribute('y1').hasValue()
                 && !this.attribute('x2').hasValue()
                 && !this.attribute('y2').hasValue()) {
                    this.attribute('x1', true).value = 0;
                    this.attribute('y1', true).value = 0;
                    this.attribute('x2', true).value = 1;
                    this.attribute('y2', true).value = 0;
                 }
                
                var x1 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('x1').numValue() 
                    : this.attribute('x1').toPixels('x'));
                var y1 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('y1').numValue()
                    : this.attribute('y1').toPixels('y'));
                var x2 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('x2').numValue()
                    : this.attribute('x2').toPixels('x'));
                var y2 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('y2').numValue()
                    : this.attribute('y2').toPixels('y'));

                if (x1 == x2 && y1 == y2) return null;
                return ctx.createLinearGradient(x1, y1, x2, y2);
            }
        }
        svg.Element.linearGradient.prototype = new svg.Element.GradientBase;
        
        // radial gradient element
        svg.Element.radialGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            
            this.getGradient = function(ctx, element) {
                var bb = element.getBoundingBox();
                
                if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
                if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
                if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';
                
                var cx = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('cx').numValue() 
                    : this.attribute('cx').toPixels('x'));
                var cy = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('cy').numValue() 
                    : this.attribute('cy').toPixels('y'));
                
                var fx = cx;
                var fy = cy;
                if (this.attribute('fx').hasValue()) {
                    fx = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('fx').numValue() 
                    : this.attribute('fx').toPixels('x'));
                }
                if (this.attribute('fy').hasValue()) {
                    fy = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('fy').numValue() 
                    : this.attribute('fy').toPixels('y'));
                }
                
                var r = (this.gradientUnits == 'objectBoundingBox' 
                    ? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
                    : this.attribute('r').toPixels());
                
                return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
            }
        }
        svg.Element.radialGradient.prototype = new svg.Element.GradientBase;
        
        // gradient stop element
        svg.Element.stop = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.offset = this.attribute('offset').numValue();
            if (this.offset < 0) this.offset = 0;
            if (this.offset > 1) this.offset = 1;
            
            var stopColor = this.style('stop-color');
            if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));
            this.color = stopColor.value;
        }
        svg.Element.stop.prototype = new svg.Element.ElementBase;
        
        // animation base element
        svg.Element.AnimateBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            svg.Animations.push(this);
            
            this.duration = 0.0;
            this.begin = this.attribute('begin').toMilliseconds();
            this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();
            
            this.getProperty = function() {
                var attributeType = this.attribute('attributeType').value;
                var attributeName = this.attribute('attributeName').value;
                
                if (attributeType == 'CSS') {
                    return this.parent.style(attributeName, true);
                }
                return this.parent.attribute(attributeName, true);          
            };
            
            this.initialValue = null;
            this.initialUnits = '';
            this.removed = false;       

            this.calcValue = function() {
                // OVERRIDE ME!
                return '';
            }
                    
            this.update = function(delta) { 
                // set initial value
                if (this.initialValue == null) {
                    this.initialValue = this.getProperty().value;
                    this.initialUnits = this.getProperty().getUnits();
                }
            
                // if we're past the end time
                if (this.duration > this.maxDuration) {
                    // loop for indefinitely repeating animations
                    if (this.attribute('repeatCount').value == 'indefinite'
                     || this.attribute('repeatDur').value == 'indefinite') {
                        this.duration = 0.0
                    }
                    else if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {
                        this.frozen = true;
                        this.parent.animationFrozen = true;
                        this.parent.animationFrozenValue = this.getProperty().value;
                    }
                    else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
                        this.removed = true;
                        this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;
                        return true;
                    }
                    return false;
                }           
                this.duration = this.duration + delta;
            
                // if we're past the begin time
                var updated = false;
                if (this.begin < this.duration) {
                    var newValue = this.calcValue(); // tween
                    
                    if (this.attribute('type').hasValue()) {
                        // for transform, etc.
                        var type = this.attribute('type').value;
                        newValue = type + '(' + newValue + ')';
                    }
                    
                    this.getProperty().value = newValue;
                    updated = true;
                }
                
                return updated;
            }
            
            this.from = this.attribute('from');
            this.to = this.attribute('to');
            this.values = this.attribute('values');
            if (this.values.hasValue()) this.values.value = this.values.value.split(';');
            
            // fraction of duration we've covered
            this.progress = function() {
                var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
                if (this.values.hasValue()) {
                    var p = ret.progress * (this.values.value.length - 1);
                    var lb = Math.floor(p), ub = Math.ceil(p);
                    ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
                    ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
                    ret.progress = (p - lb) / (ub - lb);
                }
                else {
                    ret.from = this.from;
                    ret.to = this.to;
                }
                return ret;
            }           
        }
        svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;
        
        // animate element
        svg.Element.animate = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            
            this.calcValue = function() {
                var p = this.progress();
                
                // tween value linearly
                var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress; 
                return newValue + this.initialUnits;
            };
        }
        svg.Element.animate.prototype = new svg.Element.AnimateBase;
            
        // animate color element
        svg.Element.animateColor = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);

            this.calcValue = function() {
                var p = this.progress();
                var from = new RGBColor(p.from.value);
                var to = new RGBColor(p.to.value);
                
                if (from.ok && to.ok) {
                    // tween color linearly
                    var r = from.r + (to.r - from.r) * p.progress;
                    var g = from.g + (to.g - from.g) * p.progress;
                    var b = from.b + (to.b - from.b) * p.progress;
                    return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
                }
                return this.attribute('from').value;
            };
        }
        svg.Element.animateColor.prototype = new svg.Element.AnimateBase;
        
        // animate transform element
        svg.Element.animateTransform = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            
            this.calcValue = function() {
                var p = this.progress();
                
                // tween value linearly
                var from = svg.ToNumberArray(p.from.value);
                var to = svg.ToNumberArray(p.to.value);
                var newValue = '';
                for (var i=0; i<from.length; i++) {
                    newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
                }
                return newValue;
            };
        }
        svg.Element.animateTransform.prototype = new svg.Element.animate;
        
        // font element
        svg.Element.font = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.horizAdvX = this.attribute('horiz-adv-x').numValue();          
            
            this.isRTL = false;
            this.isArabic = false;
            this.fontFace = null;
            this.missingGlyph = null;
            this.glyphs = [];           
            for (var i=0; i<this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'font-face') {
                    this.fontFace = child;
                    if (child.style('font-family').hasValue()) {
                        svg.Definitions[child.style('font-family').value] = this;
                    }
                }
                else if (child.type == 'missing-glyph') this.missingGlyph = child;
                else if (child.type == 'glyph') {
                    if (child.arabicForm != '') {
                        this.isRTL = true;
                        this.isArabic = true;
                        if (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];
                        this.glyphs[child.unicode][child.arabicForm] = child;
                    }
                    else {
                        this.glyphs[child.unicode] = child;
                    }
                }
            }   
        }
        svg.Element.font.prototype = new svg.Element.ElementBase;
        
        // font-face element
        svg.Element.fontface = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);    
            
            this.ascent = this.attribute('ascent').value;
            this.descent = this.attribute('descent').value;
            this.unitsPerEm = this.attribute('units-per-em').numValue();                
        }
        svg.Element.fontface.prototype = new svg.Element.ElementBase;
        
        // missing-glyph element
        svg.Element.missingglyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);    
            
            this.horizAdvX = 0;
        }
        svg.Element.missingglyph.prototype = new svg.Element.path;
        
        // glyph element
        svg.Element.glyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);    
            
            this.horizAdvX = this.attribute('horiz-adv-x').numValue();
            this.unicode = this.attribute('unicode').value;
            this.arabicForm = this.attribute('arabic-form').value;
        }
        svg.Element.glyph.prototype = new svg.Element.path;
        
        // text element
        svg.Element.text = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                
                var textBaseline = this.style('dominant-baseline').toTextBaseline();
                if (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();
                if (textBaseline != null) ctx.textBaseline = textBaseline;
            }
            
            this.getBoundingBox = function () {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);
            }
            
            this.renderChildren = function(ctx) {
                this.x = this.attribute('x').toPixels('x');
                this.y = this.attribute('y').toPixels('y');
                this.x += this.getAnchorDelta(ctx, this, 0);
                for (var i=0; i<this.children.length; i++) {
                    this.renderChild(ctx, this, i);
                }
            }
            
            this.getAnchorDelta = function (ctx, parent, startI) {
                var textAnchor = this.style('text-anchor').valueOrDefault('start');
                if (textAnchor != 'start') {
                    var width = 0;
                    for (var i=startI; i<parent.children.length; i++) {
                        var child = parent.children[i];
                        if (i > startI && child.attribute('x').hasValue()) break; // new group
                        width += child.measureTextRecursive(ctx);
                    }
                    return -1 * (textAnchor == 'end' ? width : width / 2.0);
                }
                return 0;
            }
            
            this.renderChild = function(ctx, parent, i) {
                var child = parent.children[i];
                if (child.attribute('x').hasValue()) {
                    child.x = child.attribute('x').toPixels('x') + this.getAnchorDelta(ctx, parent, i);
                    if (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');
                }
                else {
                    if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
                    if (child.attribute('dx').hasValue()) this.x += child.attribute('dx').toPixels('x');
                    child.x = this.x;
                }
                this.x = child.x + child.measureText(ctx);
                
                if (child.attribute('y').hasValue()) {
                    child.y = child.attribute('y').toPixels('y');
                    if (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');
                }
                else {
                    if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
                    if (child.attribute('dy').hasValue()) this.y += child.attribute('dy').toPixels('y');
                    child.y = this.y;
                }
                this.y = child.y;
                
                child.render(ctx);
                
                for (var i=0; i<child.children.length; i++) {
                    this.renderChild(ctx, child, i);
                }
            }
        }
        svg.Element.text.prototype = new svg.Element.RenderedElementBase;
        
        // text base
        svg.Element.TextElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.getGlyph = function(font, text, i) {
                var c = text[i];
                var glyph = null;
                if (font.isArabic) {
                    var arabicForm = 'isolated';
                    if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal'; 
                    if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
                    if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
                    if (typeof(font.glyphs[c]) != 'undefined') {
                        glyph = font.glyphs[c][arabicForm];
                        if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
                    }
                }
                else {
                    glyph = font.glyphs[c];
                }
                if (glyph == null) glyph = font.missingGlyph;
                return glyph;
            }
            
            this.renderChildren = function(ctx) {
                var customFont = this.parent.style('font-family').getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
                    var text = this.getText();
                    if (customFont.isRTL) text = text.split("").reverse().join("");
                    
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i=0; i<text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        var scale = fontSize / customFont.fontFace.unitsPerEm;
                        ctx.translate(this.x, this.y);
                        ctx.scale(scale, -scale);
                        var lw = ctx.lineWidth;
                        ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
                        if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
                        glyph.render(ctx);
                        if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
                        ctx.lineWidth = lw;
                        ctx.scale(1/scale, -1/scale);
                        ctx.translate(-this.x, -this.y);    
                        
                        this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            this.x += dx[i];
                        }
                    }
                    return;
                }
            
                if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
                if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
            }
            
            this.getText = function() {
                // OVERRIDE ME
            }
            
            this.measureTextRecursive = function(ctx) {
                var width = this.measureText(ctx);
                for (var i=0; i<this.children.length; i++) {
                    width += this.children[i].measureTextRecursive(ctx);
                }
                return width;
            }
            
            this.measureText = function(ctx) {
                var customFont = this.parent.style('font-family').getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var measure = 0;
                    var text = this.getText();
                    if (customFont.isRTL) text = text.split("").reverse().join("");
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i=0; i<text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            measure += dx[i];
                        }
                    }
                    return measure;
                }
            
                var textToMeasure = svg.compressSpaces(this.getText());
                if (!ctx.measureText) return textToMeasure.length * 10;
                
                ctx.save();
                this.setContext(ctx);
                var width = ctx.measureText(textToMeasure).width;
                ctx.restore();
                return width;
            }
        }
        svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;
        
        // tspan 
        svg.Element.tspan = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.TextElementBase;
            this.base(node);
            
            this.text = node.nodeValue || node.text || '';
            this.getText = function() {
                return this.text;
            }
        }
        svg.Element.tspan.prototype = new svg.Element.TextElementBase;
        
        // tref
        svg.Element.tref = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            
            this.getText = function() {
                var element = this.getHrefAttribute().getDefinition();
                if (element != null) return element.children[0].getText();
            }
        }
        svg.Element.tref.prototype = new svg.Element.TextElementBase;       
        
        // a element
        svg.Element.a = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            
            this.hasText = true;
            for (var i=0; i<node.childNodes.length; i++) {
                if (node.childNodes[i].nodeType != 3) this.hasText = false;
            }
            
            // this might contain text
            this.text = this.hasText ? node.childNodes[0].nodeValue : '';
            this.getText = function() {
                return this.text;
            }       

            this.baseRenderChildren = this.renderChildren;
            this.renderChildren = function(ctx) {
                if (this.hasText) {
                    // render as text element
                    this.baseRenderChildren(ctx);
                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));                 
                }
                else {
                    // render as temporary group
                    var g = new svg.Element.g();
                    g.children = this.children;
                    g.parent = this;
                    g.render(ctx);
                }
            }
            
            this.onclick = function() {
                window.open(this.getHrefAttribute().value);
            }
            
            this.onmousemove = function() {
                svg.ctx.canvas.style.cursor = 'pointer';
            }
        }
        svg.Element.a.prototype = new svg.Element.TextElementBase;      
        
        // image element
        svg.Element.image = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            var href = this.getHrefAttribute().value;
            if (href == '') { return; }
            var isSvg = href.match(/\.svg$/)
            
            svg.Images.push(this);
            this.loaded = false;
            if (!isSvg) {
                this.img = document.createElement('img');
                if (svg.opts['useCORS'] == true) { this.img.crossOrigin = 'Anonymous'; }
                var self = this;
                this.img.onload = function() { self.loaded = true; }
                this.img.onerror = function() { svg.log('ERROR: image "' + href + '" not found'); self.loaded = true; }
                this.img.src = href;
            }
            else {
                this.img = svg.ajax(href);
                this.loaded = true;
            }
            
            this.renderChildren = function(ctx) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');            
                if (width == 0 || height == 0) return;
            
                ctx.save();
                if (isSvg) {
                    ctx.drawSvg(this.img, x, y, width, height);
                }
                else {
                    ctx.translate(x, y);
                    svg.AspectRatio(ctx,
                                    this.attribute('preserveAspectRatio').value,
                                    width,
                                    this.img.width,
                                    height,
                                    this.img.height,
                                    0,
                                    0); 
                    ctx.drawImage(this.img, 0, 0);      
                }
                ctx.restore();
            }
            
            this.getBoundingBox = function() {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        }
        svg.Element.image.prototype = new svg.Element.RenderedElementBase;
        
        // group element
        svg.Element.g = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.getBoundingBox = function() {
                var bb = new svg.BoundingBox();
                for (var i=0; i<this.children.length; i++) {
                    bb.addBoundingBox(this.children[i].getBoundingBox());
                }
                return bb;
            };
        }
        svg.Element.g.prototype = new svg.Element.RenderedElementBase;

        // symbol element
        svg.Element.symbol = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.render = function(ctx) {
                // NO RENDER
            };
        }
        svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;     
            
        // style element
        svg.Element.style = function(node) { 
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            // text, or spaces then CDATA
            var css = ''
            for (var i=0; i<node.childNodes.length; i++) {
              css += node.childNodes[i].nodeValue;
            }
            css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
            css = svg.compressSpaces(css); // replace whitespace
            var cssDefs = css.split('}');
            for (var i=0; i<cssDefs.length; i++) {
                if (svg.trim(cssDefs[i]) != '') {
                    var cssDef = cssDefs[i].split('{');
                    var cssClasses = cssDef[0].split(',');
                    var cssProps = cssDef[1].split(';');
                    for (var j=0; j<cssClasses.length; j++) {
                        var cssClass = svg.trim(cssClasses[j]);
                        if (cssClass != '') {
                            var props = {};
                            for (var k=0; k<cssProps.length; k++) {
                                var prop = cssProps[k].indexOf(':');
                                var name = cssProps[k].substr(0, prop);
                                var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
                                if (name != null && value != null) {
                                    props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
                                }
                            }
                            svg.Styles[cssClass] = props;
                            if (cssClass == '@font-face') {
                                var fontFamily = props['font-family'].value.replace(/"/g,'');
                                var srcs = props['src'].value.split(',');
                                for (var s=0; s<srcs.length; s++) {
                                    if (srcs[s].indexOf('format("svg")') > 0) {
                                        var urlStart = srcs[s].indexOf('url');
                                        var urlEnd = srcs[s].indexOf(')', urlStart);
                                        var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
                                        var doc = svg.parseXml(svg.ajax(url));
                                        var fonts = doc.getElementsByTagName('font');
                                        for (var f=0; f<fonts.length; f++) {
                                            var font = svg.CreateElement(fonts[f]);
                                            svg.Definitions[fontFamily] = font;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        svg.Element.style.prototype = new svg.Element.ElementBase;
        
        // use element 
        svg.Element.use = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
                if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
            }
            
            var element = this.getHrefAttribute().getDefinition();
            
            this.path = function(ctx) {
                if (element != null) element.path(ctx);
            }
            
            this.getBoundingBox = function() {
                if (element != null) return element.getBoundingBox();
            }
            
            this.renderChildren = function(ctx) {
                if (element != null) {
                    var tempSvg = element;
                    if (element.type == 'symbol') {
                        // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
                        tempSvg = new svg.Element.svg();
                        tempSvg.type = 'svg';
                        tempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);
                        tempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);
                        tempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);
                        tempSvg.children = element.children;
                    }
                    if (tempSvg.type == 'svg') {
                        // if symbol or svg, inherit width/height from me
                        if (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
                        if (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
                    }
                    var oldParent = tempSvg.parent;
                    tempSvg.parent = null;
                    tempSvg.render(ctx);
                    tempSvg.parent = oldParent;
                }
            }
        }
        svg.Element.use.prototype = new svg.Element.RenderedElementBase;
        
        // mask element
        svg.Element.mask = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
                        
            this.apply = function(ctx, element) {
                // render as temp svg   
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                
                if (width == 0 && height == 0) {
                    var bb = new svg.BoundingBox();
                    for (var i=0; i<this.children.length; i++) {
                        bb.addBoundingBox(this.children[i].getBoundingBox());
                    }
                    var x = Math.floor(bb.x1);
                    var y = Math.floor(bb.y1);
                    var width = Math.floor(bb.width());
                    var height = Math.floor(bb.height());
                }
                
                // temporarily remove mask to avoid recursion
                var mask = element.attribute('mask').value;
                element.attribute('mask').value = '';
                
                    var cMask = document.createElement('canvas');
                    cMask.width = x + width;
                    cMask.height = y + height;
                    var maskCtx = cMask.getContext('2d');
                    this.renderChildren(maskCtx);
                
                    var c = document.createElement('canvas');
                    c.width = x + width;
                    c.height = y + height;
                    var tempCtx = c.getContext('2d');
                    element.render(tempCtx);
                    tempCtx.globalCompositeOperation = 'destination-in';
                    tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
                    tempCtx.fillRect(0, 0, x + width, y + height);
                    
                    ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
                    ctx.fillRect(0, 0, x + width, y + height);
                    
                // reassign mask
                element.attribute('mask').value = mask; 
            }
            
            this.render = function(ctx) {
                // NO RENDER
            }
        }
        svg.Element.mask.prototype = new svg.Element.ElementBase;
        
        // clip element
        svg.Element.clipPath = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx) {
                var oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;
                CanvasRenderingContext2D.prototype.beginPath = function () { };
                
                var oldClosePath = CanvasRenderingContext2D.prototype.closePath;
                CanvasRenderingContext2D.prototype.closePath = function () { };
            
                oldBeginPath.call(ctx);
                for (var i=0; i<this.children.length; i++) {
                    var child = this.children[i];
                    if (typeof(child.path) != 'undefined') {
                        var transform = null;
                        if (child.attribute('transform').hasValue()) { 
                            transform = new svg.Transform(child.attribute('transform').value);
                            transform.apply(ctx);
                        }
                        child.path(ctx);
                        CanvasRenderingContext2D.prototype.closePath = oldClosePath;
                        if (transform) { transform.unapply(ctx); }
                    }
                }
                oldClosePath.call(ctx);
                ctx.clip();
                
                CanvasRenderingContext2D.prototype.beginPath = oldBeginPath;
                CanvasRenderingContext2D.prototype.closePath = oldClosePath;
            }
            
            this.render = function(ctx) {
                // NO RENDER
            }
        }
        svg.Element.clipPath.prototype = new svg.Element.ElementBase;

        // filters
        svg.Element.filter = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
                        
            this.apply = function(ctx, element) {
                // render as temp svg   
                var bb = element.getBoundingBox();
                var x = Math.floor(bb.x1);
                var y = Math.floor(bb.y1);
                var width = Math.floor(bb.width());
                var height = Math.floor(bb.height());

                // temporarily remove filter to avoid recursion
                var filter = element.style('filter').value;
                element.style('filter').value = '';
                
                var px = 0, py = 0;
                for (var i=0; i<this.children.length; i++) {
                    var efd = this.children[i].extraFilterDistance || 0;
                    px = Math.max(px, efd);
                    py = Math.max(py, efd);
                }
                
                var c = document.createElement('canvas');
                c.width = width + 2*px;
                c.height = height + 2*py;
                var tempCtx = c.getContext('2d');
                tempCtx.translate(-x + px, -y + py);
                element.render(tempCtx);
            
                // apply filters
                for (var i=0; i<this.children.length; i++) {
                    this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
                }
                
                // render on me
                ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);
                
                // reassign filter
                element.style('filter', true).value = filter;   
            }
            
            this.render = function(ctx) {
                // NO RENDER
            }       
        }
        svg.Element.filter.prototype = new svg.Element.ElementBase;
        
        svg.Element.feMorphology = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx, x, y, width, height) {
                // TODO: implement
            }
        }
        svg.Element.feMorphology.prototype = new svg.Element.ElementBase;
        
        svg.Element.feComposite = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx, x, y, width, height) {
                // TODO: implement
            }
        }
        svg.Element.feComposite.prototype = new svg.Element.ElementBase;
        
        svg.Element.feColorMatrix = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            var matrix = svg.ToNumberArray(this.attribute('values').value);
            switch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
                case 'saturate':
                    var s = matrix[0];
                    matrix = [0.213+0.787*s,0.715-0.715*s,0.072-0.072*s,0,0,
                              0.213-0.213*s,0.715+0.285*s,0.072-0.072*s,0,0,
                              0.213-0.213*s,0.715-0.715*s,0.072+0.928*s,0,0,
                              0,0,0,1,0,
                              0,0,0,0,1];
                    break;
                case 'hueRotate':
                    var a = matrix[0] * Math.PI / 180.0;
                    var c = function (m1,m2,m3) { return m1 + Math.cos(a)*m2 + Math.sin(a)*m3; };
                    matrix = [c(0.213,0.787,-0.213),c(0.715,-0.715,-0.715),c(0.072,-0.072,0.928),0,0,
                              c(0.213,-0.213,0.143),c(0.715,0.285,0.140),c(0.072,-0.072,-0.283),0,0,
                              c(0.213,-0.213,-0.787),c(0.715,-0.715,0.715),c(0.072,0.928,0.072),0,0,
                              0,0,0,1,0,
                              0,0,0,0,1];
                    break;
                case 'luminanceToAlpha':
                    matrix = [0,0,0,0,0,
                              0,0,0,0,0,
                              0,0,0,0,0,
                              0.2125,0.7154,0.0721,0,0,
                              0,0,0,0,1];
                    break;
            }
            
            function imGet(img, x, y, width, height, rgba) {
                return img[y*width*4 + x*4 + rgba];
            }
            
            function imSet(img, x, y, width, height, rgba, val) {
                img[y*width*4 + x*4 + rgba] = val;
            }
            
            function m(i, v) {
                var mi = matrix[i];
                return mi * (mi < 0 ? v - 255 : v);
            }
                        
            this.apply = function(ctx, x, y, width, height) {
                // assuming x==0 && y==0 for now
                var srcData = ctx.getImageData(0, 0, width, height);
                for (var y = 0; y < height; y++) {
                    for (var x = 0; x < width; x++) {
                        var r = imGet(srcData.data, x, y, width, height, 0);
                        var g = imGet(srcData.data, x, y, width, height, 1);
                        var b = imGet(srcData.data, x, y, width, height, 2);
                        var a = imGet(srcData.data, x, y, width, height, 3);
                        imSet(srcData.data, x, y, width, height, 0, m(0,r)+m(1,g)+m(2,b)+m(3,a)+m(4,1));
                        imSet(srcData.data, x, y, width, height, 1, m(5,r)+m(6,g)+m(7,b)+m(8,a)+m(9,1));
                        imSet(srcData.data, x, y, width, height, 2, m(10,r)+m(11,g)+m(12,b)+m(13,a)+m(14,1));
                        imSet(srcData.data, x, y, width, height, 3, m(15,r)+m(16,g)+m(17,b)+m(18,a)+m(19,1));
                    }
                }
                ctx.clearRect(0, 0, width, height);
                ctx.putImageData(srcData, 0, 0);
            }
        }
        svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;
        
        svg.Element.feGaussianBlur = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
            this.extraFilterDistance = this.blurRadius;
            
            this.apply = function(ctx, x, y, width, height) {
                if (typeof(stackBlurCanvasRGBA) == 'undefined') {
                    svg.log('ERROR: StackBlur.js must be included for blur to work');
                    return;
                }
                
                // StackBlur requires canvas be on document
                ctx.canvas.id = svg.UniqueId();
                ctx.canvas.style.display = 'none';
                document.body.appendChild(ctx.canvas);
                stackBlurCanvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
                document.body.removeChild(ctx.canvas);
            }
        }
        svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;
        
        // title element, do nothing
        svg.Element.title = function(node) {
        }
        svg.Element.title.prototype = new svg.Element.ElementBase;

        // desc element, do nothing
        svg.Element.desc = function(node) {
        }
        svg.Element.desc.prototype = new svg.Element.ElementBase;       
        
        svg.Element.MISSING = function(node) {
            svg.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
        }
        svg.Element.MISSING.prototype = new svg.Element.ElementBase;
        
        // element factory
        svg.CreateElement = function(node) {    
            var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
            className = className.replace(/\-/g,''); // remove dashes
            var e = null;
            if (typeof(svg.Element[className]) != 'undefined') {
                e = new svg.Element[className](node);
            }
            else {
                e = new svg.Element.MISSING(node);
            }

            e.type = node.nodeName;
            return e;
        }
                
        // load from url
        svg.load = function(ctx, url) {
            svg.loadXml(ctx, svg.ajax(url));
        }
        
        // load from xml
        svg.loadXml = function(ctx, xml) {
            svg.loadXmlDoc(ctx, svg.parseXml(xml));
        }
        
        svg.loadXmlDoc = function(ctx, dom) {
            svg.init(ctx);
            
            var mapXY = function(p) {
                var e = ctx.canvas;
                while (e) {
                    p.x -= e.offsetLeft;
                    p.y -= e.offsetTop;
                    e = e.offsetParent;
                }
                if (window.scrollX) p.x += window.scrollX;
                if (window.scrollY) p.y += window.scrollY;
                return p;
            }
            
            // bind mouse
            if (svg.opts['ignoreMouse'] != true) {
                ctx.canvas.onclick = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onclick(p.x, p.y);
                };
                ctx.canvas.onmousemove = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onmousemove(p.x, p.y);
                };
            }
        
            var e = svg.CreateElement(dom.documentElement);
            e.root = true;
                    
            // render loop
            var isFirstRender = true;
            var draw = function() {
                svg.ViewPort.Clear();
                if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);
            
                if (svg.opts['ignoreDimensions'] != true) {
                    // set canvas size
                    if (e.style('width').hasValue()) {
                        ctx.canvas.width = e.style('width').toPixels('x');
                        ctx.canvas.style.width = ctx.canvas.width + 'px';
                    }
                    if (e.style('height').hasValue()) {
                        ctx.canvas.height = e.style('height').toPixels('y');
                        ctx.canvas.style.height = ctx.canvas.height + 'px';
                    }
                }
                var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
                var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
                if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
                    cWidth = e.style('width').toPixels('x');
                    cHeight = e.style('height').toPixels('y');
                }
                svg.ViewPort.SetCurrent(cWidth, cHeight);       
                
                if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
                if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
                if (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {
                    var xRatio = null, yRatio = null, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);
                    
                    if (svg.opts['scaleWidth'] != null) {
                        if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
                        else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
                    }
                    
                    if (svg.opts['scaleHeight'] != null) {
                        if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
                        else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
                    }

                    if (xRatio == null) { xRatio = yRatio; }
                    if (yRatio == null) { yRatio = xRatio; }
                    
                    e.attribute('width', true).value = svg.opts['scaleWidth'];
                    e.attribute('height', true).value = svg.opts['scaleHeight'];
                    e.attribute('transform', true).value += ' scale('+(1.0/xRatio)+','+(1.0/yRatio)+')';
                }
            
                // clear and render
                if (svg.opts['ignoreClear'] != true) {
                    ctx.clearRect(0, 0, cWidth, cHeight);
                }
                e.render(ctx);
                if (isFirstRender) {
                    isFirstRender = false;
                    if (typeof(svg.opts['renderCallback']) == 'function') svg.opts['renderCallback'](dom);
                }           
            }
            
            var waitingForImages = true;
            if (svg.ImagesLoaded()) {
                waitingForImages = false;
                draw();
            }
            svg.intervalID = setInterval(function() { 
                var needUpdate = false;
                
                if (waitingForImages && svg.ImagesLoaded()) {
                    waitingForImages = false;
                    needUpdate = true;
                }
            
                // need update from mouse events?
                if (svg.opts['ignoreMouse'] != true) {
                    needUpdate = needUpdate | svg.Mouse.hasEvents();
                }
            
                // need update from animations?
                if (svg.opts['ignoreAnimation'] != true) {
                    for (var i=0; i<svg.Animations.length; i++) {
                        needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
                    }
                }
                
                // need update from redraw?
                if (typeof(svg.opts['forceRedraw']) == 'function') {
                    if (svg.opts['forceRedraw']() == true) needUpdate = true;
                }
                
                // render if needed
                if (needUpdate) {
                    draw();             
                    svg.Mouse.runEvents(); // run and clear our events
                }
            }, 1000 / svg.FRAMERATE);
        }
        
        svg.stop = function() {
            if (svg.intervalID) {
                clearInterval(svg.intervalID);
            }
        }
        
        svg.Mouse = new (function() {
            this.events = [];
            this.hasEvents = function() { return this.events.length != 0; }
        
            this.onclick = function(x, y) {
                this.events.push({ type: 'onclick', x: x, y: y, 
                    run: function(e) { if (e.onclick) e.onclick(); }
                });
            }
            
            this.onmousemove = function(x, y) {
                this.events.push({ type: 'onmousemove', x: x, y: y,
                    run: function(e) { if (e.onmousemove) e.onmousemove(); }
                });
            }           
            
            this.eventElements = [];
            
            this.checkPath = function(element, ctx) {
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
                }
            }
            
            this.checkBoundingBox = function(element, bb) {
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
                }           
            }
            
            this.runEvents = function() {
                svg.ctx.canvas.style.cursor = '';
                
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    var element = this.eventElements[i];
                    while (element) {
                        e.run(element);
                        element = element.parent;
                    }
                }       
            
                // done running, clear
                this.events = []; 
                this.eventElements = [];
            }
        });
        
        return svg;
    }
})();

if (typeof(CanvasRenderingContext2D) != 'undefined') {
    CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
        canvg(this.canvas, s, { 
            ignoreMouse: true, 
            ignoreAnimation: true, 
            ignoreDimensions: true, 
            ignoreClear: true, 
            offsetX: dx, 
            offsetY: dy, 
            scaleWidth: dw, 
            scaleHeight: dh
        });
    }
}

},{}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\lib-src\\rgbcolor.js":[function(require,module,exports){
// dependency for canvg
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license Use it if you like it
 */
function RGBColor(color_string)
{
    this.ok = false;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    for (var key in simple_colors) {
        if (color_string == key) {
            color_string = simple_colors[key];
        }
    }
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}


module.exports = RGBColor;

},{}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\underscore-transpose.js":[function(require,module,exports){
var _ = require('underscore');

_.mixin({
  transpose: function(arrs) {
    return _.zip.apply(_, arrs);
  }
});

},{"underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\app\\js\\ugly\\util.js":[function(require,module,exports){
// hopefully not that ugly, but seemed as good a place as any for this stuff...

var d3 = require('d3');


var formatKMB = function(precision, decimalSeparator) {
  var app = window.app;
  var formatSI = d3.format('.' + (precision || 3) + 's');
  decimalSeparator = decimalSeparator || '.';
  return function(value) {
    return formatSI(value)
      .replace('k', app.translator.translateSync('amp.dashboard:chart-thousand'))
      .replace('M', app.translator.translateSync('amp.dashboard:chart-million'))
      .replace('G', app.translator.translateSync('amp.dashboard:chart-billion'))  // now just need to convert G Gigia -> B Billion
      .replace('T', app.translator.translateSync('amp.dashboard:chart-trillion'))
      .replace('P', app.translator.translateSync('amp.dashboard:chart-peta'))
      .replace('E', app.translator.translateSync('amp.dashboard:chart-exa'))
      .replace('.', decimalSeparator);
  };
};

var translateLanguage = function(value) {
  var app = window.app;
  return value
    .replace('k', app.translator.translateSync('amp.dashboard:chart-thousand'))
    .replace('M', app.translator.translateSync('amp.dashboard:chart-million'))
    .replace('B', app.translator.translateSync('amp.dashboard:chart-billion'))
    .replace('T', app.translator.translateSync('amp.dashboard:chart-trillion'))
    .replace('P', app.translator.translateSync('amp.dashboard:chart-peta'))
    .replace('E', app.translator.translateSync('amp.dashboard:chart-exa'));
};

var formatShortText = function(maxWidth) {
  var ellipseWidth = 1;
  return function(text) {
    if (text.length - ellipseWidth > maxWidth) {
      text = text.slice(0, maxWidth - ellipseWidth) + '...';
    }
    return text;
  };
};


var categoryColours = function(cats) {
  // get an appropriate colour scale for the number of categories we are
  // dealing with
  var colours = d3.scale['category20']().range();
  return function(d, i) {
    return d.color || (d.data && d.data.color) || colours[i % colours.length];
  };
};


var u16le64 = function(str) {
  // base64-encode a string as UTF-16-LE (for MS Excel, probably). It will only
  // work for 2-byte-wide utf-16 characters, and will break at the first hint
  // of any 4-byte char. Two bytes covers the Basic Multiningual Plane, so we
  // should be good.
  var u16num,
      asciiBytePairString = String.fromCharCode(0xFF) + String.fromCharCode(0xFE);
  asciiBytePairString += Array.prototype.reduce.call(str, function(acc, chr) {
    u16num = chr.charCodeAt(0);
    /* jshint bitwise:false */
    return acc + String.fromCharCode(u16num & 0xFF) + String.fromCharCode(u16num >> 8);
    /* jshint bitwise:true */
  }, '');
  return btoa(asciiBytePairString);
};


var textAsDataURL = function(str) {
  return 'data:text/plain;base64,' + u16le64(str);
};


function transformArgs(transformer, wrapped) {
  return function(/* arguments */) {
    var transformedArgs = transformer.apply(null, arguments);
    return wrapped.apply(null, transformedArgs);
  };
}


function toDashed(name) {
  // transform namesLikeThis to names-like-this
  return name.replace(/([A-Z])/g, function(u) {
    return '-' + u.toLowerCase();
  });
}


function data(el, name, newValue) {
  if (newValue === void 0) {
    return el.getAttribute('data-' + toDashed(name));
  }
  el.setAttribute('data-' + toDashed(name), newValue);
}

/**
 * This function calculates how much height we need to show a readable chart with different number of legends. 
 */
function calculateChartHeight(length, isDownload, model) {
	var height = null;
	var bigN = null;
	if (length < 30) {
		bigN = '0';
		if (isDownload === true) {
			height = 450;
		}
	} else if(length >= 30 && length < 40) {
		if (isDownload === true) {
			height = 550;
		}  else {
			height = 475;
		}
		bigN = '1';
	} else if(length >= 40 && length < 50) {
		if (isDownload === true) {
			height = 700;
		} else {
			height = 625;
		}
		bigN = '2';
	} else if(length >= 50 && length < 60) {
		if (isDownload === true) {
			height = 850;
		} else {
			height = 775;
		}
		bigN = '3';
	} else if(length >= 60 && length < 70) {
		if (isDownload === true) {
			height = 1000;
		} else {
			height = 925;
		}
		bigN = '4';
	} else if(length >= 70 && length < 80) {
		if (isDownload === true) {
			height = 1150;
		} else {
			height = 1075;
		}
		bigN = '5';
	} else if(length >= 80 && length < 90) {
		if (isDownload === true) {
			height = 1150;
		} else {
			height = 1225;
		}
		bigN = '6';	
	} else if(length >= 90) {
		// Seriously????
		if (isDownload === true) {
			height = 1300;
		} else {
			height = 1375;
		}
		bigN = '7';
	}
	if (model !== undefined) {
		model.set('bigN', bigN);
	}
	return height
}


module.exports = {
  formatKMB: formatKMB,
  translateLanguage: translateLanguage,
  formatShortText: formatShortText,
  categoryColours: categoryColours,
  u16le64: u16le64,
  textAsDataURL: textAsDataURL,
  transformArgs: transformArgs,
  data: data,
  calculateChartHeight: calculateChartHeight
};

},{"d3":"d3"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\node_modules\\babyparse\\babyparse.js":[function(require,module,exports){
/*
	Baby Parse
	v0.2.1
	https://github.com/Rich-Harris/BabyParse

	based on Papa Parse v3.0.1
	https://github.com/mholt/PapaParse
*/


(function ( global ) {

	// A configuration object from which to draw default settings
	var DEFAULTS = {
		delimiter: "",	// empty: auto-detect
		header: false,
		dynamicTyping: false,
		preview: 0,
		step: undefined,
		comments: false,
		complete: undefined,
		keepEmptyRows: false
	};

	var Baby = {};
	Baby.parse = CsvToJson;
	Baby.unparse = JsonToCsv;
	Baby.RECORD_SEP = String.fromCharCode(30);
	Baby.UNIT_SEP = String.fromCharCode(31);
	Baby.BYTE_ORDER_MARK = "\ufeff";
	Baby.BAD_DELIMITERS = ["\r", "\n", "\"", Baby.BYTE_ORDER_MARK];


	function CsvToJson(_input, _config)
	{
		var config = copyAndValidateConfig(_config);
		var ph = new ParserHandle(config);
		var results = ph.parse(_input);
		if (isFunction(config.complete))
			config.complete(results);
		return results;
	}




	function JsonToCsv(_input, _config)
	{
		var _output = "";
		var _fields = [];

		// Default configuration
		var _quotes = false;	// whether to surround every datum with quotes
		var _delimiter = ",";	// delimiting character
		var _newline = "\r\n";	// newline character(s)

		unpackConfig();

		if (typeof _input === 'string')
			_input = JSON.parse(_input);

		if (_input instanceof Array)
		{
			if (!_input.length || _input[0] instanceof Array)
				return serialize(null, _input);
			else if (typeof _input[0] === 'object')
				return serialize(objectKeys(_input[0]), _input);
		}
		else if (typeof _input === 'object')
		{
			if (typeof _input.data === 'string')
				_input.data = JSON.parse(_input.data);

			if (_input.data instanceof Array)
			{
				if (!_input.fields)
					_input.fields = _input.data[0] instanceof Array
									? _input.fields
									: objectKeys(_input.data[0]);

				if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')
					_input.data = [_input.data];	// handles input like [1,2,3] or ["asdf"]
			}

			return serialize(_input.fields || [], _input.data || []);
		}

		// Default (any valid paths should return before this)
		throw "exception: Unable to serialize unrecognized input";


		function unpackConfig()
		{
			if (typeof _config !== 'object')
				return;

			if (typeof _config.delimiter === 'string'
				&& _config.delimiter.length == 1
				&& Baby.BAD_DELIMITERS.indexOf(_config.delimiter) == -1)
			{
				_delimiter = _config.delimiter;
			}

			if (typeof _config.quotes === 'boolean'
				|| _config.quotes instanceof Array)
				_quotes = _config.quotes;

			if (typeof _config.newline === 'string')
				_newline = _config.newline;
		}


		// Turns an object's keys into an array
		function objectKeys(obj)
		{
			if (typeof obj !== 'object')
				return [];
			var keys = [];
			for (var key in obj)
				keys.push(key);
			return keys;
		}

		// The double for loop that iterates the data and writes out a CSV string including header row
		function serialize(fields, data)
		{
			var csv = "";

			if (typeof fields === 'string')
				fields = JSON.parse(fields);
			if (typeof data === 'string')
				data = JSON.parse(data);

			var hasHeader = fields instanceof Array && fields.length > 0;
			var dataKeyedByField = !(data[0] instanceof Array);

			// If there a header row, write it first
			if (hasHeader)
			{
				for (var i = 0; i < fields.length; i++)
				{
					if (i > 0)
						csv += _delimiter;
					csv += safe(fields[i], i);
				}
				if (data.length > 0)
					csv += _newline;
			}

			// Then write out the data
			for (var row = 0; row < data.length; row++)
			{
				var maxCol = hasHeader ? fields.length : data[row].length;

				for (var col = 0; col < maxCol; col++)
				{
					if (col > 0)
						csv += _delimiter;
					var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
					csv += safe(data[row][colIdx], col);
				}

				if (row < data.length - 1)
					csv += _newline;
			}

			return csv;
		}

		// Encloses a value around quotes if needed (makes a value safe for CSV insertion)
		function safe(str, col)
		{
			if (typeof str === "undefined")
				return "";

			str = str.toString().replace(/"/g, '""');

			var needsQuotes = (typeof _quotes === 'boolean' && _quotes)
							|| (_quotes instanceof Array && _quotes[col])
							|| hasAny(str, Baby.BAD_DELIMITERS)
							|| str.indexOf(_delimiter) > -1
							|| str.charAt(0) == ' '
							|| str.charAt(str.length - 1) == ' ';

			return needsQuotes ? '"' + str + '"' : str;
		}

		function hasAny(str, substrings)
		{
			for (var i = 0; i < substrings.length; i++)
				if (str.indexOf(substrings[i]) > -1)
					return true;
			return false;
		}
	}






	// Use one ParserHandle per entire CSV file or string
	function ParserHandle(_config)
	{
		// One goal is to minimize the use of regular expressions...
		var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;

		var _delimiterError;	// Temporary state between delimiter detection and processing results
		var _fields = [];		// Fields are from the header row of the input, if there is one
		var _results = {		// The last results returned from the parser
			data: [],
			errors: [],
			meta: {}
		};
		_config = copy(_config);

		this.parse = function(input)
		{
			_delimiterError = false;
			if (!_config.delimiter)
			{
				var delimGuess = guessDelimiter(input);
				if (delimGuess.successful)
					_config.delimiter = delimGuess.bestDelimiter;
				else
				{
					_delimiterError = true;	// add error after parsing (otherwise it would be overwritten)
					_config.delimiter = ",";
				}
				_results.meta.delimiter = _config.delimiter;
			}

			if (isFunction(_config.step))
			{
				var userStep = _config.step;
				_config.step = function(results, parser)
				{
					_results = results;
					if (needsHeaderRow())
						processResults();
					else
						userStep(processResults(), parser);
				};
			}

			_results = new Parser(_config).parse(input);
			return processResults();
		};

		function processResults()
		{
			if (_results && _delimiterError)
			{
				addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to comma");
				_delimiterError = false;
			}

			if (needsHeaderRow())
				fillHeaderFields();

			return applyHeaderAndDynamicTyping();
		}

		function needsHeaderRow()
		{
			return _config.header && _fields.length == 0;
		}

		function fillHeaderFields()
		{
			if (!_results)
				return;
			for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
				for (var j = 0; j < _results.data[i].length; j++)
					_fields.push(_results.data[i][j]);
			_results.data.splice(0, 1);
		}

		function applyHeaderAndDynamicTyping()
		{
			if (!_results || (!_config.header && !_config.dynamicTyping))
				return _results;

			for (var i = 0; i < _results.data.length; i++)
			{
				var row = {};
				for (var j = 0; j < _results.data[i].length; j++)
				{
					if (_config.dynamicTyping)
					{
						var value = _results.data[i][j];
						if (value == "true")
							_results.data[i][j] = true;
						else if (value == "false")
							_results.data[i][j] = false;
						else
							_results.data[i][j] = tryParseFloat(value);
					}

					if (_config.header)
					{
						if (j >= _fields.length)
						{
							if (!row["__parsed_extra"])
								row["__parsed_extra"] = [];
							row["__parsed_extra"].push(_results.data[i][j]);
						}
						row[_fields[j]] = _results.data[i][j];
					}
				}

				if (_config.header)
				{
					_results.data[i] = row;
					if (j > _fields.length)
						addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + _fields.length + " fields but parsed " + j, i);
					else if (j < _fields.length)
						addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + _fields.length + " fields but parsed " + j, i);
				}
			}

			if (_config.header && _results.meta);
				_results.meta.fields = _fields;

			return _results;
		}

		function guessDelimiter(input)
		{
			var delimChoices = [",", "\t", "|", ";", Baby.RECORD_SEP, Baby.UNIT_SEP];
			var bestDelim, bestDelta, fieldCountPrevRow;

			for (var i = 0; i < delimChoices.length; i++)
			{
				var delim = delimChoices[i];
				var delta = 0, avgFieldCount = 0;
				fieldCountPrevRow = undefined;

				var preview = new Parser({
					delimiter: delim,
					preview: 10
				}).parse(input);

				for (var j = 0; j < preview.data.length; j++)
				{
					var fieldCount = preview.data[j].length;
					avgFieldCount += fieldCount;

					if (typeof fieldCountPrevRow === 'undefined')
					{
						fieldCountPrevRow = fieldCount;
						continue;
					}
					else if (fieldCount > 1)
					{
						delta += Math.abs(fieldCount - fieldCountPrevRow);
						fieldCountPrevRow = fieldCount;
					}
				}

				avgFieldCount /= preview.data.length;

				if ((typeof bestDelta === 'undefined' || delta < bestDelta)
					&& avgFieldCount > 1.99)
				{
					bestDelta = delta;
					bestDelim = delim;
				}
			}

			_config.delimiter = bestDelim;

			return {
				successful: !!bestDelim,
				bestDelimiter: bestDelim
			}
		}

		function tryParseFloat(val)
		{
			var isNumber = FLOAT.test(val);
			return isNumber ? parseFloat(val) : val;
		}

		function addError(type, code, msg, row)
		{
			_results.errors.push({
				type: type,
				code: code,
				message: msg,
				row: row
			});
		}
	}







	function Parser(config)
	{
		var self = this;
		var EMPTY = /^\s*$/;

		var _input;		// The input text being parsed
		var _delimiter;	// The delimiting character
		var _comments;	// Comment character (default '#') or boolean
		var _step;		// The step (streaming) function
		var _callback;	// The callback to invoke when finished
		var _preview;	// Maximum number of lines (not rows) to parse
		var _ch;		// Current character
		var _i;			// Current character's positional index
		var _inQuotes;	// Whether in quotes or not
		var _lineNum;	// Current line number (1-based indexing)
		var _data;		// Parsed data (results)
		var _errors;	// Parse errors
		var _rowIdx;	// Current row index within results (0-based)
		var _colIdx;	// Current col index within result row (0-based)
		var _runningRowIdx;		// Cumulative row index, used by the preview feature
		var _aborted = false;	// Abort flag
		var _paused = false;	// Pause flag

		// Unpack the config object
		config = config || {};
		_delimiter = config.delimiter;
		_comments = config.comments;
		_step = config.step;
		_preview = config.preview;

		// Delimiter integrity check
		if (typeof _delimiter !== 'string'
			|| _delimiter.length != 1
			|| Baby.BAD_DELIMITERS.indexOf(_delimiter) > -1)
			_delimiter = ",";

		// Comment character integrity check
		if (_comments === true)
			_comments = "#";
		else if (typeof _comments !== 'string'
			|| _comments.length != 1
			|| Baby.BAD_DELIMITERS.indexOf(_comments) > -1
			|| _comments == _delimiter)
			_comments = false;


		this.parse = function(input)
		{
			if (typeof input !== 'string')
				throw "Input must be a string";
			reset(input);
			return parserLoop();
		};

		this.abort = function()
		{
			_aborted = true;
		};

		function parserLoop()
		{
			while (_i < _input.length)
			{
				if (_aborted) break;
				if (_preview > 0 && _runningRowIdx >= _preview) break;
				if (_paused) return finishParsing();

				if (_ch == '"')
					parseQuotes();
				else if (_inQuotes)
					parseInQuotes();
				else
					parseNotInQuotes();

				nextChar();
			}

			return finishParsing();
		}

		function nextChar()
		{
			_i++;
			_ch = _input[_i];
		}

		function finishParsing()
		{
			if (_aborted)
				addError("Abort", "ParseAbort", "Parsing was aborted by the user's step function");
			if (_inQuotes)
				addError("Quotes", "MissingQuotes", "Unescaped or mismatched quotes");
			endRow();	// End of input is also end of the last row
			if (!isFunction(_step))
				return returnable();
		}

		function parseQuotes()
		{
			if (quotesOnBoundary() && !quotesEscaped())
				_inQuotes = !_inQuotes;
			else
			{
				saveChar();
				if (_inQuotes && quotesEscaped())
					_i++
				else
					addError("Quotes", "UnexpectedQuotes", "Unexpected quotes");
			}
		}

		function parseInQuotes()
		{
			if (twoCharLineBreak(_i) || oneCharLineBreak(_i))
				_lineNum++;
			saveChar();
		}

		function parseNotInQuotes()
		{
			if (_ch == _delimiter)
				newField();
			else if (twoCharLineBreak(_i))
			{
				newRow();
				nextChar();
			}
			else if (oneCharLineBreak(_i))
				newRow();
			else if (isCommentStart())
				skipLine();
			else
				saveChar();
		}

		function isCommentStart()
		{
			if (!_comments)
				return false;

			var firstCharOfLine = _i == 0
									|| oneCharLineBreak(_i-1)
									|| twoCharLineBreak(_i-2);
			return firstCharOfLine && _input[_i] === _comments;
		}

		function skipLine()
		{
			while (!twoCharLineBreak(_i)
				&& !oneCharLineBreak(_i)
				&& _i < _input.length)
			{
				nextChar();
			}
		}

		function saveChar()
		{
			_data[_rowIdx][_colIdx] += _ch;
		}

		function newField()
		{
			_data[_rowIdx].push("");
			_colIdx = _data[_rowIdx].length - 1;
		}

		function newRow()
		{
			endRow();

			_lineNum++;
			_runningRowIdx++;
			_data.push([]);
			_rowIdx = _data.length - 1;
			newField();
		}

		function endRow()
		{
			trimEmptyLastRow();
			if (isFunction(_step))
			{
				if (_data[_rowIdx])
					_step(returnable(), self);
				clearErrorsAndData();
			}
		}

		function trimEmptyLastRow()
		{
			if (_data[_rowIdx].length == 1 && EMPTY.test(_data[_rowIdx][0]))
			{
				if (config.keepEmptyRows)
					_data[_rowIdx].splice(0, 1);	// leave row, but no fields
				else
					_data.splice(_rowIdx, 1);		// cut out row entirely
				_rowIdx = _data.length - 1;
			}
		}

		function twoCharLineBreak(i)
		{
			return i < _input.length - 1 &&
				((_input[i] == "\r" && _input[i+1] == "\n")
				|| (_input[i] == "\n" && _input[i+1] == "\r"))
		}

		function oneCharLineBreak(i)
		{
			return _input[i] == "\r" || _input[i] == "\n";
		}

		function quotesEscaped()
		{
			// Quotes as data cannot be on boundary, for example: ,"", are not escaped quotes
			return !quotesOnBoundary() && _i < _input.length - 1 && _input[_i+1] == '"';
		}

		function quotesOnBoundary()
		{
			return (!_inQuotes && isBoundary(_i-1)) || isBoundary(_i+1);
		}

		function isBoundary(i)
		{
			if (typeof i != 'number')
				i = _i;

			var ch = _input[i];

			return (i <= -1 || i >= _input.length)
				|| (ch == _delimiter
					|| ch == "\r"
					|| ch == "\n");
		}

		function addError(type, code, msg)
		{
			_errors.push({
				type: type,
				code: code,
				message: msg,
				line: _lineNum,
				row: _rowIdx,
				index: _i
			});
		}

		function reset(input)
		{
			_input = input;
			_inQuotes = false;
			_i = 0, _runningRowIdx = 0, _lineNum = 1;
			clearErrorsAndData();
			_data = [ [""] ];	// starting parsing requires an empty field
			_ch = _input[_i];
		}

		function clearErrorsAndData()
		{
			_data = [];
			_errors = [];
			_rowIdx = 0;
			_colIdx = 0;
		}

		function returnable()
		{
			return {
				data: _data,
				errors: _errors,
				meta: {
					lines: _lineNum,
					delimiter: _delimiter,
					aborted: _aborted
				}
			};
		}
	}

	// Replaces bad config values with good, default ones
	function copyAndValidateConfig(origConfig)
	{
		if (typeof origConfig !== 'object')
			origConfig = {};

		var config = copy(origConfig);

		if (typeof config.delimiter !== 'string'
			|| config.delimiter.length != 1
			|| Baby.BAD_DELIMITERS.indexOf(config.delimiter) > -1)
			config.delimiter = DEFAULTS.delimiter;

		if (typeof config.header !== 'boolean')
			config.header = DEFAULTS.header;

		if (typeof config.dynamicTyping !== 'boolean')
			config.dynamicTyping = DEFAULTS.dynamicTyping;

		if (typeof config.preview !== 'number')
			config.preview = DEFAULTS.preview;

		if (typeof config.step !== 'function')
			config.step = DEFAULTS.step;

		if (typeof config.complete !== 'function')
			config.complete = DEFAULTS.complete;

		if (typeof config.keepEmptyRows !== 'boolean')
			config.keepEmptyRows = DEFAULTS.keepEmptyRows;

		return config;
	}

	function copy(obj)
	{
		if (typeof obj !== 'object')
			return obj;
		var cpy = obj instanceof Array ? [] : {};
		for (var key in obj)
			cpy[key] = copy(obj[key]);
		return cpy;
	}

	function isFunction(func)
	{
		return typeof func === 'function';
	}






	// export to Node...
	if ( typeof module !== 'undefined' && module.exports ) {
		module.exports = Baby;
	}

	// ...or as AMD module...
	else if ( typeof define === 'function' && define.amd ) {
		define( function () { return Baby; });
	}

	// ...or as browser global
	else {
		global.Baby = Baby;
	}



}( typeof window !== 'undefined' ? window : this ));

},{}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\node_modules\\numeral\\numeral.js":[function(require,module,exports){
/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var numeral,
        VERSION = '1.5.3',
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',
        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports);


    /************************************
        Constructors
    ************************************/


    // Numeral prototype object
    function Numeral (number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed (value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;
            
        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral (n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) { // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) { // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) { // time
            output = formatTime(n, format);
        } else { // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral (n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency (n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage (n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);
        
        if (output.indexOf(')') > -1 ) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime (n) {
        var hours = Math.floor(n._value/60/60),
            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
    }

    function unformatTime (string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
            // minutes
            seconds = seconds + (Number(timeArray[1]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + (Number(timeArray[0]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber (value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false, // force abbreviation to thousands
            abbrM = false, // force abbreviation to millions
            abbrB = false, // force abbreviation to billions
            abbrT = false, // force abbreviation to trillions
            abbrForce = false, // force abbreviation
            bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power+1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    numeral = function (input) {
        if (numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if(!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return numeral;
    };
    
    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }
        
        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }
        
        return languages[key];
    };

    numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    numeral.zeroFormat = function (format) {
        zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function (format) {
        defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';
            
            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }
            
            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    
    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
        return mp > mn ? mp : mn;
        }, -Infinity);
    }        


    /************************************
        Numeral Prototype
    ************************************/


    numeral.fn = Numeral.prototype = {

        clone : function () {
            return numeral(this);
        },

        format : function (inputString, roundingFunction) {
            return formatNumeral(this, 
                  inputString ? inputString : defaultFormat, 
                  (roundingFunction !== undefined) ? roundingFunction : Math.round
              );
        },

        unformat : function (inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') { 
                return inputString; 
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value : function () {
            return this._value;
        },

        valueOf : function () {
            return this._value;
        },

        set : function (value) {
            this._value = Number(value);
            return this;
        },

        add : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            
            return this;
        },

        multiply : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) * (curr * corrFactor) /
                    (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);            
            return this;
        },

        difference : function (value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    // CommonJS module is defined
    if (hasModule) {
        module.exports = numeral;
    }

    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `numeral` as a global object via a string identifier,
        // for Closure Compiler 'advanced' mode
        this['numeral'] = numeral;
    }

    /*global define:false */
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return numeral;
        });
    }
}).call(this);

},{}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\dashboard\\dev\\node_modules\\nvd3\\build\\nv.d3.js":[function(require,module,exports){
/* nvd3 version 1.7.1(https://github.com/novus/nvd3) 2015-02-05 */
(function(){

// set up main nv object on window
var nv = window.nv || {};
window.nv = nv;

// the major global objects under the nv namespace
nv.dev = false; //set false when in production
nv.tooltip = nv.tooltip || {}; // For the tooltip system
nv.utils = nv.utils || {}; // Utility subsystem
nv.models = nv.models || {}; //stores all the possible models/components
nv.charts = {}; //stores all the ready to use charts
nv.graphs = []; //stores all the graphs currently on the page
nv.logs = {}; //stores some statistics and potential error messages

nv.dispatch = d3.dispatch('render_start', 'render_end');

// Function bind polyfill
// Needed ONLY for phantomJS as it's missing until version 2.0 which is unreleased as of this comment
// https://github.com/ariya/phantomjs/issues/10522
// http://kangax.github.io/compat-table/es5/#Function.prototype.bind
// phantomJS is used for running the test suite
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== "function") {
            // closest thing possible to the ECMAScript 5 internal IsCallable function
            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        }

        var aArgs = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP = function () {},
            fBound = function () {
                return fToBind.apply(this instanceof fNOP && oThis
                        ? this
                        : oThis,
                    aArgs.concat(Array.prototype.slice.call(arguments)));
            };

        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
}

//  Development render timers - disabled if dev = false
if (nv.dev) {
    nv.dispatch.on('render_start', function(e) {
        nv.logs.startTime = +new Date();
    });

    nv.dispatch.on('render_end', function(e) {
        nv.logs.endTime = +new Date();
        nv.logs.totalTime = nv.logs.endTime - nv.logs.startTime;
        nv.log('total', nv.logs.totalTime); // used for development, to keep track of graph generation times
    });
}

// Logs all arguments, and returns the last so you can test things in place
// Note: in IE8 console.log is an object not a function, and if modernizr is used
// then calling Function.prototype.bind with with anything other than a function
// causes a TypeError to be thrown.
nv.log = function() {
    if (nv.dev && window.console && console.log && console.log.apply)
        console.log.apply(console, arguments);
    else if (nv.dev && window.console && typeof console.log == "function" && Function.prototype.bind) {
        var log = Function.prototype.bind.call(console.log, console);
        log.apply(console, arguments);
    }
    return arguments[arguments.length - 1];
};

// print console warning, should be used by deprecated functions
nv.deprecated = function(name) {
    if (nv.dev && console && console.warn) {
        console.warn('`' + name + '` has been deprecated.');
    }
};

// render function is used to queue up chart rendering
// in non-blocking timeout functions
nv.render = function render(step) {
    // number of graphs to generate in each timeout loop
    step = step || 1;

    nv.render.active = true;
    nv.dispatch.render_start();

    setTimeout(function() {
        var chart, graph;

        for (var i = 0; i < step && (graph = nv.render.queue[i]); i++) {
            chart = graph.generate();
            if (typeof graph.callback == typeof(Function)) graph.callback(chart);
            nv.graphs.push(chart);
        }

        nv.render.queue.splice(0, i);

        if (nv.render.queue.length) setTimeout(arguments.callee, 0);
        else {
            nv.dispatch.render_end();
            nv.render.active = false;
        }
    }, 0);
};

nv.render.active = false;
nv.render.queue = [];

// main function to use when adding a new graph, see examples
nv.addGraph = function(obj) {
    if (typeof arguments[0] === typeof(Function)) {
        obj = {generate: arguments[0], callback: arguments[1]};
    }

    nv.render.queue.push(obj);

    if (!nv.render.active) {
        nv.render();
    }
};/* Utility class to handle creation of an interactive layer.
 This places a rectangle on top of the chart. When you mouse move over it, it sends a dispatch
 containing the X-coordinate. It can also render a vertical line where the mouse is located.

 dispatch.elementMousemove is the important event to latch onto.  It is fired whenever the mouse moves over
 the rectangle. The dispatch is given one object which contains the mouseX/Y location.
 It also has 'pointXValue', which is the conversion of mouseX to the x-axis scale.
 */
nv.interactiveGuideline = function() {
    "use strict";

    var tooltip = nv.models.tooltip();

    //Public settings
    var width = null;
    var height = null;

    //Please pass in the bounding chart's top and left margins
    //This is important for calculating the correct mouseX/Y positions.
    var margin = {left: 0, top: 0}
        , xScale = d3.scale.linear()
        , yScale = d3.scale.linear()
        , dispatch = d3.dispatch('elementMousemove', 'elementMouseout', 'elementClick', 'elementDblclick')
        , showGuideLine = true;
    //Must pass in the bounding chart's <svg> container.
    //The mousemove event is attached to this container.
    var svgContainer = null;

    // check if IE by looking for activeX
    var isMSIE = "ActiveXObject" in window;


    function layer(selection) {
        selection.each(function(data) {
            var container = d3.select(this);
            var availableWidth = (width || 960), availableHeight = (height || 400);
            var wrap = container.selectAll("g.nv-wrap.nv-interactiveLineLayer")
                .data([data]);
            var wrapEnter = wrap.enter()
                .append("g").attr("class", " nv-wrap nv-interactiveLineLayer");
            wrapEnter.append("g").attr("class","nv-interactiveGuideLine");

            if (!svgContainer) {
                return;
            }

            function mouseHandler() {
                var d3mouse = d3.mouse(this);
                var mouseX = d3mouse[0];
                var mouseY = d3mouse[1];
                var subtractMargin = true;
                var mouseOutAnyReason = false;
                if (isMSIE) {
                    /*
                     D3.js (or maybe SVG.getScreenCTM) has a nasty bug in Internet Explorer 10.
                     d3.mouse() returns incorrect X,Y mouse coordinates when mouse moving
                     over a rect in IE 10.
                     However, d3.event.offsetX/Y also returns the mouse coordinates
                     relative to the triggering <rect>. So we use offsetX/Y on IE.
                     */
                    mouseX = d3.event.offsetX;
                    mouseY = d3.event.offsetY;

                    /*
                     On IE, if you attach a mouse event listener to the <svg> container,
                     it will actually trigger it for all the child elements (like <path>, <circle>, etc).
                     When this happens on IE, the offsetX/Y is set to where ever the child element
                     is located.
                     As a result, we do NOT need to subtract margins to figure out the mouse X/Y
                     position under this scenario. Removing the line below *will* cause
                     the interactive layer to not work right on IE.
                     */
                    if(d3.event.target.tagName !== "svg") {
                        subtractMargin = false;
                    }

                    if (d3.event.target.className.baseVal.match("nv-legend")) {
                        mouseOutAnyReason = true;
                    }

                }

                if(subtractMargin) {
                    mouseX -= margin.left;
                    mouseY -= margin.top;
                }

                /* If mouseX/Y is outside of the chart's bounds,
                 trigger a mouseOut event.
                 */
                if (mouseX < 0 || mouseY < 0
                    || mouseX > availableWidth || mouseY > availableHeight
                    || (d3.event.relatedTarget && d3.event.relatedTarget.ownerSVGElement === undefined)
                    || mouseOutAnyReason
                    ) {

                    if (isMSIE) {
                        if (d3.event.relatedTarget
                            && d3.event.relatedTarget.ownerSVGElement === undefined
                            && d3.event.relatedTarget.className.match(tooltip.nvPointerEventsClass)) {

                            return;
                        }
                    }
                    dispatch.elementMouseout({
                        mouseX: mouseX,
                        mouseY: mouseY
                    });
                    layer.renderGuideLine(null); //hide the guideline
                    return;
                }

                var pointXValue = xScale.invert(mouseX);
                dispatch.elementMousemove({
                    mouseX: mouseX,
                    mouseY: mouseY,
                    pointXValue: pointXValue
                });

                //If user double clicks the layer, fire a elementDblclick
                if (d3.event.type === "dblclick") {
                    dispatch.elementDblclick({
                        mouseX: mouseX,
                        mouseY: mouseY,
                        pointXValue: pointXValue
                    });
                }

                // if user single clicks the layer, fire elementClick
                if (d3.event.type === 'click') {
                    dispatch.elementClick({
                        mouseX: mouseX,
                        mouseY: mouseY,
                        pointXValue: pointXValue
                    });
                }
            }

            svgContainer
                .on("mousemove",mouseHandler, true)
                .on("mouseout" ,mouseHandler,true)
                .on("dblclick" ,mouseHandler)
                .on("click", mouseHandler)
            ;

            //Draws a vertical guideline at the given X postion.
            layer.renderGuideLine = function(x) {
                if (!showGuideLine) return;
                var line = wrap.select(".nv-interactiveGuideLine")
                    .selectAll("line")
                    .data((x != null) ? [nv.utils.NaNtoZero(x)] : [], String);

                line.enter()
                    .append("line")
                    .attr("class", "nv-guideline")
                    .attr("x1", function(d) { return d;})
                    .attr("x2", function(d) { return d;})
                    .attr("y1", availableHeight)
                    .attr("y2",0)
                ;
                line.exit().remove();

            }
        });
    }

    layer.dispatch = dispatch;
    layer.tooltip = tooltip;

    layer.margin = function(_) {
        if (!arguments.length) return margin;
        margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
        margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
        return layer;
    };

    layer.width = function(_) {
        if (!arguments.length) return width;
        width = _;
        return layer;
    };

    layer.height = function(_) {
        if (!arguments.length) return height;
        height = _;
        return layer;
    };

    layer.xScale = function(_) {
        if (!arguments.length) return xScale;
        xScale = _;
        return layer;
    };

    layer.showGuideLine = function(_) {
        if (!arguments.length) return showGuideLine;
        showGuideLine = _;
        return layer;
    };

    layer.svgContainer = function(_) {
        if (!arguments.length) return svgContainer;
        svgContainer = _;
        return layer;
    };

    return layer;
};

/* Utility class that uses d3.bisect to find the index in a given array, where a search value can be inserted.
 This is different from normal bisectLeft; this function finds the nearest index to insert the search value.

 For instance, lets say your array is [1,2,3,5,10,30], and you search for 28.
 Normal d3.bisectLeft will return 4, because 28 is inserted after the number 10.  But interactiveBisect will return 5
 because 28 is closer to 30 than 10.

 Unit tests can be found in: interactiveBisectTest.html

 Has the following known issues:
 * Will not work if the data points move backwards (ie, 10,9,8,7, etc) or if the data points are in random order.
 * Won't work if there are duplicate x coordinate values.
 */
nv.interactiveBisect = function (values, searchVal, xAccessor) {
    "use strict";
    if (! (values instanceof Array)) {
        return null;
    }
    if (typeof xAccessor !== 'function') {
        xAccessor = function(d,i) {
            return d.x;
        }
    }

    var bisect = d3.bisector(xAccessor).left;
    var index = d3.max([0, bisect(values,searchVal) - 1]);
    var currentValue = xAccessor(values[index], index);

    if (typeof currentValue === 'undefined') {
        currentValue = index;
    }

    if (currentValue === searchVal) {
        return index; //found exact match
    }

    var nextIndex = d3.min([index+1, values.length - 1]);
    var nextValue = xAccessor(values[nextIndex], nextIndex);

    if (typeof nextValue === 'undefined') {
        nextValue = nextIndex;
    }

    if (Math.abs(nextValue - searchVal) >= Math.abs(currentValue - searchVal)) {
        return index;
    } else {
        return nextIndex
    }
};

/*
 Returns the index in the array "values" that is closest to searchVal.
 Only returns an index if searchVal is within some "threshold".
 Otherwise, returns null.
 */
nv.nearestValueIndex = function (values, searchVal, threshold) {
    "use strict";
    var yDistMax = Infinity, indexToHighlight = null;
    values.forEach(function(d,i) {
        var delta = Math.abs(searchVal - d);
        if ( delta <= yDistMax && delta < threshold) {
            yDistMax = delta;
            indexToHighlight = i;
        }
    });
    return indexToHighlight;
};
/* Tooltip rendering model for nvd3 charts.
 window.nv.models.tooltip is the updated,new way to render tooltips.

 window.nv.tooltip.show is the old tooltip code.
 window.nv.tooltip.* also has various helper methods.
 */
(function() {
    "use strict";
    window.nv.tooltip = {};

    /* Model which can be instantiated to handle tooltip rendering.
     Example usage:
     var tip = nv.models.tooltip().gravity('w').distance(23)
     .data(myDataObject);

     tip();    //just invoke the returned function to render tooltip.
     */
    window.nv.models.tooltip = function() {
        //HTML contents of the tooltip.  If null, the content is generated via the data variable.
        var content = null;

        /*
        Tooltip data. If data is given in the proper format, a consistent tooltip is generated.
        Example Format of data:
        {
            key: "Date",
            value: "August 2009",
            series: [
                {key: "Series 1", value: "Value 1", color: "#000"},
                {key: "Series 2", value: "Value 2", color: "#00f"}
            ]
        }
        */
        var data = null;

        var gravity = 'w'   //Can be 'n','s','e','w'. Determines how tooltip is positioned.
            ,distance = 50   //Distance to offset tooltip from the mouse location.
            ,snapDistance = 25   //Tolerance allowed before tooltip is moved from its current position (creates 'snapping' effect)
            ,   fixedTop = null //If not null, this fixes the top position of the tooltip.
            ,   classes = null  //Attaches additional CSS classes to the tooltip DIV that is created.
            ,   chartContainer = null   //Parent DIV, of the SVG Container that holds the chart.
            ,   tooltipElem = null  //actual DOM element representing the tooltip.
            ,   position = {left: null, top: null}      //Relative position of the tooltip inside chartContainer.
            ,   enabled = true;  //True -> tooltips are rendered. False -> don't render tooltips.

        //Generates a unique id when you create a new tooltip() object
        var id = "nvtooltip-" + Math.floor(Math.random() * 100000);

        //CSS class to specify whether element should not have mouse events.
        var  nvPointerEventsClass = "nv-pointer-events-none";

        //Format function for the tooltip values column
        var valueFormatter = function(d,i) {
            return d;
        };

        //Format function for the tooltip header value.
        var headerFormatter = function(d) {
            return d;
        };

        //By default, the tooltip model renders a beautiful table inside a DIV.
        //You can override this function if a custom tooltip is desired.
        var contentGenerator = function(d) {
            if (content != null) {
                return content;
            }

            if (d == null) {
                return '';
            }

            var table = d3.select(document.createElement("table"));
            var theadEnter = table.selectAll("thead")
                .data([d])
                .enter().append("thead");

            theadEnter.append("tr")
                .append("td")
                .attr("colspan",3)
                .append("strong")
                .classed("x-value",true)
                .html(headerFormatter(d.value));

            var tbodyEnter = table.selectAll("tbody")
                .data([d])
                .enter().append("tbody");

            var trowEnter = tbodyEnter.selectAll("tr")
                    .data(function(p) { return p.series})
                    .enter()
                    .append("tr")
                    .classed("highlight", function(p) { return p.highlight});

            trowEnter.append("td")
                .classed("legend-color-guide",true)
                .append("div")
                .style("background-color", function(p) { return p.color});

            trowEnter.append("td")
                .classed("key",true)
                .html(function(p) {return p.key});

            trowEnter.append("td")
                .classed("value",true)
                .html(function(p,i) { return valueFormatter(p.value,i) });


            trowEnter.selectAll("td").each(function(p) {
                if (p.highlight) {
                    var opacityScale = d3.scale.linear().domain([0,1]).range(["#fff",p.color]);
                    var opacity = 0.6;
                    d3.select(this)
                        .style("border-bottom-color", opacityScale(opacity))
                        .style("border-top-color", opacityScale(opacity))
                    ;
                }
            });

            var html = table.node().outerHTML;
            if (d.footer !== undefined)
                html += "<div class='footer'>" + d.footer + "</div>";
            return html;

        };

        var dataSeriesExists = function(d) {
            if (d && d.series && d.series.length > 0) {
                return true;
            }
            return false;
        };

        //In situations where the chart is in a 'viewBox', re-position the tooltip based on how far chart is zoomed.
        function convertViewBoxRatio() {
            if (chartContainer) {
                var svg = d3.select(chartContainer);
                if (svg.node().tagName !== "svg") {
                    svg = svg.select("svg");
                }
                var viewBox = (svg.node()) ? svg.attr('viewBox') : null;
                if (viewBox) {
                    viewBox = viewBox.split(' ');
                    var ratio = parseInt(svg.style('width')) / viewBox[2];

                    position.left = position.left * ratio;
                    position.top  = position.top * ratio;
                }
            }
        }

        //Creates new tooltip container, or uses existing one on DOM.
        function getTooltipContainer(newContent) {
            var body;
            if (chartContainer) {
                body = d3.select(chartContainer);
            } else {
                body = d3.select("body");
            }

            var container = body.select(".nvtooltip");
            if (container.node() === null) {
                //Create new tooltip div if it doesn't exist on DOM.
                container = body.append("div")
                    .attr("class", "nvtooltip " + (classes? classes: "xy-tooltip"))
                    .attr("id",id)
                ;
            }

            container.node().innerHTML = newContent;
            container.style("top",0).style("left",0).style("opacity",0);
            container.selectAll("div, table, td, tr").classed(nvPointerEventsClass,true)
            container.classed(nvPointerEventsClass,true);
            return container.node();
        }

        //Draw the tooltip onto the DOM.
        function nvtooltip() {
            if (!enabled) return;
            if (!dataSeriesExists(data)) return;

            convertViewBoxRatio();

            var left = position.left;
            var top = (fixedTop != null) ? fixedTop : position.top;
            var container = getTooltipContainer(contentGenerator(data));
            tooltipElem = container;
            if (chartContainer) {
                var svgComp = chartContainer.getElementsByTagName("svg")[0];
                var boundRect = (svgComp) ? svgComp.getBoundingClientRect() : chartContainer.getBoundingClientRect();
                var svgOffset = {left:0,top:0};
                if (svgComp) {
                    var svgBound = svgComp.getBoundingClientRect();
                    var chartBound = chartContainer.getBoundingClientRect();
                    var svgBoundTop = svgBound.top;

                    //Defensive code. Sometimes, svgBoundTop can be a really negative
                    //  number, like -134254. That's a bug.
                    //  If such a number is found, use zero instead. FireFox bug only
                    if (svgBoundTop < 0) {
                        var containerBound = chartContainer.getBoundingClientRect();
                        svgBoundTop = (Math.abs(svgBoundTop) > containerBound.height) ? 0 : svgBoundTop;
                    }
                    svgOffset.top = Math.abs(svgBoundTop - chartBound.top);
                    svgOffset.left = Math.abs(svgBound.left - chartBound.left);
                }
                //If the parent container is an overflow <div> with scrollbars, subtract the scroll offsets.
                //You need to also add any offset between the <svg> element and its containing <div>
                //Finally, add any offset of the containing <div> on the whole page.
                left += chartContainer.offsetLeft + svgOffset.left - 2*chartContainer.scrollLeft;
                top += chartContainer.offsetTop + svgOffset.top - 2*chartContainer.scrollTop;
            }

            if (snapDistance && snapDistance > 0) {
                top = Math.floor(top/snapDistance) * snapDistance;
            }

            nv.tooltip.calcTooltipPosition([left,top], gravity, distance, container);
            return nvtooltip;
        }

        nvtooltip.nvPointerEventsClass = nvPointerEventsClass;

        nvtooltip.content = function(_) {
            if (!arguments.length) return content;
            content = _;
            return nvtooltip;
        };

        //Returns tooltipElem...not able to set it.
        nvtooltip.tooltipElem = function() {
            return tooltipElem;
        };

        nvtooltip.contentGenerator = function(_) {
            if (!arguments.length) return contentGenerator;
            if (typeof _ === 'function') {
                contentGenerator = _;
            }
            return nvtooltip;
        };

        nvtooltip.data = function(_) {
            if (!arguments.length) return data;
            data = _;
            return nvtooltip;
        };

        nvtooltip.gravity = function(_) {
            if (!arguments.length) return gravity;
            gravity = _;
            return nvtooltip;
        };

        nvtooltip.distance = function(_) {
            if (!arguments.length) return distance;
            distance = _;
            return nvtooltip;
        };

        nvtooltip.snapDistance = function(_) {
            if (!arguments.length) return snapDistance;
            snapDistance = _;
            return nvtooltip;
        };

        nvtooltip.classes = function(_) {
            if (!arguments.length) return classes;
            classes = _;
            return nvtooltip;
        };

        nvtooltip.chartContainer = function(_) {
            if (!arguments.length) return chartContainer;
            chartContainer = _;
            return nvtooltip;
        };

        nvtooltip.position = function(_) {
            if (!arguments.length) return position;
            position.left = (typeof _.left !== 'undefined') ? _.left : position.left;
            position.top = (typeof _.top !== 'undefined') ? _.top : position.top;
            return nvtooltip;
        };

        nvtooltip.fixedTop = function(_) {
            if (!arguments.length) return fixedTop;
            fixedTop = _;
            return nvtooltip;
        };

        nvtooltip.enabled = function(_) {
            if (!arguments.length) return enabled;
            enabled = _;
            return nvtooltip;
        };

        nvtooltip.valueFormatter = function(_) {
            if (!arguments.length) return valueFormatter;
            if (typeof _ === 'function') {
                valueFormatter = _;
            }
            return nvtooltip;
        };

        nvtooltip.headerFormatter = function(_) {
            if (!arguments.length) return headerFormatter;
            if (typeof _ === 'function') {
                headerFormatter = _;
            }
            return nvtooltip;
        };

        //id() is a read-only function. You can't use it to set the id.
        nvtooltip.id = function() {
            return id;
        };

        return nvtooltip;
    };

    //Original tooltip.show function. Kept for backward compatibility.
    // pos = [left,top]
    nv.tooltip.show = function(pos, content, gravity, dist, parentContainer, classes) {

        //Create new tooltip div if it doesn't exist on DOM.
        var   container = document.createElement('div');
        container.className = 'nvtooltip ' + (classes ? classes : 'xy-tooltip');

        var body = parentContainer;
        if ( !parentContainer || parentContainer.tagName.match(/g|svg/i)) {
            //If the parent element is an SVG element, place tooltip in the <body> element.
            body = document.getElementsByTagName('body')[0];
        }

        container.style.left = 0;
        container.style.top = 0;
        container.style.opacity = 0;
        // Content can also be dom element
        if (typeof content !== 'string')
            container.appendChild(content);
        else
            container.innerHTML = content;
        body.appendChild(container);

        //If the parent container is an overflow <div> with scrollbars, subtract the scroll offsets.
        if (parentContainer) {
            pos[0] = pos[0] - parentContainer.scrollLeft;
            pos[1] = pos[1] - parentContainer.scrollTop;
        }
        nv.tooltip.calcTooltipPosition(pos, gravity, dist, container);
    };

    //Looks up the ancestry of a DOM element, and returns the first NON-svg node.
    nv.tooltip.findFirstNonSVGParent = function(Elem) {
        while(Elem.tagName.match(/^g|svg$/i) !== null) {
            Elem = Elem.parentNode;
        }
        return Elem;
    };

    //Finds the total offsetTop of a given DOM element.
    //Looks up the entire ancestry of an element, up to the first relatively positioned element.
    nv.tooltip.findTotalOffsetTop = function ( Elem, initialTop ) {
        var offsetTop = initialTop;

        do {
            if( !isNaN( Elem.offsetTop ) ) {
                offsetTop += (Elem.offsetTop);
            }
        } while( Elem = Elem.offsetParent );
        return offsetTop;
    };

    //Finds the total offsetLeft of a given DOM element.
    //Looks up the entire ancestry of an element, up to the first relatively positioned element.
    nv.tooltip.findTotalOffsetLeft = function ( Elem, initialLeft) {
        var offsetLeft = initialLeft;

        do {
            if( !isNaN( Elem.offsetLeft ) ) {
                offsetLeft += (Elem.offsetLeft);
            }
        } while( Elem = Elem.offsetParent );
        return offsetLeft;
    };

    //Global utility function to render a tooltip on the DOM.
    //pos = [left,top] coordinates of where to place the tooltip, relative to the SVG chart container.
    //gravity = how to orient the tooltip
    //dist = how far away from the mouse to place tooltip
    //container = tooltip DIV
    nv.tooltip.calcTooltipPosition = function(pos, gravity, dist, container) {

        var height = parseInt(container.offsetHeight),
            width = parseInt(container.offsetWidth),
            windowWidth = nv.utils.windowSize().width,
            windowHeight = nv.utils.windowSize().height,
            scrollTop = window.pageYOffset,
            scrollLeft = window.pageXOffset,
            left, top;

        windowHeight = window.innerWidth >= document.body.scrollWidth ? windowHeight : windowHeight - 16;
        windowWidth = window.innerHeight >= document.body.scrollHeight ? windowWidth : windowWidth - 16;

        gravity = gravity || 's';
        dist = dist || 20;

        var tooltipTop = function ( Elem ) {
            return nv.tooltip.findTotalOffsetTop(Elem, top);
        };

        var tooltipLeft = function ( Elem ) {
            return nv.tooltip.findTotalOffsetLeft(Elem,left);
        };

        switch (gravity) {
            case 'e':
                left = pos[0] - width - dist;
                top = pos[1] - (height / 2);
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft < scrollLeft) left = pos[0] + dist > scrollLeft ? pos[0] + dist : scrollLeft - tLeft + left;
                if (tTop < scrollTop) top = scrollTop - tTop + top;
                if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;
                break;
            case 'w':
                left = pos[0] + dist;
                top = pos[1] - (height / 2);
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft + width > windowWidth) left = pos[0] - width - dist;
                if (tTop < scrollTop) top = scrollTop + 5;
                if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;
                break;
            case 'n':
                left = pos[0] - (width / 2) - 5;
                top = pos[1] + dist;
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft < scrollLeft) left = scrollLeft + 5;
                if (tLeft + width > windowWidth) left = left - width/2 + 5;
                if (tTop + height > scrollTop + windowHeight) top = scrollTop + windowHeight - tTop + top - height;
                break;
            case 's':
                left = pos[0] - (width / 2);
                top = pos[1] - height - dist;
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                if (tLeft < scrollLeft) left = scrollLeft + 5;
                if (tLeft + width > windowWidth) left = left - width/2 + 5;
                if (scrollTop > tTop) top = scrollTop;
                break;
            case 'none':
                left = pos[0];
                top = pos[1] - dist;
                var tLeft = tooltipLeft(container);
                var tTop = tooltipTop(container);
                break;
        }

        container.style.left = left+'px';
        container.style.top = top+'px';
        container.style.opacity = 1;
        container.style.position = 'absolute';

        return container;
    };

    //Global utility function to remove tooltips from the DOM.
    nv.tooltip.cleanup = function() {

        // Find the tooltips, mark them for removal by this class (so others cleanups won't find it)
        var tooltips = document.getElementsByClassName('nvtooltip');
        var purging = [];
        while(tooltips.length) {
            purging.push(tooltips[0]);
            tooltips[0].style.transitionDelay = '0 !important';
            tooltips[0].style.opacity = 0;
            tooltips[0].className = 'nvtooltip-pending-removal';
        }

        setTimeout(function() {

            while (purging.length) {
                var removeMe = purging.pop();
                removeMe.parentNode.removeChild(removeMe);
            }
        }, 500);
    };

})();


/*
Gets the browser window size

Returns object with height and width properties
 */
nv.utils.windowSize = function() {
    // Sane defaults
    var size = {width: 640, height: 480};

    // Earlier IE uses Doc.body
    if (document.body && document.body.offsetWidth) {
        size.width = document.body.offsetWidth;
        size.height = document.body.offsetHeight;
    }

    // IE can use depending on mode it is in
    if (document.compatMode=='CSS1Compat' &&
        document.documentElement &&
        document.documentElement.offsetWidth ) {

        size.width = document.documentElement.offsetWidth;
        size.height = document.documentElement.offsetHeight;
    }

    // Most recent browsers use
    if (window.innerWidth && window.innerHeight) {
        size.width = window.innerWidth;
        size.height = window.innerHeight;
    }
    return (size);
};


/*
Binds callback function to run when window is resized
 */
nv.utils.windowResize = function(handler) {
    if (window.addEventListener) {
        window.addEventListener('resize', handler);
    } else {
        nv.log("ERROR: Failed to bind to window.resize with: ", handler);
    }
    // return object with clear function to remove the single added callback.
    return {
        callback: handler,
        clear: function() {
            window.removeEventListener('resize', handler);
        }
    }
};


/*
Backwards compatible way to implement more d3-like coloring of graphs.
If passed an array, wrap it in a function which implements the old behavior
Else return what was passed in
*/
nv.utils.getColor = function(color) {
    //if you pass in nothing, get default colors back
    if (!arguments.length) {
        return nv.utils.defaultColor();

    //if passed an array, wrap it in a function
    } else if(color instanceof Array) {
        return function(d, i) { return d.color || color[i % color.length]; };

    //if passed a function, return the function, or whatever it may be
    //external libs, such as angularjs-nvd3-directives use this
    } else {
        //can't really help it if someone passes rubbish as color
        return color;
    }
};


/*
Default color chooser uses the index of an object as before.
 */
nv.utils.defaultColor = function() {
    var colors = d3.scale.category20().range();
    return function(d, i) {
        return d.color || colors[i % colors.length]
    };
};


/*
Returns a color function that takes the result of 'getKey' for each series and
looks for a corresponding color from the dictionary
*/
nv.utils.customTheme = function(dictionary, getKey, defaultColors) {
    // use default series.key if getKey is undefined
    getKey = getKey || function(series) { return series.key };
    defaultColors = defaultColors || d3.scale.category20().range();

    // start at end of default color list and walk back to index 0
    var defIndex = defaultColors.length;

    return function(series, index) {
        var key = getKey(series);
        if (typeof dictionary[key] === 'function') {
            return dictionary[key]();
        } else if (dictionary[key] !== undefined) {
            return dictionary[key];
        } else {
            // no match in dictionary, use a default color
            if (!defIndex) {
                // used all the default colors, start over
                defIndex = defaultColors.length;
            }
            defIndex = defIndex - 1;
            return defaultColors[defIndex];
        }
    };
};


/*
From the PJAX example on d3js.org, while this is not really directly needed
it's a very cool method for doing pjax, I may expand upon it a little bit,
open to suggestions on anything that may be useful
*/
nv.utils.pjax = function(links, content) {

    var load = function(href) {
        d3.html(href, function(fragment) {
            var target = d3.select(content).node();
            target.parentNode.replaceChild(
                d3.select(fragment).select(content).node(),
                target);
            nv.utils.pjax(links, content);
        });
    };

    d3.selectAll(links).on("click", function() {
        history.pushState(this.href, this.textContent, this.href);
        load(this.href);
        d3.event.preventDefault();
    });

    d3.select(window).on("popstate", function() {
        if (d3.event.state) {
            load(d3.event.state);
        }
    });
};


/*
For when we want to approximate the width in pixels for an SVG:text element.
Most common instance is when the element is in a display:none; container.
Forumla is : text.length * font-size * constant_factor
*/
nv.utils.calcApproxTextWidth = function (svgTextElem) {
    if (typeof svgTextElem.style === 'function'
        && typeof svgTextElem.text === 'function') {

        var fontSize = parseInt(svgTextElem.style("font-size").replace("px",""));
        var textLength = svgTextElem.text().length;
        return textLength * fontSize * 0.5;
    }
    return 0;
};


/*
Numbers that are undefined, null or NaN, convert them to zeros.
*/
nv.utils.NaNtoZero = function(n) {
    if (typeof n !== 'number'
        || isNaN(n)
        || n === null
        || n === Infinity
        || n === -Infinity) {

        return 0;
    }
    return n;
};

/*
Add a way to watch for d3 transition ends to d3
*/
d3.selection.prototype.watchTransition = function(renderWatch){
    var args = [this].concat([].slice.call(arguments, 1));
    return renderWatch.transition.apply(renderWatch, args);
};


/*
Helper object to watch when d3 has rendered something
*/
nv.utils.renderWatch = function(dispatch, duration) {
    if (!(this instanceof nv.utils.renderWatch)) {
        return new nv.utils.renderWatch(dispatch, duration);
    }

    var _duration = duration !== undefined ? duration : 250;
    var renderStack = [];
    var self = this;

    this.models = function(models) {
        models = [].slice.call(arguments, 0);
        models.forEach(function(model){
            model.__rendered = false;
            (function(m){
                m.dispatch.on('renderEnd', function(arg){
                    m.__rendered = true;
                    self.renderEnd('model');
                });
            })(model);

            if (renderStack.indexOf(model) < 0) {
                renderStack.push(model);
            }
        });
    return this;
    };

    this.reset = function(duration) {
        if (duration !== undefined) {
            _duration = duration;
        }
        renderStack = [];
    };

    this.transition = function(selection, args, duration) {
        args = arguments.length > 1 ? [].slice.call(arguments, 1) : [];

        if (args.length > 1) {
            duration = args.pop();
        } else {
            duration = _duration !== undefined ? _duration : 250;
        }
        selection.__rendered = false;

        if (renderStack.indexOf(selection) < 0) {
            renderStack.push(selection);
        }

        if (duration === 0) {
            selection.__rendered = true;
            selection.delay = function() { return this; };
            selection.duration = function() { return this; };
            return selection;
        } else {
            if (selection.length === 0) {
                selection.__rendered = true;
            } else if (selection.every( function(d){ return !d.length; } )) {
                selection.__rendered = true;
            } else {
                selection.__rendered = false;
            }

            var n = 0;
            return selection
                .transition()
                .duration(duration)
                .each(function(){ ++n; })
                .each('end', function(d, i) {
                    if (--n === 0) {
                        selection.__rendered = true;
                        self.renderEnd.apply(this, args);
                    }
                });
        }
    };

    this.renderEnd = function() {
        if (renderStack.every( function(d){ return d.__rendered; } )) {
            renderStack.forEach( function(d){ d.__rendered = false; });
            dispatch.renderEnd.apply(this, arguments);
        }
    }

};


/*
Takes multiple objects and combines them into the first one (dst)
example:  nv.utils.deepExtend({a: 1}, {a: 2, b: 3}, {c: 4});
gives:  {a: 2, b: 3, c: 4}
*/
nv.utils.deepExtend = function(dst){
    var sources = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
    sources.forEach(function(source) {
        for (key in source) {
            var isArray = dst[key] instanceof Array;
            var isObject = typeof dst[key] === 'object';
            var srcObj = typeof source[key] === 'object';

            if (isObject && !isArray && srcObj) {
                nv.utils.deepExtend(dst[key], source[key]);
            } else {
                dst[key] = source[key];
            }
        }
    });
};


/*
state utility object, used to track d3 states in the models
*/
nv.utils.state = function(){
    if (!(this instanceof nv.utils.state)) {
        return new nv.utils.state();
    }
    var state = {};
    var _self = this;
    var _setState = function(){};
    var _getState = function(){ return {}; };
    var init = null;
    var changed = null;

    this.dispatch = d3.dispatch('change', 'set');

    this.dispatch.on('set', function(state){
        _setState(state, true);
    });

    this.getter = function(fn){
        _getState = fn;
        return this;
    };

    this.setter = function(fn, callback) {
        if (!callback) {
            callback = function(){};
        }
        _setState = function(state, update){
            fn(state);
            if (update) {
                callback();
            }
        };
        return this;
    };

    this.init = function(state){
        init = init || {};
        nv.utils.deepExtend(init, state);
    };

    var _set = function(){
        var settings = _getState();

        if (JSON.stringify(settings) === JSON.stringify(state)) {
            return false;
        }

        for (var key in settings) {
            if (state[key] === undefined) {
                state[key] = {};
            }
            state[key] = settings[key];
            changed = true;
        }
        return true;
    };

    this.update = function(){
        if (init) {
            _setState(init, false);
            init = null;
        }
        if (_set.call(this)) {
            this.dispatch.change(state);
        }
    };

};


/*
Snippet of code you can insert into each nv.models.* to give you the ability to
do things like:
chart.options({
  showXAxis: true,
  tooltips: true
});

To enable in the chart:
chart.options = nv.utils.optionsFunc.bind(chart);
*/
nv.utils.optionsFunc = function(args) {
    nv.deprecated('nv.utils.optionsFunc');
    if (args) {
        d3.map(args).forEach((function(key,value) {
            if (typeof this[key] === "function") {
                this[key](value);
            }
        }).bind(this));
    }
    return this;
};


/*
numTicks:  requested number of ticks
data:  the chart data

returns the number of ticks to actually use on X axis, based on chart data
to avoid duplicate ticks with the same value
*/
nv.utils.calcTicksX = function(numTicks, data) {
    // find max number of values from all data streams
    var numValues = 1;
    var i = 0;
    for (i; i < data.length; i += 1) {
        var stream_len = data[i] && data[i].values ? data[i].values.length : 0;
        numValues = stream_len > numValues ? stream_len : numValues;
    }
    nv.log("Requested number of ticks: ", numTicks);
    nv.log("Calculated max values to be: ", numValues);
    // make sure we don't have more ticks than values to avoid duplicates
    numTicks = numTicks > numValues ? numTicks = numValues - 1 : numTicks;
    // make sure we have at least one tick
    numTicks = numTicks < 1 ? 1 : numTicks;
    // make sure it's an integer
    numTicks = Math.floor(numTicks);
    nv.log("Calculating tick count as: ", numTicks);
    return numTicks;
};


/*
returns number of ticks to actually use on Y axis, based on chart data
*/
nv.utils.calcTicksY = function(numTicks, data) {
    // currently uses the same logic but we can adjust here if needed later
    return nv.utils.calcTicksX(numTicks, data);
};


/*
Add a particular option from an options object onto chart
Options exposed on a chart are a getter/setter function that returns chart
on set to mimic typical d3 option chaining, e.g. svg.option1('a').option2('b');

option objects should be generated via Object.create() to provide
the option of manipulating data via get/set functions.
*/
nv.utils.initOption = function(chart, name) {
    // if it's a call option, just call it directly, otherwise do get/set
    if (chart._calls && chart._calls[name]) {
        chart[name] = chart._calls[name];
    } else {
        chart[name] = function (_) {
            if (!arguments.length) return chart._options[name];
            chart._options[name] = _;
            return chart;
        };
    }
};


/*
Add all options in an options object to the chart
*/
nv.utils.initOptions = function(chart) {
    var ops = Object.getOwnPropertyNames(chart._options || {});
    var calls = Object.getOwnPropertyNames(chart._calls || {});
    ops = ops.concat(calls);
    for (var i in ops) {
        nv.utils.initOption(chart, ops[i]);
    }
};


/*
Inherit options from a D3 object
d3.rebind makes calling the function on target actually call it on source
Also use _d3options so we can track what we inherit for documentation and chained inheritance
*/
nv.utils.inheritOptionsD3 = function(target, d3_source, oplist) {
    target._d3options = oplist.concat(target._d3options || []);
    oplist.unshift(d3_source);
    oplist.unshift(target);
    d3.rebind.apply(this, oplist);
};


/*
Remove duplicates from an array
*/
nv.utils.arrayUnique = function(a) {
    return a.sort().filter(function(item, pos) {
        return !pos || item != a[pos - 1];
    });
};


/*
Keeps a list of custom symbols to draw from in addition to d3.svg.symbol
Necessary since d3 doesn't let you extend its list -_-
Add new symbols by doing nv.utils.symbols.set('name', function(size){...});
*/
nv.utils.symbolMap = d3.map();


/*
Replaces d3.svg.symbol so that we can look both there and our own map
 */
nv.utils.symbol = function() {
    var type,
        size = 64;
    function symbol(d,i) {
        var t = type.call(this,d,i);
        var s = size.call(this,d,i);
        if (d3.svg.symbolTypes.indexOf(t) !== -1) {
            return d3.svg.symbol().type(t).size(s)();
        } else {
            return nv.utils.symbolMap.get(t)(s);
        }
    }
    symbol.type = function(_) {
        if (!arguments.length) return type;
        type = d3.functor(_);
        return symbol;
    };
    symbol.size = function(_) {
        if (!arguments.length) return size;
        size = d3.functor(_);
        return symbol;
    };
    return symbol;
};


/*
Inherit option getter/setter functions from source to target
d3.rebind makes calling the function on target actually call it on source
Also track via _inherited and _d3options so we can track what we inherit
for documentation generation purposes and chained inheritance
*/
nv.utils.inheritOptions = function(target, source) {
    // inherit all the things
    var ops = Object.getOwnPropertyNames(source._options || {});
    var calls = Object.getOwnPropertyNames(source._calls || {});
    var inherited = source._inherited || [];
    var d3ops = source._d3options || [];
    var args = ops.concat(calls).concat(inherited).concat(d3ops);
    args.unshift(source);
    args.unshift(target);
    d3.rebind.apply(this, args);
    // pass along the lists to keep track of them, don't allow duplicates
    target._inherited = nv.utils.arrayUnique(ops.concat(calls).concat(inherited).concat(ops).concat(target._inherited || []));
    target._d3options = nv.utils.arrayUnique(d3ops.concat(target._d3options || []));
};


/*
Runs common initialize code on the svg before the chart builds
*/
nv.utils.initSVG = function(svg) {
    svg.classed({'nvd3-svg':true});
};nv.models.axis = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var axis = d3.svg.axis();
    var scale = d3.scale.linear();

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 75 //only used for tickLabel currently
        , height = 60 //only used for tickLabel currently
        , axisLabelText = null
        , showMaxMin = true //TODO: showMaxMin should be disabled on all ordinal scaled axes
        , highlightZero = true
        , rotateLabels = 0
        , rotateYLabel = true
        , staggerLabels = false
        , isOrdinal = false
        , ticks = null
        , axisLabelDistance = 0
        , duration = 250
        , dispatch = d3.dispatch('renderEnd')
        , axisRendered = false
        , maxMinRendered = false
        ;
    axis
        .scale(scale)
        .orient('bottom')
        .tickFormat(function(d) { return d })
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var scale0;
    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var container = d3.select(this);
            nv.utils.initSVG(container);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-axis').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-axis');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g')

            if (ticks !== null)
                axis.ticks(ticks);
            else if (axis.orient() == 'top' || axis.orient() == 'bottom')
                axis.ticks(Math.abs(scale.range()[1] - scale.range()[0]) / 100);

            //TODO: consider calculating width/height based on whether or not label is added, for reference in charts using this component
            g.watchTransition(renderWatch, 'axis').call(axis);

            scale0 = scale0 || axis.scale();

            var fmt = axis.tickFormat();
            if (fmt == null) {
                fmt = scale0.tickFormat();
            }

            var axisLabel = g.selectAll('text.nv-axislabel')
                .data([axisLabelText || null]);
            axisLabel.exit().remove();

            switch (axis.orient()) {
                case 'top':
                    axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                    var w;
                    if (scale.range().length < 2) {
                        w = 0;
                    } else if (scale.range().length === 2) {
                        w = scale.range()[1];
                    } else {
                        w = scale.range()[scale.range().length-1]+(scale.range()[1]-scale.range()[0]);
                    }
                    axisLabel
                        .attr('text-anchor', 'middle')
                        .attr('y', 0)
                        .attr('x', w/2);
                    if (showMaxMin) {
                        var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                            .data(scale.domain());
                        axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text');
                        axisMaxMin.exit().remove();
                        axisMaxMin
                            .attr('transform', function(d,i) {
                                return 'translate(' + nv.utils.NaNtoZero(scale(d)) + ',0)'
                            })
                            .select('text')
                            .attr('dy', '-0.5em')
                            .attr('y', -axis.tickPadding())
                            .attr('text-anchor', 'middle')
                            .text(function(d,i) {
                                var v = fmt(d);
                                return ('' + v).match('NaN') ? '' : v;
                            });
                        axisMaxMin.watchTransition(renderWatch, 'min-max top')
                            .attr('transform', function(d,i) {
                                return 'translate(' + nv.utils.NaNtoZero(scale.range()[i]) + ',0)'
                            });
                    }
                    break;
                case 'bottom':
                    var xLabelMargin = axisLabelDistance + 36;
                    var maxTextWidth = 30;
                    var xTicks = g.selectAll('g').select("text");
                    if (rotateLabels%360) {
                        //Calculate the longest xTick width
                        xTicks.each(function(d,i){
                            var width = this.getBoundingClientRect().width;
                            if(width > maxTextWidth) maxTextWidth = width;
                        });
                        //Convert to radians before calculating sin. Add 30 to margin for healthy padding.
                        var sin = Math.abs(Math.sin(rotateLabels*Math.PI/180));
                        var xLabelMargin = (sin ? sin*maxTextWidth : maxTextWidth)+30;
                        //Rotate all xTicks
                        xTicks
                            .attr('transform', function(d,i,j) { return 'rotate(' + rotateLabels + ' 0,0)' })
                            .style('text-anchor', rotateLabels%360 > 0 ? 'start' : 'end');
                    }
                    axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                    var w;
                    if (scale.range().length < 2) {
                        w = 0;
                    } else if (scale.range().length === 2) {
                        w = scale.range()[1];
                    } else {
                        w = scale.range()[scale.range().length-1]+(scale.range()[1]-scale.range()[0]);
                    }
                    axisLabel
                        .attr('text-anchor', 'middle')
                        .attr('y', xLabelMargin)
                        .attr('x', w/2);
                    if (showMaxMin) {
                        //if (showMaxMin && !isOrdinal) {
                        var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                            //.data(scale.domain())
                            .data([scale.domain()[0], scale.domain()[scale.domain().length - 1]]);
                        axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text');
                        axisMaxMin.exit().remove();
                        axisMaxMin
                            .attr('transform', function(d,i) {
                                return 'translate(' + nv.utils.NaNtoZero((scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0))) + ',0)'
                            })
                            .select('text')
                            .attr('dy', '.71em')
                            .attr('y', axis.tickPadding())
                            .attr('transform', function(d,i,j) { return 'rotate(' + rotateLabels + ' 0,0)' })
                            .style('text-anchor', rotateLabels ? (rotateLabels%360 > 0 ? 'start' : 'end') : 'middle')
                            .text(function(d,i) {
                                var v = fmt(d);
                                return ('' + v).match('NaN') ? '' : v;
                            });
                        axisMaxMin.watchTransition(renderWatch, 'min-max bottom')
                            .attr('transform', function(d,i) {
                                return 'translate(' + nv.utils.NaNtoZero((scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0))) + ',0)'
                            });
                    }
                    if (staggerLabels)
                        xTicks
                            .attr('transform', function(d,i) {
                                return 'translate(0,' + (i % 2 == 0 ? '0' : '12') + ')'
                            });

                    break;
                case 'right':
                    axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                    axisLabel
                        .style('text-anchor', rotateYLabel ? 'middle' : 'begin')
                        .attr('transform', rotateYLabel ? 'rotate(90)' : '')
                        .attr('y', rotateYLabel ? (-Math.max(margin.right,width) + 12) : -10) //TODO: consider calculating this based on largest tick width... OR at least expose this on chart
                        .attr('x', rotateYLabel ? (scale.range()[0] / 2) : axis.tickPadding());
                    if (showMaxMin) {
                        var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                            .data(scale.domain());
                        axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text')
                            .style('opacity', 0);
                        axisMaxMin.exit().remove();
                        axisMaxMin
                            .attr('transform', function(d,i) {
                                return 'translate(0,' + nv.utils.NaNtoZero(scale(d)) + ')'
                            })
                            .select('text')
                            .attr('dy', '.32em')
                            .attr('y', 0)
                            .attr('x', axis.tickPadding())
                            .style('text-anchor', 'start')
                            .text(function(d,i) {
                                var v = fmt(d);
                                return ('' + v).match('NaN') ? '' : v;
                            });
                        axisMaxMin.watchTransition(renderWatch, 'min-max right')
                            .attr('transform', function(d,i) {
                                return 'translate(0,' + nv.utils.NaNtoZero(scale.range()[i]) + ')'
                            })
                            .select('text')
                            .style('opacity', 1);
                    }
                    break;
                case 'left':
                    /*
                     //For dynamically placing the label. Can be used with dynamically-sized chart axis margins
                     var yTicks = g.selectAll('g').select("text");
                     yTicks.each(function(d,i){
                     var labelPadding = this.getBoundingClientRect().width + axis.tickPadding() + 16;
                     if(labelPadding > width) width = labelPadding;
                     });
                     */
                    axisLabel.enter().append('text').attr('class', 'nv-axislabel');
                    axisLabel
                        .style('text-anchor', rotateYLabel ? 'middle' : 'end')
                        .attr('transform', rotateYLabel ? 'rotate(-90)' : '')
                        .attr('y', rotateYLabel ? (-Math.max(margin.left,width) + 25 - (axisLabelDistance || 0)) : -10)
                        .attr('x', rotateYLabel ? (-scale.range()[0] / 2) : -axis.tickPadding());
                    if (showMaxMin) {
                        var axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')
                            .data(scale.domain());
                        axisMaxMin.enter().append('g').attr('class', 'nv-axisMaxMin').append('text')
                            .style('opacity', 0);
                        axisMaxMin.exit().remove();
                        axisMaxMin
                            .attr('transform', function(d,i) {
                                return 'translate(0,' + nv.utils.NaNtoZero(scale0(d)) + ')'
                            })
                            .select('text')
                            .attr('dy', '.32em')
                            .attr('y', 0)
                            .attr('x', -axis.tickPadding())
                            .attr('text-anchor', 'end')
                            .text(function(d,i) {
                                var v = fmt(d);
                                return ('' + v).match('NaN') ? '' : v;
                            });
                        axisMaxMin.watchTransition(renderWatch, 'min-max right')
                            .attr('transform', function(d,i) {
                                return 'translate(0,' + nv.utils.NaNtoZero(scale.range()[i]) + ')'
                            })
                            .select('text')
                            .style('opacity', 1);
                    }
                    break;
            }
            axisLabel.text(function(d) { return d });

            if (showMaxMin && (axis.orient() === 'left' || axis.orient() === 'right')) {
                //check if max and min overlap other values, if so, hide the values that overlap
                g.selectAll('g') // the g's wrapping each tick
                    .each(function(d,i) {
                        d3.select(this).select('text').attr('opacity', 1);
                        if (scale(d) < scale.range()[1] + 10 || scale(d) > scale.range()[0] - 10) { // 10 is assuming text height is 16... if d is 0, leave it!
                            if (d > 1e-10 || d < -1e-10) // accounts for minor floating point errors... though could be problematic if the scale is EXTREMELY SMALL
                                d3.select(this).attr('opacity', 0);

                            d3.select(this).select('text').attr('opacity', 0); // Don't remove the ZERO line!!
                        }
                    });

                //if Max and Min = 0 only show min, Issue #281
                if (scale.domain()[0] == scale.domain()[1] && scale.domain()[0] == 0) {
                    wrap.selectAll('g.nv-axisMaxMin').style('opacity', function (d, i) {
                        return !i ? 1 : 0
                    });
                }
            }

            if (showMaxMin && (axis.orient() === 'top' || axis.orient() === 'bottom')) {
                var maxMinRange = [];
                wrap.selectAll('g.nv-axisMaxMin')
                    .each(function(d,i) {
                        try {
                            if (i) // i== 1, max position
                                maxMinRange.push(scale(d) - this.getBoundingClientRect().width - 4)  //assuming the max and min labels are as wide as the next tick (with an extra 4 pixels just in case)
                            else // i==0, min position
                                maxMinRange.push(scale(d) + this.getBoundingClientRect().width + 4)
                        }catch (err) {
                            if (i) // i== 1, max position
                                maxMinRange.push(scale(d) - 4);  //assuming the max and min labels are as wide as the next tick (with an extra 4 pixels just in case)
                            else // i==0, min position
                                maxMinRange.push(scale(d) + 4);
                        }
                    });
                // the g's wrapping each tick
                g.selectAll('g').each(function(d,i) {
                    if (scale(d) < maxMinRange[0] || scale(d) > maxMinRange[1]) {
                        if (d > 1e-10 || d < -1e-10) // accounts for minor floating point errors... though could be problematic if the scale is EXTREMELY SMALL
                            d3.select(this).remove();
                        else
                            d3.select(this).select('text').remove(); // Don't remove the ZERO line!!
                    }
                });
            }

            //highlight zero line ... Maybe should not be an option and should just be in CSS?
            if (highlightZero) {
                g.selectAll('.tick')
                    .filter(function (d) {
                        return !parseFloat(Math.round(this.__data__ * 100000) / 1000000) && (this.__data__ !== undefined)
                    }) //this is because sometimes the 0 tick is a very small fraction, TODO: think of cleaner technique
                    .classed('zero', true);
            }
            //store old scales for use in transitions on update
            scale0 = scale.copy();

        });

        renderWatch.renderEnd('axis immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.axis = axis;
    chart.dispatch = dispatch;

    chart.options = nv.utils.optionsFunc.bind(chart);
    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        axisLabelDistance: {get: function(){return axisLabelDistance;}, set: function(_){axisLabelDistance=_;}},
        staggerLabels:     {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},
        rotateLabels:      {get: function(){return rotateLabels;}, set: function(_){rotateLabels=_;}},
        rotateYLabel:      {get: function(){return rotateYLabel;}, set: function(_){rotateYLabel=_;}},
        highlightZero:     {get: function(){return highlightZero;}, set: function(_){highlightZero=_;}},
        showMaxMin:        {get: function(){return showMaxMin;}, set: function(_){showMaxMin=_;}},
        axisLabel:         {get: function(){return axisLabelText;}, set: function(_){axisLabelText=_;}},
        height:            {get: function(){return height;}, set: function(_){height=_;}},
        ticks:             {get: function(){return ticks;}, set: function(_){ticks=_;}},
        width:             {get: function(){return width;}, set: function(_){width=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top !== undefined    ? _.top    : margin.top;
            margin.right  = _.right !== undefined  ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left !== undefined   ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration=_;
            renderWatch.reset(duration);
        }},
        scale: {get: function(){return scale;}, set: function(_){
            scale = _;
            axis.scale(scale);
            isOrdinal = typeof scale.rangeBands === 'function';
            nv.utils.inheritOptionsD3(chart, scale, ['domain', 'range', 'rangeBand', 'rangeBands']);
        }}
    });

    nv.utils.initOptions(chart);
    nv.utils.inheritOptionsD3(chart, axis, ['orient', 'tickValues', 'tickSubdivide', 'tickSize', 'tickPadding', 'tickFormat']);
    nv.utils.inheritOptionsD3(chart, scale, ['domain', 'range', 'rangeBand', 'rangeBands']);

    return chart;
};

// Chart design based on the recommendations of Stephen Few. Implementation
// based on the work of Clint Ivy, Jamie Love, and Jason Davies.
// http://projects.instantcognition.com/protovis/bulletchart/

nv.models.bullet = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , orient = 'left' // TODO top & bottom
        , reverse = false
        , ranges = function(d) { return d.ranges }
        , markers = function(d) { return d.markers ? d.markers : [0] }
        , measures = function(d) { return d.measures }
        , rangeLabels = function(d) { return d.rangeLabels ? d.rangeLabels : [] }
        , markerLabels = function(d) { return d.markerLabels ? d.markerLabels : []  }
        , measureLabels = function(d) { return d.measureLabels ? d.measureLabels : []  }
        , forceX = [0] // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)
        , width = 380
        , height = 30
        , tickFormat = null
        , color = nv.utils.getColor(['#1f77b4'])
        , dispatch = d3.dispatch('elementMouseover', 'elementMouseout')
        ;

    function chart(selection) {
        selection.each(function(d, i) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            var rangez = ranges.call(this, d, i).slice().sort(d3.descending),
                markerz = markers.call(this, d, i).slice().sort(d3.descending),
                measurez = measures.call(this, d, i).slice().sort(d3.descending),
                rangeLabelz = rangeLabels.call(this, d, i).slice(),
                markerLabelz = markerLabels.call(this, d, i).slice(),
                measureLabelz = measureLabels.call(this, d, i).slice();

            // Setup Scales
            // Compute the new x-scale.
            var x1 = d3.scale.linear()
                .domain( d3.extent(d3.merge([forceX, rangez])) )
                .range(reverse ? [availableWidth, 0] : [0, availableWidth]);

            // Retrieve the old x-scale, if this is an update.
            var x0 = this.__chart__ || d3.scale.linear()
                .domain([0, Infinity])
                .range(x1.range());

            // Stash the new scale.
            this.__chart__ = x1;

            var rangeMin = d3.min(rangez), //rangez[2]
                rangeMax = d3.max(rangez), //rangez[0]
                rangeAvg = rangez[1];

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-bullet').data([d]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bullet');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('rect').attr('class', 'nv-range nv-rangeMax');
            gEnter.append('rect').attr('class', 'nv-range nv-rangeAvg');
            gEnter.append('rect').attr('class', 'nv-range nv-rangeMin');
            gEnter.append('rect').attr('class', 'nv-measure');
            gEnter.append('path').attr('class', 'nv-markerTriangle');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            var w0 = function(d) { return Math.abs(x0(d) - x0(0)) }, // TODO: could optimize by precalculating x0(0) and x1(0)
                w1 = function(d) { return Math.abs(x1(d) - x1(0)) };
            var xp0 = function(d) { return d < 0 ? x0(d) : x0(0) },
                xp1 = function(d) { return d < 0 ? x1(d) : x1(0) };

            g.select('rect.nv-rangeMax')
                .attr('height', availableHeight)
                .attr('width', w1(rangeMax > 0 ? rangeMax : rangeMin))
                .attr('x', xp1(rangeMax > 0 ? rangeMax : rangeMin))
                .datum(rangeMax > 0 ? rangeMax : rangeMin)

            g.select('rect.nv-rangeAvg')
                .attr('height', availableHeight)
                .attr('width', w1(rangeAvg))
                .attr('x', xp1(rangeAvg))
                .datum(rangeAvg)

            g.select('rect.nv-rangeMin')
                .attr('height', availableHeight)
                .attr('width', w1(rangeMax))
                .attr('x', xp1(rangeMax))
                .attr('width', w1(rangeMax > 0 ? rangeMin : rangeMax))
                .attr('x', xp1(rangeMax > 0 ? rangeMin : rangeMax))
                .datum(rangeMax > 0 ? rangeMin : rangeMax)

            g.select('rect.nv-measure')
                .style('fill', color)
                .attr('height', availableHeight / 3)
                .attr('y', availableHeight / 3)
                .attr('width', measurez < 0 ?
                    x1(0) - x1(measurez[0])
                    : x1(measurez[0]) - x1(0))
                .attr('x', xp1(measurez))
                .on('mouseover', function() {
                    dispatch.elementMouseover({
                        value: measurez[0],
                        label: measureLabelz[0] || 'Current',
                        pos: [x1(measurez[0]), availableHeight/2]
                    })
                })
                .on('mouseout', function() {
                    dispatch.elementMouseout({
                        value: measurez[0],
                        label: measureLabelz[0] || 'Current'
                    })
                });

            var h3 =  availableHeight / 6;
            if (markerz[0]) {
                g.selectAll('path.nv-markerTriangle')
                    .attr('transform', function(d) { return 'translate(' + x1(markerz[0]) + ',' + (availableHeight / 2) + ')' })
                    .attr('d', 'M0,' + h3 + 'L' + h3 + ',' + (-h3) + ' ' + (-h3) + ',' + (-h3) + 'Z')
                    .on('mouseover', function() {
                        dispatch.elementMouseover({
                            value: markerz[0],
                            label: markerLabelz[0] || 'Previous',
                            pos: [x1(markerz[0]), availableHeight/2]
                        })
                    })
                    .on('mouseout', function() {
                        dispatch.elementMouseout({
                            value: markerz[0],
                            label: markerLabelz[0] || 'Previous'
                        })
                    });
            } else {
                g.selectAll('path.nv-markerTriangle').remove();
            }

            wrap.selectAll('.nv-range')
                .on('mouseover', function(d,i) {
                    var label = rangeLabelz[i] || (!i ? "Maximum" : i == 1 ? "Mean" : "Minimum");

                    dispatch.elementMouseover({
                        value: d,
                        label: label,
                        pos: [x1(d), availableHeight/2]
                    })
                })
                .on('mouseout', function(d,i) {
                    var label = rangeLabelz[i] || (!i ? "Maximum" : i == 1 ? "Mean" : "Minimum");

                    dispatch.elementMouseout({
                        value: d,
                        label: label
                    })
                });
        });

        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        ranges:      {get: function(){return ranges;}, set: function(_){ranges=_;}}, // ranges (bad, satisfactory, good)
        markers:     {get: function(){return markers;}, set: function(_){markers=_;}}, // markers (previous, goal)
        measures: {get: function(){return measures;}, set: function(_){measures=_;}}, // measures (actual, forecast)
        forceX:      {get: function(){return forceX;}, set: function(_){forceX=_;}},
        width:    {get: function(){return width;}, set: function(_){width=_;}},
        height:    {get: function(){return height;}, set: function(_){height=_;}},
        tickFormat:    {get: function(){return tickFormat;}, set: function(_){tickFormat=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        orient: {get: function(){return orient;}, set: function(_){ // left, right, top, bottom
            orient = _;
            reverse = orient == 'right' || orient == 'bottom';
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};



// Chart design based on the recommendations of Stephen Few. Implementation
// based on the work of Clint Ivy, Jamie Love, and Jason Davies.
// http://projects.instantcognition.com/protovis/bulletchart/
nv.models.bulletChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var bullet = nv.models.bullet()
        ;

    var orient = 'left' // TODO top & bottom
        , reverse = false
        , margin = {top: 5, right: 40, bottom: 20, left: 120}
        , ranges = function(d) { return d.ranges }
        , markers = function(d) { return d.markers ? d.markers : [0] }
        , measures = function(d) { return d.measures }
        , width = null
        , height = 55
        , tickFormat = null
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + x + '</h3>' +
                '<p>' + y + '</p>'
        }
        , noData = 'No Data Available.'
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ) + margin.left,
            top = e.pos[1] + ( offsetElement.offsetTop || 0) + margin.top,
            content = tooltip(e.key, e.label, e.value, e, chart);

        nv.tooltip.show([left, top], content, e.value < 0 ? 'e' : 'w', null, offsetElement);
    };

    function chart(selection) {
        selection.each(function(d, i) {
            var container = d3.select(this);
            nv.utils.initSVG(container);

            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                that = this;

            chart.update = function() { chart(selection) };
            chart.container = this;

            // Display No Data message if there's nothing to show.
            if (!d || !ranges.call(this, d, i)) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', 18 + margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            var rangez = ranges.call(this, d, i).slice().sort(d3.descending),
                markerz = markers.call(this, d, i).slice().sort(d3.descending),
                measurez = measures.call(this, d, i).slice().sort(d3.descending);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-bulletChart').data([d]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bulletChart');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-bulletWrap');
            gEnter.append('g').attr('class', 'nv-titles');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Compute the new x-scale.
            var x1 = d3.scale.linear()
                .domain([0, Math.max(rangez[0], markerz[0], measurez[0])])  // TODO: need to allow forceX and forceY, and xDomain, yDomain
                .range(reverse ? [availableWidth, 0] : [0, availableWidth]);

            // Retrieve the old x-scale, if this is an update.
            var x0 = this.__chart__ || d3.scale.linear()
                .domain([0, Infinity])
                .range(x1.range());

            // Stash the new scale.
            this.__chart__ = x1;

            var w0 = function(d) { return Math.abs(x0(d) - x0(0)) }, // TODO: could optimize by precalculating x0(0) and x1(0)
                w1 = function(d) { return Math.abs(x1(d) - x1(0)) };

            var title = gEnter.select('.nv-titles').append('g')
                .attr('text-anchor', 'end')
                .attr('transform', 'translate(-6,' + (height - margin.top - margin.bottom) / 2 + ')');
            title.append('text')
                .attr('class', 'nv-title')
                .text(function(d) { return d.title; });

            title.append('text')
                .attr('class', 'nv-subtitle')
                .attr('dy', '1em')
                .text(function(d) { return d.subtitle; });

            bullet
                .width(availableWidth)
                .height(availableHeight)

            var bulletWrap = g.select('.nv-bulletWrap');
            d3.transition(bulletWrap).call(bullet);

            // Compute the tick format.
            var format = tickFormat || x1.tickFormat( availableWidth / 100 );

            // Update the tick groups.
            var tick = g.selectAll('g.nv-tick')
                .data(x1.ticks( availableWidth / 50 ), function(d) {
                    return this.textContent || format(d);
                });

            // Initialize the ticks with the old scale, x0.
            var tickEnter = tick.enter().append('g')
                .attr('class', 'nv-tick')
                .attr('transform', function(d) { return 'translate(' + x0(d) + ',0)' })
                .style('opacity', 1e-6);

            tickEnter.append('line')
                .attr('y1', availableHeight)
                .attr('y2', availableHeight * 7 / 6);

            tickEnter.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '1em')
                .attr('y', availableHeight * 7 / 6)
                .text(format);

            // Transition the updating ticks to the new scale, x1.
            var tickUpdate = d3.transition(tick)
                .attr('transform', function(d) { return 'translate(' + x1(d) + ',0)' })
                .style('opacity', 1);

            tickUpdate.select('line')
                .attr('y1', availableHeight)
                .attr('y2', availableHeight * 7 / 6);

            tickUpdate.select('text')
                .attr('y', availableHeight * 7 / 6);

            // Transition the exiting ticks to the new scale, x1.
            d3.transition(tick.exit())
                .attr('transform', function(d) { return 'translate(' + x1(d) + ',0)' })
                .style('opacity', 1e-6)
                .remove();

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            dispatch.on('tooltipShow', function(e) {
                e.key = d.title;
                if (tooltips) showTooltip(e, that.parentNode);
            });

        });

        d3.timer.flush();
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    bullet.dispatch.on('elementMouseover.tooltip', function(e) {
        dispatch.tooltipShow(e);
    });

    bullet.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.bullet = bullet;
    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        ranges:      {get: function(){return ranges;}, set: function(_){ranges=_;}}, // ranges (bad, satisfactory, good)
        markers:     {get: function(){return markers;}, set: function(_){markers=_;}}, // markers (previous, goal)
        measures: {get: function(){return measures;}, set: function(_){measures=_;}}, // measures (actual, forecast)
        width:    {get: function(){return width;}, set: function(_){width=_;}},
        height:    {get: function(){return height;}, set: function(_){height=_;}},
        tickFormat:    {get: function(){return tickFormat;}, set: function(_){tickFormat=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        orient: {get: function(){return orient;}, set: function(_){ // left, right, top, bottom
            orient = _;
            reverse = orient == 'right' || orient == 'bottom';
        }}
    });

    nv.utils.inheritOptions(chart, bullet);
    nv.utils.initOptions(chart);

    return chart;
};



nv.models.cumulativeLineChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var lines = nv.models.line()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , legend = nv.models.legend()
        , controls = nv.models.legend()
        , interactiveLayer = nv.interactiveGuideline()
        ;

    var margin = {top: 30, right: 30, bottom: 50, left: 60}
        , color = nv.utils.defaultColor()
        , width = null
        , height = null
        , showLegend = true
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , tooltips = true
        , showControls = true
        , useInteractiveGuideline = false
        , rescaleY = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' at ' + x + '</p>'
        }
        , x //can be accessed via chart.xScale()
        , y //can be accessed via chart.yScale()
        , id = lines.id()
        , state = nv.utils.state()
        , defaultState = null
        , noData = 'No Data Available.'
        , average = function(d) { return d.average }
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd')
        , transitionDuration = 250
        , duration = 250
        , noErrorCheck = false  //if set to TRUE, will bypass an error check in the indexify function.
        ;

    state.index = 0;
    state.rescaleY = rescaleY;

    xAxis
        .orient('bottom')
        .tickPadding(7)
    ;
    yAxis
        .orient((rightAlignYAxis) ? 'right' : 'left')
    ;

    controls.updateState(false);

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var dx = d3.scale.linear()
        , index = {i: 0, x: 0}
        , renderWatch = nv.utils.renderWatch(dispatch, duration)
        ;

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, null, null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled }),
                index: index.i,
                rescaleY: rescaleY
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.index !== undefined)
                index.i = state.index;
            if (state.rescaleY !== undefined)
                rescaleY = state.rescaleY;
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(lines);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);
        selection.each(function(data) {
            var container = d3.select(this);
            nv.utils.initSVG(container);
            container.classed('nv-chart-' + id, true);
            var that = this;

            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() {
                if (duration === 0)
                    container.call(chart);
                else
                    container.transition().duration(duration).call(chart)
            };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            var indexDrag = d3.behavior.drag()
                .on('dragstart', dragStart)
                .on('drag', dragMove)
                .on('dragend', dragEnd);


            function dragStart(d,i) {
                d3.select(chart.container)
                    .style('cursor', 'ew-resize');
            }

            function dragMove(d,i) {
                index.x = d3.event.x;
                index.i = Math.round(dx.invert(index.x));
                updateZero();
            }

            function dragEnd(d,i) {
                d3.select(chart.container)
                    .style('cursor', 'auto');

                // update state and send stateChange with new index
                state.index = index.i;
                dispatch.stateChange(state);
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = lines.xScale();
            y = lines.yScale();

            if (!rescaleY) {
                var seriesDomains = data
                    .filter(function(series) { return !series.disabled })
                    .map(function(series,i) {
                        var initialDomain = d3.extent(series.values, lines.y());

                        //account for series being disabled when losing 95% or more
                        if (initialDomain[0] < -.95) initialDomain[0] = -.95;

                        return [
                                (initialDomain[0] - initialDomain[1]) / (1 + initialDomain[1]),
                                (initialDomain[1] - initialDomain[0]) / (1 + initialDomain[0])
                        ];
                    });

                var completeDomain = [
                    d3.min(seriesDomains, function(d) { return d[0] }),
                    d3.max(seriesDomains, function(d) { return d[1] })
                ];

                lines.yDomain(completeDomain);
            } else {
                lines.yDomain(null);
            }

            dx.domain([0, data[0].values.length - 1]) //Assumes all series have same length
                .range([0, availableWidth])
                .clamp(true);

            var data = indexify(index.i, data);

            // Setup containers and skeleton of chart
            var interactivePointerEvents = (useInteractiveGuideline) ? "none" : "all";
            var wrap = container.selectAll('g.nv-wrap.nv-cumulativeLine').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-cumulativeLine').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-interactive');
            gEnter.append('g').attr('class', 'nv-x nv-axis').style("pointer-events","none");
            gEnter.append('g').attr('class', 'nv-y nv-axis');
            gEnter.append('g').attr('class', 'nv-background');
            gEnter.append('g').attr('class', 'nv-linesWrap').style("pointer-events",interactivePointerEvents);
            gEnter.append('g').attr('class', 'nv-avgLinesWrap').style("pointer-events","none");
            gEnter.append('g').attr('class', 'nv-legendWrap');
            gEnter.append('g').attr('class', 'nv-controlsWrap');

            // Legend
            if (showLegend) {
                legend.width(availableWidth);

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
            }

            // Controls
            if (showControls) {
                var controlsData = [
                    { key: 'Re-scale y-axis', disabled: !rescaleY }
                ];

                controls
                    .width(140)
                    .color(['#444', '#444', '#444'])
                    .rightAlign(false)
                    .margin({top: 5, right: 0, bottom: 5, left: 20})
                ;

                g.select('.nv-controlsWrap')
                    .datum(controlsData)
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
                    .call(controls);
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            // Show error if series goes below 100%
            var tempDisabled = data.filter(function(d) { return d.tempDisabled });

            wrap.select('.tempDisabled').remove(); //clean-up and prevent duplicates
            if (tempDisabled.length) {
                wrap.append('text').attr('class', 'tempDisabled')
                    .attr('x', availableWidth / 2)
                    .attr('y', '-.71em')
                    .style('text-anchor', 'end')
                    .text(tempDisabled.map(function(d) { return d.key }).join(', ') + ' values cannot be calculated for this time period.');
            }

            //Set up interactive layer
            if (useInteractiveGuideline) {
                interactiveLayer
                    .width(availableWidth)
                    .height(availableHeight)
                    .margin({left:margin.left,top:margin.top})
                    .svgContainer(container)
                    .xScale(x);
                wrap.select(".nv-interactive").call(interactiveLayer);
            }

            gEnter.select('.nv-background')
                .append('rect');

            g.select('.nv-background rect')
                .attr('width', availableWidth)
                .attr('height', availableHeight);

            lines
                //.x(function(d) { return d.x })
                .y(function(d) { return d.display.y })
                .width(availableWidth)
                .height(availableHeight)
                .color(data.map(function(d,i) {
                    return d.color || color(d, i);
                }).filter(function(d,i) { return !data[i].disabled && !data[i].tempDisabled; }));

            var linesWrap = g.select('.nv-linesWrap')
                .datum(data.filter(function(d) { return  !d.disabled && !d.tempDisabled }));

            linesWrap.call(lines);

            //Store a series index number in the data array.
            data.forEach(function(d,i) {
                d.seriesIndex = i;
            });

            var avgLineData = data.filter(function(d) {
                return !d.disabled && !!average(d);
            });

            var avgLines = g.select(".nv-avgLinesWrap").selectAll("line")
                .data(avgLineData, function(d) { return d.key; });

            var getAvgLineY = function(d) {
                //If average lines go off the svg element, clamp them to the svg bounds.
                var yVal = y(average(d));
                if (yVal < 0) return 0;
                if (yVal > availableHeight) return availableHeight;
                return yVal;
            };

            avgLines.enter()
                .append('line')
                .style('stroke-width',2)
                .style('stroke-dasharray','10,10')
                .style('stroke',function (d,i) {
                    return lines.color()(d,d.seriesIndex);
                })
                .attr('x1',0)
                .attr('x2',availableWidth)
                .attr('y1', getAvgLineY)
                .attr('y2', getAvgLineY);

            avgLines
                .style('stroke-opacity',function(d){
                    //If average lines go offscreen, make them transparent
                    var yVal = y(average(d));
                    if (yVal < 0 || yVal > availableHeight) return 0;
                    return 1;
                })
                .attr('x1',0)
                .attr('x2',availableWidth)
                .attr('y1', getAvgLineY)
                .attr('y2', getAvgLineY);

            avgLines.exit().remove();

            //Create index line
            var indexLine = linesWrap.selectAll('.nv-indexLine')
                .data([index]);
            indexLine.enter().append('rect').attr('class', 'nv-indexLine')
                .attr('width', 3)
                .attr('x', -2)
                .attr('fill', 'red')
                .attr('fill-opacity', .5)
                .style("pointer-events","all")
                .call(indexDrag);

            indexLine
                .attr('transform', function(d) { return 'translate(' + dx(d.i) + ',0)' })
                .attr('height', availableHeight);

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/70, data) )
                    .tickSize(-availableHeight, 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y.range()[0] + ')');
                g.select('.nv-x.nv-axis')
                    .call(xAxis);
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis')
                    .call(yAxis);
            }

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            function updateZero() {
                indexLine
                    .data([index]);

                //When dragging the index line, turn off line transitions.
                // Then turn them back on when done dragging.
                var oldDuration = chart.duration();
                chart.duration(0);
                chart.update();
                chart.duration(oldDuration);
            }

            g.select('.nv-background rect')
                .on('click', function() {
                    index.x = d3.mouse(this)[0];
                    index.i = Math.round(dx.invert(index.x));

                    // update state and send stateChange with new index
                    state.index = index.i;
                    dispatch.stateChange(state);

                    updateZero();
                });

            lines.dispatch.on('elementClick', function(e) {
                index.i = e.pointIndex;
                index.x = dx(index.i);

                // update state and send stateChange with new index
                state.index = index.i;
                dispatch.stateChange(state);

                updateZero();
            });

            controls.dispatch.on('legendClick', function(d,i) {
                d.disabled = !d.disabled;
                rescaleY = !d.disabled;

                state.rescaleY = rescaleY;
                dispatch.stateChange(state);
                chart.update();
            });

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            interactiveLayer.dispatch.on('elementMousemove', function(e) {
                lines.clearHighlights();
                var singlePoint, pointIndex, pointXLocation, allData = [];

                data
                    .filter(function(series, i) {
                        series.seriesIndex = i;
                        return !series.disabled;
                    })
                    .forEach(function(series,i) {
                        pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                        lines.highlightPoint(i, pointIndex, true);
                        var point = series.values[pointIndex];
                        if (typeof point === 'undefined') return;
                        if (typeof singlePoint === 'undefined') singlePoint = point;
                        if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                        allData.push({
                            key: series.key,
                            value: chart.y()(point, pointIndex),
                            color: color(series,series.seriesIndex)
                        });
                    });

                //Highlight the tooltip entry based on which point the mouse is closest to.
                if (allData.length > 2) {
                    var yValue = chart.yScale().invert(e.mouseY);
                    var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
                    var threshold = 0.03 * domainExtent;
                    var indexToHighlight = nv.nearestValueIndex(allData.map(function(d){return d.value}),yValue,threshold);
                    if (indexToHighlight !== null)
                        allData[indexToHighlight].highlight = true;
                }

                var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex), pointIndex);
                interactiveLayer.tooltip
                    .position({left: pointXLocation + margin.left, top: e.mouseY + margin.top})
                    .chartContainer(that.parentNode)
                    .enabled(tooltips)
                    .valueFormatter(function(d,i) {
                        return yAxis.tickFormat()(d);
                    })
                    .data(
                    {
                        value: xValue,
                        series: allData
                    }
                )();

                interactiveLayer.renderGuideLine(pointXLocation);
            });

            interactiveLayer.dispatch.on("elementMouseout",function(e) {
                dispatch.tooltipHide();
                lines.clearHighlights();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                if (typeof e.index !== 'undefined') {
                    index.i = e.index;
                    index.x = dx(index.i);

                    state.index = e.index;

                    indexLine
                        .data([index]);
                }

                if (typeof e.rescaleY !== 'undefined') {
                    rescaleY = e.rescaleY;
                }

                chart.update();
            });

        });

        renderWatch.renderEnd('cumulativeLineChart immediate');

        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    lines.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Functions
    //------------------------------------------------------------

    var indexifyYGetter = null;
    /* Normalize the data according to an index point. */
    function indexify(idx, data) {
        if (!indexifyYGetter) indexifyYGetter = lines.y();
        return data.map(function(line, i) {
            if (!line.values) {
                return line;
            }
            var indexValue = line.values[idx];
            if (indexValue == null) {
                return line;
            }
            var v = indexifyYGetter(indexValue, idx);

            //TODO: implement check below, and disable series if series loses 100% or more cause divide by 0 issue
            if (v < -.95 && !noErrorCheck) {
                //if a series loses more than 100%, calculations fail.. anything close can cause major distortion (but is mathematically correct till it hits 100)

                line.tempDisabled = true;
                return line;
            }

            line.tempDisabled = false;

            line.values = line.values.map(function(point, pointIndex) {
                point.display = {'y': (indexifyYGetter(point, pointIndex) - v) / (1 + v) };
                return point;
            });

            return line;
        })
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.lines = lines;
    chart.legend = legend;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.interactiveLayer = interactiveLayer;
    chart.state = state;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        rescaleY:     {get: function(){return rescaleY;}, set: function(_){rescaleY=_;}},
        showControls:     {get: function(){return showControls;}, set: function(_){showControls=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        average: {get: function(){return average;}, set: function(_){average=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
        showXAxis:    {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        noErrorCheck:    {get: function(){return noErrorCheck;}, set: function(_){noErrorCheck=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
        }},
        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
            useInteractiveGuideline = _;
            if (_ === true) {
                chart.interactive(false);
                chart.useVoronoi(false);
            }
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( (_) ? 'right' : 'left');
        }},
        duration:    {get: function(){return duration;}, set: function(_){
            duration = _;
            lines.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
            renderWatch.reset(duration);
        }}
    });

    nv.utils.inheritOptions(chart, lines);
    nv.utils.initOptions(chart);

    return chart;
};//TODO: consider deprecating by adding necessary features to multiBar model
nv.models.discreteBar = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 960
        , height = 500
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , x = d3.scale.ordinal()
        , y = d3.scale.linear()
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove
        , color = nv.utils.defaultColor()
        , showValues = false
        , valueFormat = d3.format(',.2f')
        , xDomain
        , yDomain
        , xRange
        , yRange
        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout','renderEnd')
        , rectClass = 'discreteBar'
        , duration = 250
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0;
    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            //add series index to each data point for reference
            data.forEach(function(series, i) {
                series.values.forEach(function(point) {
                    point.series = i;
                });
            });

            // Setup Scales
            // remap and flatten the data for use in calculating the scales' domains
            var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate
                data.map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: getX(d,i), y: getY(d,i), y0: d.y0 }
                    })
                });

            x   .domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))
                .rangeBands(xRange || [0, availableWidth], .1);
            y   .domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return d.y }).concat(forceY)));

            // If showValues, pad the Y axis range to account for label height
            if (showValues) y.range(yRange || [availableHeight - (y.domain()[0] < 0 ? 12 : 0), y.domain()[1] > 0 ? 12 : 0]);
            else y.range(yRange || [availableHeight, 0]);

            //store old scales if they exist
            x0 = x0 || x;
            y0 = y0 || y.copy().range([y(0),y(0)]);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-discretebar').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discretebar');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-groups');
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            //TODO: by definition, the discrete bar should not have multiple groups, will modify/remove later
            var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                .data(function(d) { return d }, function(d) { return d.key });
            groups.enter().append('g')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6);
            groups.exit()
                .watchTransition(renderWatch, 'discreteBar: exit groups')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6)
                .remove();
            groups
                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                .classed('hover', function(d) { return d.hover });
            groups
                .watchTransition(renderWatch, 'discreteBar: groups')
                .style('stroke-opacity', 1)
                .style('fill-opacity', .75);

            var bars = groups.selectAll('g.nv-bar')
                .data(function(d) { return d.values });
            bars.exit().remove();

            var barsEnter = bars.enter().append('g')
                .attr('transform', function(d,i,j) {
                    return 'translate(' + (x(getX(d,i)) + x.rangeBand() * .05 ) + ', ' + y(0) + ')'
                })
                .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here
                    d3.select(this).classed('hover', true);
                    dispatch.elementMouseover({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (d.series + .5) / data.length), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                })
                .on('mouseout', function(d,i) {
                    d3.select(this).classed('hover', false);
                    dispatch.elementMouseout({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                })
                .on('click', function(d,i) {
                    dispatch.elementClick({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (d.series + .5) / data.length), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                })
                .on('dblclick', function(d,i) {
                    dispatch.elementDblClick({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (d.series + .5) / data.length), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                });

            barsEnter.append('rect')
                .attr('height', 0)
                .attr('width', x.rangeBand() * .9 / data.length )

            if (showValues) {
                barsEnter.append('text')
                    .attr('text-anchor', 'middle')
                ;

                bars.select('text')
                    .text(function(d,i) { return valueFormat(getY(d,i)) })
                    .watchTransition(renderWatch, 'discreteBar: bars text')
                    .attr('x', x.rangeBand() * .9 / 2)
                    .attr('y', function(d,i) { return getY(d,i) < 0 ? y(getY(d,i)) - y(0) + 12 : -4 })

                ;
            } else {
                bars.selectAll('text').remove();
            }

            bars
                .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive' })
                .style('fill', function(d,i) { return d.color || color(d,i) })
                .style('stroke', function(d,i) { return d.color || color(d,i) })
                .select('rect')
                .attr('class', rectClass)
                .watchTransition(renderWatch, 'discreteBar: bars rect')
                .attr('width', x.rangeBand() * .9 / data.length);
            bars.watchTransition(renderWatch, 'discreteBar: bars')
                //.delay(function(d,i) { return i * 1200 / data[0].values.length })
                .attr('transform', function(d,i) {
                    var left = x(getX(d,i)) + x.rangeBand() * .05,
                        top = getY(d,i) < 0 ?
                            y(0) :
                                y(0) - y(getY(d,i)) < 1 ?
                            y(0) - 1 : //make 1 px positive bars show up above y=0
                            y(getY(d,i));

                    return 'translate(' + left + ', ' + top + ')'
                })
                .select('rect')
                .attr('height', function(d,i) {
                    return  Math.max(Math.abs(y(getY(d,i)) - y((yDomain && yDomain[0]) || 0)) || 1)
                });


            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();

        });

        renderWatch.renderEnd('discreteBar immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:   {get: function(){return width;}, set: function(_){width=_;}},
        height:  {get: function(){return height;}, set: function(_){height=_;}},
        forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},
        showValues: {get: function(){return showValues;}, set: function(_){showValues=_;}},
        x:       {get: function(){return getX;}, set: function(_){getX=_;}},
        y:       {get: function(){return getY;}, set: function(_){getY=_;}},
        xScale:  {get: function(){return x;}, set: function(_){x=_;}},
        yScale:  {get: function(){return y;}, set: function(_){y=_;}},
        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
        valueFormat:    {get: function(){return valueFormat;}, set: function(_){valueFormat=_;}},
        id:          {get: function(){return id;}, set: function(_){id=_;}},
        rectClass: {get: function(){return rectClass;}, set: function(_){rectClass=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};

nv.models.discreteBarChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var discretebar = nv.models.discreteBar()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        ;

    var margin = {top: 15, right: 10, bottom: 50, left: 60}
        , width = null
        , height = null
        , color = nv.utils.getColor()
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , staggerLabels = false
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + x + '</h3>' +
                '<p>' +  y + '</p>'
        }
        , x
        , y
        , noData = "No Data Available."
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'beforeUpdate','renderEnd')
        , duration = 250
        ;

    xAxis
        .orient('bottom')
        .highlightZero(false)
        .showMaxMin(false)
        .tickFormat(function(d) { return d })
    ;
    yAxis
        .orient((rightAlignYAxis) ? 'right' : 'left')
        .tickFormat(d3.format(',.1f'))
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(discretebar.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(discretebar.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(discretebar);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() {
                dispatch.beforeUpdate();
                container.transition().duration(duration).call(chart);
            };
            chart.container = this;

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = discretebar.xScale();
            y = discretebar.yScale().clamp(true);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-discreteBarWithAxes').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discreteBarWithAxes').append('g');
            var defsEnter = gEnter.append('defs');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis')
                .append('g').attr('class', 'nv-zeroLine')
                .append('line');

            gEnter.append('g').attr('class', 'nv-barsWrap');

            g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            // Main Chart Component(s)
            discretebar
                .width(availableWidth)
                .height(availableHeight);

            var barsWrap = g.select('.nv-barsWrap')
                .datum(data.filter(function(d) { return !d.disabled }))

            barsWrap.transition().call(discretebar);


            defsEnter.append('clipPath')
                .attr('id', 'nv-x-label-clip-' + discretebar.id())
                .append('rect');

            g.select('#nv-x-label-clip-' + discretebar.id() + ' rect')
                .attr('width', x.rangeBand() * (staggerLabels ? 2 : 1))
                .attr('height', 16)
                .attr('x', -x.rangeBand() / (staggerLabels ? 1 : 2 ));

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize(-availableHeight, 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + (y.range()[0] + ((discretebar.showValues() && y.domain()[0] < 0) ? 16 : 0)) + ')');
                g.select('.nv-x.nv-axis').call(xAxis);

                var xTicks = g.select('.nv-x.nv-axis').selectAll('g');
                if (staggerLabels) {
                    xTicks
                        .selectAll('text')
                        .attr('transform', function(d,i,j) { return 'translate(0,' + (j % 2 == 0 ? '5' : '17') + ')' })
                }
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis').call(yAxis);
            }

            // Zero line
            g.select(".nv-zeroLine line")
                .attr("x1",0)
                .attr("x2",availableWidth)
                .attr("y1", y(0))
                .attr("y2", y(0))
            ;

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

        });

        renderWatch.renderEnd('discreteBar chart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    discretebar.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    discretebar.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.discretebar = discretebar;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        staggerLabels: {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},
        showXAxis: {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis: {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            discretebar.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            discretebar.color(color);
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( (_) ? 'right' : 'left');
        }}
    });

    nv.utils.inheritOptions(chart, discretebar);
    nv.utils.initOptions(chart);

    return chart;
}

nv.models.distribution = function() {
    "use strict";
    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 400 //technically width or height depending on x or y....
        , size = 8
        , axis = 'x' // 'x' or 'y'... horizontal or vertical
        , getData = function(d) { return d[axis] }  // defaults d.x or d.y
        , color = nv.utils.defaultColor()
        , scale = d3.scale.linear()
        , domain
        , duration = 250
        , dispatch = d3.dispatch('renderEnd')
        ;

    //============================================================


    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var scale0;
    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    //============================================================


    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var availableLength = width - (axis === 'x' ? margin.left + margin.right : margin.top + margin.bottom),
                naxis = axis == 'x' ? 'y' : 'x',
                container = d3.select(this);
            nv.utils.initSVG(container);

            //------------------------------------------------------------
            // Setup Scales

            scale0 = scale0 || scale;

            //------------------------------------------------------------


            //------------------------------------------------------------
            // Setup containers and skeleton of chart

            var wrap = container.selectAll('g.nv-distribution').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-distribution');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

            //------------------------------------------------------------


            var distWrap = g.selectAll('g.nv-dist')
                .data(function(d) { return d }, function(d) { return d.key });

            distWrap.enter().append('g');
            distWrap
                .attr('class', function(d,i) { return 'nv-dist nv-series-' + i })
                .style('stroke', function(d,i) { return color(d, i) });

            var dist = distWrap.selectAll('line.nv-dist' + axis)
                .data(function(d) { return d.values })
            dist.enter().append('line')
                .attr(axis + '1', function(d,i) { return scale0(getData(d,i)) })
                .attr(axis + '2', function(d,i) { return scale0(getData(d,i)) })
            renderWatch.transition(distWrap.exit().selectAll('line.nv-dist' + axis), 'dist exit')
                // .transition()
                .attr(axis + '1', function(d,i) { return scale(getData(d,i)) })
                .attr(axis + '2', function(d,i) { return scale(getData(d,i)) })
                .style('stroke-opacity', 0)
                .remove();
            dist
                .attr('class', function(d,i) { return 'nv-dist' + axis + ' nv-dist' + axis + '-' + i })
                .attr(naxis + '1', 0)
                .attr(naxis + '2', size);
            renderWatch.transition(dist, 'dist')
                // .transition()
                .attr(axis + '1', function(d,i) { return scale(getData(d,i)) })
                .attr(axis + '2', function(d,i) { return scale(getData(d,i)) })


            scale0 = scale.copy();

        });
        renderWatch.renderEnd('distribution immediate');
        return chart;
    }


    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------
    chart.options = nv.utils.optionsFunc.bind(chart);
    chart.dispatch = dispatch;

    chart.margin = function(_) {
        if (!arguments.length) return margin;
        margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
        margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
        margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
        margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
        return chart;
    };

    chart.width = function(_) {
        if (!arguments.length) return width;
        width = _;
        return chart;
    };

    chart.axis = function(_) {
        if (!arguments.length) return axis;
        axis = _;
        return chart;
    };

    chart.size = function(_) {
        if (!arguments.length) return size;
        size = _;
        return chart;
    };

    chart.getData = function(_) {
        if (!arguments.length) return getData;
        getData = d3.functor(_);
        return chart;
    };

    chart.scale = function(_) {
        if (!arguments.length) return scale;
        scale = _;
        return chart;
    };

    chart.color = function(_) {
        if (!arguments.length) return color;
        color = nv.utils.getColor(_);
        return chart;
    };

    chart.duration = function(_) {
        if (!arguments.length) return duration;
        duration = _;
        renderWatch.reset(duration);
        return chart;
    };
    //============================================================


    return chart;
}
//TODO: consider deprecating and using multibar with single series for this
nv.models.historicalBar = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = null
        , height = null
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , x = d3.scale.linear()
        , y = d3.scale.linear()
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , forceX = []
        , forceY = [0]
        , padData = false
        , clipEdge = true
        , color = nv.utils.defaultColor()
        , xDomain
        , yDomain
        , xRange
        , yRange
        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
        , interactive = true
        ;

    var renderWatch = nv.utils.renderWatch(dispatch, 0);

    function chart(selection) {
        selection.each(function(data) {
            renderWatch.reset();

            var container = d3.select(this);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                - margin.left - margin.right;
            var availableHeight = (height || parseInt(container.style('height')) || 400)
                - margin.top - margin.bottom;

            nv.utils.initSVG(container);

            // Setup Scales
            x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX) ));

            if (padData)
                x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
            else
                x.range(xRange || [0, availableWidth]);

            y.domain(yDomain || d3.extent(data[0].values.map(getY).concat(forceY) ))
                .range(yRange || [availableHeight, 0]);

            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
            if (x.domain()[0] === x.domain()[1])
                x.domain()[0] ?
                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                    : x.domain([-1,1]);

            if (y.domain()[0] === y.domain()[1])
                y.domain()[0] ?
                    y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
                    : y.domain([-1,1]);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-historicalBar-' + id).data([data[0].values]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBar-' + id);
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-bars');
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            container
                .on('click', function(d,i) {
                    dispatch.chartClick({
                        data: d,
                        index: i,
                        pos: d3.event,
                        id: id
                    });
                });

            defsEnter.append('clipPath')
                .attr('id', 'nv-chart-clip-path-' + id)
                .append('rect');

            wrap.select('#nv-chart-clip-path-' + id + ' rect')
                .attr('width', availableWidth)
                .attr('height', availableHeight);

            g.attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');

            var bars = wrap.select('.nv-bars').selectAll('.nv-bar')
                .data(function(d) { return d }, function(d,i) {return getX(d,i)});
            bars.exit().remove();

            var barsEnter = bars.enter().append('rect')
                .attr('x', 0 )
                .attr('y', function(d,i) {  return nv.utils.NaNtoZero(y(Math.max(0, getY(d,i)))) })
                .attr('height', function(d,i) { return nv.utils.NaNtoZero(Math.abs(y(getY(d,i)) - y(0))) })
                .attr('transform', function(d,i) { return 'translate(' + (x(getX(d,i)) - availableWidth / data[0].values.length * .45) + ',0)'; })
                .on('mouseover', function(d,i) {
                    if (!interactive) return;
                    d3.select(this).classed('hover', true);
                    dispatch.elementMouseover({
                        point: d,
                        series: data[0],
                        pos: [x(getX(d,i)), y(getY(d,i))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: 0,
                        e: d3.event
                    });

                })
                .on('mouseout', function(d,i) {
                    if (!interactive) return;
                    d3.select(this).classed('hover', false);
                    dispatch.elementMouseout({
                        point: d,
                        series: data[0],
                        pointIndex: i,
                        seriesIndex: 0,
                        e: d3.event
                    });
                })
                .on('click', function(d,i) {
                    if (!interactive) return;
                    dispatch.elementClick({
                        //label: d[label],
                        value: getY(d,i),
                        data: d,
                        index: i,
                        pos: [x(getX(d,i)), y(getY(d,i))],
                        e: d3.event,
                        id: id
                    });
                    d3.event.stopPropagation();
                })
                .on('dblclick', function(d,i) {
                    if (!interactive) return;
                    dispatch.elementDblClick({
                        //label: d[label],
                        value: getY(d,i),
                        data: d,
                        index: i,
                        pos: [x(getX(d,i)), y(getY(d,i))],
                        e: d3.event,
                        id: id
                    });
                    d3.event.stopPropagation();
                });

            bars
                .attr('fill', function(d,i) { return color(d, i); })
                .attr('class', function(d,i,j) { return (getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive') + ' nv-bar-' + j + '-' + i })
                .watchTransition(renderWatch, 'bars')
                .attr('transform', function(d,i) { return 'translate(' + (x(getX(d,i)) - availableWidth / data[0].values.length * .45) + ',0)'; })
                //TODO: better width calculations that don't assume always uniform data spacing;w
                .attr('width', (availableWidth / data[0].values.length) * .9 );

            bars.watchTransition(renderWatch, 'bars')
                .attr('y', function(d,i) {
                    var rval = getY(d,i) < 0 ?
                        y(0) :
                            y(0) - y(getY(d,i)) < 1 ?
                        y(0) - 1 :
                        y(getY(d,i));
                    return nv.utils.NaNtoZero(rval);
                })
                .attr('height', function(d,i) { return nv.utils.NaNtoZero(Math.max(Math.abs(y(getY(d,i)) - y(0)),1)) });

        });

        renderWatch.renderEnd('historicalBar immediate');
        return chart;
    }

    //Create methods to allow outside functions to highlight a specific bar.
    chart.highlightPoint = function(pointIndex, isHoverOver) {
        d3.select(".nv-historicalBar-" + id)
            .select(".nv-bars .nv-bar-0-" + pointIndex)
            .classed("hover", isHoverOver)
        ;
    };

    chart.clearHighlights = function() {
        d3.select(".nv-historicalBar-" + id)
            .select(".nv-bars .nv-bar.hover")
            .classed("hover", false)
        ;
    };

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:   {get: function(){return width;}, set: function(_){width=_;}},
        height:  {get: function(){return height;}, set: function(_){height=_;}},
        forceX:  {get: function(){return forceX;}, set: function(_){forceX=_;}},
        forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},
        padData: {get: function(){return padData;}, set: function(_){padData=_;}},
        x:       {get: function(){return getX;}, set: function(_){getX=_;}},
        y:       {get: function(){return getY;}, set: function(_){getY=_;}},
        xScale:  {get: function(){return x;}, set: function(_){x=_;}},
        yScale:  {get: function(){return y;}, set: function(_){y=_;}},
        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
        clipEdge:    {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
        id:          {get: function(){return id;}, set: function(_){id=_;}},
        interactive: {get: function(){return interactive;}, set: function(_){interactive=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};

nv.models.historicalBarChart = function(bar_model) {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var bars = bar_model || nv.models.historicalBar()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , legend = nv.models.legend()
        , interactiveLayer = nv.interactiveGuideline()
        ;


    var margin = {top: 30, right: 90, bottom: 50, left: 90}
        , color = nv.utils.defaultColor()
        , width = null
        , height = null
        , showLegend = false
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , useInteractiveGuideline = false
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' at ' + x + '</p>'
        }
        , x
        , y
        , state = {}
        , defaultState = null
        , noData = 'No Data Available.'
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd')
        , transitionDuration = 250
        ;

    xAxis
        .orient('bottom')
        .tickPadding(7)
    ;
    yAxis
        .orient( (rightAlignYAxis) ? 'right' : 'left')
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {

        // New addition to calculate position if SVG is scaled with viewBox, may move TODO: consider implementing everywhere else
        if (offsetElement) {
            var svg = d3.select(offsetElement).select('svg');
            var viewBox = (svg.node()) ? svg.attr('viewBox') : null;
            if (viewBox) {
                viewBox = viewBox.split(' ');
                var ratio = parseInt(svg.style('width')) / viewBox[2];
                e.pos[0] = e.pos[0] * ratio;
                e.pos[1] = e.pos[1] * ratio;
            }
        }

        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(bars.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(bars.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, null, null, offsetElement);
    };
    var renderWatch = nv.utils.renderWatch(dispatch, 0);

    function chart(selection) {
        selection.each(function(data) {
            renderWatch.reset();
            renderWatch.models(bars);
            if (showXAxis) renderWatch.models(xAxis);
            if (showYAxis) renderWatch.models(yAxis);

            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;


            chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
            chart.container = this;

            //set state.disabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display noData message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = bars.xScale();
            y = bars.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-historicalBarChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBarChart').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis');
            gEnter.append('g').attr('class', 'nv-barsWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');
            gEnter.append('g').attr('class', 'nv-interactive');

            // Legend
            if (showLegend) {
                legend.width(availableWidth);

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                wrap.select('.nv-legendWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
            }
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            //Set up interactive layer
            if (useInteractiveGuideline) {
                interactiveLayer
                    .width(availableWidth)
                    .height(availableHeight)
                    .margin({left:margin.left, top:margin.top})
                    .svgContainer(container)
                    .xScale(x);
                wrap.select(".nv-interactive").call(interactiveLayer);
            }
            bars
                .width(availableWidth)
                .height(availableHeight)
                .color(data.map(function(d,i) {
                    return d.color || color(d, i);
                }).filter(function(d,i) { return !data[i].disabled }));

            var barsWrap = g.select('.nv-barsWrap')
                .datum(data.filter(function(d) { return !d.disabled }));
            barsWrap.transition().call(bars);

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .tickSize(-availableHeight, 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y.range()[0] + ')');
                g.select('.nv-x.nv-axis')
                    .transition()
                    .call(xAxis);
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis')
                    .transition()
                    .call(yAxis);
            }

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            interactiveLayer.dispatch.on('elementMousemove', function(e) {
                bars.clearHighlights();

                var singlePoint, pointIndex, pointXLocation, allData = [];
                data
                    .filter(function(series, i) {
                        series.seriesIndex = i;
                        return !series.disabled;
                    })
                    .forEach(function(series,i) {
                        pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                        bars.highlightPoint(pointIndex,true);
                        var point = series.values[pointIndex];
                        if (typeof point === 'undefined') return;
                        if (typeof singlePoint === 'undefined') singlePoint = point;
                        if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                        allData.push({
                            key: series.key,
                            value: chart.y()(point, pointIndex),
                            color: color(series,series.seriesIndex),
                            data: series.values[pointIndex]
                        });
                    });

                var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex));
                interactiveLayer.tooltip
                    .position({left: pointXLocation + margin.left, top: e.mouseY + margin.top})
                    .chartContainer(that.parentNode)
                    .enabled(tooltips)
                    .valueFormatter(function(d,i) {
                        return yAxis.tickFormat()(d);
                    })
                    .data(
                    {
                        value: xValue,
                        series: allData
                    }
                )();

                interactiveLayer.renderGuideLine(pointXLocation);

            });

            interactiveLayer.dispatch.on("elementMouseout",function(e) {
                dispatch.tooltipHide();
                bars.clearHighlights();
            });

            legend.dispatch.on('legendClick', function(d,i) {
                d.disabled = !d.disabled;

                if (!data.filter(function(d) { return !d.disabled }).length) {
                    data.map(function(d) {
                        d.disabled = false;
                        wrap.selectAll('.nv-series').classed('disabled', false);
                        return d;
                    });
                }

                state.disabled = data.map(function(d) { return !!d.disabled });
                dispatch.stateChange(state);

                selection.transition().call(chart);
            });

            legend.dispatch.on('legendDblclick', function(d) {
                //Double clicking should always enable current series, and disabled all others.
                data.forEach(function(d) {
                    d.disabled = true;
                });
                d.disabled = false;

                state.disabled = data.map(function(d) { return !!d.disabled });
                dispatch.stateChange(state);
                chart.update();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                chart.update();
            });
        });

        renderWatch.renderEnd('historicalBarChart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    bars.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    bars.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.bars = bars;
    chart.legend = legend;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.interactiveLayer = interactiveLayer;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        showXAxis: {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis: {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
            bars.color(color);
        }},
        duration:    {get: function(){return transitionDuration;}, set: function(_){
            transitionDuration=_;
            renderWatch.reset(transitionDuration);
            yAxis.duration(transitionDuration);
            xAxis.duration(transitionDuration);
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( (_) ? 'right' : 'left');
        }},
        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
            useInteractiveGuideline = _;
            if (_ === true) {
                chart.interactive(false);
            }
        }}
    });

    nv.utils.inheritOptions(chart, bars);
    nv.utils.initOptions(chart);

    return chart;
};


// ohlcChart is just a historical chart with oclc bars and some tweaks
nv.models.ohlcBarChart = function() {
    var chart = nv.models.historicalBarChart(nv.models.ohlcBar());

    // special default tooltip since we show multiple values per x
    chart.useInteractiveGuideline(true);
    chart.interactiveLayer.tooltip.contentGenerator(function(data) {
        // we assume only one series exists for this chart
        var d = data.series[0].data;
        // match line colors as defined in nv.d3.css
        var color = d.open < d.close ? "2ca02c" : "d62728";
        return '' +
            '<h3 style="color: #' + color + '">' + data.value + '</h3>' +
            '<table>' +
            '<tr><td>open:</td><td>' + chart.yAxis.tickFormat()(d.open) + '</td></tr>' +
            '<tr><td>close:</td><td>' + chart.yAxis.tickFormat()(d.close) + '</td></tr>' +
            '<tr><td>high</td><td>' + chart.yAxis.tickFormat()(d.high) + '</td></tr>' +
            '<tr><td>low:</td><td>' + chart.yAxis.tickFormat()(d.low) + '</td></tr>' +
            '</table>';
    });
    return chart;
};nv.models.legend = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 5, right: 0, bottom: 5, left: 0}
        , width = 400
        , height = 20
        , getKey = function(d) { return d.key }
        , color = nv.utils.defaultColor()
        , align = true
        , rightAlign = true
        , updateState = true   //If true, legend will update data.disabled and trigger a 'stateChange' dispatch.
        , radioButtonMode = false   //If true, clicking legend items will cause it to behave like a radio button. (only one can be selected at a time)
        , dispatch = d3.dispatch('legendClick', 'legendDblclick', 'legendMouseover', 'legendMouseout', 'stateChange')
        ;

    function chart(selection) {
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                container = d3.select(this);
            nv.utils.initSVG(container);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-legend').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-legend').append('g');
            var g = wrap.select('g');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            var series = g.selectAll('.nv-series')
                .data(function(d) { return d });
            var seriesEnter = series.enter().append('g').attr('class', 'nv-series')
                .on('mouseover', function(d,i) {
                    dispatch.legendMouseover(d,i);  //TODO: Make consistent with other event objects
                })
                .on('mouseout', function(d,i) {
                    dispatch.legendMouseout(d,i);
                })
                .on('click', function(d,i) {
                    dispatch.legendClick(d,i);
                    if (updateState) {
                        if (radioButtonMode) {
                            //Radio button mode: set every series to disabled,
                            //  and enable the clicked series.
                            data.forEach(function(series) { series.disabled = true});
                            d.disabled = false;
                        }
                        else {
                            d.disabled = !d.disabled;
                            if (data.every(function(series) { return series.disabled})) {
                                //the default behavior of NVD3 legends is, if every single series
                                // is disabled, turn all series' back on.
                                data.forEach(function(series) { series.disabled = false});
                            }
                        }
                        dispatch.stateChange({
                            disabled: data.map(function(d) { return !!d.disabled })
                        });
                    }
                })
                .on('dblclick', function(d,i) {
                    dispatch.legendDblclick(d,i);
                    if (updateState) {
                        //the default behavior of NVD3 legends, when double clicking one,
                        // is to set all other series' to false, and make the double clicked series enabled.
                        data.forEach(function(series) {
                            series.disabled = true;
                        });
                        d.disabled = false;
                        dispatch.stateChange({
                            disabled: data.map(function(d) { return !!d.disabled })
                        });
                    }
                });
            seriesEnter.append('circle')
                .style('stroke-width', 2)
                .attr('class','nv-legend-symbol')
                .attr('r', 5);
            seriesEnter.append('text')
                .attr('text-anchor', 'start')
                .attr('class','nv-legend-text')
                .attr('dy', '.32em')
                .attr('dx', '8');
            series.classed('nv-disabled', function(d) { return d.disabled });
            series.exit().remove();
            series.select('circle')
                .style('fill', function(d,i) { return d.color || color(d,i)})
                .style('stroke', function(d,i) { return d.color || color(d, i) });
            series.select('text').text(getKey);

            //TODO: implement fixed-width and max-width options (max-width is especially useful with the align option)
            // NEW ALIGNING CODE, TODO: clean up
            if (align) {

                var seriesWidths = [];
                series.each(function(d,i) {
                    var legendText = d3.select(this).select('text');
                    var nodeTextLength;
                    try {
                        nodeTextLength = legendText.node().getComputedTextLength();
                        // If the legendText is display:none'd (nodeTextLength == 0), simulate an error so we approximate, instead
                        if(nodeTextLength <= 0) throw Error();
                    }
                    catch(e) {
                        nodeTextLength = nv.utils.calcApproxTextWidth(legendText);
                    }

                    seriesWidths.push(nodeTextLength + 28); // 28 is ~ the width of the circle plus some padding
                });

                var seriesPerRow = 0;
                var legendWidth = 0;
                var columnWidths = [];

                while ( legendWidth < availableWidth && seriesPerRow < seriesWidths.length) {
                    columnWidths[seriesPerRow] = seriesWidths[seriesPerRow];
                    legendWidth += seriesWidths[seriesPerRow++];
                }
                if (seriesPerRow === 0) seriesPerRow = 1; //minimum of one series per row

                while ( legendWidth > availableWidth && seriesPerRow > 1 ) {
                    columnWidths = [];
                    seriesPerRow--;

                    for (var k = 0; k < seriesWidths.length; k++) {
                        if (seriesWidths[k] > (columnWidths[k % seriesPerRow] || 0) )
                            columnWidths[k % seriesPerRow] = seriesWidths[k];
                    }

                    legendWidth = columnWidths.reduce(function(prev, cur, index, array) {
                        return prev + cur;
                    });
                }

                var xPositions = [];
                for (var i = 0, curX = 0; i < seriesPerRow; i++) {
                    xPositions[i] = curX;
                    curX += columnWidths[i];
                }

                series
                    .attr('transform', function(d, i) {
                        return 'translate(' + xPositions[i % seriesPerRow] + ',' + (5 + Math.floor(i / seriesPerRow) * 20) + ')';
                    });

                //position legend as far right as possible within the total width
                if (rightAlign) {
                    g.attr('transform', 'translate(' + (width - margin.right - legendWidth) + ',' + margin.top + ')');
                }
                else {
                    g.attr('transform', 'translate(0' + ',' + margin.top + ')');
                }

                height = margin.top + margin.bottom + (Math.ceil(seriesWidths.length / seriesPerRow) * 20);

            } else {

                var ypos = 5,
                    newxpos = 5,
                    maxwidth = 0,
                    xpos;
                series
                    .attr('transform', function(d, i) {
                        var length = d3.select(this).select('text').node().getComputedTextLength() + 28;
                        xpos = newxpos;

                        if (width < margin.left + margin.right + xpos + length) {
                            newxpos = xpos = 5;
                            ypos += 20;
                        }

                        newxpos += length;
                        if (newxpos > maxwidth) maxwidth = newxpos;

                        return 'translate(' + xpos + ',' + ypos + ')';
                    });

                //position legend as far right as possible within the total width
                g.attr('transform', 'translate(' + (width - margin.right - maxwidth) + ',' + margin.top + ')');

                height = margin.top + margin.bottom + ypos + 15;
            }
        });

        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        key: {get: function(){return getKey;}, set: function(_){getKey=_;}},
        align:      {get: function(){return align;}, set: function(_){align=_;}},
        rightAlign:    {get: function(){return rightAlign;}, set: function(_){rightAlign=_;}},
        updateState:    {get: function(){return updateState;}, set: function(_){updateState=_;}},
        radioButtonMode:    {get: function(){return radioButtonMode;}, set: function(_){radioButtonMode=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};

nv.models.line = function() {
    "use strict";
    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var  scatter = nv.models.scatter()
        ;

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 960
        , height = 500
        , color = nv.utils.defaultColor() // a function that returns a color
        , getX = function(d) { return d.x } // accessor to get the x value from a data point
        , getY = function(d) { return d.y } // accessor to get the y value from a data point
        , defined = function(d,i) { return !isNaN(getY(d,i)) && getY(d,i) !== null } // allows a line to be not continuous when it is not defined
        , isArea = function(d) { return d.area } // decides if a line is an area or just a line
        , clipEdge = false // if true, masks lines within x and y scale
        , x //can be accessed via chart.xScale()
        , y //can be accessed via chart.yScale()
        , interpolate = "linear" // controls the line interpolation
        , duration = 250
        , dispatch = d3.dispatch('elementClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
        ;

    scatter
        .pointSize(16) // default size
        .pointDomain([16,256]) //set to speed up calculation, needs to be unset if there is a custom size accessor
    ;

    //============================================================


    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0 //used to store previous scales
        , renderWatch = nv.utils.renderWatch(dispatch, duration)
        ;

    //============================================================


    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(scatter);
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            // Setup Scales
            x = scatter.xScale();
            y = scatter.yScale();

            x0 = x0 || x;
            y0 = y0 || y;

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-line').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-line');
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-groups');
            gEnter.append('g').attr('class', 'nv-scatterWrap');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            scatter
                .width(availableWidth)
                .height(availableHeight);

            var scatterWrap = wrap.select('.nv-scatterWrap');
            scatterWrap.call(scatter);

            defsEnter.append('clipPath')
                .attr('id', 'nv-edge-clip-' + scatter.id())
                .append('rect');

            wrap.select('#nv-edge-clip-' + scatter.id() + ' rect')
                .attr('width', availableWidth)
                .attr('height', (availableHeight > 0) ? availableHeight : 0);

            g   .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');
            scatterWrap
                .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');

            var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                .data(function(d) { return d }, function(d) { return d.key });
            groups.enter().append('g')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6);

            groups.exit().remove();

            groups
                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                .classed('hover', function(d) { return d.hover })
                .style('fill', function(d,i){ return color(d, i) })
                .style('stroke', function(d,i){ return color(d, i)});
            groups.watchTransition(renderWatch, 'line: groups')
                .style('stroke-opacity', 1)
                .style('fill-opacity', .5);

            var areaPaths = groups.selectAll('path.nv-area')
                .data(function(d) { return isArea(d) ? [d] : [] }); // this is done differently than lines because I need to check if series is an area
            areaPaths.enter().append('path')
                .attr('class', 'nv-area')
                .attr('d', function(d) {
                    return d3.svg.area()
                        .interpolate(interpolate)
                        .defined(defined)
                        .x(function(d,i) { return nv.utils.NaNtoZero(x0(getX(d,i))) })
                        .y0(function(d,i) { return nv.utils.NaNtoZero(y0(getY(d,i))) })
                        .y1(function(d,i) { return y0( y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0] ) })
                        //.y1(function(d,i) { return y0(0) }) //assuming 0 is within y domain.. may need to tweak this
                        .apply(this, [d.values])
                });
            groups.exit().selectAll('path.nv-area')
                .remove();

            areaPaths.watchTransition(renderWatch, 'line: areaPaths')
                .attr('d', function(d) {
                    return d3.svg.area()
                        .interpolate(interpolate)
                        .defined(defined)
                        .x(function(d,i) { return nv.utils.NaNtoZero(x(getX(d,i))) })
                        .y0(function(d,i) { return nv.utils.NaNtoZero(y(getY(d,i))) })
                        .y1(function(d,i) { return y( y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0] ) })
                        //.y1(function(d,i) { return y0(0) }) //assuming 0 is within y domain.. may need to tweak this
                        .apply(this, [d.values])
                });

            var linePaths = groups.selectAll('path.nv-line')
                .data(function(d) { return [d.values] });
            linePaths.enter().append('path')
                .attr('class', 'nv-line')
                .attr('d',
                    d3.svg.line()
                    .interpolate(interpolate)
                    .defined(defined)
                    .x(function(d,i) { return nv.utils.NaNtoZero(x0(getX(d,i))) })
                    .y(function(d,i) { return nv.utils.NaNtoZero(y0(getY(d,i))) })
            );

            linePaths.watchTransition(renderWatch, 'line: linePaths')
                .attr('d',
                    d3.svg.line()
                    .interpolate(interpolate)
                    .defined(defined)
                    .x(function(d,i) { return nv.utils.NaNtoZero(x(getX(d,i))) })
                    .y(function(d,i) { return nv.utils.NaNtoZero(y(getY(d,i))) })
            );

            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();
        });
        renderWatch.renderEnd('line immediate');
        return chart;
    }


    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.scatter = scatter;
    // Pass through events
    scatter.dispatch.on('elementClick', function(){ dispatch.elementClick.apply(this, arguments); })
    scatter.dispatch.on('elementMouseover', function(){ dispatch.elementMouseover.apply(this, arguments); })
    scatter.dispatch.on('elementMouseout', function(){ dispatch.elementMouseout.apply(this, arguments); })

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        defined: {get: function(){return defined;}, set: function(_){defined=_;}},
        interpolate:      {get: function(){return interpolate;}, set: function(_){interpolate=_;}},
        clipEdge:    {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            scatter.duration(duration);
        }},
        isArea: {get: function(){return isArea;}, set: function(_){
            isArea = d3.functor(_);
        }},
        x: {get: function(){return getX;}, set: function(_){
            getX = _;
            scatter.x(_);
        }},
        y: {get: function(){return getY;}, set: function(_){
            getY = _;
            scatter.y(_);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            scatter.color(color);
        }}
    });

    nv.utils.inheritOptions(chart, scatter);
    nv.utils.initOptions(chart);

    return chart;
};
nv.models.lineChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var lines = nv.models.line()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , legend = nv.models.legend()
        , interactiveLayer = nv.interactiveGuideline()
        ;

    var margin = {top: 30, right: 20, bottom: 50, left: 60}
        , color = nv.utils.defaultColor()
        , width = null
        , height = null
        , showLegend = true
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , useInteractiveGuideline = false
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' at ' + x + '</p>'
        }
        , x
        , y
        , state = nv.utils.state()
        , defaultState = null
        , noData = 'No Data Available.'
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd')
        , duration = 250
        ;

    xAxis
        .orient('bottom')
        .tickPadding(7)
    ;
    yAxis
        .orient((rightAlignYAxis) ? 'right' : 'left')
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, null, null, offsetElement);
    };

    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(lines);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;


            chart.update = function() {
                if (duration === 0)
                    container.call(chart);
                else
                    container.transition().duration(duration).call(chart)
            };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display noData message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }


            // Setup Scales
            x = lines.xScale();
            y = lines.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-lineChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineChart').append('g');
            var g = wrap.select('g');

            gEnter.append("rect").style("opacity",0);
            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis');
            gEnter.append('g').attr('class', 'nv-linesWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');
            gEnter.append('g').attr('class', 'nv-interactive');

            g.select("rect")
                .attr("width",availableWidth)
                .attr("height",(availableHeight > 0) ? availableHeight : 0);

            // Legend
            if (showLegend) {
                legend.width(availableWidth);

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                wrap.select('.nv-legendWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            //Set up interactive layer
            if (useInteractiveGuideline) {
                interactiveLayer
                    .width(availableWidth)
                    .height(availableHeight)
                    .margin({left:margin.left, top:margin.top})
                    .svgContainer(container)
                    .xScale(x);
                wrap.select(".nv-interactive").call(interactiveLayer);
            }

            lines
                .width(availableWidth)
                .height(availableHeight)
                .color(data.map(function(d,i) {
                    return d.color || color(d, i);
                }).filter(function(d,i) { return !data[i].disabled }));


            var linesWrap = g.select('.nv-linesWrap')
                .datum(data.filter(function(d) { return !d.disabled }));

            linesWrap.call(lines);

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize(-availableHeight, 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y.range()[0] + ')');
                g.select('.nv-x.nv-axis')
                    .call(xAxis);
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis')
                    .call(yAxis);
            }

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            interactiveLayer.dispatch.on('elementMousemove', function(e) {
                lines.clearHighlights();
                var singlePoint, pointIndex, pointXLocation, allData = [];
                data
                    .filter(function(series, i) {
                        series.seriesIndex = i;
                        return !series.disabled;
                    })
                    .forEach(function(series,i) {
                        pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                        lines.highlightPoint(i, pointIndex, true);
                        var point = series.values[pointIndex];
                        if (typeof point === 'undefined') return;
                        if (typeof singlePoint === 'undefined') singlePoint = point;
                        if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                        allData.push({
                            key: series.key,
                            value: chart.y()(point, pointIndex),
                            color: color(series,series.seriesIndex)
                        });
                    });
                //Highlight the tooltip entry based on which point the mouse is closest to.
                if (allData.length > 2) {
                    var yValue = chart.yScale().invert(e.mouseY);
                    var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
                    var threshold = 0.03 * domainExtent;
                    var indexToHighlight = nv.nearestValueIndex(allData.map(function(d){return d.value}),yValue,threshold);
                    if (indexToHighlight !== null)
                        allData[indexToHighlight].highlight = true;
                }

                var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex));
                interactiveLayer.tooltip
                    .position({left: pointXLocation + margin.left, top: e.mouseY + margin.top})
                    .chartContainer(that.parentNode)
                    .enabled(tooltips)
                    .valueFormatter(function(d,i) {
                        return yAxis.tickFormat()(d);
                    })
                    .data(
                    {
                        value: xValue,
                        series: allData
                    }
                )();

                interactiveLayer.renderGuideLine(pointXLocation);

            });

            interactiveLayer.dispatch.on('elementClick', function(e) {
                var pointXLocation, allData = [];

                data.filter(function(series, i) {
                    series.seriesIndex = i;
                    return !series.disabled;
                }).forEach(function(series) {
                    var pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                    var point = series.values[pointIndex];
                    if (typeof point === 'undefined') return;
                    if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                    var yPos = chart.yScale()(chart.y()(point,pointIndex));
                    allData.push({
                        point: point,
                        pointIndex: pointIndex,
                        pos: [pointXLocation, yPos],
                        seriesIndex: series.seriesIndex,
                        series: series
                    });
                });

                lines.dispatch.elementClick(allData);
            });

            interactiveLayer.dispatch.on("elementMouseout",function(e) {
                dispatch.tooltipHide();
                lines.clearHighlights();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                chart.update();
            });

        });

        renderWatch.renderEnd('lineChart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    lines.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.lines = lines;
    chart.legend = legend;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.interactiveLayer = interactiveLayer;

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            lines.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
            lines.color(color);
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( rightAlignYAxis ? 'right' : 'left');
        }},
        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
            useInteractiveGuideline = _;
            if (useInteractiveGuideline) {
                lines.interactive(false);
                lines.useVoronoi(false);
            }
        }}
    });

    nv.utils.inheritOptions(chart, lines);
    nv.utils.initOptions(chart);

    return chart;
};
nv.models.linePlusBarChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var lines = nv.models.line()
        , lines2 = nv.models.line()
        , bars = nv.models.historicalBar()
        , bars2 = nv.models.historicalBar()
        , xAxis = nv.models.axis()
        , x2Axis = nv.models.axis()
        , y1Axis = nv.models.axis()
        , y2Axis = nv.models.axis()
        , y3Axis = nv.models.axis()
        , y4Axis = nv.models.axis()
        , legend = nv.models.legend()
        , brush = d3.svg.brush()
        ;

    var margin = {top: 30, right: 30, bottom: 30, left: 60}
        , margin2 = {top: 0, right: 30, bottom: 20, left: 60}
        , width = null
        , height = null
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , color = nv.utils.defaultColor()
        , showLegend = true
        , focusEnable = true
        , focusShowAxisY = false
        , focusShowAxisX = true
        , focusHeight = 50
        , extent
        , brushExtent = null
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' at ' + x + '</p>';
        }
        , x
        , x2
        , y1
        , y2
        , y3
        , y4
        , noData = "No Data Available."
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'brush', 'stateChange', 'changeState')
        , transitionDuration = 0
        , state = nv.utils.state()
        , defaultState = null
        , legendLeftAxisHint = ' (left axis)'
        , legendRightAxisHint = ' (right axis)'
        ;

    lines
        .clipEdge(true)
    ;
    lines2
        .interactive(false)
    ;
    xAxis
        .orient('bottom')
        .tickPadding(5)
    ;
    y1Axis
        .orient('left')
    ;
    y2Axis
        .orient('right')
    ;
    x2Axis
        .orient('bottom')
        .tickPadding(5)
    ;
    y3Axis
        .orient('left')
    ;
    y4Axis
        .orient('right')
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        if (extent) {
            e.pointIndex += Math.ceil(extent[0]);
        }
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
            y = (e.series.bar ? y1Axis : y2Axis).tickFormat()(lines.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight1 = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom - (focusEnable ? focusHeight : 0) ,
                availableHeight2 = focusHeight - margin2.top - margin2.bottom;

            chart.update = function() { container.transition().duration(transitionDuration).call(chart); };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight1 / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            var dataBars = data.filter(function(d) { return !d.disabled && d.bar });
            var dataLines = data.filter(function(d) { return !d.bar }); // removed the !d.disabled clause here to fix Issue #240

            x = bars.xScale();
            x2 = x2Axis.scale();
            y1 = bars.yScale();
            y2 = lines.yScale();
            y3 = bars2.yScale();
            y4 = lines2.yScale();

            var series1 = data
                .filter(function(d) { return !d.disabled && d.bar })
                .map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: getX(d,i), y: getY(d,i) }
                    })
                });

            var series2 = data
                .filter(function(d) { return !d.disabled && !d.bar })
                .map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: getX(d,i), y: getY(d,i) }
                    })
                });

            x.range([0, availableWidth]);

            x2  .domain(d3.extent(d3.merge(series1.concat(series2)), function(d) { return d.x } ))
                .range([0, availableWidth]);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-linePlusBar').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-linePlusBar').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-legendWrap');

            // this is the main chart
            var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
            focusEnter.append('g').attr('class', 'nv-x nv-axis');
            focusEnter.append('g').attr('class', 'nv-y1 nv-axis');
            focusEnter.append('g').attr('class', 'nv-y2 nv-axis');
            focusEnter.append('g').attr('class', 'nv-barsWrap');
            focusEnter.append('g').attr('class', 'nv-linesWrap');

            // context chart is where you can focus in
            var contextEnter = gEnter.append('g').attr('class', 'nv-context');
            contextEnter.append('g').attr('class', 'nv-x nv-axis');
            contextEnter.append('g').attr('class', 'nv-y1 nv-axis');
            contextEnter.append('g').attr('class', 'nv-y2 nv-axis');
            contextEnter.append('g').attr('class', 'nv-barsWrap');
            contextEnter.append('g').attr('class', 'nv-linesWrap');
            contextEnter.append('g').attr('class', 'nv-brushBackground');
            contextEnter.append('g').attr('class', 'nv-x nv-brush');

            //============================================================
            // Legend
            //------------------------------------------------------------

            if (showLegend) {
                legend.width( availableWidth / 2 );

                g.select('.nv-legendWrap')
                    .datum(data.map(function(series) {
                        series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
                        series.key = series.originalKey + (series.bar ? legendLeftAxisHint : legendRightAxisHint);
                        return series;
                    }))
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight1 = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom - focusHeight;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(' + ( availableWidth / 2 ) + ',' + (-margin.top) +')');
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            //============================================================
            // Context chart (focus chart) components
            //------------------------------------------------------------

            // hide or show the focus context chart
            g.select('.nv-context').style('display', focusEnable ? 'initial' : 'none');

            bars2
                .width(availableWidth)
                .height(availableHeight2)
                .color(data.map(function (d, i) {
                    return d.color || color(d, i);
                }).filter(function (d, i) {
                    return !data[i].disabled && data[i].bar
                }));
            lines2
                .width(availableWidth)
                .height(availableHeight2)
                .color(data.map(function (d, i) {
                    return d.color || color(d, i);
                }).filter(function (d, i) {
                    return !data[i].disabled && !data[i].bar
                }));

            var bars2Wrap = g.select('.nv-context .nv-barsWrap')
                .datum(dataBars.length ? dataBars : [
                    {values: []}
                ]);
            var lines2Wrap = g.select('.nv-context .nv-linesWrap')
                .datum(!dataLines[0].disabled ? dataLines : [
                    {values: []}
                ]);

            g.select('.nv-context')
                .attr('transform', 'translate(0,' + ( availableHeight1 + margin.bottom + margin2.top) + ')');

            bars2Wrap.transition().call(bars2);
            lines2Wrap.transition().call(lines2);

            // context (focus chart) axis controls
            if (focusShowAxisX) {
                x2Axis
                    .ticks(nv.utils.calcTicksX(availableWidth / 100, data))
                    .tickSize(-availableHeight2, 0);
                g.select('.nv-context .nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y3.range()[0] + ')');
                g.select('.nv-context .nv-x.nv-axis').transition()
                    .call(x2Axis);
            }

            if (focusShowAxisY) {
                y3Axis
                    .scale(y3)
                    .ticks( availableHeight2 / 36 )
                    .tickSize( -availableWidth, 0);
                y4Axis
                    .scale(y4)
                    .ticks( availableHeight2 / 36 )
                    .tickSize(dataBars.length ? 0 : -availableWidth, 0); // Show the y2 rules only if y1 has none

                g.select('.nv-context .nv-y3.nv-axis')
                    .style('opacity', dataBars.length ? 1 : 0)
                    .attr('transform', 'translate(0,' + x2.range()[0] + ')');
                g.select('.nv-context .nv-y2.nv-axis')
                    .style('opacity', dataLines.length ? 1 : 0)
                    .attr('transform', 'translate(' + x2.range()[1] + ',0)');

                g.select('.nv-context .nv-y1.nv-axis').transition()
                    .call(y3Axis);
                g.select('.nv-context .nv-y2.nv-axis').transition()
                    .call(y4Axis);
            }

            // Setup Brush
            brush.x(x2).on('brush', onBrush);

            if (brushExtent) brush.extent(brushExtent);

            var brushBG = g.select('.nv-brushBackground').selectAll('g')
                .data([brushExtent || brush.extent()]);

            var brushBGenter = brushBG.enter()
                .append('g');

            brushBGenter.append('rect')
                .attr('class', 'left')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', availableHeight2);

            brushBGenter.append('rect')
                .attr('class', 'right')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', availableHeight2);

            var gBrush = g.select('.nv-x.nv-brush')
                .call(brush);
            gBrush.selectAll('rect')
                //.attr('y', -5)
                .attr('height', availableHeight2);
            gBrush.selectAll('.resize').append('path').attr('d', resizePath);

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {
                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });
                    state.disabled = e.disabled;
                }
                chart.update();
            });

            //============================================================
            // Functions
            //------------------------------------------------------------

            // Taken from crossfilter (http://square.github.com/crossfilter/)
            function resizePath(d) {
                var e = +(d == 'e'),
                    x = e ? 1 : -1,
                    y = availableHeight2 / 3;
                return 'M' + (.5 * x) + ',' + y
                    + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)
                    + 'V' + (2 * y - 6)
                    + 'A6,6 0 0 ' + e + ' ' + (.5 * x) + ',' + (2 * y)
                    + 'Z'
                    + 'M' + (2.5 * x) + ',' + (y + 8)
                    + 'V' + (2 * y - 8)
                    + 'M' + (4.5 * x) + ',' + (y + 8)
                    + 'V' + (2 * y - 8);
            }


            function updateBrushBG() {
                if (!brush.empty()) brush.extent(brushExtent);
                brushBG
                    .data([brush.empty() ? x2.domain() : brushExtent])
                    .each(function(d,i) {
                        var leftWidth = x2(d[0]) - x2.range()[0],
                            rightWidth = x2.range()[1] - x2(d[1]);
                        d3.select(this).select('.left')
                            .attr('width',  leftWidth < 0 ? 0 : leftWidth);

                        d3.select(this).select('.right')
                            .attr('x', x2(d[1]))
                            .attr('width', rightWidth < 0 ? 0 : rightWidth);
                    });
            }

            function onBrush() {
                brushExtent = brush.empty() ? null : brush.extent();
                extent = brush.empty() ? x2.domain() : brush.extent();
                dispatch.brush({extent: extent, brush: brush});
                updateBrushBG();

                // Prepare Main (Focus) Bars and Lines
                bars
                    .width(availableWidth)
                    .height(availableHeight1)
                    .color(data.map(function(d,i) {
                        return d.color || color(d, i);
                    }).filter(function(d,i) { return !data[i].disabled && data[i].bar }));

                lines
                    .width(availableWidth)
                    .height(availableHeight1)
                    .color(data.map(function(d,i) {
                        return d.color || color(d, i);
                    }).filter(function(d,i) { return !data[i].disabled && !data[i].bar }));

                var focusBarsWrap = g.select('.nv-focus .nv-barsWrap')
                    .datum(!dataBars.length ? [{values:[]}] :
                        dataBars
                            .map(function(d,i) {
                                return {
                                    key: d.key,
                                    values: d.values.filter(function(d,i) {
                                        return bars.x()(d,i) >= extent[0] && bars.x()(d,i) <= extent[1];
                                    })
                                }
                            })
                );

                var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')
                    .datum(dataLines[0].disabled ? [{values:[]}] :
                        dataLines
                            .map(function(d,i) {
                                return {
                                    key: d.key,
                                    values: d.values.filter(function(d,i) {
                                        return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                                    })
                                }
                            })
                );

                // Update Main (Focus) X Axis
                if (dataBars.length) {
                    x = bars.xScale();
                } else {
                    x = lines.xScale();
                }

                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize(-availableHeight1, 0);

                xAxis.domain([Math.ceil(extent[0]), Math.floor(extent[1])]);

                g.select('.nv-x.nv-axis').transition().duration(transitionDuration)
                    .call(xAxis);

                // Update Main (Focus) Bars and Lines
                focusBarsWrap.transition().duration(transitionDuration).call(bars);
                focusLinesWrap.transition().duration(transitionDuration).call(lines);

                // Setup and Update Main (Focus) Y Axes
                g.select('.nv-focus .nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y1.range()[0] + ')');

                y1Axis
                    .scale(y1)
                    .ticks( nv.utils.calcTicksY(availableHeight1/36, data) )
                    .tickSize(-availableWidth, 0);
                y2Axis
                    .scale(y2)
                    .ticks( nv.utils.calcTicksY(availableHeight1/36, data) )
                    .tickSize(dataBars.length ? 0 : -availableWidth, 0); // Show the y2 rules only if y1 has none

                g.select('.nv-focus .nv-y1.nv-axis')
                    .style('opacity', dataBars.length ? 1 : 0);
                g.select('.nv-focus .nv-y2.nv-axis')
                    .style('opacity', dataLines.length && !dataLines[0].disabled ? 1 : 0)
                    .attr('transform', 'translate(' + x.range()[1] + ',0)');

                g.select('.nv-focus .nv-y1.nv-axis').transition().duration(transitionDuration)
                    .call(y1Axis);
                g.select('.nv-focus .nv-y2.nv-axis').transition().duration(transitionDuration)
                    .call(y2Axis);
            }

            onBrush();

        });

        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    lines.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    bars.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    bars.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================


    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.legend = legend;
    chart.lines = lines;
    chart.lines2 = lines2;
    chart.bars = bars;
    chart.bars2 = bars2;
    chart.xAxis = xAxis;
    chart.x2Axis = x2Axis;
    chart.y1Axis = y1Axis;
    chart.y2Axis = y2Axis;
    chart.y3Axis = y3Axis;
    chart.y4Axis = y4Axis;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        brushExtent:    {get: function(){return brushExtent;}, set: function(_){brushExtent=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
        focusEnable:    {get: function(){return focusEnable;}, set: function(_){focusEnable=_;}},
        focusHeight:    {get: function(){return focusHeight;}, set: function(_){focusHeight=_;}},
        focusShowAxisX:    {get: function(){return focusShowAxisX;}, set: function(_){focusShowAxisX=_;}},
        focusShowAxisY:    {get: function(){return focusShowAxisY;}, set: function(_){focusShowAxisY=_;}},
        legendLeftAxisHint:    {get: function(){return legendLeftAxisHint;}, set: function(_){legendLeftAxisHint=_;}},
        legendRightAxisHint:    {get: function(){return legendRightAxisHint;}, set: function(_){legendRightAxisHint=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return transitionDuration;}, set: function(_){
            transitionDuration = _;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
        }},
        x: {get: function(){return getX;}, set: function(_){
            getX = _;
            lines.x(_);
            lines2.x(_);
            bars.x(_);
            bars2.x(_);
        }},
        y: {get: function(){return getY;}, set: function(_){
            getY = _;
            lines.y(_);
            lines2.y(_);
            bars.y(_);
            bars2.y(_);
        }}
    });

    nv.utils.inheritOptions(chart, lines);
    nv.utils.initOptions(chart);

    return chart;
};
nv.models.lineWithFocusChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var lines = nv.models.line()
        , lines2 = nv.models.line()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , x2Axis = nv.models.axis()
        , y2Axis = nv.models.axis()
        , legend = nv.models.legend()
        , brush = d3.svg.brush()
        ;

    var margin = {top: 30, right: 30, bottom: 30, left: 60}
        , margin2 = {top: 0, right: 30, bottom: 20, left: 60}
        , color = nv.utils.defaultColor()
        , width = null
        , height = null
        , height2 = 100
        , x
        , y
        , x2
        , y2
        , showLegend = true
        , brushExtent = null
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' at ' + x + '</p>'
        }
        , noData = "No Data Available."
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'brush', 'stateChange', 'changeState')
        , transitionDuration = 250
        , state = nv.utils.state()
        , defaultState = null
        ;

    lines
        .clipEdge(true)
    ;
    lines2
        .interactive(false)
    ;
    xAxis
        .orient('bottom')
        .tickPadding(5)
    ;
    yAxis
        .orient('left')
    ;
    x2Axis
        .orient('bottom')
        .tickPadding(5)
    ;
    y2Axis
        .orient('left')
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(lines.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(lines.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, null, null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight1 = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom - height2,
                availableHeight2 = height2 - margin2.top - margin2.bottom;

            chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight1 / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = lines.xScale();
            y = lines.yScale();
            x2 = lines2.xScale();
            y2 = lines2.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-lineWithFocusChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineWithFocusChart').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-legendWrap');

            var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
            focusEnter.append('g').attr('class', 'nv-x nv-axis');
            focusEnter.append('g').attr('class', 'nv-y nv-axis');
            focusEnter.append('g').attr('class', 'nv-linesWrap');

            var contextEnter = gEnter.append('g').attr('class', 'nv-context');
            contextEnter.append('g').attr('class', 'nv-x nv-axis');
            contextEnter.append('g').attr('class', 'nv-y nv-axis');
            contextEnter.append('g').attr('class', 'nv-linesWrap');
            contextEnter.append('g').attr('class', 'nv-brushBackground');
            contextEnter.append('g').attr('class', 'nv-x nv-brush');

            // Legend
            if (showLegend) {
                legend.width(availableWidth);

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight1 = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom - height2;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Main Chart Component(s)
            lines
                .width(availableWidth)
                .height(availableHeight1)
                .color(
                data
                    .map(function(d,i) {
                        return d.color || color(d, i);
                    })
                    .filter(function(d,i) {
                        return !data[i].disabled;
                    })
            );

            lines2
                .defined(lines.defined())
                .width(availableWidth)
                .height(availableHeight2)
                .color(
                data
                    .map(function(d,i) {
                        return d.color || color(d, i);
                    })
                    .filter(function(d,i) {
                        return !data[i].disabled;
                    })
            );

            g.select('.nv-context')
                .attr('transform', 'translate(0,' + ( availableHeight1 + margin.bottom + margin2.top) + ')')

            var contextLinesWrap = g.select('.nv-context .nv-linesWrap')
                .datum(data.filter(function(d) { return !d.disabled }))

            d3.transition(contextLinesWrap).call(lines2);

            // Setup Main (Focus) Axes
            xAxis
                .scale(x)
                .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                .tickSize(-availableHeight1, 0);

            yAxis
                .scale(y)
                .ticks( nv.utils.calcTicksY(availableHeight1/36, data) )
                .tickSize( -availableWidth, 0);

            g.select('.nv-focus .nv-x.nv-axis')
                .attr('transform', 'translate(0,' + availableHeight1 + ')');

            // Setup Brush
            brush
                .x(x2)
                .on('brush', function() {
                    //When brushing, turn off transitions because chart needs to change immediately.
                    var oldTransition = chart.duration();
                    chart.duration(0);
                    onBrush();
                    chart.duration(oldTransition);
                });

            if (brushExtent) brush.extent(brushExtent);

            var brushBG = g.select('.nv-brushBackground').selectAll('g')
                .data([brushExtent || brush.extent()])

            var brushBGenter = brushBG.enter()
                .append('g');

            brushBGenter.append('rect')
                .attr('class', 'left')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', availableHeight2);

            brushBGenter.append('rect')
                .attr('class', 'right')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', availableHeight2);

            var gBrush = g.select('.nv-x.nv-brush')
                .call(brush);
            gBrush.selectAll('rect')
                //.attr('y', -5)
                .attr('height', availableHeight2);
            gBrush.selectAll('.resize').append('path').attr('d', resizePath);

            onBrush();

            // Setup Secondary (Context) Axes
            x2Axis
                .scale(x2)
                .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                .tickSize(-availableHeight2, 0);

            g.select('.nv-context .nv-x.nv-axis')
                .attr('transform', 'translate(0,' + y2.range()[0] + ')');
            d3.transition(g.select('.nv-context .nv-x.nv-axis'))
                .call(x2Axis);

            y2Axis
                .scale(y2)
                .ticks( nv.utils.calcTicksY(availableHeight2/36, data) )
                .tickSize( -availableWidth, 0);

            d3.transition(g.select('.nv-context .nv-y.nv-axis'))
                .call(y2Axis);

            g.select('.nv-context .nv-x.nv-axis')
                .attr('transform', 'translate(0,' + y2.range()[0] + ')');

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            dispatch.on('changeState', function(e) {
                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });
                }
                chart.update();
            });

            //============================================================
            // Functions
            //------------------------------------------------------------

            // Taken from crossfilter (http://square.github.com/crossfilter/)
            function resizePath(d) {
                var e = +(d == 'e'),
                    x = e ? 1 : -1,
                    y = availableHeight2 / 3;
                return 'M' + (.5 * x) + ',' + y
                    + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)
                    + 'V' + (2 * y - 6)
                    + 'A6,6 0 0 ' + e + ' ' + (.5 * x) + ',' + (2 * y)
                    + 'Z'
                    + 'M' + (2.5 * x) + ',' + (y + 8)
                    + 'V' + (2 * y - 8)
                    + 'M' + (4.5 * x) + ',' + (y + 8)
                    + 'V' + (2 * y - 8);
            }


            function updateBrushBG() {
                if (!brush.empty()) brush.extent(brushExtent);
                brushBG
                    .data([brush.empty() ? x2.domain() : brushExtent])
                    .each(function(d,i) {
                        var leftWidth = x2(d[0]) - x.range()[0],
                            rightWidth = x.range()[1] - x2(d[1]);
                        d3.select(this).select('.left')
                            .attr('width',  leftWidth < 0 ? 0 : leftWidth);

                        d3.select(this).select('.right')
                            .attr('x', x2(d[1]))
                            .attr('width', rightWidth < 0 ? 0 : rightWidth);
                    });
            }


            function onBrush() {
                brushExtent = brush.empty() ? null : brush.extent();
                var extent = brush.empty() ? x2.domain() : brush.extent();

                //The brush extent cannot be less than one.  If it is, don't update the line chart.
                if (Math.abs(extent[0] - extent[1]) <= 1) {
                    return;
                }

                dispatch.brush({extent: extent, brush: brush});


                updateBrushBG();

                // Update Main (Focus)
                var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')
                    .datum(
                    data
                        .filter(function(d) { return !d.disabled })
                        .map(function(d,i) {
                            return {
                                key: d.key,
                                area: d.area,
                                values: d.values.filter(function(d,i) {
                                    return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                                })
                            }
                        })
                );
                focusLinesWrap.transition().duration(transitionDuration).call(lines);


                // Update Main (Focus) Axes
                g.select('.nv-focus .nv-x.nv-axis').transition().duration(transitionDuration)
                    .call(xAxis);
                g.select('.nv-focus .nv-y.nv-axis').transition().duration(transitionDuration)
                    .call(yAxis);
            }
        });

        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    lines.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.legend = legend;
    chart.lines = lines;
    chart.lines2 = lines2;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.x2Axis = x2Axis;
    chart.y2Axis = y2Axis;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        focusHeight:     {get: function(){return height2;}, set: function(_){height2=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        brushExtent: {get: function(){return brushExtent;}, set: function(_){brushExtent=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
            // line color is handled above?
        }},
        interpolate: {get: function(){return lines.interpolate();}, set: function(_){
            lines.interpolate(_);
            lines2.interpolate(_);
        }},
        xTickFormat: {get: function(){return xAxis.xTickFormat();}, set: function(_){
            xAxis.xTickFormat(_);
            x2Axis.xTickFormat(_);
        }},
        yTickFormat: {get: function(){return yAxis.yTickFormat();}, set: function(_){
            yAxis.yTickFormat(_);
            y2Axis.yTickFormat(_);
        }},
        duration:    {get: function(){return transitionDuration;}, set: function(_){
            transitionDuration=_;
            yAxis.duration(transitionDuration);
            xAxis.duration(transitionDuration);
        }},
        x: {get: function(){return lines.x();}, set: function(_){
            lines.x(_);
            lines2.x(_);
        }},
        y: {get: function(){return lines.y();}, set: function(_){
            lines.y(_);
            lines2.y(_);
        }}
    });

    nv.utils.inheritOptions(chart, lines);
    nv.utils.initOptions(chart);

    return chart;
};

nv.models.multiBar = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 960
        , height = 500
        , x = d3.scale.ordinal()
        , y = d3.scale.linear()
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove
        , clipEdge = true
        , stacked = false
        , stackOffset = 'zero' // options include 'silhouette', 'wiggle', 'expand', 'zero', or a custom function
        , color = nv.utils.defaultColor()
        , hideable = false
        , barColor = null // adding the ability to set the color for each rather than the whole group
        , disabled // used in conjunction with barColor to communicate from multiBarHorizontalChart what series are disabled
        , duration = 500
        , xDomain
        , yDomain
        , xRange
        , yRange
        , groupSpacing = 0.1
        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0 //used to store previous scales
        , renderWatch = nv.utils.renderWatch(dispatch, duration)
        ;

    var last_datalength = 0;

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            // This function defines the requirements for render complete
            var endFn = function(d, i) {
                if (d.series === data.length - 1 && i === data[0].values.length - 1)
                    return true;
                return false;
            };

            if(hideable && data.length) hideable = [{
                values: data[0].values.map(function(d) {
                        return {
                            x: d.x,
                            y: 0,
                            series: d.series,
                            size: 0.01
                        };}
                )}];

            if (stacked)
                data = d3.layout.stack()
                    .offset(stackOffset)
                    .values(function(d){ return d.values })
                    .y(getY)
                (!data.length && hideable ? hideable : data);


            //add series index to each data point for reference
            data.forEach(function(series, i) {
                series.values.forEach(function(point) {
                    point.series = i;
                });
            });

            // HACK for negative value stacking
            if (stacked)
                data[0].values.map(function(d,i) {
                    var posBase = 0, negBase = 0;
                    data.map(function(d) {
                        var f = d.values[i]
                        f.size = Math.abs(f.y);
                        if (f.y<0)  {
                            f.y1 = negBase;
                            negBase = negBase - f.size;
                        } else
                        {
                            f.y1 = f.size + posBase;
                            posBase = posBase + f.size;
                        }
                    });
                });

            // Setup Scales
            // remap and flatten the data for use in calculating the scales' domains
            var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate
                data.map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: getX(d,i), y: getY(d,i), y0: d.y0, y1: d.y1 }
                    })
                });

            x.domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))
                .rangeBands(xRange || [0, availableWidth], groupSpacing);

            y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return stacked ? (d.y > 0 ? d.y1 : d.y1 + d.y ) : d.y }).concat(forceY)))
                .range(yRange || [availableHeight, 0]);

            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
            if (x.domain()[0] === x.domain()[1])
                x.domain()[0] ?
                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                    : x.domain([-1,1]);

            if (y.domain()[0] === y.domain()[1])
                y.domain()[0] ?
                    y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
                    : y.domain([-1,1]);

            x0 = x0 || x;
            y0 = y0 || y;

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-multibar').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibar');
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g')

            gEnter.append('g').attr('class', 'nv-groups');
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            defsEnter.append('clipPath')
                .attr('id', 'nv-edge-clip-' + id)
                .append('rect');
            wrap.select('#nv-edge-clip-' + id + ' rect')
                .attr('width', availableWidth)
                .attr('height', availableHeight);

            g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');

            var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                .data(function(d) { return d }, function(d,i) { return i });
            groups.enter().append('g')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6);

            var exitTransition = renderWatch
                .transition(groups.exit().selectAll('rect.nv-bar'), 'multibarExit', Math.min(100, duration))
                .attr('y', function(d) { return (stacked ? y0(d.y0) : y0(0)) || 0 })
                .attr('height', 0)
                .remove();
            if (exitTransition.delay)
                exitTransition.delay(function(d,i) {
                    var delay = i * (duration / (last_datalength + 1)) - i;
                    return delay;
                });
            groups
                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                .classed('hover', function(d) { return d.hover })
                .style('fill', function(d,i){ return color(d, i) })
                .style('stroke', function(d,i){ return color(d, i) });
            groups
                .style('stroke-opacity', 1)
                .style('fill-opacity', 0.75);

            var bars = groups.selectAll('rect.nv-bar')
                .data(function(d) { return (hideable && !data.length) ? hideable.values : d.values });
            bars.exit().remove();

            var barsEnter = bars.enter().append('rect')
                    .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})
                    .attr('x', function(d,i,j) {
                        return stacked ? 0 : (j * x.rangeBand() / data.length )
                    })
                    .attr('y', function(d) { return y0(stacked ? d.y0 : 0) || 0 })
                    .attr('height', 0)
                    .attr('width', x.rangeBand() / (stacked ? 1 : data.length) )
                    .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',0)'; })
                ;
            bars
                .style('fill', function(d,i,j){ return color(d, j, i);  })
                .style('stroke', function(d,i,j){ return color(d, j, i); })
                .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here
                    d3.select(this).classed('hover', true);
                    dispatch.elementMouseover({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                })
                .on('mouseout', function(d,i) {
                    d3.select(this).classed('hover', false);
                    dispatch.elementMouseout({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                })
                .on('click', function(d,i) {
                    dispatch.elementClick({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                })
                .on('dblclick', function(d,i) {
                    dispatch.elementDblClick({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                });
            bars
                .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})
                .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',0)'; })

            if (barColor) {
                if (!disabled) disabled = data.map(function() { return true });
                bars
                    .style('fill', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); })
                    .style('stroke', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); });
            }

            var barSelection =
                bars.watchTransition(renderWatch, 'multibar', Math.min(250, duration))
                    .delay(function(d,i) {
                        return i * duration / data[0].values.length;
                    });
            if (stacked)
                barSelection
                    .attr('y', function(d,i) {
                        return y((stacked ? d.y1 : 0));
                    })
                    .attr('height', function(d,i) {
                        return Math.max(Math.abs(y(d.y + (stacked ? d.y0 : 0)) - y((stacked ? d.y0 : 0))),1);
                    })
                    .attr('x', function(d,i) {
                        return stacked ? 0 : (d.series * x.rangeBand() / data.length )
                    })
                    .attr('width', x.rangeBand() / (stacked ? 1 : data.length) );
            else
                barSelection
                    .attr('x', function(d,i) {
                        return d.series * x.rangeBand() / data.length
                    })
                    .attr('width', x.rangeBand() / data.length)
                    .attr('y', function(d,i) {
                        return getY(d,i) < 0 ?
                            y(0) :
                                y(0) - y(getY(d,i)) < 1 ?
                            y(0) - 1 :
                            y(getY(d,i)) || 0;
                    })
                    .attr('height', function(d,i) {
                        return Math.max(Math.abs(y(getY(d,i)) - y(0)),1) || 0;
                    });

            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();

            // keep track of the last data value length for transition calculations
            if (data[0] && data[0].values) {
                last_datalength = data[0].values.length;
            }

        });

        renderWatch.renderEnd('multibar immediate');

        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:   {get: function(){return width;}, set: function(_){width=_;}},
        height:  {get: function(){return height;}, set: function(_){height=_;}},
        x:       {get: function(){return getX;}, set: function(_){getX=_;}},
        y:       {get: function(){return getY;}, set: function(_){getY=_;}},
        xScale:  {get: function(){return x;}, set: function(_){x=_;}},
        yScale:  {get: function(){return y;}, set: function(_){y=_;}},
        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
        forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},
        stacked: {get: function(){return stacked;}, set: function(_){stacked=_;}},
        stackOffset: {get: function(){return stackOffset;}, set: function(_){stackOffset=_;}},
        clipEdge:    {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
        disabled:    {get: function(){return disabled;}, set: function(_){disabled=_;}},
        id:          {get: function(){return id;}, set: function(_){id=_;}},
        hideable:    {get: function(){return hideable;}, set: function(_){hideable=_;}},
        groupSpacing:{get: function(){return groupSpacing;}, set: function(_){groupSpacing=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        barColor:  {get: function(){return barColor;}, set: function(_){
            barColor = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};

nv.models.multiBarChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var multibar = nv.models.multiBar()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , legend = nv.models.legend()
        , controls = nv.models.legend()
        ;

    var margin = {top: 30, right: 20, bottom: 50, left: 60}
        , width = null
        , height = null
        , color = nv.utils.defaultColor()
        , showControls = true
        , controlLabels = {}
        , showLegend = true
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , reduceXTicks = true // if false a tick will show for every data point
        , staggerLabels = false
        , rotateLabels = 0
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' on ' + x + '</p>'
        }
        , x //can be accessed via chart.xScale()
        , y //can be accessed via chart.yScale()
        , state = nv.utils.state()
        , defaultState = null
        , noData = "No Data Available."
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd')
        , controlWidth = function() { return showControls ? 180 : 0 }
        , duration = 250
        ;

    state.stacked = false // DEPRECATED Maintained for backward compatibility

    multibar
        .stacked(false)
    ;
    xAxis
        .orient('bottom')
        .tickPadding(7)
        .highlightZero(true)
        .showMaxMin(false)
        .tickFormat(function(d) { return d })
    ;
    yAxis
        .orient((rightAlignYAxis) ? 'right' : 'left')
        .tickFormat(d3.format(',.1f'))
    ;

    controls.updateState(false);

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var renderWatch = nv.utils.renderWatch(dispatch);
    var stacked = false;

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled }),
                stacked: stacked
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.stacked !== undefined)
                stacked = state.stacked;
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(multibar);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() {
                if (duration === 0)
                    container.call(chart);
                else
                    container.transition()
                        .duration(duration)
                        .call(chart);
            };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display noData message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = multibar.xScale();
            y = multibar.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-multiBarWithLegend').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarWithLegend').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis');
            gEnter.append('g').attr('class', 'nv-barsWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');
            gEnter.append('g').attr('class', 'nv-controlsWrap');

            // Legend
            if (showLegend) {
                legend.width(availableWidth - controlWidth());

                if (multibar.barColor())
                    data.forEach(function(series,i) {
                        series.color = d3.rgb('#ccc').darker(i * 1.5).toString();
                    });

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');
            }

            // Controls
            if (showControls) {
                var controlsData = [
                    { key: controlLabels.grouped || 'Grouped', disabled: multibar.stacked() },
                    { key: controlLabels.stacked || 'Stacked', disabled: !multibar.stacked() }
                ];

                controls.width(controlWidth()).color(['#444', '#444', '#444']);
                g.select('.nv-controlsWrap')
                    .datum(controlsData)
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
                    .call(controls);
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            // Main Chart Component(s)
            multibar
                .disabled(data.map(function(series) { return series.disabled }))
                .width(availableWidth)
                .height(availableHeight)
                .color(data.map(function(d,i) {
                    return d.color || color(d, i);
                }).filter(function(d,i) { return !data[i].disabled }));


            var barsWrap = g.select('.nv-barsWrap')
                .datum(data.filter(function(d) { return !d.disabled }));

            barsWrap.call(multibar);

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize(-availableHeight, 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y.range()[0] + ')');
                g.select('.nv-x.nv-axis')
                    .call(xAxis);

                var xTicks = g.select('.nv-x.nv-axis > g').selectAll('g');

                xTicks
                    .selectAll('line, text')
                    .style('opacity', 1)

                if (staggerLabels) {
                    var getTranslate = function(x,y) {
                        return "translate(" + x + "," + y + ")";
                    };

                    var staggerUp = 5, staggerDown = 17;  //pixels to stagger by
                    // Issue #140
                    xTicks
                        .selectAll("text")
                        .attr('transform', function(d,i,j) {
                            return  getTranslate(0, (j % 2 == 0 ? staggerUp : staggerDown));
                        });

                    var totalInBetweenTicks = d3.selectAll(".nv-x.nv-axis .nv-wrap g g text")[0].length;
                    g.selectAll(".nv-x.nv-axis .nv-axisMaxMin text")
                        .attr("transform", function(d,i) {
                            return getTranslate(0, (i === 0 || totalInBetweenTicks % 2 !== 0) ? staggerDown : staggerUp);
                        });
                }

                if (reduceXTicks)
                    xTicks
                        .filter(function(d,i) {
                            return i % Math.ceil(data[0].values.length / (availableWidth / 100)) !== 0;
                        })
                        .selectAll('text, line')
                        .style('opacity', 0);

                if(rotateLabels)
                    xTicks
                        .selectAll('.tick text')
                        .attr('transform', 'rotate(' + rotateLabels + ' 0,0)')
                        .style('text-anchor', rotateLabels > 0 ? 'start' : 'end');

                g.select('.nv-x.nv-axis').selectAll('g.nv-axisMaxMin text')
                    .style('opacity', 1);
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis')
                    .call(yAxis);
            }

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            controls.dispatch.on('legendClick', function(d,i) {
                if (!d.disabled) return;
                controlsData = controlsData.map(function(s) {
                    s.disabled = true;
                    return s;
                });
                d.disabled = false;

                switch (d.key) {
                    case 'Grouped':
                        multibar.stacked(false);
                        break;
                    case 'Stacked':
                        multibar.stacked(true);
                        break;
                }

                state.stacked = multibar.stacked();
                dispatch.stateChange(state);

                chart.update();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode)
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                if (typeof e.stacked !== 'undefined') {
                    multibar.stacked(e.stacked);
                    state.stacked = e.stacked;
                    stacked = e.stacked;
                }

                chart.update();
            });
        });

        renderWatch.renderEnd('multibarchart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    multibar.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    multibar.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });
    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.multibar = multibar;
    chart.legend = legend;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.state = state;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        showControls: {get: function(){return showControls;}, set: function(_){showControls=_;}},
        controlLabels: {get: function(){return controlLabels;}, set: function(_){controlLabels=_;}},
        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
        reduceXTicks:    {get: function(){return reduceXTicks;}, set: function(_){reduceXTicks=_;}},
        rotateLabels:    {get: function(){return rotateLabels;}, set: function(_){rotateLabels=_;}},
        staggerLabels:    {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            multibar.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
            renderWatch.reset(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( rightAlignYAxis ? 'right' : 'left');
        }}
    });

    nv.utils.inheritOptions(chart, multibar);
    nv.utils.initOptions(chart);

    return chart;
};

nv.models.multiBarHorizontal = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 960
        , height = 500
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , x = d3.scale.ordinal()
        , y = d3.scale.linear()
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , getYerr = function(d) { return d.yErr }
        , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove
        , color = nv.utils.defaultColor()
        , barColor = null // adding the ability to set the color for each rather than the whole group
        , disabled // used in conjunction with barColor to communicate from multiBarHorizontalChart what series are disabled
        , stacked = false
        , showValues = false
        , showBarLabels = false
        , valuePadding = 60
        , valueFormat = d3.format(',.2f')
        , delay = 1200
        , xDomain
        , yDomain
        , xRange
        , yRange
        , duration = 250
        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout','renderEnd')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0; //used to store previous scales
    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            if (stacked)
                data = d3.layout.stack()
                    .offset('zero')
                    .values(function(d){ return d.values })
                    .y(getY)
                (data);

            //add series index to each data point for reference
            data.forEach(function(series, i) {
                series.values.forEach(function(point) {
                    point.series = i;
                });
            });

            // HACK for negative value stacking
            if (stacked)
                data[0].values.map(function(d,i) {
                    var posBase = 0, negBase = 0;
                    data.map(function(d) {
                        var f = d.values[i]
                        f.size = Math.abs(f.y);
                        if (f.y<0)  {
                            f.y1 = negBase - f.size;
                            negBase = negBase - f.size;
                        } else
                        {
                            f.y1 = posBase;
                            posBase = posBase + f.size;
                        }
                    });
                });

            // Setup Scales
            // remap and flatten the data for use in calculating the scales' domains
            var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate
                data.map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: getX(d,i), y: getY(d,i), y0: d.y0, y1: d.y1 }
                    })
                });

            x.domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))
                .rangeBands(xRange || [0, availableHeight], .1);

            y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return stacked ? (d.y > 0 ? d.y1 + d.y : d.y1 ) : d.y }).concat(forceY)))

            if (showValues && !stacked)
                y.range(yRange || [(y.domain()[0] < 0 ? valuePadding : 0), availableWidth - (y.domain()[1] > 0 ? valuePadding : 0) ]);
            else
                y.range(yRange || [0, availableWidth]);

            x0 = x0 || x;
            y0 = y0 || d3.scale.linear().domain(y.domain()).range([y(0),y(0)]);

            // Setup containers and skeleton of chart
            var wrap = d3.select(this).selectAll('g.nv-wrap.nv-multibarHorizontal').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibarHorizontal');
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-groups');
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                .data(function(d) { return d }, function(d,i) { return i });
            groups.enter().append('g')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6);
            groups.exit().watchTransition(renderWatch, 'multibarhorizontal: exit groups')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6)
                .remove();
            groups
                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                .classed('hover', function(d) { return d.hover })
                .style('fill', function(d,i){ return color(d, i) })
                .style('stroke', function(d,i){ return color(d, i) });
            groups.watchTransition(renderWatch, 'multibarhorizontal: groups')
                .style('stroke-opacity', 1)
                .style('fill-opacity', .75);

            var bars = groups.selectAll('g.nv-bar')
                .data(function(d) { return d.values });
            bars.exit().remove();

            var barsEnter = bars.enter().append('g')
                .attr('transform', function(d,i,j) {
                    return 'translate(' + y0(stacked ? d.y0 : 0) + ',' + (stacked ? 0 : (j * x.rangeBand() / data.length ) + x(getX(d,i))) + ')'
                });

            barsEnter.append('rect')
                .attr('width', 0)
                .attr('height', x.rangeBand() / (stacked ? 1 : data.length) )

            bars
                .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here
                    d3.select(this).classed('hover', true);
                    dispatch.elementMouseover({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [ y(getY(d,i) + (stacked ? d.y0 : 0)), x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length) ],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                })
                .on('mouseout', function(d,i) {
                    d3.select(this).classed('hover', false);
                    dispatch.elementMouseout({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                })
                .on('click', function(d,i) {
                    dispatch.elementClick({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                })
                .on('dblclick', function(d,i) {
                    dispatch.elementDblClick({
                        value: getY(d,i),
                        point: d,
                        series: data[d.series],
                        pos: [x(getX(d,i)) + (x.rangeBand() * (stacked ? data.length / 2 : d.series + .5) / data.length), y(getY(d,i) + (stacked ? d.y0 : 0))],  // TODO: Figure out why the value appears to be shifted
                        pointIndex: i,
                        seriesIndex: d.series,
                        e: d3.event
                    });
                    d3.event.stopPropagation();
                });

            if (getYerr(data[0],0)) {
                barsEnter.append('polyline');

                bars.select('polyline')
                    .attr('fill', 'none')
                    .attr('points', function(d,i) {
                        var xerr = getYerr(d,i)
                            , mid = 0.8 * x.rangeBand() / ((stacked ? 1 : data.length) * 2);
                        xerr = xerr.length ? xerr : [-Math.abs(xerr), Math.abs(xerr)];
                        xerr = xerr.map(function(e) { return y(e) - y(0); });
                        var a = [[xerr[0],-mid], [xerr[0],mid], [xerr[0],0], [xerr[1],0], [xerr[1],-mid], [xerr[1],mid]];
                        return a.map(function (path) { return path.join(',') }).join(' ');
                    })
                    .attr('transform', function(d,i) {
                        var mid = x.rangeBand() / ((stacked ? 1 : data.length) * 2);
                        return 'translate(' + (getY(d,i) < 0 ? 0 : y(getY(d,i)) - y(0)) + ', ' + mid + ')'
                    });
            }

            barsEnter.append('text');

            if (showValues && !stacked) {
                bars.select('text')
                    .attr('text-anchor', function(d,i) { return getY(d,i) < 0 ? 'end' : 'start' })
                    .attr('y', x.rangeBand() / (data.length * 2))
                    .attr('dy', '.32em')
                    .html(function(d,i) {
                        var t = valueFormat(getY(d,i))
                            , yerr = getYerr(d,i);
                        if (yerr === undefined)
                            return t;
                        if (!yerr.length)
                            return t + '&plusmn;' + valueFormat(Math.abs(yerr));
                        return t + '+' + valueFormat(Math.abs(yerr[1])) + '-' + valueFormat(Math.abs(yerr[0]));
                    });
                bars.watchTransition(renderWatch, 'multibarhorizontal: bars')
                    .select('text')
                    .attr('x', function(d,i) { return getY(d,i) < 0 ? -4 : y(getY(d,i)) - y(0) + 4 })
            } else {
                bars.selectAll('text').text('');
            }

            if (showBarLabels && !stacked) {
                barsEnter.append('text').classed('nv-bar-label',true);
                bars.select('text.nv-bar-label')
                    .attr('text-anchor', function(d,i) { return getY(d,i) < 0 ? 'start' : 'end' })
                    .attr('y', x.rangeBand() / (data.length * 2))
                    .attr('dy', '.32em')
                    .text(function(d,i) { return getX(d,i) });
                bars.watchTransition(renderWatch, 'multibarhorizontal: bars')
                    .select('text.nv-bar-label')
                    .attr('x', function(d,i) { return getY(d,i) < 0 ? y(0) - y(getY(d,i)) + 4 : -4 });
            }
            else {
                bars.selectAll('text.nv-bar-label').text('');
            }

            bars
                .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})

            if (barColor) {
                if (!disabled) disabled = data.map(function() { return true });
                bars
                    .style('fill', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); })
                    .style('stroke', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); });
            }

            if (stacked)
                bars.watchTransition(renderWatch, 'multibarhorizontal: bars')
                    .attr('transform', function(d,i) {
                        return 'translate(' + y(d.y1) + ',' + x(getX(d,i)) + ')'
                    })
                    .select('rect')
                    .attr('width', function(d,i) {
                        return Math.abs(y(getY(d,i) + d.y0) - y(d.y0))
                    })
                    .attr('height', x.rangeBand() );
            else
                bars.watchTransition(renderWatch, 'multibarhorizontal: bars')
                    .attr('transform', function(d,i) {
                        //TODO: stacked must be all positive or all negative, not both?
                        return 'translate(' +
                            (getY(d,i) < 0 ? y(getY(d,i)) : y(0))
                            + ',' +
                            (d.series * x.rangeBand() / data.length
                                +
                                x(getX(d,i)) )
                            + ')'
                    })
                    .select('rect')
                    .attr('height', x.rangeBand() / data.length )
                    .attr('width', function(d,i) {
                        return Math.max(Math.abs(y(getY(d,i)) - y(0)),1)
                    });

            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();

        });

        renderWatch.renderEnd('multibarHorizontal immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:   {get: function(){return width;}, set: function(_){width=_;}},
        height:  {get: function(){return height;}, set: function(_){height=_;}},
        x:       {get: function(){return getX;}, set: function(_){getX=_;}},
        y:       {get: function(){return getY;}, set: function(_){getY=_;}},
        yErr:       {get: function(){return getYerr;}, set: function(_){getYerr=_;}},
        xScale:  {get: function(){return x;}, set: function(_){x=_;}},
        yScale:  {get: function(){return y;}, set: function(_){y=_;}},
        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},
        forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},
        stacked: {get: function(){return stacked;}, set: function(_){stacked=_;}},
        showValues: {get: function(){return showValues;}, set: function(_){showValues=_;}},
        // this shows the group name, seems pointless?
        //showBarLabels:    {get: function(){return showBarLabels;}, set: function(_){showBarLabels=_;}},
        disabled:     {get: function(){return disabled;}, set: function(_){disabled=_;}},
        id:           {get: function(){return id;}, set: function(_){id=_;}},
        valueFormat:  {get: function(){return valueFormat;}, set: function(_){valueFormat=_;}},
        valuePadding: {get: function(){return valuePadding;}, set: function(_){valuePadding=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        barColor:  {get: function(){return color;}, set: function(_){
            barColor = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};
nv.models.multiBarHorizontalChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var multibar = nv.models.multiBarHorizontal()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , legend = nv.models.legend().height(30)
        , controls = nv.models.legend().height(30)
        ;

    var margin = {top: 30, right: 20, bottom: 50, left: 60}
        , width = null
        , height = null
        , color = nv.utils.defaultColor()
        , showControls = true
        , controlLabels = {}
        , showLegend = true
        , showXAxis = true
        , showYAxis = true
        , stacked = false
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + ' - ' + x + '</h3>' +
                '<p>' +  y + '</p>'
        }
        , x //can be accessed via chart.xScale()
        , y //can be accessed via chart.yScale()
        , state = nv.utils.state()
        , defaultState = null
        , noData = 'No Data Available.'
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState','renderEnd')
        , controlWidth = function() { return showControls ? 180 : 0 }
        , duration = 250
        ;

    state.stacked = false; // DEPRECATED Maintained for backward compatibility

    multibar
        .stacked(stacked)
    ;
    xAxis
        .orient('left')
        .tickPadding(5)
        .highlightZero(false)
        .showMaxMin(false)
        .tickFormat(function(d) { return d })
    ;
    yAxis
        .orient('bottom')
        .tickFormat(d3.format(',.1f'))
    ;

    controls.updateState(false);

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(multibar.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(multibar.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, e.value < 0 ? 'e' : 'w', null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled }),
                stacked: stacked
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.stacked !== undefined)
                stacked = state.stacked;
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(multibar);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() { container.transition().duration(duration).call(chart) };
            chart.container = this;

            stacked = multibar.stacked();

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = multibar.xScale();
            y = multibar.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-multiBarHorizontalChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarHorizontalChart').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis')
                .append('g').attr('class', 'nv-zeroLine')
                .append('line');
            gEnter.append('g').attr('class', 'nv-barsWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');
            gEnter.append('g').attr('class', 'nv-controlsWrap');

            // Legend
            if (showLegend) {
                legend.width(availableWidth - controlWidth());

                if (multibar.barColor())
                    data.forEach(function(series,i) {
                        series.color = d3.rgb('#ccc').darker(i * 1.5).toString();
                    });

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');
            }

            // Controls
            if (showControls) {
                var controlsData = [
                    { key: controlLabels.grouped || 'Grouped', disabled: multibar.stacked() },
                    { key: controlLabels.stacked || 'Stacked', disabled: !multibar.stacked() }
                ];

                controls.width(controlWidth()).color(['#444', '#444', '#444']);
                g.select('.nv-controlsWrap')
                    .datum(controlsData)
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
                    .call(controls);
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Main Chart Component(s)
            multibar
                .disabled(data.map(function(series) { return series.disabled }))
                .width(availableWidth)
                .height(availableHeight)
                .color(data.map(function(d,i) {
                    return d.color || color(d, i);
                }).filter(function(d,i) { return !data[i].disabled }));

            var barsWrap = g.select('.nv-barsWrap')
                .datum(data.filter(function(d) { return !d.disabled }));

            barsWrap.transition().call(multibar);

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( nv.utils.calcTicksY(availableHeight/24, data) )
                    .tickSize(-availableWidth, 0);

                g.select('.nv-x.nv-axis').call(xAxis);

                var xTicks = g.select('.nv-x.nv-axis').selectAll('g');

                xTicks
                    .selectAll('line, text');
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize( -availableHeight, 0);

                g.select('.nv-y.nv-axis')
                    .attr('transform', 'translate(0,' + availableHeight + ')');
                g.select('.nv-y.nv-axis').call(yAxis);
            }

            // Zero line
            g.select(".nv-zeroLine line")
                .attr("x1", y(0))
                .attr("x2", y(0))
                .attr("y1", 0)
                .attr("y2", -availableHeight)
            ;

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            controls.dispatch.on('legendClick', function(d,i) {
                if (!d.disabled) return;
                controlsData = controlsData.map(function(s) {
                    s.disabled = true;
                    return s;
                });
                d.disabled = false;

                switch (d.key) {
                    case 'Grouped':
                        multibar.stacked(false);
                        break;
                    case 'Stacked':
                        multibar.stacked(true);
                        break;
                }

                state.stacked = multibar.stacked();
                dispatch.stateChange(state);
                stacked = multibar.stacked();

                chart.update();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                if (typeof e.stacked !== 'undefined') {
                    multibar.stacked(e.stacked);
                    state.stacked = e.stacked;
                    stacked = e.stacked;
                }

                chart.update();
            });
        });
        renderWatch.renderEnd('multibar horizontal chart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    multibar.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    multibar.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });
    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.multibar = multibar;
    chart.legend = legend;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.state = state;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        showControls: {get: function(){return showControls;}, set: function(_){showControls=_;}},
        controlLabels: {get: function(){return controlLabels;}, set: function(_){controlLabels=_;}},
        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            multibar.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
        }}
    });

    nv.utils.inheritOptions(chart, multibar);
    nv.utils.initOptions(chart);

    return chart;
};
nv.models.multiChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 30, right: 20, bottom: 50, left: 60},
        color = nv.utils.defaultColor(),
        width = null,
        height = null,
        showLegend = true,
        tooltips = true,
        tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' at ' + x + '</p>'
        },
        x,
        y,
        noData = 'No Data Available.',
        yDomain1,
        yDomain2,
        getX = function(d) { return d.x },
        getY = function(d) { return d.y},
        interpolate = 'monotone'
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x = d3.scale.linear(),
        yScale1 = d3.scale.linear(),
        yScale2 = d3.scale.linear(),

        lines1 = nv.models.line().yScale(yScale1),
        lines2 = nv.models.line().yScale(yScale2),

        bars1 = nv.models.multiBar().stacked(false).yScale(yScale1),
        bars2 = nv.models.multiBar().stacked(false).yScale(yScale2),

        stack1 = nv.models.stackedArea().yScale(yScale1),
        stack2 = nv.models.stackedArea().yScale(yScale2),

        xAxis = nv.models.axis().scale(x).orient('bottom').tickPadding(5),
        yAxis1 = nv.models.axis().scale(yScale1).orient('left'),
        yAxis2 = nv.models.axis().scale(yScale2).orient('right'),

        legend = nv.models.legend().height(30),
        dispatch = d3.dispatch('tooltipShow', 'tooltipHide');

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(lines1.x()(e.point, e.pointIndex)),
            y = ((e.series.yAxis == 2) ? yAxis2 : yAxis1).tickFormat()(lines1.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, undefined, undefined, offsetElement.offsetParent);
    };

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);

            chart.update = function() { container.transition().call(chart); };
            chart.container = this;

            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            var dataLines1 = data.filter(function(d) {return d.type == 'line' && d.yAxis == 1});
            var dataLines2 = data.filter(function(d) {return d.type == 'line' && d.yAxis == 2});
            var dataBars1 =  data.filter(function(d) {return d.type == 'bar'  && d.yAxis == 1});
            var dataBars2 =  data.filter(function(d) {return d.type == 'bar'  && d.yAxis == 2});
            var dataStack1 = data.filter(function(d) {return d.type == 'area' && d.yAxis == 1});
            var dataStack2 = data.filter(function(d) {return d.type == 'area' && d.yAxis == 2});

            // Display noData message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            var series1 = data.filter(function(d) {return !d.disabled && d.yAxis == 1})
                .map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: d.x, y: d.y }
                    })
                });

            var series2 = data.filter(function(d) {return !d.disabled && d.yAxis == 2})
                .map(function(d) {
                    return d.values.map(function(d,i) {
                        return { x: d.x, y: d.y }
                    })
                });

            x   .domain(d3.extent(d3.merge(series1.concat(series2)), function(d) { return d.x } ))
                .range([0, availableWidth]);

            var wrap = container.selectAll('g.wrap.multiChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'wrap nvd3 multiChart').append('g');

            gEnter.append('g').attr('class', 'x axis');
            gEnter.append('g').attr('class', 'y1 axis');
            gEnter.append('g').attr('class', 'y2 axis');
            gEnter.append('g').attr('class', 'lines1Wrap');
            gEnter.append('g').attr('class', 'lines2Wrap');
            gEnter.append('g').attr('class', 'bars1Wrap');
            gEnter.append('g').attr('class', 'bars2Wrap');
            gEnter.append('g').attr('class', 'stack1Wrap');
            gEnter.append('g').attr('class', 'stack2Wrap');
            gEnter.append('g').attr('class', 'legendWrap');

            var g = wrap.select('g');

            var color_array = data.map(function(d,i) {
                return data[i].color || color(d, i);
            });

            if (showLegend) {
                legend.color(color_array);
                legend.width( availableWidth / 2 );

                g.select('.legendWrap')
                    .datum(data.map(function(series) {
                        series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;
                        series.key = series.originalKey + (series.yAxis == 1 ? '' : ' (right axis)');
                        return series;
                    }))
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                g.select('.legendWrap')
                    .attr('transform', 'translate(' + ( availableWidth / 2 ) + ',' + (-margin.top) +')');
            }

            lines1
                .width(availableWidth)
                .height(availableHeight)
                .interpolate(interpolate)
                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'line'}));
            lines2
                .width(availableWidth)
                .height(availableHeight)
                .interpolate(interpolate)
                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'line'}));
            bars1
                .width(availableWidth)
                .height(availableHeight)
                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'bar'}));
            bars2
                .width(availableWidth)
                .height(availableHeight)
                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'bar'}));
            stack1
                .width(availableWidth)
                .height(availableHeight)
                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'area'}));
            stack2
                .width(availableWidth)
                .height(availableHeight)
                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'area'}));

            g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            var lines1Wrap = g.select('.lines1Wrap')
                .datum(
                    dataLines1.filter(function(d){return !d.disabled})
                );
            var bars1Wrap = g.select('.bars1Wrap')
                .datum(
                    dataBars1.filter(function(d){return !d.disabled})
                );
            var stack1Wrap = g.select('.stack1Wrap')
                .datum(
                    dataStack1.filter(function(d){return !d.disabled})
                );

            var lines2Wrap = g.select('.lines2Wrap')
                .datum(
                    dataLines2.filter(function(d){return !d.disabled})
                );
            var bars2Wrap = g.select('.bars2Wrap')
                .datum(
                    dataBars2.filter(function(d){return !d.disabled})
                );
            var stack2Wrap = g.select('.stack2Wrap')
                .datum(
                    dataStack2.filter(function(d){return !d.disabled})
                );

            var extraValue1 = dataStack1.length ? dataStack1.map(function(a){return a.values}).reduce(function(a,b){
                return a.map(function(aVal,i){return {x: aVal.x, y: aVal.y + b[i].y}})
            }).concat([{x:0, y:0}]) : []
            var extraValue2 = dataStack2.length ? dataStack2.map(function(a){return a.values}).reduce(function(a,b){
                return a.map(function(aVal,i){return {x: aVal.x, y: aVal.y + b[i].y}})
            }).concat([{x:0, y:0}]) : []

            yScale1 .domain(yDomain1 || d3.extent(d3.merge(series1).concat(extraValue1), function(d) { return d.y } ))
                .range([0, availableHeight])

            yScale2 .domain(yDomain2 || d3.extent(d3.merge(series2).concat(extraValue2), function(d) { return d.y } ))
                .range([0, availableHeight])

            lines1.yDomain(yScale1.domain())
            bars1.yDomain(yScale1.domain())
            stack1.yDomain(yScale1.domain())

            lines2.yDomain(yScale2.domain())
            bars2.yDomain(yScale2.domain())
            stack2.yDomain(yScale2.domain())

            if(dataStack1.length){d3.transition(stack1Wrap).call(stack1);}
            if(dataStack2.length){d3.transition(stack2Wrap).call(stack2);}

            if(dataBars1.length){d3.transition(bars1Wrap).call(bars1);}
            if(dataBars2.length){d3.transition(bars2Wrap).call(bars2);}

            if(dataLines1.length){d3.transition(lines1Wrap).call(lines1);}
            if(dataLines2.length){d3.transition(lines2Wrap).call(lines2);}

            xAxis
                .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                .tickSize(-availableHeight, 0);

            g.select('.x.axis')
                .attr('transform', 'translate(0,' + availableHeight + ')');
            d3.transition(g.select('.x.axis'))
                .call(xAxis);

            yAxis1
                .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                .tickSize( -availableWidth, 0);


            d3.transition(g.select('.y1.axis'))
                .call(yAxis1);

            yAxis2
                .ticks( nv.utils.calcTicksY(availableHeight/36, data) )
                .tickSize( -availableWidth, 0);

            d3.transition(g.select('.y2.axis'))
                .call(yAxis2);

            g.select('.y1.axis')
                .classed('nv-disabled', series1.length ? false : true)
                .attr('transform', 'translate(' + x.range()[0] + ',0)');

            g.select('.y2.axis')
                .classed('nv-disabled', series2.length ? false : true)
                .attr('transform', 'translate(' + x.range()[1] + ',0)');

            legend.dispatch.on('stateChange', function(newState) {
                chart.update();
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

        });

        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    lines1.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines1.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    lines2.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines2.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    bars1.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    bars1.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    bars2.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    bars2.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    stack1.dispatch.on('tooltipShow', function(e) {
        //disable tooltips when value ~= 0
        //// TODO: consider removing points from voronoi that have 0 value instead of this hack
        if (!Math.round(stack1.y()(e.point) * 100)) {  // 100 will not be good for very small numbers... will have to think about making this valu dynamic, based on data range
            setTimeout(function() { d3.selectAll('.point.hover').classed('hover', false) }, 0);
            return false;
        }

        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top],
            dispatch.tooltipShow(e);
    });

    stack1.dispatch.on('tooltipHide', function(e) {
        dispatch.tooltipHide(e);
    });

    stack2.dispatch.on('tooltipShow', function(e) {
        //disable tooltips when value ~= 0
        //// TODO: consider removing points from voronoi that have 0 value instead of this hack
        if (!Math.round(stack2.y()(e.point) * 100)) {  // 100 will not be good for very small numbers... will have to think about making this valu dynamic, based on data range
            setTimeout(function() { d3.selectAll('.point.hover').classed('hover', false) }, 0);
            return false;
        }

        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top],
            dispatch.tooltipShow(e);
    });

    stack2.dispatch.on('tooltipHide', function(e) {
        dispatch.tooltipHide(e);
    });

    lines1.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines1.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    lines2.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    lines2.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Global getters and setters
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.lines1 = lines1;
    chart.lines2 = lines2;
    chart.bars1 = bars1;
    chart.bars2 = bars2;
    chart.stack1 = stack1;
    chart.stack2 = stack2;
    chart.xAxis = xAxis;
    chart.yAxis1 = yAxis1;
    chart.yAxis2 = yAxis2;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        yDomain1:      {get: function(){return yDomain1;}, set: function(_){yDomain1=_;}},
        yDomain2:    {get: function(){return yDomain2;}, set: function(_){yDomain2=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
        interpolate:    {get: function(){return interpolate;}, set: function(_){interpolate=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        x: {get: function(){return getX;}, set: function(_){
            getX = _;
            lines1.x(_);
            bars1.x(_);
        }},
        y: {get: function(){return getY;}, set: function(_){
            getY = _;
            lines1.y(_);
            bars1.y(_);
        }}
    });

    nv.utils.initOptions(chart);

    return chart;
};


nv.models.ohlcBar = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = null
        , height = null
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , x = d3.scale.linear()
        , y = d3.scale.linear()
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , getOpen = function(d) { return d.open }
        , getClose = function(d) { return d.close }
        , getHigh = function(d) { return d.high }
        , getLow = function(d) { return d.low }
        , forceX = []
        , forceY = []
        , padData     = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart
        , clipEdge = true
        , color = nv.utils.defaultColor()
        , interactive = false
        , xDomain
        , yDomain
        , xRange
        , yRange
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd', 'chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                - margin.left - margin.right;
            var availableHeight = (height || parseInt(container.style('height')) || 400)
                - margin.top - margin.bottom;

            nv.utils.initSVG(container);

            // Setup Scales
            x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX) ));

            if (padData)
                x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
            else
                x.range(xRange || [0, availableWidth]);

            y.domain(yDomain || [
                    d3.min(data[0].values.map(getLow).concat(forceY)),
                    d3.max(data[0].values.map(getHigh).concat(forceY))
                ]
            ).range(yRange || [availableHeight, 0]);

            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
            if (x.domain()[0] === x.domain()[1])
                x.domain()[0] ?
                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                    : x.domain([-1,1]);

            if (y.domain()[0] === y.domain()[1])
                y.domain()[0] ?
                    y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])
                    : y.domain([-1,1]);

            // Setup containers and skeleton of chart
            var wrap = d3.select(this).selectAll('g.nv-wrap.nv-ohlcBar').data([data[0].values]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-ohlcBar');
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-ticks');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            container
                .on('click', function(d,i) {
                    dispatch.chartClick({
                        data: d,
                        index: i,
                        pos: d3.event,
                        id: id
                    });
                });

            defsEnter.append('clipPath')
                .attr('id', 'nv-chart-clip-path-' + id)
                .append('rect');

            wrap.select('#nv-chart-clip-path-' + id + ' rect')
                .attr('width', availableWidth)
                .attr('height', availableHeight);

            g   .attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');

            var ticks = wrap.select('.nv-ticks').selectAll('.nv-tick')
                .data(function(d) { return d });
            ticks.exit().remove();

            var ticksEnter = ticks.enter().append('path')
                .attr('class', function(d,i,j) { return (getOpen(d,i) > getClose(d,i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i })
                .attr('d', function(d,i) {
                    var w = (availableWidth / data[0].values.length) * .9;
                    return 'm0,0l0,'
                        + (y(getOpen(d,i))
                            - y(getHigh(d,i)))
                        + 'l'
                        + (-w/2)
                        + ',0l'
                        + (w/2)
                        + ',0l0,'
                        + (y(getLow(d,i)) - y(getOpen(d,i)))
                        + 'l0,'
                        + (y(getClose(d,i))
                            - y(getLow(d,i)))
                        + 'l'
                        + (w/2)
                        + ',0l'
                        + (-w/2)
                        + ',0z';
                })
                .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',' + y(getHigh(d,i)) + ')'; })
                .attr('fill', function(d,i) { return color[0]; })
                .attr('stroke', function(d,i) { return color[0]; })
                .attr('x', 0 )
                .attr('y', function(d,i) {  return y(Math.max(0, getY(d,i))) })
                .attr('height', function(d,i) { return Math.abs(y(getY(d,i)) - y(0)) });

            // the bar colors are controlled by CSS currently
            ticks.attr('class', function(d,i,j) {
                return (getOpen(d,i) > getClose(d,i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i;
            });

            d3.transition(ticks)
                .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',' + y(getHigh(d,i)) + ')'; })
                .attr('d', function(d,i) {
                    var w = (availableWidth / data[0].values.length) * .9;
                    return 'm0,0l0,'
                        + (y(getOpen(d,i))
                            - y(getHigh(d,i)))
                        + 'l'
                        + (-w/2)
                        + ',0l'
                        + (w/2)
                        + ',0l0,'
                        + (y(getLow(d,i))
                            - y(getOpen(d,i)))
                        + 'l0,'
                        + (y(getClose(d,i))
                            - y(getLow(d,i)))
                        + 'l'
                        + (w/2)
                        + ',0l'
                        + (-w/2)
                        + ',0z';
                });
        });

        return chart;
    }


    //Create methods to allow outside functions to highlight a specific bar.
    chart.highlightPoint = function(pointIndex, isHoverOver) {
        chart.clearHighlights();
        d3.select(".nv-ohlcBar .nv-tick-0-" + pointIndex)
            .classed("hover", isHoverOver)
        ;
    };

    chart.clearHighlights = function() {
        d3.select(".nv-ohlcBar .nv-tick.hover")
            .classed("hover", false)
        ;
    };

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:    {get: function(){return width;}, set: function(_){width=_;}},
        height:   {get: function(){return height;}, set: function(_){height=_;}},
        xScale:   {get: function(){return x;}, set: function(_){x=_;}},
        yScale:   {get: function(){return y;}, set: function(_){y=_;}},
        xDomain:  {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain:  {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:   {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:   {get: function(){return yRange;}, set: function(_){yRange=_;}},
        forceX:   {get: function(){return forceX;}, set: function(_){forceX=_;}},
        forceY:   {get: function(){return forceY;}, set: function(_){forceY=_;}},
        padData:  {get: function(){return padData;}, set: function(_){padData=_;}},
        clipEdge: {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
        id:       {get: function(){return id;}, set: function(_){id=_;}},
        interactive: {get: function(){return interactive;}, set: function(_){interactive=_;}},

        x:     {get: function(){return getX;}, set: function(_){getX=_;}},
        y:     {get: function(){return getY;}, set: function(_){getY=_;}},
        open:  {get: function(){return getOpen();}, set: function(_){getOpen=_;}},
        close: {get: function(){return getClose();}, set: function(_){getClose=_;}},
        high:  {get: function(){return getHigh;}, set: function(_){getHigh=_;}},
        low:   {get: function(){return getLow;}, set: function(_){getLow=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    != undefined ? _.top    : margin.top;
            margin.right  = _.right  != undefined ? _.right  : margin.right;
            margin.bottom = _.bottom != undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   != undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};

// Code adapted from Jason Davies' "Parallel Coordinates"
// http://bl.ocks.org/jasondavies/1341281

nv.models.parallelCoordinates = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 30, right: 10, bottom: 10, left: 10}
        , width = null
        , height = null
        , x = d3.scale.ordinal()
        , y = {}
        , dimensions = []
        , color = nv.utils.defaultColor()
        , filters = []
        , active = []
        , dispatch = d3.dispatch('brush')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                - margin.left - margin.right;
            var availableHeight = (height || parseInt(container.style('height')) || 400)
                - margin.top - margin.bottom;

            nv.utils.initSVG(container);

            active = data; //set all active before first brush call

            //This is a placeholder until this chart is made resizeable
            chart.update = function() { };

            // Setup Scales
            x.rangePoints([0, availableWidth], 1).domain(dimensions);

            // Extract the list of dimensions and create a scale for each.
            dimensions.forEach(function(d) {
                y[d] = d3.scale.linear()
                    .domain(d3.extent(data, function(p) { return +p[d]; }))
                    .range([availableHeight, 0]);

                y[d].brush = d3.svg.brush().y(y[d]).on('brush', brush);

                return d != 'name';
            });

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-parallelCoordinates').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-parallelCoordinates');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-parallelCoordinatesWrap');
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            var line = d3.svg.line(),
                axis = d3.svg.axis().orient('left'),
                background,
                foreground;

            // Add grey background lines for context.
            background = gEnter.append('g')
                .attr('class', 'background')
                .selectAll('path')
                .data(data)
                .enter().append('path')
                .attr('d', path)
            ;

            // Add blue foreground lines for focus.
            foreground = gEnter.append('g')
                .attr('class', 'foreground')
                .selectAll('path')
                .data(data)
                .enter().append('path')
                .attr('d', path)
                .attr('stroke', color)
            ;

            // Add a group element for each dimension.
            var dimension = g.selectAll('.dimension')
                .data(dimensions)
                .enter().append('g')
                .attr('class', 'dimension')
                .attr('transform', function(d) { return 'translate(' + x(d) + ',0)'; });

            // Add an axis and title.
            dimension.append('g')
                .attr('class', 'axis')
                .each(function(d) { d3.select(this).call(axis.scale(y[d])); })
                .append('text')
                .attr('text-anchor', 'middle')
                .attr('y', -9)
                .text(String);

            // Add and store a brush for each axis.
            dimension.append('g')
                .attr('class', 'brush')
                .each(function(d) { d3.select(this).call(y[d].brush); })
                .selectAll('rect')
                .attr('x', -8)
                .attr('width', 16);

            // Returns the path for a given data point.
            function path(d) {
                return line(dimensions.map(function(p) { return [x(p), y[p](d[p])]; }));
            }

            // Handles a brush event, toggling the display of foreground lines.
            function brush() {
                var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
                    extents = actives.map(function(p) { return y[p].brush.extent(); });

                filters = []; //erase current filters
                actives.forEach(function(d,i) {
                    filters[i] = {
                        dimension: d,
                        extent: extents[i]
                    }
                });

                active = []; //erase current active list
                foreground.style('display', function(d) {
                    var isActive = actives.every(function(p, i) {
                        return extents[i][0] <= d[p] && d[p] <= extents[i][1];
                    });
                    if (isActive) active.push(d);
                    return isActive ? null : 'none';
                });

                dispatch.brush({
                    filters: filters,
                    active: active
                });
            }
        });

        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        dimensions: {get: function(){return dimensions;}, set: function(_){dimensions=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
            margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
            margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
            margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};
nv.models.pie = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 500
        , height = 500
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one
        , color = nv.utils.defaultColor()
        , valueFormat = d3.format(',.2f')
        , labelFormat = d3.format('%')
        , showLabels = true
        , pieLabelsOutside = true
        , donutLabelsOutside = false
        , labelType = "key"
        , labelThreshold = .02 //if slice percentage is under this, don't show label
        , donut = false
        , title = false
        , growOnHover = true
        , titleOffset = 0
        , labelSunbeamLayout = false
        , startAngle = false
        , padAngle = false
        , endAngle = false
        , cornerRadius = 0
        , donutRatio = 0.5
        , duration = 250
        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
        ;


    //============================================================
    // chart function
    //------------------------------------------------------------

    var renderWatch = nv.utils.renderWatch(dispatch);

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right
                ,availableHeight = height - margin.top - margin.bottom
                ,radius = Math.min(availableWidth, availableHeight) / 2
                ,arcRadius = radius-(radius / 5)
                ,container = d3.select(this)
                ;
            nv.utils.initSVG(container);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('.nv-wrap.nv-pie').data(data);
            var wrapEnter = wrap.enter().append('g').attr('class','nvd3 nv-wrap nv-pie nv-chart-' + id);
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');
            var g_pie = gEnter.append('g').attr('class', 'nv-pie');
            gEnter.append('g').attr('class', 'nv-pieLabels');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
            g.select('.nv-pie').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');
            g.select('.nv-pieLabels').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');

            //
            container.on('click', function(d,i) {
                dispatch.chartClick({
                    data: d,
                    index: i,
                    pos: d3.event,
                    id: id
                });
            });


            var arc = d3.svg.arc().outerRadius(arcRadius);
            var arcOver = d3.svg.arc().outerRadius(arcRadius + 5);

            if (startAngle) {
                arc.startAngle(startAngle);
                arcOver.startAngle(startAngle);
            }
            if (endAngle) {
                arc.endAngle(endAngle);
                arcOver.endAngle(endAngle);
            }
            if (donut) {
                arc.innerRadius(radius * donutRatio);
                arcOver.innerRadius(radius * donutRatio);
            }

            // Setup the Pie chart and choose the data element
            var pie = d3.layout.pie()
                .sort(null)
                .value(function(d) { return d.disabled ? 0 : getY(d) });

            // padAngle added in d3 3.5
            if (pie.padAngle && padAngle) {
                pie.padAngle(padAngle);
            }

            if (arc.cornerRadius && cornerRadius) {
                arc.cornerRadius(cornerRadius);
                arcOver.cornerRadius(cornerRadius);
            }

            // if title is specified and donut, put it in the middle
            if (donut && title) {
                var title_g = g_pie.append('g').attr('class', 'nv-pie');

                title_g.append("text")
                    .style("text-anchor", "middle")
                    .attr('class', 'nv-pie-title')
                    .text(function (d) {
                        return title;
                    })
                    .attr("dy", "0.35em") // trick to vertically center text
                    .attr('transform', function(d, i) {
                        return 'translate(0, '+ titleOffset + ')';
                    });
            }

            var slices = wrap.select('.nv-pie').selectAll('.nv-slice').data(pie);
            var pieLabels = wrap.select('.nv-pieLabels').selectAll('.nv-label').data(pie);

            slices.exit().remove();
            pieLabels.exit().remove();

            var ae = slices.enter().append('g')
            ae.attr('class', 'nv-slice')
            ae.on('mouseover', function(d,i){
                d3.select(this).classed('hover', true);
                if (growOnHover) {
                    d3.select(this).select("path").transition()
                        .duration(70)
                        .attr("d", arcOver);
                }
                dispatch.elementMouseover({
                    label: getX(d.data),
                    value: getY(d.data),
                    point: d.data,
                    pointIndex: i,
                    pos: [d3.event.pageX, d3.event.pageY],
                    id: id,
                    color: d3.select(this).style("fill")
                });
            });
            ae.on('mouseout', function(d,i){
                d3.select(this).classed('hover', false);
                if (growOnHover) {
                    d3.select(this).select("path").transition()
                        .duration(50)
                        .attr("d", arc);
                }
                dispatch.elementMouseout({
                    label: getX(d.data),
                    value: getY(d.data),
                    point: d.data,
                    index: i,
                    id: id
                });
            });

            slices.attr('fill', function(d,i) { return color(d, i); })
            slices.attr('stroke', function(d,i) { return color(d, i); });

            var paths = ae.append('path').each(function(d) {
                this._current = d;
            });

            paths.on('click', function(d,i) {
                dispatch.elementClick({
                    label: getX(d.data),
                    value: getY(d.data),
                    point: d.data,
                    index: i,
                    pos: d3.event,
                    id: id
                });
                d3.event.stopPropagation();
            });
            paths.on('dblclick', function(d,i) {
                dispatch.elementDblClick({
                    label: getX(d.data),
                    value: getY(d.data),
                    point: d.data,
                    index: i,
                    pos: d3.event,
                    id: id
                });
                d3.event.stopPropagation();
            });
            slices.select('path')
                .transition()
                .attr('d', arc)
                .attrTween('d', arcTween);

            if (showLabels) {
                // This does the normal label
                var labelsArc = d3.svg.arc().innerRadius(0);

                if (pieLabelsOutside){
                    var labelsArc = arc;
                }

                if (donutLabelsOutside) {
                    labelsArc = d3.svg.arc().outerRadius(arc.outerRadius());
                }

                pieLabels.enter().append("g").classed("nv-label",true).each(function(d,i) {
                    var group = d3.select(this);

                    group.attr('transform', function(d) {
                        if (labelSunbeamLayout) {
                            d.outerRadius = arcRadius + 10; // Set Outer Coordinate
                            d.innerRadius = arcRadius + 15; // Set Inner Coordinate
                            var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);
                            if ((d.startAngle+d.endAngle)/2 < Math.PI) {
                                rotateAngle -= 90;
                            } else {
                                rotateAngle += 90;
                            }
                            return 'translate(' + labelsArc.centroid(d) + ') rotate(' + rotateAngle + ')';
                        } else {
                            d.outerRadius = radius + 10; // Set Outer Coordinate
                            d.innerRadius = radius + 15; // Set Inner Coordinate
                            return 'translate(' + labelsArc.centroid(d) + ')'
                        }
                    });

                    group.append('rect')
                        .style('stroke', '#fff')
                        .style('fill', '#fff')
                        .attr("rx", 3)
                        .attr("ry", 3);

                    group.append('text')
                        .style('text-anchor', labelSunbeamLayout ? ((d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end') : 'middle') //center the text on it's origin or begin/end if orthogonal aligned
                        .style('fill', '#000')

                });

                var labelLocationHash = {};
                var avgHeight = 14;
                var avgWidth = 140;
                var createHashKey = function(coordinates) {
                    return Math.floor(coordinates[0]/avgWidth) * avgWidth + ',' + Math.floor(coordinates[1]/avgHeight) * avgHeight;
                };

                pieLabels.watchTransition(renderWatch,'pie labels').attr('transform', function(d) {
                    if (labelSunbeamLayout) {
                        d.outerRadius = arcRadius + 10; // Set Outer Coordinate
                        d.innerRadius = arcRadius + 15; // Set Inner Coordinate
                        var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);
                        if ((d.startAngle+d.endAngle)/2 < Math.PI) {
                            rotateAngle -= 90;
                        } else {
                            rotateAngle += 90;
                        }
                        return 'translate(' + labelsArc.centroid(d) + ') rotate(' + rotateAngle + ')';
                    } else {
                        d.outerRadius = radius + 10; // Set Outer Coordinate
                        d.innerRadius = radius + 15; // Set Inner Coordinate

                        /*
                         Overlapping pie labels are not good. What this attempts to do is, prevent overlapping.
                         Each label location is hashed, and if a hash collision occurs, we assume an overlap.
                         Adjust the label's y-position to remove the overlap.
                         */
                        var center = labelsArc.centroid(d);
                        if(d.value){
                            var hashKey = createHashKey(center);
                            if (labelLocationHash[hashKey]) {
                                center[1] -= avgHeight;
                            }
                            labelLocationHash[createHashKey(center)] = true;
                        }
                        return 'translate(' + center + ')'
                    }
                });

                pieLabels.select(".nv-label text")
                    .style('text-anchor', labelSunbeamLayout ? ((d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end') : 'middle') //center the text on it's origin or begin/end if orthogonal aligned
                    .text(function(d, i) {
                        var percent = (d.endAngle - d.startAngle) / (2 * Math.PI);
                        var labelTypes = {
                            "key" : getX(d.data),
                            "value": getY(d.data),
                            "percent": labelFormat(percent)
                        };
                        return (d.value && percent > labelThreshold) ? labelTypes[labelType] : '';
                    })
                ;
            }


            // Computes the angle of an arc, converting from radians to degrees.
            function angle(d) {
                var a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;
                return a > 90 ? a - 180 : a;
            }

            function arcTween(a) {
                a.endAngle = isNaN(a.endAngle) ? 0 : a.endAngle;
                a.startAngle = isNaN(a.startAngle) ? 0 : a.startAngle;
                if (!donut) a.innerRadius = 0;
                var i = d3.interpolate(this._current, a);
                this._current = i(0);
                return function(t) {
                    return arc(i(t));
                };
            }
        });

        renderWatch.renderEnd('pie immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLabels: {get: function(){return showLabels;}, set: function(_){showLabels=_;}},
        title:      {get: function(){return title;}, set: function(_){title=_;}},
        titleOffset:    {get: function(){return titleOffset;}, set: function(_){titleOffset=_;}},
        labelThreshold: {get: function(){return labelThreshold;}, set: function(_){labelThreshold=_;}},
        labelFormat:    {get: function(){return labelFormat;}, set: function(_){labelFormat=_;}},
        valueFormat:    {get: function(){return valueFormat;}, set: function(_){valueFormat=_;}},
        x:          {get: function(){return getX;}, set: function(_){getX=_;}},
        id:         {get: function(){return id;}, set: function(_){id=_;}},
        endAngle:   {get: function(){return endAngle;}, set: function(_){endAngle=_;}},
        startAngle: {get: function(){return startAngle;}, set: function(_){startAngle=_;}},
        padAngle:   {get: function(){return padAngle;}, set: function(_){padAngle=_;}},
        cornerRadius: {get: function(){return cornerRadius;}, set: function(_){cornerRadius=_;}},
        donutRatio:   {get: function(){return donutRatio;}, set: function(_){donutRatio=_;}},
        pieLabelsOutside:   {get: function(){return pieLabelsOutside;}, set: function(_){pieLabelsOutside=_;}},
        donutLabelsOutside: {get: function(){return donutLabelsOutside;}, set: function(_){donutLabelsOutside=_;}},
        labelSunbeamLayout: {get: function(){return labelSunbeamLayout;}, set: function(_){labelSunbeamLayout=_;}},
        donut:              {get: function(){return donut;}, set: function(_){donut=_;}},
        growOnHover:        {get: function(){return growOnHover;}, set: function(_){growOnHover=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;
            margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;
            margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;
            margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;
        }},
        y: {get: function(){return getY;}, set: function(_){
            getY=d3.functor(_);
        }},
        color: {get: function(){return color;}, set: function(_){
            color=nv.utils.getColor(_);
        }},
        labelType:          {get: function(){return labelType;}, set: function(_){
            labelType= _ || 'key';
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};
nv.models.pieChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var pie = nv.models.pie();
    var legend = nv.models.legend();

    var margin = {top: 30, right: 20, bottom: 20, left: 20}
        , width = null
        , height = null
        , showLegend = true
        , color = nv.utils.defaultColor()
        , tooltips = true
        , tooltip = function(key, y, e, graph) {
            return '<h3 style="background-color: '
                + e.color + '">' + key + '</h3>'
                + '<p>' +  y + '</p>';
        }
        , state = nv.utils.state()
        , defaultState = null
        , noData = "No Data Available."
        , duration = 250
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState','renderEnd')
        ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var showTooltip = function(e, offsetElement) {
        var tooltipLabel = pie.x()(e.point);
        var left = e.pos[0] + ( (offsetElement && offsetElement.offsetLeft) || 0 ),
            top = e.pos[1] + ( (offsetElement && offsetElement.offsetTop) || 0),
            y = pie.valueFormat()(pie.y()(e.point)),
            content = tooltip(tooltipLabel, y, e, chart)
            ;
        nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var renderWatch = nv.utils.renderWatch(dispatch);

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined) {
                data.forEach(function (series, i) {
                    series.disabled = !state.active[i];
                });
            }
        }
    };

    //============================================================
    // Chart function
    //------------------------------------------------------------

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(pie);

        selection.each(function(data) {
            var container = d3.select(this);
            nv.utils.initSVG(container);

            var that = this;
            var availableWidth = (width || parseInt(container.style('width'), 10) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height'), 10) || 400)
                    - margin.top - margin.bottom
                ;

            chart.update = function() { container.transition().call(chart); };
            chart.container = this;

            state.setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            //set state.disabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-pieChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-pieChart').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-pieWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');

            // Legend
            if (showLegend) {
                legend.width( availableWidth ).key(pie.x());

                wrap.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                wrap.select('.nv-legendWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')');
            }
            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Main Chart Component(s)
            pie.width(availableWidth).height(availableHeight);
            var pieWrap = g.select('.nv-pieWrap').datum([data]);
            d3.transition(pieWrap).call(pie);

            // Event Handling/Dispatching (in chart's scope)
            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState) {
                    state[key] = newState[key];
                }
                dispatch.stateChange(state);
                chart.update();
            });

            pie.dispatch.on('elementMouseout.tooltip', function(e) {
                dispatch.tooltipHide(e);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {
                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });
                    state.disabled = e.disabled;
                }
                chart.update();
            });

        });

        renderWatch.renderEnd('pieChart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    pie.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] +  margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    dispatch.on('tooltipShow', function(e) {
        if (tooltips) showTooltip(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.legend = legend;
    chart.dispatch = dispatch;
    chart.pie = pie;
    chart.options = nv.utils.optionsFunc.bind(chart);

    // use Object get/set functionality to map between vars and chart functions
    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        noData:         {get: function(){return noData;},         set: function(_){noData=_;}},
        tooltipContent: {get: function(){return tooltip;},        set: function(_){tooltip=_;}},
        tooltips:       {get: function(){return tooltips;},       set: function(_){tooltips=_;}},
        showLegend:     {get: function(){return showLegend;},     set: function(_){showLegend=_;}},
        defaultState:   {get: function(){return defaultState;},   set: function(_){defaultState=_;}},
        // options that require extra logic in the setter
        color: {get: function(){return color;}, set: function(_){
            color = _;
            legend.color(color);
            pie.color(color);
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }}
    });
    nv.utils.inheritOptions(chart, pie);
    nv.utils.initOptions(chart);
    return chart;
};

nv.models.scatter = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin       = {top: 0, right: 0, bottom: 0, left: 0}
        , width        = null
        , height       = null
        , color        = nv.utils.defaultColor() // chooses color
        , id           = Math.floor(Math.random() * 100000) //Create semi-unique ID incase user doesn't select one
        , x            = d3.scale.linear()
        , y            = d3.scale.linear()
        , z            = d3.scale.linear() //linear because d3.svg.shape.size is treated as area
        , getX         = function(d) { return d.x } // accessor to get the x value
        , getY         = function(d) { return d.y } // accessor to get the y value
        , getSize      = function(d) { return d.size || 1} // accessor to get the point size
        , getShape     = function(d) { return d.shape || 'circle' } // accessor to get point shape
        , forceX       = [] // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)
        , forceY       = [] // List of numbers to Force into the Y scale
        , forceSize    = [] // List of numbers to Force into the Size scale
        , interactive  = true // If true, plots a voronoi overlay for advanced point intersection
        , pointActive  = function(d) { return !d.notActive } // any points that return false will be filtered out
        , padData      = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart
        , padDataOuter = .1 //outerPadding to imitate ordinal scale outer padding
        , clipEdge     = false // if true, masks points within x and y scale
        , clipVoronoi  = true // if true, masks each point with a circle... can turn off to slightly increase performance
        , clipRadius   = function() { return 25 } // function to get the radius for voronoi point clips
        , xDomain      = null // Override x domain (skips the calculation from data)
        , yDomain      = null // Override y domain
        , xRange       = null // Override x range
        , yRange       = null // Override y range
        , sizeDomain   = null // Override point size domain
        , sizeRange    = null
        , singlePoint  = false
        , dispatch     = d3.dispatch('elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd')
        , useVoronoi   = true
        , duration     = 250
        ;


    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0, z0 // used to store previous scales
        , timeoutID
        , needsUpdate = false // Flag for when the points are visually updating, but the interactive layer is behind, to disable tooltips
        , renderWatch = nv.utils.renderWatch(dispatch, duration)
        ;

    function chart(selection) {
        renderWatch.reset();
        selection.each(function(data) {
            var container = d3.select(this);
            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                - margin.left - margin.right;
            var availableHeight = (height || parseInt(container.style('height')) || 400)
                - margin.top - margin.bottom;

            nv.utils.initSVG(container);

            //add series index to each data point for reference
            data.forEach(function(series, i) {
                series.values.forEach(function(point) {
                    point.series = i;
                });
            });

            // Setup Scales
            // remap and flatten the data for use in calculating the scales' domains
            var seriesData = (xDomain && yDomain && sizeDomain) ? [] : // if we know xDomain and yDomain and sizeDomain, no need to calculate.... if Size is constant remember to set sizeDomain to speed up performance
                d3.merge(
                    data.map(function(d) {
                        return d.values.map(function(d,i) {
                            return { x: getX(d,i), y: getY(d,i), size: getSize(d,i) }
                        })
                    })
                );

            x   .domain(xDomain || d3.extent(seriesData.map(function(d) { return d.x; }).concat(forceX)))

            if (padData && data[0])
                x.range(xRange || [(availableWidth * padDataOuter +  availableWidth) / (2 *data[0].values.length), availableWidth - availableWidth * (1 + padDataOuter) / (2 * data[0].values.length)  ]);
            //x.range([availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);
            else
                x.range(xRange || [0, availableWidth]);

            y   .domain(yDomain || d3.extent(seriesData.map(function(d) { return d.y }).concat(forceY)))
                .range(yRange || [availableHeight, 0]);

            z   .domain(sizeDomain || d3.extent(seriesData.map(function(d) { return d.size }).concat(forceSize)))
                .range(sizeRange || [16, 256]);

            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point
            if (x.domain()[0] === x.domain()[1] || y.domain()[0] === y.domain()[1]) singlePoint = true;
            if (x.domain()[0] === x.domain()[1])
                x.domain()[0] ?
                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])
                    : x.domain([-1,1]);

            if (y.domain()[0] === y.domain()[1])
                y.domain()[0] ?
                    y.domain([y.domain()[0] - y.domain()[0] * 0.01, y.domain()[1] + y.domain()[1] * 0.01])
                    : y.domain([-1,1]);

            if ( isNaN(x.domain()[0])) {
                x.domain([-1,1]);
            }

            if ( isNaN(y.domain()[0])) {
                y.domain([-1,1]);
            }

            x0 = x0 || x;
            y0 = y0 || y;
            z0 = z0 || z;

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-scatter').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatter nv-chart-' + id + (singlePoint ? ' nv-single-point' : ''));
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-groups');
            gEnter.append('g').attr('class', 'nv-point-paths');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            defsEnter.append('clipPath')
                .attr('id', 'nv-edge-clip-' + id)
                .append('rect');

            wrap.select('#nv-edge-clip-' + id + ' rect')
                .attr('width', availableWidth)
                .attr('height', (availableHeight > 0) ? availableHeight : 0);

            g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');

            function updateInteractiveLayer() {

                if (!interactive) return false;

                var eventElements;

                var vertices = d3.merge(data.map(function(group, groupIndex) {
                        return group.values
                            .map(function(point, pointIndex) {
                                // *Adding noise to make duplicates very unlikely
                                // *Injecting series and point index for reference
                                /* *Adding a 'jitter' to the points, because there's an issue in d3.geom.voronoi.
                                 */
                                var pX = getX(point,pointIndex);
                                var pY = getY(point,pointIndex);

                                return [x(pX)+ Math.random() * 1e-7,
                                        y(pY)+ Math.random() * 1e-7,
                                    groupIndex,
                                    pointIndex, point]; //temp hack to add noise untill I think of a better way so there are no duplicates
                            })
                            .filter(function(pointArray, pointIndex) {
                                return pointActive(pointArray[4], pointIndex); // Issue #237.. move filter to after map, so pointIndex is correct!
                            })
                    })
                );

                //inject series and point index for reference into voronoi
                if (useVoronoi === true) {

                    if(vertices.length < 3) {
                        // Issue #283 - Adding 2 dummy points to the voronoi b/c voronoi requires min 3 points to work
                        vertices.push([x.range()[0] - 20, y.range()[0] - 20, null, null]);
                        vertices.push([x.range()[1] + 20, y.range()[1] + 20, null, null]);
                        vertices.push([x.range()[0] - 20, y.range()[0] + 20, null, null]);
                        vertices.push([x.range()[1] + 20, y.range()[1] - 20, null, null]);
                    }

                    // keep voronoi sections from going more than 10 outside of graph
                    // to avoid overlap with other things like legend etc
                    var bounds = d3.geom.polygon([
                        [-10,-10],
                        [-10,height + 10],
                        [width + 10,height + 10],
                        [width + 10,-10]
                    ]);

                    var voronoi = d3.geom.voronoi(vertices).map(function(d, i) {
                        return {
                            'data': bounds.clip(d),
                            'series': vertices[i][2],
                            'point': vertices[i][3]
                        }
                    });

                    // nuke all voronoi paths on reload and recreate them
                    wrap.select('.nv-point-paths').selectAll('path').remove();
                    var pointPaths = wrap.select('.nv-point-paths').selectAll('path').data(voronoi);
                    pointPaths
                        .enter().append("svg:path")
                        .attr("d", function(d) {
                            if (!d || !d.data || d.data.length === 0)
                                return 'M 0 0';
                            else
                                return "M" + d.data.join(",") + "Z";
                        })
                        .attr("id", function(d,i) {
                            return "nv-path-"+i; })
                        .attr("clip-path", function(d,i) { return "url(#nv-clip-"+i+")"; })
                        ;
                        // chain these to above to see the voronoi elements (good for debugging)
                        //.style("fill", d3.rgb(230, 230, 230))
                        //.style('fill-opacity', 0.4)
                        //.style('stroke-opacity', 1)
                        //.style("stroke", d3.rgb(200,200,200));

                    if (clipVoronoi) {
                        // voronoi sections are already set to clip,
                        // just create the circles with the IDs they expect
                        var clips = wrap.append("svg:g").attr("id", "nv-point-clips");
                        clips.selectAll("clipPath")
                            .data(vertices)
                            .enter().append("svg:clipPath")
                            .attr("id", function(d, i) { return "nv-clip-"+i;})
                            .append("svg:circle")
                            .attr('cx', function(d) { return d[0]; })
                            .attr('cy', function(d) { return d[1]; })
                            .attr('r', clipRadius);
                    }

                    var mouseEventCallback = function(d,mDispatch) {
                        if (needsUpdate) return 0;
                        var series = data[d.series];
                        if (typeof series === 'undefined') return;
                        var point  = series.values[d.point];

                        mDispatch({
                            point: point,
                            series: series,
                            pos: [x(getX(point, d.point)) + margin.left, y(getY(point, d.point)) + margin.top],
                            seriesIndex: d.series,
                            pointIndex: d.point
                        });
                    };

                    pointPaths
                        .on('click', function(d) {
                            mouseEventCallback(d, dispatch.elementClick);
                        })
                        .on('dblclick', function(d) {
                            mouseEventCallback(d, dispatch.elementDblClick);
                        })
                        .on('mouseover', function(d) {
                            mouseEventCallback(d, dispatch.elementMouseover);
                        })
                        .on('mouseout', function(d, i) {
                            mouseEventCallback(d, dispatch.elementMouseout);
                        });

                } else {
                    /*
                     // bring data in form needed for click handlers
                     var dataWithPoints = vertices.map(function(d, i) {
                     return {
                     'data': d,
                     'series': vertices[i][2],
                     'point': vertices[i][3]
                     }
                     });
                     */

                    // add event handlers to points instead voronoi paths
                    wrap.select('.nv-groups').selectAll('.nv-group')
                        .selectAll('.nv-point')
                        //.data(dataWithPoints)
                        //.style('pointer-events', 'auto') // recativate events, disabled by css
                        .on('click', function(d,i) {
                            //nv.log('test', d, i);
                            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point
                            var series = data[d.series],
                                point  = series.values[i];

                            dispatch.elementClick({
                                point: point,
                                series: series,
                                pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],
                                seriesIndex: d.series,
                                pointIndex: i
                            });
                        })
                        .on('mouseover', function(d,i) {
                            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point
                            var series = data[d.series],
                                point  = series.values[i];

                            dispatch.elementMouseover({
                                point: point,
                                series: series,
                                pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],
                                seriesIndex: d.series,
                                pointIndex: i
                            });
                        })
                        .on('mouseout', function(d,i) {
                            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point
                            var series = data[d.series],
                                point  = series.values[i];

                            dispatch.elementMouseout({
                                point: point,
                                series: series,
                                seriesIndex: d.series,
                                pointIndex: i
                            });
                        });
                }

                needsUpdate = false;
            }

            needsUpdate = true;
            var groups = wrap.select('.nv-groups').selectAll('.nv-group')
                .data(function(d) { return d }, function(d) { return d.key });
            groups.enter().append('g')
                .style('stroke-opacity', 1e-6)
                .style('fill-opacity', 1e-6);
            groups.exit()
                .remove();
            groups
                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })
                .classed('hover', function(d) { return d.hover });
            groups.watchTransition(renderWatch, 'scatter: groups')
                .style('fill', function(d,i) { return color(d, i) })
                .style('stroke', function(d,i) { return color(d, i) })
                .style('stroke-opacity', 1)
                .style('fill-opacity', .5);

            // create the points
            var points = groups.selectAll('path.nv-point')
                .data(function(d) { return d.values });
            points.enter().append('path')
                .style('fill', function (d,i) { return d.color })
                .style('stroke', function (d,i) { return d.color })
                .attr('transform', function(d,i) {
                    return 'translate(' + x0(getX(d,i)) + ',' + y0(getY(d,i)) + ')'
                })
                .attr('d',
                    nv.utils.symbol()
                    .type(getShape)
                    .size(function(d,i) { return z(getSize(d,i)) })
            );
            points.exit().remove();
            groups.exit().selectAll('path.nv-point')
                .watchTransition(renderWatch, 'scatter exit')
                .attr('transform', function(d,i) {
                    return 'translate(' + x(getX(d,i)) + ',' + y(getY(d,i)) + ')'
                })
                .remove();
            points.each(function(d,i) {
                d3.select(this)
                    .classed('nv-point', true)
                    .classed('nv-point-' + i, true)
                    .classed('hover',false)
                ;
            });
            points
                .watchTransition(renderWatch, 'scatter points')
                .attr('transform', function(d,i) {
                    //nv.log(d,i,getX(d,i), x(getX(d,i)));
                    return 'translate(' + x(getX(d,i)) + ',' + y(getY(d,i)) + ')'
                })
                .attr('d',
                    nv.utils.symbol()
                    .type(getShape)
                    .size(function(d,i) { return z(getSize(d,i)) })
            );

            // Delay updating the invisible interactive layer for smoother animation
            clearTimeout(timeoutID); // stop repeat calls to updateInteractiveLayer
            timeoutID = setTimeout(updateInteractiveLayer, 300);
            //updateInteractiveLayer();

            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();
            z0 = z.copy();

        });
        renderWatch.renderEnd('scatter immediate');
        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    // utility function calls provided by this chart
    chart._calls = new function() {
        this.clearHighlights = function () {
            d3.selectAll(".nv-chart-" + id + " .nv-point.hover").classed("hover", false);
            return null;
        };
        this.highlightPoint = function (seriesIndex, pointIndex, isHoverOver) {
            d3.select(".nv-chart-" + id + " .nv-series-" + seriesIndex + " .nv-point-" + pointIndex)
                .classed("hover", isHoverOver);
        };
    };

    // trigger calls from events too
    dispatch.on('elementMouseover.point', function(d) {
        if (interactive) chart._calls.highlightPoint(d.seriesIndex,d.pointIndex,true);
    });

    dispatch.on('elementMouseout.point', function(d) {
        if (interactive) chart._calls.highlightPoint(d.seriesIndex,d.pointIndex,false);
    });

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:        {get: function(){return width;}, set: function(_){width=_;}},
        height:       {get: function(){return height;}, set: function(_){height=_;}},
        xScale:       {get: function(){return x;}, set: function(_){x=_;}},
        yScale:       {get: function(){return y;}, set: function(_){y=_;}},
        pointScale:   {get: function(){return z;}, set: function(_){z=_;}},
        xDomain:      {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain:      {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        pointDomain:  {get: function(){return sizeDomain;}, set: function(_){sizeDomain=_;}},
        xRange:       {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:       {get: function(){return yRange;}, set: function(_){yRange=_;}},
        pointRange:   {get: function(){return sizeRange;}, set: function(_){sizeRange=_;}},
        forceX:       {get: function(){return forceX;}, set: function(_){forceX=_;}},
        forceY:       {get: function(){return forceY;}, set: function(_){forceY=_;}},
        forcePoint:   {get: function(){return forceSize;}, set: function(_){forceSize=_;}},
        interactive:  {get: function(){return interactive;}, set: function(_){interactive=_;}},
        pointActive:  {get: function(){return pointActive;}, set: function(_){pointActive=_;}},
        padDataOuter: {get: function(){return padDataOuter;}, set: function(_){padDataOuter=_;}},
        padData:      {get: function(){return padData;}, set: function(_){padData=_;}},
        clipEdge:     {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
        clipVoronoi:  {get: function(){return clipVoronoi;}, set: function(_){clipVoronoi=_;}},
        clipRadius:   {get: function(){return clipRadius;}, set: function(_){clipRadius=_;}},
        id:           {get: function(){return id;}, set: function(_){id=_;}},


        // simple functor options
        x:     {get: function(){return getX;}, set: function(_){getX = d3.functor(_);}},
        y:     {get: function(){return getY;}, set: function(_){getY = d3.functor(_);}},
        pointSize: {get: function(){return getSize;}, set: function(_){getSize = d3.functor(_);}},
        pointShape: {get: function(){return getShape;}, set: function(_){getShape = d3.functor(_);}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
        }},
        color: {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        useVoronoi: {get: function(){return useVoronoi;}, set: function(_){
            useVoronoi = _;
            if (useVoronoi === false) {
                clipVoronoi = false;
            }
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};

nv.models.scatterChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var scatter      = nv.models.scatter()
        , xAxis        = nv.models.axis()
        , yAxis        = nv.models.axis()
        , legend       = nv.models.legend()
        , distX        = nv.models.distribution()
        , distY        = nv.models.distribution()
        ;

    var margin       = {top: 30, right: 20, bottom: 50, left: 75}
        , width        = null
        , height       = null
        , color        = nv.utils.defaultColor()
        , x            = scatter.xScale()
        , y            = scatter.yScale()
        , showDistX    = false
        , showDistY    = false
        , showLegend   = true
        , showXAxis    = true
        , showYAxis    = true
        , rightAlignYAxis = false
        , tooltips     = true
        , tooltipX     = function(key, x, y) { return '<strong>' + x + '</strong>' }
        , tooltipY     = function(key, x, y) { return '<strong>' + y + '</strong>' }
        , tooltip      = function(key, x, y, date) { return '<h3>' + key + '</h3>'
            + '<p>' + date + '</p>' }
        , state = nv.utils.state()
        , defaultState = null
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd')
        , noData       = "No Data Available."
        , duration = 250
        ;

    scatter
        .xScale(x)
        .yScale(y)
    ;
    xAxis
        .orient('bottom')
        .tickPadding(10)
    ;
    yAxis
        .orient((rightAlignYAxis) ? 'right' : 'left')
        .tickPadding(10)
    ;
    distX
        .axis('x')
    ;
    distY
        .axis('y')
    ;

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var x0, y0
        , renderWatch = nv.utils.renderWatch(dispatch, duration);

    var showTooltip = function(e, offsetElement) {
        //TODO: make tooltip style an option between single or dual on axes (maybe on all charts with axes?
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            leftX = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            topX = y.range()[0] + margin.top + ( offsetElement.offsetTop || 0),
            leftY = x.range()[0] + margin.left + ( offsetElement.offsetLeft || 0 ),
            topY = e.pos[1] + ( offsetElement.offsetTop || 0),
            xVal = xAxis.tickFormat()(scatter.x()(e.point, e.pointIndex)),
            yVal = yAxis.tickFormat()(scatter.y()(e.point, e.pointIndex));

        if( tooltipX != null )
            nv.tooltip.show([leftX, topX], tooltipX(e.series.key, xVal, yVal, e, chart), 'n', 1, offsetElement, 'x-nvtooltip');
        if( tooltipY != null )
            nv.tooltip.show([leftY, topY], tooltipY(e.series.key, xVal, yVal, e, chart), 'e', 1, offsetElement, 'y-nvtooltip');
        if( tooltip != null )
            nv.tooltip.show([left, top], tooltip(e.series.key, xVal, yVal, e.point.tooltip, e, chart), e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(scatter);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);
        if (showDistX) renderWatch.models(distX);
        if (showDistY) renderWatch.models(distY);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);

            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() {
                if (duration === 0)
                    container.call(chart);
                else
                    container.transition().duration(duration).call(chart);
            };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display noData message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                renderWatch.renderEnd('scatter immediate');

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = scatter.xScale();
            y = scatter.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-scatterChart').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatterChart nv-chart-' + scatter.id());
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            // background for pointer events
            gEnter.append('rect').attr('class', 'nvd3 nv-background').style("pointer-events","none");

            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis');
            gEnter.append('g').attr('class', 'nv-scatterWrap');
            gEnter.append('g').attr('class', 'nv-regressionLinesWrap');
            gEnter.append('g').attr('class', 'nv-distWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            // Legend
            if (showLegend) {
                legend.width( availableWidth / 2 );

                wrap.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                wrap.select('.nv-legendWrap')
                    .attr('transform', 'translate(' + (availableWidth / 2) + ',' + (-margin.top) +')');
            }

            // Main Chart Component(s)
            scatter
                .width(availableWidth)
                .height(availableHeight)
                .color(data.map(function(d,i) {
                    return d.color || color(d, i);
                }).filter(function(d,i) { return !data[i].disabled }));

            wrap.select('.nv-scatterWrap')
                .datum(data.filter(function(d) { return !d.disabled }))
                .call(scatter);


            wrap.select('.nv-regressionLinesWrap')
                .attr('clip-path', 'url(#nv-edge-clip-' + scatter.id() + ')');

            var regWrap = wrap.select('.nv-regressionLinesWrap').selectAll('.nv-regLines')
                .data(function (d) {
                    return d;
                });

            regWrap.enter().append('g').attr('class', 'nv-regLines');

            var regLine = regWrap.selectAll('.nv-regLine')
                .data(function (d) {
                    return [d]
                });

            regLine.enter()
                .append('line').attr('class', 'nv-regLine')
                .style('stroke-opacity', 0);

            // don't add lines unless we have slope and intercept to use
            regLine.filter(function(d) {
                return d.intercept && d.slope;
            })
                .watchTransition(renderWatch, 'scatterPlusLineChart: regline')
                .attr('x1', x.range()[0])
                .attr('x2', x.range()[1])
                .attr('y1', function (d, i) {
                    return y(x.domain()[0] * d.slope + d.intercept)
                })
                .attr('y2', function (d, i) {
                    return y(x.domain()[1] * d.slope + d.intercept)
                })
                .style('stroke', function (d, i, j) {
                    return color(d, j)
                })
                .style('stroke-opacity', function (d, i) {
                    return (d.disabled || typeof d.slope === 'undefined' || typeof d.intercept === 'undefined') ? 0 : 1
                });

            // Setup Axes
            if (showXAxis) {
                xAxis
                    .scale(x)
                    .ticks( xAxis.ticks() ? xAxis.ticks() : nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize( -availableHeight , 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + y.range()[0] + ')')
                    .call(xAxis);
            }

            if (showYAxis) {
                yAxis
                    .scale(y)
                    .ticks( yAxis.ticks() ? yAxis.ticks() : nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize( -availableWidth, 0);

                g.select('.nv-y.nv-axis')
                    .call(yAxis);
            }


            if (showDistX) {
                distX
                    .getData(scatter.x())
                    .scale(x)
                    .width(availableWidth)
                    .color(data.map(function(d,i) {
                        return d.color || color(d, i);
                    }).filter(function(d,i) { return !data[i].disabled }));
                gEnter.select('.nv-distWrap').append('g')
                    .attr('class', 'nv-distributionX');
                g.select('.nv-distributionX')
                    .attr('transform', 'translate(0,' + y.range()[0] + ')')
                    .datum(data.filter(function(d) { return !d.disabled }))
                    .call(distX);
            }

            if (showDistY) {
                distY
                    .getData(scatter.y())
                    .scale(y)
                    .width(availableHeight)
                    .color(data.map(function(d,i) {
                        return d.color || color(d, i);
                    }).filter(function(d,i) { return !data[i].disabled }));
                gEnter.select('.nv-distWrap').append('g')
                    .attr('class', 'nv-distributionY');
                g.select('.nv-distributionY')
                    .attr('transform', 'translate(' + (rightAlignYAxis ? availableWidth : -distY.size() ) + ',0)')
                    .datum(data.filter(function(d) { return !d.disabled }))
                    .call(distY);
            }

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });


            scatter.dispatch.on('elementMouseover.tooltip', function(e) {
                d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-distx-' + e.pointIndex)
                    .attr('y1', e.pos[1] - availableHeight);
                d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-disty-' + e.pointIndex)
                    .attr('x2', e.pos[0] + distX.size());

                e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];
                dispatch.tooltipShow(e);
            });

            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                chart.update();
            });

            //store old scales for use in transitions on update
            x0 = x.copy();
            y0 = y.copy();

        });

        renderWatch.renderEnd('scatter with line immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    scatter.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);

        d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-distx-' + e.pointIndex)
            .attr('y1', 0);
        d3.select('.nv-chart-' + scatter.id() + ' .nv-series-' + e.seriesIndex + ' .nv-disty-' + e.pointIndex)
            .attr('x2', distY.size());
    });
    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.scatter = scatter;
    chart.legend = legend;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.distX = distX;
    chart.distY = distY;

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showDistX:  {get: function(){return showDistX;}, set: function(_){showDistX=_;}},
        showDistY:  {get: function(){return showDistY;}, set: function(_){showDistY=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        showXAxis:  {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis:  {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:   {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:   {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        tooltipXContent:  {get: function(){return tooltipX;}, set: function(_){tooltipX=_;}},
        tooltipYContent:  {get: function(){return tooltipY;}, set: function(_){tooltipY=_;}},
        defaultState:     {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:     {get: function(){return noData;}, set: function(_){noData=_;}},
        duration:   {get: function(){return duration;}, set: function(_){duration=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( (_) ? 'right' : 'left');
        }},
        color: {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
            distX.color(color);
            distY.color(color);
        }}
    });

    nv.utils.inheritOptions(chart, scatter);
    nv.utils.initOptions(chart);
    return chart;
};

nv.models.sparkline = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 2, right: 0, bottom: 2, left: 0}
        , width = 400
        , height = 32
        , animate = true
        , x = d3.scale.linear()
        , y = d3.scale.linear()
        , getX = function(d) { return d.x }
        , getY = function(d) { return d.y }
        , color = nv.utils.getColor(['#000'])
        , xDomain
        , yDomain
        , xRange
        , yRange
        ;

    function chart(selection) {
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            // Setup Scales
            x   .domain(xDomain || d3.extent(data, getX ))
                .range(xRange || [0, availableWidth]);

            y   .domain(yDomain || d3.extent(data, getY ))
                .range(yRange || [availableHeight, 0]);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-sparkline').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparkline');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

            var paths = wrap.selectAll('path')
                .data(function(d) { return [d] });
            paths.enter().append('path');
            paths.exit().remove();
            paths
                .style('stroke', function(d,i) { return d.color || color(d, i) })
                .attr('d', d3.svg.line()
                    .x(function(d,i) { return x(getX(d,i)) })
                    .y(function(d,i) { return y(getY(d,i)) })
            );

            // TODO: Add CURRENT data point (Need Min, Mac, Current / Most recent)
            var points = wrap.selectAll('circle.nv-point')
                .data(function(data) {
                    var yValues = data.map(function(d, i) { return getY(d,i); });
                    function pointIndex(index) {
                        if (index != -1) {
                            var result = data[index];
                            result.pointIndex = index;
                            return result;
                        } else {
                            return null;
                        }
                    }
                    var maxPoint = pointIndex(yValues.lastIndexOf(y.domain()[1])),
                        minPoint = pointIndex(yValues.indexOf(y.domain()[0])),
                        currentPoint = pointIndex(yValues.length - 1);
                    return [minPoint, maxPoint, currentPoint].filter(function (d) {return d != null;});
                });
            points.enter().append('circle');
            points.exit().remove();
            points
                .attr('cx', function(d,i) { return x(getX(d,d.pointIndex)) })
                .attr('cy', function(d,i) { return y(getY(d,d.pointIndex)) })
                .attr('r', 2)
                .attr('class', function(d,i) {
                    return getX(d, d.pointIndex) == x.domain()[1] ? 'nv-point nv-currentValue' :
                            getY(d, d.pointIndex) == y.domain()[0] ? 'nv-point nv-minValue' : 'nv-point nv-maxValue'
                });
        });

        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:     {get: function(){return width;}, set: function(_){width=_;}},
        height:    {get: function(){return height;}, set: function(_){height=_;}},
        xDomain:   {get: function(){return xDomain;}, set: function(_){xDomain=_;}},
        yDomain:   {get: function(){return yDomain;}, set: function(_){yDomain=_;}},
        xRange:    {get: function(){return xRange;}, set: function(_){xRange=_;}},
        yRange:    {get: function(){return yRange;}, set: function(_){yRange=_;}},
        xScale:    {get: function(){return x;}, set: function(_){x=_;}},
        yScale:    {get: function(){return y;}, set: function(_){y=_;}},
        animate:   {get: function(){return animate;}, set: function(_){animate=_;}},

        //functor options
        x: {get: function(){return getX;}, set: function(_){getX=d3.functor(_);}},
        y: {get: function(){return getY;}, set: function(_){getY=d3.functor(_);}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }}
    });

    nv.utils.initOptions(chart);
    return chart;
};

nv.models.sparklinePlus = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var sparkline = nv.models.sparkline();

    var margin = {top: 15, right: 100, bottom: 10, left: 50}
        , width = null
        , height = null
        , x
        , y
        , index = []
        , paused = false
        , xTickFormat = d3.format(',r')
        , yTickFormat = d3.format(',.2f')
        , showValue = true
        , alignValue = true
        , rightAlignValue = false
        , noData = "No Data Available."
        ;

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this);
            nv.utils.initSVG(container);

            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() { chart(selection) };
            chart.container = this;

            // Display No Data message if there's nothing to show.
            if (!data || !data.length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            var currentValue = sparkline.y()(data[data.length-1], data.length-1);

            // Setup Scales
            x = sparkline.xScale();
            y = sparkline.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-sparklineplus').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparklineplus');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-sparklineWrap');
            gEnter.append('g').attr('class', 'nv-valueWrap');
            gEnter.append('g').attr('class', 'nv-hoverArea');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            // Main Chart Component(s)
            var sparklineWrap = g.select('.nv-sparklineWrap');

            sparkline.width(availableWidth).height(availableHeight);
            sparklineWrap.call(sparkline);

            var valueWrap = g.select('.nv-valueWrap');
            var value = valueWrap.selectAll('.nv-currentValue')
                .data([currentValue]);

            value.enter().append('text').attr('class', 'nv-currentValue')
                .attr('dx', rightAlignValue ? -8 : 8)
                .attr('dy', '.9em')
                .style('text-anchor', rightAlignValue ? 'end' : 'start');

            value
                .attr('x', availableWidth + (rightAlignValue ? margin.right : 0))
                .attr('y', alignValue ? function(d) { return y(d) } : 0)
                .style('fill', sparkline.color()(data[data.length-1], data.length-1))
                .text(yTickFormat(currentValue));

            gEnter.select('.nv-hoverArea').append('rect')
                .on('mousemove', sparklineHover)
                .on('click', function() { paused = !paused })
                .on('mouseout', function() { index = []; updateValueLine(); });

            g.select('.nv-hoverArea rect')
                .attr('transform', function(d) { return 'translate(' + -margin.left + ',' + -margin.top + ')' })
                .attr('width', availableWidth + margin.left + margin.right)
                .attr('height', availableHeight + margin.top);

            //index is currently global (within the chart), may or may not keep it that way
            function updateValueLine() {
                if (paused) return;

                var hoverValue = g.selectAll('.nv-hoverValue').data(index)

                var hoverEnter = hoverValue.enter()
                    .append('g').attr('class', 'nv-hoverValue')
                    .style('stroke-opacity', 0)
                    .style('fill-opacity', 0);

                hoverValue.exit()
                    .transition().duration(250)
                    .style('stroke-opacity', 0)
                    .style('fill-opacity', 0)
                    .remove();

                hoverValue
                    .attr('transform', function(d) { return 'translate(' + x(sparkline.x()(data[d],d)) + ',0)' })
                    .transition().duration(250)
                    .style('stroke-opacity', 1)
                    .style('fill-opacity', 1);

                if (!index.length) return;

                hoverEnter.append('line')
                    .attr('x1', 0)
                    .attr('y1', -margin.top)
                    .attr('x2', 0)
                    .attr('y2', availableHeight);

                hoverEnter.append('text').attr('class', 'nv-xValue')
                    .attr('x', -6)
                    .attr('y', -margin.top)
                    .attr('text-anchor', 'end')
                    .attr('dy', '.9em')

                g.select('.nv-hoverValue .nv-xValue')
                    .text(xTickFormat(sparkline.x()(data[index[0]], index[0])));

                hoverEnter.append('text').attr('class', 'nv-yValue')
                    .attr('x', 6)
                    .attr('y', -margin.top)
                    .attr('text-anchor', 'start')
                    .attr('dy', '.9em')

                g.select('.nv-hoverValue .nv-yValue')
                    .text(yTickFormat(sparkline.y()(data[index[0]], index[0])));
            }

            function sparklineHover() {
                if (paused) return;

                var pos = d3.mouse(this)[0] - margin.left;

                function getClosestIndex(data, x) {
                    var distance = Math.abs(sparkline.x()(data[0], 0) - x);
                    var closestIndex = 0;
                    for (var i = 0; i < data.length; i++){
                        if (Math.abs(sparkline.x()(data[i], i) - x) < distance) {
                            distance = Math.abs(sparkline.x()(data[i], i) - x);
                            closestIndex = i;
                        }
                    }
                    return closestIndex;
                }

                index = [getClosestIndex(data, Math.round(x.invert(pos)))];
                updateValueLine();
            }

        });

        return chart;
    }

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.sparkline = sparkline;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:           {get: function(){return width;}, set: function(_){width=_;}},
        height:          {get: function(){return height;}, set: function(_){height=_;}},
        xTickFormat:     {get: function(){return xTickFormat;}, set: function(_){xTickFormat=_;}},
        yTickFormat:     {get: function(){return yTickFormat;}, set: function(_){yTickFormat=_;}},
        showValue:       {get: function(){return showValue;}, set: function(_){showValue=_;}},
        alignValue:      {get: function(){return alignValue;}, set: function(_){alignValue=_;}},
        rightAlignValue: {get: function(){return rightAlignValue;}, set: function(_){rightAlignValue=_;}},
        noData:          {get: function(){return noData;}, set: function(_){noData=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }}
    });

    nv.utils.inheritOptions(chart, sparkline);
    nv.utils.initOptions(chart);

    return chart;
};

nv.models.stackedArea = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var margin = {top: 0, right: 0, bottom: 0, left: 0}
        , width = 960
        , height = 500
        , color = nv.utils.defaultColor() // a function that computes the color
        , id = Math.floor(Math.random() * 100000) //Create semi-unique ID incase user doesn't selet one
        , getX = function(d) { return d.x } // accessor to get the x value from a data point
        , getY = function(d) { return d.y } // accessor to get the y value from a data point
        , style = 'stack'
        , offset = 'zero'
        , order = 'default'
        , interpolate = 'linear'  // controls the line interpolation
        , clipEdge = false // if true, masks lines within x and y scale
        , x //can be accessed via chart.xScale()
        , y //can be accessed via chart.yScale()
        , scatter = nv.models.scatter()
        , duration = 250
        , dispatch =  d3.dispatch('tooltipShow', 'tooltipHide', 'areaClick', 'areaMouseover', 'areaMouseout','renderEnd')
        ;

    // scatter is interactive by default, but this chart isn't so must disable
    scatter.interactive(false);

    scatter
        .pointSize(2.2) // default size
        .pointDomain([2.2, 2.2]) // all the same size by default
    ;

    /************************************
     * offset:
     *   'wiggle' (stream)
     *   'zero' (stacked)
     *   'expand' (normalize to 100%)
     *   'silhouette' (simple centered)
     *
     * order:
     *   'inside-out' (stream)
     *   'default' (input order)
     ************************************/

    var renderWatch = nv.utils.renderWatch(dispatch, duration);

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(scatter);
        selection.each(function(data) {
            var availableWidth = width - margin.left - margin.right,
                availableHeight = height - margin.top - margin.bottom,
                container = d3.select(this);
            nv.utils.initSVG(container);

            // Setup Scales
            x = scatter.xScale();
            y = scatter.yScale();

            var dataRaw = data;
            // Injecting point index into each point because d3.layout.stack().out does not give index
            data.forEach(function(aseries, i) {
                aseries.seriesIndex = i;
                aseries.values = aseries.values.map(function(d, j) {
                    d.index = j;
                    d.seriesIndex = i;
                    return d;
                });
            });

            var dataFiltered = data.filter(function(series) {
                return !series.disabled;
            });

            data = d3.layout.stack()
                .order(order)
                .offset(offset)
                .values(function(d) { return d.values })  //TODO: make values customizeable in EVERY model in this fashion
                .x(getX)
                .y(getY)
                .out(function(d, y0, y) {
                    var yHeight = (getY(d) === 0) ? 0 : y;
                    d.display = {
                        y: yHeight,
                        y0: y0
                    };
                })
            (dataFiltered);

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-stackedarea').data([data]);
            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedarea');
            var defsEnter = wrapEnter.append('defs');
            var gEnter = wrapEnter.append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-areaWrap');
            gEnter.append('g').attr('class', 'nv-scatterWrap');

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            scatter
                .width(availableWidth)
                .height(availableHeight)
                .x(getX)
                .y(function(d) { return d.display.y + d.display.y0 })
                .forceY([0])
                .color(data.map(function(d,i) {
                    return d.color || color(d, d.seriesIndex);
                }));

            var scatterWrap = g.select('.nv-scatterWrap')
                .datum(data);

            scatterWrap.call(scatter);

            defsEnter.append('clipPath')
                .attr('id', 'nv-edge-clip-' + id)
                .append('rect');

            wrap.select('#nv-edge-clip-' + id + ' rect')
                .attr('width', availableWidth)
                .attr('height', availableHeight);

            g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');

            var area = d3.svg.area()
                .x(function(d,i)  { return x(getX(d,i)) })
                .y0(function(d) {
                    return y(d.display.y0)
                })
                .y1(function(d) {
                    return y(d.display.y + d.display.y0)
                })
                .interpolate(interpolate);

            var zeroArea = d3.svg.area()
                .x(function(d,i)  { return x(getX(d,i)) })
                .y0(function(d) { return y(d.display.y0) })
                .y1(function(d) { return y(d.display.y0) });

            var path = g.select('.nv-areaWrap').selectAll('path.nv-area')
                .data(function(d) { return d });

            path.enter().append('path').attr('class', function(d,i) { return 'nv-area nv-area-' + i })
                .attr('d', function(d,i){
                    return zeroArea(d.values, d.seriesIndex);
                })
                .on('mouseover', function(d,i) {
                    d3.select(this).classed('hover', true);
                    dispatch.areaMouseover({
                        point: d,
                        series: d.key,
                        pos: [d3.event.pageX, d3.event.pageY],
                        seriesIndex: d.seriesIndex
                    });
                })
                .on('mouseout', function(d,i) {
                    d3.select(this).classed('hover', false);
                    dispatch.areaMouseout({
                        point: d,
                        series: d.key,
                        pos: [d3.event.pageX, d3.event.pageY],
                        seriesIndex: d.seriesIndex
                    });
                })
                .on('click', function(d,i) {
                    d3.select(this).classed('hover', false);
                    dispatch.areaClick({
                        point: d,
                        series: d.key,
                        pos: [d3.event.pageX, d3.event.pageY],
                        seriesIndex: d.seriesIndex
                    });
                });

            path.exit().remove();
            path.style('fill', function(d,i){
                    return d.color || color(d, d.seriesIndex)
                })
                .style('stroke', function(d,i){ return d.color || color(d, d.seriesIndex) });
            path.watchTransition(renderWatch,'stackedArea path')
                .attr('d', function(d,i) {
                    return area(d.values,i)
                });

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            scatter.dispatch.on('elementMouseover.area', function(e) {
                g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', true);
            });
            scatter.dispatch.on('elementMouseout.area', function(e) {
                g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', false);
            });

            //Special offset functions
            chart.d3_stackedOffset_stackPercent = function(stackData) {
                var n = stackData.length,    //How many series
                    m = stackData[0].length,     //how many points per series
                    k = 1 / n,
                    i,
                    j,
                    o,
                    y0 = [];

                for (j = 0; j < m; ++j) { //Looping through all points
                    for (i = 0, o = 0; i < dataRaw.length; i++) { //looping through series'
                        o += getY(dataRaw[i].values[j]);   //total value of all points at a certian point in time.
                    }

                    if (o) for (i = 0; i < n; i++) {
                        stackData[i][j][1] /= o;
                    } else {
                        for (i = 0; i < n; i++) {
                            stackData[i][j][1] = k;
                        }
                    }
                }
                for (j = 0; j < m; ++j) y0[j] = 0;
                return y0;
            };

        });

        renderWatch.renderEnd('stackedArea immediate');
        return chart;
    }


    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    scatter.dispatch.on('elementClick.area', function(e) {
        dispatch.areaClick(e);
    });
    scatter.dispatch.on('elementMouseover.tooltip', function(e) {
        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top],
            dispatch.tooltipShow(e);
    });
    scatter.dispatch.on('elementMouseout.tooltip', function(e) {
        dispatch.tooltipHide(e);
    });

    //============================================================
    // Global getters and setters
    //------------------------------------------------------------

    chart.dispatch = dispatch;
    chart.scatter = scatter;

    chart.interpolate = function(_) {
        if (!arguments.length) return interpolate;
        interpolate = _;
        return chart;
    };

    chart.duration = function(_) {
        if (!arguments.length) return duration;
        duration = _;
        renderWatch.reset(duration);
        scatter.duration(duration);
        return chart;
    };

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        clipEdge: {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},
        offset:      {get: function(){return offset;}, set: function(_){offset=_;}},
        order:    {get: function(){return order;}, set: function(_){order=_;}},
        interpolate:    {get: function(){return interpolate;}, set: function(_){interpolate=_;}},

        // simple functor options
        x:     {get: function(){return getX;}, set: function(_){getX = d3.functor(_);}},
        y:     {get: function(){return getY;}, set: function(_){getY = d3.functor(_);}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
        }},
        style: {get: function(){return style;}, set: function(_){
            style = _;
            switch (style) {
                case 'stack':
                    chart.offset('zero');
                    chart.order('default');
                    break;
                case 'stream':
                    chart.offset('wiggle');
                    chart.order('inside-out');
                    break;
                case 'stream-center':
                    chart.offset('silhouette');
                    chart.order('inside-out');
                    break;
                case 'expand':
                    chart.offset('expand');
                    chart.order('default');
                    break;
                case 'stack_percent':
                    chart.offset(chart.d3_stackedOffset_stackPercent);
                    chart.order('default');
                    break;
            }
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            scatter.duration(duration);
        }}
    });

    nv.utils.inheritOptions(chart, scatter);
    nv.utils.initOptions(chart);

    return chart;
};

nv.models.stackedAreaChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var stacked = nv.models.stackedArea()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , legend = nv.models.legend()
        , controls = nv.models.legend()
        , interactiveLayer = nv.interactiveGuideline()
        ;

    var margin = {top: 30, right: 25, bottom: 50, left: 60}
        , width = null
        , height = null
        , color = nv.utils.defaultColor()
        , showControls = true
        , showLegend = true
        , showXAxis = true
        , showYAxis = true
        , rightAlignYAxis = false
        , useInteractiveGuideline = false
        , tooltips = true
        , tooltip = function(key, x, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' +  y + ' on ' + x + '</p>'
        }
        , x //can be accessed via chart.xScale()
        , y //can be accessed via chart.yScale()
        , yAxisTickFormat = d3.format(',.2f')
        , state = nv.utils.state()
        , defaultState = null
        , noData = 'No Data Available.'
        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState','renderEnd')
        , controlWidth = 250
        , cData = ['Stacked','Stream','Expanded']
        , controlLabels = {}
        , duration = 250
        ;

    state.style = stacked.style();
    xAxis.orient('bottom').tickPadding(7);
    yAxis.orient((rightAlignYAxis) ? 'right' : 'left');

    controls.updateState(false);

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var renderWatch = nv.utils.renderWatch(dispatch);
    var style = stacked.style();

    var showTooltip = function(e, offsetElement) {
        var left = e.pos[0] + ( offsetElement.offsetLeft || 0 ),
            top = e.pos[1] + ( offsetElement.offsetTop || 0),
            x = xAxis.tickFormat()(stacked.x()(e.point, e.pointIndex)),
            y = yAxis.tickFormat()(stacked.y()(e.point, e.pointIndex)),
            content = tooltip(e.series.key, x, y, e, chart);

        nv.tooltip.show([left, top], content, e.value < 0 ? 'n' : 's', null, offsetElement);
    };

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled }),
                style: stacked.style()
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.style !== undefined)
                style = state.style;
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        renderWatch.reset();
        renderWatch.models(stacked);
        if (showXAxis) renderWatch.models(xAxis);
        if (showYAxis) renderWatch.models(yAxis);

        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);

            var availableWidth = (width  || parseInt(container.style('width')) || 960)
                    - margin.left - margin.right,
                availableHeight = (height || parseInt(container.style('height')) || 400)
                    - margin.top - margin.bottom;

            chart.update = function() { container.transition().duration(duration).call(chart); };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                var noDataText = container.selectAll('.nv-noData').data([noData]);

                noDataText.enter().append('text')
                    .attr('class', 'nvd3 nv-noData')
                    .attr('dy', '-.7em')
                    .style('text-anchor', 'middle');

                noDataText
                    .attr('x', margin.left + availableWidth / 2)
                    .attr('y', margin.top + availableHeight / 2)
                    .text(function(d) { return d });

                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = stacked.xScale();
            y = stacked.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-stackedAreaChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedAreaChart').append('g');
            var g = wrap.select('g');

            gEnter.append("rect").style("opacity",0);
            gEnter.append('g').attr('class', 'nv-x nv-axis');
            gEnter.append('g').attr('class', 'nv-y nv-axis');
            gEnter.append('g').attr('class', 'nv-stackedWrap');
            gEnter.append('g').attr('class', 'nv-legendWrap');
            gEnter.append('g').attr('class', 'nv-controlsWrap');
            gEnter.append('g').attr('class', 'nv-interactive');

            g.select("rect").attr("width",availableWidth).attr("height",availableHeight);

            // Legend
            if (showLegend) {
                var legendWidth = (showControls) ? availableWidth - controlWidth : availableWidth;

                legend.width(legendWidth);
                g.select('.nv-legendWrap').datum(data).call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(' + (availableWidth-legendWidth) + ',' + (-margin.top) +')');
            }

            // Controls
            if (showControls) {
                var controlsData = [
                    {
                        key: controlLabels.stacked || 'Stacked',
                        metaKey: 'Stacked',
                        disabled: stacked.style() != 'stack',
                        style: 'stack'
                    },
                    {
                        key: controlLabels.stream || 'Stream',
                        metaKey: 'Stream',
                        disabled: stacked.style() != 'stream',
                        style: 'stream'
                    },
                    {
                        key: controlLabels.expanded || 'Expanded',
                        metaKey: 'Expanded',
                        disabled: stacked.style() != 'expand',
                        style: 'expand'
                    },
                    {
                        key: controlLabels.stack_percent || 'Stack %',
                        metaKey: 'Stack_Percent',
                        disabled: stacked.style() != 'stack_percent',
                        style: 'stack_percent'
                    }
                ];

                controlWidth = (cData.length/3) * 260;
                controlsData = controlsData.filter(function(d) {
                    return cData.indexOf(d.metaKey) !== -1;
                });

                controls
                    .width( controlWidth )
                    .color(['#444', '#444', '#444']);

                g.select('.nv-controlsWrap')
                    .datum(controlsData)
                    .call(controls);

                if ( margin.top != Math.max(controls.height(), legend.height()) ) {
                    margin.top = Math.max(controls.height(), legend.height());
                    availableHeight = (height || parseInt(container.style('height')) || 400)
                        - margin.top - margin.bottom;
                }

                g.select('.nv-controlsWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')');
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            if (rightAlignYAxis) {
                g.select(".nv-y.nv-axis")
                    .attr("transform", "translate(" + availableWidth + ",0)");
            }

            //Set up interactive layer
            if (useInteractiveGuideline) {
                interactiveLayer
                    .width(availableWidth)
                    .height(availableHeight)
                    .margin({left: margin.left, top: margin.top})
                    .svgContainer(container)
                    .xScale(x);
                wrap.select(".nv-interactive").call(interactiveLayer);
            }

            stacked
                .width(availableWidth)
                .height(availableHeight);

            var stackedWrap = g.select('.nv-stackedWrap')
                .datum(data);

            stackedWrap.transition().call(stacked);

            // Setup Axes
            if (showXAxis) {
                xAxis.scale(x)
                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                    .tickSize( -availableHeight, 0);

                g.select('.nv-x.nv-axis')
                    .attr('transform', 'translate(0,' + availableHeight + ')');

                g.select('.nv-x.nv-axis')
                    .transition().duration(0)
                    .call(xAxis);
            }

            if (showYAxis) {
                yAxis.scale(y)
                    .ticks(stacked.offset() == 'wiggle' ? 0 : nv.utils.calcTicksY(availableHeight/36, data) )
                    .tickSize(-availableWidth, 0)
                    .setTickFormat( (stacked.style() == 'expand' || stacked.style() == 'stack_percent')
                        ? d3.format('%') : yAxisTickFormat);

                g.select('.nv-y.nv-axis')
                    .transition().duration(0)
                    .call(yAxis);
            }

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            stacked.dispatch.on('areaClick.toggle', function(e) {
                if (data.filter(function(d) { return !d.disabled }).length === 1)
                    data.forEach(function(d) {
                        d.disabled = false;
                    });
                else
                    data.forEach(function(d,i) {
                        d.disabled = (i != e.seriesIndex);
                    });

                state.disabled = data.map(function(d) { return !!d.disabled });
                dispatch.stateChange(state);

                chart.update();
            });

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            controls.dispatch.on('legendClick', function(d,i) {
                if (!d.disabled) return;

                controlsData = controlsData.map(function(s) {
                    s.disabled = true;
                    return s;
                });
                d.disabled = false;

                stacked.style(d.style);


                state.style = stacked.style();
                dispatch.stateChange(state);

                chart.update();
            });

            interactiveLayer.dispatch.on('elementMousemove', function(e) {
                stacked.clearHighlights();
                var singlePoint, pointIndex, pointXLocation, allData = [];
                data
                    .filter(function(series, i) {
                        series.seriesIndex = i;
                        return !series.disabled;
                    })
                    .forEach(function(series,i) {
                        pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());
                        stacked.highlightPoint(i, pointIndex, true);
                        var point = series.values[pointIndex];
                        if (typeof point === 'undefined') return;
                        if (typeof singlePoint === 'undefined') singlePoint = point;
                        if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));

                        //If we are in 'expand' mode, use the stacked percent value instead of raw value.
                        var tooltipValue = (stacked.style() == 'expand') ? point.display.y : chart.y()(point,pointIndex);
                        allData.push({
                            key: series.key,
                            value: tooltipValue,
                            color: color(series,series.seriesIndex),
                            stackedValue: point.display
                        });
                    });

                allData.reverse();

                //Highlight the tooltip entry based on which stack the mouse is closest to.
                if (allData.length > 2) {
                    var yValue = chart.yScale().invert(e.mouseY);
                    var yDistMax = Infinity, indexToHighlight = null;
                    allData.forEach(function(series,i) {

                        //To handle situation where the stacked area chart is negative, we need to use absolute values
                        //when checking if the mouse Y value is within the stack area.
                        yValue = Math.abs(yValue);
                        var stackedY0 = Math.abs(series.stackedValue.y0);
                        var stackedY = Math.abs(series.stackedValue.y);
                        if ( yValue >= stackedY0 && yValue <= (stackedY + stackedY0))
                        {
                            indexToHighlight = i;
                            return;
                        }
                    });
                    if (indexToHighlight != null)
                        allData[indexToHighlight].highlight = true;
                }

                var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex));

                //If we are in 'expand' mode, force the format to be a percentage.
                var valueFormatter = (stacked.style() == 'expand') ?
                    function(d,i) {return d3.format(".1%")(d);} :
                    function(d,i) {return yAxis.tickFormat()(d); };
                interactiveLayer.tooltip
                    .position({left: pointXLocation + margin.left, top: e.mouseY + margin.top})
                    .chartContainer(that.parentNode)
                    .enabled(tooltips)
                    .valueFormatter(valueFormatter)
                    .data(
                    {
                        value: xValue,
                        series: allData
                    }
                )();

                interactiveLayer.renderGuideLine(pointXLocation);

            });

            interactiveLayer.dispatch.on("elementMouseout",function(e) {
                dispatch.tooltipHide();
                stacked.clearHighlights();
            });


            dispatch.on('tooltipShow', function(e) {
                if (tooltips) showTooltip(e, that.parentNode);
            });

            // Update chart from a state object passed to event handler
            dispatch.on('changeState', function(e) {

                if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });

                    state.disabled = e.disabled;
                }

                if (typeof e.style !== 'undefined') {
                    stacked.style(e.style);
                    style = e.style;
                }

                chart.update();
            });

        });

        renderWatch.renderEnd('stacked Area chart immediate');
        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    stacked.dispatch.on('tooltipShow', function(e) {
        e.pos = [e.pos[0] + margin.left, e.pos[1] + margin.top];
        dispatch.tooltipShow(e);
    });

    stacked.dispatch.on('tooltipHide', function(e) {
        dispatch.tooltipHide(e);
    });

    dispatch.on('tooltipHide', function() {
        if (tooltips) nv.tooltip.cleanup();
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.stacked = stacked;
    chart.legend = legend;
    chart.controls = controls;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.interactiveLayer = interactiveLayer;

    yAxis.setTickFormat = yAxis.tickFormat;

    chart.dispatch = dispatch;
    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},
        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},
        tooltips:    {get: function(){return tooltips;}, set: function(_){tooltips=_;}},
        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},
        showControls:    {get: function(){return showControls;}, set: function(_){showControls=_;}},
        controlLabels:    {get: function(){return controlLabels;}, set: function(_){controlLabels=_;}},
        yAxisTickFormat:    {get: function(){return yAxisTickFormat;}, set: function(_){yAxisTickFormat=_;}},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        duration: {get: function(){return duration;}, set: function(_){
            duration = _;
            renderWatch.reset(duration);
            stacked.duration(duration);
            xAxis.duration(duration);
            yAxis.duration(duration);
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
            stacked.color(color);
        }},
        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){
            rightAlignYAxis = _;
            yAxis.orient( rightAlignYAxis ? 'right' : 'left');
        }},
        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
            useInteractiveGuideline = !!_;
            if (_) {
                chart.interactive(false);
                chart.useVoronoi(false);
            }
        }}
    });

    nv.utils.inheritOptions(chart, stacked);
    nv.utils.initOptions(chart);

    return chart;
};

nv.version = "1.7.1";
})();
},{}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\index.js":[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
//loading hacks
var jQuery = require('jquery');

//loading jquery is colliding in GIS module, so we only load it if
//it is not loaded or if there is a jquery loaded but version is older than 2.x.x
if (window.$ == undefined || $.fn.jquery.split(' ')[0].split('.')[0] < 2) {
  window.jQuery = window.$ = Backbone.$ = jQuery;
}

var bootstrap_enabled = (typeof $().modal == 'function');
if (bootstrap_enabled) {
  require('bootstrap/dist/js/bootstrap');
}

var MenuView = require('./src/views/menu-view.js');
var HeaderFooterView = require('./src/views/header-footer-view.js');
var Translator = require('amp-translate');


/* example of use
 * this.menus = new Menus({
 *   translator: this.translator,
 *   caller: 'GIS'
 * });
 */


function Widget() {
  this.initialize.apply(this, arguments);
}

_.extend(Widget.prototype, Backbone.Events, {
  initialize: function(options) {
    options = _.defaults(options, {
      showFooterAdmin: true,
      showDGFooter: true,
      showLogin: true,
      useSingleRowHeader: false
    });
    if (_.has(options, 'sync')) {
      Backbone.sync = options.sync;
    }
    var defaultKeys = JSON.parse("{\n\"amp.common:footer\": \"Developed in partnership with OECD, UNDP, WB, Government of Ethiopia and DGF\",\n\"amp.common:title\": \"AMP Toolbar\",\n\"amp.common:title-help\": \"Help\",\n\"amp.common:subtitle-amp-help\": \"AMP Help\",\n\"amp.common:subtitle-glossary\": \"Glossary\",\n\"amp.common:subtitle-email-support-team\": \"Email Support Team\",\n\"amp.common:title-logout\": \"Log Out\",\n\"amp.common:platform\": \"Aid Management Platform (AMP)\",\n\"[title]amp.common:platform\": \"Aid Management Platform\",\n\"amp.common:platform-short\": \"AMP\",\n\"amp.common:title-login\": \"Login\",\n\"amp.dashboard:close\": \"Close\",\n\"amp.about:modal.title\": \"About AMP\",\n\"amp.about:credits\": \"Developed in partnership with OECD, UNDP, WB, Government of Ethiopia and Development Gateway Foundation.\",\n\"amp.about:trademark\": \"The Development Gateway and the The Development Gateway logo are trademarks for The Development Gateway Foundation\",\n\"amp.about:rights\": \"All Rights Reserved\",\n\"amp.about:version\": \"Version\"\n}\n\n");
    this.translator = new Translator({
      defaultKeys: defaultKeys
    });
    options.translator = this.translator;

    this.menu = new MenuView(options);
    this.headerFooter = new HeaderFooterView(options);

    this.listenTo(this.headerFooter, 'all', function() {
      this.trigger.apply(this, arguments);
    });
    this.listenTo(this.menu, 'all', function() {
      this.trigger.apply(this, arguments);
    });
    var self = this;
    $.when(this.menu.menuRendered, this.headerFooter.layoutFetched).then(function() {
      self.headerFooter.refreshUserSection();
      self.translator.translateDOM(document);
      if ($.fn.dropdown !== undefined) {
        $('.dropdown-toggle').dropdown();
      }
    });
  },

});


module.exports = {
  layout: Widget
};
window.boilerplate = Widget;

},{"./src/views/header-footer-view.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\views\\header-footer-view.js","./src/views/menu-view.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\views\\menu-view.js","amp-translate":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-translate\\index.js","backbone":"backbone","bootstrap/dist/js/bootstrap":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\node_modules\\bootstrap\\dist\\js\\bootstrap.js","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\node_modules\\bootstrap\\dist\\js\\bootstrap.js":[function(require,module,exports){
/*!
 * Bootstrap v3.3.0 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
}

+function ($) {
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher')
  }
}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.0
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.3.0
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.0'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.3.0
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.0'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state = state + 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked') && this.$element.hasClass('active')) changed = false
        else $parent.find('.active').removeClass('active')
      }
      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
    }

    if (changed) this.$element.toggleClass('active')
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', e.type == 'focus')
    })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.3.0
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      =
    this.sliding     =
    this.interval    =
    this.$active     =
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.0'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var delta = direction == 'prev' ? -1 : 1
    var activeIndex = this.getItemIndex(active)
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var fallback  = type == 'next' ? 'first' : 'last'
    var that      = this

    if (!$next.length) {
      if (!this.options.wrap) return
      $next = this.$element.find('.item')[fallback]()
    }

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.3.0
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $(this.options.trigger).filter('[href="#' + element.id + '"], [data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.0'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true,
    trigger: '[data-toggle="collapse"]'
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.find('> .panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && option == 'show') options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $.extend({}, $this.data(), { trigger: this })

    Plugin.call($target, option)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.0
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.0'

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger('shown.bs.dropdown', relatedTarget)
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.divider):visible a'
    var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--                        // up
    if (e.which == 40 && index < $items.length - 1) index++                        // down
    if (!~index)                                      index = 0

    $items.eq(index).trigger('focus')
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
    })
  }

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="menu"]', Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '[role="listbox"]', Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.0
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options        = options
    this.$body          = $(document.body)
    this.$element       = $(element)
    this.$backdrop      =
    this.isShown        = null
    this.scrollbarWidth = 0

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.0'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.$body.addClass('modal-open')

    this.setScrollbar()
    this.escape()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element
        .addClass('in')
        .attr('aria-hidden', false)

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$element.find('.modal-dialog') // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .attr('aria-hidden', true)
      .off('click.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .prependTo(this.$element)
        .on('click.dismiss.bs.modal', $.proxy(function (e) {
          if (e.target !== e.currentTarget) return
          this.options.backdrop == 'static'
            ? this.$element[0].focus.call(this.$element[0])
            : this.hide.call(this)
        }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  Modal.prototype.checkScrollbar = function () {
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    if (this.scrollbarWidth) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', '')
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    if (document.body.clientWidth >= window.innerWidth) return 0
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.0
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       =
    this.options    =
    this.enabled    =
    this.timeout    =
    this.hoverState =
    this.$element   = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.0'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (self && self.$tip && self.$tip.is(':visible')) {
      self.hoverState = 'in'
      return
    }

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()
        var containerDim = this.getPosition($container)

        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) {
    this.arrow()
      .css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isHorizontal ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = this.tip()
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && this.$tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    return (this.$tip = this.$tip || $(this.options.template))
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.tooltip')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.tooltip', (data = {}))
        if (!data[selector]) data[selector] = new Tooltip(this, options)
      } else {
        if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.0
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.0'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }

  Popover.prototype.tip = function () {
    if (!this.$tip) this.$tip = $(this.options.template)
    return this.$tip
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.popover')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.popover', (data = {}))
        if (!data[selector]) data[selector] = new Popover(this, options)
      } else {
        if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.0
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    var process  = $.proxy(this.process, this)

    this.$body          = $('body')
    this.$scrollElement = $(element).is('body') ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', process)
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.0'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var offsetMethod = 'offset'
    var offsetBase   = 0

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.offsets = []
    this.targets = []
    this.scrollHeight = this.getScrollHeight()

    var self     = this

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        self.offsets.push(this[0])
        self.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
        '[data-target="' + target + '"],' +
        this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.3.0
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    this.element = $(element)
  }

  Tab.VERSION = '3.3.0'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && (($active.length && $active.hasClass('fade')) || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu')) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback && callback()
    }

    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.0
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      =
    this.unpin        =
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.0'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && colliderTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = $('body').height()

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

},{}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\collections\\amp-menus-collection.js":[function(require,module,exports){
var Backbone = require('backbone');
var MenuModel = require('../models/amp-menus-model.js');

module.exports = Backbone.Collection.extend({
  url: '/rest/security/menus',
  model: MenuModel,

  fetch: function(options) {
    options = options || {};
    options.cache = false;
    return Backbone.Model.prototype.fetch.call(this, options);
  }

});

},{"../models/amp-menus-model.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\models\\amp-menus-model.js","backbone":"backbone"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\models\\amp-layout-model.js":[function(require,module,exports){
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
  url: '/rest/security/layout',

  defaults: {
    email: undefined
  },
  fetch: function(options) {
    options = options || {};
    options.cache = false;
    return Backbone.Model.prototype.fetch.call(this, options);
  }

});

},{"backbone":"backbone"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\models\\amp-menus-model.js":[function(require,module,exports){
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
  url: '/rest/security/menus',

  defaults: {
    name: "Default",
    children: []
  },
  fetch: function(options) {
    options = options || {};
    options.cache = false;
    return Backbone.Model.prototype.fetch.call(this, options);
  }

});

},{"backbone":"backbone"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\views\\about-view.js":[function(require,module,exports){

var $ = require('jquery');
var Backbone = require('backbone');
var _ = require('underscore');
var Template = "<div class=\"modal fade\" id=\"about-popup\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\r\n<div class=\"modal-dialog\">\r\n <div class=\"modal-content\">\r\n <div class=\"modal-header\">\r\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\"><span aria-hidden=\"true\">&times;</span><span data-i18n=\"amp.dashboard:close\" class=\"sr-only\">Close</span></button>\r\n        <h4 class=\"modal-title text-primary\" data-i18n=\"amp.about:modal.title\">About AMP</h4>\r\n </div>\r\n<table width=\"474\" border=\"0\" style=\"margin:15px;\">\r\n\t<tbody><tr>\r\n\t\t<td width=\"257\">\r\n\t\t<p align=\"center\" style=\"font-size: 16px;\"><strong>&nbsp;<span data-i18n=\"amp.common:platform\">Aid Management Platform (AMP)</span></strong></p>\r\n\t\t<p align=\"center\"> Version <%= ampVersion %></p>\r\n\t\t</td>\r\n\t\t<td width=\"220\"><img width=\"220\" height=\"100\" src=\"/TEMPLATE/ampTemplate/img_2/logo-development-gateway.png\"></td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td colspan=\"2\">\r\n\t\t<p  style=\"font-size: 12px;\">&nbsp;<span data-i18n=\"amp.common:platform\">Aid Management Platform (AMP)</span>\r\n\t\t <span data-i18n=\"amp.about:version\">Version</span> <%= ampVersion %> <%= buildDate %>\r\n\t\t<span data-i18n=\"amp.about:credits\">Developed in partnership with OECD, UNDP, WB, Government of Ethiopia and Development Gateway Foundation</span>.\r\n\t\t</p>\r\n\t\t</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td colspan=\"2\">\r\n\t\t<p style=\"font-size: 12px;\">\r\n\t\t<span data-i18n=\"amp.about:trademark\">The Development Gateway and the The Development Gateway logo are trademarks for The Development Gateway Foundation</span>.<span data-i18n=\"amp.about:rights\">All Rights Reserved</span>.</p>\r\n\t\t</td>\r\n\t</tr>\r\n</tbody></table>\r\n</div>\r\n</div>\r\n</div>";

module.exports = Backbone.View.extend({
  template: _.template(Template),
  id: 'aboutModal',
  
  initialize: function(options) {
	  this.app = options.app;
    _.bindAll(this, 'render');

  },

  render: function() {
	var self = this;
	_.defaults(window, {ampVersion: "0", buildDate: "0"});
    this.$el.html(self.template({
      ampVersion: window.ampVersion,
      buildDate: window.buildDate
    }));
    return this;
  }
  
});


},{"backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\views\\header-footer-view.js":[function(require,module,exports){

var Backbone = require('backbone');
var _ = require('underscore');
require('bootstrap/dist/js/bootstrap');

var Template = "<style>\r\n    .footerText {\r\n    padding: 0;\r\n    font-family: arial;\r\n    font-size: 11px;\r\n    border: 0px;\r\n    }\r\n    .footer {\r\n    background-color: #8B8B8B;\r\n    color: #FFF;\r\n    margin-top: 0;\r\n    padding-bottom: 10px;\r\n    padding-top: 10px;\r\n    text-align: center;\r\n    }\r\n    .dgf_footer {\r\n    color: #8B8B8B;\r\n    line-height: 18px;\r\n    text-align: center;\r\n    background-color:white;\r\n    padding-top:10px;\r\n    }\r\n    .dgf_footer img {\r\n    line-height: 18px;\r\n    margin-bottom: 5px;\r\n    }\r\n    .loading{   \r\n      margin: 10px 20px 10px 20px;\r\n    }\r\n    \r\n</style>\r\n\r\n<div class=\"footer footerText\">\r\n    AMP <b><%=  properties.ampVersion %></b> build <b><%=  properties.buildDate %></b> - <%= properties.footerText %>\r\n    <% if(showAdminLinks == true  && properties.adminLinks != undefined) { %>\r\n    <a href='<%=  properties.adminLinks[0].url %>'><%=  properties.adminLinks[0].name %></a>\r\n    <a href='<%=  properties.adminLinks[1].url %>'><%=  properties.adminLinks[1].name %></digi:trn></a>\r\n    <% } %>\r\n</div>\r\n<% if(showDGFooter == true)  { %>\r\n<div class=\"dgf_footer footerText\">\r\n    <img src=\"/TEMPLATE/ampTemplate/img_2/dgf_logo_bottom.gif\" class=\"dgf_logo_footer\">\r\n    <br/>\r\n    Development Gateway\r\n    <br/>\r\n    1110 Vermont Ave, NW, Suite 500\r\n    <br/>\r\n    Washington, DC 20005 USA\r\n    <br/>\r\n    info@developmentgateway.org, Tel: +1.202.572.9200, Fax: +1 202.572.9290\r\n</div>\r\n<% } %>\r\n\r\n\r\n<div id=\"user-profile\" class=\"modal fade\" id=\"about-popup\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\r\n<div class=\"modal-dialog\">\r\n <div class=\"modal-content\">\r\n <div class=\"modal-header\">\r\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\"><span aria-hidden=\"true\">&times;</span><span data-i18n=\"amp.dashboard:close\" class=\"sr-only\">Close</span></button>\r\n        <h4 class=\"modal-title text-primary\" data-i18n=\"amp.profile:modal.title\">Member Details</h4>\r\n </div>\r\n <div class=\"user-profile-content\">\r\n   <div class='loading' data-i18n=\"amp.profile:modal.loading\">Loading...</div>\r\n </div> \r\n </div>\r\n </div>\r\n </div>\r\n<% if(properties.trackingEnabled === true) { %>\r\n<!-- Piwik\r\nSite id can be checked here: http://stats.ampsite.net/index.php?module=SitesManager&action=index&idSite=1&period=range&date=last30\r\nAlso,the wiki for piwik: https://wiki.dgfoundation.org/display/AMPDOC/Integrating+AMP+with+Piwik\r\n-->\r\n<script type=\"text/javascript\">\r\n\t  var _paq = _paq || [];\r\n    if (window.PiwikAlreadyFetched === undefined ) {\r\n      _paq.push(['setUserId', \"<%= properties.email %>\"]);\r\n      _paq.push(['setCustomVariable',\r\n          1,\r\n          \"Workspace|WID\",\r\n          \"<%= properties.workspace %>|<%= properties.workspaceId %>\",\r\n          \"page\"]);\r\n  \t  _paq.push([\"trackPageView\"]);\r\n  \t  _paq.push([\"enableLinkTracking\"]);\r\n\r\n      /* TDK: keep track of whether we put the script DOM node on the page already\r\n       *   in case the page reparses this javascript on another modification.\r\n       */\r\n      window.PiwikAlreadyFetched = true;\r\n\r\n      /* Stock Piwik code: */\r\n  \t  (function() {\r\n  \t    var u=\"<%=  properties.trackingUrl %>\";\r\n  \t    _paq.push([\"setTrackerUrl\", u+\"piwik.php\"]);\r\n  \t    _paq.push([\"setSiteId\", \"<%=properties.siteId %>\"]);\r\n  \t    var d=document, g=d.createElement(\"script\"), s=d.getElementsByTagName(\"script\")[0]; g.type=\"text/javascript\";\r\n  \t    g.defer=true; g.async=true; g.src=u+\"piwik.js\"; s.parentNode.insertBefore(g,s);\r\n  \t  })();\r\n    }\r\n\t</script>\r\n<!-- End Piwik Code -->\r\n<% } %>\r\n";
var LayoutModel = require('../models/amp-layout-model.js');

module.exports = Backbone.View.extend({
  model: null,
  template: _.template(Template),
  el: '#amp-footer',
  layoutFetched: new $.Deferred(),
  showAdminFooter: true,
  showDGFooter: true,  
  events: {
	    "click .user-url": "showUserProfile"
  },
  initialize: function(options) {
    this.showAdminFooter = options.showAdminFooter;
    this.showDGFooter = options.showDGFooter;
    var layoutModel = new LayoutModel();
    var self = this;
    layoutModel.fetch().then(function(layout) {
      self.model = layout;
      window.buildDate = layout.buildDate;
      window.ampVersion = layout.ampVersion;
      self.render();
      self.layoutFetched.resolve();
    });

    //AMP-20646: we need to wait until the endpoint has responded.
    this.layoutFetched.done(function() {
      self.render();
    });
    _.bindAll(this, 'render', 'refreshUserSection');
  },
  render: function() {
    if (this.model) {
      this.refreshUserSection();
      var self = this;
      this.$el.html(this.template({
        properties: self.model,
        showAdminLinks: self.showAdminFooter,
        showDGFooter: self.showDGFooter
      }));
    }
    return this;
  },
  refreshUserSection: function() {
	var self = this;
    if (this.model.logged === true) {
      $('.container-fluid', $('#amp-header')).toggleClass('ampUserLoggedIn');
      $('#headerUrl').attr("href", "/aim");
    } else {
      $('#headerUrl').attr("href", "/");
    }
    if (this.model.email) {    	 
      $("#header-name" ).click(function() {		  
		  self.showUserProfile();
      });
      $('#header-workspace', $('#amp-header')).text(this.model.workspace);
      $('#header-workspace', $('#amp-header')).prop('title', this.model.workspace);
      $('#header-name #header-first-name', $('#amp-header')).text(this.model.firstName);
      $('#header-name #header-last-name', $('#amp-header')).text(this.model.lastName);
    }

  },  
  showUserProfile: function(){
	if (this.model.email) {
       var url = '/aim/default/userProfile.do~edit=true~id=' + this.model.userId;       
       if(!this.profileLoaded ){    	   
          $('.user-profile-content').load(url);  
          this.profileLoaded = true;
       }            
       if (typeof $().modal !== 'function') {
    	      $.noConflict();
       }       
       $('#user-profile').modal({
    	      show: true,
    	      backdrop: false
      });
	}
  }

});

},{"../models/amp-layout-model.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\models\\amp-layout-model.js","backbone":"backbone","bootstrap/dist/js/bootstrap":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\node_modules\\bootstrap\\dist\\js\\bootstrap.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\views\\menu-view.js":[function(require,module,exports){

var Backbone = require('backbone');
require('bootstrap/dist/js/bootstrap');
var _ = require('underscore');

var Template = "<!-- inline styles used so we can relocate amp-boilerplate module-->\n<style>\n  /* This directory and then Dashboard & GIS need\n   * to be rebuilt with their respective browserify-processes to see\n   * changes from this filter-popup due to brfs, see readme.md\n   */\n  #amp-header {\n    font-family: \"Open Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif;\n  }\n  #amp-header .navbar-header>button.navbar-toggle {\n    /* fix contracted menu icon to not block map*/\n    padding: 2px;\n    margin: 4px;\n  }\n\n  #amp-header .container-fluid.ampUserLoggedIn ul.ampPublic,\n  #amp-header .container.ampUserLoggedIn ul.ampPublic {\n    display: none !important;\n  }\n\n  #amp-header .container-fluid.ampUserLoggedIn ul.ampUserLoggedIn,\n  #amp-header .container.ampUserLoggedIn ul.ampUserLoggedIn {\n    display: inherit !important;\n  }\n\n  #amp-header .container-fluid ul.ampPublic,\n  #amp-header .container ul.ampPublic {\n    display: inherit !important;\n  }\n\n  #amp-header .container-fluid ul.ampUserLoggedIn,\n  #amp-header .container ul.ampUserLoggedIn {\n    display: none !important;\n  }\n\n\n  div#amp-header nav div.container,\n  div#amp-header nav div.navbar-collapse a,\n  div#amp-header nav div.container-fluid,\n  div#amp-header nav div.navbar-collapse a {\n    font-size: 12px;\n  }\n\n  div#amp-header .navbar-brand {\n    font-size: 16px !important;\n    color: #E69923;\n    text-shadow: 1px 1px 5px #CCC;\n    white-space: nowrap;\n    padding-bottom: 8px;\n  }\n\n  div#amp-header .double-row .navbar-brand {\n    padding-top: 8px;\n    height: 41px;\n  }\n\n  /* Several places in AMP include things that will set this\n   * back to gigantic margins.\n   * 8px feels like generous padding\n   * 5px is slightly tight.\n   *\n   */\n  div#amp-header .single-row .nav > li > a {\n    padding-right: 6px;\n    padding-left: 6px;\n  }\n  div#amp-header .double-row .nav > li > a{\n    padding-right: 10px;\n    padding-left: 10px;\n    padding-bottom: 8px;\n    padding-top: 9px;\n  }\n\n  div#amp-header .double-row #AmpMenus.nav > li:nth-child(1) > a {\n    /* For first element, eliminate padding to ensure is flush. */\n    padding-left: 0;\n  }\n\n    div#amp-header .workspace-name {\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n    div#amp-header .user-url {\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n\n  /* limit size of top level menu to prevent translations that are too long\n   * Apply to a span so that that caret doesn't get chopped off.\n   */\n  /* max-width:\n   * 141px is generous, fits ÉTUDES ET DOCUMENTS\n   * 124px is minimum to include 3 words (Ministry of ??...)\n   * 117px fits TABLEAUX DE BORD\n   *\n   * div.ampUserLoggedIn in selector makes this effective ONLY when logged in\n   * single-row selector only when using that mode\n   */\n  #amp-header div.ampUserLoggedIn .single-row ul#AmpMenus > .dropdown > a > span.dropdown-text {\n    max-width: 141px;\n  }\n\n  #amp-header ul#AmpMenus > .dropdown > a > span.dropdown-text {\n    display: inline-block;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    color: #3E6C94;\n    text-rendering: optimizeLegibility;\n  }\n\n\n  #amp-header ul#AmpMenus > .dropdown > a > span.caret {\n    /* bump up caret to the height of the truncate-able inline-block next to it */\n    padding-bottom: 11px;\n    color: rgb(11, 12, 26);\n  }\n\n\n  #amp-header .container-fluid.no-gutters,\n  #amp-header .container.no-gutters {\n    padding-right: 0;\n    padding-left: 0;\n  }\n\n  /* No gutters creates space for 1 gridsquare logo.\n   * http://julienmelissas.com/no-gutter-column-trick-for-bootstrap/\n   */\n  #amp-header .container-fluid .row.no-gutters,\n  #amp-header .container .row.no-gutters {\n    margin-right: 0;\n    margin-left: 0;\n  }\n  #amp-header .container-fluid .row.no-gutters > [class^=\"col-\"],\n  #amp-header .container-fluid .row.no-gutters > [class*=\" col-\"],\n  #amp-header .container .row.no-gutters > [class^=\"col-\"],\n  #amp-header .container .row.no-gutters > [class*=\"col-\"] {\n    padding-right: 0;\n    padding-left: 0;\n  }\n\n  #amp-header nav > .container-fluid > div.row:nth-child(1),\n  #amp-header nav > .container > div.row:nth-child(1) {\n    background-color: #FFF;\n  }\n\n  #amp-header nav > .container > div.row:nth-child(2),\n  #amp-header nav > .container-fluid > div.row:nth-child(2) {\n    border-top: 1px solid #EDEDED;\n    background-color: #F7F7F7;\n  }\n\n  #amp-header .container-fluid,\n  #amp-header .container {\n    background-color: #FFF; /* Fixes gray area in gutter of single-row */\n  }\n\n\n/* There is a second set of gutters on the navbar itself. */\n  div#amp-header .navbar-collapse.no-gutters{\n    padding-right: 0;\n    padding-left: 0;\n  }\n\n  /* These four styles avoids setting hard max-widths on these items */\n  #amp-header .ampLoggedInMenus {\n    width: 95%; /* account for scrollbar */\n    text-shadow: 1px 1px 1px #AAA;\n  }\n\n  /* give a bit of extra width to workspace */\n  #amp-header ul.nav.navbar-nav.ampLoggedInMenus li:nth-child(1) {\n      text-align: right;\n  }\n  /* user name */\n  #amp-header ul.nav.navbar-nav.ampLoggedInMenus li:nth-child(2) {\n      text-align: center;\n  }\n  /* Logout */\n  #amp-header ul.nav.navbar-nav.ampLoggedInMenus li:nth-child(3) {\n      white-space: nowrap; /* prevent translations of logout from wrapping */\n  }\n\n  div#amp-header div#logincontainer {\n    padding-left: 140px; /* IE9 fix that works everywhere: make room for green login button */\n  }\n\n  div#amp-header .login_here {\n    margin-top: 3px !important; /* override 7 other specs in amp-wicket, and various copies of amp.css */\n  }\n\n  html.ie9 div#amp-header .login_here {\n    margin-top: -11px !important; /* override 7 other specs in amp-wicket, and various copies of amp.css */\n  }\n\n  /******/\n  .scrollable-menu {\n    height: auto;\n    max-height: 400px;\n    overflow-x: hidden;\n  }\n\n  .dropdown-submenu {\n    position: relative;\n  }\n\n  .dropdown-submenu>.dropdown-menu {\n    top: 0;\n    left: 100%;\n    margin-top: -6px;\n    margin-left: -1px;\n    -webkit-border-radius: 0 6px 6px 6px;\n    -moz-border-radius: 0 6px 6px 6px;\n    border-radius: 0 6px 6px 6px;\n  }\n\n  .dropdown-submenu:hover>.dropdown-menu {\n    display: block;\n  }\n\n  .dropdown-submenu>a:after {\n    display: block;\n    content: \" \";\n    float: right;\n    width: 0;\n    height: 0;\n    border-color: transparent;\n    border-style: solid;\n    border-width: 5px 0 5px 5px;\n    border-left-color: #cccccc;\n    margin-top: 5px;\n    margin-right: -10px;\n  }\n\n  .dropdown-submenu:hover>a:after {\n    border-left-color: #ffffff;\n  }\n\n  .dropdown-submenu.pull-left {\n    float: none;\n  }\n\n  .dropdown-submenu.pull-left>.dropdown-menu {\n    left: -100%;\n    margin-left: 10px;\n    -webkit-border-radius: 6px 0 6px 6px;\n    -moz-border-radius: 6px 0 6px 6px;\n    border-radius: 6px 0 6px 6px;\n  }\n\n</style>\n<script type=\"text/javascript\">\n  function switchTranslation (url) {\n    $('#backUrl').val(document.location.href);\n    document.modeSwitchForm.action = url;\n    document.modeSwitchForm.submit();\n  }\n</script>\n<form name=\"modeSwitchForm\" method=\"post\" action=\"/translation/switchMode.do\" style=\"display:none;\">\n  <input type=\"hidden\" name=\"backUrl\" id=\"backUrl\" value=\"\">\n</form>\n<%\n/***\n * Single Row Header Design (used when optionally requested: on GIS)\n * Useful for fixed height apps.\n *\n * Container-fluid structure:\n * row\n *  column navbar-brand (logo)\n *  column navbar-collapse\n *    nested row:\n *      columns AmpMenus (public or internal menus shown as provided by API)\n *      nested row ampUserLoggedInMenus (shown when logged in, incl: workspace, user, logout):\n *        3 columns\n *  login_here (ignores bootstrap container structure; shown when logged out)\n *  div#logincontainer: inserted by jQuery + rendered by JSP\n ***/\n\n  if (useSingleRowHeader) {\n %>\n<nav class=\"navbar navbar-default single-row\" role=\"navigation\">\n  <div class=\"container-fluid\">\n    <div class=\"row no-gutters\">\n      <!-- .ampUserLoggedIn hides public version-->\n\n      <!-- Brand and toggle get grouped for better mobile display -->\n      <div class=\"navbar-header col-sm-1\">\n        <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\">\n          <span class=\"sr-only\">Toggle navigation</span>\n          <span class=\"icon-bar\"></span>\n          <span class=\"icon-bar\"></span>\n          <span class=\"icon-bar\"></span>\n        </button>\n          <a id=\"headerUrl\" class=\"navbar-brand\" href=\"/\" data-i18n=\"[title]amp.common:platform\">\n          <span>\n            <img class=\"flag\" src=\"/aim/default/displayFlag.do\" height=\"20\" width=\"30\">\n          </span>\n          <span data-i18n=\"amp.common:platform-short\">AMP</span></a>\n      </div>\n\n      <div class=\"col-sm-11\">\n        <div class=\"collapse navbar-collapse row no-gutters\" id=\"bs-example-navbar-collapse-1\">\n          <div class=\"col-md-8 col-sm-10\">\n            <ul id=\"AmpMenus\" class=\"nav navbar-nav menus\">\n\n              <!-- File -->\n\n            </ul>\n            <div class=\"clearfix\"></div>\n          </div>\n          <div class=\"col-md-4 col-sm-2\">\n              <ul class=\"row no-gutters nav navbar-nav ampUserLoggedIn ampLoggedInMenus\">\n                <li id=\"header-workspace-li\" class=\"col-sm-9 col-md-6\"><a title=\"Workspace\" class=\"workspace-name\" id=\"header-workspace\">&nbsp;</a></li>\n                <li id=\"header-name\" class=\"hidden-xs hidden-sm col-md-4\">\n                  <a class=\"user-url\">\n                    <span id=\"header-first-name\">&nbsp;</span>&nbsp;<span id=\"header-last-name\">&nbsp;</span>\n                  </a>\n                </li>\n                <li id=\"header-logout\" class=\"col-sm-2\"><a data-i18n=\"amp.common:title-logout\" href=\"/aim/j_spring_logout\" >Logout</a></li>\n              </ul>\n              <% if(showLogin) { %>\n                <% if(loginDropdown){ %>\n                  <div class=\"login_here\" id=\"show_login_pop\">\n                    <div class=\"login_here_cont\">\n                      <a data-i18n=\"amp.common:title-login\" href=\"javascript:void(0)\">Login</a>\n                    </div>\n                  </div>\n                <% } else { %>\n                  <ul class=\"nav navbar-nav ampPublic navbar-right\">\n                    <li id=\"header-login\"><a data-i18n=\"amp.common:title-login\" href=\"/login.do\" >Login</a></li>\n                  </ul>\n                <% } %>\n              <% } %>\n              <!-- div#logincontainer with anchors gets appended here -->\n          </div>\n        </div>\n      </div>\n\n    </div>\n    <!-- Collect the nav links, forms, and other content for toggling -->\n  </div><!-- /.container-fluid -->\n</nav>\n <% } else { %>\n\n<% /***\n * Double Row Header Design (used by default)\n *\n * Container-Fluid structure:\n * row\n *  column navbar-brand (logo)\n *  column navbar-collapse\n *    nested row:\n *        nested row ampUserLoggedInMenus (shown when logged in, incl: workspace, user, logout):\n            3 columns\n * row\n *    columns AmpMenus (public or internal menus shown as provided by API)\n *  login_here (ignores bootstrap container structure, shown when logged out)\n *  div#logincontainer: inserted by jQuery + rendered by JSP\n ***/ %>\n<nav class=\"navbar navbar-default double-row\" role=\"navigation\">\n  <div class=\"container-fluid no-gutters\">\n    <div class=\"row no-gutters\">\n      <!-- .ampUserLoggedIn hides public version-->\n\n      <!-- Brand and toggle get grouped for better mobile display -->\n      <div class=\"navbar-header col-sm-1 col-sm-offset-1\">\n        <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\">\n          <span class=\"sr-only\">Toggle navigation</span>\n          <span class=\"icon-bar\"></span>\n          <span class=\"icon-bar\"></span>\n          <span class=\"icon-bar\"></span>\n        </button>\n          <a id=\"headerUrl\" class=\"navbar-brand\" href=\"/\" data-i18n=\"[title]amp.common:platform\">\n          <span>\n            <img class=\"flag\" src=\"/aim/default/displayFlag.do\" height=\"20\" width=\"30\">\n          </span>\n          <span data-i18n=\"amp.common:platform-short\">AMP</span></a>\n      </div>\n\n      <div class=\"col-sm-9\">\n        <div class=\"collapse navbar-collapse row no-gutters\" id=\"bs-example-navbar-collapse-1\">\n          <!-- To change workspace/user truncation length, edit the offset and grid number below:-->\n          <div class=\"col-sm-offset-5 col-sm-7\">\n            <ul class=\"row no-gutters nav navbar-nav ampUserLoggedIn ampLoggedInMenus\">\n              <li id=\"header-workspace-li\" class=\"col-sm-9 col-md-6\"><a title=\"Workspace\" class=\"workspace-name\" id=\"header-workspace\">&nbsp;</a></li>\n              <li id=\"header-name\" class=\"hidden-xs hidden-sm col-md-4\">\n                <a class=\"user-url\">\n                  <span id=\"header-first-name\">&nbsp;</span>&nbsp;<span id=\"header-last-name\">&nbsp;</span>\n                </a>\n              </li>\n              <li id=\"header-logout\" class=\"col-sm-2\"><a data-i18n=\"amp.common:title-logout\" href=\"/aim/j_spring_logout\" >Logout</a></li>\n            </ul>\n            <% if(showLogin) { %>\n              <% if(loginDropdown){ %>\n                <div class=\"login_here\" id=\"show_login_pop\">\n                  <div class=\"login_here_cont\">\n                    <a data-i18n=\"amp.common:title-login\" href=\"javascript:void(0)\">Login</a>\n                  </div>\n                </div>\n              <% } else { %>\n                <ul class=\"nav navbar-nav ampPublic navbar-right\">\n                  <li id=\"header-login\"><a data-i18n=\"amp.common:title-login\" href=\"/login.do\" >Login</a></li>\n                </ul>\n              <% } %>\n            <% } %>\n            <!-- div#logincontainer with anchors gets appended here -->\n          </div>\n        </div>\n      </div>\n\n    </div>\n\n    <div class=\"row no-gutters\">\n      <div class=\"col-sm-11 col-sm-offset-1\">\n        <ul id=\"AmpMenus\" class=\"nav navbar-nav menus\">\n\n          <!-- File -->\n\n        </ul>\n        <div class=\"clearfix\"></div>\n      </div>\n    </div>\n    <!-- Collect the nav links, forms, and other content for toggling -->\n  </div><!-- /.container-fluid -->\n</nav>\n\n<%\n  } %>\n";
var MenuCollection = require('../collections/amp-menus-collection.js');
var MenuModel = require('../models/amp-menus-model.js');

var SubmenuView = require('./submenu-compositeview.js');
var AboutView = require('./about-view.js');


module.exports = Backbone.View.extend({
  el: '#amp-header',
  appendEl: '#AmpMenus',
  template: _.template(Template),
  menuRendered: new $.Deferred(),
  events: {
    'click #show_login_pop': 'openLoginBox'
  },

  initialize: function(options) {
    this.collection = new MenuCollection();
    this.translator = options.translator;
    this.showLogin = options.showLogin;
    this.useSingleRowHeader = options.useSingleRowHeader;
    this.loginDropdown = !!options.loginDropdown;
    var self = this;
    this.collection.fetch().then(function() {
      self.render();
    });
    this.firstRender = true;
    this.about = new AboutView(options);
    _.bindAll(this, 'addOne', 'addAll', 'showAbout');

  },

  addAll: function() {
    this.collection.each(this.addOne);
    this.menuRendered.resolve();
  },

  addOne: function(model) {
    view = new SubmenuView({
      model: model
    });
    this.listenTo(view, 'showAbout', this.showAbout);
    var self = this;
    this.listenTo(view, 'switchLanguage', function(lng) {
      self.translator.setLanguage(lng.language).always(function(data, textStatus, jqXHR) {
    	  if (textStatus !== "error") {
    		  location.reload();
    	  } else {
    		  // AMP-21714: For some unknown reason there are 2 async calls to the endpoint and FF sometimes takes the error from the 1st call.
        	  self.translator.setLanguage(lng.language).always(function(data, textStatus, jqXHR) {
    			  location.reload();
    		  });
    	  }
      });
    });
    view.render();
    $(this.appendEl).append(view.el);
  },

  render: function() {
    var self = this;
    if (this.firstRender) {
      this.$el.html(this.template({
        showLogin: self.showLogin,
        loginDropdown: self.loginDropdown,
        useSingleRowHeader: self.useSingleRowHeader
      }));
      this.addAll();
      this.firstRender = false;
      //Ashamed still, I'm forced to this, because the form comes from `loginWidget3.js` and I'm too afraid to touch it
      $('#show_login_pop_box').insertBefore('#show_login_pop');
      $('#logincontainer').insertAfter('#show_login_pop');
    }

    return this;
  },

  showAbout: function() {
    if ($('#about-popup').length == 0) {
      this.$el.parent().append(this.about.render().el);
    }
    if (typeof $().modal !== 'function') {
      $.noConflict();
    }
    $('#about-popup').modal({
      show: true,
      backdrop: false
    });
    this.translator.translateDOM($('#about-popup')[0]);
    return false;
  },

  openLoginBox: function() {
    $("div#show_login_pop_box").show();
    $("#j_username").focus();
  }
});

},{"../collections/amp-menus-collection.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\collections\\amp-menus-collection.js","../models/amp-menus-model.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\models\\amp-menus-model.js","./about-view.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\views\\about-view.js","./submenu-compositeview.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\views\\submenu-compositeview.js","backbone":"backbone","bootstrap/dist/js/bootstrap":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\node_modules\\bootstrap\\dist\\js\\bootstrap.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\src\\views\\submenu-compositeview.js":[function(require,module,exports){

var Backbone = require('backbone');
var _ = require('underscore');
var Template = "<%\n  /* Prepare the A tag at top level menus */\n  if (!obj.url) {\n      obj.url = '#';\n      obj.className = 'dropdown-toggle';\n      obj.dataToggle = 'data-toggle=\"dropdown\"';\n    }\n    else {\n      obj.className = '';\n      obj.dataToggle = '';\n    }\n\n    if (obj.tab) {\n      obj.tabTarget = 'target=\"_blank\"';\n    }\n    else {\n      obj.tabTarget = '';\n    }\n    %>\n<%\n/* TODO escape the code in HTML */\n%>\n<a href=\"<%= url %>\" class=\"<%= className %>\" <%= dataToggle %> <%= obj.tabTarget %> >\n  <span class=\"dropdown-text\" title=\"<%= obj.name.trim() %>\"><%= obj.name.trim() %>&nbsp;</span><% if (obj.children && obj.children.length > 0) { %><span class=\"caret\"></span><% } %>\n</a>\n<% if (obj.children && obj.children.length !== 0) { %>\n  <ul class=\"children dropdown-menu\" role=\"menu\">\n  <% _.each(obj.children, function(model) { %>\n\n    <%\n      /* Prepare the A tag at second level menus */\n      if (model.children && model.children.length !== 0) {\n        model.dropdownSubmenu = 'dropdown-submenu';\n       };\n\n       if (!model.tooltip) {\n         model.tooltip = '';\n       };\n       var elementClass = '2nd-level-item';\n       if (model.language) {\n\t\t\t elementClass = elementClass+ ' language';\n\t   }\n       if (model.popup) {\n       \t elementClass = elementClass + ' popup';\n       }\n       if (model.tab) {\n         model.tabTarget = 'target=\"_blank\"';\n       } else {\n         model.tabTarget = '';\n       }\n       var elementUrl = model.url;\n       if (model.post === true) {\n         elementUrl = 'javascript:switchTranslation (\"'+elementUrl+'\")';\n\n       }\n       if (!model.url) {\n        elementUrl = 'javascript:;';\n       }\n       /* if it doesn't have children, nor url. then it is the About */\n       if (!model.url && !model.children) {\n       elementClass = elementClass + ' about-amp';\n       }\n    %>\n\n    <li class='dropdown <%= model.dropdownSubmenu %>' >\n    <a href='<%=  elementUrl %>' title=\"<%= model.tooltip %>\" onclick=\"return canExit()\" class=\"<%= elementClass %>\" <%= model.tabTarget %> ><%= model.name %></a>\n\n    <%\n      if (model.children && model.children.length !== 0) {\n     %>\n\n      <ul class=\"children dropdown-menu scrollable-menu\" role=\"menu\">\n      <% _.each(model.children, function(submodel) { %>\n\n        <%\n          /* Prepare the A tag at third level menus */\n          if (!submodel.url) {\n            submodel.url = '#';\n          };\n\t\t  var itemClass = '3rd-level-item';\n\t\t  if (submodel.language) {\n\t\t\t itemClass = itemClass+ ' language';\n\t\t   }\n\t\t  if (!submodel.tooltip) {\n            submodel.tooltip = '';\n          };\n\n          if (submodel.tab) {\n            submodel.tabTarget='target=\"_blank\"';\n          } else {\n            submodel.tabTarget = '';\n          };\n        %>\n\n        <li class=\"menu-item\"><a href=\"<%= submodel.url %>\" onclick=\"return canExit()\" class=\"<%= itemClass %>\" <%= submodel.tabTarget %> title=\"<%= submodel.tooltip %>\"><%= submodel.name %></a></li>\n\n      <% }) %>\n      </ul>\n    <% } %>\n\n    </li>\n\n  <% }); %>\n  </ul>\n<% }%>\n<!--\n<li class=\"menu-item dropdown dropdown-submenu\"><a class=\"dropdown-toggle\" data-toggle=\"dropdown\">\n<ul class=\"children dropdown-menu scrollable-menu\" role=\"menu\">\n      <li class=\"menu-item first-of-type\" id=\"yui-gen4\" groupindex=\"0\" index=\"0\">\n  <a class=\"yuiampmenuitemlabel yuimenuitemlabel\" href=\"/selectTeam.do?id=680\" onclick=\"return canExit()\">\n    Academy of Sciences\n  </a>\n</li>--!>\n";


module.exports = Backbone.View.extend({
  tagName: 'li',
  className: 'dropdown',
  events: {
    'click .language': 'switchLanguage',
    'click .popup': 'openPopup',
    'click .about-amp': 'about'
  },

  template: _.template(Template),

  initialize:function(options) {
    _.bindAll(this, 'render','switchLanguage','about');
  },

  render: function() {
      var self = this;
      this.$el.html(this.template(self.model.attributes));

      return this;
    },
   switchLanguage:function (event) {
	   var index = event.currentTarget.href.lastIndexOf ('/');
	   var lng = event.currentTarget.href.substr (index +1);
	   //if the SwithLanguageMenu exists, let the jsp handle how to change language.
	   //TODO trigger an event and handle on the jsp
	   if (typeof SwitchLanguageMenu !== 'undefined' && $.isFunction(SwitchLanguageMenu)) {
		   event.preventDefault();
		   var url = "/translation/switchLanguage.do?code="+lng+"&rfr=";
		   SwitchLanguageMenu (url);
	   }
	   else {
		   this.trigger ('switchLanguage',{language:lng});
	   }
	   /*var self = this;
	   this.Translator.setLanguage(lng).then(function() {
		   self.Translator.translateDOM(document); 
       });*/
	  
   },
   openPopup:function (event) {
	   window.name = "opener" + new Date().getTime();
	   var wndWidth = 768; 
	   var wndHeight = 1024;
	   var t = ((screen.width)-768)/2;
	   var l = ((screen.height)-1024)/2;
	   var wparams = "height=" + wndHeight + ",width=" + wndWidth + ",top=" + l + ",left=" + t +",menubar=no,scrollbars=yes";
	   popupPointer = window.open(event.currentTarget.href, "forumPopup", wparams);
	   event.preventDefault();
	   return popupPointer;
   },
   about:function (event) {
	   this.trigger ('showAbout',{});
	   return false;
   }

});


},{"backbone":"backbone","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\bootstrap\\dist\\js\\bootstrap.js":[function(require,module,exports){
module.exports=require("C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\node_modules\\bootstrap\\dist\\js\\bootstrap.js")
},{"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\node_modules\\bootstrap\\dist\\js\\bootstrap.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-boilerplate\\node_modules\\bootstrap\\dist\\js\\bootstrap.js"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\jquery-ui\\core.js":[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Core 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.4",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

})( jQuery );

},{"jquery":"jquery"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\jquery-ui\\datepicker.js":[function(require,module,exports){
var jQuery = require('jquery');
require('./core');

/*!
 * jQuery UI Datepicker 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/datepicker/
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.10.4" } });

var PROP_NAME = "datepicker",
	instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[""] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: ["January","February","March","April","May","June",
			"July","August","September","October","November","December"], // Names of months for drop-down and formatting
		monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
		dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
		dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
		dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional[""]);
	this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function(target, settings) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = (nodeName === "div" || nodeName === "span");
		if (!target.id) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {});
		if (nodeName === "input") {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName)) {
			return;
		}
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp);
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var showOn, buttonText, buttonImage,
			appendText = this._get(inst, "appendText"),
			isRTL = this._get(inst, "isRTL");

		if (inst.append) {
			inst.append.remove();
		}
		if (appendText) {
			inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
			input[isRTL ? "before" : "after"](inst.append);
		}

		input.unbind("focus", this._showDatepicker);

		if (inst.trigger) {
			inst.trigger.remove();
		}

		showOn = this._get(inst, "showOn");
		if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		}
		if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
			buttonText = this._get(inst, "buttonText");
			buttonImage = this._get(inst, "buttonImage");
			inst.trigger = $(this._get(inst, "buttonImageOnly") ?
				$("<img/>").addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$("<button type='button'></button>").addClass(this._triggerClass).
					html(!buttonImage ? buttonText : $("<img/>").attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? "before" : "after"](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
					$.datepicker._hideDatepicker();
				} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else {
					$.datepicker._showDatepicker(input[0]);
				}
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, "autoSize") && !inst.inline) {
			var findMax, max, maxI, i,
				date = new Date(2009, 12 - 1, 20), // Ensure double digits
				dateFormat = this._get(inst, "dateFormat");

			if (dateFormat.match(/[DM]/)) {
				findMax = function(names) {
					max = 0;
					maxI = 0;
					for (i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					"monthNames" : "monthNamesShort"))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
			}
			inst.input.attr("size", this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName)) {
			return;
		}
		divSpan.addClass(this.markerClassName).append(inst.dpDiv);
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if (!inst) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $("<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>");
			this._dialogInput.keydown(this._doKeyDown);
			$("body").append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI) {
			$.blockUI(this.dpDiv);
		}
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function(target) {
		var nodeName,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName === "input") {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind("focus", this._showDatepicker).
				unbind("keydown", this._doKeyDown).
				unbind("keypress", this._doKeyPress).
				unbind("keyup", this._doKeyUp);
		} else if (nodeName === "div" || nodeName === "span") {
			$target.removeClass(this.markerClassName).empty();
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = false;
			inst.trigger.filter("button").
				each(function() { this.disabled = false; }).end().
				filter("img").css({opacity: "1.0", cursor: ""});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().removeClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = true;
			inst.trigger.filter("button").
				each(function() { this.disabled = true; }).end().
				filter("img").css({opacity: "0.5", cursor: "default"});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().addClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] === target) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function(target, name, value) {
		var settings, date, minDate, maxDate,
			inst = this._getInst(target);

		if (arguments.length === 2 && typeof name === "string") {
			return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name === "all" ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}

		settings = name || {};
		if (typeof name === "string") {
			settings = {};
			settings[name] = value;
		}

		if (inst) {
			if (this._curInst === inst) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker(target, true);
			minDate = this._getMinMaxDate(inst, "min");
			maxDate = this._getMinMaxDate(inst, "max");
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
				inst.settings.minDate = this._formatDate(inst, minDate);
			}
			if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker(target);
				} else {
					this._enableDatepicker(target);
				}
			}
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline) {
			this._setDateFromField(inst, noDefault);
		}
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst(event.target),
			handled = true,
			isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing) {
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv);
						if (sel[0]) {
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
						}

						onSelect = $.datepicker._get(inst, "onSelect");
						if (onSelect) {
							dateStr = $.datepicker._formatDate(inst);

							// trigger custom callback
							onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, "stepBigMonths") :
							-$.datepicker._get(inst, "stepMonths")), "M");
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, "stepBigMonths") :
							+$.datepicker._get(inst, "stepMonths")), "M");
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) {
							$.datepicker._clearDate(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) {
							$.datepicker._gotoToday(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, -7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, +7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		} else {
			handled = false;
		}

		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var chars, chr,
			inst = $.datepicker._getInst(event.target);

		if ($.datepicker._get(inst, "constrainInput")) {
			chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
			chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var date,
			inst = $.datepicker._getInst(event.target);

		if (inst.input.val() !== inst.lastVal) {
			try {
				date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));

				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
			input = $("input", input.parentNode)[0];
		}

		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}

		beforeShow = $.datepicker._get(inst, "beforeShow");
		beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);

		if ($.datepicker._inDialog) { // hide cursor
			input.value = "";
		}
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css("position") === "fixed";
			return !isFixed;
		});

		offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			"static" : (isFixed ? "fixed" : "absolute")), display: "none",
			left: offset.left + "px", top: offset.top + "px"});

		if (!inst.inline) {
			showAnim = $.datepicker._get(inst, "showAnim");
			duration = $.datepicker._get(inst, "duration");
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
			} else {
				inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.focus();
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();

		var origyearshtml,
			numMonths = this._getNumberOfMonths(inst),
			cols = numMonths[1],
			width = 17;

		inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
		if (cols > 1) {
			inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
		}
		inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
			"Class"]("ui-datepicker-multi");
		inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
			"Class"]("ui-datepicker-rtl");

		if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.focus();
		}

		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
			viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var position,
			inst = this._getInst(obj),
			isRTL = this._get(inst, "isRTL");

		while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? "previousSibling" : "nextSibling"];
		}

		position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function(input) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
			return;
		}

		if (this._datepickerShowing) {
			showAnim = this._get(inst, "showAnim");
			duration = this._get(inst, "duration");
			postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
			} else {
				inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
					(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
			}

			if (!showAnim) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get(inst, "onClose");
			if (onClose) {
				onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
			}

			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
				if ($.blockUI) {
					$.unblockUI();
					$("body").append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst) {
			return;
		}

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
				$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var date,
			target = $(id),
			inst = this._getInst(target[0]);

		if (this._get(inst, "gotoCurrent") && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		inst["selected" + (period === "M" ? "Month" : "Year")] =
		inst["draw" + (period === "M" ? "Month" : "Year")] =
			parseInt(select.options[select.selectedIndex].value,10);

		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var inst,
			target = $(id);

		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}

		inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $("a", td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		this._selectDate(target, "");
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var onSelect,
			target = $(id),
			inst = this._getInst(target[0]);

		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input) {
			inst.input.val(dateStr);
		}
		this._updateAlternate(inst);

		onSelect = this._get(inst, "onSelect");
		if (onSelect) {
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		} else if (inst.input) {
			inst.input.trigger("change"); // fire the change event
		}

		if (inst.inline){
			this._updateDatepicker(inst);
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) !== "object") {
				inst.input.focus(); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altFormat, date, dateStr,
			altField = this._get(inst, "altField");

		if (altField) { // update alternate field too
			altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
			date = this._getDate(inst);
			dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ""];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function(date) {
		var time,
			checkDate = new Date(date.getTime());

		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

		time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function (format, value, settings) {
		if (format == null || value == null) {
			throw "Invalid arguments";
		}

		value = (typeof value === "object" ? value.toString() : value + "");
		if (value === "") {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
			shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Extract a number from the string value
			getNumber = function(match) {
				var isDoubled = lookAhead(match),
					size = (match === "@" ? 14 : (match === "!" ? 20 :
					(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
					digits = new RegExp("^\\d{1," + size + "}"),
					num = value.substring(iValue).match(digits);
				if (!num) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			},
			// Extract a name from the string value and convert to an index
			getName = function(match, shortNames, longNames) {
				var index = -1,
					names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
						return [ [k, v] ];
					}).sort(function (a, b) {
						return -(a[1].length - b[1].length);
					});

				$.each(names, function (i, pair) {
					var name = pair[1];
					if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
						index = pair[0];
						iValue += name.length;
						return false;
					}
				});
				if (index !== -1) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},
			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d":
						day = getNumber("d");
						break;
					case "D":
						getName("D", dayNamesShort, dayNames);
						break;
					case "o":
						doy = getNumber("o");
						break;
					case "m":
						month = getNumber("m");
						break;
					case "M":
						month = getName("M", monthNamesShort, monthNames);
						break;
					case "y":
						year = getNumber("y");
						break;
					case "@":
						date = new Date(getNumber("@"));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'")){
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if (iValue < value.length){
			extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if (year === -1) {
			year = new Date().getFullYear();
		} else if (year < 100) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		}

		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim) {
					break;
				}
				month++;
				day -= dim;
			} while (true);
		}

		date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function (format, date, settings) {
		if (!date) {
			return "";
		}

		var iFormat,
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Format a number, with leading zero if necessary
			formatNumber = function(match, value, len) {
				var num = "" + value;
				if (lookAhead(match)) {
					while (num.length < len) {
						num = "0" + num;
					}
				}
				return num;
			},
			// Format a name, short or long as requested
			formatName = function(match, value, shortNames, longNames) {
				return (lookAhead(match) ? longNames[value] : shortNames[value]);
			},
			output = "",
			literal = false;

		if (date) {
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						output += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							output += formatNumber("d", date.getDate(), 2);
							break;
						case "D":
							output += formatName("D", date.getDay(), dayNamesShort, dayNames);
							break;
						case "o":
							output += formatNumber("o",
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case "m":
							output += formatNumber("m", date.getMonth() + 1, 2);
							break;
						case "M":
							output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
							break;
						case "y":
							output += (lookAhead("y") ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'")) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var iFormat,
			chars = "",
			literal = false,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					chars += format.charAt(iFormat);
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if (lookAhead("'")) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt(iFormat);
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() === inst.lastVal) {
			return;
		}

		var dateFormat = this._get(inst, "dateFormat"),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate(inst),
			date = defaultDate,
			settings = this._getFormatConfig(inst);

		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			dates = (noDefault ? "" : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
				var date = new Date();
				date.setDate(date.getDate() + offset);
				return date;
			},
			offsetString = function(offset) {
				try {
					return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						offset, $.datepicker._getFormatConfig(inst));
				}
				catch (e) {
					// Ignore
				}

				var date = (offset.toLowerCase().match(/^c/) ?
					$.datepicker._getDate(inst) : null) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec(offset);

				while (matches) {
					switch (matches[2] || "d") {
						case "d" : case "D" :
							day += parseInt(matches[1],10); break;
						case "w" : case "W" :
							day += parseInt(matches[1],10) * 7; break;
						case "m" : case "M" :
							month += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
						case "y": case "Y" :
							year += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
					}
					matches = pattern.exec(offset);
				}
				return new Date(year, month, day);
			},
			newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
				(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

		newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function(date) {
		if (!date) {
			return null;
		}
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
			this._notifyChange(inst);
		}
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? "" : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, "stepMonths"),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find("[data-handler]").map(function () {
			var handler = {
				prev: function () {
					$.datepicker._adjustDate(id, -stepMonths, "M");
				},
				next: function () {
					$.datepicker._adjustDate(id, +stepMonths, "M");
				},
				hide: function () {
					$.datepicker._hideDatepicker();
				},
				today: function () {
					$.datepicker._gotoToday(id);
				},
				selectDay: function () {
					$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
					return false;
				},
				selectMonth: function () {
					$.datepicker._selectMonthYear(id, this, "M");
					return false;
				},
				selectYear: function () {
					$.datepicker._selectMonthYear(id, this, "Y");
					return false;
				}
			};
			$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
			isRTL = this._get(inst, "isRTL"),
			showButtonPanel = this._get(inst, "showButtonPanel"),
			hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
			navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
			numMonths = this._getNumberOfMonths(inst),
			showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
			stepMonths = this._get(inst, "stepMonths"),
			isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
			currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
				new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get(inst, "prevText");
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));

		prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

		nextText = this._get(inst, "nextText");
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));

		next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

		currentText = this._get(inst, "currentText");
		gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

		controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get(inst, "closeText") + "</button>" : "");

		buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
			(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

		firstDay = parseInt(this._get(inst, "firstDay"),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);

		showWeek = this._get(inst, "showWeek");
		dayNames = this._get(inst, "dayNames");
		dayNamesMin = this._get(inst, "dayNamesMin");
		monthNames = this._get(inst, "monthNames");
		monthNamesShort = this._get(inst, "monthNamesShort");
		beforeShowDay = this._get(inst, "beforeShowDay");
		showOtherMonths = this._get(inst, "showOtherMonths");
		selectOtherMonths = this._get(inst, "selectOtherMonths");
		defaultDate = this._getDefaultDate(inst);
		html = "";
		dow;
		for (row = 0; row < numMonths[0]; row++) {
			group = "";
			this.maxRows = 4;
			for (col = 0; col < numMonths[1]; col++) {
				selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				cornerClass = " ui-corner-all";
				calender = "";
				if (isMultiMonth) {
					calender += "<div class='ui-datepicker-group";
					if (numMonths[1] > 1) {
						switch (col) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
							case numMonths[1]-1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
					(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
				for (dow = 0; dow < 7; dow++) { // days of the week
					day = (dow + firstDay) % 7;
					thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
						"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				}
				leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += "<tr>";
					tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get(inst, "calculateWeek")(printDate) + "</td>");
					for (dow = 0; dow < 7; dow++) { // create date picker days
						daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
						otherMonth = (printDate.getMonth() !== drawMonth);
						unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += "<td class='" +
							((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
							(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
							((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "") + // highlight selected day
							(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
							(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
							(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
							(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
							(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
							(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
							(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
							((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get(inst, "changeMonth"),
			changeYear = this._get(inst, "changeYear"),
			showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// month selection
		if (secondary || !changeMonth) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
		} else {
			inMinYear = (minDate && minDate.getFullYear() === drawYear);
			inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
					monthHtml += "<option value='" + month + "'" +
						(month === drawMonth ? " selected='selected'" : "") +
						">" + monthNamesShort[month] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if (!showMonthAfterYear) {
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
		}

		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if (secondary || !changeYear) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {
				// determine range of years to display
				years = this._get(inst, "yearRange").split(":");
				thisYear = new Date().getFullYear();
				determineYear = function(value) {
					var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				year = determineYear(years[0]);
				endYear = Math.max(year, determineYear(years[1] || ""));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for (; year <= endYear; year++) {
					inst.yearshtml += "<option value='" + year + "'" +
						(year === drawYear ? " selected='selected'" : "") +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get(inst, "yearSuffix");
		if (showMonthAfterYear) {
			html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period === "Y" ? offset : 0),
			month = inst.drawMonth + (period === "M" ? offset : 0),
			day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
			date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period === "M" || period === "Y") {
			this._notifyChange(inst);
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			newDate = (minDate && date < minDate ? minDate : date);
		return (maxDate && newDate > maxDate ? maxDate : newDate);
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, "onChangeMonthYear");
		if (onChange) {
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, "numberOfMonths");
		return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst),
			date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

		if (offset < 0) {
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		}
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			minYear = null,
			maxYear = null,
			years = this._get(inst, "yearRange");
			if (years){
				yearSplit = years.split(":");
				currentYear = new Date().getFullYear();
				minYear = parseInt(yearSplit[0], 10);
				maxYear = parseInt(yearSplit[1], 10);
				if ( yearSplit[0].match(/[+\-].*/) ) {
					minYear += currentYear;
				}
				if ( yearSplit[1].match(/[+\-].*/) ) {
					maxYear += currentYear;
				}
			}

		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()) &&
			(!minYear || date.getFullYear() >= minYear) &&
			(!maxYear || date.getFullYear() <= maxYear));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, "shortYearCutoff");
		shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
			monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day === "object" ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.delegate(selector, "mouseout", function() {
			$(this).removeClass("ui-state-hover");
			if (this.className.indexOf("ui-datepicker-prev") !== -1) {
				$(this).removeClass("ui-datepicker-prev-hover");
			}
			if (this.className.indexOf("ui-datepicker-next") !== -1) {
				$(this).removeClass("ui-datepicker-next-hover");
			}
		})
		.delegate(selector, "mouseover", function(){
			if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
				$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
				$(this).addClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).addClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).addClass("ui-datepicker-next-hover");
				}
			}
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props) {
		if (props[name] == null) {
			target[name] = props[name];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick);
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ($("#"+$.datepicker._mainDivId).length === 0) {
		$("body").append($.datepicker.dpDiv);
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	return this.each(function() {
		typeof options === "string" ?
			$.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.10.4";

})(jQuery);

},{"./core":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\jquery-ui\\core.js","jquery":"jquery"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\jquery-ui\\draggable.js":[function(require,module,exports){
var jQuery = require('jquery');
require('./core');
require('./mouse');
require('./widget');

/*!
 * jQuery UI Draggable 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	version: "1.10.4",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
			this.element[0].style.position = "relative";
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
			.css({
				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent();
		this.offsetParent = this.helper.offsetParent();
		this.offsetParentCssPosition = this.offsetParent.css( "position" );

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		//Reset scroll cache
		this.offset.scroll = false;

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.offsetParentCssPosition === "fixed" ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		if ( this.options.helper === "original" && !$.contains( this.element[ 0 ].ownerDocument, this.element[ 0 ] ) ) {
			return false;
		}

		if((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

		if(!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		//This needs to be actually done for all browsers, since pageX/pageY includes this information
		//Ugly IE fix
		if((this.offsetParent[0] === document.body) ||
			(this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var over, c, ce,
			o = this.options;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document") {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if( !ce ) {
			return;
		}

		over = c.css( "overflow" ) !== "hidden";

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ) ,
			( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
			( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
		];
		this.relative_container = c;
	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top ) * mod )
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left ) * mod )
			)
		};

	},

	_generatePosition: function(event) {

		var containment, co, top, left,
			o = this.options,
			scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent,
			pageX = event.pageX,
			pageY = event.pageY;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( this.originalPosition ) {
			if ( this.containment ) {
				if ( this.relative_container ){
					co = this.relative_container.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				}
				else {
					containment = this.containment;
				}

				if(event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		//The absolute position has to be recalculated after plugins
		if(type === "drag") {
			this.positionAbs = this._convertPositionTo("absolute");
		}
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("ui-draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, "ui-sortable");
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("ui-draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
				if(this.shouldRevert) {
					this.instance.options.revert = this.shouldRevert;
				}

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper === "original") {
					this.instance.currentItem.css({ top: "auto", left: "auto" });
				}

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("ui-draggable"), that = this;

		$.each(inst.sortables, function() {

			var innermostIntersecting = false,
				thisSortable = this;

			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if (this !== thisSortable &&
						this.instance._intersectsWith(this.instance.containerCache) &&
						$.contains(thisSortable.instance.element[0], this.instance.element[0])
					) {
						innermostIntersecting = false;
					}
					return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) {
					this.instance._mouseDrag(event);
				}

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger("out", event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) {
						this.instance.placeholder.remove();
					}

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			}

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function() {
		var t = $("body"), o = $(this).data("ui-draggable").options;
		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function() {
		var o = $(this).data("ui-draggable").options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function() {
		var i = $(this).data("ui-draggable");
		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
			i.overflowOffset = i.scrollParent.offset();
		}
	},
	drag: function( event ) {

		var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {

			if(!o.axis || o.axis !== "x") {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
				}
			}

			if(!o.axis || o.axis !== "y") {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if(!o.axis || o.axis !== "x") {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if(!o.axis || o.axis !== "y") {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function() {

		var i = $(this).data("ui-draggable"),
			o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if(this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function(event, ui) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			inst = $(this).data("ui-draggable"),
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top;
			b = t + inst.snapElements[i].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if(inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
				}
			}

			first = (ts || bs || ls || rs);

			if(o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
				}
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function() {
		var min,
			o = this.data("ui-draggable").options,
			group = $.makeArray($(o.stack)).sort(function(a,b) {
				return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css("zIndex"), 10) || 0;
		$(group).each(function(i) {
			$(this).css("zIndex", min + i);
		});
		this.css("zIndex", (min + group.length));
	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

})(jQuery);

},{"./core":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\jquery-ui\\core.js","./mouse":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\jquery-ui\\mouse.js","./widget":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\jquery-ui\\widget.js","jquery":"jquery"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\jquery-ui\\mouse.js":[function(require,module,exports){
var jQuery = require('jquery');
require('./widget');

/*!
 * jQuery UI Mouse 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.10.4",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown."+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click."+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("."+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});

})(jQuery);

},{"./widget":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\jquery-ui\\widget.js","jquery":"jquery"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\jquery-ui\\widget.js":[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Widget 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

},{"jquery":"jquery"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\collections\\all-filters-collection.js":[function(require,module,exports){
var Backbone = require('backbone');
var _ = require('underscore');
var $ = require('jquery');

var GenericFilterModel = require('../models/generic-filter-model');
var OrgRoleFilterModel = require('../models/org-role-filter-model');
var YearsFilterModel = require('../models/years-filter-model');
var YearsOnlyFilterModel = require('../models/years-only-filter-model');


//TODO: move most code from filters-view here.
module.exports = Backbone.Collection.extend({
  url: '/rest/filters',
  _loaded: null,
  _allDeferreds: [],
  orgCollection: null,
  orgGroupCollection: null,
  orgTypeCollection: null,
  componentCaller: null,

  initialize: function(models,options) {
    this.on('add', this._cleanUpAfterAdd);
    this.load();
    if (options.caller) {
    	componentCaller = options.caller;
    }
  },

  load: function() {
    var self = this;

    if(!this._loaded){
      this._loaded = new $.Deferred();
      this._allDeferreds.push(this._createOrgFilters());

      this.fetch({remove: false}).then(function() {
        // when all child calls are done resolve.
        $.when.apply($, self._allDeferreds)
          .done(self._loaded.resolve)
          .fail(self._loaded.reject);
      }).fail(self._loaded.reject);
    }

    return this._loaded;
  },

  _cleanUpAfterAdd: function(model) {
    var self = this;
    // remove if ui false also catches empty dummy filters we add in 'model' function below.
    if (!model.get('ui')) {
      self.remove(model);
    }
    //remove if the endpoint returns the filter type (dashboard,tabs,reports and/or GIS) for which
    //the model should be visible and the caller is not of the same tpe
    
    if (model.get('filterType')) {
    	// CONSTANTIN: here filtering irrelevant columns for the set filter type are filtered out
    	var isOfRequiredType = _.some( model.get('filterType'), function( type ) {
    	    return type === componentCaller || type === "ALL";
    	});
    	//console.log("decided whether to show column " + model.get("name") + ": " + isOfRequiredType)
    	if (!isOfRequiredType) {
    		self.remove (model);
    	}
    }
    // Expose this field for later usage.
    this.componentCaller = componentCaller;
  },


//  contains: function(key) {
//	  if ()
//  },
  
  parse: function(data) {
    //only keep filters with ui == true;
    data = _.filter(data, function(obj) {
      return obj.ui;
    });

    //remove orgs, groups, and types, because they are not filters on their own.
    // We use them down below.
    data = _.filter(data, function(obj) {
      return (obj.endpoint !== '/rest/filters/org-groups' &&
        obj.endpoint !== '/rest/filters/org-types' &&
        obj.endpoint !== '/rest/filters/org-roles' &&
        obj.endpoint !== '/rest/filters/orgs');
    });


    return data;
  },


  model: function(attrs, options) {
    var tmpModel = null;

    // slightly unconventional, but model is special case since it's called with
    // new so 'this' wont be the collection.
    var self = options.collection;

    // switch for model polymorphism.
    switch (attrs.id) {
      case 'Programs':
      case 'Sectors':
        self._allDeferreds.push(self._goOneDeeper(self, attrs));
        //tmp hack because we need to return something.
        tmpModel = new Backbone.Model({ui:false});
        break;
        
      default:
    	  if (attrs.id == 'Dates' || (attrs.id.length > 4 && attrs.id.substring(attrs.id.length - 4) == 'Date')) {
    		  tmpModel = new YearsFilterModel(attrs);  // hacky but less hacky than enumerating them. Long term solution -> the endpoint should return a field telling the type of a field
    	  } else if (attrs.id == 'computedYear') {
    		  tmpModel = new YearsOnlyFilterModel(attrs);
    	  } else {
    		  tmpModel = new GenericFilterModel(attrs);
    		  self._allDeferreds.push(tmpModel.getTree());
    	  }
    }

    return tmpModel;
  },

  // get endpoint's children and load them into self...
  _goOneDeeper: function(self, attrs) {
    var url = attrs.endpoint;
    var deferred = $.Deferred();
    var tmpDeferreds = [];

    var tmpCollection = new Backbone.Collection();
    tmpCollection.url = url;
    tmpCollection.fetch().then(function(data) {
      _.each(data, function(APIFilter) {
        var tmpModel = new GenericFilterModel({
          url: url + '/' + APIFilter.id,
          name: APIFilter.name,
          tab: APIFilter.tab,
          ui: true,
          group: attrs.id,
          empty: false
        });
        self.add(tmpModel);
        tmpDeferreds.push(tmpModel.getTree());
      });

      if (_.isEmpty(data)) {
        console.warn('Filters API returned empty', url);
        // Create empty model so the view doesnt fail.
        var tmpModel = new GenericFilterModel({
            url: url,
            name: attrs.name,
            ui: true,
            group: attrs.id,
            empty: true
          });
          self.add(tmpModel);
          tmpDeferreds.push(tmpModel.getTree());
      }
      
      $.when.apply($, tmpDeferreds).then(function() {
          deferred.resolve();
        });

    });

    return deferred;
  },


// ---------------------
// Special org and donor specific code since it has special behaviour
// ---------------------

  _createOrgFilters:function() {
    var self = this;

    // Create 'joins' for each type add ref to groups, and for each group add refs to orgs.
    return this._fetchOrgCollections().then(function() {

      // jsonify orgs and set them as children in groups.

      self.makeTreeHelper(self.orgGroupCollection, self.orgCollection, 'orgIds', 'children');


      // For each role create a filter with collection of just orgs that match.
      self.orgRolesCollection.each(function(role) {
        var tmpJSON = role.toJSON();

        // treat donor differently...
        if (role.get('name') === 'Donor') {
          self.makeTreeHelper(self.orgTypeCollection, self.orgGroupCollection, 'groupIds', 'children');
          // Create tree rootNode and raw JSON.
          _.extend(tmpJSON,
            {
              ui: true,
              group: 'Donor',
              tab: 'Funding Organizations',
              data: self.orgTypeCollection.toJSON()
            });

          // filter orgs...
          tmpJSON.data = self._filterDonorOrgs(tmpJSON.data, role.id);
        } else {
          // Create tree rootNode and raw JSON.
          _.extend(tmpJSON,
            {
              ui: true,
              group: 'Role', //TODO: ?should this be 'Role' or role.id or role.get('name')?
              tab: 'All Agencies',
              data: self.orgGroupCollection.toJSON()
            });

          //remove all orgs that don't belong in this role
          tmpJSON.data = self._filterOrgs(tmpJSON.data, role.id);
        }

        if (tmpJSON.data.length > 0) {
        	//The role name is Donor and the back end, for donor, is expecting either Donor Id or Donor Agency
          var currentFilterId = role.get('name') + (role.get('name') === 'Donor'? " Agency":"");
          tmpJSON.data = self._setFilterId(tmpJSON.data, currentFilterId);
          self.add(new OrgRoleFilterModel(tmpJSON));
        }
      });

      //only needed for donor if we want to do special listening....:
      // self.joinHelper(self.orgTypeCollection, self.orgGroupCollection, 'groupIds', 'groups');
      // self.joinHelper(self.orgGroupCollection, self.orgCollection, 'orgIds', 'orgs');
    });
  },

  // explicitly sets the filter id on all the orgs.
  _setFilterId: function(collection, filterId){
    var self = this;
    _.each(collection, function(org) {
      //only set filterId on orgs, not group or type, or it will cause bugs.
      if(org.rolesIds){
        org.filterId = filterId;
      }
      if(org.children){
        org.children = self._setFilterId(org.children, filterId);
      }
    });

    return collection;
  },



  // filter orgs tree to only orgs that appear as the given roleID
  _filterOrgs: function(orgGroupsJSON, roleID) {
    orgGroupsJSON = _.filter(orgGroupsJSON, function(group) {
      group.children = _.filter(group.children, function(org) {
        return (org.rolesIds.indexOf(roleID) > -1);
      });
      group.isSelectable = false; //stops tree from creating 'unkown' children.
      return (group.children.length > 0);
    });
    return orgGroupsJSON;
  },


	  // special case for donor tree, since it has type
	_filterDonorOrgs : function(orgTypesJSON, roleID) {
		var self = this;
		orgTypesJSON = _.filter(orgTypesJSON, function(type) {
			type.children = self._filterOrgs(type.children, roleID);
	
			_.each(type.children, function(group) {
				group.filterId = 'Donor Group';
			});	

			type.filterId = 'Donor Type';
			type.isSelectable = false; // stops tree from creating 'unkown' children.
			return (type.children.length > 0);
		});
		return orgTypesJSON;
	},

    // 1. get all orgs, groups, types, and roles
  _fetchOrgCollections: function() {
    var filterDeferreds = [];

    this.orgCollection = new Backbone.Collection();
    this.orgCollection.url = '/rest/filters/orgs';
    filterDeferreds.push(this.orgCollection.fetch());

    this.orgGroupCollection = new Backbone.Collection();
    this.orgGroupCollection.url = '/rest/filters/org-groups';
    filterDeferreds.push(this.orgGroupCollection.fetch());

    this.orgTypeCollection = new Backbone.Collection();
    this.orgTypeCollection.url = '/rest/filters/org-types';
    filterDeferreds.push(this.orgTypeCollection.fetch());

    this.orgRolesCollection = new Backbone.Collection();
    this.orgRolesCollection.url = '/rest/filters/org-roles';
    filterDeferreds.push(this.orgRolesCollection.fetch({}));

    return $.when.apply($, filterDeferreds);
  },


  // Adds references to collectionB into collectionA joining on given foreign key
  // TODO: option to add bi-directional reference.
  joinHelper: function(collectionA, collectionB, keyForForeignID, keyForCollectionDestination) {
    collectionA.each(function(modelA) {
      var idsToJoin = modelA.get(keyForForeignID);
      var tempCollection = collectionB.filter(function(modelB) {
        return _.indexOf(idsToJoin, modelB.get('id')) >= 0;
      });

      modelA.set(keyForCollectionDestination, tempCollection);
    });
  },

  makeTreeHelper : function(parentCollection, childCollection, keyForForeignID, keyForCollectionDestination) {
	  var self = this;
	  var donorRole = _.filter(self.orgRolesCollection.models, function(item) {
			return item.get('name') === 'Donor';
		})[0];
		parentCollection.each(function(parent) {
			var idsToJoin = parent.get(keyForForeignID);
			var tempCollection = childCollection.toJSON();
			
			// Because of the business logic of old filters, if an organization has been used as a funding org
			// (present in amp_funding) then we need to
			// add it to the list of 'Donors' no matter which is the 'role' of that organization, so in order to
			// make it appear in the tree we also need to
			// add the 'DN' rol to it, otherwise it will be ignored even if its in tempCollection.
			tempCollection = _.each(tempCollection,function(aux) {
				if (aux.hasFundings === true && aux.rolesIds != undefined) {
					aux.rolesIds.push(donorRole);
				}
			});
			tempCollection = _.filter(tempCollection,function(val) {
				return _.contains(idsToJoin, val.id);
			});
			parent.set(keyForCollectionDestination, tempCollection);
		});
	}
});

},{"../models/generic-filter-model":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\generic-filter-model.js","../models/org-role-filter-model":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\org-role-filter-model.js","../models/years-filter-model":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\years-filter-model.js","../models/years-only-filter-model":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\years-only-filter-model.js","backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\collections\\settings-collection.js":[function(require,module,exports){

var Deferred = require('jquery').Deferred;
var _ = require('underscore');
var Backbone = require('backbone');
var Setting = require('../models/setting');

module.exports  = Backbone.Collection.extend({
		model : Setting,
		url : '/rest/amp/settings'
});


},{"../models/setting":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\setting.js","backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\lib\\jquery-ui-i18n.js":[function(require,module,exports){
/*! jQuery UI - v1.10.4 - 2014-01-17
* http://jqueryui.com
* Includes: jquery.ui.datepicker-af.js, jquery.ui.datepicker-ar-DZ.js, jquery.ui.datepicker-ar.js, jquery.ui.datepicker-az.js, jquery.ui.datepicker-be.js, jquery.ui.datepicker-bg.js, jquery.ui.datepicker-bs.js, jquery.ui.datepicker-ca.js, jquery.ui.datepicker-cs.js, jquery.ui.datepicker-cy-GB.js, jquery.ui.datepicker-da.js, jquery.ui.datepicker-de.js, jquery.ui.datepicker-el.js, jquery.ui.datepicker-en-AU.js, jquery.ui.datepicker-en-GB.js, jquery.ui.datepicker-en-NZ.js, jquery.ui.datepicker-eo.js, jquery.ui.datepicker-es.js, jquery.ui.datepicker-et.js, jquery.ui.datepicker-eu.js, jquery.ui.datepicker-fa.js, jquery.ui.datepicker-fi.js, jquery.ui.datepicker-fo.js, jquery.ui.datepicker-fr-CA.js, jquery.ui.datepicker-fr-CH.js, jquery.ui.datepicker-fr.js, jquery.ui.datepicker-gl.js, jquery.ui.datepicker-he.js, jquery.ui.datepicker-hi.js, jquery.ui.datepicker-hr.js, jquery.ui.datepicker-hu.js, jquery.ui.datepicker-hy.js, jquery.ui.datepicker-id.js, jquery.ui.datepicker-is.js, jquery.ui.datepicker-it.js, jquery.ui.datepicker-ja.js, jquery.ui.datepicker-ka.js, jquery.ui.datepicker-kk.js, jquery.ui.datepicker-km.js, jquery.ui.datepicker-ko.js, jquery.ui.datepicker-ky.js, jquery.ui.datepicker-lb.js, jquery.ui.datepicker-lt.js, jquery.ui.datepicker-lv.js, jquery.ui.datepicker-mk.js, jquery.ui.datepicker-ml.js, jquery.ui.datepicker-ms.js, jquery.ui.datepicker-nb.js, jquery.ui.datepicker-nl-BE.js, jquery.ui.datepicker-nl.js, jquery.ui.datepicker-nn.js, jquery.ui.datepicker-no.js, jquery.ui.datepicker-pl.js, jquery.ui.datepicker-pt-BR.js, jquery.ui.datepicker-pt.js, jquery.ui.datepicker-rm.js, jquery.ui.datepicker-ro.js, jquery.ui.datepicker-ru.js, jquery.ui.datepicker-sk.js, jquery.ui.datepicker-sl.js, jquery.ui.datepicker-sq.js, jquery.ui.datepicker-sr-SR.js, jquery.ui.datepicker-sr.js, jquery.ui.datepicker-sv.js, jquery.ui.datepicker-ta.js, jquery.ui.datepicker-th.js, jquery.ui.datepicker-tj.js, jquery.ui.datepicker-tr.js, jquery.ui.datepicker-uk.js, jquery.ui.datepicker-vi.js, jquery.ui.datepicker-zh-CN.js, jquery.ui.datepicker-zh-HK.js, jquery.ui.datepicker-zh-TW.js
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
/* Afrikaans initialisation for the jQuery UI date picker plugin. */
/* Written by Renier Pretorius. */
/*ALTERED FOR AMP -- ADDED TETUM LOCALE*/
jQuery(function($){
	$.datepicker.regional['af'] = {
		closeText: 'Selekteer',
		prevText: 'Vorige',
		nextText: 'Volgende',
		currentText: 'Vandag',
		monthNames: ['Januarie','Februarie','Maart','April','Mei','Junie',
		'Julie','Augustus','September','Oktober','November','Desember'],
		monthNamesShort: ['Jan', 'Feb', 'Mrt', 'Apr', 'Mei', 'Jun',
		'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Des'],
		dayNames: ['Sondag', 'Maandag', 'Dinsdag', 'Woensdag', 'Donderdag', 'Vrydag', 'Saterdag'],
		dayNamesShort: ['Son', 'Maa', 'Din', 'Woe', 'Don', 'Vry', 'Sat'],
		dayNamesMin: ['So','Ma','Di','Wo','Do','Vr','Sa'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['af']);
});

/* Algerian Arabic Translation for jQuery UI date picker plugin. (can be used for Tunisia)*/
/* Mohamed Cherif BOUCHELAGHEM -- cherifbouchelaghem@yahoo.fr */

jQuery(function($){
	$.datepicker.regional['ar-DZ'] = {
		closeText: 'إغلاق',
		prevText: '&#x3C;السابق',
		nextText: 'التالي&#x3E;',
		currentText: 'اليوم',
		monthNames: ['جانفي', 'فيفري', 'مارس', 'أفريل', 'ماي', 'جوان',
		'جويلية', 'أوت', 'سبتمبر','أكتوبر', 'نوفمبر', 'ديسمبر'],
		monthNamesShort: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
		dayNames: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
		dayNamesShort: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
		dayNamesMin: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
		weekHeader: 'أسبوع',
		dateFormat: 'dd/mm/yy',
		firstDay: 6,
  		isRTL: true,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ar-DZ']);
});

/* Arabic Translation for jQuery UI date picker plugin. */
/* Khaled Alhourani -- me@khaledalhourani.com */
/* NOTE: monthNames are the original months names and they are the Arabic names, not the new months name فبراير - يناير and there isn't any Arabic roots for these months */
jQuery(function($){
	$.datepicker.regional['ar'] = {
		closeText: 'إغلاق',
		prevText: '&#x3C;السابق',
		nextText: 'التالي&#x3E;',
		currentText: 'اليوم',
		monthNames: ['كانون الثاني', 'شباط', 'آذار', 'نيسان', 'مايو', 'حزيران',
		'تموز', 'آب', 'أيلول',	'تشرين الأول', 'تشرين الثاني', 'كانون الأول'],
		monthNamesShort: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
		dayNames: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
		dayNamesShort: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
		dayNamesMin: ['ح', 'ن', 'ث', 'ر', 'خ', 'ج', 'س'],
		weekHeader: 'أسبوع',
		dateFormat: 'dd/mm/yy',
		firstDay: 6,
  		isRTL: true,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ar']);
});

/* Azerbaijani (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Jamil Najafov (necefov33@gmail.com). */
jQuery(function($) {
	$.datepicker.regional['az'] = {
		closeText: 'Bağla',
		prevText: '&#x3C;Geri',
		nextText: 'İrəli&#x3E;',
		currentText: 'Bugün',
		monthNames: ['Yanvar','Fevral','Mart','Aprel','May','İyun',
		'İyul','Avqust','Sentyabr','Oktyabr','Noyabr','Dekabr'],
		monthNamesShort: ['Yan','Fev','Mar','Apr','May','İyun',
		'İyul','Avq','Sen','Okt','Noy','Dek'],
		dayNames: ['Bazar','Bazar ertəsi','Çərşənbə axşamı','Çərşənbə','Cümə axşamı','Cümə','Şənbə'],
		dayNamesShort: ['B','Be','Ça','Ç','Ca','C','Ş'],
		dayNamesMin: ['B','B','Ç','С','Ç','C','Ş'],
		weekHeader: 'Hf',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['az']);
});

/* Belarusian initialisation for the jQuery UI date picker plugin. */
/* Written by Pavel Selitskas <p.selitskas@gmail.com> */
jQuery(function($){
	$.datepicker.regional['be'] = {
		closeText: 'Зачыніць',
		prevText: '&larr;Папяр.',
		nextText: 'Наст.&rarr;',
		currentText: 'Сёньня',
		monthNames: ['Студзень','Люты','Сакавік','Красавік','Травень','Чэрвень',
		'Ліпень','Жнівень','Верасень','Кастрычнік','Лістапад','Сьнежань'],
		monthNamesShort: ['Сту','Лют','Сак','Кра','Тра','Чэр',
		'Ліп','Жні','Вер','Кас','Ліс','Сьн'],
		dayNames: ['нядзеля','панядзелак','аўторак','серада','чацьвер','пятніца','субота'],
		dayNamesShort: ['ндз','пнд','аўт','срд','чцв','птн','сбт'],
		dayNamesMin: ['Нд','Пн','Аў','Ср','Чц','Пт','Сб'],
		weekHeader: 'Тд',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['be']);
});

/* Bulgarian initialisation for the jQuery UI date picker plugin. */
/* Written by Stoyan Kyosev (http://svest.org). */
jQuery(function($){
	$.datepicker.regional['bg'] = {
		closeText: 'затвори',
		prevText: '&#x3C;назад',
		nextText: 'напред&#x3E;',
		nextBigText: '&#x3E;&#x3E;',
		currentText: 'днес',
		monthNames: ['Януари','Февруари','Март','Април','Май','Юни',
		'Юли','Август','Септември','Октомври','Ноември','Декември'],
		monthNamesShort: ['Яну','Фев','Мар','Апр','Май','Юни',
		'Юли','Авг','Сеп','Окт','Нов','Дек'],
		dayNames: ['Неделя','Понеделник','Вторник','Сряда','Четвъртък','Петък','Събота'],
		dayNamesShort: ['Нед','Пон','Вто','Сря','Чет','Пет','Съб'],
		dayNamesMin: ['Не','По','Вт','Ср','Че','Пе','Съ'],
		weekHeader: 'Wk',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['bg']);
});

/* Bosnian i18n for the jQuery UI date picker plugin. */
/* Written by Kenan Konjo. */
jQuery(function($){
	$.datepicker.regional['bs'] = {
		closeText: 'Zatvori',
		prevText: '&#x3C;',
		nextText: '&#x3E;',
		currentText: 'Danas',
		monthNames: ['Januar','Februar','Mart','April','Maj','Juni',
		'Juli','August','Septembar','Oktobar','Novembar','Decembar'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maj','Jun',
		'Jul','Aug','Sep','Okt','Nov','Dec'],
		dayNames: ['Nedelja','Ponedeljak','Utorak','Srijeda','Četvrtak','Petak','Subota'],
		dayNamesShort: ['Ned','Pon','Uto','Sri','Čet','Pet','Sub'],
		dayNamesMin: ['Ne','Po','Ut','Sr','Če','Pe','Su'],
		weekHeader: 'Wk',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['bs']);
});

/* Inicialització en català per a l'extensió 'UI date picker' per jQuery. */
/* Writers: (joan.leon@gmail.com). */
jQuery(function($){
	$.datepicker.regional['ca'] = {
		closeText: 'Tanca',
		prevText: 'Anterior',
		nextText: 'Següent',
		currentText: 'Avui',
		monthNames: ['gener','febrer','març','abril','maig','juny',
		'juliol','agost','setembre','octubre','novembre','desembre'],
		monthNamesShort: ['gen','feb','març','abr','maig','juny',
		'jul','ag','set','oct','nov','des'],
		dayNames: ['diumenge','dilluns','dimarts','dimecres','dijous','divendres','dissabte'],
		dayNamesShort: ['dg','dl','dt','dc','dj','dv','ds'],
		dayNamesMin: ['dg','dl','dt','dc','dj','dv','ds'],
		weekHeader: 'Set',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ca']);
});

/* Czech initialisation for the jQuery UI date picker plugin. */
/* Written by Tomas Muller (tomas@tomas-muller.net). */
jQuery(function($){
	$.datepicker.regional['cs'] = {
		closeText: 'Zavřít',
		prevText: '&#x3C;Dříve',
		nextText: 'Později&#x3E;',
		currentText: 'Nyní',
		monthNames: ['leden','únor','březen','duben','květen','červen',
		'červenec','srpen','září','říjen','listopad','prosinec'],
		monthNamesShort: ['led','úno','bře','dub','kvě','čer',
		'čvc','srp','zář','říj','lis','pro'],
		dayNames: ['neděle', 'pondělí', 'úterý', 'středa', 'čtvrtek', 'pátek', 'sobota'],
		dayNamesShort: ['ne', 'po', 'út', 'st', 'čt', 'pá', 'so'],
		dayNamesMin: ['ne','po','út','st','čt','pá','so'],
		weekHeader: 'Týd',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['cs']);
});

/* Welsh/UK initialisation for the jQuery UI date picker plugin. */
/* Written by William Griffiths. */
jQuery(function($){
	$.datepicker.regional['cy-GB'] = {
		closeText: 'Done',
		prevText: 'Prev',
		nextText: 'Next',
		currentText: 'Today',
		monthNames: ['Ionawr','Chwefror','Mawrth','Ebrill','Mai','Mehefin',
		'Gorffennaf','Awst','Medi','Hydref','Tachwedd','Rhagfyr'],
		monthNamesShort: ['Ion', 'Chw', 'Maw', 'Ebr', 'Mai', 'Meh',
		'Gor', 'Aws', 'Med', 'Hyd', 'Tac', 'Rha'],
		dayNames: ['Dydd Sul', 'Dydd Llun', 'Dydd Mawrth', 'Dydd Mercher', 'Dydd Iau', 'Dydd Gwener', 'Dydd Sadwrn'],
		dayNamesShort: ['Sul', 'Llu', 'Maw', 'Mer', 'Iau', 'Gwe', 'Sad'],
		dayNamesMin: ['Su','Ll','Ma','Me','Ia','Gw','Sa'],
		weekHeader: 'Wy',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['cy-GB']);
});

/* Danish initialisation for the jQuery UI date picker plugin. */
/* Written by Jan Christensen ( deletestuff@gmail.com). */
jQuery(function($){
	$.datepicker.regional['da'] = {
		closeText: 'Luk',
		prevText: '&#x3C;Forrige',
		nextText: 'Næste&#x3E;',
		currentText: 'Idag',
		monthNames: ['Januar','Februar','Marts','April','Maj','Juni',
		'Juli','August','September','Oktober','November','December'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maj','Jun',
		'Jul','Aug','Sep','Okt','Nov','Dec'],
		dayNames: ['Søndag','Mandag','Tirsdag','Onsdag','Torsdag','Fredag','Lørdag'],
		dayNamesShort: ['Søn','Man','Tir','Ons','Tor','Fre','Lør'],
		dayNamesMin: ['Sø','Ma','Ti','On','To','Fr','Lø'],
		weekHeader: 'Uge',
		dateFormat: 'dd-mm-yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['da']);
});

/* German initialisation for the jQuery UI date picker plugin. */
/* Written by Milian Wolff (mail@milianw.de). */
jQuery(function($){
	$.datepicker.regional['de'] = {
		closeText: 'Schließen',
		prevText: '&#x3C;Zurück',
		nextText: 'Vor&#x3E;',
		currentText: 'Heute',
		monthNames: ['Januar','Februar','März','April','Mai','Juni',
		'Juli','August','September','Oktober','November','Dezember'],
		monthNamesShort: ['Jan','Feb','Mär','Apr','Mai','Jun',
		'Jul','Aug','Sep','Okt','Nov','Dez'],
		dayNames: ['Sonntag','Montag','Dienstag','Mittwoch','Donnerstag','Freitag','Samstag'],
		dayNamesShort: ['So','Mo','Di','Mi','Do','Fr','Sa'],
		dayNamesMin: ['So','Mo','Di','Mi','Do','Fr','Sa'],
		weekHeader: 'KW',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['de']);
});

/* Greek (el) initialisation for the jQuery UI date picker plugin. */
/* Written by Alex Cicovic (http://www.alexcicovic.com) */
jQuery(function($){
	$.datepicker.regional['el'] = {
		closeText: 'Κλείσιμο',
		prevText: 'Προηγούμενος',
		nextText: 'Επόμενος',
		currentText: 'Τρέχων Μήνας',
		monthNames: ['Ιανουάριος','Φεβρουάριος','Μάρτιος','Απρίλιος','Μάιος','Ιούνιος',
		'Ιούλιος','Αύγουστος','Σεπτέμβριος','Οκτώβριος','Νοέμβριος','Δεκέμβριος'],
		monthNamesShort: ['Ιαν','Φεβ','Μαρ','Απρ','Μαι','Ιουν',
		'Ιουλ','Αυγ','Σεπ','Οκτ','Νοε','Δεκ'],
		dayNames: ['Κυριακή','Δευτέρα','Τρίτη','Τετάρτη','Πέμπτη','Παρασκευή','Σάββατο'],
		dayNamesShort: ['Κυρ','Δευ','Τρι','Τετ','Πεμ','Παρ','Σαβ'],
		dayNamesMin: ['Κυ','Δε','Τρ','Τε','Πε','Πα','Σα'],
		weekHeader: 'Εβδ',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['el']);
});

/* English/Australia initialisation for the jQuery UI date picker plugin. */
/* Based on the en-GB initialisation. */
jQuery(function($){
	$.datepicker.regional['en-AU'] = {
		closeText: 'Done',
		prevText: 'Prev',
		nextText: 'Next',
		currentText: 'Today',
		monthNames: ['January','February','March','April','May','June',
		'July','August','September','October','November','December'],
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
		'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['en-AU']);
});

/* English/UK initialisation for the jQuery UI date picker plugin. */
/* Written by Stuart. */
jQuery(function($){
	$.datepicker.regional['en-GB'] = {
		closeText: 'Done',
		prevText: 'Prev',
		nextText: 'Next',
		currentText: 'Today',
		monthNames: ['January','February','March','April','May','June',
		'July','August','September','October','November','December'],
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
		'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['en-GB']);
});

/* English/New Zealand initialisation for the jQuery UI date picker plugin. */
/* Based on the en-GB initialisation. */
jQuery(function($){
	$.datepicker.regional['en-NZ'] = {
		closeText: 'Done',
		prevText: 'Prev',
		nextText: 'Next',
		currentText: 'Today',
		monthNames: ['January','February','March','April','May','June',
		'July','August','September','October','November','December'],
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
		'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['en-NZ']);
});

/* Esperanto initialisation for the jQuery UI date picker plugin. */
/* Written by Olivier M. (olivierweb@ifrance.com). */
jQuery(function($){
	$.datepicker.regional['eo'] = {
		closeText: 'Fermi',
		prevText: '&#x3C;Anta',
		nextText: 'Sekv&#x3E;',
		currentText: 'Nuna',
		monthNames: ['Januaro','Februaro','Marto','Aprilo','Majo','Junio',
		'Julio','Aŭgusto','Septembro','Oktobro','Novembro','Decembro'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maj','Jun',
		'Jul','Aŭg','Sep','Okt','Nov','Dec'],
		dayNames: ['Dimanĉo','Lundo','Mardo','Merkredo','Ĵaŭdo','Vendredo','Sabato'],
		dayNamesShort: ['Dim','Lun','Mar','Mer','Ĵaŭ','Ven','Sab'],
		dayNamesMin: ['Di','Lu','Ma','Me','Ĵa','Ve','Sa'],
		weekHeader: 'Sb',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['eo']);
});

/* Inicialización en español para la extensión 'UI date picker' para jQuery. */
/* Traducido por Vester (xvester@gmail.com). */
jQuery(function($){
	$.datepicker.regional['es'] = {
		closeText: 'Cerrar',
		prevText: '&#x3C;Ant',
		nextText: 'Sig&#x3E;',
		currentText: 'Hoy',
		monthNames: ['enero','febrero','marzo','abril','mayo','junio',
		'julio','agosto','septiembre','octubre','noviembre','diciembre'],
		monthNamesShort: ['ene','feb','mar','abr','may','jun',
		'jul','ogo','sep','oct','nov','dic'],
		dayNames: ['domingo','lunes','martes','miércoles','jueves','viernes','sábado'],
		dayNamesShort: ['dom','lun','mar','mié','juv','vie','sáb'],
		dayNamesMin: ['D','L','M','X','J','V','S'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['es']);
});

/* Estonian initialisation for the jQuery UI date picker plugin. */
/* Written by Mart Sõmermaa (mrts.pydev at gmail com). */
jQuery(function($){
	$.datepicker.regional['et'] = {
		closeText: 'Sulge',
		prevText: 'Eelnev',
		nextText: 'Järgnev',
		currentText: 'Täna',
		monthNames: ['Jaanuar','Veebruar','Märts','Aprill','Mai','Juuni',
		'Juuli','August','September','Oktoober','November','Detsember'],
		monthNamesShort: ['Jaan', 'Veebr', 'Märts', 'Apr', 'Mai', 'Juuni',
		'Juuli', 'Aug', 'Sept', 'Okt', 'Nov', 'Dets'],
		dayNames: ['Pühapäev', 'Esmaspäev', 'Teisipäev', 'Kolmapäev', 'Neljapäev', 'Reede', 'Laupäev'],
		dayNamesShort: ['Pühap', 'Esmasp', 'Teisip', 'Kolmap', 'Neljap', 'Reede', 'Laup'],
		dayNamesMin: ['P','E','T','K','N','R','L'],
		weekHeader: 'näd',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['et']);
});

/* Euskarako oinarria 'UI date picker' jquery-ko extentsioarentzat */
/* Karrikas-ek itzulia (karrikas@karrikas.com) */
jQuery(function($){
	$.datepicker.regional['eu'] = {
		closeText: 'Egina',
		prevText: '&#x3C;Aur',
		nextText: 'Hur&#x3E;',
		currentText: 'Gaur',
		monthNames: ['urtarrila','otsaila','martxoa','apirila','maiatza','ekaina',
			'uztaila','abuztua','iraila','urria','azaroa','abendua'],
		monthNamesShort: ['urt.','ots.','mar.','api.','mai.','eka.',
			'uzt.','abu.','ira.','urr.','aza.','abe.'],
		dayNames: ['igandea','astelehena','asteartea','asteazkena','osteguna','ostirala','larunbata'],
		dayNamesShort: ['ig.','al.','ar.','az.','og.','ol.','lr.'],
		dayNamesMin: ['ig','al','ar','az','og','ol','lr'],
		weekHeader: 'As',
		dateFormat: 'yy-mm-dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['eu']);
});

/* Persian (Farsi) Translation for the jQuery UI date picker plugin. */
/* Javad Mowlanezhad -- jmowla@gmail.com */
/* Jalali calendar should supported soon! (Its implemented but I have to test it) */
jQuery(function($) {
	$.datepicker.regional['fa'] = {
		closeText: 'بستن',
		prevText: '&#x3C;قبلی',
		nextText: 'بعدی&#x3E;',
		currentText: 'امروز',
		monthNames: [
			'فروردين',
			'ارديبهشت',
			'خرداد',
			'تير',
			'مرداد',
			'شهريور',
			'مهر',
			'آبان',
			'آذر',
			'دی',
			'بهمن',
			'اسفند'
		],
		monthNamesShort: ['1','2','3','4','5','6','7','8','9','10','11','12'],
		dayNames: [
			'يکشنبه',
			'دوشنبه',
			'سه‌شنبه',
			'چهارشنبه',
			'پنجشنبه',
			'جمعه',
			'شنبه'
		],
		dayNamesShort: [
			'ی',
			'د',
			'س',
			'چ',
			'پ',
			'ج',
			'ش'
		],
		dayNamesMin: [
			'ی',
			'د',
			'س',
			'چ',
			'پ',
			'ج',
			'ش'
		],
		weekHeader: 'هف',
		dateFormat: 'yy/mm/dd',
		firstDay: 6,
		isRTL: true,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['fa']);
});

/* Finnish initialisation for the jQuery UI date picker plugin. */
/* Written by Harri Kilpiö (harrikilpio@gmail.com). */
jQuery(function($){
	$.datepicker.regional['fi'] = {
		closeText: 'Sulje',
		prevText: '&#xAB;Edellinen',
		nextText: 'Seuraava&#xBB;',
		currentText: 'Tänään',
		monthNames: ['Tammikuu','Helmikuu','Maaliskuu','Huhtikuu','Toukokuu','Kesäkuu',
		'Heinäkuu','Elokuu','Syyskuu','Lokakuu','Marraskuu','Joulukuu'],
		monthNamesShort: ['Tammi','Helmi','Maalis','Huhti','Touko','Kesä',
		'Heinä','Elo','Syys','Loka','Marras','Joulu'],
		dayNamesShort: ['Su','Ma','Ti','Ke','To','Pe','La'],
		dayNames: ['Sunnuntai','Maanantai','Tiistai','Keskiviikko','Torstai','Perjantai','Lauantai'],
		dayNamesMin: ['Su','Ma','Ti','Ke','To','Pe','La'],
		weekHeader: 'Vk',
		dateFormat: 'd.m.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['fi']);
});

/* Faroese initialisation for the jQuery UI date picker plugin */
/* Written by Sverri Mohr Olsen, sverrimo@gmail.com */
jQuery(function($){
	$.datepicker.regional['fo'] = {
		closeText: 'Lat aftur',
		prevText: '&#x3C;Fyrra',
		nextText: 'Næsta&#x3E;',
		currentText: 'Í dag',
		monthNames: ['Januar','Februar','Mars','Apríl','Mei','Juni',
		'Juli','August','September','Oktober','November','Desember'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Mei','Jun',
		'Jul','Aug','Sep','Okt','Nov','Des'],
		dayNames: ['Sunnudagur','Mánadagur','Týsdagur','Mikudagur','Hósdagur','Fríggjadagur','Leyardagur'],
		dayNamesShort: ['Sun','Mán','Týs','Mik','Hós','Frí','Ley'],
		dayNamesMin: ['Su','Má','Tý','Mi','Hó','Fr','Le'],
		weekHeader: 'Vk',
		dateFormat: 'dd-mm-yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['fo']);
});

/* Canadian-French initialisation for the jQuery UI date picker plugin. */
jQuery(function ($) {
	$.datepicker.regional['fr-CA'] = {
		closeText: 'Fermer',
		prevText: 'Précédent',
		nextText: 'Suivant',
		currentText: 'Aujourd\'hui',
		monthNames: ['janvier', 'février', 'mars', 'avril', 'mai', 'juin',
			'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'],
		monthNamesShort: ['janv.', 'févr.', 'mars', 'avril', 'mai', 'juin',
			'juil.', 'août', 'sept.', 'oct.', 'nov.', 'déc.'],
		dayNames: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'],
		dayNamesShort: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
		dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
		weekHeader: 'Sem.',
		dateFormat: 'yy-mm-dd',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''
	};
	$.datepicker.setDefaults($.datepicker.regional['fr-CA']);
});

/* Swiss-French initialisation for the jQuery UI date picker plugin. */
/* Written Martin Voelkle (martin.voelkle@e-tc.ch). */
jQuery(function($){
	$.datepicker.regional['fr-CH'] = {
		closeText: 'Fermer',
		prevText: '&#x3C;Préc',
		nextText: 'Suiv&#x3E;',
		currentText: 'Courant',
		monthNames: ['janvier', 'février', 'mars', 'avril', 'mai', 'juin',
			'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'],
		monthNamesShort: ['janv.', 'févr.', 'mars', 'avril', 'mai', 'juin',
			'juil.', 'août', 'sept.', 'oct.', 'nov.', 'déc.'],
		dayNames: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'],
		dayNamesShort: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
		dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
		weekHeader: 'Sm',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['fr-CH']);
});

/* French initialisation for the jQuery UI date picker plugin. */
/* Written by Keith Wood (kbwood{at}iinet.com.au),
			  Stéphane Nahmani (sholby@sholby.net),
			  Stéphane Raimbault <stephane.raimbault@gmail.com> */
jQuery(function($){
	$.datepicker.regional['fr'] = {
		closeText: 'Fermer',
		prevText: 'Précédent',
		nextText: 'Suivant',
		currentText: 'Aujourd\'hui',
		monthNames: ['janvier', 'février', 'mars', 'avril', 'mai', 'juin',
			'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'],
		monthNamesShort: ['janv.', 'févr.', 'mars', 'avril', 'mai', 'juin',
			'juil.', 'août', 'sept.', 'oct.', 'nov.', 'déc.'],
		dayNames: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'],
		dayNamesShort: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
		dayNamesMin: ['D','L','M','M','J','V','S'],
		weekHeader: 'Sem.',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['fr']);
});

/* Galician localization for 'UI date picker' jQuery extension. */
/* Translated by Jorge Barreiro <yortx.barry@gmail.com>. */
jQuery(function($){
	$.datepicker.regional['gl'] = {
		closeText: 'Pechar',
		prevText: '&#x3C;Ant',
		nextText: 'Seg&#x3E;',
		currentText: 'Hoxe',
		monthNames: ['Xaneiro','Febreiro','Marzo','Abril','Maio','Xuño',
		'Xullo','Agosto','Setembro','Outubro','Novembro','Decembro'],
		monthNamesShort: ['Xan','Feb','Mar','Abr','Mai','Xuñ',
		'Xul','Ago','Set','Out','Nov','Dec'],
		dayNames: ['Domingo','Luns','Martes','Mércores','Xoves','Venres','Sábado'],
		dayNamesShort: ['Dom','Lun','Mar','Mér','Xov','Ven','Sáb'],
		dayNamesMin: ['Do','Lu','Ma','Mé','Xo','Ve','Sá'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['gl']);
});

/* Hebrew initialisation for the UI Datepicker extension. */
/* Written by Amir Hardon (ahardon at gmail dot com). */
jQuery(function($){
	$.datepicker.regional['he'] = {
		closeText: 'סגור',
		prevText: '&#x3C;הקודם',
		nextText: 'הבא&#x3E;',
		currentText: 'היום',
		monthNames: ['ינואר','פברואר','מרץ','אפריל','מאי','יוני',
		'יולי','אוגוסט','ספטמבר','אוקטובר','נובמבר','דצמבר'],
		monthNamesShort: ['ינו','פבר','מרץ','אפר','מאי','יוני',
		'יולי','אוג','ספט','אוק','נוב','דצמ'],
		dayNames: ['ראשון','שני','שלישי','רביעי','חמישי','שישי','שבת'],
		dayNamesShort: ['א\'','ב\'','ג\'','ד\'','ה\'','ו\'','שבת'],
		dayNamesMin: ['א\'','ב\'','ג\'','ד\'','ה\'','ו\'','שבת'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: true,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['he']);
});

/* Hindi initialisation for the jQuery UI date picker plugin. */
/* Written by Michael Dawart. */
jQuery(function($){
	$.datepicker.regional['hi'] = {
		closeText: 'बंद',
		prevText: 'पिछला',
		nextText: 'अगला',
		currentText: 'आज',
		monthNames: ['जनवरी ','फरवरी','मार्च','अप्रेल','मई','जून',
		'जूलाई','अगस्त ','सितम्बर','अक्टूबर','नवम्बर','दिसम्बर'],
		monthNamesShort: ['जन', 'फर', 'मार्च', 'अप्रेल', 'मई', 'जून',
		'जूलाई', 'अग', 'सित', 'अक्ट', 'नव', 'दि'],
		dayNames: ['रविवार', 'सोमवार', 'मंगलवार', 'बुधवार', 'गुरुवार', 'शुक्रवार', 'शनिवार'],
		dayNamesShort: ['रवि', 'सोम', 'मंगल', 'बुध', 'गुरु', 'शुक्र', 'शनि'],
		dayNamesMin: ['रवि', 'सोम', 'मंगल', 'बुध', 'गुरु', 'शुक्र', 'शनि'],
		weekHeader: 'हफ्ता',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['hi']);
});

/* Croatian i18n for the jQuery UI date picker plugin. */
/* Written by Vjekoslav Nesek. */
jQuery(function($){
	$.datepicker.regional['hr'] = {
		closeText: 'Zatvori',
		prevText: '&#x3C;',
		nextText: '&#x3E;',
		currentText: 'Danas',
		monthNames: ['Siječanj','Veljača','Ožujak','Travanj','Svibanj','Lipanj',
		'Srpanj','Kolovoz','Rujan','Listopad','Studeni','Prosinac'],
		monthNamesShort: ['Sij','Velj','Ožu','Tra','Svi','Lip',
		'Srp','Kol','Ruj','Lis','Stu','Pro'],
		dayNames: ['Nedjelja','Ponedjeljak','Utorak','Srijeda','Četvrtak','Petak','Subota'],
		dayNamesShort: ['Ned','Pon','Uto','Sri','Čet','Pet','Sub'],
		dayNamesMin: ['Ne','Po','Ut','Sr','Če','Pe','Su'],
		weekHeader: 'Tje',
		dateFormat: 'dd.mm.yy.',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['hr']);
});

/* Hungarian initialisation for the jQuery UI date picker plugin. */
/* Written by Istvan Karaszi (jquery@spam.raszi.hu). */
jQuery(function($){
	$.datepicker.regional['hu'] = {
		closeText: 'bezár',
		prevText: 'vissza',
		nextText: 'előre',
		currentText: 'ma',
		monthNames: ['Január', 'Február', 'Március', 'Április', 'Május', 'Június',
		'Július', 'Augusztus', 'Szeptember', 'Október', 'November', 'December'],
		monthNamesShort: ['Jan', 'Feb', 'Már', 'Ápr', 'Máj', 'Jún',
		'Júl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'],
		dayNames: ['Vasárnap', 'Hétfő', 'Kedd', 'Szerda', 'Csütörtök', 'Péntek', 'Szombat'],
		dayNamesShort: ['Vas', 'Hét', 'Ked', 'Sze', 'Csü', 'Pén', 'Szo'],
		dayNamesMin: ['V', 'H', 'K', 'Sze', 'Cs', 'P', 'Szo'],
		weekHeader: 'Hét',
		dateFormat: 'yy.mm.dd.',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['hu']);
});

/* Armenian(UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Levon Zakaryan (levon.zakaryan@gmail.com)*/
jQuery(function($){
	$.datepicker.regional['hy'] = {
		closeText: 'Փակել',
		prevText: '&#x3C;Նախ.',
		nextText: 'Հաջ.&#x3E;',
		currentText: 'Այսօր',
		monthNames: ['Հունվար','Փետրվար','Մարտ','Ապրիլ','Մայիս','Հունիս',
		'Հուլիս','Օգոստոս','Սեպտեմբեր','Հոկտեմբեր','Նոյեմբեր','Դեկտեմբեր'],
		monthNamesShort: ['Հունվ','Փետր','Մարտ','Ապր','Մայիս','Հունիս',
		'Հուլ','Օգս','Սեպ','Հոկ','Նոյ','Դեկ'],
		dayNames: ['կիրակի','եկուշաբթի','երեքշաբթի','չորեքշաբթի','հինգշաբթի','ուրբաթ','շաբաթ'],
		dayNamesShort: ['կիր','երկ','երք','չրք','հնգ','ուրբ','շբթ'],
		dayNamesMin: ['կիր','երկ','երք','չրք','հնգ','ուրբ','շբթ'],
		weekHeader: 'ՇԲՏ',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['hy']);
});

/* Indonesian initialisation for the jQuery UI date picker plugin. */
/* Written by Deden Fathurahman (dedenf@gmail.com). */
jQuery(function($){
	$.datepicker.regional['id'] = {
		closeText: 'Tutup',
		prevText: '&#x3C;mundur',
		nextText: 'maju&#x3E;',
		currentText: 'hari ini',
		monthNames: ['Januari','Februari','Maret','April','Mei','Juni',
		'Juli','Agustus','September','Oktober','Nopember','Desember'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Mei','Jun',
		'Jul','Agus','Sep','Okt','Nop','Des'],
		dayNames: ['Minggu','Senin','Selasa','Rabu','Kamis','Jumat','Sabtu'],
		dayNamesShort: ['Min','Sen','Sel','Rab','kam','Jum','Sab'],
		dayNamesMin: ['Mg','Sn','Sl','Rb','Km','jm','Sb'],
		weekHeader: 'Mg',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['id']);
});

/* Icelandic initialisation for the jQuery UI date picker plugin. */
/* Written by Haukur H. Thorsson (haukur@eskill.is). */
jQuery(function($){
	$.datepicker.regional['is'] = {
		closeText: 'Loka',
		prevText: '&#x3C; Fyrri',
		nextText: 'Næsti &#x3E;',
		currentText: 'Í dag',
		monthNames: ['Janúar','Febrúar','Mars','Apríl','Maí','Júní',
		'Júlí','Ágúst','September','Október','Nóvember','Desember'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maí','Jún',
		'Júl','Ágú','Sep','Okt','Nóv','Des'],
		dayNames: ['Sunnudagur','Mánudagur','Þriðjudagur','Miðvikudagur','Fimmtudagur','Föstudagur','Laugardagur'],
		dayNamesShort: ['Sun','Mán','Þri','Mið','Fim','Fös','Lau'],
		dayNamesMin: ['Su','Má','Þr','Mi','Fi','Fö','La'],
		weekHeader: 'Vika',
		dateFormat: 'dd.mm.yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['is']);
});

/* Italian initialisation for the jQuery UI date picker plugin. */
/* Written by Antonello Pasella (antonello.pasella@gmail.com). */
jQuery(function($){
	$.datepicker.regional['it'] = {
		closeText: 'Chiudi',
		prevText: '&#x3C;Prec',
		nextText: 'Succ&#x3E;',
		currentText: 'Oggi',
		monthNames: ['Gennaio','Febbraio','Marzo','Aprile','Maggio','Giugno',
			'Luglio','Agosto','Settembre','Ottobre','Novembre','Dicembre'],
		monthNamesShort: ['Gen','Feb','Mar','Apr','Mag','Giu',
			'Lug','Ago','Set','Ott','Nov','Dic'],
		dayNames: ['Domenica','Lunedì','Martedì','Mercoledì','Giovedì','Venerdì','Sabato'],
		dayNamesShort: ['Dom','Lun','Mar','Mer','Gio','Ven','Sab'],
		dayNamesMin: ['Do','Lu','Ma','Me','Gi','Ve','Sa'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['it']);
});

/* Japanese initialisation for the jQuery UI date picker plugin. */
/* Written by Kentaro SATO (kentaro@ranvis.com). */
jQuery(function($){
	$.datepicker.regional['ja'] = {
		closeText: '閉じる',
		prevText: '&#x3C;前',
		nextText: '次&#x3E;',
		currentText: '今日',
		monthNames: ['1月','2月','3月','4月','5月','6月',
		'7月','8月','9月','10月','11月','12月'],
		monthNamesShort: ['1月','2月','3月','4月','5月','6月',
		'7月','8月','9月','10月','11月','12月'],
		dayNames: ['日曜日','月曜日','火曜日','水曜日','木曜日','金曜日','土曜日'],
		dayNamesShort: ['日','月','火','水','木','金','土'],
		dayNamesMin: ['日','月','火','水','木','金','土'],
		weekHeader: '週',
		dateFormat: 'yy/mm/dd',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: '年'};
	$.datepicker.setDefaults($.datepicker.regional['ja']);
});

/* Georgian (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Lado Lomidze (lado.lomidze@gmail.com). */
jQuery(function($){
	$.datepicker.regional['ka'] = {
		closeText: 'დახურვა',
		prevText: '&#x3c; წინა',
		nextText: 'შემდეგი &#x3e;',
		currentText: 'დღეს',
		monthNames: ['იანვარი','თებერვალი','მარტი','აპრილი','მაისი','ივნისი', 'ივლისი','აგვისტო','სექტემბერი','ოქტომბერი','ნოემბერი','დეკემბერი'],
		monthNamesShort: ['იან','თებ','მარ','აპრ','მაი','ივნ', 'ივლ','აგვ','სექ','ოქტ','ნოე','დეკ'],
		dayNames: ['კვირა','ორშაბათი','სამშაბათი','ოთხშაბათი','ხუთშაბათი','პარასკევი','შაბათი'],
		dayNamesShort: ['კვ','ორშ','სამ','ოთხ','ხუთ','პარ','შაბ'],
		dayNamesMin: ['კვ','ორშ','სამ','ოთხ','ხუთ','პარ','შაბ'],
		weekHeader: 'კვირა',
		dateFormat: 'dd-mm-yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ka']);
});

/* Kazakh (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Dmitriy Karasyov (dmitriy.karasyov@gmail.com). */
jQuery(function($){
	$.datepicker.regional['kk'] = {
		closeText: 'Жабу',
		prevText: '&#x3C;Алдыңғы',
		nextText: 'Келесі&#x3E;',
		currentText: 'Бүгін',
		monthNames: ['Қаңтар','Ақпан','Наурыз','Сәуір','Мамыр','Маусым',
		'Шілде','Тамыз','Қыркүйек','Қазан','Қараша','Желтоқсан'],
		monthNamesShort: ['Қаң','Ақп','Нау','Сәу','Мам','Мау',
		'Шіл','Там','Қыр','Қаз','Қар','Жел'],
		dayNames: ['Жексенбі','Дүйсенбі','Сейсенбі','Сәрсенбі','Бейсенбі','Жұма','Сенбі'],
		dayNamesShort: ['жкс','дсн','ссн','срс','бсн','жма','снб'],
		dayNamesMin: ['Жк','Дс','Сс','Ср','Бс','Жм','Сн'],
		weekHeader: 'Не',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['kk']);
});

/* Khmer initialisation for the jQuery calendar extension. */
/* Written by Chandara Om (chandara.teacher@gmail.com). */
jQuery(function($){
	$.datepicker.regional['km'] = {
		closeText: 'ធ្វើ​រួច',
		prevText: 'មុន',
		nextText: 'បន្ទាប់',
		currentText: 'ថ្ងៃ​នេះ',
		monthNames: ['មករា','កុម្ភៈ','មីនា','មេសា','ឧសភា','មិថុនា',
		'កក្កដា','សីហា','កញ្ញា','តុលា','វិច្ឆិកា','ធ្នូ'],
		monthNamesShort: ['មករា','កុម្ភៈ','មីនា','មេសា','ឧសភា','មិថុនា',
		'កក្កដា','សីហា','កញ្ញា','តុលា','វិច្ឆិកា','ធ្នូ'],
		dayNames: ['អាទិត្យ', 'ចន្ទ', 'អង្គារ', 'ពុធ', 'ព្រហស្បតិ៍', 'សុក្រ', 'សៅរ៍'],
		dayNamesShort: ['អា', 'ច', 'អ', 'ពុ', 'ព្រហ', 'សុ', 'សៅ'],
		dayNamesMin: ['អា', 'ច', 'អ', 'ពុ', 'ព្រហ', 'សុ', 'សៅ'],
		weekHeader: 'សប្ដាហ៍',
		dateFormat: 'dd-mm-yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['km']);
});

/* Korean initialisation for the jQuery calendar extension. */
/* Written by DaeKwon Kang (ncrash.dk@gmail.com), Edited by Genie. */
jQuery(function($){
	$.datepicker.regional['ko'] = {
		closeText: '닫기',
		prevText: '이전달',
		nextText: '다음달',
		currentText: '오늘',
		monthNames: ['1월','2월','3월','4월','5월','6월',
		'7월','8월','9월','10월','11월','12월'],
		monthNamesShort: ['1월','2월','3월','4월','5월','6월',
		'7월','8월','9월','10월','11월','12월'],
		dayNames: ['일요일','월요일','화요일','수요일','목요일','금요일','토요일'],
		dayNamesShort: ['일','월','화','수','목','금','토'],
		dayNamesMin: ['일','월','화','수','목','금','토'],
		weekHeader: 'Wk',
		dateFormat: 'yy-mm-dd',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: '년'};
	$.datepicker.setDefaults($.datepicker.regional['ko']);
});

/* Kyrgyz (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Sergey Kartashov (ebishkek@yandex.ru). */
jQuery(function($){
	$.datepicker.regional['ky'] = {
		closeText: 'Жабуу',
		prevText: '&#x3c;Мур',
		nextText: 'Кий&#x3e;',
		currentText: 'Бүгүн',
		monthNames: ['Январь','Февраль','Март','Апрель','Май','Июнь',
		'Июль','Август','Сентябрь','Октябрь','Ноябрь','Декабрь'],
		monthNamesShort: ['Янв','Фев','Мар','Апр','Май','Июн',
		'Июл','Авг','Сен','Окт','Ноя','Дек'],
		dayNames: ['жекшемби', 'дүйшөмбү', 'шейшемби', 'шаршемби', 'бейшемби', 'жума', 'ишемби'],
		dayNamesShort: ['жек', 'дүй', 'шей', 'шар', 'бей', 'жум', 'ише'],
		dayNamesMin: ['Жк','Дш','Шш','Шр','Бш','Жм','Иш'],
		weekHeader: 'Жум',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''
	};
	$.datepicker.setDefaults($.datepicker.regional['ky']);
});

/* Luxembourgish initialisation for the jQuery UI date picker plugin. */
/* Written by Michel Weimerskirch <michel@weimerskirch.net> */
jQuery(function($){
	$.datepicker.regional['lb'] = {
		closeText: 'Fäerdeg',
		prevText: 'Zréck',
		nextText: 'Weider',
		currentText: 'Haut',
		monthNames: ['Januar','Februar','Mäerz','Abrëll','Mee','Juni',
		'Juli','August','September','Oktober','November','Dezember'],
		monthNamesShort: ['Jan', 'Feb', 'Mäe', 'Abr', 'Mee', 'Jun',
		'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
		dayNames: ['Sonndeg', 'Méindeg', 'Dënschdeg', 'Mëttwoch', 'Donneschdeg', 'Freideg', 'Samschdeg'],
		dayNamesShort: ['Son', 'Méi', 'Dën', 'Mët', 'Don', 'Fre', 'Sam'],
		dayNamesMin: ['So','Mé','Dë','Më','Do','Fr','Sa'],
		weekHeader: 'W',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['lb']);
});

/* Lithuanian (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* @author Arturas Paleicikas <arturas@avalon.lt> */
jQuery(function($){
	$.datepicker.regional['lt'] = {
		closeText: 'Uždaryti',
		prevText: '&#x3C;Atgal',
		nextText: 'Pirmyn&#x3E;',
		currentText: 'Šiandien',
		monthNames: ['Sausis','Vasaris','Kovas','Balandis','Gegužė','Birželis',
		'Liepa','Rugpjūtis','Rugsėjis','Spalis','Lapkritis','Gruodis'],
		monthNamesShort: ['Sau','Vas','Kov','Bal','Geg','Bir',
		'Lie','Rugp','Rugs','Spa','Lap','Gru'],
		dayNames: ['sekmadienis','pirmadienis','antradienis','trečiadienis','ketvirtadienis','penktadienis','šeštadienis'],
		dayNamesShort: ['sek','pir','ant','tre','ket','pen','šeš'],
		dayNamesMin: ['Se','Pr','An','Tr','Ke','Pe','Še'],
		weekHeader: 'SAV',
		dateFormat: 'yy-mm-dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['lt']);
});

/* Latvian (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* @author Arturas Paleicikas <arturas.paleicikas@metasite.net> */
jQuery(function($){
	$.datepicker.regional['lv'] = {
		closeText: 'Aizvērt',
		prevText: 'Iepr.',
		nextText: 'Nāk.',
		currentText: 'Šodien',
		monthNames: ['Janvāris','Februāris','Marts','Aprīlis','Maijs','Jūnijs',
		'Jūlijs','Augusts','Septembris','Oktobris','Novembris','Decembris'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Mai','Jūn',
		'Jūl','Aug','Sep','Okt','Nov','Dec'],
		dayNames: ['svētdiena','pirmdiena','otrdiena','trešdiena','ceturtdiena','piektdiena','sestdiena'],
		dayNamesShort: ['svt','prm','otr','tre','ctr','pkt','sst'],
		dayNamesMin: ['Sv','Pr','Ot','Tr','Ct','Pk','Ss'],
		weekHeader: 'Ned.',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['lv']);
});

/* Macedonian i18n for the jQuery UI date picker plugin. */
/* Written by Stojce Slavkovski. */
jQuery(function($){
	$.datepicker.regional['mk'] = {
		closeText: 'Затвори',
		prevText: '&#x3C;',
		nextText: '&#x3E;',
		currentText: 'Денес',
		monthNames: ['Јануари','Февруари','Март','Април','Мај','Јуни',
		'Јули','Август','Септември','Октомври','Ноември','Декември'],
		monthNamesShort: ['Јан','Фев','Мар','Апр','Мај','Јун',
		'Јул','Авг','Сеп','Окт','Ное','Дек'],
		dayNames: ['Недела','Понеделник','Вторник','Среда','Четврток','Петок','Сабота'],
		dayNamesShort: ['Нед','Пон','Вто','Сре','Чет','Пет','Саб'],
		dayNamesMin: ['Не','По','Вт','Ср','Че','Пе','Са'],
		weekHeader: 'Сед',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['mk']);
});

/* Malayalam (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Saji Nediyanchath (saji89@gmail.com). */
jQuery(function($){
	$.datepicker.regional['ml'] = {
		closeText: 'ശരി',
		prevText: 'മുന്നത്തെ',
		nextText: 'അടുത്തത് ',
		currentText: 'ഇന്ന്',
		monthNames: ['ജനുവരി','ഫെബ്രുവരി','മാര്‍ച്ച്','ഏപ്രില്‍','മേയ്','ജൂണ്‍',
		'ജൂലൈ','ആഗസ്റ്റ്','സെപ്റ്റംബര്‍','ഒക്ടോബര്‍','നവംബര്‍','ഡിസംബര്‍'],
		monthNamesShort: ['ജനു', 'ഫെബ്', 'മാര്‍', 'ഏപ്രി', 'മേയ്', 'ജൂണ്‍',
		'ജൂലാ', 'ആഗ', 'സെപ്', 'ഒക്ടോ', 'നവം', 'ഡിസ'],
		dayNames: ['ഞായര്‍', 'തിങ്കള്‍', 'ചൊവ്വ', 'ബുധന്‍', 'വ്യാഴം', 'വെള്ളി', 'ശനി'],
		dayNamesShort: ['ഞായ', 'തിങ്ക', 'ചൊവ്വ', 'ബുധ', 'വ്യാഴം', 'വെള്ളി', 'ശനി'],
		dayNamesMin: ['ഞാ','തി','ചൊ','ബു','വ്യാ','വെ','ശ'],
		weekHeader: 'ആ',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ml']);
});

/* Malaysian initialisation for the jQuery UI date picker plugin. */
/* Written by Mohd Nawawi Mohamad Jamili (nawawi@ronggeng.net). */
jQuery(function($){
	$.datepicker.regional['ms'] = {
		closeText: 'Tutup',
		prevText: '&#x3C;Sebelum',
		nextText: 'Selepas&#x3E;',
		currentText: 'hari ini',
		monthNames: ['Januari','Februari','Mac','April','Mei','Jun',
		'Julai','Ogos','September','Oktober','November','Disember'],
		monthNamesShort: ['Jan','Feb','Mac','Apr','Mei','Jun',
		'Jul','Ogo','Sep','Okt','Nov','Dis'],
		dayNames: ['Ahad','Isnin','Selasa','Rabu','Khamis','Jumaat','Sabtu'],
		dayNamesShort: ['Aha','Isn','Sel','Rab','kha','Jum','Sab'],
		dayNamesMin: ['Ah','Is','Se','Ra','Kh','Ju','Sa'],
		weekHeader: 'Mg',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ms']);
});

/* Norwegian Bokmål initialisation for the jQuery UI date picker plugin. */
/* Written by Bjørn Johansen (post@bjornjohansen.no). */
jQuery(function($){
	$.datepicker.regional['nb'] = {
		closeText: 'Lukk',
		prevText: '&#xAB;Forrige',
		nextText: 'Neste&#xBB;',
		currentText: 'I dag',
		monthNames: ['januar','februar','mars','april','mai','juni','juli','august','september','oktober','november','desember'],
		monthNamesShort: ['jan','feb','mar','apr','mai','jun','jul','aug','sep','okt','nov','des'],
		dayNamesShort: ['søn','man','tir','ons','tor','fre','lør'],
		dayNames: ['søndag','mandag','tirsdag','onsdag','torsdag','fredag','lørdag'],
		dayNamesMin: ['sø','ma','ti','on','to','fr','lø'],
		weekHeader: 'Uke',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''
	};
	$.datepicker.setDefaults($.datepicker.regional['nb']);
});

/* Dutch (Belgium) initialisation for the jQuery UI date picker plugin. */
/* David De Sloovere @DavidDeSloovere */
jQuery(function($){
	$.datepicker.regional['nl-BE'] = {
		closeText: 'Sluiten',
		prevText: '←',
		nextText: '→',
		currentText: 'Vandaag',
		monthNames: ['januari', 'februari', 'maart', 'april', 'mei', 'juni',
		'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
		monthNamesShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun',
		'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
		dayNames: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag'],
		dayNamesShort: ['zon', 'maa', 'din', 'woe', 'don', 'vri', 'zat'],
		dayNamesMin: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['nl-BE']);
});

/* Dutch (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Mathias Bynens <http://mathiasbynens.be/> */
jQuery(function($){
	$.datepicker.regional.nl = {
		closeText: 'Sluiten',
		prevText: '←',
		nextText: '→',
		currentText: 'Vandaag',
		monthNames: ['januari', 'februari', 'maart', 'april', 'mei', 'juni',
		'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
		monthNamesShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun',
		'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
		dayNames: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag'],
		dayNamesShort: ['zon', 'maa', 'din', 'woe', 'don', 'vri', 'zat'],
		dayNamesMin: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
		weekHeader: 'Wk',
		dateFormat: 'dd-mm-yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional.nl);
});

/* Norwegian Nynorsk initialisation for the jQuery UI date picker plugin. */
/* Written by Bjørn Johansen (post@bjornjohansen.no). */
jQuery(function($){
	$.datepicker.regional['nn'] = {
		closeText: 'Lukk',
		prevText: '&#xAB;Førre',
		nextText: 'Neste&#xBB;',
		currentText: 'I dag',
		monthNames: ['januar','februar','mars','april','mai','juni','juli','august','september','oktober','november','desember'],
		monthNamesShort: ['jan','feb','mar','apr','mai','jun','jul','aug','sep','okt','nov','des'],
		dayNamesShort: ['sun','mån','tys','ons','tor','fre','lau'],
		dayNames: ['sundag','måndag','tysdag','onsdag','torsdag','fredag','laurdag'],
		dayNamesMin: ['su','må','ty','on','to','fr','la'],
		weekHeader: 'Veke',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''
	};
	$.datepicker.setDefaults($.datepicker.regional['nn']);
});

/* Norwegian initialisation for the jQuery UI date picker plugin. */
/* Written by Naimdjon Takhirov (naimdjon@gmail.com). */

jQuery(function($){
	$.datepicker.regional['no'] = {
		closeText: 'Lukk',
		prevText: '&#xAB;Forrige',
		nextText: 'Neste&#xBB;',
		currentText: 'I dag',
		monthNames: ['januar','februar','mars','april','mai','juni','juli','august','september','oktober','november','desember'],
		monthNamesShort: ['jan','feb','mar','apr','mai','jun','jul','aug','sep','okt','nov','des'],
		dayNamesShort: ['søn','man','tir','ons','tor','fre','lør'],
		dayNames: ['søndag','mandag','tirsdag','onsdag','torsdag','fredag','lørdag'],
		dayNamesMin: ['sø','ma','ti','on','to','fr','lø'],
		weekHeader: 'Uke',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''
	};
	$.datepicker.setDefaults($.datepicker.regional['no']);
});

/* Polish initialisation for the jQuery UI date picker plugin. */
/* Written by Jacek Wysocki (jacek.wysocki@gmail.com). */
jQuery(function($){
	$.datepicker.regional['pl'] = {
		closeText: 'Zamknij',
		prevText: '&#x3C;Poprzedni',
		nextText: 'Następny&#x3E;',
		currentText: 'Dziś',
		monthNames: ['Styczeń','Luty','Marzec','Kwiecień','Maj','Czerwiec',
		'Lipiec','Sierpień','Wrzesień','Październik','Listopad','Grudzień'],
		monthNamesShort: ['Sty','Lu','Mar','Kw','Maj','Cze',
		'Lip','Sie','Wrz','Pa','Lis','Gru'],
		dayNames: ['Niedziela','Poniedziałek','Wtorek','Środa','Czwartek','Piątek','Sobota'],
		dayNamesShort: ['Nie','Pn','Wt','Śr','Czw','Pt','So'],
		dayNamesMin: ['N','Pn','Wt','Śr','Cz','Pt','So'],
		weekHeader: 'Tydz',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['pl']);
});

/* Brazilian initialisation for the jQuery UI date picker plugin. */
/* Written by Leonildo Costa Silva (leocsilva@gmail.com). */
jQuery(function($){
	$.datepicker.regional['pt-BR'] = {
		closeText: 'Fechar',
		prevText: '&#x3C;Anterior',
		nextText: 'Próximo&#x3E;',
		currentText: 'Hoje',
		monthNames: ['Janeiro','Fevereiro','Março','Abril','Maio','Junho',
		'Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'],
		monthNamesShort: ['Jan','Fev','Mar','Abr','Mai','Jun',
		'Jul','Ago','Set','Out','Nov','Dez'],
		dayNames: ['Domingo','Segunda-feira','Terça-feira','Quarta-feira','Quinta-feira','Sexta-feira','Sábado'],
		dayNamesShort: ['Dom','Seg','Ter','Qua','Qui','Sex','Sáb'],
		dayNamesMin: ['Dom','Seg','Ter','Qua','Qui','Sex','Sáb'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['pt-BR']);
});

/* Portuguese initialisation for the jQuery UI date picker plugin. */
jQuery(function($){
	$.datepicker.regional['pt'] = {
		closeText: 'Fechar',
		prevText: 'Anterior',
		nextText: 'Seguinte',
		currentText: 'Hoje',
		monthNames: ['Janeiro','Fevereiro','Março','Abril','Maio','Junho',
		'Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'],
		monthNamesShort: ['Jan','Fev','Mar','Abr','Mai','Jun',
		'Jul','Ago','Set','Out','Nov','Dez'],
		dayNames: ['Domingo','Segunda-feira','Terça-feira','Quarta-feira','Quinta-feira','Sexta-feira','Sábado'],
		dayNamesShort: ['Dom','Seg','Ter','Qua','Qui','Sex','Sáb'],
		dayNamesMin: ['Dom','Seg','Ter','Qua','Qui','Sex','Sáb'],
		weekHeader: 'Sem',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['pt']);
});

/* Romansh initialisation for the jQuery UI date picker plugin. */
/* Written by Yvonne Gienal (yvonne.gienal@educa.ch). */
jQuery(function($){
	$.datepicker.regional['rm'] = {
		closeText: 'Serrar',
		prevText: '&#x3C;Suandant',
		nextText: 'Precedent&#x3E;',
		currentText: 'Actual',
		monthNames: ['Schaner','Favrer','Mars','Avrigl','Matg','Zercladur', 'Fanadur','Avust','Settember','October','November','December'],
		monthNamesShort: ['Scha','Fev','Mar','Avr','Matg','Zer', 'Fan','Avu','Sett','Oct','Nov','Dec'],
		dayNames: ['Dumengia','Glindesdi','Mardi','Mesemna','Gievgia','Venderdi','Sonda'],
		dayNamesShort: ['Dum','Gli','Mar','Mes','Gie','Ven','Som'],
		dayNamesMin: ['Du','Gl','Ma','Me','Gi','Ve','So'],
		weekHeader: 'emna',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['rm']);
});

/* Romanian initialisation for the jQuery UI date picker plugin.
 *
 * Written by Edmond L. (ll_edmond@walla.com)
 * and Ionut G. Stan (ionut.g.stan@gmail.com)
 */
jQuery(function($){
	$.datepicker.regional['ro'] = {
		closeText: 'Închide',
		prevText: '&#xAB; Luna precedentă',
		nextText: 'Luna următoare &#xBB;',
		currentText: 'Azi',
		monthNames: ['Ianuarie','Februarie','Martie','Aprilie','Mai','Iunie',
		'Iulie','August','Septembrie','Octombrie','Noiembrie','Decembrie'],
		monthNamesShort: ['Ian', 'Feb', 'Mar', 'Apr', 'Mai', 'Iun',
		'Iul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		dayNames: ['Duminică', 'Luni', 'Marţi', 'Miercuri', 'Joi', 'Vineri', 'Sâmbătă'],
		dayNamesShort: ['Dum', 'Lun', 'Mar', 'Mie', 'Joi', 'Vin', 'Sâm'],
		dayNamesMin: ['Du','Lu','Ma','Mi','Jo','Vi','Sâ'],
		weekHeader: 'Săpt',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ro']);
});

/* Russian (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Andrew Stromnov (stromnov@gmail.com). */
jQuery(function($){
	$.datepicker.regional['ru'] = {
		closeText: 'Закрыть',
		prevText: '&#x3C;Пред',
		nextText: 'След&#x3E;',
		currentText: 'Сегодня',
		monthNames: ['Январь','Февраль','Март','Апрель','Май','Июнь',
		'Июль','Август','Сентябрь','Октябрь','Ноябрь','Декабрь'],
		monthNamesShort: ['Янв','Фев','Мар','Апр','Май','Июн',
		'Июл','Авг','Сен','Окт','Ноя','Дек'],
		dayNames: ['воскресенье','понедельник','вторник','среда','четверг','пятница','суббота'],
		dayNamesShort: ['вск','пнд','втр','срд','чтв','птн','сбт'],
		dayNamesMin: ['Вс','Пн','Вт','Ср','Чт','Пт','Сб'],
		weekHeader: 'Нед',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ru']);
});

/* Slovak initialisation for the jQuery UI date picker plugin. */
/* Written by Vojtech Rinik (vojto@hmm.sk). */
jQuery(function($){
	$.datepicker.regional['sk'] = {
		closeText: 'Zavrieť',
		prevText: '&#x3C;Predchádzajúci',
		nextText: 'Nasledujúci&#x3E;',
		currentText: 'Dnes',
		monthNames: ['január','február','marec','apríl','máj','jún',
		'júl','august','september','október','november','december'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Máj','Jún',
		'Júl','Aug','Sep','Okt','Nov','Dec'],
		dayNames: ['nedeľa','pondelok','utorok','streda','štvrtok','piatok','sobota'],
		dayNamesShort: ['Ned','Pon','Uto','Str','Štv','Pia','Sob'],
		dayNamesMin: ['Ne','Po','Ut','St','Št','Pia','So'],
		weekHeader: 'Ty',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['sk']);
});

/* Slovenian initialisation for the jQuery UI date picker plugin. */
/* Written by Jaka Jancar (jaka@kubje.org). */
/* c = č, s = š z = ž C = Č S = Š Z = Ž */
jQuery(function($){
	$.datepicker.regional['sl'] = {
		closeText: 'Zapri',
		prevText: '&#x3C;Prejšnji',
		nextText: 'Naslednji&#x3E;',
		currentText: 'Trenutni',
		monthNames: ['Januar','Februar','Marec','April','Maj','Junij',
		'Julij','Avgust','September','Oktober','November','December'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maj','Jun',
		'Jul','Avg','Sep','Okt','Nov','Dec'],
		dayNames: ['Nedelja','Ponedeljek','Torek','Sreda','Četrtek','Petek','Sobota'],
		dayNamesShort: ['Ned','Pon','Tor','Sre','Čet','Pet','Sob'],
		dayNamesMin: ['Ne','Po','To','Sr','Če','Pe','So'],
		weekHeader: 'Teden',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['sl']);
});

/* Albanian initialisation for the jQuery UI date picker plugin. */
/* Written by Flakron Bytyqi (flakron@gmail.com). */
jQuery(function($){
	$.datepicker.regional['sq'] = {
		closeText: 'mbylle',
		prevText: '&#x3C;mbrapa',
		nextText: 'Përpara&#x3E;',
		currentText: 'sot',
		monthNames: ['Janar','Shkurt','Mars','Prill','Maj','Qershor',
		'Korrik','Gusht','Shtator','Tetor','Nëntor','Dhjetor'],
		monthNamesShort: ['Jan','Shk','Mar','Pri','Maj','Qer',
		'Kor','Gus','Sht','Tet','Nën','Dhj'],
		dayNames: ['E Diel','E Hënë','E Martë','E Mërkurë','E Enjte','E Premte','E Shtune'],
		dayNamesShort: ['Di','Hë','Ma','Më','En','Pr','Sh'],
		dayNamesMin: ['Di','Hë','Ma','Më','En','Pr','Sh'],
		weekHeader: 'Ja',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['sq']);
});

/* Serbian i18n for the jQuery UI date picker plugin. */
/* Written by Dejan Dimić. */
jQuery(function($){
	$.datepicker.regional['sr-SR'] = {
		closeText: 'Zatvori',
		prevText: '&#x3C;',
		nextText: '&#x3E;',
		currentText: 'Danas',
		monthNames: ['Januar','Februar','Mart','April','Maj','Jun',
		'Jul','Avgust','Septembar','Oktobar','Novembar','Decembar'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maj','Jun',
		'Jul','Avg','Sep','Okt','Nov','Dec'],
		dayNames: ['Nedelja','Ponedeljak','Utorak','Sreda','Četvrtak','Petak','Subota'],
		dayNamesShort: ['Ned','Pon','Uto','Sre','Čet','Pet','Sub'],
		dayNamesMin: ['Ne','Po','Ut','Sr','Če','Pe','Su'],
		weekHeader: 'Sed',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['sr-SR']);
});

/* Serbian i18n for the jQuery UI date picker plugin. */
/* Written by Dejan Dimić. */
jQuery(function($){
	$.datepicker.regional['sr'] = {
		closeText: 'Затвори',
		prevText: '&#x3C;',
		nextText: '&#x3E;',
		currentText: 'Данас',
		monthNames: ['Јануар','Фебруар','Март','Април','Мај','Јун',
		'Јул','Август','Септембар','Октобар','Новембар','Децембар'],
		monthNamesShort: ['Јан','Феб','Мар','Апр','Мај','Јун',
		'Јул','Авг','Сеп','Окт','Нов','Дец'],
		dayNames: ['Недеља','Понедељак','Уторак','Среда','Четвртак','Петак','Субота'],
		dayNamesShort: ['Нед','Пон','Уто','Сре','Чет','Пет','Суб'],
		dayNamesMin: ['Не','По','Ут','Ср','Че','Пе','Су'],
		weekHeader: 'Сед',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['sr']);
});

/* Swedish initialisation for the jQuery UI date picker plugin. */
/* Written by Anders Ekdahl ( anders@nomadiz.se). */
jQuery(function($){
	$.datepicker.regional['sv'] = {
		closeText: 'Stäng',
		prevText: '&#xAB;Förra',
		nextText: 'Nästa&#xBB;',
		currentText: 'Idag',
		monthNames: ['Januari','Februari','Mars','April','Maj','Juni',
		'Juli','Augusti','September','Oktober','November','December'],
		monthNamesShort: ['Jan','Feb','Mar','Apr','Maj','Jun',
		'Jul','Aug','Sep','Okt','Nov','Dec'],
		dayNamesShort: ['Sön','Mån','Tis','Ons','Tor','Fre','Lör'],
		dayNames: ['Söndag','Måndag','Tisdag','Onsdag','Torsdag','Fredag','Lördag'],
		dayNamesMin: ['Sö','Må','Ti','On','To','Fr','Lö'],
		weekHeader: 'Ve',
		dateFormat: 'yy-mm-dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['sv']);
});

/* Tamil (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by S A Sureshkumar (saskumar@live.com). */
jQuery(function($){
	$.datepicker.regional['ta'] = {
		closeText: 'மூடு',
		prevText: 'முன்னையது',
		nextText: 'அடுத்தது',
		currentText: 'இன்று',
		monthNames: ['தை','மாசி','பங்குனி','சித்திரை','வைகாசி','ஆனி',
		'ஆடி','ஆவணி','புரட்டாசி','ஐப்பசி','கார்த்திகை','மார்கழி'],
		monthNamesShort: ['தை','மாசி','பங்','சித்','வைகா','ஆனி',
		'ஆடி','ஆவ','புர','ஐப்','கார்','மார்'],
		dayNames: ['ஞாயிற்றுக்கிழமை','திங்கட்கிழமை','செவ்வாய்க்கிழமை','புதன்கிழமை','வியாழக்கிழமை','வெள்ளிக்கிழமை','சனிக்கிழமை'],
		dayNamesShort: ['ஞாயிறு','திங்கள்','செவ்வாய்','புதன்','வியாழன்','வெள்ளி','சனி'],
		dayNamesMin: ['ஞா','தி','செ','பு','வி','வெ','ச'],
		weekHeader: 'Не',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['ta']);
});

/* Thai initialisation for the jQuery UI date picker plugin. */
/* Written by pipo (pipo@sixhead.com). */
jQuery(function($){
	$.datepicker.regional['th'] = {
		closeText: 'ปิด',
		prevText: '&#xAB;&#xA0;ย้อน',
		nextText: 'ถัดไป&#xA0;&#xBB;',
		currentText: 'วันนี้',
		monthNames: ['มกราคม','กุมภาพันธ์','มีนาคม','เมษายน','พฤษภาคม','มิถุนายน',
		'กรกฎาคม','สิงหาคม','กันยายน','ตุลาคม','พฤศจิกายน','ธันวาคม'],
		monthNamesShort: ['ม.ค.','ก.พ.','มี.ค.','เม.ย.','พ.ค.','มิ.ย.',
		'ก.ค.','ส.ค.','ก.ย.','ต.ค.','พ.ย.','ธ.ค.'],
		dayNames: ['อาทิตย์','จันทร์','อังคาร','พุธ','พฤหัสบดี','ศุกร์','เสาร์'],
		dayNamesShort: ['อา.','จ.','อ.','พ.','พฤ.','ศ.','ส.'],
		dayNamesMin: ['อา.','จ.','อ.','พ.','พฤ.','ศ.','ส.'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['th']);
});

/* Tajiki (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Abdurahmon Saidov (saidovab@gmail.com). */
jQuery(function($){
	$.datepicker.regional['tj'] = {
		closeText: 'Идома',
		prevText: '&#x3c;Қафо',
		nextText: 'Пеш&#x3e;',
		currentText: 'Имрӯз',
		monthNames: ['Январ','Феврал','Март','Апрел','Май','Июн',
		'Июл','Август','Сентябр','Октябр','Ноябр','Декабр'],
		monthNamesShort: ['Янв','Фев','Мар','Апр','Май','Июн',
		'Июл','Авг','Сен','Окт','Ноя','Дек'],
		dayNames: ['якшанбе','душанбе','сешанбе','чоршанбе','панҷшанбе','ҷумъа','шанбе'],
		dayNamesShort: ['якш','душ','сеш','чор','пан','ҷум','шан'],
		dayNamesMin: ['Як','Дш','Сш','Чш','Пш','Ҷм','Шн'],
		weekHeader: 'Хф',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['tj']);
});

/* Tetum (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Alexandru Cartaleanu (acartaleanu@developmentgateway.org). */
/* LOCAL AMP CODE -- THIS WILL DISAPPEAR */
jQuery(function($){
	$.datepicker.regional['tm'] = {
		closeText: 'Halo',
		prevText: 'Uluk',
		nextText: 'Tuir mai',
		currentText: 'Ohin loron',
		monthNames: ['Janeiru','Fevreiru','Marsu','Abril','Maiu','Junhu',
		'Julhu','Agostu','Septembru','Otubru','Novembru','Dezrembru'],
		monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun',
		'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dez'],
		dayNames: ['Dumingu', 'Segunda', 'Tersa', 'Kuarta', 'Kinta', 'Sesta', 'Sabadu'],
		dayNamesShort: ['Dum', 'Seg', 'Ter', 'Krt', 'Kin', 'Ses', 'Sab'],
		dayNamesMin: ['Dm','Sg','Tr','Kt','Kn','Ss','Sb'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['tm']);
});
/* Turkish initialisation for the jQuery UI date picker plugin. */
/* Written by Izzet Emre Erkan (kara@karalamalar.net). */
jQuery(function($){
	$.datepicker.regional['tr'] = {
		closeText: 'kapat',
		prevText: '&#x3C;geri',
		nextText: 'ileri&#x3e',
		currentText: 'bugün',
		monthNames: ['Ocak','Şubat','Mart','Nisan','Mayıs','Haziran',
		'Temmuz','Ağustos','Eylül','Ekim','Kasım','Aralık'],
		monthNamesShort: ['Oca','Şub','Mar','Nis','May','Haz',
		'Tem','Ağu','Eyl','Eki','Kas','Ara'],
		dayNames: ['Pazar','Pazartesi','Salı','Çarşamba','Perşembe','Cuma','Cumartesi'],
		dayNamesShort: ['Pz','Pt','Sa','Ça','Pe','Cu','Ct'],
		dayNamesMin: ['Pz','Pt','Sa','Ça','Pe','Cu','Ct'],
		weekHeader: 'Hf',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['tr']);
});

/* Ukrainian (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Maxim Drogobitskiy (maxdao@gmail.com). */
/* Corrected by Igor Milla (igor.fsp.milla@gmail.com). */
jQuery(function($){
	$.datepicker.regional['uk'] = {
		closeText: 'Закрити',
		prevText: '&#x3C;',
		nextText: '&#x3E;',
		currentText: 'Сьогодні',
		monthNames: ['Січень','Лютий','Березень','Квітень','Травень','Червень',
		'Липень','Серпень','Вересень','Жовтень','Листопад','Грудень'],
		monthNamesShort: ['Січ','Лют','Бер','Кві','Тра','Чер',
		'Лип','Сер','Вер','Жов','Лис','Гру'],
		dayNames: ['неділя','понеділок','вівторок','середа','четвер','п’ятниця','субота'],
		dayNamesShort: ['нед','пнд','вів','срд','чтв','птн','сбт'],
		dayNamesMin: ['Нд','Пн','Вт','Ср','Чт','Пт','Сб'],
		weekHeader: 'Тиж',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['uk']);
});

/* Vietnamese initialisation for the jQuery UI date picker plugin. */
/* Translated by Le Thanh Huy (lthanhhuy@cit.ctu.edu.vn). */
jQuery(function($){
	$.datepicker.regional['vi'] = {
		closeText: 'Đóng',
		prevText: '&#x3C;Trước',
		nextText: 'Tiếp&#x3E;',
		currentText: 'Hôm nay',
		monthNames: ['Tháng Một', 'Tháng Hai', 'Tháng Ba', 'Tháng Tư', 'Tháng Năm', 'Tháng Sáu',
		'Tháng Bảy', 'Tháng Tám', 'Tháng Chín', 'Tháng Mười', 'Tháng Mười Một', 'Tháng Mười Hai'],
		monthNamesShort: ['Tháng 1', 'Tháng 2', 'Tháng 3', 'Tháng 4', 'Tháng 5', 'Tháng 6',
		'Tháng 7', 'Tháng 8', 'Tháng 9', 'Tháng 10', 'Tháng 11', 'Tháng 12'],
		dayNames: ['Chủ Nhật', 'Thứ Hai', 'Thứ Ba', 'Thứ Tư', 'Thứ Năm', 'Thứ Sáu', 'Thứ Bảy'],
		dayNamesShort: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
		dayNamesMin: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
		weekHeader: 'Tu',
		dateFormat: 'dd/mm/yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['vi']);
});

/* Chinese initialisation for the jQuery UI date picker plugin. */
/* Written by Cloudream (cloudream@gmail.com). */
jQuery(function($){
	$.datepicker.regional['zh-CN'] = {
		closeText: '关闭',
		prevText: '&#x3C;上月',
		nextText: '下月&#x3E;',
		currentText: '今天',
		monthNames: ['一月','二月','三月','四月','五月','六月',
		'七月','八月','九月','十月','十一月','十二月'],
		monthNamesShort: ['一月','二月','三月','四月','五月','六月',
		'七月','八月','九月','十月','十一月','十二月'],
		dayNames: ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'],
		dayNamesShort: ['周日','周一','周二','周三','周四','周五','周六'],
		dayNamesMin: ['日','一','二','三','四','五','六'],
		weekHeader: '周',
		dateFormat: 'yy-mm-dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: '年'};
	$.datepicker.setDefaults($.datepicker.regional['zh-CN']);
});

/* Chinese initialisation for the jQuery UI date picker plugin. */
/* Written by SCCY (samuelcychan@gmail.com). */
jQuery(function($){
	$.datepicker.regional['zh-HK'] = {
		closeText: '關閉',
		prevText: '&#x3C;上月',
		nextText: '下月&#x3E;',
		currentText: '今天',
		monthNames: ['一月','二月','三月','四月','五月','六月',
		'七月','八月','九月','十月','十一月','十二月'],
		monthNamesShort: ['一月','二月','三月','四月','五月','六月',
		'七月','八月','九月','十月','十一月','十二月'],
		dayNames: ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'],
		dayNamesShort: ['周日','周一','周二','周三','周四','周五','周六'],
		dayNamesMin: ['日','一','二','三','四','五','六'],
		weekHeader: '周',
		dateFormat: 'dd-mm-yy',
		firstDay: 0,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: '年'};
	$.datepicker.setDefaults($.datepicker.regional['zh-HK']);
});

/* Chinese initialisation for the jQuery UI date picker plugin. */
/* Written by Ressol (ressol@gmail.com). */
jQuery(function($){
	$.datepicker.regional['zh-TW'] = {
		closeText: '關閉',
		prevText: '&#x3C;上月',
		nextText: '下月&#x3E;',
		currentText: '今天',
		monthNames: ['一月','二月','三月','四月','五月','六月',
		'七月','八月','九月','十月','十一月','十二月'],
		monthNamesShort: ['一月','二月','三月','四月','五月','六月',
		'七月','八月','九月','十月','十一月','十二月'],
		dayNames: ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'],
		dayNamesShort: ['周日','周一','周二','周三','周四','周五','周六'],
		dayNamesMin: ['日','一','二','三','四','五','六'],
		weekHeader: '周',
		dateFormat: 'yy/mm/dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: '年'};
	$.datepicker.setDefaults($.datepicker.regional['zh-TW']);
});


/* English/EN initialisation for the jQuery UI date picker plugin. */
/* Written by Stuart. */
jQuery(function($){
	$.datepicker.regional['en'] = {
		closeText: 'Done',
		prevText: 'Prev',
		nextText: 'Next',
		currentText: 'Today',
		monthNames: ['January','February','March','April','May','June',
		'July','August','September','October','November','December'],
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
		'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional['en-GB']);
});
},{}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\lib\\jquery.nouislider.min.js":[function(require,module,exports){
/*

$.Link (part of noUiSlider) - WTFPL */
(function(c){function m(a,c,d){if((a[c]||a[d])&&a[c]===a[d])throw Error("(Link) '"+c+"' can't match '"+d+"'.'");}function r(a){void 0===a&&(a={});if("object"!==typeof a)throw Error("(Format) 'format' option must be an object.");var h={};c(u).each(function(c,n){if(void 0===a[n])h[n]=A[c];else if(typeof a[n]===typeof A[c]){if("decimals"===n&&(0>a[n]||7<a[n]))throw Error("(Format) 'format.decimals' option must be between 0 and 7.");h[n]=a[n]}else throw Error("(Format) 'format."+n+"' must be a "+typeof A[c]+
".");});m(h,"mark","thousand");m(h,"prefix","negative");m(h,"prefix","negativeBefore");this.r=h}function k(a,h){"object"!==typeof a&&c.error("(Link) Initialize with an object.");return new k.prototype.p(a.target||function(){},a.method,a.format||{},h)}var u="decimals mark thousand prefix postfix encoder decoder negative negativeBefore to from".split(" "),A=[2,".","","","",function(a){return a},function(a){return a},"-","",function(a){return a},function(a){return a}];r.prototype.a=function(a){return this.r[a]};
r.prototype.L=function(a){function c(a){return a.split("").reverse().join("")}a=this.a("encoder")(a);var d=this.a("decimals"),n="",k="",m="",r="";0===parseFloat(a.toFixed(d))&&(a="0");0>a&&(n=this.a("negative"),k=this.a("negativeBefore"));a=Math.abs(a).toFixed(d).toString();a=a.split(".");this.a("thousand")?(m=c(a[0]).match(/.{1,3}/g),m=c(m.join(c(this.a("thousand"))))):m=a[0];this.a("mark")&&1<a.length&&(r=this.a("mark")+a[1]);return this.a("to")(k+this.a("prefix")+n+m+r+this.a("postfix"))};r.prototype.w=
function(a){function c(a){return a.replace(/[\-\/\\\^$*+?.()|\[\]{}]/g,"\\$&")}var d;if(null===a||void 0===a)return!1;a=this.a("from")(a);a=a.toString();d=a.replace(RegExp("^"+c(this.a("negativeBefore"))),"");a!==d?(a=d,d="-"):d="";a=a.replace(RegExp("^"+c(this.a("prefix"))),"");this.a("negative")&&(d="",a=a.replace(RegExp("^"+c(this.a("negative"))),"-"));a=a.replace(RegExp(c(this.a("postfix"))+"$"),"").replace(RegExp(c(this.a("thousand")),"g"),"").replace(this.a("mark"),".");a=this.a("decoder")(parseFloat(d+
a));return isNaN(a)?!1:a};k.prototype.K=function(a,h){this.method=h||"html";this.j=c(a.replace("-tooltip-","")||"<div/>")[0]};k.prototype.H=function(a){this.method="val";this.j=document.createElement("input");this.j.name=a;this.j.type="hidden"};k.prototype.G=function(a){function h(a,c){return[c?null:a,c?a:null]}var d=this;this.method="val";this.target=a.on("change",function(a){d.B.val(h(c(a.target).val(),d.t),{link:d,set:!0})})};k.prototype.p=function(a,h,d,k){this.g=d;this.update=!k;if("string"===
typeof a&&0===a.indexOf("-tooltip-"))this.K(a,h);else if("string"===typeof a&&0!==a.indexOf("-"))this.H(a);else if("function"===typeof a)this.target=!1,this.method=a;else{if(a instanceof c||c.zepto&&c.zepto.isZ(a)){if(!h){if(a.is("input, select, textarea")){this.G(a);return}h="html"}if("function"===typeof h||"string"===typeof h&&a[h]){this.method=h;this.target=a;return}}throw new RangeError("(Link) Invalid Link.");}};k.prototype.write=function(a,c,d,k){if(!this.update||!1!==k)if(this.u=a,this.F=a=
this.format(a),"function"===typeof this.method)this.method.call(this.target[0]||d[0],a,c,d);else this.target[this.method](a,c,d)};k.prototype.q=function(a){this.g=new r(c.extend({},a,this.g instanceof r?this.g.r:this.g))};k.prototype.J=function(a){this.B=a};k.prototype.I=function(a){this.t=a};k.prototype.format=function(a){return this.g.L(a)};k.prototype.A=function(a){return this.g.w(a)};k.prototype.p.prototype=k.prototype;c.Link=k})(window.jQuery||window.Zepto);/*

$.fn.noUiSlider - WTFPL - refreshless.com/nouislider/ */
(function(c){function m(e){return"number"===typeof e&&!isNaN(e)&&isFinite(e)}function r(e){return c.isArray(e)?e:[e]}function k(e,b){e.addClass(b);setTimeout(function(){e.removeClass(b)},300)}function u(e,b){return 100*b/(e[1]-e[0])}function A(e,b){if(b>=e.d.slice(-1)[0])return 100;for(var a=1,c,f,d;b>=e.d[a];)a++;c=e.d[a-1];f=e.d[a];d=e.c[a-1];c=[c,f];return d+u(c,0>c[0]?b+Math.abs(c[0]):b-c[0])/(100/(e.c[a]-d))}function a(e,b){if(100<=b)return e.d.slice(-1)[0];for(var a=1,c,f,d;b>=e.c[a];)a++;c=
e.d[a-1];f=e.d[a];d=e.c[a-1];c=[c,f];return 100/(e.c[a]-d)*(b-d)*(c[1]-c[0])/100+c[0]}function h(a,b){for(var c=1,g;(a.dir?100-b:b)>=a.c[c];)c++;if(a.m)return g=a.c[c-1],c=a.c[c],b-g>(c-g)/2?c:g;a.h[c-1]?(g=a.h[c-1],c=a.c[c-1]+Math.round((b-a.c[c-1])/g)*g):c=b;return c}function d(a,b){if(!m(b))throw Error("noUiSlider: 'step' is not numeric.");a.h[0]=b}function n(a,b){if("object"!==typeof b||c.isArray(b))throw Error("noUiSlider: 'range' is not an object.");if(void 0===b.min||void 0===b.max)throw Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
c.each(b,function(b,g){var d;"number"===typeof g&&(g=[g]);if(!c.isArray(g))throw Error("noUiSlider: 'range' contains invalid value.");d="min"===b?0:"max"===b?100:parseFloat(b);if(!m(d)||!m(g[0]))throw Error("noUiSlider: 'range' value isn't numeric.");a.c.push(d);a.d.push(g[0]);d?a.h.push(isNaN(g[1])?!1:g[1]):isNaN(g[1])||(a.h[0]=g[1])});c.each(a.h,function(b,c){if(!c)return!0;a.h[b]=u([a.d[b],a.d[b+1]],c)/(100/(a.c[b+1]-a.c[b]))})}function E(a,b){"number"===typeof b&&(b=[b]);if(!c.isArray(b)||!b.length||
2<b.length)throw Error("noUiSlider: 'start' option is incorrect.");a.b=b.length;a.start=b}function I(a,b){a.m=b;if("boolean"!==typeof b)throw Error("noUiSlider: 'snap' option must be a boolean.");}function J(a,b){if("lower"===b&&1===a.b)a.i=1;else if("upper"===b&&1===a.b)a.i=2;else if(!0===b&&2===a.b)a.i=3;else if(!1===b)a.i=0;else throw Error("noUiSlider: 'connect' option doesn't match handle count.");}function D(a,b){switch(b){case "horizontal":a.k=0;break;case "vertical":a.k=1;break;default:throw Error("noUiSlider: 'orientation' option is invalid.");
}}function K(a,b){if(2<a.c.length)throw Error("noUiSlider: 'margin' option is only supported on linear sliders.");a.margin=u(a.d,b);if(!m(b))throw Error("noUiSlider: 'margin' option must be numeric.");}function L(a,b){switch(b){case "ltr":a.dir=0;break;case "rtl":a.dir=1;a.i=[0,2,1,3][a.i];break;default:throw Error("noUiSlider: 'direction' option was not recognized.");}}function M(a,b){if("string"!==typeof b)throw Error("noUiSlider: 'behaviour' must be a string containing options.");var c=0<=b.indexOf("snap");
a.n={s:0<=b.indexOf("tap")||c,extend:0<=b.indexOf("extend"),v:0<=b.indexOf("drag"),fixed:0<=b.indexOf("fixed"),m:c}}function N(a,b,d){a.o=[b.lower,b.upper];a.g=b.format;c.each(a.o,function(a,e){if(!c.isArray(e))throw Error("noUiSlider: 'serialization."+(a?"upper":"lower")+"' must be an array.");c.each(e,function(){if(!(this instanceof c.Link))throw Error("noUiSlider: 'serialization."+(a?"upper":"lower")+"' can only contain Link instances.");this.I(a);this.J(d);this.q(b.format)})});a.dir&&1<a.b&&a.o.reverse()}
function O(a,b){var f={c:[],d:[],h:[!1],margin:0},g;g={step:{e:!1,f:d},start:{e:!0,f:E},connect:{e:!0,f:J},direction:{e:!0,f:L},range:{e:!0,f:n},snap:{e:!1,f:I},orientation:{e:!1,f:D},margin:{e:!1,f:K},behaviour:{e:!0,f:M},serialization:{e:!0,f:N}};a=c.extend({connect:!1,direction:"ltr",behaviour:"tap",orientation:"horizontal"},a);a.serialization=c.extend({lower:[],upper:[],format:{}},a.serialization);c.each(g,function(c,d){if(void 0===a[c]){if(d.e)throw Error("noUiSlider: '"+c+"' is required.");
return!0}d.f(f,a[c],b)});f.style=f.k?"top":"left";return f}function P(a,b){var d=c("<div><div/></div>").addClass(f[2]),g=["-lower","-upper"];a.dir&&g.reverse();d.children().addClass(f[3]+" "+f[3]+g[b]);return d}function Q(a,b){b.j&&(b=new c.Link({target:c(b.j).clone().appendTo(a),method:b.method,format:b.g},!0));return b}function R(a,b){var d,f=[];for(d=0;d<a.b;d++){var k=f,h=d,m=a.o[d],n=b[d].children(),r=a.g,s=void 0,v=[],s=new c.Link({},!0);s.q(r);v.push(s);for(s=0;s<m.length;s++)v.push(Q(n,m[s]));
k[h]=v}return f}function S(a,b,c){switch(a){case 1:b.addClass(f[7]);c[0].addClass(f[6]);break;case 3:c[1].addClass(f[6]);case 2:c[0].addClass(f[7]);case 0:b.addClass(f[6])}}function T(a,b){var c,d=[];for(c=0;c<a.b;c++)d.push(P(a,c).appendTo(b));return d}function U(a,b){b.addClass([f[0],f[8+a.dir],f[4+a.k]].join(" "));return c("<div/>").appendTo(b).addClass(f[1])}function V(d,b,m){function g(){return t[["width","height"][b.k]]()}function n(a){var b,c=[q.val()];for(b=0;b<a.length;b++)q.trigger(a[b],
c)}function u(d,p,e){var g=d[0]!==l[0][0]?1:0,H=x[0]+b.margin,k=x[1]-b.margin;e&&1<l.length&&(p=g?Math.max(p,H):Math.min(p,k));100>p&&(p=h(b,p));p=Math.max(Math.min(parseFloat(p.toFixed(7)),100),0);if(p===x[g])return 1===l.length?!1:p===H||p===k?0:!1;d.css(b.style,p+"%");d.is(":first-child")&&d.toggleClass(f[17],50<p);x[g]=p;b.dir&&(p=100-p);c(y[g]).each(function(){this.write(a(b,p),d.children(),q)});return!0}function B(a,b,c){c||k(q,f[14]);u(a,b,!1);n(["slide","set","change"])}function w(a,c,d,e){a=
a.replace(/\s/g,".nui ")+".nui";c.on(a,function(a){var c=q.attr("disabled");if(q.hasClass(f[14])||void 0!==c&&null!==c)return!1;a.preventDefault();var c=0===a.type.indexOf("touch"),p=0===a.type.indexOf("mouse"),F=0===a.type.indexOf("pointer"),g,k,l=a;0===a.type.indexOf("MSPointer")&&(F=!0);a.originalEvent&&(a=a.originalEvent);c&&(g=a.changedTouches[0].pageX,k=a.changedTouches[0].pageY);if(p||F)F||void 0!==window.pageXOffset||(window.pageXOffset=document.documentElement.scrollLeft,window.pageYOffset=
document.documentElement.scrollTop),g=a.clientX+window.pageXOffset,k=a.clientY+window.pageYOffset;l.C=[g,k];l.cursor=p;a=l;a.l=a.C[b.k];d(a,e)})}function C(a,c){var b=c.b||l,d,e=!1,e=100*(a.l-c.start)/g(),f=b[0][0]!==l[0][0]?1:0;var k=c.D;d=e+k[0];e+=k[1];1<b.length?(0>d&&(e+=Math.abs(d)),100<e&&(d-=e-100),d=[Math.max(Math.min(d,100),0),Math.max(Math.min(e,100),0)]):d=[d,e];e=u(b[0],d[f],1===b.length);1<b.length&&(e=u(b[1],d[f?0:1],!1)||e);e&&n(["slide"])}function s(a){c("."+f[15]).removeClass(f[15]);
a.cursor&&c("body").css("cursor","").off(".nui");G.off(".nui");q.removeClass(f[12]);n(["set","change"])}function v(a,b){1===b.b.length&&b.b[0].children().addClass(f[15]);a.stopPropagation();w(z.move,G,C,{start:a.l,b:b.b,D:[x[0],x[l.length-1]]});w(z.end,G,s,null);a.cursor&&(c("body").css("cursor",c(a.target).css("cursor")),1<l.length&&q.addClass(f[12]),c("body").on("selectstart.nui",!1))}function D(a){var d=a.l,e=0;a.stopPropagation();c.each(l,function(){e+=this.offset()[b.style]});e=d<e/2||1===l.length?
0:1;d-=t.offset()[b.style];d=100*d/g();B(l[e],d,b.n.m);b.n.m&&v(a,{b:[l[e]]})}function E(a){var c=(a=a.l<t.offset()[b.style])?0:100;a=a?0:l.length-1;B(l[a],c,!1)}var q=c(d),x=[-1,-1],t,y,l;if(q.hasClass(f[0]))throw Error("Slider was already initialized.");t=U(b,q);l=T(b,t);y=R(b,l);S(b.i,q,l);(function(a){var b;if(!a.fixed)for(b=0;b<l.length;b++)w(z.start,l[b].children(),v,{b:[l[b]]});a.s&&w(z.start,t,D,{b:l});a.extend&&(q.addClass(f[16]),a.s&&w(z.start,q,E,{b:l}));a.v&&(b=t.find("."+f[7]).addClass(f[10]),
a.fixed&&(b=b.add(t.children().not(b).children())),w(z.start,b,v,{b:l}))})(b.n);d.vSet=function(){var a=Array.prototype.slice.call(arguments,0),d,e,g,h,m,s,t=r(a[0]);"object"===typeof a[1]?(d=a[1].set,e=a[1].link,g=a[1].update,h=a[1].animate):!0===a[1]&&(d=!0);b.dir&&1<b.b&&t.reverse();h&&k(q,f[14]);a=1<l.length?3:1;1===t.length&&(a=1);for(m=0;m<a;m++)h=e||y[m%2][0],h=h.A(t[m%2]),!1!==h&&(h=A(b,h),b.dir&&(h=100-h),!0!==u(l[m%2],h,!0)&&c(y[m%2]).each(function(a){if(!a)return s=this.u,!0;this.write(s,
l[m%2].children(),q,g)}));!0===d&&n(["set"]);return this};d.vGet=function(){var a,c=[];for(a=0;a<b.b;a++)c[a]=y[a][0].F;return 1===c.length?c[0]:b.dir?c.reverse():c};d.destroy=function(){c.each(y,function(){c.each(this,function(){this.target&&this.target.off(".nui")})});c(this).off(".nui").removeClass(f.join(" ")).empty();return m};q.val(b.start)}function W(a){if(!this.length)throw Error("noUiSlider: Can't initialize slider on empty selection.");var b=O(a,this);return this.each(function(){V(this,
b,a)})}function X(a){return this.each(function(){var b=c(this).val(),d=this.destroy(),f=c.extend({},d,a);c(this).noUiSlider(f);d.start===f.start&&c(this).val(b)})}function B(){return this[0][arguments.length?"vSet":"vGet"].apply(this[0],arguments)}var G=c(document),C=c.fn.val,z=window.navigator.pointerEnabled?{start:"pointerdown",move:"pointermove",end:"pointerup"}:window.navigator.msPointerEnabled?{start:"MSPointerDown",move:"MSPointerMove",end:"MSPointerUp"}:{start:"mousedown touchstart",move:"mousemove touchmove",
end:"mouseup touchend"},f="noUi-target noUi-base noUi-origin noUi-handle noUi-horizontal noUi-vertical noUi-background noUi-connect noUi-ltr noUi-rtl noUi-dragable  noUi-state-drag  noUi-state-tap noUi-active noUi-extended noUi-stacking".split(" ");c.fn.val=function(){var a=arguments,b=c(this[0]);return arguments.length?this.each(function(){(c(this).hasClass(f[0])?B:C).apply(c(this),a)}):(b.hasClass(f[0])?B:C).call(b)};c.noUiSlider={Link:c.Link};c.fn.noUiSlider=function(a,b){return(b?X:W).call(this,
a)}})(window.jQuery||window.Zepto);

},{}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\main.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');

// loading hacks
var jQuery = require('jquery');
//loading jqueryÑ only load it if
//it is not loaded or if there is a jquery loaded but version is older than 2.x.x
if (window.$ == undefined || $.fn.jquery.split(' ')[0].split('.')[0] < 2) {
	window.jQuery = window.$ = Backbone.$ = jQuery;
}
require('jquery-ui/draggable');
require('bootstrap/dist/js/bootstrap');
require('./lib/jquery-ui-i18n')

var FilterView = require('./views/filters-view');

// see README.md for documentation on using widget.


function Widget() {
  this.initialize.apply(this, arguments);
}

_.extend(Widget.prototype, Backbone.Events, {

  initialize: function(options) {
    var self = this;
    options = _.defaults(options, { draggable: true });
    if (_.has(options, 'sync')) {
      Backbone.sync = options.sync;
    }
    this.view = new FilterView(options);

    // used to make all filters request faster.
    this._cachedAllFilters = null;

    // loaded deferred to allow for other code to wait for filters to finish loading.
    this.loaded = this.view._loaded.promise();

    // proxy all filter events through here
    this.listenTo(this.view, 'all', function() {
      this.trigger.apply(this, arguments);
    });
  },

  // put the filters into the DOM tree post-initialization
  setElement: function() {
    this.view.setElement(arguments);
  },

  // this will stash current filter state, so it can be restored on cancel.
  showFilters: function() {
    this.view.showFilters();
  },

  setStash: function() {
    this.view.setStash();
  },

  // return models of all filters, even unselected ones..
  getAllFilters: function() {
    var self = this;
    return this.loaded.then(function(){
      // cache, because won't change. avoids calling serialize everytime.
      if(!this._cachedAllFilters){
        this._cachedAllFilters = self.view.serialize({includeUnselected: true, wholeModel: true});
      }
      return this._cachedAllFilters;
    });
  },

  // return models of serialized filter state, has entire models instead of just ids.
  serializeToModels: function() {
    return this.view.serialize({wholeModel: true});
  },

  formatDate: function(date){
	  return this.view.formatDate(date);  
  },
  
  // return json blob of serialized filter state, ids only.
  serialize: function() {
    return this.view.serialize({});
  },

  // restores filter state given a json blob, ids only.
  deserialize: function(stateBlob, options) {
    return this.view.deserialize(stateBlob, options);
  },

  // reset filters to empty state
  reset: function(options) {
    this.view.resetFilters();
    if (!options || !options.silent) {
      this.view.applyFilters();
    }
  },
  /**
   * searches the settings array of models for the ones which hold the min/max values instructed to and, if found,
   * writes them in filtersOut.otherFilters.date.{start}{end}
   *
   * use it as an utility function (it does not reference 'this', so
   * it is safe to use it at any point in the lifecycle of the widget
   */
  extractDates: function(settings, filtersOut, minName, maxName) {
    filtersOut.otherFilters = filtersOut.otherFilters || {};
    filtersOut.otherFilters.date = filtersOut.otherFilters.date || {
        start: '',
        end: ''
      };

    var defaultMinDate = _.find(settings, function(item) {
      return item.get('id') === minName;
    });
    if (defaultMinDate !== undefined && defaultMinDate.get('name') !== '') {
      filtersOut.otherFilters.date.start = defaultMinDate.get('name');
    }
    var defaultMaxDate = _.find(settings, function(item) {
      return item.get('id') === maxName;
    });
    if (defaultMaxDate !== undefined && defaultMaxDate.get('name') !== '') {
      filtersOut.otherFilters.date.end = defaultMaxDate.get('name');
    }
  }

});



module.exports = Widget;

},{"./lib/jquery-ui-i18n":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\lib\\jquery-ui-i18n.js","./views/filters-view":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\filters-view.js","backbone":"backbone","bootstrap/dist/js/bootstrap":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\bootstrap\\dist\\js\\bootstrap.js","jquery":"jquery","jquery-ui/draggable":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\jquery-ui\\draggable.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\base-filter-model.js":[function(require,module,exports){
var Backbone = require('backbone');

  // Parent model for filters.
module.exports = Backbone.Model.extend({
  defaults: {
    name: 'Filter Name',
    method: 'GET',
    totalCount: 0,
    activeCount: 0,
    _loaded: false,
    empty: false
  },

  initialize:function(options) {
    this.set('name', options.name);
    this.set('group', options.group || options.id);
    this.set('method', options.method);
    this.set('columns', options.columns);
    this.set('empty', options.empty || false);
    this.url =  options.url || options.endpoint;
  }

});

},{"backbone":"backbone"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\generic-filter-model.js":[function(require,module,exports){
var _ = require('underscore');

var BaseFilterModel = require('../models/base-filter-model');
var TreeNodeModel = require('../tree/tree-node-model');


module.exports = BaseFilterModel.extend({

  initialize:function(options) {
    BaseFilterModel.prototype.initialize.apply(this, [options]);
    this.set('modelType', 'TREE');
    this.getTree(); // starts getTree calls
  },

  // load tree if needed, else return what we already have..
  getTree: function() {
    var self = this;
    var loaded = this.get('_loaded');

    if (!loaded) {
      self.set('_loaded', this._createTree().then(function() {

        // trickle up numSelected.
    	  if(self.get('tree')!= undefined){
        self.get('tree').on('change:numSelected', function(model, value) {
          self.set('numSelected', value);
          self.set('numPossible', self.get('tree').get('numPossible'));
        });
    	  }
        return self.get('tree');
      }));
      
    }

    return this.get('_loaded');
  },

  getNumSelected: function(){
    var numSelected = this.get('numSelected');
    // if none selected, or all selected, treat the same.
    if (!numSelected || this.get('numSelected') === this.get('numPossible')) {
      return 0;
    } else {
      return numSelected;
    }
  },

  serialize: function(options) {
    var tree = this.get('tree');
    if (!tree) {
      //console.warn('no tree found', this.attributes);
      return {}; //no tree, nothing to serialize.
    } else {
      var tmpAry = tree.serialize(options);
      return tmpAry;
    }
  },

  deserialize: function(listOfSelected) {
    var self = this;
    var tree = this.get('tree');
    if (listOfSelected) {
      if (!tree) {
        console.warn('deserialize no tree found', self);
        return false; //no tree, nothing to serialize.
      } else {
        tree.deserialize(listOfSelected);
      }
    }
  },

  reset: function() {
    var tree = this.get('tree');
    if (tree) {
      // TODO: add a third type for semi-filled
      // force trigger, because otherwise nodes that are 'half-filled' but false won't refresh.
      tree.set('selected', true);
      tree.set('selected', false);

    }
  },

  _createTree: function() {
    if (!this.url) {
      this.url = this.get('endpoint');
    }

    return this.fetch({
      type: this.get('method'),
      data:'{}'
    })
    .fail(function(jqXHR, textStatus, errorThrown) {
      console.error('failed to get filter ', jqXHR, textStatus, errorThrown);
    });
  },

  parse: function(data) {
    var self = this;    

    //if it's an obj, jam it into an array first, helps solve inconsistancy in API format.
    if (!_.isArray(data)) {
      data = [data];
    }

    if (_.isArray(data) && data.length > 0) {
      var rootNodeObj = null;
      // Builds tree of views from returned data
      // If data is a single element, just make it the root..
      
      /* TODO-CONSTANTIN: temporary comment until I finish learning Filters frontend
      console.log("iterating " + data.length + " elems...");
      _.each(data, function(elem) {
    	  console.log("\tname = " + elem.name + ", id = " + elem.id);
      });
      */
      if (data.length === 1) {
    	if(data[0].filterId && !data[0].name) {
          data[0].name =  data[0].filterId;
        }
        if(data[0].values){
          data[0].children =  data[0].values;
        }

        data[0].isSelectable = false;
        
        //data[0].filterName = data[0].displayName;

        rootNodeObj = data[0];

      } else {
        rootNodeObj = {
          id: -1,
          code: '-1',
          name: self.get('name'),
          children: data,
          selected: undefined,
          expanded: false,
          isSelectable: false,
          createUnkowns: true/*,
          filterName: self.get('displayName')*/
        };
      }

      var treeModel = new TreeNodeModel(rootNodeObj);
      self.set('tree', treeModel);
    }

    return;
  }

});


},{"../models/base-filter-model":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\base-filter-model.js","../tree/tree-node-model":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\tree\\tree-node-model.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\org-role-filter-model.js":[function(require,module,exports){
var $ = require('jquery');

var GenericFilterModel = require('../models/generic-filter-model');
var TreeNodeModel = require('../tree/tree-node-model');


module.exports = GenericFilterModel.extend({


  initialize:function(options) {
    this.loaded = $.Deferred();
    this._createTree(options.data);
    GenericFilterModel.prototype.initialize.apply(this, [options]);
  },

  //org doesn't have async part, but still use deferred, so behaves same as generic filter model
  getTree: function() {
    return this.loaded;
  },

  _createTree:function(data) {
    var self = this;
    var rootNodeObj = {};
    if (data.length === 1) {
      rootNodeObj = data[0];
    } else {
      rootNodeObj = {
        id: -1,
        code: '-1',
        name: self.get('displayName'),
        filterId: self.get('filterId'),
        children: data,
        selected: undefined,
        expanded: false,
        isSelectable: false,
        createUnkowns: false
      };
    }

    var treeModel = new TreeNodeModel(rootNodeObj);
    this.set('tree', treeModel);

    // trickle up numSelected.
    self.get('tree').on('change:numSelected', function(model, value) {
      self.set('numSelected', value);
      self.set('numPossible', self.get('tree').get('numPossible'));
    });

    this.loaded.resolve(treeModel);
  }

});


},{"../models/generic-filter-model":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\generic-filter-model.js","../tree/tree-node-model":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\tree\\tree-node-model.js","jquery":"jquery"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\setting.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
module.exports = Backbone.Model.extend({
	defaults : {
		id : "",
		multi : "",
		name : "",
		defaultId : "",
		options : []
		
	}
});
},{"backbone":"backbone","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\years-filter-model.js":[function(require,module,exports){
var $ = require('jquery');
var _ = require('underscore');
var BaseFilterModel = require('../models/base-filter-model');


module.exports = BaseFilterModel.extend({


  defaults: {
    selectedStart: null,
    selectedEnd: null,
    // range is provided by api, but will fallback to this if not provided, or set to -1
    startYear: '',
    endYear: '',
    modelType: 'DATE-RANGE-VALUES'
  },
  
  sync: function () {
	  /**
	   * hackish: the data coming off the /dates endpoint should be ignored at all moments, because
	   * 1. for tabs/saiku, it should always be empty
	   * 2. for gis/dashboards, it is coming off the /setting endpoint
	   * 
	   * All the other years-filter-model should by spec be always empty at this point. In case this would cease to be true in the future,
	   * just filter by "name"
	   */ 
	  	
	  //console.error('SYNCING YEARS MODEL: ' + this.get('name'));
	  return $.when(true);
  },

  initialize: function(options) {
    BaseFilterModel.prototype.initialize.apply(this, [options]);
    this.url = options.endpoint;
    this.set('_loaded', $.Deferred());
  },

  parse: function(data) {
	  console.log('years-filter-model.parse: data = ' + JSON.stringify(data));
    if (!data.startYear || data.startYear === -1) {
      data.startYear = this.defaults.startYear;
    } else {
      data.startYear = data.startYear + '-01-01';
    }
    if (!data.endYear || data.endYear === -1) {
      data.endYear = this.defaults.endYear;
    } else {
      data.endYear = data.endYear + '-12-31';
    }

    if (!data.selectedStart) {
    	// good ole' partial copy-paste off postprocess()
    	data.selectedStart = data.startYear;
    	data.selectedEnd = data.endYear;
    }
    this.get('_loaded').resolve();
    return data;
  },

  serialize: function() {
	// AMP-21041: Enabled filtering by start OR end date.
    if (this.get('selectedStart') || this.get('selectedEnd')) {
    	  var key = _.first(this.get('columns')) !='N/A' ? _.first(this.get('columns')): 'date';
    	  //console.log('serializing years-filter-model for ' + key + ', start = ' + this.get('selectedStart') + ', end = ' + this.get('selectedEnd'));    	  
    	  var obj = {};
    	  obj[key] = {
				  //start: this._dateConvert(this.get('selectedStart')),
				  //end: this._dateConvert(this.get('selectedEnd'))
				  start: this.get('selectedStart'),
				  end: this.get('selectedEnd'),
				  modelType: this.get('modelType')
			 };
    	  return obj;
    } else {
      return null;
    }
  },

  /**
   * postprocess model after having fetched data from the server
   */
  postprocess: function() {
	  // only set if not set by deserialize
	  if (!this.get('selectedStart')) {
	  	  this.set('selectedStart', this.get('startYear'));
	  }
	  // AMP-21041: Enabled filtering by start OR end date.
      if (!this.get('selectedEnd')) {                  
          this.set('selectedEnd', this.get('endYear'));
      }
  },
  
  deserialize: function(obj) {
	var key = _.first(this.get('columns')) !='N/A' ? _.first(this.get('columns')) : 'date';
	if (obj && obj[key]) {
	  this.set('selectedStart', this._dateConvert(obj[key].start));
	  this.set('selectedEnd', this._dateConvert(obj[key].end));
      this.postprocess();
	}else{
		this.set('selectedStart', this.get('startYear'));
	    this.set('selectedEnd', this.get('endYear'));
	}
  },

  reset: function() {
    this.set('selectedStart', this.get('startYear'));
    this.set('selectedEnd', this.get('endYear'));
  },

  // converts: 03/01/1961 ==> 1961-01-01 IF NEEDED.
  // DOES NOT CONVERT from the "-" format to "/" format anymore
  // 
  // amp expects with '-' and jQuery wants with '/'
  _dateConvert: function(input){
	  console.log('asked to convert input: ' + input);
    var output = null;
    if (input) {
      if (input.indexOf('/')>-1){
        input = input.split('/');
        output = input[2] + '-' + input[1] + '-' + input[0];
      } else {
    	  output = input;
      }
      /* else if(input.indexOf('-')>-1){
      }
        input = input.split('-');
        output = input[2] + '/' + input[1] + '/' + input[0];
      }*/
    }
    return output;
  }

});

},{"../models/base-filter-model":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\base-filter-model.js","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\years-only-filter-model.js":[function(require,module,exports){
var $ = require('jquery');
var _ = require('underscore');
var BaseFilterModel = require('../models/base-filter-model');

module.exports = BaseFilterModel.extend({

	defaults : {
		selectedYear : undefined,
		defaultYear : undefined,
		modelType : 'YEAR-SINGLE-VALUE'
	},

	initialize : function(options) {
		BaseFilterModel.prototype.initialize.apply(this, [ options ]);
		this.url = options.endpoint;
		this.set('_loaded', $.Deferred());
	},

	parse : function(data) {
		if (data && data.value && data.value.options) {
			data.defaultYear = _.find(data.value.options, function(item) {
				return item.id === data.value.defaultId;
			}).value;
		}
		// console.log(data);
		this.get('_loaded').resolve();
		return data;
	},

	serialize : function() {	
		if (this.get('selectedYear')) {
			var key = this.get('id');
			var obj = {};
			obj[key] = {
				year : this.get('selectedYear'),
				modelType : this.get('modelType'),
				displayName : this.get('name')
			};
			return obj;
		} else {
			return null;
		}
	},

	deserialize : function(obj) {
		var key = this.get('id');
		if (obj && obj[key]) {
			this.set('selectedYear', obj[key].year);
			this.set('displayName', obj[key].displayName);
		} else {
			this.reset();
		}
	},

	reset : function() {
		this.set('selectedYear', '');
		this.set('displayName', '')
	},

});

},{"../models/base-filter-model":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\base-filter-model.js","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\tree\\tree-node-model.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');
var TreeNodeModel; // declare here to help with ref loop of collection and model
var TreeNodeCollection = Backbone.Collection.extend({  model:TreeNodeModel });

//TODO: propagation bug if mid level node is half filled and you 'deselect all' it won't propogate to children.

TreeNodeModel = Backbone.Model.extend({
  defaults:{
    selected: undefined,  // default is selected. change to string / ternary, for off, semi, and on
    expanded: true,
    visible: true,
    numSelected: 0,
    numPossible: 0,
    children: null,     // type TreeNodeCollection
    isSelectable: false  // is this node itself selectable (ie. should it have an 'unkown' child)
  },

  initialize:function(obj) {
    var self = this;
    var childrenCollection = new TreeNodeCollection();
    this.set('children', childrenCollection);
    
    /* TODO-CONSTANTIN: temporary comment until I am finished learning Filters frontend 
     console.log("building a tree node model for: " + JSON.stringify(obj));
     */
    
    //iterate over children
    if (Array.isArray(obj.children)) {
      _.each(obj.children, function(child) {
        var newChild = new TreeNodeModel(child);
        childrenCollection.add(newChild);
      });
    }

    // if we have children, then add self as a leaf node, 'unkown'
    if (!childrenCollection.isEmpty() &&  this.get('isSelectable')) {
      var unkownNode = new TreeNodeModel(self.toJSON());
      unkownNode.set('name', 'unkown: ' + this.get('name'));
      childrenCollection.add(unkownNode);
    }

    this._addListenersToChildren();

    this.on('change:selected', self._onSelectChange);

    this._updateCount();
  },


// merge based on filterId as we serialize....
// options.wholeModel returns whole Models instead of just ids
// options.includeUnselected returns full tree, even if nodes are not selected.
// Code explicitly ignores Donor Group,Donor Type and the rest of the organizations.
//   they only have FilterIds for deserialize for backwards compatibility.
// TODO: consider pulling out options.includeUnselected into its own function getAllFilters()
serialize: function(options) {
	  var tmpSerialized = {};
	  var children = this.get('children');

    /**
	        
	     
	  +--^----------,--------,-----,--------^-,
	  | |||||||||   `--------'     |          O
	  `+---------------------------^----------|
	    `\_,---------,---------,--------------'
	      / XXXXXX /'|       /'
	     / XXXXXX /  `\    /'                      TO INVESTIGATE: why is this function called for 4 times (!!!) per each item when pressing "apply"?
	    / XXXXXX /`-------'
	   / XXXXXX /
	  / XXXXXX /
	 (________(                
	   
	    
	// 
	//    if ((this.get('name')== 'Yes') || (this.get('name') == 'No') || (this.get('name') == 'All') || this.get('name') == 'Humanitarian Aid' || this.get('name') == 'Disaster Response Marker') {
	//    	console.log('serializing node with name ' + this.get('name') + ", selected: " + this.get('selected'));
	//
	//    	debugger;
	//    }
	*/
    
    if (options.includeUnselected) {
    	if (this.get('filterId') && this.get('filterId') !== 'Donor Group' && this.get('filterId') !== 'Donor Type' 
    		&& this.get('filterId') !== 'Implementing Agency' && this.get('filterId') !== 'Beneficiary Agency' && this.get('filterId') !== 'Executing Agency' && this.get('filterId') !== 'Responsible Organization') {
    			tmpSerialized[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
    	} else{
    		tmpSerialized.unassigned = (options.wholeModel? [this]:[this.id]);
    	}
    	this._serializeChildren(tmpSerialized, children, options);
    } else {
    	if (children.length > 0) {
    		// If all children are selected, and we have our own filterId, then just use our id, don't recurse.
    		if (this.get('numSelected') >= this.get('numPossible') && this.get('filterId') && this.get('filterId') !== 'Donor Group' && this.get('filterId') !== 'Donor Type' 
    			&& this.get('filterId') !== 'Implementing Agency' && this.get('filterId') !== 'Beneficiary Agency' && this.get('filterId') !== 'Executing Agency' && this.get('filterId') !== 'Responsible Organization') {
    			if (this.id === undefined) // top level of a non-hierarchical group (like type of assistance)
       				this._serializeChildren(tmpSerialized, children, options);
        		else
        			tmpSerialized[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
    		} else {
    			this._serializeChildren(tmpSerialized, children, options);
    		}
      } else {
    	  //no children so just return self.
    	  if (this.get('selected')) {
    		  if (this.get('filterId') && this.get('filterId') !== 'Donor Group' && this.get('filterId') !== 'Donor Type' 
    			  && this.get('filterId') !== 'Implementing Agency' && this.get('filterId') !== 'Beneficiary Agency' && this.get('filterId') !== 'Executing Agency' && this.get('filterId') !== 'Responsible Organization') {
    			  	tmpSerialized[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
    		  } else {
    			  tmpSerialized.unassigned = (options.wholeModel? [this]:[this.id]);
    		  }
    	  }
      }
   }
   this._mergeUnassigned(tmpSerialized);
   return tmpSerialized;
},

  _serializeChildren: function(tmpSerialized, children, options){
    children.each(function(child) {
      var serializedChild = child.serialize(options);
      _.each(serializedChild, function(v,k){
        if(v){
          //merge if key exists
          if (tmpSerialized[k]) {
            tmpSerialized[k] = tmpSerialized[k].concat(v);
          } else {
            tmpSerialized[k] = v;
          }
        }
      });
    });
  },

  _mergeUnassigned: function(tmpSerialized){
    // if current node has a filterId put all 'unassigned' elements under this.
    if(this.get('filterId')){
      var filterId = this.get('filterId');
      if(tmpSerialized[filterId] && tmpSerialized.unassigned){
        tmpSerialized[filterId] = tmpSerialized[filterId].concat(tmpSerialized.unassigned);
        delete tmpSerialized.unassigned;
      } else if (tmpSerialized.unassigned){
        tmpSerialized[filterId] = tmpSerialized.unassigned;
        delete tmpSerialized.unassigned;
      }
    }
  },

  deserialize: function(blob) {
    var self = this;
    var children = this.get('children');
    if (children.length > 0) {
      children.each(function(child) {
        if(!child.get('filterId') && self.get('filterId')){
          child.set('filterId', self.get('filterId'));
        }
        child.deserialize(blob);
      });
    }

    if(blob[this.get('filterId')]){
      if (_(blob[this.get('filterId')]).indexOf(this.id) > -1) {
        this.set('selected', true, {propagation: true});
      } else if (children.length === 0) {
        this.set('selected', false, {propagation: true});
      }
    }
  },


  _onSelectChange:function(model, argument, options) {
    var self = this;
    var children = this.get('children');

    if (this.get('selected')) {
      this.set('numSelected', this.get('numPossible'));
    } else {
      this.set('numSelected', 0);
    }

    if (!children.isEmpty()) {
      self._updateChildNodes(options.propagation);
    }

    if (options.propagation) {
      self.trigger('updateCount');
    }
  },


  _addListenersToChildren:function() {
    var self = this;
    var children = this.get('children');
    children.each(function(child) {
      child.on('change:visible', function() {
        // If no children are visible, then hide self.
        if (!children.findWhere({visible: true})) {
          self.set({visible: false});
        } else {
          self.set({visible: true});
        }
      });
      child.on('updateCount', function() {
        self._updateCount();
        self.trigger('updateCount');
      });
    });
  },

  _updateCount:function() {
    var children = this.get('children');
    var countTotal = {
      selected: 0,
      possible:0
    };

    if (!children.isEmpty()) {
      children.each(function(child) {
        countTotal.selected += child.get('numSelected');
        countTotal.possible += child.get('numPossible');
      });
    } else {
      countTotal = {
        selected: (this.get('selected') ? 1 : 0),
        possible: 1
      };
    }

    this.set('numSelected', countTotal.selected);
    this.set('numPossible', countTotal.possible);
  },

  _updateChildNodes:function(propagation) {
    var self = this;
    var children = this.get('children');

    if (!children.isEmpty()) {
      children.each(function(child) {
        child.set('selected', self.get('selected'), {propagation: propagation});
      });
    }
  },

  filterText: function(txt) {
    var children = this.get('children');

    if (!children.isEmpty()) {
      // if the node itself matches, turn it on, even if no children are visible.
      if (this.get('name') && this.get('name').toLowerCase().indexOf(txt) > -1) {
        this.set('visible', true);
      }

      // FYI: putting inside an else above keeps children visible if parent matches.
      children.each(function(child) {
        child.filterText(txt);
      });

    } else {
      if (this.get('name') && this.get('name').toLowerCase().indexOf(txt) > -1) {
        this.set('visible', true);
      } else {
        this.set('visible', false);
      }
    }
  }

});


module.exports = TreeNodeModel;

},{"backbone":"backbone","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\tree\\tree-node-view.js":[function(require,module,exports){

var _ = require('underscore');
var Backbone = require('backbone');
var $ = require('jquery');

var Template = "<div class=\"node small\">\n  <div class=\"selectable\"></div>\n  <div class=\"toggle-nav\">\n    <% if(name.length > 63){ %>\n      <span title=\"<%= name %>\"><%= name.substring(0,60) %>...</span>\n    <% } else { %>\n      <%= name %>\n    <% } %>\n\n\n    <span class=\"count\">(<%= numSelected %> / <%= numPossible %>)</span>\n    <span class=\"expanded\">+</span>\n  </div>\n\n  <% /*TODO: fix hardcode of 'unkown' */\n  if (obj.name && obj.name.indexOf(\"unkown\")>-1) { %>\n    &nbsp;<a href=\"#\"\n      data-toggle=\"popover\"\n      data-container=\"body\"\n      data-placement=\"right\"\n      data-trigger=\"click\"\n      data-content=\"projects that aren't tagged to a specific child.\">\n      <span class=\"glyphicon glyphicon-info-sign\"></span>\n    </a>\n  <%}%>\n</div>\n";


var TreeNodeView = Backbone.View.extend({

  tagName: 'li',
  className: 'parent_li',

  //TODO: debug after usability testing, currently setting in addUIListeners
  // won't work on second use of widget.
  // events: {
  //   'click .selectable': 'select',
  //   'click  .toggle-nav': 'clickName'
  // },

  template: _.template(Template),
  isRoot: false,
  initialize:function(options) {
	 if(!_.isUndefined(options) && !_.isUndefined(options.isRoot)){
		 this.isRoot = options.isRoot;
	 }
	  
  },


  render:function(model) {
    this.model = model;
    if (model) {
      this.$el.html(this.template(model.toJSON()));
      this.renderChildren();
    }

    return this;
  },

  renderChildren:function() {
    var ul = $('<ul>');
    this.$el.append(ul);

    var children = this.model.get('children');
    if (!children.isEmpty()) {
      children.each(function(child) {
        var tmpView = new TreeNodeView();
        ul.append(tmpView.render(child).$el);
      });
    } else {
      this.$('.expanded').remove();
      this.$('> .node > .toggle-nav > .count').text('');
    }

    this._addModelListeners();
    this._addUIListeners();

    this._updateSelection();
    this._updateExpanded(ul);
  },

  _addModelListeners:function() {
    var self = this;

    //Add model listeneres
    this.model.on('change:selected', function() {
      self._updateSelection();
    });

    this.model.on('change:expanded', function() {
      self._updateExpanded();
    });

    this.model.on('change:numSelected', function() {
      self._updateCountUI();
    });

    this.model.on('change:visible', function() {
      self._updateVisibility();
    });
  },

  _addUIListeners:function() {
    var self = this;
    this.$('> .node > .selectable').on('click', function() {
      self.clickBox();

    });
    this.$('> .node > .toggle-nav').on('click', function() {
      self.clickName();
    });
  },

  _updateSelection:function() {
    this._updateCheckboxFill();
  },

  _updateCountUI:function() {
    if (!this.model.get('children').isEmpty()) {
      this.$('> .node > .toggle-nav > .count').text(
        '(' + this.model.get('numSelected') + ' / ' + this.model.get('numPossible') + ')');
      this._updateCheckboxFill();
    }
  },

  _updateVisibility: function() {
    if (this.model.get('visible')) {
      this.$el.show();
    } else {
      this.$el.hide();
    }
  },


  // For updating non-leaf nodes
  _updateCheckboxFill:function() {
    if (!this.model.get('children').isEmpty()) {
      if (this.model.get('numSelected') > 0) {
        if (this.model.get('numSelected') < this.model.get('numPossible')) {
          this.$('> .node > .selectable').addClass('half-fill');
          this.$('> .node > .selectable').removeClass('selected');
        } else {
          this.$('> .node > .selectable').removeClass('half-fill');
          this.$('> .node > .selectable').addClass('selected');
        }
      } else if (this.model.get('numSelected') === 0) {
        this.$('> .node > .selectable').removeClass('half-fill');
        this.$('> .node > .selectable').removeClass('selected');
      }
    } else { // else leaf node
      if (this.model.get('selected')) {
        this.$('> .node > .selectable').addClass('selected');
      } else {
        this.$('> .node > .selectable').removeClass('selected');
      }
    }
  },

  _updateExpanded:function(ul) {
    var iElement = this.$('> .node > .toggle-nav > .expanded');
    if (this.model.get('expanded')) {
      this.expand();
      iElement.text('-');
      iElement.addClass('open').removeClass('closed');
    } else {
      this.collapse();

      // to run on first time...need to use ul, since el is not on DOM yet
      if (ul) {
        ul.find('> li').hide();
      }

      iElement.text('+');
      iElement.addClass('closed').removeClass('open');
    }
  },


  clickBox:function() {
	  if(this.isRoot){
		  this.model.set('selected', !this.model.get('selected'));		  
	  }else{
		  this.model.set('selected', !this.model.get('selected'), {propagation: true});  
	  }    
  },


  clickName:function() {
    // if we have children expand
    if (!this.model.get('children').isEmpty()) {
      this.model.set('expanded', !this.model.get('expanded'));
    } else {
      // leaf node, so pretend the clicked on the box
      this.clickBox();
    }
  },


  collapse:function() {
    var children = this.$el.find(' > ul > li');
    children.hide('fast');

  },

  expand:function() {
    var children = this.$el.find(' > ul > li');
    children.show('fast');
  }

});

module.exports = TreeNodeView;

},{"backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\utils\\date-utils.js":[function(require,module,exports){
var _ = require('underscore');

var extractDates = function(settings, filtersOut, minName, maxName) {
    filtersOut.otherFilters = filtersOut.otherFilters || {};
    filtersOut.otherFilters.date = filtersOut.otherFilters.date || {
        start: '',
        end: ''
      };

    var defaultMinDate = _.find(settings, function(item) {
      return item.get('id') === minName;
    });
    if (defaultMinDate !== undefined && defaultMinDate.get('name') !== '') {
      filtersOut.otherFilters.date.start = defaultMinDate.get('name');
    }
    var defaultMaxDate = _.find(settings, function(item) {
      return item.get('id') === maxName;
    });
    if (defaultMaxDate !== undefined && defaultMaxDate.get('name') !== '') {
      filtersOut.otherFilters.date.end = defaultMaxDate.get('name');
    }
  }

module.exports = {
		extractDates: extractDates
}

},{"underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\base-filter-view.js":[function(require,module,exports){

var _ = require('underscore');
var $ = require('jquery');

var Backbone = require('backbone');
var TitleTemplate = "<li>\n\t<a href=\"#\">\n\t\t<span data-i18n=\"amp.gis:pane-subfilters-<%= name.replace(/ /g,'') %>\">\n\t\t\t<%= name %>\n\t\t</span>   \n\t\t<span class='filter-count small pull-right'></span>\n\t</a>\n</li>";
var ContentTemplate = "<%\n  // this renders the \"big\" filter list (the tabs)\n%>\n<div class=\"panel-heading\">\n  <a type=\"button\" class=\"close cancel\"  aria-hidden=\"true\">&times;</a>\n  <h3 data-i18n=\"amp.gis:title-filters\" class=\"panel-title\">Filters</h3>\n</div>\n<div class=\"panel-body filter-body\">\n\n  <ul class=\"nav nav-tabs filter-titles\" role=\"tablist\">\n  </ul>\n\n  <div class=\"tab-content filter-options\">\n    <img src=\"img_2/loading-icon.gif\" />\n  </div>\n</div>\n<div class=\"panel-footer\">\n  &nbsp;\n  <div class=\"pull-right\" style=\"display: inline-block; margin-bottom: 5px;\">\n    <button type=\"button\" class=\"btn btn-sm btn-danger reset\"  data-i18n=\"amp.gis:button-reset\"  title=\"Turn off all filters.\">Reset</button>\n    <button type=\"button\" class=\"btn btn-sm btn-warning cancel\"  data-i18n=\"amp.gis:button-cancel\"  title=\"Revert filters to state when opened.\">Cancel</button>\n    <button type=\"button\" class=\"btn btn-sm btn-success apply\"  data-i18n=\"amp.gis:button-apply\" >Apply</button>\n  </div>\n</div>\n";

// Parent base view for filters.
module.exports = Backbone.View.extend({

  className: 'filter-type',

  titleTemplate: _.template(TitleTemplate),
  contentTemplate: _.template(ContentTemplate),

  initialize:function(options) {
    this.app = options.app;
  },

  renderFilters: function() {

  },

  renderTitle: function() {	  
    var self = this;
    this.titleEl = this.titleTemplate(this.model.toJSON());
    this.$titleEl = $(this.titleEl);
    this.$titleEl.on('click', function(evt) {
      // console.log('handling the click on low-level titleEl...'); CONSTANTIN TEMP COMMENT WHILE LEARNING FILTERS
      $(this).siblings().removeClass('active');
      $(this).addClass('active');

      self.$el.html('');
      self.renderFilters();
      return false;
    });

    return this;
  }

});

},{"backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\filters-view.js":[function(require,module,exports){
/**
 * this is the view which renders the big Filter contents (the tabs)
 */

var $ = require('jquery');
var _ = require('underscore');
var Backbone = require('backbone');

var Translator = require('amp-translate');

var TopLevelFilterView = require('../views/top-level-filter-view');
var AllFilterCollection = require('../collections/all-filters-collection');


var Template = "<%\n  // this renders the \"big\" filter list (the tabs)\n%>\n<div class=\"panel-heading\">\n  <a type=\"button\" class=\"close cancel\"  aria-hidden=\"true\">&times;</a>\n  <h3 data-i18n=\"amp.gis:title-filters\" class=\"panel-title\">Filters</h3>\n</div>\n<div class=\"panel-body filter-body\">\n\n  <ul class=\"nav nav-tabs filter-titles\" role=\"tablist\">\n  </ul>\n\n  <div class=\"tab-content filter-options\">\n    <img src=\"img_2/loading-icon.gif\" />\n  </div>\n</div>\n<div class=\"panel-footer\">\n  &nbsp;\n  <div class=\"pull-right\" style=\"display: inline-block; margin-bottom: 5px;\">\n    <button type=\"button\" class=\"btn btn-sm btn-danger reset\"  data-i18n=\"amp.gis:button-reset\"  title=\"Turn off all filters.\">Reset</button>\n    <button type=\"button\" class=\"btn btn-sm btn-warning cancel\"  data-i18n=\"amp.gis:button-cancel\"  title=\"Revert filters to state when opened.\">Cancel</button>\n    <button type=\"button\" class=\"btn btn-sm btn-success apply\"  data-i18n=\"amp.gis:button-apply\" >Apply</button>\n  </div>\n</div>\n";
var TitleTemplate = "<%\n// renders the title of a tab \n%>\n<li class=\"\"><a data-i18n=\"amp.gis:pane-filters-<%= name.replace(/ /g,'') %>\" href=\"#filter-pane-<%= name.replace(/ /g,'') %>\" role=\"tab\" data-toggle=\"tab\"><%= name %></a></li>\n";
var filtersViewLog = require("../../../../../reamp/tools/log")('amp:filters:top-level:view');

var SettingsCollection = require('../collections/settings-collection');

var DateUtils = require('../utils/date-utils');

var filterInstancesNames = {donors: 'Funding Organizations', sectors : 'Sectors', programs: 'Programs', 
	  activity: 'Activity', allAgencies: 'All Agencies', financials: 'Financial',
		  locations: 'Location', others: 'Other'};


module.exports = Backbone.View.extend({
  id: 'tool-filters',
  name: 'Filters',
  apiURL: '/rest/filters',

  events: {
    'click .apply': 'applyFilters',
    'click .cancel': 'cancel',
    'click .reset': 'resetFilters'
  },

  // collection of top-level-filter views..
  filterViewsInstances:{},

  template: _.template(Template),
  titleTemplate: _.template(TitleTemplate),
  PARAMS_DATE_FORMAT:'yy-mm-dd', //backend expects filters to be submitted in this format
  initialize:function(options) {
    var self = this;
    this.draggable = options.draggable;
    this.caller = options.caller;
    this.settings = new SettingsCollection();
    this.settings.fetch();
    
    this.dateFormatMappings = [];
    this.dateFormatMappings.push({ampformat: 'dd/MMM/yyyy', datepickerformat:'dd/M/yy'});
    this.dateFormatMappings.push({ampformat: 'MMM/dd/yyyy', datepickerformat:'M/dd/yy'});
    this.dateFormatMappings.push({ampformat: 'dd/MM/yyyy', datepickerformat:'dd/mm/yy'});
    this.dateFormatMappings.push({ampformat: 'MM/dd/yyyy', datepickerformat:'mm/dd/yy'});
    
    if(options.translator === undefined) {
      this.createTranslator();
    } else {
      this.translator = options.translator;
    }

    this.firstRender = true;
    this._createTopLevelFilterViews();
    this.allFilters = new AllFilterCollection([],options);
    this._loaded =  this.allFilters._loaded;
    this._getFilterList().then(function() {    	
        self.allFilters.each(function(model) {        	
      	  if(model.get('empty')){      		     		  
      		for (key in filterInstancesNames) {
    			if (filterInstancesNames.hasOwnProperty(key)) {
    				if(filterInstancesNames[key] == model.get('group')){
    					// remove tab if there is no data for the tab
    					delete filterInstancesNames[key];
    					delete self.filterViewsInstances[key];
    				}    				
    				
    			}
    		}      		
      	  }else{
      		self._createFilterViews(model);  
      	  }
      	  
      });        
   
      return this;
    });

  },

  
//  
//  _generateFilterViewInstance : function(keyname) {
//	  return new TopLevelFilterView({name:filterInstancesNames[keyname], translator: this.translator, translate: this.translate});
//  },	  					  
	  					
  
  _createTopLevelFilterViews: function() {
    //this.filterViewsInstances = {
    		for (key in filterInstancesNames) {
    			if (filterInstancesNames.hasOwnProperty(key)) {
    				
    				this.filterViewsInstances[key] = new TopLevelFilterView({name:filterInstancesNames[key], translator: this.translator, translate: this.translate, filterView: this});
    			}
    		}
    		/*
      donors: new TopLevelFilterView({name:'Funding Organizations', translator: this.translator, translate: this.translate}),
      sectors: new TopLevelFilterView({name:'Sector', translator: this.translator, translate: this.translate}),
      programs: new TopLevelFilterView({name:'Programs', translator: this.translator, translate: this.translate}),
      activity: new TopLevelFilterView({name:'Activity', translator: this.translator, translate: this.translate}),
      allAgencies: new TopLevelFilterView({name:'All Agencies', translator: this.translator, translate: this.translate}),
      financials: new TopLevelFilterView({name:'Financial', translator: this.translator, translate: this.translate}),
      locations: new TopLevelFilterView({name:'Location', translator: this.translator, translate: this.translate}),
      others: new TopLevelFilterView({name:'Other', translator: this.translator, translate: this.translate})
    };*/
  },


  render: function() {
    var self = this;
    this.$el.addClass('panel panel-primary');
    if (this.draggable) {
      this.$el.draggable({cursor: 'move', containment: 'window' });
    }
    this.firstRender = true;

    if (this.firstRender) {
      this.$el.html(this.template({}));
      this.$el.show();

      this._getFilterList().done(function() {
//    	self.cleanupUnusedTabs(); 
        self.renderFilters();
        self.translate(this.$el);
      });
      //debugger; // AMP-20617  wth does thing not work in saiku?
      // handle click on a Tab's title: http://getbootstrap.com/javascript/#tabs-events
      $(document).on('shown.bs.tab click', "ul.nav.filter-titles>li>a[data-toggle='tab']", function (e) {  // <- this line makes little sense but works in Saiku/Tabs also
        //this.$el.find("ul.nav.filter-titles>li>a[data-toggle='tab']").on('shown.bs.tab', function (e) {   // <- this line works in anything except Saiku/Tabs
        /**
         * the 'click' event added because (weirdly) the shown.bs.tab event not being fired AT ALL under Saiku/Tabs. Until this is investigated
         * on GIS/Dashboard tabs this second event is superfluous
         */

        //e.target // newly activated tab
        //e.relatedTarget // previous active tab

        var activeTab = $(e.target.parentElement).index(); // shameful hack, but haven't been able to find a cleaner solution
        var oldTabNr = e.relatedTarget ? $(e.relatedTarget.parentElement).index() : -1;
        filtersViewLog.log('switching from filters tab', oldTabNr, 'to tab', activeTab);
        $(e.target).closest('ul.filter-titles').attr('active-tab-number', activeTab); // not used in the current implementation of the code

        // render the first item of the tab
        var tabId = $(e.target).attr('href');
        var tabFirstChild = $(tabId).find('ul.sub-filters-titles>li:first a');
        if (tabFirstChild)
          tabFirstChild.click();
      });

      this.firstRender = false;
    } else {
      self.translate();
    }

    return this;
  },

  createTranslator: function(force) {
    var self = this;
    var filterTranslateKeys = JSON.parse("{\n  \"amp.gis:title-Country\": \"Country\",\n  \"amp.gis:title-Region\": \"Region\",\n  \"amp.gis:title-Zone\": \"Zone\",\n  \"amp.gis:title-District\": \"District\",\n  \"amp.gis:title-filters\": \"Filter\",\n  \"amp.gis:title-filters\": \"Filter\",\n  \"amp.gis:pane-filters-search\": \"Go\",\n  \"amp.gis:pane-filters-select\": \"select all\",\n  \"amp.gis:pane-filters-deselect\": \"deselect all\",\n  \"[placeholder]amp.gis:pane-filters-search-placeholder\": \"Search...\",\n  \"amp.gis:pane-filters-FundingOrganizations\": \"Funding Organizations\",\n  \"amp.gis:pane-filters-Sector\": \"Sector\",\n  \"amp.gis:pane-filters-Sectors\": \"Sectors\",\n  \"amp.gis:pane-filters-Programs\": \"Programs\",\n  \"amp.gis:pane-filters-Activity\": \"Activity\",\n  \"amp.gis:pane-filters-AllAgencies\": \"All Agencies\",\n  \"amp.gis:pane-filters-Financial\": \"Financial\",\n  \"amp.gis:pane-filters-Location\": \"Location\",\n  \"amp.gis:pane-filters-Other\": \"Other\",\n  \"amp.gis:pane-subfilters-Donor\": \"Donor\",\n  \"amp.gis:pane-subfilters-Primary\": \"Primary\",\n  \"amp.gis:pane-subfilters-Secondary\": \"Secondary\",\n  \"amp.gis:pane-subfilters-NationalPlanObjective\": \"National Plan Objective\",\n  \"amp.gis:pane-subfilters-ActivityStatus\": \"Activity Status\",\n  \"amp.gis:pane-subfilters-ApprovalStatus\": \"Approval Status\",\n  \"amp.gis:pane-subfilters-ImplementingAgency\": \"Implementing Agency\",\n  \"amp.gis:pane-subfilters-ExecutingAgency\": \"Executing Agency\",\n  \"amp.gis:pane-subfilters-BeneficiaryAgency\": \"Beneficiary Agency\",\n  \"amp.gis:pane-subfilters-ContractingAgency\": \"Contracting Agency\",\n  \"amp.gis:pane-subfilters-AidModality\": \"Aid Modality\",\n  \"amp.gis:pane-subfilters-TypeOfAssistance\": \"Type Of Assistance\",\n  \"amp.gis:pane-subfilters-ResponsibleOrganization\": \"Responsible Organization\",\n  \"amp.gis:pane-subfilters-Dates\": \"Dates\",\n  \"amp.gis:pane-subfilters-RegionalGroup\": \"Regional Group\",\n  \"amp.gis:pane-subfilters-SectorGroup\": \"Sector Group\",\n  \"amp.gis:pane-subfilters-TertiarySectors\": \"Tertiary Sectors\",\n  \"amp.gis:pane-subfilters-FinancingInstruments\": \"Financing Instruments\",\n  \"amp.gis:pane-filters-all\": \"all\",\n  \"amp.gis:button-reset\": \"Reset\",\n  \"amp.gis:button-cancel\": \"Cancel\",\n  \"amp.gis:button-apply\": \"Apply\",\n  \"amp.gis:pane-subfilters-startdate\": \"Start Date:\",\n  \"amp.gis:pane-subfilters-enddate\": \"End Date:\",\n  \"amp.gis:pane-subfilters-empty\": \"No data for this filter\"\n}\n");
    // setup any popovers as needed...
    self.popovers = self.$('[data-toggle="popover"]');
    self.popovers.popover();
    if (force === true || self.translator === undefined) {
      filtersViewLog.onDebug(function() {
        filtersViewLog.log('Creating translator for filters because', force === true ? 'I was forced' : 'there is no translator');
      });
      self.translator = new Translator({defaultKeys: filterTranslateKeys});
    }
  },

  translate: function(target) {
    var element = this;
    if (target !== undefined) {
      element = target;
    }
    if (element.el !== undefined) {
      this.translator.translateDOM(element.el);
    } else {
      this.translator.translateDOM(element);
    }
  },

  /**
   * renders the tabs within the filters, only rendering the first item of the active tab (the others don't have their first item's contents rendered for performance reasons)
   */
  renderFilters: function() {
    this.$('.filter-options').html('');

    var renderingTitleNumber = -1;
    var activeTitleNumber = this.$('.filter-titles').attr('active-tab-number') || 0;

    for (var filterView in this.filterViewsInstances) {
//    	console.log(filterView);
      if (this.filterViewsInstances.hasOwnProperty(filterView)) {
    	  contained = false;
    	  var index;
    	  for (index = 0; index < this.allFilters.length; index++) {
    		  if ((this.allFilters.models[index].attributes.tab === this.filterViewsInstances[filterView].name) || 
    		  (this.allFilters.models[index].attributes.group === this.filterViewsInstances[filterView].name)){
    			  contained = true;
    			  break;
    		  } 
    	  }
    	  if (!contained) {
    		  delete this.filterViewsInstances[filterView];
    		  continue;
    	  }
    		  
        var tmpFilterView = this.filterViewsInstances[filterView];
        renderingTitleNumber = renderingTitleNumber + 1;
        // console.log('rendering top-level-filter-view ' + tmpFilterView.name); CONSTANTIN - comment to be removed once filters sanitisation is done
        this.$('.filter-titles').append(tmpFilterView.renderTitle().titleEl);
        var active = renderingTitleNumber == activeTitleNumber;
        this.$('.filter-options').append(tmpFilterView.renderFilters(active).el);
      }
    }

    // Opens the first tab in the filter
    this.$('.filter-titles a:first').tab('show');
  },


  _getFilterList: function() {
    return this.allFilters.load();
  },

  _createFilterViews: function(tmpModel) {
    // TODO: magic strings are dangerous, config somewhere...
    switch (tmpModel.get('group')) {
      case 'ActivityBudgetList':
      case 'TypeOfAssistanceList':
      case 'ModeOfPaymentList':
      case 'ExpenditureClassList':
      case 'FinancingInstrumentsList':
      case 'FundingStatus':
      case 'effectiveFundingDate':
      case 'fundingClosingDate':
        this.filterViewsInstances.financials.filterCollection.add(tmpModel);
        break;
      case 'ActivityStatusList':
      case 'ActivityApprovalStatus':
        this.filterViewsInstances.activity.filterCollection.add(tmpModel);
        break;
      case 'Programs':
        this.filterViewsInstances.programs.filterCollection.add(tmpModel);
        break;
      case 'Sectors':
        this.filterViewsInstances.sectors.filterCollection.add(tmpModel);
        break;
      case 'Donor':
        this.filterViewsInstances.donors.filterCollection.add(tmpModel);
        break;
      case 'Role':
        this.filterViewsInstances.allAgencies.filterCollection.add(tmpModel);
        break;
      case 'LocationList':
        this.filterViewsInstances.locations.filterCollection.add(tmpModel);
        break;
      default:
        this.filterViewsInstances.others.filterCollection.add(tmpModel);
    }

  },
  
  serializeToModels: function(filter) {
	  var _self = this;
	  _self.values = {0: [], 1: [], 2: [], 3: []}; //TODO: Implement calculateFilterDept() function.
	  if (filter.get('tree')) {
		  var entryPoint = filter.get('tree').get('children');
		  var currentLevel = 0;
		  if (filter.get('numSelected') !== filter.get('numPossible')) {
			  _.each(entryPoint.models, function(item) {
				  _self.serializeLevel(item, 0, _self.values);
			  });
		  }
	  } else {
		  _self.values = filter;
	  }
	  return _self.values;
  },
    
  serializeLevel: function(node, level, values) {
	// When we enter here it means the parent is not 'fully selected'.
	  var _self = this;
	  if (node.get('children').models.length > 0) {
		  // "Double check" because some selected middle nodes have get('selected') === false. 
		  if (node.get('numSelected') !== node.get('numPossible') && node.get('selected') === false) {
			  _.each(node.get('children').models, function(node2) {				  
				  _self.serializeLevel(node2, level + 1, values);
			  });
		  } else {
			  if (values[level] === undefined) {
				  values << [];
			  }
			  values[level].push({'level': level, 'levelName': node.get('filterId'), name: node.get('name')});
		  }
	  } else { // We reached the last level..
		  if (node.get('selected') === true) {
			  if (values[level] === undefined) {
				  values << [];
			  }
			  values[level].push({'level': level, 'levelName': node.get('filterId'), name: node.get('name')});
		  }
	  }	  
  },
  
  //TODO: move from view to all-collection
  serialize: function(options) {
    var self = this;
    var serializedFilters = {'columnFilters':{}, 'otherFilters':{} };

    this.allFilters.each(function(filter) {
      // TODO: build a util for bettermerge that concat's array if
      // duplicate keys in objects...
      if (filter.get('id') || filter.url) {
        if (filter.get('modelType') === 'DATE-RANGE-VALUES') {
          _.extend(serializedFilters.otherFilters, filter.serialize(options));
        } else if (filter.get('modelType') === 'YEAR-SINGLE-VALUE') {
            _.extend(serializedFilters.otherFilters, filter.serialize(options));
        } else {
          var serialized = filter.serialize(options);
          if (options.wholeModel === true) {
            var keys = [];
            for(var k in serialized) keys.push(k);
            if (keys[0] !== undefined && serialized[keys[0]] !== undefined) {
              serialized[keys[0]].filterName = (filter.get('displayName') || filter.get('name'));
              serialized[keys[0]].serializedToModels = self.serializeToModels(filter);
            }
          }
          _.extend(serializedFilters.columnFilters, serialized);
        }
      }
    });

    //remove empty / false values.
    _.each(serializedFilters, function(v, k) {
      if(!v || _.isEmpty(v)) {
        delete serializedFilters[k];
      }
    });

    return serializedFilters;
  },
 deserialize: function(blob, options) {
    if (blob) {
      if(_.isUndefined(this.initialFilters)){
    	  this.initialFilters = blob;
      }     
      var that = this;
      that.allFilters.each(function(filter) {
        if (filter.get('id') || filter.url) {
          if(filter.get('modelType') === 'DATE-RANGE-VALUES') {
            if (_.isEmpty(blob.otherFilters)){ 
            	that.setDefaultDates(blob);
            }            
            filter.deserialize(blob.otherFilters);
          } else if (filter.get('modelType') === 'YEAR-SINGLE-VALUE') {
        	  filter.deserialize(blob.otherFilters);  
          } else{
            filter.deserialize(blob.columnFilters);
          }
        }
      });
    } else {
      console.warn('could not deserialize blob:', blob);
    }
    if (!options || !options.silent) {
      this.applyFilters();  // triggers the "apply" event
    }
  },

  showFilters: function() {
    this.render();
    this.filterStash = null;  // in case they haven't loaded yet, don't try to .serialize()
    this._loaded.done(_.bind(function() { this.filterStash = this.serialize({}); }, this));
  },

  setStash: function() {
    this.filterStash = null;  // in case they haven't loaded yet, don't try to .serialize()
    this._loaded.done(_.bind(function() { this.filterStash = this.serialize({}); }, this));
  },

  resetFilters: function() {
	var self = this;
	 var blob = !_.isUndefined(this.initialFilters) ? JSON.parse(JSON.stringify(this.initialFilters)) : {};//clone initial filters
    this.allFilters.each(function(filter) {
    if (filter.get('modelType') === 'DATE-RANGE-VALUES') {
    	 if (_.isEmpty(blob.otherFilters)){ 
    		 self.setDefaultDates(blob);
         }   	 
    	 filter.deserialize(blob.otherFilters);
     }else{
    	 filter.reset();
     }      
    });
  },

  applyFilters: function() {
    this._loaded.done(_.bind(function() {
      var state = this.serialize({});
      this.trigger('apply', state);
    }, this));
  },

  getDateFormat: function(){
	  if(this.dFormat){
		  return this.dFormat;
	  }	
	  
	  var dateFormatSetting = this.settings.findWhere({ id: 'default-date-format' });
	  if(dateFormatSetting && dateFormatSetting.get("options") && dateFormatSetting.get("options").length > 0){			
			var foundMapping =_.findWhere(this.dateFormatMappings, {ampformat: dateFormatSetting.get("options")[0].name});
			if(foundMapping){
				this.dFormat = foundMapping.datepickerformat;
			}
	  }	  
	  if(!this.dFormat){
		  this.dFormat = this.PARAMS_DATE_FORMAT;
	  }	  
	  return this.dFormat;
   },
  
   formatDate: function(date){
	   return $.datepicker.formatDate(this.getDateFormat(), ($.datepicker.parseDate(this.PARAMS_DATE_FORMAT,date)));
   }, 
   setDefaultDates: function(blob){
	 var self = this;
  	 if(self.caller === "DASHBOARD"){
  		 return DateUtils.extractDates(self.settings.models, blob, 'dashboard-default-min-date', 'dashboard-default-max-date'); 	 
  	 }else if(self.caller === "GIS"){
  		return DateUtils.extractDates(self.settings.models, blob, 'gis-default-min-date', 'gis-default-max-date');
  	 }
  	 return blob
   },
  cancel: function() {
    if(this.filterStash){
      this.deserialize(this.filterStash, {silent: true});
    }
    this.trigger('cancel', this.filterStash);
  }
});


},{"../../../../../reamp/tools/log":"C:\\Git\\amp\\TEMPLATE\\reamp\\tools\\log\\index.js","../collections/all-filters-collection":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\collections\\all-filters-collection.js","../collections/settings-collection":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\collections\\settings-collection.js","../utils/date-utils":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\utils\\date-utils.js","../views/top-level-filter-view":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\top-level-filter-view.js","amp-translate":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-translate\\index.js","backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\generic-filter-view.js":[function(require,module,exports){

var _ = require('underscore');

// var GenericFilterModel = require('../models/generic-filter-model');
var TreeNodeView = require('../tree/tree-node-view');
var BaseFilterView = require('../views/base-filter-view');
var Template = "<% if (!empty) { %>\n\t<div class=\"search-form\">\n\t  <div class=\"input-group form-group\">\n\t    <input type=\"text\" data-i18n=\"[placeholder]amp.gis:pane-filters-search-placeholder\" class=\"form-control search-text\" placeholder=\"Search...\">\n\t    <span class=\"input-group-btn\">\n\t      <button data-i18n=\"amp.gis:pane-filters-search\" class=\"btn btn-success\">Go</button>\n\t    </span>\n\t  </div><!-- /input-group -->\n\t</div>\n\t<div class=\"toggle-all\">\n\t  <em>\n\t    <a href=\"#\" data-i18n=\"amp.gis:pane-filters-select\" class=\"select-all\" >select all</a> /\n\t    <a href=\"#\"  data-i18n=\"amp.gis:pane-filters-deselect\" class=\"select-none\" >deselect all</a>\n\t  </em>\n\t</div>\n\t\n\t<div class=\"tree tree-container\" style=\"\"></div><!--display:none;-->\n<% } else { %>\n\t<span data-i18n='amp.gis:pane-subfilters-empty'></span>\n<% } %>\n";


// This is a generic model for filters. It assumes a tree structure.
// If you don't want a tree structure just extend base-filter
module.exports = BaseFilterView.extend({

  className: BaseFilterView.prototype.className + ' filter-generic',
  template: _.template(Template),
  _loaded: null,

  events:{
    // attach in filter render instead since these events are attached to the el object
    // and then namespaced. this means that the way we re-use
    // DOM elements will accidentally trigger multiple events.
    // 'click  .select-all': '_selectAll',
    // 'click  .select-none': '_selectNone',
    //'keyup input.search-text': 'searchKeyUp'
  },

  initialize:function(options) {
    var self = this;
    BaseFilterView.prototype.initialize.apply(this, [options]);

    this.model = options.model;
    this.translator = options.translator;
    this.translate = options.translate;
    this.treeView = new TreeNodeView({isRoot:true});

    // Create tree view
    // TODO: make tree loading content responsibility of model, not view...
    this.model.getTree().then(function(treeModel) {
      if (treeModel) {
        self._updateCountInMenu();
        treeModel.on('change:numSelected', function() {
          self._updateCountInMenu();
        });
      } else {
        console.warn('no tree for: ', self.model);
      }
    });
  },

  searchKeyUp: function(event) {
    if (event.keyCode === 13 || // Pressed 'enter'
      this.$('.search-text').val() === '' ||
      this.$('.search-text').val().length > 1
      ) {
      this.model.get('tree').filterText(this.$('.search-text').val().toLowerCase());
    }
  },


  _updateCountInMenu:function() {	
    if (this.$titleEl && this.model.get('tree')) {
      if (this.model.get('tree').get('numSelected') === this.model.get('tree').get('numPossible') ||
          this.model.get('tree').get('numSelected') === 0) {    	  
    	  this.$titleEl.find('.filter-count').attr('data-i18n','amp.gis:pane-filters-all');
    	  this.$el.removeClass('active');     	  
    	  this.translate(this.$titleEl.find('.filter-count').parent());
      } else {    	
        this.$titleEl.find('.filter-count').text(this.model.get('tree').get('numSelected') +
          '/' +
          this.model.get('tree').get('numPossible'));
        this.$el.addClass('active');
        this.$titleEl.find('.filter-count').attr('data-i18n','');
      }
    }
  },	
  renderTitle : function() {	  
	  BaseFilterView.prototype.renderTitle.apply(this);
	  this._updateCountInMenu();
	  return this;
  },

  renderFilters:function() {
    var self = this;
    BaseFilterView.prototype.renderFilters.apply(this);

    this.model.getTree().then(function(treeModel) {
      self.$el.html(self.template(self.model.toJSON()));

      // add event listeners
      self.$('.select-none').on('click', function() {self._selectNone(); return false;}); //return false to stop page refresh.
      self.$('.select-all').on('click', function() {self._selectAll(); return false;}); //return false to stop page refresh.
      self.$('input.search-text').on('keyup', function(event) {self.searchKeyUp(event);});

      if (treeModel) {
        self.$('.tree-container').append(self.treeView.render(self.model.get('tree')).$el);
        treeModel.set('expanded', true);
        treeModel.filterText('');//default no filter.
      } else{
        self.$('.tree-container').append("");
      }
    })
    .done(function() {
    	self.translate(self);
    })
    .fail(function(){
      console.error('renderFilters failed :(');
    });

    return this;
  },

  _selectAll: function() {
    // force trigger even if already this state (important for half-fill ui
    this.model.get('tree').set('selected', false);
    this.model.get('tree').set('selected', true);
    //this.model.get('tree').set('selected', true, {silent: true });
    //.model.get('tree').trigger('change:selected', this.model.get('tree'), null, {propogation:false});
  },

  _selectNone: function() {
    // force trigger even if already this state (important for half-fill ui)
    this.model.get('tree').set('selected', true);
    this.model.get('tree').set('selected', false);
    // this.model.get('tree').set('selected', false, {silent: true });
    // this.model.get('tree').trigger('change:selected', this.model.get('tree'), null, {propogation:false});
  }

});


},{"../tree/tree-node-view":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\tree\\tree-node-view.js","../views/base-filter-view":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\base-filter-view.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\top-level-filter-view.js":[function(require,module,exports){

var _ = require('underscore');
var $ = require('jquery');

var Backbone = require('backbone');
var TitleTemplate = "<%\n// renders the title of a tab \n%>\n<li class=\"\"><a data-i18n=\"amp.gis:pane-filters-<%= name.replace(/ /g,'') %>\" href=\"#filter-pane-<%= name.replace(/ /g,'') %>\" role=\"tab\" data-toggle=\"tab\"><%= name %></a></li>\n";
var ContentTemplate = "<%\n // renders the contents of a filter's tab (e.g. for example the \"Contracting / Implementing / Executing / Primary Beneficiary / Secondary Beneficiary Agency\" list of the \"All Agencies\" tab)\n // <h6>mde  %- Math.random() </h6>\n%>\n<ul class=\"sub-filters-titles nav nav-pills nav-stacked\">\n</ul>\n<div class=\"sub-filters-content\">\n  <img src=\"img_2/loading-icon.gif\" />\n</div>\n";

var GenericFilterView = require('../views/generic-filter-view');
var YearsFilterView = require('../views/years-filter-view');
var YearsOnlyFilterView = require('../views/years-only-filter-view');

var YearsFilterModel = require('../models/years-filter-model');
var YearsOnlyFilterModel = require('../models/years-only-filter-model');

var filtersViewLog = require("../../../../../reamp/tools/log")('amp:filters:top-level:view');
var SettingsCollection = require('../collections/settings-collection');

//TODO: rename to 'group' to be consistent
// Parent base view for filters.
module.exports = Backbone.View.extend({
  className:  'tab-pane',
  titleTemplate: _.template(TitleTemplate),
  contentTemplate: _.template(ContentTemplate),
  filterCollection: null,
  viewList:[],
  name: 'tbd',

  initialize:function(options) {
    var self = this;
    this.name = options.name;
    this.translator = options.translator;
    this.translate = options.translate;
    this.filterView = options.filterView; 
    this.filterCollection = new Backbone.Collection();    
    this.filterCollection.on('change:numSelected', function(){
      self._refreshTitle();
    });
  },

  cleanupUnusedTabs: function() {
	  console.log(this);
//	debugger(self);
  },
  
  
  /**
   * renders the items in a tab
   * the first element of the tab's contents will be rendered IFF options.renderFirstElement has been specified
   */
  renderFilters: function(renderFirstElement) {
    var self = this;
    var view = null;
    var first = true;
    this.$el.attr('id', 'filter-pane-' + this.name.replace(/ /g,''));
    this.$el.html(this.contentTemplate());
    // renders the tabs of the filter (one tab for each filterCollection element)
    this.filterCollection.each(function(filter) {
      filtersViewLog.onDebug(function(){
        // Constantin: harmless debug message to be removed once the filters sanitisation is done
        // @Constantin, we can do bettr than this, senpai!
        //filtersViewLog.log('rendering filter', filter.get('name'));
      });
    	if (filter instanceof YearsFilterModel) {    		
    		view = new YearsFilterView({
    			model:filter,
    			el: self.$('.sub-filters-content'),
    			translator: self.translator,
    			translate: self.translate,
    			filterView: self.filterView    			
    		});
    		self.viewList.push(view);
    	} else if (filter instanceof YearsOnlyFilterModel) {
    		view = new YearsOnlyFilterView({
    			model:filter,
    			el: self.$('.sub-filters-content'),
    			translator: self.translator,
    			translate: self.translate,
    			filterView: self.filterView    			
    		});
    		self.viewList.push(view);
    	} else {
    		view = new GenericFilterView({
    			model:filter,
    			el: self.$('.sub-filters-content'),
    			translator: self.translator,
    			translate: self.translate
    		});
    		self.viewList.push(view);
    	}

    	var titleElem = view.renderTitle().$titleEl;
    	self.$('.sub-filters-titles').append(titleElem);

    	// hacky way to open first one for now.
    	if (first && renderFirstElement) {
    		first = false;
    		view.renderFilters();
    		self.$('.sub-filters-titles li:first').addClass('active');
    	}
    });
    
    // We need to re-translate some strings from the right panel.
	self.translate(this);

   	return this;
  },

  _refreshTitle: function(){
    var totalSelected = 0;
    var countStr ='';

    this.filterCollection.each(function(filter) {
      if(filter.getNumSelected){
        totalSelected += filter.getNumSelected();
      }
    });

    if( totalSelected !== 0) {
      countStr = totalSelected;
    }

    // TODO: should be locally scoped, not global jquery.
    $('#'+this.name.replace(/ /g,'') + ' .title-count').text(countStr);
  },

  /**
   * renders the title of a tab
   */
  renderTitle: function() {
    this.titleEl = this.titleTemplate({name: this.name});
    return this;
  }
});

},{"../../../../../reamp/tools/log":"C:\\Git\\amp\\TEMPLATE\\reamp\\tools\\log\\index.js","../collections/settings-collection":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\collections\\settings-collection.js","../models/years-filter-model":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\years-filter-model.js","../models/years-only-filter-model":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\models\\years-only-filter-model.js","../views/generic-filter-view":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\generic-filter-view.js","../views/years-filter-view":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\years-filter-view.js","../views/years-only-filter-view":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\years-only-filter-view.js","backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\years-filter-view.js":[function(require,module,exports){

var _ = require('underscore');
var BaseFilterView = require('../views/base-filter-view');

require('../lib/jquery.nouislider.min.js');
require('jquery-ui/datepicker');

var Template = "\n  <h3 class=\"title text-center\"><span class=\"dates\"></span></h3>\n   <div class=\"year-slider\"></div>\n\n   <span data-i18n=\"amp.gis:pane-subfilters-startdate\">Start Date:</span>&nbsp<p><input type=\"text\" id=\"start-date\" class=\"date-picker\"></p>\n   <span data-i18n=\"amp.gis:pane-subfilters-enddate\">End Date:</span>&nbsp<p><input type=\"text\" id=\"end-date\" class=\"date-picker\"></p>\n";

module.exports = BaseFilterView.extend({

  className: BaseFilterView.prototype.className + ' filter-years',
  template: _.template(Template),
  _loaded: null, 
  initialize:function(options) {
    var self = this;
    
    this.filterView = options.filterView;    
    BaseFilterView.prototype.initialize.apply(this, [options]);
    this.model = options.model;
    this.translator = options.translator;
    this.translate = options.translate;    
//    console.log("just built a years-filter-view for " + self.model.get('name'));
    this._loaded = this.model.fetch().then(function() {
    	//console.log("just loaded a years-filter-view for: " + JSON.stringify({name: self.model.get('name'), start: self.model.get('selectedStart'), end: self.model.get('selectedEnd')}));
    });

    this.listenTo(this.model, 'change', this._updateTitle);
  },


  renderFilters:function() {
    var self = this;
    BaseFilterView.prototype.renderFilters.apply(this);

    this.$el.html(this.template(this.model.toJSON()));

    this._loaded.then(function() {
      //self._renderSlider();
      self._renderDatePickers();
      self._updateTitle();
      
      // We need to re-translate some strings from the right panel.
      self.translate(self);
    });

    return this;
  },

  _renderDatePickers: function() {		
	
	

    var self = this;

    // TODO: format based on admin setting....maybe get from year api..
    // TODO: abstract common properties from object inits below...
    // var commonObj = {};

    this.$('#start-date').datepicker({
      defaultDate: this.model.get('selectedStart'),
      //minDate: this.model.get('startYear'),
      //maxDate: this.model.get('endYear'),
      dateFormat: this.filterView.getDateFormat(),
      changeMonth: true,
      changeYear: true,
      numberOfMonths: 1,
      yearRange: 'c-60:c+60',
      onClose: function(selectedDate) {
        self.$('#end-date').datepicker('option', 'minDate', selectedDate);        
        self.model.set('selectedStart', $.datepicker.formatDate(self.filterView.PARAMS_DATE_FORMAT, $.datepicker.parseDate(self.filterView.getDateFormat(), selectedDate)));
        // self._updateTitle();
      }
    });    

    this.$('#end-date').datepicker({
      defaultDate: this.model.get('selectedEnd'),
      //minDate: this.model.get('startYear'),
      //maxDate: this.model.get('endYear'),
      dateFormat: this.filterView.getDateFormat(),
      changeMonth: true,
      changeYear: true,
      numberOfMonths: 1,
      yearRange: 'c-60:c+60',
      onClose: function(selectedDate) {
        self.$('#start-date').datepicker('option', 'maxDate', selectedDate);        
        self.model.set('selectedEnd', $.datepicker.formatDate(self.filterView.PARAMS_DATE_FORMAT, $.datepicker.parseDate(self.filterView.getDateFormat(), selectedDate)));
        // self._updateTitle();
      }
    });

    //this.$('#start-date').val(this.model.get('selectedStart'));
    //this.$('#end-date').val(this.model.get('selectedEnd'));
    
    // Set the language for datepickers here (instead of doing it in filters-view.js) to prevent race conditions that would set the wrong language.
    var languageSetting = this.filterView.settings.findWhere({id:'language'});
	if (languageSetting) {
		var lang = languageSetting.get('defaultId') 
		//English is default so we dont set it.
        lang = (lang === 'en') ?  '' : lang; 
		//console.log('setting date picker lang: ' + lang);
		$.datepicker.setDefaults($.datepicker.regional[lang]);
	}
  },

  renderTitle:function() {
	BaseFilterView.prototype.renderTitle.apply(this);
    this._updateTitle();

    return this;
  },

  //TODO: do more in template.
  _updateTitle:function() {	  
	var selectedStart = this.model.get('selectedStart') ? $.datepicker.formatDate(this.filterView.getDateFormat(), ($.datepicker.parseDate(this.filterView.PARAMS_DATE_FORMAT, this.model.get('selectedStart')))) : "";
	var selectedEnd = this.model.get('selectedEnd') ? $.datepicker.formatDate(this.filterView.getDateFormat(), ($.datepicker.parseDate(this.filterView.PARAMS_DATE_FORMAT, this.model.get('selectedEnd'))))	: "";
	$('#datePicker').datepicker({ dateFormat: this.filterView.getDateFormat() });
	this.$('#start-date').datepicker("setDate", selectedStart);
	this.$('#end-date').datepicker("setDate", selectedEnd);	
	var dates = "";
	if(selectedStart.length > 0 && selectedEnd.length > 0){
		dates = selectedStart + ' - ' +  selectedEnd;		
	}else if(selectedStart.length > 0 && selectedEnd.length == 0){
		dates = 'from ' + selectedStart;				
	}else if(selectedStart.length == 0 && selectedEnd.length > 0){
		dates = 'until ' + selectedEnd;			
	}
	this.$titleEl.find('.filter-count').text(dates);
	this.$('.dates').text(dates);	
  },

  _renderSlider: function() {
    var self = this;

    // uses window.jQuery because that was the only way I had luck with browserify shim...
    // uses https://github.com/leongersen/noUiSlider
    this.slider = window.jQuery(this.$('.year-slider')).noUiSlider({
      start: [self.model.get('selectedStart'), self.model.get('selectedEnd')],
      step: 1,
      connect: true,
      range: {min: self.model.get('startYear'), max:self.model.get('endYear')},
      serialization: {
        lower: [
          window.jQuery.Link({
            target: window.jQuery('.start-year')
          })
        ],
        upper: [
          window.jQuery.Link({
            target: window.jQuery('.end-year')
          })
        ],
        format: {
          decimals: 0
        }
      }
    });

    //ugly, too much data in the dom...but it's how the example goes.
    this.slider.on('change', function() {
      self.model.set('selectedStart', parseInt(self.$('.start-year').text(), 10));
    });

    //ugly, too much data in the dom...but it's how the example goes.
    this.slider.on('change', function() {
      self.model.set('selectedEnd',  parseInt(self.$('.end-year').text(), 10));
    });
  }

});

},{"../lib/jquery.nouislider.min.js":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\lib\\jquery.nouislider.min.js","../views/base-filter-view":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\base-filter-view.js","jquery-ui/datepicker":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\node_modules\\jquery-ui\\datepicker.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\years-only-filter-view.js":[function(require,module,exports){

var _ = require('underscore');
var BaseFilterView = require('../views/base-filter-view');

var Template = "<span data-i18n=\"amp.gis:pane-subfilters-year\">Year:</span>\r\n&nbsp\r\n<p>\r\n\t<select id=\"year-select\" class=\"\"></select>\r\n</p>";

module.exports = BaseFilterView.extend({
	className : BaseFilterView.prototype.className + ' filter-years',
	template : _.template(Template),
	_loaded : null,
	initialize : function(options) {
		var self = this;

		this.filterView = options.filterView;
		BaseFilterView.prototype.initialize.apply(this, [ options ]);
		this.model = options.model;
		this.translator = options.translator;
		this.translate = options.translate;
		this._loaded = this.model.fetch().then(function() {
			/*console.log("just loaded a years-only-filter-view for: " + JSON.stringify({
				name : self.model.get('name')
			}));*/
		});

		this.listenTo(this.model, 'change', this._updateTitle);
	},

	renderFilters : function() {
		var self = this;
		BaseFilterView.prototype.renderFilters.apply(this);

		this.$el.html(this.template(this.model.toJSON()));

		this._loaded.then(function() {
			self._renderSelector();

			// We need to re-translate some strings from the right panel.
			self.translate(self);
		});

		return this;
	},

	_renderSelector : function() {
		var self = this;
		var selector = this.$('#year-select');
		selector.append($("<option>").attr('value', '').text(''));
		_.each(this.model.get('value').options, function(item, i) {
			var option = $("<option>").attr('value', item.value).text(item.value);
			if (item.value === self.model.get('selectedYear').toString()) {
				$(option).attr('selected', 'selected');
			}
			selector.append(option);
		});

		$(selector).on('change', function() {
			self.model.set('selectedYear', this.value);
		});
	},

	_updateTitle : function() {
		var selectedYear = this.model.get('selectedYear');
		this.$("#year-select").val(selectedYear);
	},

});

},{"../views/base-filter-view":"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-filter\\src\\views\\base-filter-view.js","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-state\\index.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


function StateLoadError(message, original) {
  if (!(this instanceof StateLoadError)) { return new SateLoadError(message, original); }
  this.message = message;
  this.original = original;

  this.toString = function() {
    return this.message;
  };

  return this;
}


function State() {
  'use strict';

  if (!(this instanceof State)) {
    throw new Error('State needs to be created with the `new` keyword.');
  }

  this.initialize.apply(this, arguments);
}


_.extend(State.prototype, Backbone.Events, {

  initialize: function(options) {
    this.saved = options.saved;
    // Anything that state must register itself. See `State.register`.
    this._stateRegistry = {};
    // When loading state, some things might not have registered yet.
    // It gets marked as unclaimed, and stored here.
    this._unclaimed = {};
    // use the url, if we have it
    if (options.url) {
      this.listenToURL(_(options).pick('url', 'prefix', 'autoinit'));
    }
  },

  listenToURL: function(options) {
    this._url = options.url;
    this._urlPrefixes = options.prefix || ['saved/'];

    // wrap prefixes in array to make backward compat:
    if (this._urlPrefixes.constructor !== Array){
      this._urlPrefixes = [this._urlPrefixes];
    }

    this.listenTo(this._url, 'change', this.urlMaybeLoad);
    if (options.autoinit && this._url.hash()) {
      this.urlMaybeLoad(this._url.hash());
    }  // initial state
  },

  urlMaybeLoad: function(hash) {
    var self = this;
    var matchFound = false;
    hash = hash || this._url.hash();

    // see if any prefixes match the hash.
    _.each(this._urlPrefixes, function(prefix){
      // load a state if we get the URL hash for one
      if (hash.indexOf(prefix) === 0) {
        var state_or_id = hash.split(prefix)[1];
        if (state_or_id) {
          matchFound = true;
          self[self.saved ? 'loadById' : 'load'](state_or_id, prefix);
        }
      }
    });
    if (!matchFound && hash === '') {
      self.reset();
    }
  },

  toHash: function(state_or_id) {
    if (!_(this).has('_url')) {
      console.error('Cannot generate URL hash without being initialized with URL instance');
    } else {
      return this._urlPrefixes[0] + state_or_id;
    }
  },

  loadById: function(id, matchedPrefix) {
    this.loadPromise = this.saved.load(id, matchedPrefix  );// TODO: drs: and pass matching prefix..
    this.loadPromise
      .done(_(function(stateModel) {
        this.load(stateModel.get('stateBlob'));
      }).bind(this))
      .fail(function() {
        throw new StateLoadError('Could not load state by id: ' + id);
      });
  },

  load: function(statesBlob) {
    var parsed = this.parse(statesBlob);

    var changed = false;
    _.each(parsed, function(stateToSet, id) {
      var current = this._stateRegistry[id];
      if (_.isUndefined(current)) {
        this._unclaimed[id] = stateToSet;
      } else if (!_.isEqual(current.get(), stateToSet)) {
        current.set(stateToSet);
        changed = true;
      }
    }, this);

    this.trigger('load');
    if (changed) {
      this.trigger('change');
    }
  },

  parse: function(statesBlob) {
    // break out the call to JSON.parse so that load can still be optimized
    var parsed;
    try {
      parsed = JSON.parse(statesBlob);
    } catch (e) {
      if (e instanceof SyntaxError) {
        throw new StateLoadError('Could not parse state', e);
      } else {
        throw e;
      }
    }
    return parsed;
  },

  reset: function() {
    // Restore all states to their defaults (specified at registration)
    var changed = false;
    _.each(this._stateRegistry, function(state) {
      var currentState = state.get();
      if (!_.isEqual(currentState, state.empty)) {
        // only call .set if resetting will actually change the state.
        state.set(state.empty);
        changed = true;
      }
    }, this);

    this.trigger('reset');
    if (changed) {
      this.trigger('change');
    }
  },

  
  filtersLoaded: function() {
	  var dfd = jQuery.Deferred();
	  var self = this;
	  var timer = setInterval(function() {
		  if (self._stateRegistry.filters !== undefined) {
			  clearInterval(timer);
			  dfd.resolve();
		  }
	  }, 1000);
	  return dfd.promise(); 
  },
  
  
  freeze: function(options) {
    options = options || {};
    var stateSnapshot = {};
    _.each(this._stateRegistry, function(state, id) {
      var currentState = state.get();
      stateSnapshot[id] = _.clone(currentState);  // TODO: deep clone(!!)
    });
    var statesBlob = JSON.stringify(stateSnapshot);
    if (options.toURL) {
      if (!this._url) { console.error('State cannot change URL if it does have a ref to it'); }
      this._url.hash(this._urlPrefixes[0] + encodeURIComponent(statesBlob));
    }
    this.trigger('freeze', statesBlob);
    return statesBlob;
  },

  register: function(registrable, id, options) {
    if (id in this._stateRegistry) {
      throw new Error('Attempted registration of duplicate state id ' + id);
    }

    // register the state
    this._stateRegistry[id] = {
      get: _.bind(options.get, registrable),
      set: _.bind(options.set, registrable),
      empty: options.empty
    };

    // set to the currently loaded state, or its default empty state
    if (id in this._unclaimed) {
      this._stateRegistry[id].set(this._unclaimed[id]);
      delete this._unclaimed[id];
    } else {
      this._stateRegistry[id].set(options.empty);
    }

    this.trigger('register');
  }
});


State.StateLoadError = StateLoadError;
module.exports = State;

},{"backbone":"backbone","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-translate\\index.js":[function(require,module,exports){
// TODO: move this up a dir, and instantiate and attach to the app


var _ = require('underscore');
var $ = require('jquery');
var Backbone = require('backbone');

function Translator(options) {
  'use strict';

  if (!(this instanceof Translator)) {
    throw new Error('Translator needs to be created with the `new` keyword.');
  }

  // this is the object that has all  the key value pairs for the widget.
  var translatorDefaults = {
    defaultKeys: {},
    availableLanguages: null,// backbone collection
    translations: {
      locales: {
        en:null
      }
    },
    ajax: $.ajax
  };

  /* Gather options */
  if (options) {
    /* Especially useful for overwriting defaultKeys, availableLanguages and translations */
    _.defaults(this, options, translatorDefaults);
  }

  this._promise = null;
  this._currentLng = 'tmp';
  this._firstGet = null;

  // TODO: add support for local storage with timestamp
  this.initTranslations = function get() {
    var self = this;


    // try web
    this._promise = this.getTranslations(self.defaultKeys)
      .fail(function(jqXHR, textStatus, errorThrown) {
        console.error('failed ', jqXHR, textStatus, errorThrown);
      });
    this.promise = this._promise.promise();
  };

  /* Use this for adding more defaultKeys or translations by module
   * if translator has already been instantiated
   */
  this.addTranslatorOptions = function(options) {
    /* force a request from API next time */
    _.defaults(this.defaultKeys, options.defaultKeys);
    this._firstGet = null;
  };


  this.getAvailableLanguages = function() {
    var deferred = $.Deferred();

    if (this.availableLanguages) {
      deferred.resolve(this.availableLanguages);
    } else {
      this._initAvailableLanguages().then(function() {
        deferred.resolve(this.availableLanguages);
      });
    }

    return deferred;
  };

  this._initAvailableLanguages = function() {
    this.availableLanguages = new Backbone.Collection([]);
    this.availableLanguages.url = '/rest/translations/languages';
    return this.availableLanguages.fetch();
  };


  // important to let the api know, so all responses are translated.
  this.setLanguage = function(lng) {
    this._currentLng = lng;
    return this._apiCall('/rest/translations/languages/' + lng, null, 'GET');
  };


  this.translateDOM = function(el) {
    var $newEl = $(el);
    /* TODO(tdk): We identified a major bug here where root immediate child
     *  template elements with translations are not being caught by this
     *  selector.
     *
     *  To workaround, we should clone, wrap, run the selector and unwrap the DOM.
     *
     *  Remember this has to work for el's around the app that are bound
     *  and not bound.
     */

    return this.getTranslations().then(function(data) {
      $.each(data, function(key, value) {
        /*if ($('[data-i18n="' + key + '"]', $newEl).length > 0) {
         console.log(key, '->', value,' $ found->', $newEl.find('[data-i18n="' + key + '"]').text());
         }*/

        // We need a way to identify controls where the placeholder needs to be translated instead of the text.
        if (key.indexOf('[placeholder]') > -1) {
          $('[data-i18n="' + key + '"]', $newEl).attr('placeholder', value);
        } else if (key.indexOf('[title]') > -1) {
          $('[data-i18n="' + key + '"]', $newEl).attr('title', value);
        } else {
          $('[data-i18n="' + key + '"]', $newEl).text(value);
        }
      });
      return $newEl;
    });
  };


  /*
   * Pass in a {"amp.gis:data-i18n-code": "base lang words", ...} object for
   * translation e.g. page title
   * */
  // TODO: don't call it a list if it's an object ?!
  this.translateList = function(list) {

    // update translateable elements in this key-value set
    var _updateList = function(list, i18nData) {
      _.each(list, function(value, key, list) {
        if (i18nData[key]) {
          list[key] = i18nData[key];
        } else {
          list[key] = key[value];
        }
      });
      return list;
    };

    return this.getTranslations().then(function(i18nData) {
      var outList = _updateList(list, i18nData);
      return outList;
    });
  };


  /*
   * Synchronously get a (already-loaded) translation
   */
  this.translateSync = function(key, alt) {
    if (this.getTranslations().state() !== 'resolved') {
      console.error('translateSync was called when getTranslations is not successfully resolved');
    }
    var translated = this.translations.locales[this._currentLng][key];
    if (translated === undefined) {
      console.warn('No translation has been loaded for', key);
      translated = alt || key;
    }
    return translated;
  };


  // Only do single request on launch.
  this.getTranslations = function() {
    // this way won't work with change languages mid way though.
    if (!this._firstGet) {
      this._firstGet = this._getTranslationsFromAPI(this.defaultKeys, this._currentLng);
    }
    return this._firstGet;
  };


  this._getTranslationsFromAPI = function(translateables, lng) {
    var self = this;
    var url = '/rest/translations/label-translations';

    return this._apiCall(url, translateables, 'POST').then(function(data) {
      //cache if we know the lng. TODO: get api to always return the lng.
      if (lng) {
        self.translations.locales[lng] = data;
      } else {
        // temp hack to do caching if API doesn't return current lng
        lng = this._currentLng;
        self.translations.locales[lng] = data;
      }

      return data;
    });
  };


  // helper to wrap api call
  this._apiCall = function(url, data, type) {
    var ajaxOptions = {
      headers: {
        // jscs:disable disallowQuotedKeysInObjects
        'Accept': 'application/json',
        'Content-Type': 'application/json'
        // jscs:enable disallowQuotedKeysInObjects
      },
      type: type,
      url: url,
      dataType: 'json'
    };
    if (data) {
      ajaxOptions.data = JSON.stringify(data);
    }

    return this.ajax(ajaxOptions);
  };

  this.initTranslations();
}

module.exports = Translator;

},{"backbone":"backbone","jquery":"jquery","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\ampTemplate\\node_modules\\amp-url\\index.js":[function(require,module,exports){
var _ = require('underscore');
var Backbone = require('backbone');


function URL() {
  'use strict';
  if (!(this instanceof URL)) {
    throw new Error('URL needs to be created with the `new` keyword.');
  }
  if (window._ampUrler) {
    throw new Error('Another instance of URL is already managing window.location');
  } else {
    window._ampUrler = true;
  }
  this.initialize.apply(this, arguments);
}


_.extend(URL.prototype, Backbone.Events, {

  initialize: function(options) {
    options = options || {};
    this.root = options.root || window.location.host + window.location.pathname;
    _.bindAll(this, 'change');
    window.addEventListener('hashchange', this.change);  // IE 8+
  },

  hash: function(newHash, options) {
    if (!arguments.length) {
      return window.location.hash.slice(1);  // remove '#'
    } else {
      if (options.silent) { window.removeEventListener('hashchange', this.change); }  // IE 9+
      window.location.hash = newHash;
      if (options.silent) { window.addEventListener('hashchange', this.change); }
    }
  },

  full: function() {
    return '' + window.location;
  },

  change: function() {
    this.trigger('change', this.hash());
  }

});


module.exports = URL;

},{"backbone":"backbone","underscore":"underscore"}],"C:\\Git\\amp\\TEMPLATE\\reamp\\tools\\log\\index.js":[function(require,module,exports){
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var _debug = __webpack_require__(1);

	var _debug2 = _interopRequireDefault(_debug);

	exports["default"] = function (slug) {
	  var res = {
	    log: (0, _debug2["default"])(slug),
	    err: (0, _debug2["default"])(slug),
	    warn: (0, _debug2["default"])(slug),
	    onDebug: (0, _debug2["default"])(slug)
	  };
	  res.err.log = Function.prototype.bind.call(console.error, console);
	  res.warn.log = Function.prototype.bind.call(console.warn, console);
	  res.onDebug.log = function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    for (var index in args) {
	      if ("function" == typeof args[index]) {
	        args[index]();
	        break;
	      }
	    }
	  };
	  return res;
	};

	module.exports = exports["default"];

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(2);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return args;

	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	  return args;
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(3);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 3 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ }
/******/ ]);
},{}]},{},["./app/js/app.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwiLi9hcHAvanMvYXBwLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvYXBwLWNsYXNzLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvYmFja2JvbmUtZGFzaC5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2NoYXJ0cy9fYmFyLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvY2hhcnRzL19oZWF0bWFwLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvY2hhcnRzL19tdWx0aWJhci5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2NoYXJ0cy9fcGllLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvY2hhcnRzL190YWJsZS5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2NoYXJ0cy9jaGFydC5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL2NoYXJ0cy9jb21tb24uanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9jaGFydHMvY3VzdG9taXplZC9oZWF0TWFwQ2hhcnQuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9jaGFydHMvY3VzdG9taXplZC9tdWx0aUJhckNoYXJ0LmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvY2hhcnRzL2N1c3RvbWl6ZWQvcGllQ2hhcnQuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9jaGVjay1zdXBwb3J0LmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvbW9kZWxzL2FtcC11c2VyLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvbW9kZWxzL2NoYXJ0LWFpZC1wcmVkaWN0YWJpbGl0eS5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL21vZGVscy9jaGFydC1mdW5kaW5nLXR5cGUuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9tb2RlbHMvY2hhcnQtaGVhdG1hcHMuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9tb2RlbHMvY2hhcnQtbW9kZWwtYmFzZS5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL21vZGVscy9jaGFydC10b3BzLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvbW9kZWxzL2NoYXJ0cy1jb2xsZWN0aW9uLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvbW9kZWxzL2VuYWJsZWQtY2hhcnRzLWNvbGxlY3Rpb24uanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9tb2RlbHMvaGVhdG1hcHMtY29uZmlnLWNvbGxlY3Rpb24uanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC9tb2RlbHMvc2F2ZWQtZGFzaC5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL21vZGVscy9zYXZlZC1kYXNoZXMtY29sbGVjdGlvbi5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL21vZGVscy9zZXR0aW5nLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvbW9kZWxzL3NldHRpbmdzLWNvbGxlY3Rpb24uanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9jaGFydC1haWQtcHJlZGljdGFiaWxpdHkuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9jaGFydC1mdW5kaW5nLXR5cGUuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9jaGFydC1oZWF0bWFwcy5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL2NoYXJ0LXRvcHMtaW5mby1tb2RhbC5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL2NoYXJ0LXRvcHMuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9jaGFydC12aWV3LWJhc2UuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9jaGFydHMuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9jb250cm9scy5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL2Rvd25sb2FkLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3MvZmFpbC5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL2ZpbHRlcnMuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9tYWluLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy9hcHAvdmlld3Mvc2V0dGluZ3MtbW9kYWwuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL2FwcC92aWV3cy9zZXR0aW5ncy5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvYXBwL3ZpZXdzL3NoYXJlLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy91Z2x5L2xpYi1sb2FkLWhhY2tzLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L2FwcC9qcy91Z2x5L2xpYi1zcmMvY2FudmcuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvYXBwL2pzL3VnbHkvbGliLXNyYy9yZ2Jjb2xvci5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvdWdseS91bmRlcnNjb3JlLXRyYW5zcG9zZS5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2Rldi9hcHAvanMvdWdseS91dGlsLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L25vZGVfbW9kdWxlcy9iYWJ5cGFyc2UvYmFieXBhcnNlLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvZGV2L25vZGVfbW9kdWxlcy9udW1lcmFsL251bWVyYWwuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2Rhc2hib2FyZC9kZXYvbm9kZV9tb2R1bGVzL252ZDMvYnVpbGQvbnYuZDMuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtYm9pbGVycGxhdGUvaW5kZXguanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtYm9pbGVycGxhdGUvbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1ib2lsZXJwbGF0ZS9zcmMvY29sbGVjdGlvbnMvYW1wLW1lbnVzLWNvbGxlY3Rpb24uanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtYm9pbGVycGxhdGUvc3JjL21vZGVscy9hbXAtbGF5b3V0LW1vZGVsLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWJvaWxlcnBsYXRlL3NyYy9tb2RlbHMvYW1wLW1lbnVzLW1vZGVsLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWJvaWxlcnBsYXRlL3NyYy92aWV3cy9hYm91dC12aWV3LmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWJvaWxlcnBsYXRlL3NyYy92aWV3cy9oZWFkZXItZm9vdGVyLXZpZXcuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtYm9pbGVycGxhdGUvc3JjL3ZpZXdzL21lbnUtdmlldy5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1ib2lsZXJwbGF0ZS9zcmMvdmlld3Mvc3VibWVudS1jb21wb3NpdGV2aWV3LmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9ub2RlX21vZHVsZXMvanF1ZXJ5LXVpL2NvcmUuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvZGF0ZXBpY2tlci5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvbm9kZV9tb2R1bGVzL2pxdWVyeS11aS9kcmFnZ2FibGUuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvbW91c2UuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvd2lkZ2V0LmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9zcmMvY29sbGVjdGlvbnMvYWxsLWZpbHRlcnMtY29sbGVjdGlvbi5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL2NvbGxlY3Rpb25zL3NldHRpbmdzLWNvbGxlY3Rpb24uanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy9saWIvanF1ZXJ5LXVpLWkxOG4uanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy9saWIvanF1ZXJ5Lm5vdWlzbGlkZXIubWluLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9zcmMvbWFpbi5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL21vZGVscy9iYXNlLWZpbHRlci1tb2RlbC5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL21vZGVscy9nZW5lcmljLWZpbHRlci1tb2RlbC5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL21vZGVscy9vcmctcm9sZS1maWx0ZXItbW9kZWwuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy9tb2RlbHMvc2V0dGluZy5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL21vZGVscy95ZWFycy1maWx0ZXItbW9kZWwuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy9tb2RlbHMveWVhcnMtb25seS1maWx0ZXItbW9kZWwuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy90cmVlL3RyZWUtbm9kZS1tb2RlbC5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL3RyZWUvdHJlZS1ub2RlLXZpZXcuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy91dGlscy9kYXRlLXV0aWxzLmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLWZpbHRlci9zcmMvdmlld3MvYmFzZS1maWx0ZXItdmlldy5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL3ZpZXdzL2ZpbHRlcnMtdmlldy5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL3ZpZXdzL2dlbmVyaWMtZmlsdGVyLXZpZXcuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy92aWV3cy90b3AtbGV2ZWwtZmlsdGVyLXZpZXcuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtZmlsdGVyL3NyYy92aWV3cy95ZWFycy1maWx0ZXItdmlldy5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvYW1wVGVtcGxhdGUvbm9kZV9tb2R1bGVzL2FtcC1maWx0ZXIvc3JjL3ZpZXdzL3llYXJzLW9ubHktZmlsdGVyLXZpZXcuanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtc3RhdGUvaW5kZXguanMiLCJDOi9HaXQvYW1wL1RFTVBMQVRFL2FtcFRlbXBsYXRlL25vZGVfbW9kdWxlcy9hbXAtdHJhbnNsYXRlL2luZGV4LmpzIiwiQzovR2l0L2FtcC9URU1QTEFURS9hbXBUZW1wbGF0ZS9ub2RlX21vZHVsZXMvYW1wLXVybC9pbmRleC5qcyIsIkM6L0dpdC9hbXAvVEVNUExBVEUvcmVhbXAvdG9vbHMvbG9nL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9oQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVsV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ovREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbjhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwicmVxdWlyZSgnLi91Z2x5L2xpYi1sb2FkLWhhY2tzJyk7XG52YXIganF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBVc2VyTW9kZWwgPSByZXF1aXJlKCcuL2FwcC9tb2RlbHMvYW1wLXVzZXIuanMnKTtcbnZhciBBcHAgPSByZXF1aXJlKCcuL2FwcC9hcHAtY2xhc3MnKTtcbnZhciBhcHAgPSBuZXcgQXBwKHsgZWw6ICcjYW1wLWRhc2hib2FyZCcgfSk7XG53aW5kb3cuYXBwID0gYXBwOyAgLy8gZm9yIGRlYnVnZ2luZyBjb252ZW5pZW5jZVxuXG4vL0ZvcmNlIGNhbGwgdG8gdGhlIEVQIHRoYXQgc2VuZHMgdGhlIHNhdmVkIGZpbHRlcnMgaWYgYW55LlxuYXBwLnN0YXRlLnNhdmVkLmxvYWQoKTtcbi8vYXBwLnJlbmRlcigpO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgRGVmZXJyZWQgPSByZXF1aXJlKCdqcXVlcnknKS5EZWZlcnJlZDtcbnZhciBCYWNrYm9uZURhc2ggPSByZXF1aXJlKCcuL2JhY2tib25lLWRhc2gnKTtcbnZhciBzdXBwb3J0Q2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrLXN1cHBvcnQnKTtcblxudmFyIFVSTFNlcnZpY2UgPSByZXF1aXJlKCdhbXAtdXJsL2luZGV4Jyk7XG52YXIgU3RhdGUgPSByZXF1aXJlKCdhbXAtc3RhdGUvaW5kZXgnKTtcbnZhciBTdGF0ZUxvYWRFcnJvciA9IHJlcXVpcmUoJ2FtcC1zdGF0ZS9pbmRleCcpLlN0YXRlTG9hZEVycm9yO1xuXG52YXIgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ2FtcC10cmFuc2xhdGUnKTtcbnZhciBGaWx0ZXIgPSByZXF1aXJlKCdhbXAtZmlsdGVyL3NyYy9tYWluJyk7XG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKCcuL21vZGVscy9zZXR0aW5ncy1jb2xsZWN0aW9uJyk7XG52YXIgVXNlck1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbHMvYW1wLXVzZXIuanMnKTtcbnZhciBTYXZlZERhc2hlcyA9IHJlcXVpcmUoJy4vbW9kZWxzL3NhdmVkLWRhc2hlcy1jb2xsZWN0aW9uLmpzJyk7XG5cbnZhciBNYWluVmlldyA9IHJlcXVpcmUoJy4vdmlld3MvbWFpbicpO1xudmFyIEZhaWxWaWV3ID0gcmVxdWlyZSgnLi92aWV3cy9mYWlsJyk7XG5cblxuZnVuY3Rpb24gQXBwKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQXBwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXBwIG5lZWRzIHRvIGJlIGluc3RhbnRpYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLicpO1xuICB9XG4gIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5cbl8uZXh0ZW5kKEFwcC5wcm90b3R5cGUsIEJhY2tib25lRGFzaC5FdmVudHMsIHtcblx0XG4gIHJlbmRlcmVkOiBmYWxzZSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIF9pbml0RGVmZXIgPSBuZXcgRGVmZXJyZWQoKSxcbiAgICAgICAgbWlzc2luZ0ZlYXR1cmVzO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBfaW5pdERlZmVyLnByb21pc2UoKTtcblxuICAgIHRyeSB7XG4gICAgXHR0aGlzLnNldHRpbmdzID0gbmV3IFNldHRpbmdzKFtdLCB7IGFwcDogdGhpcyB9KTtcbiAgICBcdHRoaXMudXNlciA9IG5ldyBVc2VyTW9kZWwoKVxuXG4gICAgICAvLyBjaGVjayBvdXIgc3VwcG9ydCBsZXZlbFxuICAgICAgdGhpcy5icm93c2VySXNzdWVzID0gc3VwcG9ydENoZWNrKCk7XG4gICAgICBfKHRoaXMuYnJvd3Nlcklzc3VlcykuY2hhaW4oKVxuICAgICAgICAuZ3JvdXBCeSgnc2V2ZXJpdHknKVxuICAgICAgICAuZWFjaChmdW5jdGlvbihzZXZlcml0eUdyb3VwLCBzZXZlcml0eSkge1xuICAgICAgICAgIG1pc3NpbmdGZWF0dXJlcyA9IF8oc2V2ZXJpdHlHcm91cCkucGx1Y2soJ2ZlYXR1cmUnKS5qb2luKCcsICcpO1xuICAgICAgICAgIGlmIChzZXZlcml0eSA9PT0gJ2NyaXRpY2FsJykge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICBuYW1lOiAnSW5jb21wYXRpYmxlIFdlYiBCcm93c2VyJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0Rhc2hib2FyZHMgY2Fubm90IHdvcmsgd2l0aG91dCB0aGVzZSBmZWF0dXJlcywgd2hpY2ggYXJlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAnbm90IHN1cHBvcnRlZCBieSB5b3VyIHdlYiBicm93c2VyOiAnICsgbWlzc2luZ0ZlYXR1cmVzICsgJy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdBbnkgPGEgaHJlZj1cImh0dHA6Ly9icm93c2VoYXBweS5jb20vXCI+bW9kZXJuIGJyb3dzZXI8L2E+IHdpbGwgd29yay4nLFxuICAgICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5hbWUgKyAnOiAnICsgdGhpcy5tZXNzYWdlOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2V2ZXJpdHkgPT09ICdtYWpvcicpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0KCdMaW1pdGVkIHN1cHBvcnQgZm9yIG9sZCB3ZWIgYnJvd3NlcnMnLCBbXG4gICAgICAgICAgICAgICdZb3VyIGJyb3dzZXIgZG9lcyBub3QgcHJvdmlkZSBzb21lIGZlYXR1cmVzIHVzZWQgYnkgRGFzaGJvYXJkczogJyArXG4gICAgICAgICAgICAgIG1pc3NpbmdGZWF0dXJlcyArICcuJyxcbiAgICAgICAgICAgICAgJ1NvbWUgZmVhdHVyZXMgbWF5IG5vdCB3b3JrIGNvcnJlY3RseSwgaG93ZXZlciBhbnkgJyArXG4gICAgICAgICAgICAgICc8YSBocmVmPVwiaHR0cDovL2Jyb3dzZWhhcHB5LmNvbS9cIj5tb2Rlcm4gYnJvd3NlcjwvYT4gd2lsbCBwcm92aWRlICcgK1xuICAgICAgICAgICAgICAnYSBiZXR0ZXIgZXhwZXJpZW5jZS4nXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZXZlcml0eSA9PT0gJ21pbm9yJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGlzIGJyb3dzZXIgaXMgbWlzc2luZyBzdXBwb3J0IGZvcicsIG1pc3NpbmdGZWF0dXJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgLy8gaW5qZWN0IGRvd25sb2FkaWZ5IGlmIHdlIGhhdmUgbm8gZG93bmxvYWQgYnV0IGhhdmUgZmxhc2ggKElFKVxuICAgICAgaWYgKHRoaXMuaGFzSXNzdWUoJ2Rvd25sb2FkJykgJiYgIXRoaXMuaGFzSXNzdWUoJ2ZsYXNoJykpIHtcbiAgICAgICAgdmFyIHN3Zk9iaiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuICAgICAgICAgICAgZG93bmxvYWRpZnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc3dmT2JqLnNyYyA9ICcvVEVNUExBVEUvYW1wVGVtcGxhdGUvY29tbW9uSnMvc3dmb2JqZWN0LTIuMi5qcyc7XG4gICAgICAgIGRvd25sb2FkaWZ5LnNyYyA9ICcvVEVNUExBVEUvYW1wVGVtcGxhdGUvY29tbW9uSnMvZG93bmxvYWRpZnktMC4yLmpzJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzd2ZPYmopO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvd25sb2FkaWZ5KTtcbiAgICAgIH1cblxuICAgICAgLy8gaW5pdGlhbGl6ZSBhcHAgc2VydmljZXNcbiAgICAgIHRoaXMudXJsID0gbmV3IFVSTFNlcnZpY2UoKTtcbiAgICAgIHRoaXMuc2F2ZWREYXNoZXMgPSBuZXcgU2F2ZWREYXNoZXMoW10sIHsgYXBwOiB0aGlzIH0pO1xuICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZSh7XG4gICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgIHNhdmVkOiB0aGlzLnNhdmVkRGFzaGVzXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gdHJ5IHRvIGxvYWQgYW4gaW5pdGlhbCBzdGF0ZSBmcm9tIHRoZSB1cmxcbiAgICAgIHRyeSB7XG4gICAgXHQgIHRoaXMuc3RhdGUudXJsTWF5YmVMb2FkKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTdGF0ZUxvYWRFcnJvcikge1xuICAgICAgICBcdCAgdGhpcy5yZXBvcnQoJ0NvdWxkIG5vdCBsb2FkIHNhdmVkIGRhc2hib2FyZCcsIFsnSWYgeW91IGFyZSB0cnlpbmcgdG8gbG9hZCBhIHNoYXJlZCBsaW5rLCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBlbnRpcmUgVVJMIHdhcyBjb3BpZWQnXSk7XG4gICAgICAgIFx0ICB0aGlzLnVybC5oYXNoKCcnKTsgIC8vIGNsZWFyIHRoZSBiYWQgc2F2ZWQtc3RhdGUgaGFzaFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgIFx0ICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRhc2hib2FyZFRyYW5zbGF0ZUtleXMgPSBKU09OLnBhcnNlKFwie1xcblxcXCJhbXAuY29tbW9uOmZvb3RlclxcXCI6IFxcXCJEZXZlbG9wZWQgaW4gcGFydG5lcnNoaXAgd2l0aCBPRUNELCBVTkRQLCBXQiwgR292ZXJubWVudCBvZiBFdGhpb3BpYSBhbmQgREdGXFxcIixcXG5cXG5cXFwiYW1wLmNvbW1vbjp0aXRsZVxcXCI6IFxcXCJBTVBcXFwiLFxcblxcXCJhbXAuY29tbW9uOnRpdGxlLWRlc2t0b3BcXFwiOiBcXFwiRGVza3RvcFxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtbXktZGVza3RvcFxcXCI6IFxcXCJNeSBEZXNrdG9wXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1hZGQtdGFiXFxcIjogXFxcIkFkZCBUYWJcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLXRhYi1tYW5hZ2VyXFxcIjogXFxcIlRhYiBNYW5hZ2VyXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZS1yZXBvcnRzXFxcIjogXFxcIlJlcG9ydHNcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWFsbC1yZXBvcnRzXFxcIjogXFxcIkFsbCBSZXBvcnRzXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1mYXYtcmVwb3J0c1xcXCI6IFxcXCJGYXZvdXJpdGUgUmVwb3J0c1xcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtcmVwb3J0LWdlbmVyYXRvclxcXCI6IFxcXCJSZXBvcnQgR2VuZXJhdG9yXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1zYWlrdVxcXCI6IFxcXCJTYWlrdVxcXCIsXFxuXFxcImFtcC5jb21tb246dGl0bGUtZG9jdW1lbnRzXFxcIjogXFxcIkRvY3VtZW50c1xcXCIsXFxuXFxcImFtcC5jb21tb246dGl0bGUtZGFzaGJvYXJkc1xcXCI6IFxcXCJEYXNoYm9hcmRzXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1naXNcXFwiOiBcXFwiTmV3IEdJUyAoQkVUQSlcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWRhc2hib2FyZHNcXFwiOiBcXFwiTmV3IERhc2hib2FyZCAoQkVUQSlcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWRhc2hib2FyZC1nZW5lcmF0b3JcXFwiOiBcXFwiRGFzaGJvYXJkIEdlbmVyYXRvclxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtZG9ub3ItcHJvZmlsZVxcXCI6IFxcXCJEb25vciBQcm9maWxlXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1yZWdpb24tcHJvZmlsZVxcXCI6IFxcXCJSZWdpb24gUHJvZmlsZVxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtc2VjdG9yLXByb2ZpbGVcXFwiOiBcXFwiU2VjdG9yIFByb2ZpbGVcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWV4ZWN1dGluZy1wcm9maWxlXFxcIjogXFxcIkV4ZWN1dGluZyBBZ2VuY3kgUHJvZmlsZVxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtYmVuZWZpY2lhcnktcHJvZmlsZVxcXCI6IFxcXCJCZW5lZmljaWFyeSBNaW5pc3RyeSBQcm9maWxlXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZS10b29sc1xcXCI6IFxcXCJUb29sc1xcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtd29ya3NwYWNlLXNldHVwXFxcIjogXFxcIldvcmtzcGFjZSBTZXR1cFxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtYWR2YW5jZWQtbW9kZVxcXCI6IFxcXCJBZHZhbmNlZCBNb2RlXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1zZWFyY2hcXFwiOiBcXFwiU2VhcmNoXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1hZGRyZXNzYm9va1xcXCI6IFxcXCJBZGRyZXNzIEJvb2tcXFwiLFxcblxcXCJhbXAuY29tbW9uOnRpdGxlLWhlbHBcXFwiOiBcXFwiSGVscFxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtYW1wLWhlbHBcXFwiOiBcXFwiQU1QIEhlbHBcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWdsb3NzYXJ5XFxcIjogXFxcIkdsb3NzYXJ5XFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1lbWFpbC1zdXBwb3J0LXRlYW1cXFwiOiBcXFwiRW1haWwgU3VwcG9ydCBUZWFtXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZS1sb2dvdXRcXFwiOiBcXFwiTG9nb3V0XFxcIixcXG5cXFwiYW1wLmNvbW1vbjpmaWx0ZXJzLWxvYWRpbmdcXFwiOiBcXFwiTG9hZGluZy4uLlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6cGFnZS10aXRsZVxcXCI6XFxcIkFNUCBEYXNoYm9hcmRzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpsb2FkaW5nXFxcIjogXFxcIkxvYWRpbmcuLi5cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnRpdGxlLXByb2plY3RkYXRhXFxcIjogXFxcIlByb2plY3QgRGF0YVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6c3ViLXRpdGxlLXByb2plY3RkYXRhXFxcIjogXFxcIlZpZXcgd2hlcmUgcHJvamVjdHMgYXJlIGJlaW5nIGltcGxlbWVudGVkIHRocm91Z2hvdXQgdGhlIGNvdW50cnkuXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDp0aXRsZS1Db3VudHJ5XFxcIjogXFxcIkNvdW50cnlcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnRpdGxlLVJlZ2lvblxcXCI6IFxcXCJSZWdpb25cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnRpdGxlLVpvbmVcXFwiOiBcXFwiWm9uZVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6dGl0bGUtRGlzdHJpY3RcXFwiOiBcXFwiRGlzdHJpY3RcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LXJlc2V0XFxcIjogXFxcInJlc2V0IG90aGVyc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtcmFkaW91aS1jb21taXRtZW50c1xcXCI6IFxcXCJDb21taXRtZW50c1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtcmFkaW91aS1kaXNidXJzZW1lbnRzXFxcIjogXFxcIkRpc2J1cnNlbWVudHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtbm9uZS1hcHBsaWVkXFxcIjogXFxcIk5vIGZpbHRlcnMgYXBwbGllZFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2xvc2VcXFwiOiBcXFwiQ2xvc2VcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOm1vZGFsLXNvcnJ5XFxcIjogXFxcIlNvcnJ5IGZvciBhbnkgaW5jb252ZW5pZW5jZVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6c2hhcmUtZGFzaGJvYXJkLXRvcFxcXCI6IFxcXCJTaGFyZSBkYXNoYm9hcmRcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnNoYXJlLWRhc2hib2FyZFxcXCI6IFxcXCJTaGFyZSB0aGlzIGRhc2hib2FyZCB2aWV3XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpzaGFyZS1saW5rXFxcIjogXFxcIkxpbmtcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOm9mXFxcIjogXFxcIm9mXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDp0b29sdGlwLXByZWRpY3Qtb3RoZXJzZXJpZXNcXFwiOiBcXFwiVFJBTlNMQVRFTUVcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOnRvdGFsXFxcIjogXFxcInRvdGFsXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZVxcXCI6IFxcXCJBTVAgVG9vbGJhclxcXCIsXFxuXFxcImFtcC5jb21tb246dGl0bGUtZmlsdGVyc1xcXCI6IFxcXCJGaWx0ZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1Ub3BEb25vckFnZW5jaWVzXFxcIjogXFxcIlRvcCBEb25vciBBZ2VuY2llc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtVG9wRG9ub3JHcm91cHNcXFwiOiBcXFwiVG9wIERvbm9yIEdyb3Vwc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtVG9wUmVnaW9uc1xcXCI6IFxcXCJUb3AgUmVnaW9uc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtVG9wU2VjdG9yc1xcXCI6IFxcXCJUb3AgU2VjdG9yc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtQWlkUHJlZGljdGFiaWxpdHlcXFwiOiBcXFwiQWlkIFByZWRpY3RhYmlsaXR5XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1GdW5kaW5nVHlwZVxcXCI6IFxcXCJGdW5kaW5nIFR5cGVcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LVJlc3BvbnNpYmxlT3JnYW5pemF0aW9uc1xcXCI6IFxcXCJSZXNwb25zaWJsZSBPcmdhbml6YXRpb25zXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1CZW5lZmljaWFyeUFnZW5jaWVzXFxcIjogXFxcIkJlbmVmaWNpYXJ5IEFnZW5jaWVzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1FeGVjdXRpbmdBZ2VuY2llc1xcXCI6IFxcXCJFeGVjdXRpbmcgQWdlbmNpZXNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LUltcGxlbWVudGluZ0FnZW5jaWVzXFxcIjogXFxcIkltcGxlbWVudGluZyBBZ2VuY2llc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtUGVhY2UtYnVpbGRpbmdhbmRTdGF0ZS1idWlsZGluZ0dvYWxzXFxcIjogXFxcIlBlYWNlLWJ1aWxkaW5nIGFuZCBTdGF0ZS1idWlsZGluZyBHb2Fsc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6cHJlZGljdGFiaWxpdHktcGxhbm5lZFxcXCI6IFxcXCJQbGFubmVkXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpwcmVkaWN0YWJpbGl0eS1hY3R1YWxcXFwiOiBcXFwiQWN0dWFsXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1GdW5kaW5nVHlwZS1HcmFudFxcXCI6IFxcXCJHcmFudFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtRnVuZGluZ1R5cGUtTG9hblxcXCI6IFxcXCJMb2FuXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1GdW5kaW5nVHlwZS1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1Ub3BSZWdpb25zLURpc3RyaWN0VW5kZWZpbmVkXFxcIjogXFxcIkRpc3RyaWN0OiBVXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1Ub3BSZWdpb25zLW90aGVyc1xcXCI6IFxcXCJPdGhlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LVRvcFNlY3RvcnMtb3RoZXJzXFxcIjogXFxcIk90aGVyc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtVG9wRG9ub3JBZ2VuY2llcy1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1Ub3BEb25vckdyb3Vwcy1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1SZXNwb25zaWJsZU9yZ2FuaXphdGlvbnMtb3RoZXJzXFxcIjogXFxcIk90aGVyc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtQmVuZWZpY2lhcnlBZ2VuY2llcy1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1FeGVjdXRpbmdBZ2VuY2llcy1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1JbXBsZW1lbnRpbmdBZ2VuY2llcy1vdGhlcnNcXFwiOiBcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1QZWFjZS1idWlsZGluZ2FuZFN0YXRlLWJ1aWxkaW5nR29hbHMtb3RoZXJzXFxcIjpcXFwiT3RoZXJzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLWVkaXRcXFwiOlxcXCJlZGl0IGZpbHRlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmRhc2hib2FyZC1zZXR0aW5nc1xcXCI6XFxcIlNldHRpbmdzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpzZXR0aW5ncy1lZGl0XFxcIjpcXFwiZWRpdCBzZXR0aW5nc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtYW1vdW50XFxcIjpcXFwiQW1vdW50XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpkb3dubG9hZC1wcmV2aWV3XFxcIjpcXFwiUHJldmlldzpcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmRvd25sb2FkLXJlbmRlcmluZ1xcXCI6XFxcIlJlbmRlcmluZy4uLlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtZG93bmxvYWQtY2hhcnRcXFwiOlxcXCJEb3dubG9hZCBjaGFydFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtZG93bmxvYWQtZGF0YVxcXCI6XFxcIkRvd25sb2FkIGRhdGFcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LW5vLWRhdGEtYXZhaWxhYmxlXFxcIjpcXFwiTm8gRGF0YSBBdmFpbGFibGVcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWxvYWRpbmctc2F2ZWQtc2V0dGluZ3NcXFwiOlxcXCJMb2FkaW5nIHNhdmVkIHNldHRpbmdzLi4uXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLXNob3ctc2V0dGluZ3NcXFwiOlxcXCJTaG93IGZpbHRlciBzZXR0aW5nc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZmlsdGVycy1jaGFydC1sZWdlbmRzLUdyb3VwZWRcXFwiOlxcXCJHcm91cGVkXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLWNoYXJ0LWxlZ2VuZHMtU3RhY2tlZFxcXCI6XFxcIlN0YWNrZWRcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOm9mLXRvdGFsXFxcIjogXFxcIm9mIHRvdGFsXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDphaWQtcHJlZGljdGFiaWxpdHktYWN0dWFsLWRpc2J1cnNlbWVudHNcXFwiOiBcXFwiQWN0dWFsIERpc2J1cnNlbWVudHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmFpZC1wcmVkaWN0YWJpbGl0eS1wbGFubmVkLWRpc2J1cnNlbWVudHNcXFwiOiBcXFwiUGxhbm5lZCBEaXNidXJzZW1lbnRzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLWhpZGUtZGV0YWlsc1xcXCI6IFxcXCJIaWRlIGZpbHRlciBkZXRhaWxzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpzYXZpbmctc3RhdGVcXFwiOiBcXFwiU2F2aW5nIGRhc2hib2FyZCBzdGF0ZSwgcGxlYXNlIHdhaXQuLi5cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmRhdGUtcmFuZ2VcXFwiOiBcXFwiRGF0ZSBSYW5nZVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y3VycmVuY3lcXFwiIDogXFxcIkN1cnJlbmN5XFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDp0eXBlXFxcIiA6IFxcXCJUeXBlXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDp5ZWFyXFxcIiA6IFxcXCJZZWFyXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmdHlwZS1hY3R1YWwtY29tbWl0bWVudFxcXCI6IFxcXCJBY3R1YWwgQ29tbWl0bWVudHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZ0eXBlLWFjdHVhbC1kaXNidXJzZW1lbnRcXFwiOiBcXFwiQWN0dWFsIERpc2J1cnNlbWVudHNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZ0eXBlLWFjdHVhbC1leHBlbmRpdHVyZVxcXCI6IFxcXCJBY3R1YWwgRXhwZW5kaXR1cmVzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpmdHlwZS1wbGFubmVkLWNvbW1pdG1lbnRcXFwiOiBcXFwiUGxhbm5lZCBDb21taXRtZW50c1xcXCIgLFxcblxcXCJhbXAuZGFzaGJvYXJkOmZ0eXBlLXBsYW5uZWQtZGlzYnVyc2VtZW50XFxcIjpcXHRcXFwiUGxhbm5lZCBEaXNidXJzZW1lbnRzXFxcIiAsXFxuXFxcImFtcC5kYXNoYm9hcmQ6ZnR5cGUtcGxhbm5lZC1leHBlbmRpdHVyZXNcXFwiOlxcdFxcXCJQbGFubmVkIEV4cGVuZGl0dXJlc1xcXCIsICBcXHRcXHRcXHRcXG5cXFwiYW1wLmRhc2hib2FyZDpkYXNoYm9hcmQtY2hhcnQtdG9wcy1pbmZvLW1vZGFsXFxcIjogXFxcIkNhdGVnb3J5IERldGFpbFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy10YWJsZS1wcm9qZWN0dGl0bGVcXFwiOiBcXFwiUHJvamVjdCBUaXRsZVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy1pbnVuaXRzXFxcIjogXFxcIkluIHVuaXRzXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10b3BzLWludGhvdXNhbmRzXFxcIjogXFxcIkluIHRob3VzYW5kc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy1pbm1pbGxpb25zXFxcIjogXFxcIkluIG1pbGxpb25zXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC10aG91c2FuZFxcXCI6IFxcXCJrXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1taWxsaW9uXFxcIjogXFxcIk1cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWJpbGxpb25cXFwiOiBcXFwiQlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtdHJpbGxpb25cXFwiOiBcXFwiVFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtcGV0YVxcXCI6IFxcXCJQXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1leGFcXFwiOiBcXFwiRVxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtc3dhcC1heGVzXFxcIjogXFxcIlN3YXAgQXhlc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtSGVhdE1hcGJ5U2VjdG9yYW5kRG9ub3JHcm91cFxcXCI6XFxcIlNlY3RvciBGcmFnbWVudGF0aW9uXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1IZWF0TWFwYnlMb2NhdGlvbmFuZERvbm9yR3JvdXBcXFwiOlxcXCJMb2NhdGlvbiBGcmFnbWVudGF0aW9uXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1IZWF0TWFwYnlQcm9ncmFtYW5kRG9ub3JHcm91cFxcXCI6XFxcIlByb2dyYW0gRnJhZ21lbnRhdGlvblxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1yZXNldC1vdGhlcnNcXFwiOlxcXCJSZXNldCBPdGhlcnNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOm5lZ2F0aXZlcy12YWx1ZXNcXFwiOlxcXCJOZWdhdGl2ZSB2YWx1ZXMgYXJlIG5vdCByZXByZXNlbnRlZCBpbiB0aGlzIGNoYXJ0LlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6bmVnYXRpdmVzLXZhbHVlcy1wYXJhZ1xcXCI6XFxcIlBsZWFzZSBzd2l0Y2ggdG8gYmFyIGNoYXJ0IG9yIHRhYmxlIHZpZXcgdG8gdmlldyBhbGwgdmFsdWVzLlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmRzXFxcIjpcXFwiTEVHRU5EU1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC10b3RhbHNcXFwiOlxcXCJUT1RBTFNcXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLWxlc3MtdGhhblxcXCI6XFxcIkxlc3MgdGhhblxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmQtYmV0d2VlblxcXCI6XFxcIkJldHdlZW5cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLWFuZFxcXCI6XFxcImFuZFxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmQtbW9yZS10aGFuXFxcIjpcXFwiTW9yZSB0aGFuXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLW90aGVyc1xcXCI6XFxcIk90aGVyc1xcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6cGVyY2VudGFnZVxcXCI6IFxcXCJQZXJjZW50YWdlXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLWhlbHAtdGV4dC1sb2NhdGlvblxcXCI6XFxcIkVhY2ggY2VsbCByZXByZXNlbnRzIGFuIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgZG9ub3IgZ3JvdXAgYW5kIGEgbG9jYXRpb24gYW5kIHJlcHJlc2VudHMgaG93IG11Y2ggdGhhdCBmdW5kZXIgY29udHJpYnV0ZXMgdG8gdGhlIHRvdGFsIGZ1bmRpbmcgcmVjZWl2ZWQgYnkgdGhhdCBsb2NhdGlvbi5cXFwiLFxcblxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtaGVscC10ZXh0LXNlY3RvclxcXCI6XFxcIkVhY2ggY2VsbCByZXByZXNlbnRzIGFuIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgZG9ub3IgZ3JvdXAgYW5kIGEgc2VjdG9yIGFuZCByZXByZXNlbnRzIGhvdyBtdWNoIHRoYXQgZnVuZGVyIGNvbnRyaWJ1dGVzIHRvIHRoZSB0b3RhbCBmdW5kaW5nIHJlY2VpdmVkIGJ5IHRoYXQgc2VjdG9yLlxcXCIsXFxuXFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1oZWxwLXRleHQtcHJvZ3JhbVxcXCI6XFxcIkVhY2ggY2VsbCByZXByZXNlbnRzIGFuIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgZG9ub3IgZ3JvdXAgYW5kIGEgcHJvZ3JhbSBhbmQgcmVwcmVzZW50cyBob3cgbXVjaCB0aGF0IGZ1bmRlciBjb250cmlidXRlcyB0byB0aGUgdG90YWwgZnVuZGluZyByZWNlaXZlZCBieSB0aGF0IHByb2dyYW0uXFxcIlxcbn1cIik7XG4gICAgICB0aGlzLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcih7XG4gICAgICAgIGRlZmF1bHRLZXlzOiBkYXNoYm9hcmRUcmFuc2xhdGVLZXlzLFxuICAgICAgICBhamF4OiBCYWNrYm9uZURhc2gud3JhcHBlZEFqYXhcbiAgICAgIH0pO1xuICAgICAgLy8gVE9ETzogaGFuZGxlIHRyYW5zbGF0aW9ucyBsb2FkIGZhaWx1cmUgICAgICDigItcbiAgICAgIHRoaXMuZmlsdGVyID0gbmV3IEZpbHRlcih7XG4gICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICAgIHN5bmM6IG9wdGlvbnMuc3luYyB8fCBCYWNrYm9uZURhc2guc3luYyxcbiAgICAgICAgICBjYWxsZXI6ICdEQVNIQk9BUkQnXG4gICAgICAgIH0pO1xuIFxuICBcdCAgLy8gaW5pdGlhbGl6ZSBhcHAgY29tcG9uZW50c1xuICAgICAgdGhpcy52aWV3ID0gbmV3IE1haW5WaWV3KHsgYXBwOiB0aGlzLCBlbDogb3B0aW9ucy5lbCB9KTtcblxuICAgICAgX2luaXREZWZlci5yZXNvbHZlKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF8uZGVmZXIoZnVuY3Rpb24oKSB7IHRocm93IGU7IH0pO1xuICAgICAgdGhpcy52aWV3ID0gbmV3IEZhaWxWaWV3KHsgYXBwOiB0aGlzLCBlbDogb3B0aW9ucy5lbCwgZXJyOiBlfSk7XG4gICAgICB0aGlzLmVyciA9IGU7XG4gICAgICBfaW5pdERlZmVyLnJlamVjdCh0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAvLyBUT0RPOiBmaXggc29tZSBwYXJ0cyBvZiB0aGUgYXBwIHNvIHdlIGNhbiBsb2FkIHRyYW5zbGF0aW9ucyBhc3luY1xuICAgIHRoaXMudHJ5QWZ0ZXIodGhpcy50cmFuc2xhdG9yLnByb21pc2UsIHRoaXMudmlldy5yZW5kZXIsIHRoaXMudmlldyk7XG4gICAgLy8gdGhpcy50cnlUbyh0aGlzLnZpZXcucmVuZGVyLCB0aGlzLnZpZXcpO1xuXG4gICAgLyogZW5zdXJlIGVudGlyZSBwYWdlLS1oZWFkZXIgYW5kIGZvb3Rlciwgbm90IGp1c3QgdGhpcyB2aWV3IGlzIHRyYW5zbGF0ZWQgKi9cbiAgICAvLyBUT0RPOiBpZiBwb3NzaWJsZSwgbW92ZSB0aGlzIG91dCBvZiBhcHAtY2xhc3NcbiAgICAvLyBvciBhdCBsZWFzdCBtYWtlIGl0IG1vcmUgdGFyZ2V0ZWQgdGhhbiBkb2N1bWVudFxuICAgIHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVET00oZG9jdW1lbnQpO1xuICB9LFxuXG4gIGhhc0lzc3VlOiBmdW5jdGlvbihmZWF0dXJlTmFtZSkge1xuICAgIHJldHVybiAhIV8odGhpcy5icm93c2VySXNzdWVzKS5maW5kV2hlcmUoe2ZlYXR1cmU6IGZlYXR1cmVOYW1lfSk7XG4gIH0sXG5cbiAgdmlld0ZhaWw6IGZ1bmN0aW9uKHZpZXcsIGVycikge1xuICAgIHZpZXcuJGVsLmh0bWwobmV3IEZhaWxWaWV3KHsgYXBwOiB0aGlzLCBlcnI6IGVyciB9KS5yZW5kZXIoKS5lbCk7XG4gIH0sXG5cbiAgdHJ5VG86IGZ1bmN0aW9uKGZuLCB2aWV3KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHZpZXcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF8uZGVmZXIoZnVuY3Rpb24oKSB7IHRocm93IGU7IH0pO1xuICAgICAgdGhpcy52aWV3RmFpbCh2aWV3LCBlKTtcbiAgICB9XG4gIH0sXG5cbiAgdHJ5QWZ0ZXI6IGZ1bmN0aW9uKHByb21pc2UsIGZuLCB2aWV3KSB7XG4gICAgcHJvbWlzZVxuICAgICAgLmRvbmUoXyhmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50cnlUbyhmbiwgdmlldyk7XG4gICAgICB9KS5iaW5kKHRoaXMpKVxuICAgICAgLmZhaWwoXyhmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3RmFpbCh2aWV3LCAnZmFpbGVkIHRvIGxvYWQnKTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuICB9LFxuXG4gIHJlcG9ydDogZnVuY3Rpb24odGl0bGUsIG1lc3NhZ2VzKSB7XG4gICAgdGhpcy5pbml0aWFsaXplZFxuICAgICAgLmRvbmUoZnVuY3Rpb24oYXBwKSB7XG4gICAgICAgIGFwcC5tb2RhbCh0aXRsZSwge21lc3NhZ2VzOiBtZXNzYWdlcywgdG9uZTogJ3dhcm5pbmcnfSk7XG4gICAgICB9KVxuICAgICAgLmZhaWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUkVQT1JUOicsIHRpdGxlLCBtZXNzYWdlcyk7XG4gICAgICB9KTtcbiAgfSxcblxuICBtb2RhbDogZnVuY3Rpb24odGl0bGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXyh7fSkuZXh0ZW5kKG9wdGlvbnMsIHt0b25lOiAncHJpbWFyeSd9KTtcbiAgICB2YXIgbW9kYWxSZWFkeSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWRcbiAgICAgIC5kb25lKGZ1bmN0aW9uKGFwcCkge1xuICAgICAgICB2YXIgbW9kYWxFbCA9IGFwcC52aWV3Lm1vZGFsKHRpdGxlLCBvcHRpb25zKTtcbiAgICAgICAgbW9kYWxSZWFkeS5yZXNvbHZlKG1vZGFsRWwpO1xuICAgICAgfSlcbiAgICAgIC5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2ZhaWxlZCB0byBzaG93IG1vZGFsIGJlY2F1c2UgdGhlIGFwcCB2aWV3cyBkaWQgbm90IGluaXRpYWxpemUnLCB0aXRsZSk7XG4gICAgICAgIG1vZGFsUmVhZHkucmVqZWN0KCdhcHAgdmlld3MgZGlkIG5vdCBpbml0Jyk7XG4gICAgICB9KTtcbiAgICByZXR1cm4gbW9kYWxSZWFkeS5wcm9taXNlKCk7XG4gIH1cblxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBcHA7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cblxuLy8gVE9ETzogLi4uIC4uLiAuLi5cbnZhciBJU19QSElMU19DT1JTID0gd2luZG93ICYmICh3aW5kb3cubG9jYXRpb24uaG9zdCA9PT0gJ2xvY2FsaG9zdDozMDAwJyk7XG5cblxudmFyIENBQ0hFID0gWycvcmVzdC9kYXNoYm9hcmQnXTtcblxuXG5mdW5jdGlvbiBJbml0RXJyb3IoaW5zdGFuY2UpIHtcbiAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAnTW9kdWxlIGluaXRpYWxpemF0aW9uIGVycm9yJzsgfTtcbn1cblxuXG52YXIgYWpheE9wdGlvbldyYXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBfKHt9KS5leHRlbmQob3B0aW9ucywge1xuICAgIC8vIG1heWJlIHVzZSBwaGlsJ3MgRFJDIENPUlMgZGV2IHNlcnZlclxuICAgIHVybDogKElTX1BISUxTX0NPUlMgPyAnaHR0cDovL2xvY2FsaG9zdDo4MDgwJyA6ICcnKSArIG9wdGlvbnMudXJsLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC8vIGpzY3M6ZGlzYWJsZSBkaXNhbGxvd1F1b3RlZEtleXNJbk9iamVjdHNcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAvLyBqc2NzOmVuYWJsZSBkaXNhbGxvd1F1b3RlZEtleXNJbk9iamVjdHNcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3B0aW9ucztcbn07XG5cblxudmFyIHN5bmNPdmVycmlkZSA9IChmdW5jdGlvbihicykge1xuICB2YXIgY2FjaGUgPSB7fTtcblxuICBmdW5jdGlvbiBfZG9TeW5jKHVybCwgbWV0aG9kLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfKHt9KS5leHRlbmQob3B0aW9ucywgeyB1cmw6IHVybCB9KTtcbiAgICBvcHRpb25zID0gYWpheE9wdGlvbldyYXAob3B0aW9ucyk7XG4gICAgcmV0dXJuIGJzLmNhbGwodGhpcywgbWV0aG9kLCBtb2RlbCwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBfY2FjaGVTeW5jKHVybCwgbWV0aG9kLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciBrZXkgPSB1cmwgKyAnK1BPU1Q6JyArIG9wdGlvbnMuZGF0YTtcbiAgICBpZiAoY2FjaGVba2V5XSkgeyByZXR1cm4gY2FjaGVba2V5XSgpOyB9XG5cbiAgICB2YXIgeGhyID0gX2RvU3luYyh1cmwsIG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpO1xuXG4gICAgY2FjaGVba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gY2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdpbGwgbWFrZSB0aGUgeGhyIHJlLWNhbGwgaXRzIGNhbGxiYWNrc1xuICAgICAgcmV0dXJuIHhoclxuICAgICAgICAuZG9uZShvcHRpb25zLnN1Y2Nlc3MpXG4gICAgICAgIC5hbHdheXMob3B0aW9ucy5jb21wbGV0ZSk7XG4gICAgfTtcblxuICAgIC8vIGRvIG5vdCBjYWNoZSBmYWlsZWQgcmVxdWVzdHNcbiAgICB4aHIuZmFpbChmdW5jdGlvbigpIHsgZGVsZXRlIGNhY2hlW2tleV07IH0pO1xuXG4gICAgcmV0dXJuIHhocjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihtZXRob2QsIG1vZGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIHVybCA9IG9wdGlvbnMudXJsIHx8IF8obW9kZWwpLnJlc3VsdCgndXJsJykgfHwgQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLnVybC5jYWxsKG1vZGVsKSxcbiAgICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ1BPU1QnICYmXG4gICAgICBfLnNvbWUoQ0FDSEUsIGZ1bmN0aW9uKGkpIHsgcmV0dXJuIHVybC5pbmRleE9mKGkpID09PSAwOyB9KSkge1xuICAgICAgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIChjYWNoZWFibGUgPyBfY2FjaGVTeW5jIDogX2RvU3luYykodXJsLCBtZXRob2QsIG1vZGVsLCBvcHRpb25zKTtcbiAgfTtcbn0pKEJhY2tib25lLnN5bmMpO1xuXG5cbi8vIG1peGVkIGludG8gYWxsIG1vZGVscywgY29sbGVjdGlvbnMgYW5kIHZpZXdzIHRvIGVuc3VyZSB3ZSBoYXZlIGEgY29udmVuaWVudFxuLy8gcmVmZXJlbmNlIHRvIHRoZSBhcHAgaW5zdGFuY2UgZXZlcnl3aGVyZS5cbmZ1bmN0aW9uIG1peERhc2goQ2xhc3MpIHtcbiAgcmV0dXJuIENsYXNzLmV4dGVuZCh7XG5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29uc3RydWN0ZWQgPSBDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKCF0aGlzLmFwcCkge1xuICAgICAgICB0aHJvdyBuZXcgSW5pdEVycm9yKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnN0cnVjdGVkO1xuICAgIH0sXG5cbiAgICBzeW5jOiBzeW5jT3ZlcnJpZGVcblxuICB9KTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IF8oe30pLmV4dGVuZChCYWNrYm9uZSwge1xuICAvLyBlcnJvcnNcbiAgSW5pdEVycm9yOiBJbml0RXJyb3IsXG5cbiAgTW9kZWw6IG1peERhc2goQmFja2JvbmUuTW9kZWwpLFxuICBDb2xsZWN0aW9uOiBtaXhEYXNoKEJhY2tib25lLkNvbGxlY3Rpb24pLFxuICBWaWV3OiBtaXhEYXNoKEJhY2tib25lLlZpZXcpLFxuXG4gIHN5bmM6IHN5bmNPdmVycmlkZSxcbiAgd3JhcHBlZEFqYXg6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIEJhY2tib25lLmFqYXgoYWpheE9wdGlvbldyYXAobykpOyB9XG59KTtcbiIsIi8qXG4gKiBEcmF3aW5nIGEgYmFyIGNoYXJ0IGluIEFNUD8gUGxlYXNlIHVzZSAuL2NoYXJ0LmpzIGluc3RlYWQuXG4gKi9cblxudmFyIGJhckRlYnVnID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vLi4vLi4vcmVhbXAvdG9vbHMvbG9nJykoXCJhbXA6ZGFzaGJvYXJkczpjaGFydHM6YmFyXCIpO1xuXG52YXIgbnYgPSB3aW5kb3cubnY7ICAvLyBudmQzIGlzIGEgcGFpblxudmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdWdseS91dGlsJyk7XG5cblxuZnVuY3Rpb24gZGF0YVRvTnYoZGF0YSkge1xuICByZXR1cm4gZGF0YTtcbn1cblxuXG5mdW5jdGlvbiBjb3VudENhdGVnb3JpZXMoZGF0YSkge1xuICAvLyBub3RlOiB0aGlzIHRha2VzIHJlZ3VsYXIgZGF0YSwgbm90IGRhdGFUb052IGRhdGEuXG4gIHJldHVybiBkYXRhWzBdLnZhbHVlcy5sZW5ndGggLSAxOyAgLy8gMSBmb3Igb3RoZXJzLi4uP1xufVxuXG5cbmZ1bmN0aW9uIGNoYXJ0KG9wdGlvbnMsIGRhdGEpIHtcbiAgLy90aGlzIGNoZWNrIGlzIG5lZWRlZCBiZWNhdXNlIEkgbmVlZCBzdHJpY3RseSBlaXRoZXIgMzAwIG9yIDQwMCBweCwgYW5kIHNvbWV0aW1lcywgd2hlbiB0aGUgY2hhcnQgb3ZlcmZsb3dzLCBpdFxuICAvL3dpbGwgZ2l2ZSBtZSA+NDAwIHB4IGhlaWdodFxuICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgPCA0MDAgPyAzMDAgOiA0MDA7XG4gIHZhciBjYWxjdWxhdGVkSGVpZ2h0ID0gdXRpbC5jYWxjdWxhdGVDaGFydEhlaWdodChkYXRhWzBdLnZhbHVlcy5sZW5ndGgsIGZhbHNlLCBvcHRpb25zLm1vZGVsKTtcbiAgaWYgKGNhbGN1bGF0ZWRIZWlnaHQgIT09IG51bGwpIHtcblx0ICBoZWlnaHQgPSBjYWxjdWxhdGVkSGVpZ2h0OyBcbiAgfVxuICAgXG4gIGJhckRlYnVnLmxvZyhcIlNldHRpbmcgaGVpZ2h0IHRvXCIsIGhlaWdodCk7XG4gIHZhciBfY2hhcnQgPSBudi5tb2RlbHMuZGlzY3JldGVCYXJDaGFydCgpXG4gICAgLnZhbHVlRm9ybWF0KG9wdGlvbnMuc2hvcnRGb3JtYXR0ZXIpXG4gICAgLnNob3dWYWx1ZXModHJ1ZSlcbiAgICAuc2hvd1lBeGlzKGZhbHNlKVxuICAgIC5zaG93WEF4aXMoZmFsc2UpXG4gICAgLmhlaWdodChoZWlnaHQpXG4gICAgLm1hcmdpbih7IHRvcDogNSwgcmlnaHQ6IDEwLCBib3R0b206IDEwLCBsZWZ0OiAxMCB9KTtcbiAgcmV0dXJuIF9jaGFydDtcbn1cblxuXG5mdW5jdGlvbiBhZGRMZWdlbmQoc3ZnLCBjaGFydCwgbnZEYXRhLCB0cmltTGFiZWxzLCB3aWR0aCkge1xuICB2YXIgbGVnZW5kSGVpZ2h0O1xuXG4gIHZhciBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAud2lkdGgod2lkdGggfHwgc3ZnLmNsaWVudFdpZHRoKVxuICAgIC5tYXJnaW4oe2xlZnQ6IDIwLCByaWdodDogMjB9KVxuICAgIC5yaWdodEFsaWduKGZhbHNlKVxuICAgIC5jb2xvcih1dGlsLmNhdGVnb3J5Q29sb3VycyhudkRhdGFbMF0udmFsdWVzLmxlbmd0aCkpXG4gICAgLmtleShmdW5jdGlvbihkKSB7IHJldHVybiB0cmltTGFiZWxzID8gdXRpbC5mb3JtYXRTaG9ydFRleHQoMTIpKGQueCkgOiB1dGlsLmZvcm1hdFNob3J0VGV4dCg4NSkoZC54KTsgfSk7XG5cbiAgZDMuc2VsZWN0KHN2ZylcbiAgICAuZGF0dW0obnZEYXRhKVxuICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZCcpXG4gICAgICAuZGF0dW0obnZEYXRhWzBdLnZhbHVlcylcbiAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgbGVnZW5kSGVpZ2h0ID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoJy5sZWdlbmQnKS5nZXRCQm94KCkuaGVpZ2h0O1xuICBjaGFydC5tYXJnaW4oe3RvcDogbGVnZW5kSGVpZ2h0ICsgMTV9KTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGlzcGF0Y2hOYW1lOiAnZGlzY3JldGViYXInLFxuICBjb3VudENhdGVnb3JpZXM6IGNvdW50Q2F0ZWdvcmllcyxcbiAgYWRkTGVnZW5kOiBhZGRMZWdlbmQsXG4gIGRhdGFUb052OiBkYXRhVG9OdixcbiAgY2hhcnQ6IGNoYXJ0XG59O1xuIiwiLypcbiAqIERyYXdpbmcgYSBiYXIgY2hhcnQgaW4gQU1QPyBQbGVhc2UgdXNlIC4vY2hhcnQuanMgaW5zdGVhZC5cbiAqL1xuXG52YXIgYmFyRGVidWcgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi8uLi8uLi9yZWFtcC90b29scy9sb2cnKShcImFtcDpkYXNoYm9hcmRzOmNoYXJ0czpiYXJcIik7XG5cbnZhciBudiA9IHdpbmRvdy5udjsgIC8vIG52ZDMgaXMgYSBwYWluXG52YXIgZDMgPSByZXF1aXJlKCdkMycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91Z2x5L3V0aWwnKTtcbnZhciBoZWF0TWFwQ2hhcnQgPSByZXF1aXJlKCcuL2N1c3RvbWl6ZWQvaGVhdE1hcENoYXJ0Jyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuZnVuY3Rpb24gZGF0YVRvTnYoZGF0YSkge1xuICByZXR1cm4gZGF0YTtcbn1cblxuXG5mdW5jdGlvbiBjb3VudENhdGVnb3JpZXMoZGF0YSkge1xuICAvLyBub3RlOiB0aGlzIHRha2VzIHJlZ3VsYXIgZGF0YSwgbm90IGRhdGFUb052IGRhdGEuXG4gIHJldHVybiBkYXRhWzBdLnZhbHVlcy5sZW5ndGggLSAxOyAgLy8gMSBmb3Igb3RoZXJzLi4uP1xufVxuXG5cbmZ1bmN0aW9uIGNoYXJ0KG9wdGlvbnMsIGRhdGEpIHtcbiAgLy90aGlzIGNoZWNrIGlzIG5lZWRlZCBiZWNhdXNlIEkgbmVlZCBzdHJpY3RseSBlaXRoZXIgMzAwIG9yIDQwMCBweCwgYW5kIHNvbWV0aW1lcywgd2hlbiB0aGUgY2hhcnQgb3ZlcmZsb3dzLCBpdFxuICAvL3dpbGwgZ2l2ZSBtZSA+NDAwIHB4IGhlaWdodFxuICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgPCA0MDAgPyAzMDAgOiA0MDA7XG4gIHZhciBjYWxjdWxhdGVkSGVpZ2h0ID0gdXRpbC5jYWxjdWxhdGVDaGFydEhlaWdodChkYXRhWzBdLnZhbHVlcy5sZW5ndGgsIGZhbHNlLCBvcHRpb25zLm1vZGVsKTtcbiAgaWYgKGNhbGN1bGF0ZWRIZWlnaHQgIT09IG51bGwpIHtcblx0ICBoZWlnaHQgPSBjYWxjdWxhdGVkSGVpZ2h0OyBcbiAgfVxuICAgXG4gIHZhciBfY2hhcnQgPSBudi5tb2RlbHMuaGVhdE1hcENoYXJ0KCkuaGVpZ2h0KDkwMCk7XG4gIHJldHVybiBfY2hhcnQ7XG59XG5cblxuZnVuY3Rpb24gYWRkTGVnZW5kKHN2ZywgY2hhcnQsIG52RGF0YSwgdHJpbUxhYmVscywgd2lkdGgpIHtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGlzcGF0Y2hOYW1lOiAnaGVhdG1hcCcsXG4gIGNvdW50Q2F0ZWdvcmllczogY291bnRDYXRlZ29yaWVzLFxuICBhZGRMZWdlbmQ6IGFkZExlZ2VuZCxcbiAgZGF0YVRvTnY6IGRhdGFUb052LFxuICBjaGFydDogY2hhcnRcbn07XG4iLCIvKlxuICogRHJhd2luZyBhIG11bHRpYmFyIGNoYXJ0IGluIEFNUD8gUGxlYXNlIHVzZSAuL2NoYXJ0LmpzIGluc3RlYWQuXG4gKi9cblxudmFyIG11bHRpYmFyRGVidWcgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi8uLi8uLi8uLi9yZWFtcC90b29scy9sb2cnKShcImFtcDpkYXNoYm9hcmRzOmNoYXJ0czptdWx0aWJhclwiKTtcblxudmFyIG52ID0gd2luZG93Lm52OyAgLy8gbnZkMyBpcyBhIHBhaW5cbnZhciBjdXN0b21pemVkTXVsdGlCYXJDaGFydCA9IHJlcXVpcmUoJy4vY3VzdG9taXplZC9tdWx0aUJhckNoYXJ0LmpzJyk7XG4vLyB2YXIgZDMgPSByZXF1aXJlKCdkMy1icm93c2VyaWZ5Jyk7XG5cblxuZnVuY3Rpb24gZGF0YVRvTnYoZGF0YSkge1xuICByZXR1cm4gZGF0YTtcbn1cblxuXG5mdW5jdGlvbiBjb3VudENhdGVnb3JpZXMoZGF0YSkge1xuICAvLyBub3RlOiB0aGlzIHRha2VzIHJlZ3VsYXIgZGF0YSwgbm90IGRhdGFUb052IGRhdGEuXG4gIHJldHVybiBkYXRhLmxlbmd0aDtcbn1cblxuXG5mdW5jdGlvbiBjaGFydChvcHRpb25zKSB7XG4gIHZhciBtYXhWYWx1ZSA9IDEwO1xuICAvL3RoaXMgY2hlY2sgaXMgbmVlZGVkIGJlY2F1c2UgSSBuZWVkIHN0cmljdGx5IGVpdGhlciAzMDAgb3IgNDAwIHB4LCBhbmQgc29tZXRpbWVzLCB3aGVuIHRoZSBjaGFydCBvdmVyZmxvd3MsIGl0XG4gIC8vd2lsbCBnaXZlIG1lID40MDAgcHggaGVpZ2h0XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCA8IDQwMCA/IDMwMCA6IDQwMDtcbiAgbXVsdGliYXJEZWJ1Zy5sb2coXCJTZXR0aW5nIG11bHRpYmFyIGhlaWdodFwiLCBoZWlnaHQpO1xuICB2YXIgX2NoYXJ0ID0gbnYubW9kZWxzLmN1c3RvbWl6ZWRNdWx0aUJhckNoYXJ0KCkgIFxuICAgIC5mb3JjZVkoWzAsIG1heFZhbHVlXSkgIC8vIGVuc3VyZXMgeUF4aXMgaXMgc2hvd2luZyBhdCBsZWFzdCAwIGFuZCAxMCwgYnV0IHdvbid0IHJlc3RyaWN0IHRoZSBkb21haW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAobWVhbmluZyBpZiB0aGUgYXJlIHZhbHVlcyBmYWxsaW5nIG91dHNpZGUgdGhlIHJhbmdlIGl0IHdpbGwgc2hvdyB0aGVuKS5cbiAgICAucmVkdWNlWFRpY2tzKGZhbHNlKVxuICAgIC5oZWlnaHQoaGVpZ2h0KVxuICAgIC5tYXJnaW4oeyB0b3A6IDUsIHJpZ2h0OiAxMCwgYm90dG9tOiAyMCwgbGVmdDogNTAgfSk7XG5cbiAgaWYgKCFvcHRpb25zLm52Q29udHJvbHMpIHtcbiAgICBfY2hhcnQuc2hvd0NvbnRyb2xzKGZhbHNlKTtcbiAgfVxuICBcbiAgaWYob3B0aW9ucy5zdGFja2VkKXtcblx0ICBfY2hhcnQubXVsdGliYXIuc3RhY2tlZCh0cnVlKTsgXG4gIH1lbHNle1xuXHQgIF9jaGFydC5tdWx0aWJhci5zdGFja2VkKGZhbHNlKTtcbiAgfVxuXG4gIF9jaGFydC55QXhpc1xuICAgIC50aWNrRm9ybWF0KG9wdGlvbnMuc2hvcnRGb3JtYXR0ZXIpXG4gICAgLnNob3dNYXhNaW4oZmFsc2UpO1xuXG4gIHJldHVybiBfY2hhcnQ7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRpc3BhdGNoTmFtZTogJ211bHRpYmFyJyxcbiAgY291bnRDYXRlZ29yaWVzOiBjb3VudENhdGVnb3JpZXMsXG4gIGRhdGFUb052OiBkYXRhVG9OdixcbiAgY2hhcnQ6IGNoYXJ0XG59O1xuIiwiLypcbiAqIERyYXdpbmcgYSBwaWUgY2hhcnQgaW4gQU1QPyBQbGVhc2UgdXNlIC4vY2hhcnQuanMgaW5zdGVhZC5cbiAqL1xuXG52YXIgbnYgPSB3aW5kb3cubnY7ICAvLyBudmQzIGlzIGEgcGFpblxuLy8gdmFyIGQzID0gcmVxdWlyZSgnZDMtYnJvd3NlcmlmeScpO1xuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91Z2x5L3V0aWwnKTtcbnZhciBjdXN0b21pemVkUGllQ2hhcnQgPSByZXF1aXJlKCcuL2N1c3RvbWl6ZWQvcGllQ2hhcnQuanMnKTtcblxuXG5mdW5jdGlvbiBkYXRhVG9OdihkYXRhKSB7XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gMSkge1xuICAgIGNvbW1vbi5mYWlsKCdQaWUgY2hhcnRzIGNhbiBvbmx5IHNob3cgb25lIHNlcmllcyBvZiBkYXRhLiBnb3QnLCBkYXRhLmxlbmd0aCk7XG4gIH1cbiAgaWYgKCFfLmlzQXJyYXkoZGF0YVswXS52YWx1ZXMpKSB7XG4gICAgY29tbW9uLmZhaWwoJ0RhdGEgc2VyaWVzIGRpZCBub3QgaGF2ZSBhIFwidmFsdWVzXCIgYXJyYXkuIEluc3RlYWQnLCBkYXRhWzBdLnZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIGdldFBvc2l0aXZlVmFsdWVzKGRhdGFbMF0udmFsdWVzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpdmVWYWx1ZXModmFsdWVzKSB7XG4gIHJldHVybiBfLmZpbHRlcih2YWx1ZXMsIGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZS55PjA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb3VudENhdGVnb3JpZXMoZGF0YSkge1xuICAvLyBub3RlOiB0aGlzIHRha2VzIHJlZ3VsYXIgZGF0YSwgbm90IGRhdGFUb052IGRhdGEuXG4gIHJldHVybiBnZXRQb3NpdGl2ZVZhbHVlcyhkYXRhWzBdLnZhbHVlcykubGVuZ3RoO1xufVxuXG5cbmZ1bmN0aW9uIGNoYXJ0KG9wdGlvbnMsIGRhdGEpIHtcblx0dmFyIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IDwgNDAwID8gMzAwIDogNDAwO1xuXHQgIHZhciBjYWxjdWxhdGVkSGVpZ2h0ID0gdXRpbC5jYWxjdWxhdGVDaGFydEhlaWdodChkYXRhWzBdLnZhbHVlcy5sZW5ndGgsIGZhbHNlLCBvcHRpb25zLm1vZGVsKTtcblx0ICBpZiAoY2FsY3VsYXRlZEhlaWdodCAhPT0gbnVsbCkge1xuXHRcdCAgaGVpZ2h0ID0gY2FsY3VsYXRlZEhlaWdodDsgXG5cdCAgfVxuXG4gIHZhciBfY2hhcnQgPSBudi5tb2RlbHMuY3VzdG9taXplZFBpZUNoYXJ0KClcbiAgICAudmFsdWVGb3JtYXQob3B0aW9ucy5zaG9ydEZvcm1hdHRlcilcbiAgICAubGFiZWxUeXBlKCdwZXJjZW50JylcbiAgICAuc2hvd0xlZ2VuZChmYWxzZSlcbiAgICAuZG9udXQodHJ1ZSlcbiAgICAuaGVpZ2h0KGhlaWdodClcbiAgICAubWFyZ2luKHsgdG9wOiA1LCByaWdodDogNSwgYm90dG9tOiA1LCBsZWZ0OiA1IH0pXG4gICAgLmRvbnV0UmF0aW8oMC4zNSk7XG4gIHJldHVybiBfY2hhcnQ7XG59XG5cbmZ1bmN0aW9uIGFkZExlZ2VuZChzdmcsIGNoYXJ0LCBudkRhdGEsIHRyaW1MYWJlbHMsIHdpZHRoKSB7XG5cdCAgdmFyIGxlZ2VuZEhlaWdodDtcblxuXHQgIHZhciBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcblx0ICAgIC53aWR0aCh3aWR0aCB8fCBzdmcuY2xpZW50V2lkdGgpXG5cdCAgICAubWFyZ2luKHtsZWZ0OiAyMCwgcmlnaHQ6IDIwfSlcblx0ICAgIC5yaWdodEFsaWduKGZhbHNlKVxuXHQgICAgLmNvbG9yKHV0aWwuY2F0ZWdvcnlDb2xvdXJzKG52RGF0YS5sZW5ndGgpKVxuXHQgICAgLmtleShmdW5jdGlvbihkKSB7IHJldHVybiB0cmltTGFiZWxzID8gdXRpbC5mb3JtYXRTaG9ydFRleHQoMTIpKGQueCkgOiB1dGlsLmZvcm1hdFNob3J0VGV4dCg4NSkoZC54KTsgfSk7XG5cblx0ICBkMy5zZWxlY3Qoc3ZnKVxuXHQgICAgLmRhdHVtKG52RGF0YSlcblx0ICAgIC5hcHBlbmQoJ2cnKVxuXHQgICAgICAuYXR0cignY2xhc3MnLCAnbGVnZW5kJylcblx0ICAgICAgLmRhdHVtKG52RGF0YSlcblx0ICAgICAgLmNhbGwobGVnZW5kKTtcblxuXHQgIGxlZ2VuZEhlaWdodCA9IHN2Zy5xdWVyeVNlbGVjdG9yKCcubGVnZW5kJykuZ2V0QkJveCgpLmhlaWdodDtcblx0ICBjaGFydC5tYXJnaW4oe3RvcDogbGVnZW5kSGVpZ2h0ICsgMTV9KTtcbn1cblxuXG5mdW5jdGlvbiByZW1vdmVMZWdlbmQoY2hhcnQpIHtcbiAgY2hhcnQuc2hvd0xlZ2VuZChmYWxzZSk7XG59XG5cblxuZnVuY3Rpb24gbm9ybWFsaXplTnZUVEFyZ3MoZm10WCwgZm10WSwgcmF3KSB7XG4gIC8vIG52IHBpZSBjaGFydHMgZHJvcCB0aGUgc2VyaWVzTmFtZSBhcyBmaXJzdCBhcmdcbiAgcmV0dXJuIFt2b2lkIDAsIGZtdFgsIGZtdFksIHJhd107XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRpc3BhdGNoTmFtZTogJ3BpZScsXG4gIG5vcm1hbGl6ZU52VFRBcmdzOiBub3JtYWxpemVOdlRUQXJncyxcbiAgY291bnRDYXRlZ29yaWVzOiBjb3VudENhdGVnb3JpZXMsXG4gIGFkZExlZ2VuZDogYWRkTGVnZW5kLFxuICByZW1vdmVMZWdlbmQ6IHJlbW92ZUxlZ2VuZCxcbiAgZGF0YVRvTnY6IGRhdGFUb052LFxuICBjaGFydDogY2hhcnRcbn07XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91Z2x5L3V0aWwnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIHRhYmxlVGVtcGxhdGUgPSBfLnRlbXBsYXRlKFwiPGRpdiBjbGFzcz1cXFwidGFibGUtcmVzcG9uc2l2ZVxcXCI+XFxuICA8dGFibGUgY2xhc3M9XFxcInRhYmxlIHRhYmxlLXN0cmlwZWQgdGFibGUtY29uZGVuc2VkXFxcIj5cXG5cXG4gICAgPCUgaWYgKF8oa2V5cykuc29tZSgpKSB7ICU+XFxuICAgICAgPHRoZWFkPlxcbiAgICAgICAgPHRyPlxcbiAgICAgICAgICA8dGQ+PC90ZD5cXG4gICAgICAgICAgPCUgXyhrZXlzKS5lYWNoKGZ1bmN0aW9uKGtleSwgY29sSW5kZXgpIHsgJT5cXG4gICAgICAgICAgICA8dGggZGF0YS1zZXJpZXMtaW5kZXg9XFxcIjwlPSBjb2xJbmRleCAlPlxcXCI+XFxuICAgICAgICAgICAgICA8JT0ga2V5ICU+XFxuICAgICAgICAgICAgPC90aD5cXG4gICAgICAgICAgPCUgfSk7ICU+XFxuICAgICAgICA8L3RyPlxcbiAgICAgIDwvdGhlYWQ+XFxuICAgIDwlIH0gJT5cXG5cXG4gICAgPHRib2R5PlxcbiAgICAgIDwlIF8odmFsdWVzKS5lYWNoKGZ1bmN0aW9uKHJvdywgcm93SW5kZXgpIHsgJT5cXG4gICAgICAgIDx0cj5cXG4gICAgICAgICAgPHRoIGRhdGEteC1pbmRleD1cXFwiPCU9IHJvd0luZGV4ICU+XFxcIj5cXG4gICAgICAgICAgICA8JT0gcm93WzBdLnggJT5cXG4gICAgICAgICAgPC90aD5cXG4gICAgICAgICAgPCUgXyhyb3cpLmVhY2goZnVuY3Rpb24oZGF0dW0sIGNvbEluZGV4KSB7ICU+XFxuICAgICAgICAgICAgPHRkIGRhdGEteC1pbmRleD1cXFwiPCU9IHJvd0luZGV4ICU+XFxcIiBkYXRhLXNlcmllcy1pbmRleD1cXFwiPCU9IGNvbEluZGV4ICU+XFxcIj5cXG4gICAgICAgICAgICAgIDwlPSBtb25leUZvcm1hdChkYXR1bS55KSAlPlxcbiAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgIDwlIH0pICU+XFxuICAgICAgICA8L3RyPlxcbiAgICAgIDwlIH0pICU+XFxuICAgIDwvdGJvZHk+XFxuXFxuICA8L3RhYmxlPlxcbjwvZGl2PlxcblwiKTtcbnZhciBoZWF0bWFwVGFibGVUZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8ZGl2IGNsYXNzPVxcXCJoZWF0bWFwLXRhYmxlLXJlc3BvbnNpdmVcXFwiPlxcblxcdDx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWRcXFwiPlxcblxcdFxcdDwlIGlmIChfKGtleXMpLnNvbWUoKSkgeyAlPlxcblxcdCAgICBcXHQ8dGhlYWQ+XFxuXFx0ICAgICAgICBcXHQ8dHI+XFxuXFx0ICAgICAgICAgIFxcdFxcdDwlIF8oa2V5cykuZWFjaChmdW5jdGlvbihrZXksIGNvbEluZGV4KSB7ICU+XFxuXFx0ICAgICAgICAgICAgXFx0XFx0PHRoIGRhdGEtc2VyaWVzLWluZGV4PVxcXCIwXFxcIj5cXG5cXHQgICAgICAgICAgICAgIFxcdFxcdFxcdDwlPSBrZXkgJT5cXG5cXHQgICAgICAgICAgICBcXHRcXHQ8L3RoPlxcblxcdCAgICAgICAgICBcXHRcXHQ8JSB9KTsgJT5cXG5cXHQgICAgICAgIFxcdDwvdHI+XFxuXFx0ICAgICAgXFx0PC90aGVhZD5cXG5cXHQgICAgPCUgfSAlPlxcblxcdFxcdDx0Ym9keT5cXG5cXHRcXHRcXHQ8JSBfKG1hdHJpeCkuZWFjaChmdW5jdGlvbihyb3csIGkpIHsgJT5cXG5cXHRcXHRcXHRcXHQ8JSBfKHJvdykuZWFjaChmdW5jdGlvbihjb2wsIGopIHsgJT5cXG5cXHRcXHRcXHRcXHRcXHQ8dHI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PHRkIGRhdGEteC1pbmRleD1cXFwiPCU9IGkgJT5cXFwiIGRhdGEtc2VyaWVzLWluZGV4PVxcXCIwXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8JT0gbWF0cml4W2ldW2pdLnkgJT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L3RkPlxcblxcdFxcdFxcdFxcdFxcdFxcdDx0ZCBkYXRhLXgtaW5kZXg9XFxcIjwlPSBpICU+XFxcIiBkYXRhLXNlcmllcy1pbmRleD1cXFwiMFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PCU9IG1hdHJpeFtpXVtqXS54ICU+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC90ZD5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8dGQgZGF0YS14LWluZGV4PVxcXCI8JT0gaSAlPlxcXCIgZGF0YS1zZXJpZXMtaW5kZXg9XFxcIjBcXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwlPSBtYXRyaXhbaV1bal0udmFsdWUuZHYgJT5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L3RkPlxcblxcdFxcdFxcdFxcdFxcdFxcdDx0ZCBkYXRhLXgtaW5kZXg9XFxcIjwlPSBpICU+XFxcIiBkYXRhLXNlcmllcy1pbmRleD1cXFwiMFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PCU9IG1hdHJpeFtpXVtqXS52YWx1ZS5wICU+XFxuXFx0XFx0XFx0XFx0XFx0XFx0PC90ZD5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXG5cXHRcXHRcXHRcXHRcXHQ8L3RyPlxcblxcdFxcdFxcdFxcdDwlIH0pICU+XFxuXFx0XFx0XFx0PCUgfSkgJT5cXG5cXHRcXHQ8L3Rib2R5PlxcblxcdDwvdGFibGU+XFxuPC9kaXY+XCIpO1xuXG5cbmZ1bmN0aW9uIGZha2VSYXdDb250ZXh0KGUsIGRhdGEpIHtcbiAgLy8gdHJhbnNmb3JtIGEgdGFibGUtY2xpY2sgZXZlbnQgaW50byBzb21ldGhpbmcgdGhhdCBsb29rcyBsaWtlIGl0IGNhbWUgZnJvbVxuICAvLyBhbiBudmQzIGhhbmRsZXJcbiAgdmFyIHQgPSBlLnRhcmdldCxcbiAgICAgIHNlcmllc0luZGV4ID0gcGFyc2VJbnQodXRpbC5kYXRhKHQsICdzZXJpZXNJbmRleCcpLCAxMCkgfHwgMCxcbiAgICAgIHhJbmRleCA9IHBhcnNlSW50KHV0aWwuZGF0YSh0LCAneEluZGV4JyksIDEwKTtcbiAgLy8gVGhpcyBjaGVjayBpcyBmb3IgaGVhdG1hcHMgYmVjYXVzZSB0aGV5IGRvbnQgdXNlIHRoZSBzYW1lIGRhdGEgc3RydWN0dXJlLlxuICBpZiAoIWlzTmFOKHhJbmRleCkpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgbGFiZWw6IGRhdGFbc2VyaWVzSW5kZXhdLnZhbHVlc1t4SW5kZXhdLnggfHwgeEluZGV4LFxuXHQgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuXHQgICAgcG9pbnRJbmRleDogeEluZGV4LFxuXHQgICAgcG9pbnQ6IGRhdGFbc2VyaWVzSW5kZXhdLnZhbHVlc1t4SW5kZXhdIHx8IHhJbmRleFxuXHQgIH07XG4gIH0gZWxzZSB7XG5cdCAgcmV0dXJuIHtcblx0XHQgIGxhYmVsOiAnJyxcblx0XHQgIHBvaW50OiAnJ1xuXHQgIH07XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBiaW5kQ2xpY2tIYW5kbGVyKGVsLCBkYXRhLCBvcHRpb25zKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBmYWtlUmF3ID0gZmFrZVJhd0NvbnRleHQoZSwgZGF0YSksICAvLyBzbyB3ZSBjYW4gdXNlIHRoZSBzaGFyZWQgY29udGV4dCB0cmFuc2Zvcm1lclxuICAgICAgICBjb250ZXh0ID0gY29tbW9uLmdldE5pY2VDb250ZXh0KGZha2VSYXcsIGRhdGEsIGUudGFyZ2V0LmlubmVyVGV4dCk7XG4gICAgb3B0aW9ucy5jbGlja0hhbmRsZXIoY29udGV4dCk7XG4gIH0pO1xufVxuXG5cbmZ1bmN0aW9uIGNoYXJ0ZXIoZGF0YSwgb3B0aW9ucykge1xuXHRpZiAob3B0aW9ucy5tb2RlbC5nZXQoJ2NoYXJ0VHlwZScpID09PSAnZnJhZ21lbnRhdGlvbicpIHtcblx0XHRyZXR1cm4gaGVhdG1hcENoYXJ0ZXIoZGF0YSwgb3B0aW9ucyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGNvbW1vbkNoYXJ0ZXIoZGF0YSwgb3B0aW9ucyk7XG5cdH1cdFxufVxuXG5mdW5jdGlvbiBjb21tb25DaGFydGVyKGRhdGEsIG9wdGlvbnMpIHtcblx0dmFyIGtleXMgPSBfKGRhdGEpLnBsdWNrKCdrZXknKTtcblxuXHR2YXIgdmFsdWVzID0gXyhkYXRhKS5jaGFpbigpLm1hcChmdW5jdGlvbihkYXR1bSkge1xuXHRcdHJldHVybiBkYXR1bS52YWx1ZXM7XG5cdH0pLnRyYW5zcG9zZSgpLnZhbHVlKCk7XG5cblx0dmFyIGh0bWwgPSB0YWJsZVRlbXBsYXRlKHtcblx0XHRrZXlzIDoga2V5cyxcblx0XHR2YWx1ZXMgOiB2YWx1ZXMsXG5cdFx0bW9uZXlGb3JtYXQgOiBvcHRpb25zLnNob3J0Rm9ybWF0dGVyXG5cdH0pO1xuXG5cdHZhciBjaGFydEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdGNoYXJ0RWwuaW5uZXJIVE1MID0gaHRtbDtcblxuXHRiaW5kQ2xpY2tIYW5kbGVyKGNoYXJ0RWwsIGRhdGEsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBjaGFydEVsO1xufVxuXG5mdW5jdGlvbiBoZWF0bWFwQ2hhcnRlcihkYXRhLCBvcHRpb25zKSB7XG5cdC8vIEZvciBBTVAtMjM1ODI6IHdlIGRvbnQgd2FudCB0aGUgbmFtZSBmcm9tIFwic3VtbWFyeVwiIGJlY2F1c2UgdGhhdHMgdGhlIG9yaWdOYW1lIGFuZCBub3QgYWx3YXlzIHRoZSBzYW1lIG5hbWUgdGhhbiB0aGUgWCBheGlzIGNvbWJvIHNlbGVjdG9yLiBcblx0dmFyIGZpcnN0Q29sdW1uTmFtZSA9IF8uZmluZChvcHRpb25zLm1vZGVsLmdldCgnaGVhdG1hcF9jb25maWcnKS5tb2RlbHNbMF0uZ2V0KCdjb2x1bW5zJyksIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS5vcmlnTmFtZSA9PT0gb3B0aW9ucy5tb2RlbC5nZXQoJ3N1bW1hcnknKVswXTtcblx0fSkubmFtZTsgXG5cdHZhciBzZWNvbmRDb2x1bW5OYW1lID0gXy5maW5kKG9wdGlvbnMubW9kZWwuZ2V0KCdoZWF0bWFwX2NvbmZpZycpLm1vZGVsc1swXS5nZXQoJ2NvbHVtbnMnKSwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLm9yaWdOYW1lID09PSBvcHRpb25zLm1vZGVsLmdldCgnc3VtbWFyeScpWzFdO1xuXHR9KS5uYW1lO1xuXHR2YXIga2V5cyA9IFtmaXJzdENvbHVtbk5hbWUsIFxuXHQgICAgICAgICAgICBzZWNvbmRDb2x1bW5OYW1lLCBcblx0ICAgICAgICAgICAgdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmRvd25sb2FkLWFtb3VudCcsICdBbW91bnQnKSwgXG5cdCAgICAgICAgICAgIHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpwZXJjZW50YWdlJywgJ1BlcmNlbnRhZ2UnKV07XG5cblx0dmFyIG1hdHJpeCA9IF8ubWFwKG9wdGlvbnMubW9kZWwuZ2V0KFwibWF0cml4XCIpLCBmdW5jdGlvbihpdGVtWSwgaSkge1xuXHRcdHJldHVybiBfLm1hcChpdGVtWSwgZnVuY3Rpb24oaXRlbVgsIGopIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHkgOiBvcHRpb25zLm1vZGVsLmdldChcInlEYXRhU2V0XCIpW2ldLFxuXHRcdFx0XHR4IDogb3B0aW9ucy5tb2RlbC5nZXQoXCJ4RGF0YVNldFwiKVtqXSxcblx0XHRcdFx0dmFsdWUgOiAob3B0aW9ucy5tb2RlbC5nZXQoXCJtYXRyaXhcIilbaV1bal0gPyBvcHRpb25zLm1vZGVsLmdldChcIm1hdHJpeFwiKVtpXVtqXSA6IHtcblx0XHRcdFx0XHQnZHYnIDogJycsXG5cdFx0XHRcdFx0J3AnIDogJydcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9KVxuXHR9KTtcblxuXHR2YXIgaHRtbCA9IGhlYXRtYXBUYWJsZVRlbXBsYXRlKHtcblx0XHRrZXlzIDoga2V5cyxcblx0XHRtYXRyaXggOiBtYXRyaXgsXG5cdFx0bW9uZXlGb3JtYXQgOiBvcHRpb25zLnNob3J0Rm9ybWF0dGVyXG5cdH0pO1xuXG5cdHZhciBjaGFydEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdGNoYXJ0RWwuaW5uZXJIVE1MID0gaHRtbDtcblx0XG5cdGJpbmRDbGlja0hhbmRsZXIoY2hhcnRFbCwgZGF0YSwgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGNoYXJ0RWw7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNoYXJ0ZXI6IGNoYXJ0ZXJcbn07IiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBkMyA9IHJlcXVpcmUoJ2QzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3VnbHkvdXRpbCcpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgYmFyU3BlY2lmaWMgPSByZXF1aXJlKCcuL19iYXInKTtcbnZhciBtdWx0aWJhclNwZWNpZmljID0gcmVxdWlyZSgnLi9fbXVsdGliYXInKTtcbnZhciBwaWVTcGVjaWZpYyA9IHJlcXVpcmUoJy4vX3BpZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi9fdGFibGUnKTtcbnZhciBoZWF0bWFwID0gcmVxdWlyZSgnLi9faGVhdG1hcCcpO1xudmFyIGRlZmF1bHRUVFRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLXByaW1hcnkgcGFuZWwtcG9wb3ZlclxcXCI+XFxuICA8JSBpZiAodHQuaGVhZGluZykgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj48JT0gdHQuaGVhZGluZyAlPjwvZGl2PlxcbiAgPCUgfSAlPlxcbiAgPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJkb2xsYXpcXFwiPlxcbiAgICAgIDwlIGlmICh0dC5ib2R5VGV4dCkgeyAlPlxcbiAgICAgICAgPCU9IHR0LmJvZHlUZXh0ICU+XFxuICAgICAgPCUgfSAlPlxcbiAgICAgIDwlIGlmICh0dC5ib2R5TGlzdCkgeyAlPlxcbiAgICAgICAgPHVsIGNsYXNzPVxcXCJsaXN0LXVuc3R5bGVkXFxcIj5cXG4gICAgICAgICAgPCUgXyh0dC5ib2R5TGlzdCkuZWFjaChmdW5jdGlvbihpdGVtKSB7ICU+XFxuICAgICAgICAgICAgPGxpPjxiPjwlPSBpdGVtLmsgJT48L2I+IDwlPSBpdGVtLnYgJT48L2xpPlxcbiAgICAgICAgICA8JSB9KSAlPlxcbiAgICAgICAgPC91bD5cXG4gICAgICA8JSB9ICU+XFxuICAgIDwvc3Bhbj5cXG4gIDwvZGl2PlxcbiAgPCUgaWYgKHR0LmZvb3RlclRleHQpIHsgJT5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtZm9vdGVyXFxcIj5cXG4gICAgICA8JT0gdHQuZm9vdGVyVGV4dCAlPlxcbiAgICA8L2Rpdj5cXG4gIDwlIH0gJT5cXG48L2Rpdj5cXG5cIik7XG5cblxudmFyIGNoYXJ0ZXJzID0ge1xuICBiYXI6IGNvbW1vbi5udkNoYXJ0ZXIoYmFyU3BlY2lmaWMpLFxuICBwaWU6IGNvbW1vbi5udkNoYXJ0ZXIocGllU3BlY2lmaWMpLFxuICBtdWx0aWJhcjogY29tbW9uLm52Q2hhcnRlcihtdWx0aWJhclNwZWNpZmljKSxcbiAgaGVhdG1hcDogY29tbW9uLm52Q2hhcnRlcihoZWF0bWFwKSxcbiAgdGFibGU6IHRhYmxlLmNoYXJ0ZXJcbn07XG5cblxuZnVuY3Rpb24gY2hhcnQodHlwZSwgZGF0YSwgb3B0aW9ucykge1xuICAvKlxuICAgKiBAcGFyYW0gdHlwZTogJ2JhcicgKGRlZmF1bHQpLCAncGllJywgb3IgJ211bHRpYmFyJ1xuICAgKiBAcGFyYW0gZGF0YTogW3trZXk6ICdzZXJpc05hbWUnLCB2YWx1ZXM6IFt7eDpOTiwgeTpOTn1dfV1cbiAgICogQHBhcmFtIG9wdGlvbnM6IG9wdGlvbmFsIGV4dHJhIHN0dWZmXG4gICAqL1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHNldHRpbmdzIGRlZmF1bHRzXG4gIG9wdGlvbnMgPSBfKF8ob3B0aW9ucykuY2xvbmUoKSkuZGVmYXVsdHMoe1xuICAgIGhlaWdodDogdm9pZCAwLCAgLy8gc2hvdWxkIGZpbGwgY29udGFpbmVyIGluIG1vc3QgY2FzZXMgYnkgZGVmYXVsdFxuICAgIHdpZHRoOiB2b2lkIDAsXG4gICAgbnVtYmVyRm9ybWF0dGVyOiBkMy5mb3JtYXQoJywnKSxcbiAgICBzaG9ydEZvcm1hdHRlcjogb3B0aW9ucy5udW1iZXJGb3JtYXR0ZXIgfHwgdXRpbC5mb3JtYXRLTUIoMywgYXBwLnNldHRpbmdzLm51bWJlckZvcm1hdFNldHRpbmdzLmRlY2ltYWxTZXBhcmF0b3IpLFxuICAgIGFkZExlZ2VuZDogdHJ1ZSxcbiAgICB0cmltTGFiZWxzOiB0cnVlLFxuICAgIGdldFRUQ29udGVudDogY29tbW9uLmRlZmF1bHRHZXRUVENvbnRlbnQsXG4gICAgdHRUZW1wbGF0ZTogZGVmYXVsdFRUVGVtcGxhdGUsXG4gICAgY2xpY2tIYW5kbGVyOiBjb21tb24uZGVmYXVsdENsaWNrSGFuZGxlcixcbiAgICBudkNvbnRyb2xzOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBjaGFydGVyID0gY2hhcnRlcnNbdHlwZV0gfHwgY29tbW9uLmZhaWwoJ3VucmVjb2duaXplZCBjaGFydCB0eXBlJywgdHlwZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBlbDogY2hhcnRlcihkYXRhLCBvcHRpb25zKVxuICB9O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY2hhcnQ7XG4iLCJ2YXIgbnYgPSB3aW5kb3cubnY7ICAvLyBudmQzIGlzIGEgcGFpblxudmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdWdseS91dGlsJyk7XG52YXIgTnVtZXJhbCA9IHJlcXVpcmUoJ251bWVyYWwnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5cbi8vIGhhY2sgbnZkMydzIGNhbGNBcHByb3hUZXh0V2lkdGggYmVjYXVzZSBpdCBpcyB0ZXJycnJycnJycnJpYmxlXG4vLyB0aGlzIHNvbHV0aW9uIGlzIGp1c3QgYXMgYmFkIDooXG4vLyBudmQzIG1ha2VzIG1lIHNvIHNhZCA6KFxuKGZ1bmN0aW9uKHVuZm9ydHVuYXRlTGliKSB7XG4gIHZhciBzYWRXYXlPZkNhbGN1bGF0aW5nVGV4dFdpZHRoID0gdW5mb3J0dW5hdGVMaWIudXRpbHMuY2FsY0FwcHJveFRleHRXaWR0aDtcbiAgdW5mb3J0dW5hdGVMaWIudXRpbHMuY2FsY0FwcHJveFRleHRXaWR0aCA9IGZ1bmN0aW9uKHN2Z1RleHRFbCkge1xuICAgIHZhciBvcmlnaW5hbFRleHQgPSBzdmdUZXh0RWwudGV4dCgpLFxuICAgICAgICBzcGFjZVBhZGRlZFRleHQgPSBvcmlnaW5hbFRleHQsXG4gICAgICAgIG51bWJlck9mRG90cyA9IChvcmlnaW5hbFRleHQubWF0Y2goL1xcLi9nKSB8fCBbXSkubGVuZ3RoLFxuICAgICAgICBwb29ybHlDYWxjdWxhdGVkV2lkdGg7XG5cbiAgICBpZiAob3JpZ2luYWxUZXh0LnRvVXBwZXJDYXNlKCkgPT09IG9yaWdpbmFsVGV4dCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmlnaW5hbFRleHQubGVuZ3RoIC8gNTsgaSsrKSB7IHNwYWNlUGFkZGVkVGV4dCArPSAnICc7IH1cbiAgICAgIHN2Z1RleHRFbC50ZXh0KHNwYWNlUGFkZGVkVGV4dCk7XG4gICAgICBwb29ybHlDYWxjdWxhdGVkV2lkdGggPSBzYWRXYXlPZkNhbGN1bGF0aW5nVGV4dFdpZHRoKHN2Z1RleHRFbCk7XG4gICAgICBzdmdUZXh0RWwudGV4dChvcmlnaW5hbFRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb29ybHlDYWxjdWxhdGVkV2lkdGggPSBzYWRXYXlPZkNhbGN1bGF0aW5nVGV4dFdpZHRoKHN2Z1RleHRFbCk7XG4gICAgfVxuXG4gICAgLy8g4pmqIGRvIHlvdSBiZWxpZXZlIGluIG1hYWFhZ2ljIOKZq1xuICAgIHBvb3JseUNhbGN1bGF0ZWRXaWR0aCAtPVxuICAgICAgKHBvb3JseUNhbGN1bGF0ZWRXaWR0aCAvIHNwYWNlUGFkZGVkVGV4dC5sZW5ndGgpICogKG51bWJlck9mRG90cyAvIDMpO1xuICAgIC8vIOKZqiBtYWdpYyBtYWdpYyBtYWdpYyDimatcbiAgICBwb29ybHlDYWxjdWxhdGVkV2lkdGggKz0gNjtcblxuICAgIHJldHVybiBwb29ybHlDYWxjdWxhdGVkV2lkdGg7XG4gIH07XG59KShudik7XG5cblxuZnVuY3Rpb24gZmFpbCgvKiBhcmd1bWVudHMgKi8pIHtcbiAgdGhyb3cge1xuICAgIG5hbWU6ICdDaGFydCBFcnJvcicsXG4gICAgbWVzc2FnZTogQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcsICcpLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubmFtZSArICc6ICcgKyB0aGlzLm1lc3NhZ2U7IH1cbiAgfTtcbn1cblxuXG5mdW5jdGlvbiBudkNoYXJ0Q29tbW9uKG52Q2hhcnQsIG1heENhdGVnb3JpZXMpIHtcbiAgcmV0dXJuIG52Q2hhcnRcbiAgICAueChmdW5jdGlvbihkKSB7IHJldHVybiB1dGlsLmZvcm1hdFNob3J0VGV4dCgxOSkoZC54KTsgfSkgIC8vIGZpeCBvdmVyZmxvd3MgaW4gbGVnZW5kc1xuICAgIC5jb2xvcih1dGlsLmNhdGVnb3J5Q29sb3VycyhtYXhDYXRlZ29yaWVzKSk7XG59XG5cblxuZnVuY3Rpb24gZ2V0U2VjcmV0UmVuZGVyQXJlYShoZWlnaHQsIHdpZHRoKSB7XG4gIHZhciBzZWNyZXRBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N1cGVyLXNlY3JldC1yZW5kZXItYXJlYS1zaGgnKTtcbiAgaWYgKCFzZWNyZXRBcmVhKSB7XG4gICAgc2VjcmV0QXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNlY3JldEFyZWEuaWQgPSAnc3VwZXItc2VjcmV0LXJlbmRlci1hcmVhLXNoaCc7XG4gICAgc2VjcmV0QXJlYS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgc2VjcmV0QXJlYS5zdHlsZS5sZWZ0ID0gJy05OTk5ZW0nO1xuICAgIHNlY3JldEFyZWEuc3R5bGUudG9wID0gJy05OTk5ZW0nOyAgLy8gZm9yIElFIDooXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzZWNyZXRBcmVhKTtcbiAgfVxuICBpZiAoaGVpZ2h0KSB7IHNlY3JldEFyZWEuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JzsgfVxuICBpZiAod2lkdGgpIHsgc2VjcmV0QXJlYS5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JzsgfVxuICByZXR1cm4gc2VjcmV0QXJlYTtcbn1cblxuXG5mdW5jdGlvbiBta0NoYXJ0U1ZHKGhlaWdodCwgd2lkdGgpIHtcbiAgdmFyIHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2Rhc2gtY2hhcnQnKTtcbiAgLy8gcHV0IGl0IGluIHRoZSBkb20gYnV0IG91dCBvZiB0aGUgd2F5LCBzbyB3ZSBjYW4gY29tcHV0ZSBzdHlsZXMgbiBzdHVmZlxuICBnZXRTZWNyZXRSZW5kZXJBcmVhKGhlaWdodCwgd2lkdGgpLmFwcGVuZENoaWxkKHN2Zyk7XG4gIHJldHVybiBzdmc7XG59XG5cblxuZnVuY3Rpb24gbnZCb2lsZXIobnZEYXRhLCBjaGFydCwgc3ZnLCBzcGVjaWZpYywgdHJpbUxhYmVscywgYWRkTGVnZW5kLCB3aWR0aCkge1xuICBpZiAodHJpbUxhYmVscykge1xuICAgIGNoYXJ0LngoZnVuY3Rpb24oZCkgeyByZXR1cm4gdXRpbC5mb3JtYXRTaG9ydFRleHQoNTApKGQueCk7IH0pO1xuICB9XG4gIGlmIChhZGRMZWdlbmQgJiYgc3BlY2lmaWMuYWRkTGVnZW5kKSB7XG4gICAgc3BlY2lmaWMuYWRkTGVnZW5kKHN2ZywgY2hhcnQsIG52RGF0YSwgdHJpbUxhYmVscywgd2lkdGgpO1xuICB9IGVsc2UgaWYgKCFhZGRMZWdlbmQgJiYgc3BlY2lmaWMucmVtb3ZlTGVnZW5kKSB7XG4gICAgc3BlY2lmaWMucmVtb3ZlTGVnZW5kKGNoYXJ0KTtcbiAgfVxuICBkMy5zZWxlY3Qoc3ZnKVxuICAgIC5kYXR1bShudkRhdGEpXG4gICAgLmNhbGwoY2hhcnQpO1xuICBudi51dGlscy53aW5kb3dSZXNpemUoY2hhcnQudXBkYXRlKTsgIC8vIHV1dXV1Z3VnZ2dnaFxuICBudi5hZGRHcmFwaChmdW5jdGlvbigpIHsgcmV0dXJuIGNoYXJ0OyB9KTsgIC8vIHV1dXV1Z2x5IGlzIG52ZDNcbiAgcmV0dXJuIHN2Zztcbn1cblxuXG5mdW5jdGlvbiBudkNvbG9yaWZ5Q2F0ZWdvcmllcyhjaGFydCwgZGF0YSwgc3BlY2lmaWMpIHtcbiAgdmFyIG51bWJlck9mQ2F0ZWdvcmllcyA9IHNwZWNpZmljLmNvdW50Q2F0ZWdvcmllcyhkYXRhKTtcbiAgY2hhcnQuY29sb3IodXRpbC5jYXRlZ29yeUNvbG91cnMobnVtYmVyT2ZDYXRlZ29yaWVzKSk7XG4gIHJldHVybiBjaGFydDtcbn1cblxuXG5mdW5jdGlvbiBkZWZhdWx0R2V0VFRDb250ZW50KGNvbnRleHQpIHtcbiAgcmV0dXJuIHt0dDoge1xuICAgIGhlYWRpbmc6IGNvbnRleHQueC5yYXcsXG4gICAgYm9keVRleHQ6IGNvbnRleHQueS5yYXcsXG4gICAgZm9ybWF0dGVkQW1vdW50OiBjb250ZXh0LnoucmF3XG4gIH19O1xufVxuXG5cbmZ1bmN0aW9uIGdldE5pY2VDb250ZXh0KHJhdywgZGF0YSwgZm10WSkge1xuICB2YXIgc2VyaWVzSW5kZXggPSByYXcuc2VyaWVzSW5kZXggfHwgMDtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIHNlcmllczoge1xuICAgICAga2V5OiBkYXRhW3Nlcmllc0luZGV4XS5rZXksXG4gICAgICBpbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICB2YWx1ZXM6IGRhdGFbc2VyaWVzSW5kZXhdLnZhbHVlc1xuICAgIH0sXG4gICAgeDoge1xuICAgICAgcmF3OiByYXcucG9pbnQueCxcbiAgICAgIGZtdDogcmF3LmxhYmVsLFxuICAgICAgaW5kZXg6IHJhdy5wb2ludEluZGV4IHx8IHJhdy5pbmRleCB8fCAwXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICByYXc6IHJhdy5wb2ludC55LFxuICAgICAgZm10OiByYXcucG9pbnQueiB8fCBmbXRZXG4gICAgfVxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIG52QmluZFRvb2x0aXAoY2hhcnQsIGRhdGEsIHNwZWNpZmljLCB0ZW1wbGF0ZSwgZ2V0VFRDb250ZW50KSB7XG4gIHZhciBudlRUSGFuZGxlciA9IGZ1bmN0aW9uKHNlcmllc05hbWUsIGZtdFgsIGZtdFksIHJhdykge1xuICAgIHJldHVybiB0ZW1wbGF0ZShnZXRUVENvbnRlbnQoZ2V0TmljZUNvbnRleHQocmF3LCBkYXRhLCBmbXRZKSkpO1xuICB9O1xuXG4gIGlmIChzcGVjaWZpYy5ub3JtYWxpemVOdlRUQXJncykgeyAvLyB3ZSBtaWdodCBoYXZlIHRvIGZpeCBudidzIGluY29uc2lzdGVudCBUVCBhcmdzXG4gICAgbnZUVEhhbmRsZXIgPSB1dGlsLnRyYW5zZm9ybUFyZ3Moc3BlY2lmaWMubm9ybWFsaXplTnZUVEFyZ3MsIG52VFRIYW5kbGVyKTtcbiAgfVxuICBjaGFydC50b29sdGlwQ29udGVudChudlRUSGFuZGxlcik7XG59XG5cblxuZnVuY3Rpb24gZGVmYXVsdENsaWNrSGFuZGxlcigvKiBjb250ZXh0ICovKSB7XG4gIC8vIGRvZXMgbm90aGluZ1xufVxuXG5cbmZ1bmN0aW9uIG52QmluZE90aGVyc0NiKGNoYXJ0LCBkYXRhLCBzcGVjaWZpYywgY2xpY2tIYW5kbGVyKSB7XG4gIGlmIChjaGFydFtzcGVjaWZpYy5kaXNwYXRjaE5hbWVdICE9PSB1bmRlZmluZWQpIHtcblx0ICBjaGFydFtzcGVjaWZpYy5kaXNwYXRjaE5hbWVdLmRpc3BhdGNoLm9uKCdlbGVtZW50Q2xpY2snLCBmdW5jdGlvbihyYXcpIHtcblx0XHQgIGNsaWNrSGFuZGxlcihnZXROaWNlQ29udGV4dChyYXcsIGRhdGEpKTtcblx0ICB9KTtcbiAgfVx0ZWxzZSB7XG5cdCAgY29uc29sZS53YXJuKFwiQ2FudCBmaW5kIFwiICsgc3BlY2lmaWMuZGlzcGF0Y2hOYW1lKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIG52Q2hhcnRlcihzcGVjaWZpYykge1xuICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciBzdmcgPSBta0NoYXJ0U1ZHKG9wdGlvbnMuaGVpZ2h0LCBvcHRpb25zLndpZHRoKSxcbiAgICAgICAgbnZDaGFydCA9IHNwZWNpZmljLmNoYXJ0KG9wdGlvbnMsIGRhdGEpLFxuICAgICAgICBudkRhdGEgPSBzcGVjaWZpYy5kYXRhVG9OdihkYXRhKTtcbiAgICBudkNvbG9yaWZ5Q2F0ZWdvcmllcyhudkNoYXJ0LCBkYXRhLCBzcGVjaWZpYyk7XG4gICAgbnZCaW5kVG9vbHRpcChudkNoYXJ0LCBkYXRhLCBzcGVjaWZpYywgb3B0aW9ucy50dFRlbXBsYXRlLCBvcHRpb25zLmdldFRUQ29udGVudCk7XG4gICAgbnZCb2lsZXIobnZEYXRhLCBudkNoYXJ0LCBzdmcsIHNwZWNpZmljLCBvcHRpb25zLnRyaW1MYWJlbHMsIG9wdGlvbnMuYWRkTGVnZW5kLCBvcHRpb25zLndpZHRoKTtcbiAgICBudkJpbmRPdGhlcnNDYihudkNoYXJ0LCBkYXRhLCBzcGVjaWZpYywgb3B0aW9ucy5jbGlja0hhbmRsZXIpO1xuICAgIHJldHVybiBzdmc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW1iZXIpIHtcblx0dmFyIGZvcm1hdCA9IFwiXCI7XG5cdGlmIChhcHAuc2V0dGluZ3MubnVtYmVyRm9ybWF0U2V0dGluZ3MuZ3JvdXBTZXBhcmF0b3IubGVuZ3RoID4gMCkge1xuXHRcdGZvcm1hdCA9IFwiMCwwXCI7XG5cdH0gZWxzZSB7XG5cdFx0Zm9ybWF0ID0gXCIwXCI7XG5cdH1cblx0aWYgKGFwcC5zZXR0aW5ncy5udW1iZXJGb3JtYXRTZXR0aW5ncy5udW1iZXJGb3JtYXQuaW5kZXhPZignLicpID4gMCkge1xuXHRcdHZhciBkZWNpbWFsRGlnaXRzID0gYXBwLnNldHRpbmdzLm51bWJlckZvcm1hdFNldHRpbmdzLm51bWJlckZvcm1hdC5sZW5ndGhcblx0XHRcdC0gYXBwLnNldHRpbmdzLm51bWJlckZvcm1hdFNldHRpbmdzLm51bWJlckZvcm1hdC5pbmRleE9mKCcuJyk7XG5cdFx0Zm9ybWF0ID0gZm9ybWF0ICsgXCIuXCIgKyBuZXcgQXJyYXkoZGVjaW1hbERpZ2l0cykuam9pbihcIjBcIik7XG5cdH1cblxuXHQvLyBEZWZpbmUgYSBuZXcgXCJsYW5ndWFnZVwiIGZvciBOdW1lcmFsIHdoZXJlIHdlIGNhbiBjaGFuZ2UgdGhlIGRlZmF1bHRcblx0Ly8gZGVsaW1pdGVycy5cblx0dmFyIGFtcExhbmcgPSB7XG5cdFx0ZGVsaW1pdGVycyA6IHtcblx0XHRcdHRob3VzYW5kcyA6IGFwcC5zZXR0aW5ncy5udW1iZXJGb3JtYXRTZXR0aW5ncy5ncm91cFNlcGFyYXRvcixcblx0XHRcdGRlY2ltYWwgOiBhcHAuc2V0dGluZ3MubnVtYmVyRm9ybWF0U2V0dGluZ3MuZGVjaW1hbFNlcGFyYXRvclxuXHRcdH0sXG5cdFx0YWJicmV2aWF0aW9ucyA6IHtcblx0XHRcdHRob3VzYW5kIDogYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC10aG91c2FuZCcpLFxuXHRcdFx0bWlsbGlvbiA6IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtbWlsbGlvbicpLFxuXHRcdFx0YmlsbGlvbiA6IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtYmlsbGlvbicpLFxuXHRcdFx0dHJpbGxpb24gOiBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmNoYXJ0LXRyaWxsaW9uJylcblx0XHR9LFxuXHRcdG9yZGluYWwgOiBmdW5jdGlvbihudW1iZXIpIHtcblx0XHRcdHJldHVybiBudW1iZXIgPT09IDEgPyAnc3QnIDogJ3Jkcyc7XG5cdFx0fSxcblx0XHRjdXJyZW5jeSA6IHtcblx0XHRcdHN5bWJvbCA6ICckJ1xuXHRcdH1cblx0fTtcblx0TnVtZXJhbC5sYW5ndWFnZSgnYW1wJywgYW1wTGFuZyk7XG5cdC8vIEFwcGx5IG5ldyBsYW5ndWFnZS5cblx0TnVtZXJhbC5sYW5ndWFnZSgnYW1wJyk7XG5cdC8vIEFwcGx5IHRoZSBmb3JtYXQuXG5cdHZhciBzdHJpbmdOdW1iZXIgPSBuZXcgTnVtZXJhbChudW1iZXIpLmZvcm1hdChmb3JtYXQpO1xuXHRyZXR1cm4gc3RyaW5nTnVtYmVyO1xufVxuXG52YXIgYW1wTGFuZyA9XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZhaWw6IGZhaWwsXG4gIG52Q2hhcnRDb21tb246IG52Q2hhcnRDb21tb24sXG4gIGdldE5pY2VDb250ZXh0OiBnZXROaWNlQ29udGV4dCxcbiAgZGVmYXVsdEdldFRUQ29udGVudDogZGVmYXVsdEdldFRUQ29udGVudCxcbiAgZGVmYXVsdENsaWNrSGFuZGxlcjogZGVmYXVsdENsaWNrSGFuZGxlcixcbiAgbWtDaGFydFNWRzogbWtDaGFydFNWRyxcbiAgbnZCb2lsZXI6IG52Qm9pbGVyLFxuICBudkNoYXJ0ZXI6IG52Q2hhcnRlcixcbiAgZm9ybWF0TnVtYmVyOiBmb3JtYXROdW1iZXJcbn07XG4iLCJudi5tb2RlbHMuaGVhdG1hcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxyXG4gICAgICAgICwgd2lkdGggPSA1MDBcclxuICAgICAgICAsIGhlaWdodCA9IDUwMFxyXG4gICAgICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9XHJcbiAgICAgICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cclxuICAgICAgICAsIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApIC8vQ3JlYXRlIHNlbWktdW5pcXVlIElEIGluIGNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcclxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXHJcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdjaGFydENsaWNrJywgJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsQ2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnLCAncmVuZGVyRW5kJylcclxuICAgICAgICA7XHJcblxyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBjaGFydCBmdW5jdGlvblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XHJcblxyXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcclxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2hlYXRtYXAgaW1tZWRpYXRlJyk7XHJcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xyXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xyXG5cclxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xyXG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcclxuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXHJcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXHJcbiAgICAgICAgeDogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFg9Xzt9fSxcclxuICAgICAgICBpZDogICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2lkPV87fX0sXHJcblxyXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xyXG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xyXG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gdHlwZW9mIF8ucmlnaHQgICE9ICd1bmRlZmluZWQnID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XHJcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XHJcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xyXG4gICAgICAgIH19LFxyXG4gICAgICAgIHk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtcclxuICAgICAgICAgICAgZ2V0WT1kMy5mdW5jdG9yKF8pO1xyXG4gICAgICAgIH19XHJcbiAgICB9KTtcclxuXHJcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbn07XHJcblxyXG5udi5tb2RlbHMuaGVhdE1hcENoYXJ0ID0gZnVuY3Rpb24oKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cdC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cdFxyXG5cclxuICAgIHZhciBoZWF0bWFwID0gbnYubW9kZWxzLmhlYXRtYXAoKTtcclxuXHJcbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiAyMCwgbGVmdDogMjB9XHJcbiAgICB2YXIgd2lkdGggPSBudWxsO1xyXG5cdHZhciBoZWlnaHQgPSBudWxsO1xyXG4gICAgdmFyIHNob3dMZWdlbmQgPSBmYWxzZTtcclxuICAgIHZhciBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpO1xyXG4gICAgdmFyXHRzdGF0ZSA9IG52LnV0aWxzLnN0YXRlKCk7XHJcbiAgICB2YXIgZGVmYXVsdFN0YXRlID0gbnVsbDtcclxuICAgIHZhciBub0RhdGEgPSBcIk5vIERhdGEgQXZhaWxhYmxlLlwiO1xyXG4gICAgdmFyIGR1cmF0aW9uID0gMjUwO1xyXG4gICAgdmFyIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJywncmVuZGVyRW5kJyk7XHJcbiAgICB2YXIgc2hvcnRUZXh0TGVuZ3RoID0gMTc7XHJcbiAgICB2YXIgaW5uZXJNYXJnaW4gPSB7XHJcbiAgICBcdFx0dG9wIDogMTIwLFxyXG5cdFx0XHRyaWdodCA6IDAsXHJcblx0XHRcdGJvdHRvbSA6IDEwMCxcclxuXHRcdFx0bGVmdCA6IDE1MFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uc3QgaW5pdGlhbFdpZHRoID0gOTYwO1xyXG4gICAgY29uc3QgaW5pdGlhbEhlaWdodCA9IDQwMDtcclxuICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gMTAyNDtcclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XHJcblxyXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgXHRyZXR1cm4gZnVuY3Rpb24oKXtcclxuICAgIFx0XHRyZXR1cm4ge1xyXG4gICAgXHRcdFx0YWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN0YXRlU2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoc2VyaWVzLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gIXN0YXRlLmFjdGl2ZVtpXTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICBcclxuICAgIHZhciBzaG9ydGVuVGV4dCA9IGZ1bmN0aW9uKHRleHQsIGxlbmd0aCkge1xyXG4gICAgXHRpZiAodGV4dC5sZW5ndGggPiBsZW5ndGgpIHtcclxuICAgIFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgbGVuZ3RoKSArICcuLi4nO1xyXG4gICAgXHR9XHJcbiAgICBcdHJldHVybiB0ZXh0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gQ2hhcnQgZnVuY3Rpb25cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XHJcbiAgICBcdHZhciBfc2VsZiA9IHRoaXM7XHJcbiAgICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcclxuICAgIFx0dmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7IC8vIFRoaXMgZG9lc250IHdvcmtzIG9uIHRvcCBvZiB0aGUgZmlsZSA6KCgoXHJcblxyXG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XHJcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKGhlYXRtYXApO1xyXG5cclxuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgXHQvLyBHZXQgY3VycmVuY3kgZm9yIGxhdGVyLlxyXG4gICAgICAgIFx0dmFyIGN1cnJlbmN5U2V0dGluZ3MgPSBfLmZpbmQoYXBwLnNldHRpbmdzLm1vZGVscywgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLmdldCgnaWQnKSA9PT0gJzEnfSk7XHJcbiAgICAgICAgXHR2YXIgc2VsZWN0ZWRDdXJyZW5jeSA9IF8uZmluZChjdXJyZW5jeVNldHRpbmdzLmdldCgnb3B0aW9ucycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0uc2VsZWN0ZWQgPT09IHRydWV9KS52YWx1ZTtcclxuICAgICAgICBcdHZhciBuZXdTaG9ydFRleHRMZW5ndGggPSAhZGF0YVswXS52YWx1ZXMubW9kZWwuZ2V0KCdzaG93RnVsbExlZ2VuZHMnKSA/IHNob3J0VGV4dExlbmd0aCA6IDEwMDtcclxuICAgICAgICBcdFxyXG4gICAgICAgIFx0dmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcclxuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSwgMTApIHx8IGluaXRpYWxXaWR0aClcclxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpLCAxMCkgfHwgaW5pdGlhbEhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xyXG5cclxuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHN0YXRlLnNldHRlcihzdGF0ZVNldHRlcihkYXRhKSwgY2hhcnQudXBkYXRlKVxyXG4gICAgICAgICAgICAgICAgLmdldHRlcihzdGF0ZUdldHRlcihkYXRhKSlcclxuICAgICAgICAgICAgICAgIC51cGRhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vc2V0IHN0YXRlLmRpc2FibGVkXHJcbiAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcclxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlW2tleV0gaW5zdGFuY2VvZiBBcnJheSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIFx0dmFyIGN1YmVTaXplID0gMzA7XHJcbiAgICAgICAgXHR2YXIgd2lkdGggPSBjb250YWluZXJXaWR0aCAtIGlubmVyTWFyZ2luLmxlZnQgLSBpbm5lck1hcmdpbi5yaWdodDtcclxuICAgICAgICBcdHZhciB0b3BTZWN0aW9uSGVpZ2h0ID0gMTgwO1xyXG4gICAgICAgIFx0dmFyIGxlZ2VuZFNlY3Rpb25IZWlnaHQgPSAyMDtcclxuICAgICAgICBcdHZhciBoZWlnaHQgPSB0b3BTZWN0aW9uSGVpZ2h0ICsgKGN1YmVTaXplICogZGF0YVswXS52YWx1ZXMueS5sZW5ndGgpICsgbGVnZW5kU2VjdGlvbkhlaWdodDtcclxuICAgICAgICBcdHZhciBsZWdlbmRFbGVtZW50SGVpZ2h0ID0gMjI7XHJcbiAgICAgICAgXHRjb25zdCBub0NvbG9yID0gJyNGRkZGRkYnO1xyXG4gICAgICAgIFx0dmFyIGNhdGVnb3JpZXMgPSBnZXRDYXRlZ29yaWVzQnlUaHJlc2hvbGQobm9Db2xvciwgZGF0YVswXS52YWx1ZXMubW9kZWwpO1xyXG4gICAgICAgIFx0XHJcbiAgICAgICAgXHQkKGNvbnRhaW5lclswXSkuY3NzKCdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKS5hdHRyKCdjbGFzcycsICdkYXNoLWNoYXJ0IG52ZDMtc3ZnIGhlYXRtYXAtY2hhcnQnKTtcclxuICAgICAgICBcdFxyXG4gICAgICAgIFx0dmFyIHN2ZyA9IGNvbnRhaW5lclxyXG4gICAgICAgIFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG4gICAgICAgIFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGlubmVyTWFyZ2luLmxlZnQgKyBcIixcIiArIGlubmVyTWFyZ2luLnRvcCArIFwiKVwiKVxyXG4gICAgICAgIFx0XHQuYXR0cihcImNsYXNzXCIsIFwiaGVhdG1hcC1tYWluLWNvbnRhaW5lclwiKTtcclxuICAgICAgICBcdFxyXG4gICAgICAgIFx0Ly8gQWRkIFNWRyBmaWx0ZXIgZm9yIGNlbGwgaGlnaGxpZ2h0LlxyXG4gICAgICAgIFx0Ly8gRm9yIG1vcmUgaW5mbyBhYm91dCB0aGVzZSBmaWx0ZXJzIHNlZTogaHR0cDovL3d3dy5zdmdiYXNpY3MuY29tL2ZpbHRlcnM0Lmh0bWwgLy8gaHR0cDovL2FwaWtlLmNhL3Byb2dfc3ZnX2ZpbHRlcl9mZUNvbG9yTWF0cml4Lmh0bWwgLy8gaHR0cDovL2FsaXN0YXBhcnQuY29tL2FydGljbGUvZmluZXNzaW5nLWZlY29sb3JtYXRyaXhcclxuICAgICAgICBcdHN2Zy5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcImZpbHRlclwiKS5hdHRyKFwiaWRcIiwgXCJmaWx0ZXJTYXR1cmF0ZVwiKS5hcHBlbmQoXCJmZUNvbG9yTWF0cml4XCIpLmF0dHIoXCJpblwiLCBcIlNvdXJjZUdyYXBoaWNcIikuYXR0cihcInR5cGVcIiwgXCJzYXR1cmF0ZVwiKS5hdHRyKFwidmFsdWVzXCIsIFwiNVwiKTtcclxuICAgICAgICBcdHN2Zy5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcImZpbHRlclwiKS5hdHRyKFwiaWRcIiwgXCJmaWx0ZXJMdW1pbmFuY2VUb0FscGhhXCIpLmFwcGVuZChcImZlQ29sb3JNYXRyaXhcIikuYXR0cihcImluXCIsIFwiU291cmNlR3JhcGhpY1wiKS5hdHRyKFwidHlwZVwiLCBcImx1bWluYW5jZVRvQWxwaGFcIik7XHJcbiAgICAgICAgXHRzdmcuYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJmaWx0ZXJcIikuYXR0cihcImlkXCIsIFwiZmlsdGVyQmx1clwiKS5hcHBlbmQoXCJmZUdhdXNzaWFuQmx1clwiKS5hdHRyKFwiaW5cIiwgXCJTb3VyY2VHcmFwaGljXCIpLmF0dHIoXCJzdGREZXZpYXRpb25cIiwgXCIyXCIpO1xyXG4gICAgICAgIFx0c3ZnLmFwcGVuZChcImRlZnNcIikuYXBwZW5kKFwiZmlsdGVyXCIpLmF0dHIoXCJpZFwiLCBcImZpbHRlckRhcmtlblwiKS5hcHBlbmQoXCJmZUNvbG9yTWF0cml4XCIpLmF0dHIoXCJ0eXBlXCIsIFwibWF0cml4XCIpLmF0dHIoXCJ2YWx1ZXNcIiwgXCIwLjUgMCAwIDAgMCAwIDAuNSAwIDAgMCAwIDAgMC41IDAgMCAwIDAgMCAxIDBcIik7XHJcblxyXG4gICAgICAgIFx0Ly8gUm93cyBjb250YWluZXIuXHJcbiAgICAgICAgXHR2YXIgeUF4aXNMYWJlbHNDb250YWluZXIgPSBzdmcgICAgICAgIFx0XHJcblx0XHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwiaGVhdG1hcC15QXhpcy1jb250YWluZXJcIik7XHJcbiAgICAgICAgXHRcclxuICAgICAgICBcdC8vIFJvd3MuXHJcbiAgICAgICAgXHR2YXIgeUF4aXNMYWJlbHMgPSB5QXhpc0xhYmVsc0NvbnRhaW5lclxyXG4gICAgICAgIFx0XHQuc2VsZWN0QWxsKFwiLnlMYWJlbFwiKVxyXG4gICAgICAgIFx0XHQuZGF0YShkYXRhWzBdLnZhbHVlcy55KVxyXG4gICAgICAgIFx0XHQuZW50ZXIoKVxyXG4gICAgICAgIFx0XHQuYXBwZW5kKFwidGV4dFwiKVxyXG4gICAgICAgIFx0XHQudGV4dChmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgXHRcdFx0cmV0dXJuIHNob3J0ZW5UZXh0KGQsIG5ld1Nob3J0VGV4dExlbmd0aCk7XHJcbiAgICAgICAgXHRcdH0pXHJcbiAgICAgICAgXHRcdC5hdHRyKFwieFwiLCAwKVxyXG4gICAgICAgIFx0XHQuYXR0cihcInlcIiwgZnVuY3Rpb24oZCwgaSkge1xyXG4gICAgICAgIFx0XHRcdHJldHVybiBpICogY3ViZVNpemU7XHJcbiAgICAgICAgXHRcdH0pXHJcbiAgICAgICAgXHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXHJcbiAgICAgICAgXHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKC02LFwiICsgY3ViZVNpemUgLyAxLjUgKyBcIilcIilcclxuICAgICAgICBcdFx0LmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihkLCBpKSB7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJ5TGFiZWwgbW9ubyBheGlzIG52LXNlcmllc1wiO1xyXG4gICAgICAgIFx0XHR9KVxyXG4gICAgICAgIFx0XHQuYXR0cignZGF0YS10aXRsZScsIGZ1bmN0aW9uKGQpIHtcclxuICAgICAgICBcdFx0XHRyZXR1cm4gZDtcclxuICAgICAgICBcdFx0fSk7XHJcbiAgICAgICAgXHRcclxuICAgICAgICBcdFx0Ly8gRm9ybWF0IFwiT3RoZXJzXCIgc3BlY2lhbCByb3cgaWYgbmVlZGVkLlxyXG4gICAgICAgIFx0XHRpZiAoZGF0YVswXS52YWx1ZXMueUNvdW50IDwgZGF0YVswXS52YWx1ZXMueVRvdGFsQ291bnQpIHtcclxuICAgICAgICBcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgXHRcdFx0dmFyIGRhdGEyID0gZGF0YTtcclxuICAgICAgICBcdFx0XHR2YXIgdGV4dEVsZW1lbnQgPSAkKGNvbnRhaW5lclswXSkuZmluZCgnLnlMYWJlbCcpLmxhc3QoKTtcclxuICAgICAgICBcdFx0XHQkKHRleHRFbGVtZW50KS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCwgaSkge1xyXG4gICAgICAgIFx0XHRcdFx0cmV0dXJuICQodGV4dEVsZW1lbnQpLmF0dHIoJ2NsYXNzJykgKyAnIGxlZ2VuZC1vdGhlcnMnO1xyXG4gICAgICAgIFx0XHRcdH0pO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcclxuICAgICAgICBcdFx0Ly8gQWRkIFRvdGFscyBzcGVjaWFsIHJvdy5cclxuICAgICAgICBcdFx0eUF4aXNMYWJlbHNDb250YWluZXIuYXBwZW5kKFwidGV4dFwiKVxyXG4gICAgICAgIFx0XHRcdC50ZXh0KFwiVE9UQUxTXCIpXHJcbiAgICAgICAgXHRcdFx0LmF0dHIoXCJ4XCIsIDApXHJcbiAgICAgICAgXHRcdFx0LmF0dHIoXCJ5XCIsIChkYXRhWzBdLnZhbHVlcy55Lmxlbmd0aCAqIGN1YmVTaXplKSlcclxuICAgICAgICBcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwieUxhYmVsIG1vbm8gYXhpcyBudi1zZXJpZXMgaGVhdG1hcC10b3RhbHNcIilcclxuICAgICAgICBcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxyXG4gICAgICAgIFx0XHRcdC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxyXG4gICAgICAgICAgICBcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoLTYsXCIgKyBjdWJlU2l6ZSAvIDEuNSArIFwiKVwiKVxyXG4gICAgICAgICAgICBcdFx0LmF0dHIoJ2RhdGEtaTE4bicsICdhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtdG90YWxzJyk7XHJcblxyXG4gICAgICAgIFx0XHQvLyBDb2x1bW5zIGNvbnRhaW5lci5cclxuICAgICAgICBcdFx0dmFyIHhBeGlzTGFiZWxzQ29udGFpbmVyID0gc3ZnXHJcbiAgICAgICAgXHRcdFx0LmFwcGVuZChcImdcIilcclxuICAgICAgICBcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgxOC41LCAtNSlcIilcclxuICAgICAgICBcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwiaGVhdG1hcC14QXhpcy1jb250YWluZXJcIik7XHJcblxyXG4gICAgICAgIFx0XHQvLyBDb2x1bW5zXHJcbiAgICAgICAgXHRcdC8vIE5vdGljZSBpbiB0cmFuc2Zvcm0gZnVuY3Rpb25zIHRoZSBvcmRlciBpcyB2ZXJ5IGltcG9ydGFudCBpZiB5b3UgaGF2ZSB0byBhcHBseSBtb3JlIHRoYW4gb25lLCBsaWtlIHRyYW5zbGF0ZSBhbmQgcm90YXRlLlxyXG4gICAgICAgIFx0XHQvLyBjdWJlU2l6ZSBpcyB3aGVyZSB3ZSBkZWZpbmUgaG93IGJpZyBhcmUgdGhlIGN1YmVzIHNvIGlmIHdlIGNoYW5nZSBpdCBpbiB0aGUgZnV0dXJlIHRoZSBjaGFydCB3aWxsIHJlc2l6ZSBjb3JyZWN0bHkuXHJcbiAgICAgICAgXHRcdHZhciB4QXhpc0xhYmVscyA9IHhBeGlzTGFiZWxzQ29udGFpbmVyXHJcbiAgICAgICAgXHRcdFx0LnNlbGVjdEFsbChcIi54TGFiZWxcIilcclxuICAgICAgICBcdFx0XHQuZGF0YShkYXRhWzBdLnZhbHVlcy54KVxyXG4gICAgICAgIFx0XHRcdC5lbnRlcigpXHJcbiAgICAgICAgXHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuICAgICAgICBcdFx0XHQudGV4dChmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgXHRcdFx0XHRyZXR1cm4gc2hvcnRlblRleHQoZCwgbmV3U2hvcnRUZXh0TGVuZ3RoKTtcclxuICAgICAgICBcdFx0XHR9KVxyXG4gICAgICAgIFx0XHRcdC5hdHRyKFwieFwiLCBmdW5jdGlvbihkLCBpKSB7XHJcbiAgICAgICAgXHRcdFx0XHRyZXR1cm4gaSAqIGN1YmVTaXplO1xyXG4gICAgICAgIFx0XHRcdH0pXHJcbiAgICAgICAgXHRcdFx0LmF0dHIoXCJ5XCIsIDApXHJcbiAgICAgICAgXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkge1xyXG4gICAgICAgIFx0XHRcdFx0cmV0dXJuIFwicm90YXRlKDI3MCwgXCIgKyAoY3ViZVNpemUgKiBpKSArIFwiLCAwKVwiO1xyXG4gICAgICAgIFx0XHRcdH0pXHJcbiAgICAgICAgXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihkLCBpKSB7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJ4TGFiZWwgbW9ubyBheGlzIG52LXNlcmllc1wiO1xyXG4gICAgICAgIFx0XHRcdH0pXHJcbiAgICAgICAgXHRcdFx0LmF0dHIoJ2RhdGEtdGl0bGUnLCBmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgXHRcdFx0XHRyZXR1cm4gZDtcclxuICAgICAgICBcdFx0XHR9KTtcclxuICAgICAgICBcdFx0XHJcbiAgICAgICAgXHRcdC8vIEFkZCBUb3RhbHMgc3BlY2lhbCBjb2x1bW4uXHJcbiAgICAgICAgXHRcdHhBeGlzTGFiZWxzQ29udGFpbmVyLmFwcGVuZChcInRleHRcIilcclxuICAgICAgICBcdFx0XHQudGV4dChcIlRPVEFMU1wiKVxyXG4gICAgICAgIFx0XHRcdC5hdHRyKFwieFwiLCBjdWJlU2l6ZSAqIGRhdGFbMF0udmFsdWVzLngubGVuZ3RoKVxyXG4gICAgICAgIFx0XHRcdC5hdHRyKFwieVwiLCAwKVxyXG4gICAgICAgIFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJ4TGFiZWwgbW9ubyBheGlzIG52LXNlcmllcyBoZWF0bWFwLXRvdGFsc1wiKVxyXG4gICAgICAgIFx0XHRcdC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxyXG4gICAgICAgICAgICBcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkge1xyXG4gICAgICAgIFx0XHRcdFx0cmV0dXJuIFwicm90YXRlKDI3MCwgXCIgKyAoY3ViZVNpemUgKiBkYXRhWzBdLnZhbHVlcy54Lmxlbmd0aCkgKyBcIiwgMClcIjtcclxuICAgICAgICBcdFx0XHR9KVxyXG4gICAgICAgIFx0XHRcdC5hdHRyKCdkYXRhLWkxOG4nLCAnYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLXRvdGFscycpO1xyXG5cclxuICAgICAgICBcdFx0Ly8gQ3ViZXNcclxuICAgICAgICBcdFx0dmFyIGN1YmVzQ29udGFpbmVyID0gc3ZnXHJcbiAgICBcdFx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcbiAgICBcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJoZWF0bWFwLWN1YmVzLWNvbnRhaW5lclwiKTtcclxuICAgICAgICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhWzBdLnZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIFx0XHRcdGNyZWF0ZUN1YmUoY3ViZXNDb250YWluZXIsICQuZXh0ZW5kKGRhdGFbMF0udmFsdWVzW2ldLCB7dG9vbHRpcDogc2VsZWN0ZWRDdXJyZW5jeSArICcgJyArIGRhdGFbMF0udmFsdWVzW2ldLmFtb3VudH0pLCBjdWJlU2l6ZSwgbm9Db2xvciwgY2F0ZWdvcmllcyk7ICAgICAgICBcdFx0XHQgICAgXHRcdFx0XHRcclxuICAgICAgICBcdFx0fSAgICAgICAgXHJcbiAgICAgICAgXHRcdC8vIEFkZCB0b3RhbCdzIHJvdyBpbiB0aGUgZW5kLiAgICAgICAgXHRcdFxyXG4gICAgICAgIFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFbMF0udmFsdWVzLngubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBcdFx0XHRjcmVhdGVDdWJlKGN1YmVzQ29udGFpbmVyLCB7eDogaSArIDEsIHk6IGRhdGFbMF0udmFsdWVzLnkubGVuZ3RoICsgMSwgdmFsdWU6IGRhdGFbMF0udmFsdWVzLnhQVG90YWxzW2ldLCB0b29sdGlwOiBzZWxlY3RlZEN1cnJlbmN5ICsgJyAnICsgZGF0YVswXS52YWx1ZXMueFRvdGFsc1tpXX0sIGN1YmVTaXplLCBub0NvbG9yLCBjYXRlZ29yaWVzKTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHQvLyBBZGQgdG90YWwncyBjb2x1bW4gb24gdGhlIHJpZ2h0IHNpZGUuXHJcbiAgICAgICAgXHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVswXS52YWx1ZXMueS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIFx0XHRcdGNyZWF0ZUN1YmUoY3ViZXNDb250YWluZXIsIHt4OiBkYXRhWzBdLnZhbHVlcy54Lmxlbmd0aCArIDEgLCB5OiBqICsgMSwgdmFsdWU6IGRhdGFbMF0udmFsdWVzLnlQVG90YWxzW2pdLCB0b29sdGlwOiBzZWxlY3RlZEN1cnJlbmN5ICsgJyAnICsgZGF0YVswXS52YWx1ZXMueVRvdGFsc1tqXX0sIGN1YmVTaXplLCBub0NvbG9yLCBjYXRlZ29yaWVzKTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRcclxuICAgICAgICBcdFx0Ly8gQWRkIHBlcmNlbnRhZ2UgbGVnZW5kcy5cclxuICAgICAgICBcdFx0Y3JlYXRlTGVnZW5kcyhzdmcsIGRhdGEsIGN1YmVTaXplLCBjYXRlZ29yaWVzLCBsZWdlbmRFbGVtZW50SGVpZ2h0KTtcclxuICAgICAgICBcdFx0XHJcbiAgICAgICAgXHRcdGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTShzdmdbMF0pO1xyXG4gICAgICAgIFx0XHRcclxuICAgICAgICBcdFx0Ly8gUmVjYWxjdWxhdGUgbWFyZ2lucyBpZiB3ZSBhcmUgc2hvd2luZyB0aGUgZnVsbCBsZWdlbmRzLlxyXG4gICAgICAgICAgICBcdGlmIChkYXRhWzBdLnZhbHVlcy5tb2RlbC5nZXQoJ3Nob3dGdWxsTGVnZW5kcycpKSB7ICAgICAgICBcdFx0XHJcbiAgICAgICAgICAgIFx0XHR2YXIgdG9wID0gc3ZnLnNlbGVjdCgnLmhlYXRtYXAteEF4aXMtY29udGFpbmVyJykubm9kZSgpLmdldEJCb3goKS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIFx0XHR2YXIgbGVmdCA9IHN2Zy5zZWxlY3QoJy5oZWF0bWFwLXlBeGlzLWNvbnRhaW5lcicpLm5vZGUoKS5nZXRCQm94KCkud2lkdGggKyAyNTtcclxuICAgICAgICAgICAgXHRcdHN2Zy5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbGVmdCArIFwiLFwiICsgdG9wICsgXCIpXCIpO1xyXG4gICAgICAgICAgICBcdH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2hlYXRtYXAgaW1tZWRpYXRlJyk7XHJcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZXRDYXRlZ29yaWVzQnlUaHJlc2hvbGQobm9Db2xvciwgbW9kZWwpIHtcclxuICAgIFx0dmFyIGNhdGVnb3JpZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgIFx0Y2F0ZWdvcmllcy5wdXNoKHttaW46IC0xLCBtYXg6IDAsIGNvbG9yOiBub0NvbG9yfSk7XHJcbiAgICBcdHZhciBjb2xvcnMgPSBtb2RlbC5nZXQoJ2hlYXRtYXBfY29uZmlnJykubW9kZWxzWzBdLmdldCgnYW1vdW50Q29sb3JzJyk7XHJcbiAgICBcdHZhciBpID0gMTtcclxuICAgIFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gY29sb3JzKSB7XHJcbiAgICBcdCAgICBpZiAoY29sb3JzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xyXG4gICAgXHQgICAgXHRjYXRlZ29yaWVzLnB1c2goe21pbjogcGFyc2VJbnQocHJvcGVydHkpLCBjb2xvcjogY29sb3JzW3Byb3BlcnR5XSwgbWF4OiBudWxsfSk7XHJcbiAgICBcdCAgICBcdGlmIChpID4gMSkge1xyXG4gICAgXHQgICAgXHRcdGNhdGVnb3JpZXNbaSAtIDFdLm1heCA9IHBhcnNlSW50KHByb3BlcnR5KTtcclxuICAgIFx0ICAgIFx0fVxyXG4gICAgXHQgICAgXHRpKys7XHJcbiAgICBcdCAgICB9XHJcbiAgICBcdH1cclxuICAgIFx0Y2F0ZWdvcmllc1tpIC0gMV0ubWF4ID0gMTAxO1xyXG4gICAgXHRyZXR1cm4gY2F0ZWdvcmllcztcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY3JlYXRlTGVnZW5kcyhzdmcsIGRhdGEsIGN1YmVTaXplLCBjYXRlZ29yaWVzLCBsZWdlbmRFbGVtZW50SGVpZ2h0KSB7XHJcbiAgICBcdHZhciBsZWdlbmRzQ29udGFpbmVyID0gc3ZnXHJcblx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsIFwiICsgKCgoZGF0YVswXS52YWx1ZXMueS5sZW5ndGggKyAxKSAqIGN1YmVTaXplKSArIDEwKSArIFwiKVwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIFwiaGVhdG1hcC1sZWdlbmRzLWNvbnRhaW5lclwiKTtcclxuICAgIFx0dmFyIGxlZ2VuZHNQb29sID0gW2FwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLWxlc3MtdGhhblwiKSArIFwiIFwiICsgY2F0ZWdvcmllc1sxXS5tYXggKyBcIiVcIixcclxuICAgIFx0ICAgICAgICAgICAgICAgICAgIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLWJldHdlZW5cIikgKyBcIiBcIiArIGNhdGVnb3JpZXNbMl0ubWluICsgXCIlIFwiICsgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmQtYW5kXCIpICsgXCIgPFwiICsgY2F0ZWdvcmllc1syXS5tYXggKyBcIiUgXCIsXHJcbiAgICBcdCAgICAgICAgICAgICAgICAgICBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLWxlZ2VuZC1iZXR3ZWVuXCIpICsgXCIgXCIgKyBjYXRlZ29yaWVzWzNdLm1pbiArIFwiJSBcIiArIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLWFuZFwiKSArIFwiIDxcIiArIGNhdGVnb3JpZXNbM10ubWF4ICsgXCIlIFwiLFxyXG4gICAgXHQgICAgICAgICAgICAgICAgICAgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmQtYmV0d2VlblwiKSArIFwiIFwiICsgY2F0ZWdvcmllc1s0XS5taW4gKyBcIiUgXCIgKyBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLWxlZ2VuZC1hbmRcIikgKyBcIiA8XCIgKyBjYXRlZ29yaWVzWzRdLm1heCArIFwiJSBcIixcclxuICAgIFx0ICAgICAgICAgICAgICAgICAgIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LWhlYXRtYXAtbGVnZW5kLWJldHdlZW5cIikgKyBcIiBcIiArIGNhdGVnb3JpZXNbNV0ubWluICsgXCIlIFwiICsgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmQtYW5kXCIpICsgXCIgPFwiICsgY2F0ZWdvcmllc1s1XS5tYXggKyBcIiUgXCIsXHJcbiAgICBcdCAgICAgICAgICAgICAgICAgICBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLWxlZ2VuZC1tb3JlLXRoYW5cIikgKyBcIiBcIiArIGNhdGVnb3JpZXNbNl0ubWluICsgXCIlXCJdO1xyXG4gICAgXHR2YXIgbWF4TGVnZW5kVGV4dFdpZHRoID0gMDtcclxuICAgIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZWdlbmRzUG9vbC5sZW5ndGg7IGkrKykge1xyXG4gICAgXHRcdHZhciBhdXhXaWR0aCA9IGNhbGN1bGF0ZVRleHRXaWR0aChsZWdlbmRzUG9vbFtpXSk7XHJcbiAgICBcdFx0aWYgKGF1eFdpZHRoID4gbWF4TGVnZW5kVGV4dFdpZHRoKSB7XHJcbiAgICBcdFx0XHRtYXhMZWdlbmRUZXh0V2lkdGggPSBhdXhXaWR0aDtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0JChcIiN0ZW1wU3BhblwiKS5yZW1vdmUoKTtcclxuICAgIFx0fVxyXG4gICAgXHRtYXhMZWdlbmRUZXh0V2lkdGggKz0gMjA7XHJcbiAgICBcdFxyXG4gICAgXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlZ2VuZHNQb29sLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBcdFx0dmFyIGxlZ2VuZHMgPSBsZWdlbmRzQ29udGFpbmVyXHJcblx0XHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgKGkgKiBtYXhMZWdlbmRUZXh0V2lkdGgpKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgbWF4TGVnZW5kVGV4dFdpZHRoKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGxlZ2VuZEVsZW1lbnRIZWlnaHQpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcImJvcmRlcmVkXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBjYXRlZ29yaWVzW2kgKyAxXS5jb2xvcik7XHJcblx0XHRcclxuXHRcdFx0dmFyIHRleHQgPSBsZWdlbmRzQ29udGFpbmVyLmFwcGVuZChcInRleHRcIik7IFxyXG5cdFx0XHR0ZXh0LmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ0FyaWFsJylcclxuXHRcdFx0XHQuYXR0cignZm9udC1zaXplJywgJzExcHgnKVxyXG5cdFx0XHRcdC5hdHRyKFwieVwiLCAxNSlcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgKChpICogbWF4TGVnZW5kVGV4dFdpZHRoKSArICgobWF4TGVnZW5kVGV4dFdpZHRoIC0gY2FsY3VsYXRlVGV4dFdpZHRoKGxlZ2VuZHNQb29sW2ldKSkgLyAyKSkpXHJcblx0XHRcdFx0LnRleHQobGVnZW5kc1Bvb2xbaV0pOyAvLyBXaHkgXCJ0ZXh0XCIgaW5zdGVhZCBvZiBcImh0bWxcIiwgYmVjYXVzZSBpdCBkb2VzbnQgd29yayBvbiBJRS5cclxuICAgIFx0fVxyXG4gICAgXHRcclxuICAgIFx0bGVnZW5kc0NvbnRhaW5lci5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdC50ZXh0KFwiTEVHRU5EU1wiKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgLTYpXHJcblx0XHRcdC5hdHRyKFwieVwiLCAxNSlcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcInlMYWJlbCBtb25vIGF4aXMgbnYtc2VyaWVzIGhlYXRtYXAtdG90YWxzXCIpXHJcblx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXHJcblx0XHRcdC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwiYm9sZFwiKVxyXG5cdFx0XHQuYXR0cignZGF0YS1pMThuJywgJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1sZWdlbmRzJyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1YmUoY3ViZXNDb250YWluZXIsIGRhdGEsIGN1YmVTaXplLCBub0NvbG9yLCBjYXRlZ29yaWVzKSB7XHJcbiAgICBcdHZhciBzZWxmRGF0YSA9IGRhdGE7XHJcbiAgICBcdHZhciBjdWJlID0gY3ViZXNDb250YWluZXJcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0LmF0dHIoXCJ4XCIsICgoZGF0YS54IC0gMSkgKiBjdWJlU2l6ZSkpXHJcblx0XHRcdC5hdHRyKFwieVwiLCAoKGRhdGEueSAtIDEpICogY3ViZVNpemUpKVxyXG5cdFx0XHQuYXR0cihcInJ4XCIsIDQpXHJcblx0XHRcdC5hdHRyKFwicnlcIiwgNClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcImJvcmRlcmVkXCIpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgY3ViZVNpemUpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGN1YmVTaXplKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIG5vQ29sb3IpXHJcblx0XHRcdC5hdHRyKFwiZGF0YS14XCIsIGRhdGEueCAtIDEpXHJcblx0XHRcdC5hdHRyKFwiZGF0YS15XCIsIGRhdGEueSAtIDEpO1xyXG5cdFx0XHJcblx0XHRjdWJlLnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwMClcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBjYWxjdWxhdGVDb2xvckZyb21DYXRlZ29yaWVzKGRhdGEudmFsdWUsIGNhdGVnb3JpZXMsIG5vQ29sb3IpKTtcclxuXHRcdFxyXG5cdFx0dmFyIHRleHQgPSBjdWJlc0NvbnRhaW5lci5hcHBlbmQoXCJ0ZXh0XCIpOyBcclxuXHRcdHRleHQuYXR0cignZm9udC1mYW1pbHknLCAnQXJpYWwnKVxyXG5cdFx0XHQuYXR0cignZm9udC1zaXplJywgJzExcHgnKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgKChkYXRhLnkgLSAxKSAqIGN1YmVTaXplKSlcclxuXHRcdFx0LmF0dHIoXCJ5XCIsICgoZGF0YS55IC0gMSkgKiBjdWJlU2l6ZSkgKyAxOSlcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcImhlYXRtYXAtY2VsbFwiKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gVGhlIFwib2Zmc2V0c1wiIHdlIGFkZCBvbiBlYWNoIHJldHVybiBjYWxsIGFyZSB0aWVkIHRvIHRoZSBjdXJyZW50IGZvbnQgZmFtaWx5IGFuZCBzaXplLCBzbyBpZiB3ZSBjaGFuZ2UgdGhlbSB3ZSBtaWdodCBuZWVkIHRvIGNoYW5nZSB0aGUgb2Zmc2V0cyB0b28uXHJcblx0XHRcdFx0dmFyIGQgPSBkYXRhO1xyXG5cdFx0XHRcdHZhciBhdXhWYWwgPSBkLnZhbHVlO1xyXG5cdFx0XHRcdGlmIChhdXhWYWwgPiAwICYmIGF1eFZhbCA8IDEpIHtcclxuXHRcdFx0XHRcdHJldHVybiAoKGQueCAtIDEpICogY3ViZVNpemUpICsgNDtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGF1eFZhbCA8IDEwKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gKChkLnggLSAxKSAqIGN1YmVTaXplKSArIDg7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChhdXhWYWwgPT0gMTAwKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gKChkLnggLSAxKSAqIGN1YmVTaXplKSArIDE7XHRcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuICgoZC54IC0gMSkgKiBjdWJlU2l6ZSkgKyA1O1xyXG5cdFx0XHRcdH1cdFx0XHRcdFx0XHJcblx0XHRcdH0pLnRleHQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gQ2FudCB1c2UgXCJodG1sXCIgZnVuY3Rpb24gb24gSUUuXHJcblx0XHRcdFx0dmFyIGQgPSBkYXRhO1xyXG5cdFx0XHRcdHZhciBhdXhWYWwgPSBkLnZhbHVlO1xyXG5cdFx0XHRcdGlmIChhdXhWYWwgPiAtMSkge1xyXG5cdFx0XHRcdFx0aWYgKGF1eFZhbCA+IDAgJiYgYXV4VmFsIDwgMSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gJzwxJSc7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gYXV4VmFsICsgJyUnO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gJyc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KVxyXG5cdFx0XHQub24oXCJjbGlja1wiLCBmdW5jdGlvbihvYmopIHtcdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFJlbW92ZSBhbGwgZmlsdGVycyBhcHBsaWVkLlxyXG5cdFx0XHRcdCQoJChjdWJlc0NvbnRhaW5lclswXSkuZmluZChcInJlY3RcIikpLnJlbW92ZUF0dHIoXCJmaWx0ZXJcIik7XHJcblx0XHRcdFx0Ly8gQXBwbHkgXCJkYXJrZW5cIiB0byB0aGUgcm93IGFuZCBjb2x1bW4uXHRcdFxyXG5cdFx0XHRcdCQoJChjdWJlc0NvbnRhaW5lclswXSkuZmluZChcIltkYXRhLXg9J1wiKyAoc2VsZkRhdGEueCAtIDEpICsgXCInXVwiKSkuYXR0cihcImZpbHRlclwiLCBcInVybCgjZmlsdGVyRGFya2VuKVwiKTtcclxuXHRcdFx0XHQkKCQoY3ViZXNDb250YWluZXJbMF0pLmZpbmQoXCJbZGF0YS15PSdcIisgKHNlbGZEYXRhLnkgLSAxKSArIFwiJ11cIikpLmF0dHIoXCJmaWx0ZXJcIiwgXCJ1cmwoI2ZpbHRlckRhcmtlbilcIik7XHJcblx0XHRcdFx0Ly8gSGlnaGxpZ2h0IHRoaXMgY2VsbC5cclxuXHRcdFx0XHQkKCQoY3ViZXNDb250YWluZXJbMF0pLmZpbmQoXCJbZGF0YS15PSdcIisgKHNlbGZEYXRhLnkgLSAxKSArIFwiJ11cIiArIFwiW2RhdGEteD0nXCIrIChzZWxmRGF0YS54IC0gMSkgKyBcIiddXCIpKS5yZW1vdmVBdHRyKFwiZmlsdGVyXCIpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFxyXG5cdFx0aWYgKGRhdGEudG9vbHRpcCkge1xyXG5cdFx0XHR0ZXh0LmF0dHIoJ2RhdGEtdGl0bGUnLCBkYXRhLnRvb2x0aXApXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcIm52LXNlcmllcyBoZWF0bWFwLWNlbGxcIik7XHJcblx0XHR9XHJcbiAgICB9XHJcbiAgICAgICBcclxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbG9yRnJvbUNhdGVnb3JpZXModmFsdWUsIGNhdGVnb3JpZXMsIG5vQ29sb3IpIHtcclxuICAgIFx0dmFyIGNvbG9yID0gbm9Db2xvcjtcclxuICAgIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjYXRlZ29yaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBcdFx0aWYgKCh2YWx1ZSA+PSBjYXRlZ29yaWVzW2ldLm1pbikgJiYgKHZhbHVlIDwgY2F0ZWdvcmllc1tpXS5tYXgpKSB7XHJcbiAgICBcdFx0XHRjb2xvciA9IGNhdGVnb3JpZXNbaV0uY29sb3I7XHJcbiAgICBcdFx0XHRicmVhaztcclxuICAgIFx0XHR9XHJcbiAgICBcdH1cclxuICAgIFx0cmV0dXJuIGNvbG9yO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVUZXh0V2lkdGgodGV4dCkge1xyXG4gICAgXHQkKFwiYm9keVwiKS5hcHBlbmQoXCI8c3BhbiBpZD0ndGVtcFNwYW4nIGNsYXNzPSdpbnZpc2libGUnPlwiICsgdGV4dCArIFwiPC9zcGFuPlwiKTtcclxuICAgIFx0dmFyIGF1eFdpZHRoID0gJChcIiN0ZW1wU3BhblwiKS53aWR0aCgpO1xyXG4gICAgXHQkKFwiI3RlbXBTcGFuXCIpLnJlbW92ZSgpO1xyXG4gICAgXHRyZXR1cm4gYXV4V2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXHJcbiAgICBjaGFydC5sZWdlbmQgPSB7fTtcclxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XHJcbiAgICBjaGFydC5oZWF0bWFwID0gaGVhdG1hcDtcclxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcclxuICAgIGNoYXJ0LnNob3J0VGV4dExlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgICAgICByZXR1cm4gc2hvcnRUZXh0TGVuZ3RoO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyB1c2UgT2JqZWN0IGdldC9zZXQgZnVuY3Rpb25hbGl0eSB0byBtYXAgYmV0d2VlbiB2YXJzIGFuZCBjaGFydCBmdW5jdGlvbnNcclxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwgeyAgICBcdFxyXG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcclxuICAgICAgICBub0RhdGE6ICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sICAgICAgICAgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcclxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGVmYXVsdFN0YXRlO30sICAgc2V0OiBmdW5jdGlvbihfKXtkZWZhdWx0U3RhdGU9Xzt9fSxcclxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXHJcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcclxuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xyXG4gICAgICAgIH19LFxyXG4gICAgICAgIGNvbG9yOiB7fSxcclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xyXG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcclxuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcclxuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XHJcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcclxuICAgICAgICB9fSxcclxuICAgICAgICB0b29sdGlwQ29udGVudDoge31cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBjaGFydC5oZWlnaHQgPSBmdW5jdGlvbihfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xyXG4gICAgICAgIGhlaWdodCA9IF87XHJcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIGhlYXRtYXApO1xyXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG59OyIsIlxyXG5udi5tb2RlbHMuY3VzdG9taXplZE11bHRpQmFyQ2hhcnQgPSBmdW5jdGlvbigpIHtcclxuICBcInVzZSBzdHJpY3RcIjtcclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgdmFyIG11bHRpYmFyID0gbnYubW9kZWxzLm11bHRpQmFyKClcclxuICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXHJcbiAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxyXG4gICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcclxuICAgICwgY29udHJvbHMgPSBudi5tb2RlbHMubGVnZW5kKCkgLy90aGlzIGlzbid0IGV4cG9zZWQgYnkgZGVmYXVsdCA6KFxyXG4gICAgO1xyXG5cclxuICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9XHJcbiAgICAsIHdpZHRoID0gbnVsbFxyXG4gICAgLCBoZWlnaHQgPSBudWxsXHJcbiAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcclxuICAgICwgc2hvd0NvbnRyb2xzID0gdHJ1ZVxyXG4gICAgLCBzaG93TGVnZW5kID0gdHJ1ZVxyXG4gICAgLCBzaG93WEF4aXMgPSB0cnVlXHJcbiAgICAsIHNob3dZQXhpcyA9IHRydWVcclxuICAgICwgcmlnaHRBbGlnbllBeGlzID0gZmFsc2VcclxuICAgICwgcmVkdWNlWFRpY2tzID0gdHJ1ZSAvLyBpZiBmYWxzZSBhIHRpY2sgd2lsbCBzaG93IGZvciBldmVyeSBkYXRhIHBvaW50XHJcbiAgICAsIHN0YWdnZXJMYWJlbHMgPSBmYWxzZVxyXG4gICAgLCByb3RhdGVMYWJlbHMgPSAwXHJcbiAgICAsIHRvb2x0aXBzID0gdHJ1ZVxyXG4gICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xyXG4gICAgICByZXR1cm4gJzxoMz4nICsga2V5ICsgJzwvaDM+JyArXHJcbiAgICAgICAgJzxwPicgKyAgeSArICcgb24gJyArIHggKyAnPC9wPidcclxuICAgIH1cclxuICAgICwgeCAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueFNjYWxlKClcclxuICAgICwgeSAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueVNjYWxlKClcclxuICAgICwgc3RhdGUgPSB7IHN0YWNrZWQ6IGZhbHNlIH1cclxuICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxyXG4gICAgLCBub0RhdGEgPSBcIk5vIERhdGEgQXZhaWxhYmxlLlwiXHJcbiAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJylcclxuICAgICwgY29udHJvbFdpZHRoID0gZnVuY3Rpb24oKSB7IHJldHVybiBzaG93Q29udHJvbHMgPyAzMDAgOiAwIH0gLypJbmNyZWFzZWQgZnJvbSAxODAgaW4gb3JpZ2luYWwgZmlsZS4qL1xyXG4gICAgLCB0cmFuc2l0aW9uRHVyYXRpb24gPSAyNTBcclxuICAgIDtcclxuXHJcbiAgbXVsdGliYXJcclxuICAgIC5zdGFja2VkKGZhbHNlKVxyXG4gIDtcclxuICB4QXhpc1xyXG4gICAgLm9yaWVudCgnYm90dG9tJylcclxuICAgIC50aWNrUGFkZGluZyg3KVxyXG4gICAgLmhpZ2hsaWdodFplcm8odHJ1ZSlcclxuICAgIC5zaG93TWF4TWluKGZhbHNlKVxyXG4gICAgLnRpY2tGb3JtYXQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KVxyXG4gIDtcclxuICB5QXhpc1xyXG4gICAgLm9yaWVudCgocmlnaHRBbGlnbllBeGlzKSA/ICdyaWdodCcgOiAnbGVmdCcpXHJcbiAgICAudGlja0Zvcm1hdChkMy5mb3JtYXQoJywuMWYnKSlcclxuICA7XHJcblxyXG4gIGNvbnRyb2xzLnVwZGF0ZVN0YXRlKGZhbHNlKTtcclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuXHJcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyBQcml2YXRlIFZhcmlhYmxlc1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcclxuICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXHJcbiAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcclxuICAgICAgeCA9IHhBeGlzLnRpY2tGb3JtYXQoKShtdWx0aWJhci54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXHJcbiAgICAgIHkgPSB5QXhpcy50aWNrRm9ybWF0KCkobXVsdGliYXIueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxyXG4gICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcclxuXHJcbiAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIGUudmFsdWUgPCAwID8gJ24nIDogJ3MnLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcclxuICB9O1xyXG5cclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XHJcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXHJcbiAgICAgICAgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxyXG4gICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcclxuICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcclxuICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XHJcblxyXG4gICAgICB0cnl7XHJcbiAgICAgICAgaWYoZGF0YVswXS52YWx1ZXNbMF0ueC5sZW5ndGggPiA0KXtcclxuICAgICAgICBcdC8vbWFyZ2luLmJvdHRvbSArPSAxMzA7XHJcbiAgICAgICAgXHRtYXJnaW4uYm90dG9tID0gMTMwO1xyXG4gICAgICAgIH1cclxuICAgICAgfWNhdGNoKGUpe31cclxuXHJcbiAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikuY2FsbChjaGFydCkgfTtcclxuICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcclxuXHJcbiAgICAgIC8vc2V0IHN0YXRlLmRpc2FibGVkXHJcbiAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xyXG5cclxuICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcclxuICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xyXG4gICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XHJcbiAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxyXG4gICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgLy8gRGlzcGxheSBub0RhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cclxuXHJcbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLmxlbmd0aCB9KS5sZW5ndGgpIHtcclxuICAgICAgICB2YXIgbm9EYXRhVGV4dCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5kYXRhKFtub0RhdGFdKTtcclxuXHJcbiAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi1ub0RhdGEnKVxyXG4gICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcclxuICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XHJcblxyXG4gICAgICAgIG5vRGF0YVRleHRcclxuICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXHJcbiAgICAgICAgICAuYXR0cigneScsIG1hcmdpbi50b3AgKyBhdmFpbGFibGVIZWlnaHQgLyAyKVxyXG4gICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAvLyBTZXR1cCBTY2FsZXNcclxuXHJcbiAgICAgIHggPSBtdWx0aWJhci54U2NhbGUoKTtcclxuICAgICAgeSA9IG11bHRpYmFyLnlTY2FsZSgpO1xyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxyXG5cclxuICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtbXVsdGlCYXJXaXRoTGVnZW5kJykuZGF0YShbZGF0YV0pO1xyXG4gICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1tdWx0aUJhcldpdGhMZWdlbmQnKS5hcHBlbmQoJ2cnKTtcclxuICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xyXG5cclxuICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xyXG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJyk7XHJcbiAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1iYXJzV3JhcCcpO1xyXG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xyXG4gICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtY29udHJvbHNXcmFwJyk7XHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIC8vIExlZ2VuZFxyXG5cclxuICAgICAgaWYgKHNob3dMZWdlbmQpIHtcclxuICAgICAgICBsZWdlbmQud2lkdGgoYXZhaWxhYmxlV2lkdGggLSBjb250cm9sV2lkdGgoKSk7XHJcblxyXG4gICAgICAgIGlmIChtdWx0aWJhci5iYXJDb2xvcigpKVxyXG4gICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XHJcbiAgICAgICAgICAgIHNlcmllcy5jb2xvciA9IGQzLnJnYignI2NjYycpLmRhcmtlcihpICogMS41KS50b1N0cmluZygpO1xyXG4gICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcclxuICAgICAgICAgIC5kYXR1bShkYXRhKVxyXG4gICAgICAgICAgLmNhbGwobGVnZW5kKTtcclxuXHJcbiAgICAgICAgaWYgKCBtYXJnaW4udG9wICE9IGxlZ2VuZC5oZWlnaHQoKSkge1xyXG4gICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcclxuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxyXG4gICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcclxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBjb250cm9sV2lkdGgoKSArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgLy8gQ29udHJvbHNcclxuXHJcbiAgICAgIHZhciBncm91cGVkTGVnZW5kVHJuID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6ZmlsdGVycy1jaGFydC1sZWdlbmRzLUdyb3VwZWRcIixcIkdyb3VwZWRcIik7XHJcbiAgICAgIHZhciBzdGFja2VkTGVnZW5kVHJuID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6ZmlsdGVycy1jaGFydC1sZWdlbmRzLVN0YWNrZWRcIixcIlN0YWNrZWRcIik7XHJcbiAgICAgIGlmIChzaG93Q29udHJvbHMpIHtcclxuICAgICAgICB2YXIgY29udHJvbHNEYXRhID0gW1xyXG4gICAgICAgICAgeyBrZXk6IGdyb3VwZWRMZWdlbmRUcm4sIGRpc2FibGVkOiBtdWx0aWJhci5zdGFja2VkKCkgfSxcclxuICAgICAgICAgIHsga2V5OiBzdGFja2VkTGVnZW5kVHJuLCBkaXNhYmxlZDogIW11bHRpYmFyLnN0YWNrZWQoKSB9XHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgY29udHJvbHMud2lkdGgoY29udHJvbFdpZHRoKCkpLmNvbG9yKFsnIzQ0NCcsICcjNDQ0JywgJyM0NDQnXSk7XHJcbiAgICAgICAgZy5zZWxlY3QoJy5udi1jb250cm9sc1dyYXAnKVxyXG4gICAgICAgICAgLmRhdHVtKGNvbnRyb2xzRGF0YSlcclxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJylcclxuICAgICAgICAgIC5jYWxsKGNvbnRyb2xzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XHJcblxyXG4gICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XHJcbiAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXHJcbiAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGF2YWlsYWJsZVdpZHRoICsgXCIsMClcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXHJcblxyXG4gICAgICBtdWx0aWJhclxyXG4gICAgICAgIC5kaXNhYmxlZChkYXRhLm1hcChmdW5jdGlvbihzZXJpZXMpIHsgcmV0dXJuIHNlcmllcy5kaXNhYmxlZCB9KSlcclxuICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXHJcbiAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXHJcbiAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xyXG4gICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XHJcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgfSkpXHJcblxyXG5cclxuICAgICAgdmFyIGJhcnNXcmFwID0gZy5zZWxlY3QoJy5udi1iYXJzV3JhcCcpXHJcbiAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxyXG5cclxuICAgICAgYmFyc1dyYXAudHJhbnNpdGlvbigpLmNhbGwobXVsdGliYXIpO1xyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAvLyBTZXR1cCBBeGVzXHJcblxyXG4gICAgICBpZiAoc2hvd1hBeGlzKSB7XHJcbiAgICAgICAgeEF4aXNcclxuICAgICAgICAgIC5zY2FsZSh4KVxyXG4gICAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVXaWR0aCAvIDEwMCApXHJcbiAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodCwgMCk7XHJcblxyXG4gICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcclxuICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkucmFuZ2UoKVswXSArICcpJyk7XHJcbiAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKS50cmFuc2l0aW9uKClcclxuICAgICAgICAgIC5jYWxsKHhBeGlzKTtcclxuXHJcbiAgICAgICAgdmFyIHhUaWNrcyA9IGcuc2VsZWN0KCcubnYteC5udi1heGlzID4gZycpLnNlbGVjdEFsbCgnZycpO1xyXG5cclxuICAgICAgICB4VGlja3NcclxuICAgICAgICAgIC5zZWxlY3RBbGwoJ2xpbmUsIHRleHQnKVxyXG4gICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XHJcblxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgIGlmKGRhdGFbMF0udmFsdWVzWzBdLngubGVuZ3RoID4gNCl7XHJcbiAgICAgICAgICAgIGcuc2VsZWN0QWxsKFwiLm52LXgubnYtYXhpcyAubnYtd3JhcCBnIGcgdGV4dFwiKVxyXG4gICAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXHJcbiAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBcIi0uOGVtXCIpXHJcbiAgICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4xNWVtXCIpXHJcbiAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTY1KVwiICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfWNhdGNoKGUpe31cclxuXHJcbiAgICAgICAgaWYgKHN0YWdnZXJMYWJlbHMpIHtcclxuICAgICAgICAgIHZhciBnZXRUcmFuc2xhdGUgPSBmdW5jdGlvbih4LHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICB2YXIgc3RhZ2dlclVwID0gNSwgc3RhZ2dlckRvd24gPSAxNzsgIC8vcGl4ZWxzIHRvIHN0YWdnZXIgYnlcclxuICAgICAgICAgIC8vIElzc3VlICMxNDBcclxuICAgICAgICAgIHhUaWNrc1xyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwidGV4dFwiKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpLGopIHtcclxuICAgICAgICAgICAgICByZXR1cm4gIGdldFRyYW5zbGF0ZSgwLCAoaiAlIDIgPT0gMCA/IHN0YWdnZXJVcCA6IHN0YWdnZXJEb3duKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHZhciB0b3RhbEluQmV0d2VlblRpY2tzID0gZDMuc2VsZWN0QWxsKFwiLm52LXgubnYtYXhpcyAubnYtd3JhcCBnIGcgdGV4dFwiKVswXS5sZW5ndGg7XHJcbiAgICAgICAgICBnLnNlbGVjdEFsbChcIi5udi14Lm52LWF4aXMgLm52LWF4aXNNYXhNaW4gdGV4dFwiKVxyXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLGkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZ2V0VHJhbnNsYXRlKDAsIChpID09PSAwIHx8IHRvdGFsSW5CZXR3ZWVuVGlja3MgJSAyICE9PSAwKSA/IHN0YWdnZXJEb3duIDogc3RhZ2dlclVwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVkdWNlWFRpY2tzKVxyXG4gICAgICAgICAgeFRpY2tzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGkgJSBNYXRoLmNlaWwoZGF0YVswXS52YWx1ZXMubGVuZ3RoIC8gKGF2YWlsYWJsZVdpZHRoIC8gMTAwKSkgIT09IDA7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQsIGxpbmUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKTtcclxuXHJcbiAgICAgICAgaWYocm90YXRlTGFiZWxzKVxyXG4gICAgICAgICAgeFRpY2tzXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJy50aWNrIHRleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3JvdGF0ZSgnICsgcm90YXRlTGFiZWxzICsgJyAwLDApJylcclxuICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIHJvdGF0ZUxhYmVscyA+IDAgPyAnc3RhcnQnIDogJ2VuZCcpO1xyXG5cclxuICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLnNlbGVjdEFsbCgnZy5udi1heGlzTWF4TWluIHRleHQnKVxyXG4gICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICBpZiAoc2hvd1lBeGlzKSB7XHJcbiAgICAgICAgeUF4aXNcclxuICAgICAgICAgIC5zY2FsZSh5KVxyXG4gICAgICAgICAgLnRpY2tzKCBhdmFpbGFibGVIZWlnaHQgLyAzNiApXHJcbiAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XHJcblxyXG4gICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJykudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAuY2FsbCh5QXhpcyk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcblxyXG4gICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xyXG4gICAgICAgIHN0YXRlID0gbmV3U3RhdGU7XHJcbiAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xyXG4gICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnRyb2xzLmRpc3BhdGNoLm9uKCdsZWdlbmRDbGljaycsIGZ1bmN0aW9uKGQsaSkge1xyXG4gICAgICAgIGlmICghZC5kaXNhYmxlZCkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnRyb2xzRGF0YSA9IGNvbnRyb2xzRGF0YS5tYXAoZnVuY3Rpb24ocykge1xyXG4gICAgICAgICAgcy5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICByZXR1cm4gcztcclxuICAgICAgICB9KTtcclxuICAgICAgICBkLmRpc2FibGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoZC5rZXkpIHtcclxuICAgICAgICAgIGNhc2UgZ3JvdXBlZExlZ2VuZFRybjpcclxuICAgICAgICAgICAgbXVsdGliYXIuc3RhY2tlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBzdGFja2VkTGVnZW5kVHJuOlxyXG4gICAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKHRydWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRlLnN0YWNrZWQgPSBtdWx0aWJhci5zdGFja2VkKCk7XHJcbiAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xyXG5cclxuICAgICAgICBjaGFydC51cGRhdGUoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIGNoYXJ0IGZyb20gYSBzdGF0ZSBvYmplY3QgcGFzc2VkIHRvIGV2ZW50IGhhbmRsZXJcclxuICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGUuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcclxuICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZS5zdGFja2VkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgbXVsdGliYXIuc3RhY2tlZChlLnN0YWNrZWQpO1xyXG4gICAgICAgICAgc3RhdGUuc3RhY2tlZCA9IGUuc3RhY2tlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBjaGFydDtcclxuICB9XHJcblxyXG5cclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICBtdWx0aWJhci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xyXG4gICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XHJcbiAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcclxuICB9KTtcclxuXHJcbiAgbXVsdGliYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xyXG4gICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XHJcbiAgfSk7XHJcbiAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xyXG4gIH0pO1xyXG5cclxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuXHJcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXHJcbiAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcclxuICBjaGFydC5tdWx0aWJhciA9IG11bHRpYmFyO1xyXG4gIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcclxuICBjaGFydC5jb250cm9scyA9IGNvbnRyb2xzO1xyXG4gIGNoYXJ0LnhBeGlzID0geEF4aXM7XHJcbiAgY2hhcnQueUF4aXMgPSB5QXhpcztcclxuXHJcbiAgZDMucmViaW5kKGNoYXJ0LCBtdWx0aWJhciwgJ3gnLCAneScsICd4RG9tYWluJywgJ3lEb21haW4nLCAneFJhbmdlJywgJ3lSYW5nZScsICdmb3JjZVgnLCAnZm9yY2VZJywgJ2NsaXBFZGdlJyxcclxuICAgICdpZCcsICdzdGFja2VkJywgJ3N0YWNrT2Zmc2V0JywgJ2RlbGF5JywgJ2JhckNvbG9yJywnZ3JvdXBTcGFjaW5nJyk7XHJcblxyXG4gIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcclxuXHJcbiAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFyZ2luO1xyXG4gICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcclxuICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcclxuICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XHJcbiAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xyXG4gICAgd2lkdGggPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcclxuICAgIGhlaWdodCA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQuY29sb3IgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2xvcjtcclxuICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XHJcbiAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LnNob3dDb250cm9scyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dDb250cm9scztcclxuICAgIHNob3dDb250cm9scyA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQuc2hvd0xlZ2VuZCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dMZWdlbmQ7XHJcbiAgICBzaG93TGVnZW5kID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC5zaG93WEF4aXMgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaG93WEF4aXM7XHJcbiAgICBzaG93WEF4aXMgPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LnNob3dZQXhpcyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dZQXhpcztcclxuICAgIHNob3dZQXhpcyA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQucmlnaHRBbGlnbllBeGlzID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByaWdodEFsaWduWUF4aXM7XHJcbiAgICByaWdodEFsaWduWUF4aXMgPSBfO1xyXG4gICAgeUF4aXMub3JpZW50KCAoXykgPyAncmlnaHQnIDogJ2xlZnQnKTtcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC5yZWR1Y2VYVGlja3M9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJlZHVjZVhUaWNrcztcclxuICAgIHJlZHVjZVhUaWNrcyA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQucm90YXRlTGFiZWxzID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcm90YXRlTGFiZWxzO1xyXG4gICAgcm90YXRlTGFiZWxzID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9XHJcblxyXG4gIGNoYXJ0LnN0YWdnZXJMYWJlbHMgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGFnZ2VyTGFiZWxzO1xyXG4gICAgc3RhZ2dlckxhYmVscyA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQudG9vbHRpcCA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXA7XHJcbiAgICB0b29sdGlwID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC50b29sdGlwcyA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRvb2x0aXBzO1xyXG4gICAgdG9vbHRpcHMgPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LnRvb2x0aXBDb250ZW50ID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdG9vbHRpcDtcclxuICAgIHRvb2x0aXAgPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LnN0YXRlID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhdGU7XHJcbiAgICBzdGF0ZSA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgY2hhcnQuZGVmYXVsdFN0YXRlID0gZnVuY3Rpb24oXykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGVmYXVsdFN0YXRlO1xyXG4gICAgZGVmYXVsdFN0YXRlID0gXztcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICBjaGFydC5ub0RhdGEgPSBmdW5jdGlvbihfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub0RhdGE7XHJcbiAgICBub0RhdGEgPSBfO1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIGNoYXJ0LnRyYW5zaXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uKF8pIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRyYW5zaXRpb25EdXJhdGlvbjtcclxuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF87XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcblxyXG4gIHJldHVybiBjaGFydDtcclxufSIsIlxyXG5udi5tb2RlbHMuY3VzdG9taXplZFBpZUNoYXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgdmFyIHBpZSA9IG52Lm1vZGVscy5waWUoKTtcclxuICAgIHZhciBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKCkubWFyZ2luKHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9KTtcclxuXHJcbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiAyMCwgbGVmdDogMjB9XHJcbiAgICAvL3ZhciBsZWdlbmRNYXJnaW4gPSB7dG9wOiAzMCwgcmlnaHQ6IDIwLCBib3R0b206IDIwLCBsZWZ0OiAyMH1cclxuICAgICAgICAsIHdpZHRoID0gbnVsbFxyXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxyXG4gICAgICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcclxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcclxuICAgICAgICAsIHRvb2x0aXBzID0gdHJ1ZVxyXG4gICAgICAgICwgdG9vbHRpcCA9IGZ1bmN0aW9uKGtleSwgeSwgZSwgZ3JhcGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8aDMgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAnXHJcbiAgICAgICAgICAgICAgICArIGUuY29sb3IgKyAnXCI+JyArIGtleSArICc8L2gzPidcclxuICAgICAgICAgICAgICAgICsgJzxwPicgKyAgeSArICc8L3A+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgLCBzdGF0ZSA9IG52LnV0aWxzLnN0YXRlKClcclxuICAgICAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcclxuICAgICAgICAsIG5vRGF0YSA9IFwiTm8gRGF0YSBBdmFpbGFibGUuXCJcclxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXHJcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsJ3JlbmRlckVuZCcpXHJcbiAgICAgICAgO1xyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIHRvb2x0aXBMYWJlbCA9IHBpZS54KCkoZS5wb2ludCk7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggKG9mZnNldEVsZW1lbnQgJiYgb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0KSB8fCAwICksXHJcbiAgICAgICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCAob2Zmc2V0RWxlbWVudCAmJiBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCkgfHwgMCksXHJcbiAgICAgICAgICAgIHkgPSBwaWUudmFsdWVGb3JtYXQoKShwaWUueSgpKGUucG9pbnQpKSxcclxuICAgICAgICAgICAgY29udGVudCA9IHRvb2x0aXAodG9vbHRpcExhYmVsLCB5LCBlLCBjaGFydClcclxuICAgICAgICAgICAgO1xyXG4gICAgICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgZS52YWx1ZSA8IDAgPyAnbicgOiAncycsIG51bGwsIG9mZnNldEVsZW1lbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XHJcblxyXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN0YXRlU2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoc2VyaWVzLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gIXN0YXRlLmFjdGl2ZVtpXTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gQ2hhcnQgZnVuY3Rpb25cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XHJcbiAgICBcdFxyXG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XHJcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKHBpZSk7XHJcblxyXG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcclxuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpLCAxMCkgfHwgOTYwKVxyXG4gICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXHJcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JyksIDEwKSB8fCA0MDApXHJcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbVxyXG4gICAgICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuY2FsbChjaGFydCk7IH07XHJcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5zZXR0ZXIoc3RhdGVTZXR0ZXIoZGF0YSksIGNoYXJ0LnVwZGF0ZSlcclxuICAgICAgICAgICAgICAgIC5nZXR0ZXIoc3RhdGVHZXR0ZXIoZGF0YSkpXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAvL3NldCBzdGF0ZS5kaXNhYmxlZFxyXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XS5zbGljZSgwKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXHJcbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xyXG5cclxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHRcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XHJcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LXBpZUNoYXJ0JykuZGF0YShbZGF0YV0pO1xyXG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1waWVDaGFydCcpLmFwcGVuZCgnZycpO1xyXG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0T2Zmc2V0ID0gJCgkKGNvbnRhaW5lclswXSlbMF0pLmZpbmQoXCIubGVnZW5kLm52ZDMtc3ZnXCIpWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcclxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXBpZVdyYXAnKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIGhlaWdodE9mZnNldCArICcpJyk7XHJcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBMZWdlbmRcclxuICAgICAgICAgICAgaWYgKHNob3dMZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aCggYXZhaWxhYmxlV2lkdGggKS5rZXkocGllLngoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcclxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YSlcclxuICAgICAgICAgICAgICAgICAgICAuY2FsbChsZWdlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFpbiBDaGFydCBDb21wb25lbnQocylcclxuICAgICAgICAgICAgcGllLndpZHRoKGF2YWlsYWJsZVdpZHRoKS5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIHBpZVdyYXAgPSBnLnNlbGVjdCgnLm52LXBpZVdyYXAnKS5kYXR1bShbZGF0YV0pO1xyXG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKHBpZVdyYXApLmNhbGwocGllKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxyXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBuZXdTdGF0ZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcGllLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjaGFydCBmcm9tIGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0byBldmVudCBoYW5kbGVyXHJcbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCdjaGFuZ2VTdGF0ZScsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ3BpZUNoYXJ0IGltbWVkaWF0ZScpO1xyXG4gICAgICAgIHJldHVybiBjaGFydDtcclxuICAgIH1cclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBwaWUuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcclxuICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xyXG4gICAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xyXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcclxuICAgIGNoYXJ0LnBpZSA9IHBpZTtcclxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcclxuXHJcbiAgICAvLyB1c2UgT2JqZWN0IGdldC9zZXQgZnVuY3Rpb25hbGl0eSB0byBtYXAgYmV0d2VlbiB2YXJzIGFuZCBjaGFydCBmdW5jdGlvbnNcclxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwgeyAgICBcdFxyXG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcclxuICAgICAgICBub0RhdGE6ICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sICAgICAgICAgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcclxuICAgICAgICB0b29sdGlwQ29udGVudDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcDt9LCAgICAgICAgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwPV87fX0sXHJcbiAgICAgICAgdG9vbHRpcHM6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXBzO30sICAgICAgIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcHM9Xzt9fSxcclxuICAgICAgICBzaG93TGVnZW5kOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0xlZ2VuZDt9LCAgICAgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXHJcbiAgICAgICAgZGVmYXVsdFN0YXRlOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRlZmF1bHRTdGF0ZTt9LCAgIHNldDogZnVuY3Rpb24oXyl7ZGVmYXVsdFN0YXRlPV87fX0sXHJcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxyXG4gICAgICAgIGNvbG9yOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xyXG4gICAgICAgICAgICBjb2xvciA9IF87XHJcbiAgICAgICAgICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XHJcbiAgICAgICAgICAgIHBpZS5jb2xvcihjb2xvcik7XHJcbiAgICAgICAgfX0sXHJcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcclxuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xyXG4gICAgICAgIH19LFxyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XHJcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xyXG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xyXG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcclxuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xyXG4gICAgICAgIH19LFxyXG4gICAgICAgIC8qbGVnZW5kTWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsZWdlbmRNYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcclxuICAgICAgICBcdGxlZ2VuZE1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBsZWdlbmRNYXJnaW4udG9wO1xyXG4gICAgICAgIFx0bGVnZW5kTWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IGxlZ2VuZE1hcmdpbi5yaWdodDtcclxuICAgICAgICBcdGxlZ2VuZE1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBsZWdlbmRNYXJnaW4uYm90dG9tO1xyXG4gICAgICAgIFx0bGVnZW5kTWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IGxlZ2VuZE1hcmdpbi5sZWZ0O1xyXG4gICAgICAgIH19LCovXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIHBpZSk7XHJcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbn07IiwiZnVuY3Rpb24gcXVlcnlzZWxlY3RvcigpIHtcbiAgcmV0dXJuICEhZG9jdW1lbnQucXVlcnlTZWxlY3RvcjsgIC8vIGZhaWxzIG9uIG9vb29vb29vb29sZCBJRVxufVxuXG5cbmZ1bmN0aW9uIHN2ZygpIHtcbiAgdHJ5IHtcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuXG5mdW5jdGlvbiBjYW52YXMoKSB7XG4gIHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XG59XG5cblxuZnVuY3Rpb24gY2FudmFzVGV4dCgpIHtcbiAgaWYgKCFjYW52YXMoKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgdmFyIHRleHRGbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJykuZmlsbFRleHQ7XG4gIHJldHVybiAodHlwZW9mIHRleHRGbiA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cblxudmFyIGlzSUUgPSAoZnVuY3Rpb24oKSB7XG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI0MDE4NjEvMTI5OTY5NVxuICAvLyBNYWdpYy4gRG8gbm90IHRvdWNoLlxuICB2YXIgeWVzSXRJcyA9ICEhKGZ1bmN0aW9uKCkge1xuICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsIHRlbSxcbiAgICBNID0gdWEubWF0Y2goLyhvcGVyYXxjaHJvbWV8c2FmYXJpfGZpcmVmb3h8bXNpZXx0cmlkZW50KD89XFwvKSlcXC8/XFxzKihcXGQrKS9pKSB8fCBbXTtcbiAgICBpZiAoL3RyaWRlbnQvaS50ZXN0KE1bMV0pKSB7XG4gICAgICB0ZW0gPSAgL1xcYnJ2WyA6XSsoXFxkKykvZy5leGVjKHVhKSB8fCBbXTtcbiAgICAgIHJldHVybiAnTVNJRSAnICsgKHRlbVsxXSB8fCAnJyk7XG4gICAgfVxuICAgIGlmIChNWzFdID09PSAnQ2hyb21lJykge1xuICAgICAgdGVtID0gdWEubWF0Y2goL1xcYk9QUlxcLyhcXGQrKS8pO1xuICAgICAgaWYgKCEhdGVtKSB7IHJldHVybiAnT3BlcmEgJyArIHRlbVsxXTsgfVxuICAgIH1cbiAgICBNID0gTVsyXSA/IFtNWzFdLCBNWzJdXSA6IFtuYXZpZ2F0b3IuYXBwTmFtZSwgbmF2aWdhdG9yLmFwcFZlcnNpb24sICctPyddO1xuICAgIGlmICgodGVtID0gISF1YS5tYXRjaCgvdmVyc2lvblxcLyhcXGQrKS9pKSkpIHsgTS5zcGxpY2UoMSwgMSwgdGVtWzFdKTsgfVxuICAgIHJldHVybiBNLmpvaW4oJyAnKTtcbiAgfSkoKS5tYXRjaCgvXk1TSUUvKTtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiB5ZXNJdElzOyB9O1xufSkoKTtcblxuXG5mdW5jdGlvbiBkYXRhVVJMSHJlZigpIHtcbiAgLy8gSSBkb24ndCBrbm93IGhvdyB0byBmZWF0dXJlLWRldGVjdCB0aGlzIDooXG4gIC8vIHdlIHdpbGwgYmUgb3B0aW1pc2l0aWMgYW4gb25seSBzYXkgXCJub1wiIGlmIHdlIHNlZSBJRS5cbiAgcmV0dXJuICFpc0lFKCk7XG59XG5cblxuZnVuY3Rpb24gZmxhc2goKSB7XG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMDk1NDY3LzEyOTk2OTVcbiAgLy8gZ3Jvc3MuLi5cbiAgdHJ5IHtcbiAgICByZXR1cm4gISEobmV3IEFjdGl2ZVhPYmplY3QoJ1Nob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoJykpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IubWltZVR5cGVzICYmXG4gICAgICBuYXZpZ2F0b3IubWltZVR5cGVzWydhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCddICE9PSB2b2lkIDAgJiZcbiAgICAgIG5hdmlnYXRvci5taW1lVHlwZXNbJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJ10uZW5hYmxlZFBsdWdpbjtcbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtaXNzaW5nRmVhdHVyZXMgPSBbXTsgIC8vIGFuIGVtcHR5IGFycmF5IHdpbGwgY2FzdCB0byBib29sIGZhbHNlLiBoYW5keSFcblxuICBpZiAoIXF1ZXJ5c2VsZWN0b3IoKSkge1xuICAgIG1pc3NpbmdGZWF0dXJlcy5wdXNoKHtcbiAgICAgIGZlYXR1cmU6ICdxdWVyeVNlbGVjdG9yJyxcbiAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnXG4gICAgfSk7XG4gIH1cblxuICBpZiAoIXN2ZygpKSB7XG4gICAgbWlzc2luZ0ZlYXR1cmVzLnB1c2goe1xuICAgICAgZmVhdHVyZTogJ1NWRycsXG4gICAgICBzZXZlcml0eTogJ2NyaXRpY2FsJ1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFjYW52YXNUZXh0KCkpIHtcbiAgICBtaXNzaW5nRmVhdHVyZXMucHVzaCh7XG4gICAgICBmZWF0dXJlOiAnY2FudmFzJyxcbiAgICAgIHNldmVyaXR5OiAnbWFqb3InXG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWRhdGFVUkxIcmVmKCkpIHtcbiAgICBtaXNzaW5nRmVhdHVyZXMucHVzaCh7XG4gICAgICBmZWF0dXJlOiAnZG93bmxvYWQnLFxuICAgICAgc2V2ZXJpdHk6IGZsYXNoKCkgPyAnbWlub3InIDogJ21ham9yJ1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFmbGFzaCgpKSB7XG4gICAgbWlzc2luZ0ZlYXR1cmVzLnB1c2goe1xuICAgICAgZmVhdHVyZTogJ2ZsYXNoJyxcbiAgICAgIHNldmVyaXR5OiBpc0lFKCkgPyAnbWFqb3InIDogJ21pbm9yJ1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG1pc3NpbmdGZWF0dXJlcztcbn07XG4iLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gIHVybDogJy9yZXN0L3NlY3VyaXR5L2xheW91dCcsXG5cbiAgLyoqKioqKioqKioqKlxuICAgKiBlbWFpbCBpcyBudWxsIGZyb20gc2VydmVyIHdoZW4gbm90IGxvZ2dlZCBpbiBvciB3aGVuIHdvcmtzcGFjZSBub3Qgc2V0IHlldC5cbiAgICogQmVmb3JlIGl0IGlzIGZldGNoZWQsIGRlZmF1bHQgdG8gdW5kZWZpbmVkLlxuICAgKi9cbiAgZGVmYXVsdHM6IHtcbiAgICBlbWFpbDogdW5kZWZpbmVkXG4gIH0sXG4gIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jYWNoZSA9IGZhbHNlO1xuICAgIHJldHVybiBCYWNrYm9uZS5Nb2RlbC5wcm90b3R5cGUuZmV0Y2guY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG5cbn0pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQ2hhcnRNb2RlbCA9IHJlcXVpcmUoJy4vY2hhcnQtbW9kZWwtYmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhcnRNb2RlbC5leHRlbmQoe1xuXHRcblxuXHRkZWZhdWx0cyA6IHtcblx0XHR0aXRsZSA6ICcnLFxuXHRcdHNob3dQbGFubmVkRGlzYnVyc2VtZW50czogdHJ1ZSxcblx0XHRzaG93QWN0dWFsRGlzYnVyc2VtZW50czogdHJ1ZSxcblx0XHRjaGFydFR5cGU6ICdhaWRQcmVkaWN0YWJpbGl0eSdcblx0fSxcblxuICBfcHJlcGFyZVRyYW5zbGF0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcmVkaWN0YWJpbGl0eUJhc2VMYW5ndWFnZSA9IHt9O1xuXG4gICAgLyogUHJlcGFyZSB0aGUgdHJhbnNsYXRpb25zIGZvciB0aGUgY2hhcnQgKi9cbiAgICBwcmVkaWN0YWJpbGl0eUJhc2VMYW5ndWFnZVsnYW1wLmRhc2hib2FyZDphaWQtcHJlZGljdGFiaWxpdHktcGxhbm5lZC1kaXNidXJzZW1lbnRzJ10gPSAnUGxhbm5lZCBEaXNidXJzZW1lbnRzJztcbiAgICBwcmVkaWN0YWJpbGl0eUJhc2VMYW5ndWFnZVsnYW1wLmRhc2hib2FyZDphaWQtcHJlZGljdGFiaWxpdHktYWN0dWFsLWRpc2J1cnNlbWVudHMnXSA9ICdBY3R1YWwgRGlzYnVyc2VtZW50cyc7XG5cbiAgICB0aGlzLmxvY2FsaXplZFByZWRpY3RhYmlsaXR5ID0gdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVMaXN0KHByZWRpY3RhYmlsaXR5QmFzZUxhbmd1YWdlKS50aGVuKFxuICAgICAgZnVuY3Rpb24obG9jYWxpemVkUHJlZGljdGFiaWxpdHlMaXN0KSB7XG4gICAgICAgIHNlbGYubG9jYWxpemVkUHJlZGljdGFiaWxpdHlMaXN0ID0gbG9jYWxpemVkUHJlZGljdGFiaWxpdHlMaXN0O1xuICAgICAgfSk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5zZXQoJ3RpdGxlJywgZGF0YS50aXRsZSk7XHRcblx0aWYoIV8uaXNVbmRlZmluZWQoZGF0YS5zaG93UGxhbm5lZERpc2J1cnNlbWVudHMpKXtcblx0XHR0aGlzLnNldCgnc2hvd1BsYW5uZWREaXNidXJzZW1lbnRzJywgZGF0YS5zaG93UGxhbm5lZERpc2J1cnNlbWVudHMpO1xuXHR9XG5cdGlmKCFfLmlzVW5kZWZpbmVkKGRhdGEuc2hvd0FjdHVhbERpc2J1cnNlbWVudHMpKXtcblx0XHR0aGlzLnNldCgnc2hvd0FjdHVhbERpc2J1cnNlbWVudHMnLCBkYXRhLnNob3dBY3R1YWxEaXNidXJzZW1lbnRzKTtcblx0fVx0XG5cdFxuICAgIGZ1bmN0aW9uIHBpY2sod2hpY2gpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogZC55ZWFyLFxuICAgICAgICAgIHk6IGRbd2hpY2hdWydhbW91bnQnXSxcbiAgICAgICAgICB6OiBkW3doaWNoXVsnZm9ybWF0dGVkQW1vdW50J11cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8qIHJldHVybnMgZnJvbSBtYXAoKSBsaWtlIFt7YW1wLmdpczp0aXRsZS1SZWdpb246ICdSZWdpb24nfSwgLi4uIF0qL1xuXG4gICAgZGF0YS5wcm9jZXNzZWQgPSBbXG4gICAgICB7XG4gICAgICAgIGtleTogdGhpcy5sb2NhbGl6ZWRQcmVkaWN0YWJpbGl0eUxpc3RbJ2FtcC5kYXNoYm9hcmQ6YWlkLXByZWRpY3RhYmlsaXR5LXBsYW5uZWQtZGlzYnVyc2VtZW50cyddLFxuICAgICAgICBvcmlnaW5hbEtleTogJ3BsYW5uZWQnLFxuICAgICAgICB2YWx1ZXM6IF8oZGF0YS55ZWFycykubWFwKHBpY2soJ3BsYW5uZWQgZGlzYnVyc2VtZW50cycpKSxcbiAgICAgICAgZGlzYWJsZWQ6ICF0aGlzLmdldCgnc2hvd1BsYW5uZWREaXNidXJzZW1lbnRzJylcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogdGhpcy5sb2NhbGl6ZWRQcmVkaWN0YWJpbGl0eUxpc3RbJ2FtcC5kYXNoYm9hcmQ6YWlkLXByZWRpY3RhYmlsaXR5LWFjdHVhbC1kaXNidXJzZW1lbnRzJ10sXG4gICAgICAgIG9yaWdpbmFsS2V5OiAnYWN0dWFsJyxcbiAgICAgICAgdmFsdWVzOiBfKGRhdGEueWVhcnMpLm1hcChwaWNrKCdhY3R1YWwgZGlzYnVyc2VtZW50cycpKSxcbiAgICAgICAgZGlzYWJsZWQ6ICF0aGlzLmdldCgnc2hvd0FjdHVhbERpc2J1cnNlbWVudHMnKVxuICAgICAgfVxuICAgIF07XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBDaGFydE1vZGVsID0gcmVxdWlyZSgnLi9jaGFydC1tb2RlbC1iYXNlJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY2hhcnRzL2NvbW1vbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXJ0TW9kZWwuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIHR5cGVkOiB0cnVlLFxuICAgIGxpbWl0OiAzLFxuICAgIHRpdGxlOiAnJyxcbiAgICBzdGFja2VkOiBmYWxzZSxcbiAgICBzZXJpZXNUb0V4Y2x1ZGU6IFtdLFxuICAgIHllYXJUb3RhbHM6e30sXG4gICAgY2hhcnRUeXBlOiAnZnVuZGluZ1R5cGUnXG4gIH0sXG5cbiAgX3ByZXBhcmVUcmFuc2xhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZnR5cGVCYXNlTGFuZ3VhZ2UgPSB7fTtcblxuICAgIC8qIFByZXBhcmUgdGhlIHRyYW5zbGF0aW9ucyBmb3IgdGhlIGNoYXJ0ICovXG4gICAgdmFyIGNoYXJ0TmFtZSA9IFsnYW1wLmRhc2hib2FyZDpjaGFydC0nLCB0aGlzLmdldCgnbmFtZScpLnJlcGxhY2UoLyAvZywgJycpLCAnLSddLmpvaW4oJycpO1xuXG4gICAgLypcbiAgICAgKiBUT0RPOiBsb2FkIGFsbCB0aGUgbG9jYWxpemF0aW9ucyBpbiB0aGlzIGNoYXJ0J3MgbmFtZXNwYWNlIHRvIHRoaXMgYXJyYXlcbiAgICAgKiBmcm9tIGluaXRpYWwtdHJhbnNsYXRpb24tcmVxdWVzdC5qc29uIC0tIEZvciBub3cganVzdCBoYXJkY29kZSB0aGUgdHdvIHNvcnRzLlxuICAgICAqL1xuICAgIGlmICh0aGlzLmdldCgnbmFtZScpID09PSAnRnVuZGluZyBUeXBlJykge1xuICAgICAgZnR5cGVCYXNlTGFuZ3VhZ2VbY2hhcnROYW1lICsgJ0dyYW50J10gPSAnR3JhbnQnO1xuICAgICAgZnR5cGVCYXNlTGFuZ3VhZ2VbY2hhcnROYW1lICsgJ0xvYW4nXSA9ICdMb2FuJztcbiAgICAgIGZ0eXBlQmFzZUxhbmd1YWdlW2NoYXJ0TmFtZSArICdvdGhlcnMnXSA9ICdPdGhlcnMnO1xuICAgIH1cblxuICAgIHRoaXMubG9jYWxpemVkRlR5cGUgPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZUxpc3QoZnR5cGVCYXNlTGFuZ3VhZ2UpLnRoZW4oXG4gICAgICBmdW5jdGlvbihsb2NhbGl6ZWRLZXlWYWwpIHtcbiAgICAgICAgc2VsZi5sb2NhbGl6ZWRMb29rdXAgPSBsb2NhbGl6ZWRLZXlWYWw7XG4gICAgICB9KTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuXHR0aGlzLnNldCgndGl0bGUnLCBkYXRhLnRpdGxlKTtcblx0XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB5ZWFycztcbiAgICBpZiAoZGF0YS52YWx1ZXMubGVuZ3RoID4gMCAmJiAhaXNOYU4ocGFyc2VJbnQoKGRhdGEudmFsdWVzKVswXS5ZZWFyLCAxMCkpKSB7XG4gICAgICB5ZWFycyA9IF8uc29ydEJ5KGRhdGEudmFsdWVzLCBmdW5jdGlvbihvYmopIHsgcmV0dXJuIHBhcnNlSW50KG9iai5ZZWFyLCAxMCk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ZWFycyA9IF8oZGF0YS52YWx1ZXMpLnNvcnRCeSgnWWVhcicpO1xuICAgIH1cblxuICAgIHZhciBjaGFydE5hbWUgPSBbJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtJywgdGhpcy5nZXQoJ25hbWUnKS5yZXBsYWNlKC8gL2csICcnKSwgJy0nXS5qb2luKCcnKTtcbiAgICB2YXIgbG9jYWxpemVkT3RoZXJzID0gc2VsZi5sb2NhbGl6ZWRMb29rdXBbY2hhcnROYW1lICsgJ290aGVycyddO1xuXG4gICAgLy8gcmVmb3JtYXQgdGhlIGRhdGEgZm9yIG52ZDNcbiAgICBkYXRhLnByb2Nlc3NlZCA9IF8oeWVhcnMpXG4gICAgICAuY2hhaW4oKVxuICAgICAgLnJlZHVjZShmdW5jdGlvbihzZXJpZXMsIHllYXIpIHtcbiAgICAgICAgc2VyaWVzLnB1c2guYXBwbHkoc2VyaWVzLCBfKHllYXIudmFsdWVzKS5wbHVjaygndHlwZScpKTtcbiAgICAgICAgcmV0dXJuIHNlcmllcztcbiAgICAgIH0sIFtdKVxuICAgICAgLnVuaXEoKVxuICAgICAgLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciBjbGVhbk5hbWUgPSBzLnJlcGxhY2UoL1sgOi5dL2csICcnKTtcbiAgICAgICAgdmFyIGxvY2FsaXplZE5hbWUgPSBzO1xuICAgICAgICBpZiAoc2VsZi5sb2NhbGl6ZWRMb29rdXBbY2hhcnROYW1lICsgY2xlYW5OYW1lXSkge1xuICAgICAgICAgIGxvY2FsaXplZE5hbWUgPSBzZWxmLmxvY2FsaXplZExvb2t1cFtjaGFydE5hbWUgKyBjbGVhbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5OiBsb2NhbGl6ZWROYW1lLFxuICAgICAgICAgIHZhbHVlczogXyh5ZWFycykubWFwKGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyVmFsdWUgPSBfKHkudmFsdWVzKS5maW5kV2hlcmUoe3R5cGU6IHN9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6IHkuWWVhcixcbiAgICAgICAgICAgICAgeTogeWVhclZhbHVlICYmIHllYXJWYWx1ZS5hbW91bnQgfHwgMCxcbiAgICAgICAgICAgICAgejogeWVhclZhbHVlICYmIHllYXJWYWx1ZS5mb3JtYXR0ZWRBbW91bnQgfHwgMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZGlzYWJsZWQ6IChfLmluZGV4T2Yoc2VsZi5nZXQoJ3Nlcmllc1RvRXhjbHVkZScpLGxvY2FsaXplZE5hbWUpICE9IC0xKVxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICAgIC52YWx1ZSgpO1xuICAgIFxuIFxuXHRcbiAgICAvLyBncm91cCBzbWFsbGVzdCBjb250cmlidXRvcnMgYXMgXCJvdGhlclwic1xuICAgIGlmICh0aGlzLmdldCgnbGltaXQnKSA8IGRhdGEucHJvY2Vzc2VkLmxlbmd0aCkge1xuICAgIFx0Ly8gU3VtbWFyaXplIGVhY2ggZnVuZGluZyB0eXBlIGFuZCBzb3J0IGJ5IHRvdGFsIGRlc2NlbmRpbmcsIGNyZWF0ZSBhIG5ldyBhcnJheSBvbmx5IHdpdGggZnVuZGluZyB0eXBlcyBuYW1lcy5cbiAgICBcdHZhciBvdGhlcnNOYW1lcyA9IF8oZGF0YS5wcm9jZXNzZWQpXG5cdCAgICAgICAgLmNoYWluKClcblx0ICAgICAgICAubWFwKGZ1bmN0aW9uKHNlcmllcykge1xuXHQgICAgICAgIFx0cmV0dXJuIHtcblx0ICAgICAgICBcdFx0a2V5OiBzZXJpZXMua2V5LFxuXHRcdCAgICAgICAgXHR0b3RhbDogXyhzZXJpZXMudmFsdWVzKS5yZWR1Y2UoZnVuY3Rpb24odCwgdikgeyByZXR1cm4gdCArIHYueTsgfSwgMClcblx0XHQgICAgICAgIH07XG5cdCAgICAgICAgfSlcblx0ICAgICAgICAuc29ydEJ5KCd0b3RhbCcpXG5cdCAgICAgICAgLnJldmVyc2UoKVxuXHQgICAgICAgIC5yZXN0KHRoaXMuZ2V0KCdsaW1pdCcpKVxuXHQgICAgICAgIC5wbHVjaygna2V5Jylcblx0ICAgICAgICAudmFsdWUoKTtcblxuICAgIFx0Ly8gQ3JlYXRlIGEgbmV3IGFycmF5IGZyb20gdGhlIG9yaWdpbmFsIGRhdGEgYnV0IG9ubHkgd2l0aCB0aGUgZnVuZGluZyB0eXBlcyBmcm9tICdPdGhlcnMnIGNhdGVnb3J5LlxuICAgIFx0dmFyIG90aGVyc1Nlcmllc1ZhbHVlcyA9IF8oZGF0YS5wcm9jZXNzZWQpLmZpbHRlcihmdW5jdGlvbihzZXJpZXMpIHsgcmV0dXJuIF8ob3RoZXJzTmFtZXMpLmNvbnRhaW5zKHNlcmllcy5rZXkpOyB9KVxuICAgIFx0dmFyIHNvcnRlZE90aGVyc1Nlcmllc1ZhbHVlcyA9IFtdO1xuICAgIFx0XG4gICAgXHQvLyBTb3J0ICdvdGhlcnNTZXJpZXNWYWx1ZXMnIGJ5IHRoZSB2YWx1ZXMgZnJvbSAnb3RoZXJzTmFtZXMnIFxuICAgIFx0Ly8gKGlmIHdlIGRvbnQgZG8gdGhpcyBzdGVwIHRoZW4gd2Ugd2lsbCAnZXh0cmFjdCcgdGhlIHdyb25nIGZ1bmRpbmcgdHlwZSB3aGVuIGNsaWNraW5nICdPdGhlcnMnKS5cbiAgICBcdG90aGVyc05hbWVzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgXHRcdHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIFx0XHRvdGhlcnNTZXJpZXNWYWx1ZXMgPSBvdGhlcnNTZXJpZXNWYWx1ZXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICBcdCAgICAgICAgaWYoIWZvdW5kICYmIGl0ZW0ua2V5ID09PSBrZXkpIHtcbiAgICBcdCAgICAgICAgXHRzb3J0ZWRPdGhlcnNTZXJpZXNWYWx1ZXMucHVzaChpdGVtKTtcbiAgICBcdCAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICBcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBcdCAgICAgICAgfSBlbHNlIFxuICAgIFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgXHQgICAgfSlcbiAgICBcdH0pO1xuICAgIFx0XG4gICAgXHQvLyBTdW1tYXJpemUgYWxsIGZ1bmRpbmcgdHlwZXMgKGZyb20gJ090aGVycycpIGJ5IHllYXIuXG4gICAgXHRvdGhlcnNTZXJpZXNWYWx1ZXMgPSBfKHNvcnRlZE90aGVyc1Nlcmllc1ZhbHVlcylcblx0ICAgIFx0LmNoYWluKClcblx0ICAgIFx0Lm1hcChmdW5jdGlvbihzZXJpZXMpIHsgcmV0dXJuIHNlcmllcy52YWx1ZXM7IH0pXG5cdCAgICAgICAgLnRyYW5zcG9zZSgpXG5cdCAgICAgICAgLm1hcChmdW5jdGlvbihvdGhlcnNZZWFyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIFx0eDogb3RoZXJzWWVhclswXS54LFxuXHQgICAgICAgICAgICBcdHk6IF8ob3RoZXJzWWVhcikucmVkdWNlKGZ1bmN0aW9uKHQsIHMpIHsgcmV0dXJuIHQgKyBzLnk7IH0sIDApLFxuXHQgICAgICAgICAgICBcdHo6ICcnXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSlcblx0ICAgICAgICAubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICAgICAgICBcdHJldHVybiB7XG5cdCAgICAgICAgXHRcdHg6IGl0ZW0ueCxcblx0ICAgICAgICBcdFx0eTogaXRlbS55LFxuXHQgICAgICAgIFx0XHR6OiBjb21tb24uZm9ybWF0TnVtYmVyKGl0ZW0ueSAvKiogcGFyc2VGbG9hdChhcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllci5uYW1lKSovKVxuXHQgICAgICAgIFx0fTtcblx0ICAgICAgICB9KVxuXHQgICAgICAgIC52YWx1ZSgpXG5cdCAgICBcblx0ICAgIHZhciBvdGhlcnNTZXJpZXMgPSB7IFxuXHQgICAgICAgIGtleTogbG9jYWxpemVkT3RoZXJzLFxuXHQgICAgICAgIGNvbG9yOiAnIzc3NycsXG5cdCAgICAgICAgc3BlY2lhbDogJ290aGVycycsXG5cdCAgICAgICAgZGlzYWJsZWQ6IChfLmluZGV4T2Yoc2VsZi5nZXQoJ3Nlcmllc1RvRXhjbHVkZScpLCBsb2NhbGl6ZWRPdGhlcnMpICE9IC0xKSxcblx0ICAgICAgICB2YWx1ZXM6IG90aGVyc1Nlcmllc1ZhbHVlc1xuXHQgICAgfTtcbiAgICBcdCAgICBcdC8vIFJlbW92ZSBmcm9tIHRoZSBvcmlnaW5hbCBkYXRhIHRoZSBmdW5kaW5nIHR5cGVzIHdlIGdyb3VwZWQgaW4gJ090aGVycycgKGNhbnQgdXNlIHNsaWNlIGJlY2F1c2UgdGhlIHNvcnRpbmcgaW4gJ2RhdGEucHJvY2Vzc2VkJyBpcyBkaWZmZXJlbnQpLlxuICAgIFx0ZGF0YS5wcm9jZXNzZWQgPSBfKGRhdGEucHJvY2Vzc2VkKS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge3JldHVybiAhXyhvdGhlcnNOYW1lcykuY29udGFpbnMoaXRlbS5rZXkpfSk7XG4gICAgXHRkYXRhLnByb2Nlc3NlZC5wdXNoKG90aGVyc1Nlcmllcyk7XG4gICAgfVxuICAgIFxuICAgIHZhciB5ZWFyVG90YWxzID0ge307XG5cdF8uZWFjaChkYXRhLnByb2Nlc3NlZCwgZnVuY3Rpb24oZCl7XG5cdFx0Xy5lYWNoKGQudmFsdWVzLCBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0XHR5ZWFyVG90YWxzW3ZhbHVlLnhdID0gKHllYXJUb3RhbHNbdmFsdWUueF0gfHwgMCkgKyB2YWx1ZS55O1xuXHRcdH0pOyAgICBcdFx0XG5cdH0pO1xuXHRcblx0dGhpcy5zZXQoJ3llYXJUb3RhbHMnLCB5ZWFyVG90YWxzKTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbn0pO1xuIiwidmFyIHBhcmFtID0gcmVxdWlyZSgnanF1ZXJ5JykucGFyYW07XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBDaGFydE1vZGVsID0gcmVxdWlyZSgnLi9jaGFydC1tb2RlbC1iYXNlJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY2hhcnRzL2NvbW1vbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXJ0TW9kZWwuZXh0ZW5kKHtcblxuXHRkZWZhdWx0czoge1xuXHQgICAgeExpbWl0OiAzMCwgLy9UaGlzIGlzIHRoZSBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIHdlIHdpbGwgc2VlIGluIHRoZSB4IGF4aXMuXG5cdCAgICB5TGltaXQ6IDEwLCAvL1RoaXMgaXMgdGhlIG1heCBudW1iZXIgb2YgZWxlbWVudHMgd2Ugd2lsbCBzZWUgaW4gdGhlIHkgYXhpcy4gIFxuXHQgICAgb3JpZ2luYWxZTGltaXQ6IDEwLCAvL1RoaXMgaXMgdGhlIG9yaWdpbmFsIG1heCBudW1iZXIgb2YgZWxlbWVudHMgZm9yIHRoZSB5IGF4aXMgKHVzZWQgdG8gcmV2ZXJ0IFwib3RoZXJzXCIpLlxuXHQgICAgdGl0bGU6ICcnLFxuXHQgICAgbmFtZTogJycsXG5cdCAgICBiaWdOOiAwLFxuXHQgICAgYWx0ZXJuYXRpdmVDb250YWluZXJDbGFzczogJ2hlYXRtYXAtY2hhcnQtd3JhcCcsXG5cdCAgICB2YWx1ZXM6IFtdLFxuXHQgICAgY2hhcnRUeXBlOiAnZnJhZ21lbnRhdGlvbicsXG5cdCAgICBzd2FwQXhlczogZmFsc2UsXG5cdCAgICBoZWF0bWFwX3R5cGU6IG51bGwsXG5cdCAgICBzaG93UmVzZXRCdXR0b246IGZhbHNlLFxuXHQgICAgc2hvd0Z1bGxMZWdlbmRzOiBmYWxzZVxuXHR9LFxuXG5cdF9wcmVwYXJlVHJhbnNsYXRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdG9wQmFzZUxhbmd1YWdlID0ge307XG5cblx0ICAgIC8qIFByZXBhcmUgdGhlIHRyYW5zbGF0aW9ucyBmb3IgdGhlIGNoYXJ0ICovXG5cdCAgICB2YXIgY2hhcnROYW1lID0gWydhbXAuZGFzaGJvYXJkOmNoYXJ0LScsIHRoaXMuZ2V0KCduYW1lJykucmVwbGFjZSgvIC9nLCAnJyksICctJ10uam9pbignJyk7XG5cdFxuXHQgICAgdGhpcy5sb2NhbGl6ZWRUb3BDaGFydCA9IHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlTGlzdCh0b3BCYXNlTGFuZ3VhZ2UpXG5cdCAgICBcdC5kb25lKF8oZnVuY3Rpb24obG9jYWxpemVkVG9wQ2hhcnRLZXlWYWwpIHtcblx0ICAgIFx0XHR0aGlzLmxvY2FsaXplZExvb2t1cCA9IGxvY2FsaXplZFRvcENoYXJ0S2V5VmFsO1xuXHQgICAgXHR9KS5iaW5kKHRoaXMpKTtcblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2VsZi52YWx1ZXMgPSBuZXcgQXJyYXkoKTtcblx0XHRpZiAoXy5pc1VuZGVmaW5lZChkYXRhLnhEYXRhU2V0KSB8fCBfLmlzVW5kZWZpbmVkKGRhdGEueURhdGFTZXQpKSB7XG5cdFx0XHQvLyBUaGUgRVAgZm9yIGhlYXRtYXBzIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBvdGhlciBjaGFydHMgYmVjYXVzZSBpdCByZXR1cm5zIGFuIGVtcHR5IG9iamVjdCwgc28gd2Ugc2V0IGV4cGxpY2l0bHkgc29tZSBmaWVsZHMgdG8gZW1wdHkgdmFsdWUuIFxuXHRcdFx0ZGF0YS55RGF0YVNldCA9IFtdO1xuXHRcdFx0ZGF0YS54RGF0YVNldCA9IFtdO1xuXHRcdFx0ZGF0YS5tYXRyaXggPSBbXTtcblx0XHRcdGRhdGEueFRvdGFscyA9IDA7XG5cdFx0XHRkYXRhLnlUb3RhbHMgPSAwO1xuXHRcdFx0ZGF0YS54Q291bnQgPSAwO1xuXHRcdFx0ZGF0YS55Q291bnQgPSAwO1xuXHRcdFx0ZGF0YS54VG90YWxDb3VudCA9IDA7XG5cdFx0XHRkYXRhLnlUb3RhbENvdW50ID0gMDtcblx0XHR9XHRcdFxuXHRcdHNlbGYudmFsdWVzLnggPSBkYXRhLnhEYXRhU2V0O1xuXHRcdHNlbGYudmFsdWVzLnkgPSBkYXRhLnlEYXRhU2V0O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS55RGF0YVNldC5sZW5ndGg7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhLnhEYXRhU2V0Lmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmIChkYXRhLm1hdHJpeFtpXSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IGRhdGEubWF0cml4W2ldW2pdICE9PSBudWxsID8gZGF0YS5tYXRyaXhbaV1bal0gOiB7cDogLTEsIGFtb3VudDogJzAnfTtcblx0XHRcdFx0XHR2YXIgcm93ID0ge3k6IGkgKyAxLCB4OiBqICsgMSwgdmFsdWU6IHZhbHVlLnAsIGFtb3VudDogdmFsdWUuZHYvKiwgeW5hbWU6IGRhdGEueURhdGFTZXRbaV0sIHhuYW1lOiBkYXRhLnhEYXRhU2V0W2ldKi99OyAvL25hbWUgaXMgZm9yIHRvb2x0aXBcblx0XHRcdFx0XHRzZWxmLnZhbHVlcy5wdXNoKHJvdyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi52YWx1ZXMucHVzaCh7eTogaSArIDEsIHg6IGogKyAxLCB2YWx1ZTogLTEsIGFtb3VudDogXCIwXCJ9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcdFx0XG5cdFx0Ly8gTm9ybWFsaXplIHZhbHVlcy5cblx0XHRzZWxmLnZhbHVlcyA9IHRoaXMubm9ybWFsaXplVmFsdWVzKHNlbGYudmFsdWVzKTtcblx0XHRcblx0XHQvLyBBZGQgdG90YWxzIGRhdGEuXG5cdFx0c2VsZi52YWx1ZXMueFBUb3RhbHMgPSB0aGlzLm5vcm1hbGl6ZVZhbHVlcyhkYXRhLnhQVG90YWxzKTtcblx0XHRzZWxmLnZhbHVlcy55UFRvdGFscyA9IHRoaXMubm9ybWFsaXplVmFsdWVzKGRhdGEueVBUb3RhbHMpO1xuXHRcdHNlbGYudmFsdWVzLnhUb3RhbHMgPSBkYXRhLnhUb3RhbHM7XG5cdFx0c2VsZi52YWx1ZXMueVRvdGFscyA9IGRhdGEueVRvdGFscztcblx0XHRzZWxmLnZhbHVlcy54Q291bnQgPSBkYXRhLnhDb3VudDtcblx0XHRzZWxmLnZhbHVlcy55Q291bnQgPSBkYXRhLnlDb3VudDtcblx0XHRzZWxmLnZhbHVlcy54VG90YWxDb3VudCA9IGRhdGEueFRvdGFsQ291bnQ7XG5cdFx0c2VsZi52YWx1ZXMueVRvdGFsQ291bnQgPSBkYXRhLnlUb3RhbENvdW50O1x0XG5cdFx0c2VsZi52YWx1ZXMubW9kZWwgPSB0aGlzO1xuXG5cdFx0aWYgKCF0aGlzLmxvY2FsaXplZExvb2t1cCkge1xuXHRcdFx0Ly8gd2UgY2FuJ3QgcHJvY2VkZSBpZiB3ZSBkb24ndCBoYXZlIHRyYW5zbGF0aW9ucyB5ZXQgOihcblx0XHRcdC8vIHRoaXMgY29kZSBzaG91bGQgbm93IGJlIHVucmVhY2hhYmxlLCBidXQgeSduZXZlciBrbm93Li4uXG5cdFx0XHR0aGlzLmFwcC5yZXBvcnQoJ0xvYWRpbmcgZXJyb3InLCBbJ1RyYW5zbGF0aW9ucyBmb3IgdGhlIGFwcGxpY2F0aW9uIHdlcmUgbm90IGxvYWRlZCBiZWZvcmUgcmVuZGVyaW5nJ10pO1xuXHRcdH1cblx0XHR2YXIgY2hhcnROYW1lID0gWydhbXAuZGFzaGJvYXJkOmNoYXJ0LScsIHRoaXMuZ2V0KCduYW1lJykucmVwbGFjZSgvIC9nLCAnJyksICctJ10uam9pbignJyk7XG5cblx0XHRkYXRhLnByb2Nlc3NlZCA9IFt7dmFsdWVzOiB0aGlzLnZhbHVlc31dO1xuXHRcdGRhdGEudmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0XG5cdFx0aWYgKGRhdGEueUNvdW50ID4gdGhpcy5nZXQoJ29yaWdpbmFsWUxpbWl0JykgKyAxKSB7XG5cdFx0XHR0aGlzLnNldCgnc2hvd1Jlc2V0QnV0dG9uJywgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0KCdzaG93UmVzZXRCdXR0b24nLCBmYWxzZSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBkYXRhO1xuXHR9LFxuXHRcblx0bm9ybWFsaXplVmFsdWVzOiBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHRpZiAoXy5pc1VuZGVmaW5lZCh2YWx1ZXMpID09PSBmYWxzZSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGF1eFZhbHVlID0gdmFsdWVzW2ldLnZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZXNbaV0udmFsdWUgOiB2YWx1ZXNbaV07XG5cdFx0XHRcdGlmIChhdXhWYWx1ZSA+IDAgJiYgYXV4VmFsdWUgPCAxKSB7XG5cdFx0XHRcdFx0Ly9EbyBub3RoaW5nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh2YWx1ZXNbaV0udmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dmFsdWVzW2ldLnZhbHVlID0gTWF0aC5mbG9vcihhdXhWYWx1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhbHVlc1tpXSA9IE1hdGguZmxvb3IoYXV4VmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMgfHwge30sIHsgdXJsOiB0aGlzLnVybCB9KTtcblx0XHRcblx0XHQvLyBQcm9jZXNzIHBhcmFtcyBmcm9tIGhlYXQtbWFwL2NvbmZpZ3MsIGluIHRoYXQgRVAgd2UgaGF2ZSBkZWZpbmVkIGVhY2ggaGVhdG1hcC5cblx0XHR2YXIgY29uZmlncyA9IHRoaXMuZ2V0KCdoZWF0bWFwX2NvbmZpZycpLm1vZGVsc1swXTtcblx0XHR2YXIgdGhpc0NoYXJ0ID0gXy5maW5kKGNvbmZpZ3MuZ2V0KCdjaGFydHMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLm5hbWUgPT09IHNlbGYuZ2V0KCduYW1lJyl9KTtcblx0XHR2YXIgeENvbHVtbiA9IHNlbGYuZ2V0KCd4QXhpc0NvbHVtbicpICE9PSAnJyA/IHNlbGYuZ2V0KCd4QXhpc0NvbHVtbicpIDogY29uZmlncy5nZXQoJ2NvbHVtbnMnKVt0aGlzQ2hhcnQueENvbHVtbnNbMF1dLm9yaWdOYW1lOyAvLyBGaXJzdCBjb2x1bW4gaXMgZGVmYXVsdC5cblx0XHR2YXIgeUNvbHVtbiA9IGNvbmZpZ3MuZ2V0KCdjb2x1bW5zJylbdGhpc0NoYXJ0LnlDb2x1bW5zWzBdXS5vcmlnTmFtZTsgLy8gRmlyc3QgY29sdW1uIGlzIGRlZmF1bHQuXG5cdFx0XG5cdFx0Ly8gQ2hlY2sgaWYgd2UgbmVlZCB0byBzd2l0Y2ggYXhpcy5cblx0XHRpZiAoc2VsZi5nZXQoJ3N3YXBBeGVzJykgPT09IHRydWUpIHtcblx0XHRcdHZhciBhdXhBeGlzID0geUNvbHVtbjtcblx0XHRcdHlDb2x1bW4gPSB4Q29sdW1uO1xuXHRcdFx0eENvbHVtbiA9IGF1eEF4aXM7XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBwYXJhbXNGb3JIZWF0TWFwID0ge3hDb3VudDogc2VsZi5nZXQoJ3hMaW1pdCcpLCB4Q29sdW1uOiB4Q29sdW1uLCB5Q29sdW1uOiB5Q29sdW1uLCB5Q291bnQ6IHNlbGYuZ2V0KCd5TGltaXQnKX07IFx0XHRcblx0XHRwYXJhbXNGb3JIZWF0TWFwLmZpbHRlcnMgPSAgSlNPTi5wYXJzZShvcHRpb25zLmRhdGEpO1xuXHRcdG9wdGlvbnMuZGF0YSA9IEpTT04uc3RyaW5naWZ5KHBhcmFtc0ZvckhlYXRNYXApO1xuXG5cdFx0cmV0dXJuIENoYXJ0TW9kZWwucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdH1cbn0pOyIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5Nb2RlbC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7fSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybDtcbiAgICB0aGlzLl9wcmVwYXJlVHJhbnNsYXRpb25zKCk7ICAvLyBUT0RPOiByZWZhY3RvciB0aGlzIGltcGxlbWVudGF0aW9uIGludG8gaGVyZVxuICB9LFxuXG4gIGhhc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfKHRoaXMuZ2V0KCdwcm9jZXNzZWQnKSlcbiAgICAgIC5jaGFpbigpXG4gICAgICAucGx1Y2soJ3ZhbHVlcycpXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoICYmIHRydWUgfHwgcmVzdWx0O1xuICAgICAgfSwgZmFsc2UpXG4gICAgICAudmFsdWUoKTtcbiAgfSxcblxuICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShvcHRpb25zLmRhdGEpO1xuICAgIGRhdGEuc2V0dGluZ3MgPSB0aGlzLmFwcC5zZXR0aW5ncy50b0FQSSgpO1xuXG4gICAgaWYgKHRoaXMuZ2V0KCdhZGp0eXBlJykpIHtcbiAgICAgIC8vIFRPRE8gYWRqdHlwZSBoYXJkLWNvZGluZyBrZXkgZm9yIG5vdywgc2hvdWxkIGdldCBmcm9tIHNldHRpbmdzLi4uXG4gICAgICBkYXRhLnNldHRpbmdzID0gXyh7fSkuZXh0ZW5kKGRhdGEuc2V0dGluZ3MsIHswOiB0aGlzLmdldCgnYWRqdHlwZScpfSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5kYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgcmV0dXJuIEJhY2tib25lRGFzaC5Nb2RlbC5wcm90b3R5cGUuZmV0Y2guY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG59KTtcbiIsInZhciBwYXJhbSA9IHJlcXVpcmUoJ2pxdWVyeScpLnBhcmFtO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQ2hhcnRNb2RlbCA9IHJlcXVpcmUoJy4vY2hhcnQtbW9kZWwtYmFzZScpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NoYXJ0cy9jb21tb24nKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXJ0TW9kZWwuZXh0ZW5kKHtcblxuICBkZWZhdWx0czoge1xuICAgIGxpbWl0OiA1LFxuICAgIHRpdGxlOiAnJyxcbiAgICBiaWdOOiAwLFxuICAgIGNoYXJ0VHlwZTogJ3RvcCdcbiAgfSxcblxuICBfcHJlcGFyZVRyYW5zbGF0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvcEJhc2VMYW5ndWFnZSA9IHt9O1xuXG4gICAgLyogUHJlcGFyZSB0aGUgdHJhbnNsYXRpb25zIGZvciB0aGUgY2hhcnQgKi9cbiAgICB2YXIgY2hhcnROYW1lID0gWydhbXAuZGFzaGJvYXJkOmNoYXJ0LScsIHRoaXMuZ2V0KCduYW1lJykucmVwbGFjZSgvIC9nLCAnJyksICctJ10uam9pbignJyk7XG5cbiAgICAvKlxuICAgICAqIFRPRE86IGxvYWQgYWxsIHRoZSBsb2NhbGl6YXRpb25zIGluIHRoaXMgY2hhcnQncyBuYW1lc3BhY2UgdG8gdGhpcyBhcnJheVxuICAgICAqIGZyb20gaW5pdGlhbC10cmFuc2xhdGlvbi1yZXF1ZXN0Lmpzb24gLS0gRm9yIG5vdyBqdXN0IGhhcmRjb2RlIHRoZSB0d28gc29ydHMuXG4gICAgICovXG4gICAgaWYgKHRoaXMuZ2V0KCduYW1lJykgPT09ICdUb3AgUmVnaW9ucycpIHtcbiAgICAgIHRvcEJhc2VMYW5ndWFnZVtjaGFydE5hbWUgKyAnRGlzdHJpY3RVbmRlZmluZWQnXSA9ICdEaXN0cmljdHM6IFVuZGVmaW5lZCc7XG4gICAgfVxuICAgIHRvcEJhc2VMYW5ndWFnZVtjaGFydE5hbWUgKyAnb3RoZXJzJ10gPSAnT3RoZXJzJztcblxuICAgIHRoaXMubG9jYWxpemVkVG9wQ2hhcnQgPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZUxpc3QodG9wQmFzZUxhbmd1YWdlKVxuICAgICAgLmRvbmUoXyhmdW5jdGlvbihsb2NhbGl6ZWRUb3BDaGFydEtleVZhbCkge1xuICAgICAgICB0aGlzLmxvY2FsaXplZExvb2t1cCA9IGxvY2FsaXplZFRvcENoYXJ0S2V5VmFsO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGRhdGEpIHtcblx0dGhpcy5zZXQoJ3RpdGxlJywgZGF0YS50aXRsZSk7XG5cdCAgXG4gICAgaWYgKCF0aGlzLmxvY2FsaXplZExvb2t1cCkge1xuICAgICAgLy8gd2UgY2FuJ3QgcHJvY2VkZSBpZiB3ZSBkb24ndCBoYXZlIHRyYW5zbGF0aW9ucyB5ZXQgOihcbiAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgbm93IGJlIHVucmVhY2hhYmxlLCBidXQgeSduZXZlciBrbm93Li4uXG4gICAgICB0aGlzLmFwcC5yZXBvcnQoJ0xvYWRpbmcgZXJyb3InLCBbXG4gICAgICAnVHJhbnNsYXRpb25zIGZvciB0aGUgYXBwbGljYXRpb24gd2VyZSBub3QgbG9hZGVkIGJlZm9yZSByZW5kZXJpbmcnXSk7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJ0TmFtZSA9IFsnYW1wLmRhc2hib2FyZDpjaGFydC0nLCB0aGlzLmdldCgnbmFtZScpLnJlcGxhY2UoLyAvZywgJycpLCAnLSddLmpvaW4oJycpO1xuICAgIHRoaXMubG9jYWxpemVkT3RoZXJzID0gdGhpcy5sb2NhbGl6ZWRMb29rdXBbY2hhcnROYW1lICsgJ290aGVycyddO1xuICAgIGlmICh0aGlzLmxvY2FsaXplZE90aGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgXHRjb25zb2xlLmVycm9yKCdtaXNzaW5nIHRyYW5zbGF0aW9uIGluIC5qc29uIGZpbGU6ICcgKyBjaGFydE5hbWUgKyAnb3RoZXJzJyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IF8oZGF0YS52YWx1ZXMuc2xpY2UoKSkubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciBjbGVhbk5hbWUgPSB2Lm5hbWUucmVwbGFjZSgvWyA6Ll0vZywgJycpO1xuICAgICAgdmFyIGxvY2FsaXplZE5hbWUgPSB2Lm5hbWU7XG4gICAgICBpZiAodGhpcy5sb2NhbGl6ZWRMb29rdXBbY2hhcnROYW1lICsgY2xlYW5OYW1lXSkge1xuICAgICAgICBsb2NhbGl6ZWROYW1lID0gdGhpcy5sb2NhbGl6ZWRMb29rdXBbY2hhcnROYW1lICsgY2xlYW5OYW1lXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbG9jYWxpemVkTmFtZSxcbiAgICAgICAgeTogdi5hbW91bnQsXG4gICAgICAgIHo6IHYuZm9ybWF0dGVkQW1vdW50LFxuICAgICAgICBpZDogdi5pZFxuICAgICAgfTtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIGFueSBkdXBsaWNhdGUga2V5cy4uLiBudmQzIHB1a2VzIG9uIHRob3NlXG4gICAgaWYgKF8oXyh2YWx1ZXMpLnBsdWNrKCd4JykpLnVuaXEoKS5sZW5ndGggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmFwcC5yZXBvcnQoJ0RhdGEgRXJyb3InLFxuICAgICAgICBbJ1RoZSBkYXRhIGZvciAnICsgdGhpcy5nZXQoJ25hbWUnKSArICcgd2FzIGluY29uc2lzdGVudCBkdWUgdG8gZHVwbGljYXRlIGtleXMnLFxuICAgICAgICAnVGhlIGNoYXJ0IHdpbGwgYmUgc2hvd24sIGJ1dCBpdCBtYXkgaGF2ZSBlcnJvcnMgb3Igb3RoZXIgaXNzdWVzIGFzIGEgcmVzdWx0LiddKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5tYXhMaW1pdCA+IHZhbHVlcy5sZW5ndGgpIHtcbiAgICBcdHZhciBvdGhlciA9IHtcbiAgICBcdFx0XHR4OiB0aGlzLmxvY2FsaXplZE90aGVycyxcbiAgICBcdFx0XHR5OiBkYXRhLnRvdGFsIC0gIC8vIHRvdGFsIG1pbnVzIHRoZSBzdW0gb2Ygd2hhdCB3ZSBoYXZlXG4gICAgICAgICAgICAgICAgXy5jaGFpbih2YWx1ZXMpLnBsdWNrKCd5JykucmVkdWNlKGZ1bmN0aW9uKGwsIHIpIHsgcmV0dXJuIGwgKyByOyB9LCAwKS52YWx1ZSgpLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzc3NycsXG4gICAgICAgICAgICAgICAgc3BlY2lhbDogJ290aGVycydcbiAgICAgICAgfTtcbiAgICAgICAgLy9BTVAtMTg3NDA6IFdlIGNoYW5nZWQgdGhlIEVQIHRvIHNlbmQgcmF3IG51bWJlcnMgZXhwcmVzc2VkIGluIHVuaXRzIHNvIHdlIG5lZWQgdG8gYXBwbHkgdGhlIEdTIGhlcmUuXG4gICAgXHRvdGhlci56ID0gY29tbW9uLmZvcm1hdE51bWJlcihvdGhlci55ICogcGFyc2VGbG9hdChhcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllci5uYW1lKSk7XG4gICAgICAgIHZhbHVlcy5wdXNoKG90aGVyKTtcbiAgICB9XG5cbiAgICBkYXRhLnByb2Nlc3NlZCA9IFt7dmFsdWVzOiB2YWx1ZXN9XTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcblxuICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKFxuICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgIHsgdXJsOiB0aGlzLnVybCArICc/JyArIHBhcmFtKHRoaXMucGljaygnbGltaXQnKSkgfSk7XG4gICAgcmV0dXJuIENoYXJ0TW9kZWwucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgfVxufSk7XG4iLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxuXHJcbnZhciBFbmFibGVkQ2hhcnRNb2RlbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XHJcblxyXG59KTtcclxuXHJcbnZhciBFbmFibGVkQ2hhcnRzQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcclxuXHRtb2RlbCA6IEVuYWJsZWRDaGFydE1vZGVsLFxyXG5cdHVybCA6ICcvcmVzdC9jb21tb24vZm0nLFxyXG5cdGZldGNoRGF0YSA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHBhcmFtcyA9IHtcclxuXHRcdFx0XCJkZXRhaWwtbW9kdWxlc1wiIDogWyBcIkRBU0hCT0FSRFNcIiBdXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5mZXRjaCh7XHJcblx0XHRcdHR5cGUgOiAnUE9TVCcsXHJcblx0XHRcdGFzeW5jIDogZmFsc2UsXHJcblx0XHRcdHByb2Nlc3NEYXRhIDogZmFsc2UsXHJcblx0XHRcdG1pbWVUeXBlIDogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG5cdFx0XHR0cmFkaXRpb25hbCA6IHRydWUsXHJcblx0XHRcdGhlYWRlcnMgOiB7XHJcblx0XHRcdFx0J0NvbnRlbnQtVHlwZScgOiAnYXBwbGljYXRpb24vanNvbicsXHJcblx0XHRcdFx0J0NhY2hlLUNvbnRyb2wnIDogJ25vLWNhY2hlJ1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRkYXRhIDogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSwgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZHVlIHRvXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBpbmNvbXBhdGliaWxpdGllcyB3aXRoIEplcnNleVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gd2hlbiByZWNlaXZpbmcgdGhlIHBhcmFtcy5cclxuXHRcdFx0ZXJyb3IgOiBmdW5jdGlvbihjb2xsZWN0aW9uLCByZXNwb25zZSkge1xyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ2Vycm9yIGxvYWRpbmcgY2hhcnRzLicpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRzdWNjZXNzIDogZnVuY3Rpb24oY29sbGVjdGlvbiwgcmVzcG9uc2UpIHtcclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVuYWJsZWRDaGFydHNDb2xsZWN0aW9uOyIsInZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG5cclxudmFyIEhlYXRtYXBzQ29uZmlnTW9kZWwgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xyXG5cclxufSk7XHJcblxyXG52YXIgSGVhdG1hcHNDb25maWdDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xyXG5cdG1vZGVsIDogSGVhdG1hcHNDb25maWdNb2RlbCxcclxuXHR1cmwgOiAnL3Jlc3QvZGFzaGJvYXJkL2hlYXQtbWFwL2NvbmZpZ3MnLFxyXG5cdGZldGNoRGF0YSA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5mZXRjaCh7XHJcblx0XHRcdHR5cGUgOiAnR0VUJyxcclxuXHRcdFx0YXN5bmMgOiBmYWxzZSxcclxuXHRcdFx0cHJvY2Vzc0RhdGEgOiBmYWxzZSxcclxuXHRcdFx0bWltZVR5cGUgOiAnYXBwbGljYXRpb24vanNvbicsXHJcblx0XHRcdHRyYWRpdGlvbmFsIDogdHJ1ZSxcclxuXHRcdFx0aGVhZGVycyA6IHtcclxuXHRcdFx0XHQnQ29udGVudC1UeXBlJyA6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuXHRcdFx0XHQnQ2FjaGUtQ29udHJvbCcgOiAnbm8tY2FjaGUnXHJcblx0XHRcdH0sXHJcblx0XHRcdGRhdGEgOiBKU09OLnN0cmluZ2lmeSgpLCAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBkdWUgdG9cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGluY29tcGF0aWJpbGl0aWVzIHdpdGggSmVyc2V5XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyB3aGVuIHJlY2VpdmluZyB0aGUgcGFyYW1zLlxyXG5cdFx0XHRlcnJvciA6IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHJlc3BvbnNlKSB7XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvcignZXJyb3IgbG9hZGluZyBoZWF0bWFwIGNvbmZpZ3MuJyk7XHJcblx0XHRcdH0sXHJcblx0XHRcdHN1Y2Nlc3MgOiBmdW5jdGlvbihjb2xsZWN0aW9uLCByZXNwb25zZSkge1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2cocmVzcG9uc2UpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIZWF0bWFwc0NvbmZpZ0NvbGxlY3Rpb247IiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xuXG5cbnZhciBBUElfSURfS0VZID0gJ21hcElkJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5Nb2RlbC5leHRlbmQoe1xuXG4gIGRlZmF1bHRzOiB7XG4gICAgbmFtZTogdW5kZWZpbmVkLFxuICAgIGRlc2NyaXB0aW9uOiB1bmRlZmluZWQsXG4gICAgc3RhdGVCbG9iOiB1bmRlZmluZWRcbiAgfSxcblxuICAvLyBwYXJzZSBhbmQgdG9KU09OIG1hcCB0aGUgaWQgZmllbGQgdG8gbWFwSWQgZm9yIHRoZSBBUEkuXG4gIHBhcnNlOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoXyhvYmopLmhhcyhBUElfSURfS0VZKSkge1xuICAgICAgb2JqLmlkID0gb2JqW0FQSV9JRF9LRVldO1xuICAgICAgZGVsZXRlIG9ialtBUElfSURfS0VZXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybDtcbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3B5ID0gQmFja2JvbmVEYXNoLk1vZGVsLnByb3RvdHlwZS50b0pTT04uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoXyhjb3B5KS5oYXMoJ2lkJykpIHtcbiAgICAgIGNvcHlbQVBJX0lEX0tFWV0gPSBjb3B5LmlkO1xuICAgICAgZGVsZXRlIGNvcHkuaWQ7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbn0sIHtcbiAgZnJvbUlkOiBmdW5jdGlvbihpZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGhpcyh7IGlkOiBpZCB9LCBvcHRpb25zKTtcbiAgfVxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBEZWZlcnJlZCA9IHJlcXVpcmUoJ2pxdWVyeScpLkRlZmVycmVkO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcbnZhciBTYXZlZENoYXJ0ID0gcmVxdWlyZSgnLi9zYXZlZC1kYXNoJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZURhc2guQ29sbGVjdGlvbi5leHRlbmQoe1xuXG4gIHVybDogJy9yZXN0L2Rhc2hib2FyZC9zYXZlZC1jaGFydHMnLFxuXG4gIG1vZGVsOiBTYXZlZENoYXJ0LFxuICB0aW1lcjogdW5kZWZpbmVkLFxuICBpbml0aWFsaXplZE9uY2U6IGZhbHNlLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XG4gIH0sXG5cbiAgbG9hZDogZnVuY3Rpb24oc3RhdGVJZCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdGlmIChzZWxmLmluaXRpYWxpemVkT25jZSAhPT0gZmFsc2UpIHsgcmV0dXJuOyB9XG5cdHNlbGYuaW5pdGlhbGl6ZWRPbmNlID0gdHJ1ZTtcblx0IFxuICAgIHZhciBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHZhciBsb2FkZWQgPSB0aGlzLmdldChzdGF0ZUlkKTtcbiAgICBpZiAobG9hZGVkKSB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKGxvYWRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWwuZnJvbUlkKHN0YXRlSWQsIHsgYXBwOiB0aGlzLmFwcCB9KTtcbiAgICAgIHRoaXMuYWRkKG1vZGVsKTsgIC8vIHNldHMgdXAgY29sbGVjdGlvbiBzbyB0aGUgbW9kZWwgY2FuIGZpbmQgYSBVUkxcbiAgICAgIG1vZGVsLmZldGNoKCkuZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKG1vZGVsKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBTVAtMTk4MDMgYW5kIEFNUC0yMDIwNjogSGVyZSB3ZSB3YWl0IHVudGlsIHRoZSBmaWx0ZXIgd2lkZ2V0IGhhcyBiZWVuIGxvYWRlZCB0byB0cmlnZ2VyIHRoZSAnYXBwbHknIGV2ZW50IGFuZCBmb3JjZSBlYWNoIGNoYXJ0IHRvIHJlZHJhdyB3aXRoIHRoZSBzYXZlZCBmaWx0ZXJzLlxuXHQgICAgICAvLyBUcmllZCB0byBkbyBzb21ldGhpbmcgc2ltaWxhciBiZWZvcmUgd2UgcmVhY2ggdGhpcyBzdGFnZSAoaWU6IGluIGFwcC1jbGFzcy5qcywgY2hhcnQtdmlldy1iYXNlLmpzLCBjaGFydHMuanMsIGV0YykgYnV0IHdpdGhvdXQgbHVjayBiZWNhdXNlIHRoZSByZW5kZXIgaXMgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkuXG5cdCAgICAgIC8vIFRPRE86IFdlIG5lZWQgbW9yZSB0aW1lIHRvIGV2YWx1YXRlIGEgc29sdXRpb24gdXNpbmcgdGhpcy5hcHAuZmlsdGVyLmxvYWRlZCBwcm9taXNlIGJ1dCB0aGF0IGRpZG50IHdvcmsgY29uc2lzdGVudGx5IG9uIElFLiAgICAgICAgICBcbiAgICAgICAgICBpZiAoc2VsZi50aW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFx0ICBzZWxmLnRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cdFx0ICAgIFx0ICBpZiAodGhpcy5hcHAgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmFwcC5maWx0ZXIgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmFwcC5maWx0ZXIuZmluaXNoZWRGaXJzdExvYWQgPT09IHRydWUpIHtcblx0XHQgICAgXHRcdCAgY2xlYXJJbnRlcnZhbChzZWxmLnRpbWVyKTtcblx0XHQgICAgXHRcdCAgdGhpcy5hcHAuZmlsdGVyLnRyaWdnZXIoJ2FwcGx5Jyk7XHRcdFx0ICAgIFx0XHQgIFxuXHRcdCAgICBcdFx0ICAvLyBPbmx5IG1ha2UgMSByZW5kZXIgY2FsbCB0byB0aGUgbWFpbiBhcHAgdmlldywgdGhpcyB3aWxsIHByZXZlbnQgb3RoZXIgYnVncyAoaWU6IHRoZSBkb3VibGUgYW5kIHRyaXBsZSBjaGFydCByZW5kZXJpbmcpLlxuXHRcdCAgICBcdFx0ICBpZiAodGhpcy5hcHAucmVuZGVyZWQgPT09IGZhbHNlKSB7XG5cdFx0ICAgIFx0XHRcdCAgdGhpcy5hcHAucmVuZGVyZWQgPSB0cnVlO1xuXHRcdCAgICBcdFx0XHQgIGFwcC5yZW5kZXIoKTtcblx0XHQgICAgXHRcdCAgfVxuXHRcdCAgICBcdCAgfVxuXHRcdCAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5mYWlsKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5hcHAucmVwb3J0KCdGYWlsZWQgdG8gbG9hZCBzYXZlZCBkYXNoYm9hcmQnLCBbJ0NvdWxkIG5vdCByZXRyaWV2ZSB0aGUgc2F2ZWQgc3RhdGUuJ10pO1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgfVxufSk7IiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLk1vZGVsLmV4dGVuZCh7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmw7ICAgIFxuICAgIHZhciBfc2VsZiA9IHRoaXM7XG4gICAgLy8gSW4gXCJjdXJyZW5jaWVzXCIgY29sbGVjdGlvbiB3ZSBhZGQgYW5vdGhlciBmaWVsZCB3aXRoIHRoZSBjb21wbGV0ZSBjb3B5IGZvciBmdXR1cmUgdXNlLiBcbiAgICBpZiAodGhpcy5vcmlnaW5hbEFsbEN1cnJlbmNpZXMgPT09IHVuZGVmaW5lZCAmJiBhdHRycy5pZCA9PT0gJzEnKSB7XG4gICAgXHR0aGlzLnNldCgnb3JpZ2luYWxBbGxDdXJyZW5jaWVzJywgW10pO1xuICAgIFx0Xy5lYWNoKGF0dHJzLm9wdGlvbnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICBcdFx0Ly8gTmVlZCB0byBjb3B5IG9uZSBieSBvbmUgb3IgdGhpcyBsaXN0IHdpbGwgbG9zZSBlbGVtZW50cyB3aGVuIGNoYW5naW5nIGNhbGVuZGFycy5cbiAgICBcdFx0X3NlbGYuZ2V0KCdvcmlnaW5hbEFsbEN1cnJlbmNpZXMnKS5wdXNoKGl0ZW0pO1xuICAgIFx0fSk7XG4gICAgfVxuICB9LFxuXG4gIHNlbGVjdDogZnVuY3Rpb24ob3B0aW9uSWQsIHRyaWdnZXJDaGFuZ2UpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIHVuc2VsZWN0IG9sZFxuICAgIHZhciBvbGQgPSBfKHRoaXMuYXR0cmlidXRlcy5vcHRpb25zKS5maW5kV2hlcmUoe3NlbGVjdGVkOiB0cnVlfSk7XG5cdGlmKG9sZCAhPT0gbnVsbCAmJiBvbGQgIT09IHVuZGVmaW5lZCkge1xuXHRcdGRlbGV0ZSBvbGQuc2VsZWN0ZWQ7XG5cdH0gICAgXG4gICAgLy8gc2VsZWN0IG5ld1xuICAgIHZhciBuZXdPcHQgPSBfKHRoaXMuYXR0cmlidXRlcy5vcHRpb25zKS5maW5kV2hlcmUoe2lkOiBvcHRpb25JZH0pO1xuICAgIGlmKG5ld09wdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgXHRuZXdPcHQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgXHQvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UgYXJlIGxvYWRpbmcgYSBzYXZlZCBkYXNoYm9hcmQgYW5kIHRoZSBjdXJyZW5jeSBpcyBsb2FkZWQgYmVmb3JlIHRoZSBjYWxlbmRhci5cbiAgICBcdGlmICh0aGlzLmF0dHJpYnV0ZXMuaWQgPT09IFwiMVwiKSB7XG5cdCAgICBcdG5ld09wdCA9IF8odGhpcy5hdHRyaWJ1dGVzLm9yaWdpbmFsQWxsQ3VycmVuY2llcykuZmluZFdoZXJlKHtpZDogb3B0aW9uSWR9KTtcblx0ICAgIFx0aWYgKG5ld09wdCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICBcdFx0bmV3T3B0LnNlbGVjdGVkID0gdHJ1ZTtcblx0ICAgIFx0fSBlbHNlIHtcblx0ICAgIFx0XHRjb25zb2xlLmluZm8oJ1NhdmVkIGN1cnJlbmN5IHdhcyBkZWxldGVkLicpO1xuXHQgICAgXHRcdC8vIFNlbGVjdCBkZWZhdWx0IGN1cnJlbmN5LlxuXHQgICAgXHRcdG5ld09wdCA9IF8odGhpcy5hdHRyaWJ1dGVzLm9yaWdpbmFsQWxsQ3VycmVuY2llcykuZmluZFdoZXJlKHtpZDogXy5maW5kKHNlbGYuYXBwLnNldHRpbmdzLm1vZGVscywgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLmlkID09PSBcIjFcIjt9KS5nZXQoJ2RlZmF1bHRJZCcpfSk7XG5cdCAgICBcdFx0bmV3T3B0LnNlbGVjdGVkID0gdHJ1ZTtcblx0ICAgIFx0fVxuICAgIFx0fVxuICAgIH1cblxuICAgIC8vIElmIHdlIGFyZSBjaGFuZ2luZyB0aGUgY2FsZW5kYXIgLS0+IFVwZGF0ZSBsaXN0IG9mIGN1cnJlbmNpZXMuXG4gICAgaWYgKHRoaXMuYXR0cmlidXRlcy5pZCA9PT0gXCIyXCIpIHtcbiAgICBcdHZhciBjdXJyZW5jaWVzRm9yVGhpc0NhbGVuZGFyID0gXy5maW5kKF8uZmluZChzZWxmLmFwcC5zZXR0aW5ncy5tb2RlbHMsIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbS5pZCA9PT0gXCJjYWxlbmRhckN1cnJlbmNpZXNcIjt9KS5nZXQoJ29wdGlvbnMnKSwgZnVuY3Rpb24oaXRlbTIpIHtyZXR1cm4gaXRlbTIuaWQgPT09IG9wdGlvbklkfSkudmFsdWUuc3BsaXQoJywnKTtcbiAgICBcdHZhciBhbGxDdXJyZW5jaWVzID0gXy5maW5kKHNlbGYuYXBwLnNldHRpbmdzLm1vZGVscywgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLmlkID09PSAnMSd9KTtcbiAgICBcdC8vICdvcHRpb25zJyBpcyBsaW5rZWQgdG8gdGhlIGNhbGVuZGFyIHNlbGVjdCwgbm93IHdlIGNsZWFuIGl0IG9uZSBieSBvbmUgKGFzc2lnbmluZyB0byBbXSB3aWxsIGJyZWFrIHRoZSB2aWV3KS5cbiAgICBcdGZvciAodmFyIGkgPSBhbGxDdXJyZW5jaWVzLmdldCgnb3B0aW9ucycpLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgXHRcdGFsbEN1cnJlbmNpZXMuZ2V0KCdvcHRpb25zJykuc3BsaWNlKGksIDEpO1xuICAgIFx0fVxuICAgIFx0Ly8gTWF0Y2ggdGhlIGN1cnJlbmNpZXMgZm9yIHRoaXMgY2FsZW5kYXIgd2l0aCB0aGUgbGlzdCBvZiBhbGwgY3VycmVuY2llcy5cbiAgICBcdF8uZWFjaChjdXJyZW5jaWVzRm9yVGhpc0NhbGVuZGFyLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgXHRcdHZhciBhdXhDdXJyZW5jeSA9IF8uZmluZChhbGxDdXJyZW5jaWVzLmdldCgnb3JpZ2luYWxBbGxDdXJyZW5jaWVzJyksIGZ1bmN0aW9uKGl0ZW0yKSB7XG4gICAgXHRcdFx0cmV0dXJuIGl0ZW0yLmlkID09PSBpdGVtO1xuICAgIFx0XHR9KTtcbiAgICBcdFx0aWYoYXV4Q3VycmVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgIFx0XHRcdGFsbEN1cnJlbmNpZXMuZ2V0KCdvcHRpb25zJykucHVzaChhdXhDdXJyZW5jeSk7XG4gICAgXHRcdH1cbiAgICBcdH0pO1xuICAgIFx0Ly8gQ2hlY2sgaWYgY3VycmVudGx5IHNlbGVjdGVkIGN1cnJlbmN5IGlzIHN0aWxsIHZhbGlkIGZvciB0aGUgY3VycmVudCBjYWxlbmRhciBhbmQgbWFrZSBzdXJlIHdlIGFsd2F5cyBoYXZlIGEgc2VsZWN0ZWQgY3VycmVuY3kuXG4gICAgXHR2YXIgc2VsZWN0ZWRDdXJyZW5jeSA9IF8uZmluZChhbGxDdXJyZW5jaWVzLmdldCgnb3B0aW9ucycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0uc2VsZWN0ZWQgPT09IHRydWV9KTtcbiAgICBcdGlmIChzZWxlY3RlZEN1cnJlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBcdFx0aWYgKF8uZmluZChhbGxDdXJyZW5jaWVzLmdldCgnb3JpZ2luYWxBbGxDdXJyZW5jaWVzJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbS5pZCA9PT0gc2VsZWN0ZWRDdXJyZW5jeS5pZH0pID09PSB1bmRlZmluZWQpIHtcbiAgICBcdFx0XHRzZWxlY3RlZEN1cnJlbmN5LnNlbGVjdGVkID0gZmFsc2U7XG4gICAgXHRcdFx0YWxsQ3VycmVuY2llcy5nZXQoJ29wdGlvbnMnKVswXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgXHRcdH1cbiAgICBcdH0gZWxzZSB7XG4gICAgXHRcdGFsbEN1cnJlbmNpZXMuZ2V0KCdvcHRpb25zJylbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIFx0fVxuICAgIH1cbiAgICBcbiAgICAvLyBCZWZvcmUgbGlua2luZyBjYWxlbmRhciB3aXRoIGN1cnJlbmNpZXMgdHJpZ2dlcmluZyAnY2hhbmdlJyB3YXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgaWYgKHRyaWdnZXJDaGFuZ2UgPT09IHRydWUpIHtcbiAgICBcdHRoaXMudHJpZ2dlcignY2hhbmdlJyk7ICAvLyBzb3J0IG9mIGEgaGFjayB0byBkbyB0aGlzIG1hbnVhbGx5Li4uXG4gICAgfVxuICB9LFxuICBcbiAgYXBwbHk6IGZ1bmN0aW9uKCkge1xuXHQgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgRGVmZXJyZWQgPSByZXF1aXJlKCdqcXVlcnknKS5EZWZlcnJlZDtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcbnZhciBTZXR0aW5nID0gcmVxdWlyZSgnLi9zZXR0aW5nJyk7XG5cblxuZnVuY3Rpb24gaXNJbnRTdHIobikge1xuICAvLyB0ZXN0IHdoZXRoZXIgYSBzdHJpbmcgc3RhcnRzIHdpdGggaXMgYSBiYXNlLTEwIGludFxuICByZXR1cm4gIWlzTmFOKHBhcnNlSW50KG4sIDEwKSlcbn1cblxuXG5mdW5jdGlvbiB0YWdJZih0ZXN0LCB0YWcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHNldHRpbmcpIHtcbiAgICBpZiAodGVzdChzZXR0aW5nKSkge1xuICAgICAgc2V0dGluZ1t0YWddID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNldHRpbmc7XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cbiAgdXJsOiAnL3Jlc3QvYW1wL3NldHRpbmdzJyxcblxuICBtb2RlbDogU2V0dGluZyxcblxuICBjb21wYXJhdG9yOiAnaWQnLFxuICBcbiAgZmlyc3RUaW1lOiB0cnVlLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XG4gICAgdGhpcy5fbG9hZGVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgXy5iaW5kQWxsKHRoaXMsICd0b0FQSScsICdmcm9tU3RhdGUnKTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oc2V0dGluZ3MpIHtcblx0dGhpcy5leHRyYWN0TnVtYmVyRm9ybWF0U2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIHJldHVybiBfKHNldHRpbmdzKS5jaGFpbigpXG4gICAgICAvLyBtYXJrIHdlaXJkIG9wdGlvbnMgd2l0aCBub24taW50IGtleXMgaGlkZGVuXG4gICAgICAubWFwKHRhZ0lmKGZ1bmN0aW9uKHNldHRpbmcpIHsgcmV0dXJuICFpc0ludFN0cihzZXR0aW5nLmlkKTsgfSwgJ2lnbm9yZScpKVxuICAgICAgLy8gbWFyayBmdW5kaW5nIHR5cGUgc2V0dGluZyBoaWRkZW4sIHNpbmNlIGl0J3Mgc2V0IHBlci1jaGFydC4uLlxuICAgICAgLm1hcCh0YWdJZihmdW5jdGlvbihzZXR0aW5nKSB7IHJldHVybiBzZXR0aW5nLmlkID09PSAnMCc7IH0sICdpZ25vcmUnKSlcbiAgICAgIC8vIC4uLmJ1dCBhbHNvIGZsYWcgaXQgc28gdGhlIGNoYXJ0cyBjYW4gc2VlIHRoZSB0aGUgZnVuZGluZyB0eXBlIG9wdGlvbnNcbiAgICAgIC5tYXAodGFnSWYoZnVuY3Rpb24oc2V0dGluZykgeyByZXR1cm4gc2V0dGluZy5pZCA9PT0gJzAnOyB9LCAnZnR5cGUnKSlcbiAgICAgIC8vIG1hcmsgYWxsIG9wdGlvbnMgYXMgc2VsZWN0ZWQgcGVyIHRoZSBkZWZhdWx0cyBwcm92aWRlZFxuICAgICAgLm1hcChmdW5jdGlvbihzZXR0aW5nKSB7XG4gICAgICAgIHJldHVybiBfKHNldHRpbmcpLmV4dGVuZCh7XG4gICAgICAgICAgb3B0aW9uczogXyhzZXR0aW5nLm9wdGlvbnMpLm1hcCh0YWdJZihmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uaWQgPT09IHNldHRpbmcuZGVmYXVsdElkO1xuICAgICAgICAgIH0sICdzZWxlY3RlZCcpKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC52YWx1ZSgpO1xuICB9LFxuXG4gIGxvYWQ6IGZ1bmN0aW9uKCkge1xuXHRpZih0aGlzLmZpcnN0VGltZSkge1xuXHRcdHRoaXMuZmlyc3RUaW1lID0gZmFsc2U7XG5cdFx0XG5cdFx0aWYgKHRoaXMuX2xvYWRlZC5zdGF0ZSgpICE9PSAncGVuZGluZycpIHsgcmV0dXJuIHRoaXMuX2xvYWRlZC5wcm9taXNlKCk7IH1cblxuXHQgICAgdGhpcy5mZXRjaCh7YXBwOiB0aGlzLmFwcCB9KVxuXHQgICAgICAudGhlbihfKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHRoaXMuX2xvYWRlZC5yZXNvbHZlKCk7XG5cdCAgICAgIH0pLmJpbmQodGhpcykpXG5cdCAgICAgIC5mYWlsKF8oZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdGhpcy5hcHAucmVwb3J0KCdGYWlsZWQgdG8gbG9hZCBkYXNoYm9hcmQgc2V0dGluZ3MnLFxuXHQgICAgICAgICAgWydDb3VsZCBub3QgY29ubmVjdCB0byB0aGUgc2VydmVyLiddKTtcblx0ICAgICAgICB0aGlzLl9sb2FkZWQucmVqZWN0KCk7XG5cdCAgICAgIH0pLmJpbmQodGhpcykpO1xuXHR9ICAgIFxuICAgIHJldHVybiB0aGlzLl9sb2FkZWQucHJvbWlzZSgpO1xuICB9LFxuXG4gIHRvQVBJOiBmdW5jdGlvbihvdmVycmlkZXMpIHtcbiAgICAvLyBmb3JtYXQgc2VsZWN0ZWQgZmlsdGVyIG9wdGlvbnMgdGhlIHdheSB0aGUgYXBpIHdhbnRzXG4gICAgLy8gaWdub3JlZCBmaWx0ZXJzIGFyZSBza2lwcGVkIChvdmVycmlkZXMgYXJlIG5ldmVyIHJlbW92ZWQgdGhvdWdoKVxuICAgIC8vIG92ZXJyaWRlcyBzaG91bGQgYmUgaW4gdGhlIHtzZXR0aW5nSWQ6IHNldHRpbmdPcHRpb25JZH0gZm9ybWF0IHRoZSBhcGkgZXhwZWN0c1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4ge307IH0gIC8vIGNvcCBvdXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBzZXR0aW5ncyB5ZXRcbiAgICByZXR1cm4gdGhpcy5jaGFpbigpXG4gICAgICAubWFwKGZ1bmN0aW9uKG1vZGVsKSB7IHJldHVybiBtb2RlbC50b0pTT04oKTsgfSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oc2V0dGluZykgeyByZXR1cm4gIXNldHRpbmcuaWdub3JlOyB9KVxuICAgICAgLnJlZHVjZShmdW5jdGlvbihhcGlGb3JtYXR0ZWQsIHNldHRpbmcpIHtcbiAgICAgICAgYXBpRm9ybWF0dGVkW3NldHRpbmcuaWRdID0gXyhzZXR0aW5nLm9wdGlvbnMpXG4gICAgICAgICAgLmZpbmRXaGVyZSh7c2VsZWN0ZWQ6IHRydWV9KS5pZDtcbiAgICAgICAgcmV0dXJuIGFwaUZvcm1hdHRlZDtcbiAgICAgIH0sIHt9KVxuICAgICAgLmV4dGVuZChvdmVycmlkZXMgfHwge30pXG4gICAgICAudmFsdWUoKTtcbiAgfSxcblxuICBmcm9tU3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdCAgLy8gQ2hlY2sgaWYgdGhlIHNhdmVkIGNhbGVuZGFyIHN0aWxsIGV4aXN0cy5cblx0ICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgdmFyIHNhdmVkQ2FsZW5kYXJJZCA9IF8uZmluZChzdGF0ZSwgZnVuY3Rpb24oaXRlbSwga2V5KSB7cmV0dXJuIGtleSA9PT0gXCIyXCJ9KTsgIFxuXHRcdCAgdmFyIHNhdmVkQ2FsZW5kYXIgPSBfLmZpbmQoXy5maW5kKHRoaXMubW9kZWxzLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0uaWQgPT09IFwiMlwifSkuZ2V0KFwib3B0aW9uc1wiKSwgZnVuY3Rpb24oaXRlbTIpIHtyZXR1cm4gaXRlbTIuaWQgPT09IHNhdmVkQ2FsZW5kYXJJZH0pO1xuXHRcdCAgaWYgKHNhdmVkQ2FsZW5kYXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ICAvLyBUaGlzIGNhbGVuZGFyIHdhcyBkZWxldGVkLCBzZWxlY3QgYW5vdGhlci5cblx0XHRcdCAgc3RhdGVbXCIyXCJdID0gXy5maW5kKHRoaXMubW9kZWxzLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0uaWQgPT09IFwiMlwifSkuZ2V0KFwib3B0aW9uc1wiKVswXS5pZDtcblx0XHQgIH1cblx0ICB9XG5cdFx0ICBcblx0ICAvLyBzZWxlY3Qgb3B0aW9ucyBmcm9tIGFuIGFycmF5IHdpdGggdGhlIHNhbWUgZm9ybWF0IHdlIHNlbmQgdG8gdGhlIGFwaVxuXHQgIF8oc3RhdGUpLmVhY2goZnVuY3Rpb24ob3B0SWQsIHNldHRpbmdJZCkge1xuXHRcdCAgdGhpcy5nZXQoc2V0dGluZ0lkKS5zZWxlY3Qob3B0SWQsIHRydWUpO1xuXHQgIH0sIHRoaXMpO1xuICB9LFxuXG4gIGdldFZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihzZXR0aW5nKSB7IHJldHVybiAhc2V0dGluZy5nZXQoJ2lnbm9yZScpOyB9KTtcbiAgfSxcbiAgXG4gIGV4dHJhY3ROdW1iZXJGb3JtYXRTZXR0aW5nczogZnVuY3Rpb24oc2V0dGluZ3MpIHtcblx0ICB2YXIgbnVtYmVyRm9ybWF0ID0ge307IFxuXHQgIHZhciBmb3VuZE5GID1fLmZpbmQoc2V0dGluZ3MsIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbS5pZCA9PT0gJ251bWJlci1mb3JtYXQnfSk7XG5cdCAgbnVtYmVyRm9ybWF0Lm51bWJlckZvcm1hdCA9IF8uZmluZChmb3VuZE5GLm9wdGlvbnMsIGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uaWQgPT09IGZvdW5kTkYuZGVmYXVsdElkfSkubmFtZSB8fCAnIywjLiMnO1xuXG5cdCAgLy8gSWYgdGhlIGZvcm1hdCBwYXR0ZXJuIGRvZXNudCBoYXZlIHRob3VzYW5kcyBncm91cGluZyB0aGVuIGlnbm9yZSAnbnVtYmVyLWdyb3VwLXNlcGFyYXRvcicgcGFyYW0gb3IgaXQgd2lsbCBcblx0ICAvLyBiZSB1c2VkIGJ5IEpTIHRvIGdyb3VwIGJ5IHRob3VzYW5kcyAoaWU6IGluIHRoZSAnT3RoZXJzJyBjb2x1bW5zKS5cblx0ICBpZihudW1iZXJGb3JtYXQubnVtYmVyRm9ybWF0LmluZGV4T2YoJywnKSAhPT0gLTEpIHtcblx0XHQgIHZhciBmb3VuZE5HUyA9Xy5maW5kKHNldHRpbmdzLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0uaWQgPT09ICdudW1iZXItZ3JvdXAtc2VwYXJhdG9yJ30pO1xuXHRcdCAgbnVtYmVyRm9ybWF0Lmdyb3VwU2VwYXJhdG9yID0gXy5maW5kKGZvdW5kTkdTLm9wdGlvbnMsIGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uaWQgPT09IGZvdW5kTkdTLmRlZmF1bHRJZH0pLm5hbWUgfHwgJywnO1xuXHQgIH0gZWxzZSB7XG5cdFx0ICBudW1iZXJGb3JtYXQuZ3JvdXBTZXBhcmF0b3IgPSAnJztcblx0ICB9XG5cdCAgdmFyIGZvdW5kRFMgPV8uZmluZChzZXR0aW5ncywgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLmlkID09PSAnbnVtYmVyLWRlY2ltYWwtc2VwYXJhdG9yJ30pO1xuXHQgIG51bWJlckZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yID0gXy5maW5kKGZvdW5kRFMub3B0aW9ucywgZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS5pZCA9PT0gZm91bmREUy5kZWZhdWx0SWR9KS5uYW1lIHx8ICcuJztcblx0ICB0aGlzLmFwcC5zZXR0aW5ncy5udW1iZXJGb3JtYXRTZXR0aW5ncyA9IG51bWJlckZvcm1hdDtcblx0ICBcblx0ICB2YXIgZm91bmROTSA9Xy5maW5kKHNldHRpbmdzLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0uaWQgPT09ICdudW1iZXItbXVsdGlwbGllcid9KTtcblx0ICB0aGlzLmFwcC5zZXR0aW5ncy5udW1iZXJNdWx0aXBsaWVyID0gXy5maW5kKGZvdW5kTk0ub3B0aW9ucywgZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS5pZCA9PT0gZm91bmROTS5kZWZhdWx0SWR9KTtcblx0ICBpZiAodGhpcy5hcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllci5uYW1lID09PSAnMS4wJykge1xuXHRcdCAgdGhpcy5hcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllckRlc2NyaXB0aW9uID0gJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy1pbnVuaXRzJztcblx0ICB9IGVsc2UgaWYodGhpcy5hcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllci5uYW1lID09PSAnMC4wMDEnKSB7XG5cdFx0ICB0aGlzLmFwcC5zZXR0aW5ncy5udW1iZXJNdWx0aXBsaWVyRGVzY3JpcHRpb24gPSAnYW1wLmRhc2hib2FyZDpjaGFydC10b3BzLWludGhvdXNhbmRzJztcblx0ICB9IGVsc2Uge1xuXHRcdCAgdGhpcy5hcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllckRlc2NyaXB0aW9uID0gJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy1pbm1pbGxpb25zJztcblx0ICB9XG4gIH1cblxufSk7IiwidmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcbnZhciBDaGFydFZpZXdCYXNlID0gcmVxdWlyZSgnLi9jaGFydC12aWV3LWJhc2UnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhcnRWaWV3QmFzZS5leHRlbmQoe1xuXG4gIHVpRGVmYXVsdHM6IHtcbiAgICBiaWc6IGZhbHNlLFxuICAgIHZpZXc6ICdtdWx0aWJhcicsXG4gICAgc2hvd1RvdGFsOiB0cnVlLFxuICAgIHNob3dNZWFzdXJlc1NlbGVjdG9yOiB0cnVlLFxuICAgIHNob3dUb3BMZWdlbmRzOiB0cnVlLFxuICAgIHNob3dDb21tb25DaGFydEFyZWE6IHRydWVcbiAgfSxcbiAgZXZlbnRzOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LENoYXJ0Vmlld0Jhc2UucHJvdG90eXBlLmV2ZW50cyx7XG4gICAgICAgICAgJ2NsaWNrIC5udi1zZXJpZXMnIDogJ2NoYW5nZUNoYXJ0Q29sdW1ucydcbiAgICAgIH0pO1xuICB9LCAgXG4gIGNoYW5nZUNoYXJ0Q29sdW1uczogZnVuY3Rpb24oZSl7XG5cdCAgdmFyIGtleSA9ICQoZS5jdXJyZW50VGFyZ2V0KS5maW5kKCcubnYtbGVnZW5kLXRleHQnKS50ZXh0KCk7XG5cdCAgdmFyIHBsYW5uZWREaXNidXJzZW1lbnRUcm4gPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDphaWQtcHJlZGljdGFiaWxpdHktcGxhbm5lZC1kaXNidXJzZW1lbnRzXCIsXCJQbGFubmVkIERpc2J1cnNlbWVudHNcIik7XG5cdCAgdmFyIGFjdHVhbERpc2J1cnNlbWVudFRybiA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmFpZC1wcmVkaWN0YWJpbGl0eS1hY3R1YWwtZGlzYnVyc2VtZW50c1wiLFwiQWN0dWFsIERpc2J1cnNlbWVudHNcIik7XG5cdCAgaWYoa2V5ID09IHBsYW5uZWREaXNidXJzZW1lbnRUcm4pe1xuXHRcdCAgdGhpcy5tb2RlbC5zZXQoJ3Nob3dQbGFubmVkRGlzYnVyc2VtZW50cycsICF0aGlzLm1vZGVsLmdldCgnc2hvd1BsYW5uZWREaXNidXJzZW1lbnRzJykpO1x0XG5cdCAgfWVsc2UgaWYoa2V5ID09IGFjdHVhbERpc2J1cnNlbWVudFRybil7XG5cdFx0ICB0aGlzLm1vZGVsLnNldCgnc2hvd0FjdHVhbERpc2J1cnNlbWVudHMnLCAhdGhpcy5tb2RlbC5nZXQoJ3Nob3dBY3R1YWxEaXNidXJzZW1lbnRzJykpO1x0XG5cdCAgfVx0XG4gIH0sXG4gIGNoYXJ0Vmlld3M6IFtcbiAgICAnbXVsdGliYXInLFxuICAgICd0YWJsZSdcbiAgXSxcblxuICBjaGFydE9wdGlvbnM6IHtcbiAgICBudkNvbnRyb2xzOiBmYWxzZVxuICB9LFxuXG4gIGRvd25sb2FkQ2hhcnRPcHRpb25zOiB7XG4gICAgbnZDb250cm9sczogZmFsc2UsXG4gICAgdHJpbUxhYmVsczogZmFsc2VcbiAgfSxcblxuICBnZXRUVENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgYXBwID0gdGhpcy5hcHA7XG4gICAgdmFyIG9mID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpvZicsJ29mJyk7XG4gICAgdmFyIHRvdGFsID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDp0b3RhbCcsJ3RvdGFsJyk7XG4gICAgdmFyIHVuaXRzID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhhcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllckRlc2NyaXB0aW9uKTtcblxuICAgIC8vIElNUE9SVEFOVDogV2UgYXNzdW1lIHRoaXMgY2hhcnQgd2lsbCBBTFdBWVMgc2hvdyAyIGRhdGEgc2VyaWVzLlxuICAgIC8qIG1vZGlmeSB0byBiZSBsaWtlIGNoYXJ0LWZ1bmRpbmctdHlwZSBpZiBhZGRpbmcgbW9yZSBzZXJpZXMgKi9cbiAgICB2YXIgaW5kZXggPSAtMTtcbiAgICBpZiAoY29udGV4dC5kYXRhWzBdLmRpc2FibGVkID09PSB0cnVlKSB7XG4gICAgICBpbmRleCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gY29udGV4dC5zZXJpZXMuaW5kZXg7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlciA9IGNvbnRleHQueC5yYXcgKyAnICcgK1xuICAgICAgICAgIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6YWlkLXByZWRpY3RhYmlsaXR5LScgK1xuICAgICAgICAgIGNvbnRleHQuZGF0YVtpbmRleF0ub3JpZ2luYWxLZXkgKyAnLScgKyB0aGlzLm1vZGVsLmdldCgnbWVhc3VyZScpLCAnJyk7XG5cbiAgICB2YXIgb3RoZXJTZXJpZXMgPSBjb250ZXh0LmRhdGFbMSAtIGluZGV4XTsgIC8vIFdBUk5JTkc6IGFzc3VtZXMgb25seSAyIHNlcmllc1xuICAgIHZhciBvdGhlckhlcmUgPSBvdGhlclNlcmllcy52YWx1ZXNbY29udGV4dC54LmluZGV4XTtcbiAgICB2YXIgbGluZTJBbW91bnQgPSAwO1xuICAgIGlmIChvdGhlckhlcmUueSA+IDApIHtcbiAgICAgIGxpbmUyQW1vdW50ID0gY29udGV4dC55LnJhdyAvIG90aGVySGVyZS55O1xuICAgIH1cbiAgICB2YXIgbGluZTIgPSAnPGI+JyArIGQzLmZvcm1hdCgnJScpKGxpbmUyQW1vdW50KSArXG4gICAgICAgICc8L2I+Jm5ic3A8c3Bhbj4nICsgb2YgKyAnPC9zcGFuPiZuYnNwJyArIGNvbnRleHQueC5yYXcgK1xuICAgICAgICAnJm5ic3A8c3Bhbj4nICsgdG90YWwgKyAnPC9zcGFuPic7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjdXJyZW5jeU5hbWUgPSBfLmZpbmQoYXBwLnNldHRpbmdzLmdldCgnMScpLmdldCgnb3B0aW9ucycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0uaWQgPT09IHNlbGYubW9kZWwuZ2V0KCdjdXJyZW5jeScpfSkudmFsdWU7XG4gICAgcmV0dXJuIHt0dDoge1xuICAgICAgaGVhZGluZzogaGVhZGVyLFxuICAgICAgYm9keVRleHQ6ICc8Yj4nICsgY29udGV4dC55LmZtdCArICc8L2I+ICcgKyBjdXJyZW5jeU5hbWUgKyAnICgnICsgdW5pdHMgKyAnKScsXG4gICAgICBmb290ZXJUZXh0OiBsaW5lMlxuICAgIH19O1xuICB9XG5cbn0pO1xuIiwidmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcbnZhciBDaGFydFZpZXdCYXNlID0gcmVxdWlyZSgnLi9jaGFydC12aWV3LWJhc2UnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhcnRWaWV3QmFzZS5leHRlbmQoe1xuXG4gIHVpRGVmYXVsdHM6IHtcbiAgICBiaWc6IHRydWUsXG4gICAgYWRqdHlwZTogJ0ZBS0UnLFxuICAgIHZpZXc6ICdtdWx0aWJhcicsXG4gICAgc2hvd1RvdGFsOiB0cnVlLFxuICAgIHNob3dNZWFzdXJlc1NlbGVjdG9yOiB0cnVlLFxuICAgIHNob3dUb3BMZWdlbmRzOiB0cnVlLFxuICAgIHNob3dDb21tb25DaGFydEFyZWE6IHRydWVcbiAgfSxcbiAgZXZlbnRzOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LENoYXJ0Vmlld0Jhc2UucHJvdG90eXBlLmV2ZW50cyx7XG4gICAgICAgICAgJ2NsaWNrIC5udi1zZXJpZXMnIDogJ2NoYW5nZUNoYXJ0Q29sdW1ucydcbiAgICAgIH0pO1xuICB9LCAgIFxuICBjaGFuZ2VDaGFydENvbHVtbnM6IGZ1bmN0aW9uKGUpe1x0ICBcblx0ICB2YXIga2V5ID0gJChlLmN1cnJlbnRUYXJnZXQpLmZpbmQoJy5udi1sZWdlbmQtdGV4dCcpLnRleHQoKTtcdCBcblx0ICB2YXIgc3RhY2tlZExlZ2VuZFRybiA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtY2hhcnQtbGVnZW5kcy1TdGFja2VkXCIsXCJTdGFja2VkXCIpO1xuXHQgIHZhciBncm91cGVkTGVnZW5kVHJuID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6ZmlsdGVycy1jaGFydC1sZWdlbmRzLUdyb3VwZWRcIixcIkdyb3VwZWRcIik7XG5cdCAgaWYoa2V5ID09IHN0YWNrZWRMZWdlbmRUcm4gfHwga2V5ID09IGdyb3VwZWRMZWdlbmRUcm4pe1xuXHRcdCAgdGhpcy5tb2RlbC5zZXQoJ3N0YWNrZWQnLCAoa2V5ID09IHN0YWNrZWRMZWdlbmRUcm4gKSk7XHRcblx0ICB9ZWxzZXtcblx0XHQgIHZhciBzZXJpZXNUb0V4Y2x1ZGUgPSB0aGlzLm1vZGVsLmdldCgnc2VyaWVzVG9FeGNsdWRlJykgPyB0aGlzLm1vZGVsLmdldCgnc2VyaWVzVG9FeGNsdWRlJykgOiBbXTtcblx0XHQgIHZhciBpbmRleE9mS2V5SW5FeGNsdXNpb25MaXN0ID0gXy5pbmRleE9mKHNlcmllc1RvRXhjbHVkZSwga2V5KTtcblx0XHQgIGlmKCQoZS5jdXJyZW50VGFyZ2V0KS5hdHRyKCdjbGFzcycpLmluZGV4T2YoJ2Rpc2FibGVkJykgIT0gLTEpe1xuXHRcdFx0ICBpZihpbmRleE9mS2V5SW5FeGNsdXNpb25MaXN0ID09IC0xKXtcblx0XHRcdFx0ICBzZXJpZXNUb0V4Y2x1ZGUucHVzaChrZXkpO1xuXHRcdFx0ICB9XHRcdFx0ICBcblx0XHQgIH1lbHNle1xuXHRcdFx0ICBpZihpbmRleE9mS2V5SW5FeGNsdXNpb25MaXN0ICE9IC0xKXtcblx0XHRcdFx0ICBzZXJpZXNUb0V4Y2x1ZGUuc3BsaWNlKGluZGV4T2ZLZXlJbkV4Y2x1c2lvbkxpc3QsIDEpO1xuXHRcdFx0ICB9XG5cdFx0ICB9XG5cdFx0ICB0aGlzLm1vZGVsLnNldCgnc2VyaWVzVG9FeGNsdWRlJyxzZXJpZXNUb0V4Y2x1ZGUpO1xuXHQgIH1cdCBcbiAgfSxcbiAgY2hhcnRWaWV3czogW1xuICAgICdtdWx0aWJhcicsXG4gICAgJ3RhYmxlJ1xuICBdLFxuXG4gIGRvd25sb2FkQ2hhcnRPcHRpb25zOiB7XG4gICAgdHJpbUxhYmVsczogZmFsc2VcbiAgfSxcblxuICBnZXRUVENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgYXBwID0gdGhpcy5hcHA7XG4gICAgdmFyIG9mID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpvZicsJ29mJyk7XG4gICAgdmFyIHRvdGFsID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDp0b3RhbCcsJ3RvdGFsJyk7XG4gICAgdmFyIHVuaXRzID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhhcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllckRlc2NyaXB0aW9uKTtcblxuICAgIHZhciBhY3RpdmVUb29sdGlwVGl0bGVzID0gXy5maWx0ZXIoY29udGV4dC5kYXRhLCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgIHJldHVybiBzZXJpZXMuZGlzYWJsZWQgIT09IHRydWU7XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIHRvdGFsRm9yWWVhciA9IHRoaXMubW9kZWwuZ2V0KCd5ZWFyVG90YWxzJykgPyB0aGlzLm1vZGVsLmdldCgneWVhclRvdGFscycpW2NvbnRleHQueC5yYXcgXSA6IG51bGw7XG4gICAgdmFyIGQzRm9ybWF0VG90YWwgPSAnJywgdG90YWxTcGFuID0gJyc7XG4gICAgaWYodG90YWxGb3JZZWFyICYmIHRvdGFsRm9yWWVhciAhPSAwKXtcbiAgICBcdGQzRm9ybWF0VG90YWwgPSBkMy5mb3JtYXQoJyUnKShjb250ZXh0LnkucmF3IC8gdG90YWxGb3JZZWFyKTtcbiAgICAgICAgdG90YWxTcGFuID0gJyZuYnNwPHNwYW4+JyArIHRvdGFsICsgJzwvc3Bhbj4nO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbmN5TmFtZSA9IF8uZmluZChhcHAuc2V0dGluZ3MuZ2V0KCcxJykuZ2V0KCdvcHRpb25zJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbS5pZCA9PT0gc2VsZi5tb2RlbC5nZXQoJ2N1cnJlbmN5Jyl9KS52YWx1ZTsgIFxuICAgIHJldHVybiB7dHQ6IHtcbiAgICAgIGhlYWRpbmc6IGNvbnRleHQueC5yYXcgKyAnICcgKyBhY3RpdmVUb29sdGlwVGl0bGVzW2NvbnRleHQuc2VyaWVzLmluZGV4XS5rZXksXG4gICAgICBib2R5VGV4dDogJzxiPicgKyBjb250ZXh0LnkuZm10ICsgJzwvYj4gJyArIGN1cnJlbmN5TmFtZSArICcgKCcgKyB1bml0cyArICcpJyxcbiAgICAgIGZvb3RlclRleHQ6ICc8Yj4nICsgZDNGb3JtYXRUb3RhbCArICc8L2I+Jm5ic3A8c3Bhbj4nICsgb2YgKyAnPC9zcGFuPiZuYnNwJyArIGNvbnRleHQueC5yYXcgKyB0b3RhbFNwYW5cbiAgICB9fTtcbiAgfSxcblxuICBjaGFydENsaWNrSGFuZGxlcjogZnVuY3Rpb24oY29udGV4dCkge1xuICAgIC8vIGNsaWNraW5nIG9uIHRoZSBcIm90aGVyc1wiIGJhciBsb2FkcyBmaXZlIG1vcmUuXG4gICAgaWYgKGNvbnRleHQuZGF0YVtjb250ZXh0LnNlcmllcy5pbmRleF0uc3BlY2lhbCA9PT0gJ290aGVycycpIHtcbiAgICAgIHRoaXMubW9kZWwuc2V0KCdsaW1pdCcsIHRoaXMubW9kZWwuZ2V0KCdsaW1pdCcpICsgMSk7XG4gICAgfVxuICB9XG5cbn0pO1xuIiwidmFyIGQzID0gcmVxdWlyZSgnZDMnKTtcbnZhciBDaGFydFZpZXdCYXNlID0gcmVxdWlyZSgnLi9jaGFydC12aWV3LWJhc2UnKTtcbnZhciBNb2RhbFZpZXcgPSByZXF1aXJlKCcuL2NoYXJ0LXRvcHMtaW5mby1tb2RhbCcpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhcnRWaWV3QmFzZS5leHRlbmQoe1xuXG4gIHVpRGVmYXVsdHM6IHtcblx0YWRqdHlwZTogJ0ZBS0UnLFxuXHR4QXhpc0NvbHVtbjogJycsXG4gICAgc2hvd1RvdGFsOiBmYWxzZSxcbiAgICBzaG93TWVhc3VyZXNTZWxlY3RvcjogdHJ1ZSxcbiAgICBzaG93VG9wTGVnZW5kczogZmFsc2UsXG4gICAgc2hvd0NvbW1vbkNoYXJ0QXJlYTogZmFsc2UsXG4gICAgZGlzYWJsZVJlc2l6ZTogdHJ1ZVxuICB9LFxuICBcbiAgY2hhcnRWaWV3czogW1xuICAgICdoZWF0bWFwJyxcbiAgICAndGFibGUnICAgIFxuICBdLFxuICBcbiAgbW9kYWxWaWV3OiB1bmRlZmluZWQsXG4gIFxuICBjaGFydENsaWNrSGFuZGxlciA6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0ICBpZiAoY29udGV4dC55LmZtdCA9PT0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC1oZWF0bWFwLW90aGVycycpKSB7XG5cdFx0ICB0aGlzLm1vZGVsLnNldCgneUxpbWl0JywgdGhpcy5tb2RlbC5nZXQoJ3lMaW1pdCcpICsgMTApO1xuXHRcdCAgdGhpcy51cGRhdGVEYXRhKCk7XG5cdCAgfVxuICB9LFxuICBcbiAgZG93bmxvYWRDaGFydE9wdGlvbnM6IHtcbiAgICB0cmltTGFiZWxzOiBmYWxzZVxuICB9XG5cbn0pOyIsIlxyXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcclxudmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxzY3JpcHQgdHlwZT1cXFwidGV4dC9qYXZhc2NyaXB0XFxcIj5cXHJcXG5cXHRmdW5jdGlvbiBvcGVuUHJldmlld0FjdGl2aXR5KGlkKSB7XFxyXFxuXFx0XFx0d2luZG93Lm9wZW4oJy9haW0vdmlld0FjdGl2aXR5UHJldmlldy5kb35wdWJsaWM9dHJ1ZX5wYWdlSWQ9Mn5hY3Rpdml0eUlkPScgKyBpZCwgJ19ibGFuaycpO1xcclxcblxcdH1cXHJcXG48L3NjcmlwdD5cXHJcXG5cXHJcXG48ZGl2IGNsYXNzPSdjaGFydC10b3BzLWluZm8tY2F0ZWdvcnknPlxcclxcblxcdDxzcGFuPlxcclxcblxcdFxcdDxiPjwlPSAoY29udGV4dC54LmZtdCB8fCBjb250ZXh0LngucmF3KSAlPjwvYj4gLSA8JT0gbW9kZWwuZ2V0KCdhZGp0eXBlJyklPiAtICBcXHRcXHRcXHJcXG5cXHRcXHQ8c3BhbiBkYXRhLWkxOG49XFxcIjwlPSBhcHAuc2V0dGluZ3MubnVtYmVyTXVsdGlwbGllckRlc2NyaXB0aW9uICU+XFxcIj48L3NwYW4+XFxyXFxuXFx0XFx0PCU9IG1vZGVsLmdldCgnY3VycmVuY3knKSAlPlxcclxcblxcdDwvc3Bhbj5cXHJcXG48L2Rpdj5cXHJcXG48ZGl2IGNsYXNzPVxcXCJjaGFydC10b3BzLWluZm8tY29udGFpbmVyXFxcIj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJjaGFydC10b3BzLWluZm8tY29udGVudFxcXCI+XFxyXFxuXFx0XFx0PCUgaWYoZXJyb3IpIHsgJT5cXHJcXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXJcXFwiIHJvbGU9XFxcImFsZXJ0XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHQ8c3Ryb25nPjxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDplcnJvclxcXCI+RXJyb3I8L3NwYW4+PC9zdHJvbmc+XFxyXFxuXFx0XFx0XFx0XFx0PHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmVycm9yLWRldGFpbFxcXCI+VGhlIEFpZCBNYW5hZ2VtZW50IFBsYXRmb3JtIGhhcyB0ZW1wb3JhcmlseSBlbmNvdW50ZXJlZCBhbiBpc3N1ZS4gV2UgYXBvbG9naXplIGZvciBhbnkgaW5jb252ZW5pZW5jZS48L3NwYW4+XFxyXFxuXFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0PCUgfSBlbHNlIGlmKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7ICU+XFxyXFxuXFx0XFx0XFx0PGltZyBhbHQ9XFxcIlxcXCIgc3JjPVxcXCIvVEVNUExBVEUvYW1wVGVtcGxhdGUvZGFzaGJvYXJkL2J1aWxkL2ltZy9sb2FkaW5nLWljb24uZ2lmXFxcIj5cXHJcXG5cXHRcXHRcXHQ8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtcmVuZGVyaW5nXFxcIj5SZW5kZXJpbmcuLi48L3NwYW4+XFxyXFxuXFx0XFx0PCUgfSBlbHNlIHsgJT5cXHJcXG5cXHRcXHRcXHQ8JSB2YXIgcm93Q2xhc3MgPSAnJzsgJT5cXHJcXG5cXHRcXHRcXHQ8dGFibGU+XFxyXFxuXFx0XFx0XFx0XFx0PHRyPlxcclxcblxcdFxcdFxcdFxcdFxcdDx0aD48c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6Y2hhcnQtdG9wcy10YWJsZS1wcm9qZWN0dGl0bGVcXFwiPlByb2plY3QgVGl0bGU8L3NwYW4+PC90aD5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8dGg+PHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LXRvcHMtdGFibGUtYW1vdW50XFxcIj5BbW91bnQ8L3NwYW4+PC90aD5cXHJcXG5cXHRcXHRcXHRcXHQ8L3RyPlxcdFxcdFxcdFxcclxcblxcdFxcdFxcdDwlIF8odmFsdWVzKS5lYWNoKGZ1bmN0aW9uKHJvdywgaSkgeyAlPlxcclxcbiAgICAgICAgICBcXHRcXHQ8JSBcXHRpZiAoaSAlIDIgPT09IDApIHJvd0NsYXNzID0gJ29kZF9yb3cnO1xcclxcbiAgICBcXHRcXHRcXHRcXHRlbHNlIHJvd0NsYXNzID0gJyc7ICU+XFxyXFxuICAgIFxcdFxcdFxcdDx0ciBjbGFzcz1cXFwiPCU9cm93Q2xhc3MlPlxcXCI+XFxyXFxuICAgIFxcdFxcdFxcdFxcdDx0ZD5cXHJcXG4gICAgXFx0XFx0XFx0XFx0XFx0PHNwYW4gY2xhc3M9J3BvaW50ZXInIG9uY2xpY2s9J29wZW5QcmV2aWV3QWN0aXZpdHkoPCU9cm93LmlkJT4pJz48JT1yb3cubmFtZSU+PC9zcGFuPlxcclxcbiAgICBcXHRcXHRcXHRcXHQ8L3RkPlxcclxcbiAgICBcXHRcXHRcXHRcXHQ8dGQ+PCU9cm93LmZvcm1hdHRlZEFtb3VudCU+PC90ZD5cXHJcXG4gICAgXFx0XFx0XFx0PC90cj5cXHJcXG4gICAgICAgIFxcdDwlIH0pICU+XFxyXFxuICAgICAgICBcXHQ8L3RhYmxlPlxcclxcblxcdFxcdDwlIH0gJT5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5WaWV3LmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XHJcblx0XHR0aGlzLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XHJcblx0XHR0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcclxuXHRcdHRoaXMubnVtYmVyTXVsdGlwbGllciA9IGFwcC5zZXR0aW5ncy5maW5kKGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbS5pZCA9PT0gJ251bWJlci1tdWx0aXBsaWVyJ30pO1xyXG5cdH0sXHJcblxyXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHR0aGlzLiRlbC5odG1sKHRlbXBsYXRlKHtcclxuXHRcdFx0ZXJyb3I6IHVuZGVmaW5lZCxcclxuXHRcdFx0bW9kZWw6IHRoaXMubW9kZWwsXHJcblx0XHRcdGNvbnRleHQ6IHRoaXMuY29udGV4dCxcclxuXHRcdFx0dmFsdWVzOiB1bmRlZmluZWQsXHJcblx0XHRcdG51bWJlck11bHRpcGxpZXI6IHRoaXMubnVtYmVyTXVsdGlwbGllclxyXG5cdFx0fSkpO1xyXG5cdFx0YXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKCQoXCIuZGFzaC1zZXR0aW5ncy1tb2RhbFwiKSk7XHJcblx0XHRcclxuXHRcdC8vVE9ETzogbW92ZSB0aGlzIGNvZGUgdG8gYSBuZXcgbW9kZWwgc28gdGhlIEFQSSBjYWxsIGlzIG1hZGUgYXV0b21hdGljYWxseS5cclxuICAgIFx0dmFyIGNvbmZpZyA9IHRoaXMuYXBwLmZpbHRlci5zZXJpYWxpemUoKTtcclxuICAgIFx0Y29uZmlnLnNldHRpbmdzID0gdGhpcy5hcHAuc2V0dGluZ3MudG9BUEkoKTtcclxuICAgIFx0Y29uZmlnLnNldHRpbmdzWycwJ10gPSB0aGlzLm1vZGVsLmdldCgnYWRqdHlwZScpO1xyXG4gICAgXHQkLmFqYXgoe1xyXG4gICAgXHRcdG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgXHRcdHVybDogc2VsZi5tb2RlbC51cmwgKyAnLycgKyB0aGlzLmNvbnRleHQuZGF0YVswXS52YWx1ZXNbdGhpcy5jb250ZXh0LnguaW5kZXhdLmlkLFxyXG4gICAgXHRcdGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICBcdFx0Y29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgIFx0XHRwcm9jZXNzRGF0YTogZmFsc2UsXHJcbiAgICBcdFx0ZGF0YTogSlNPTi5zdHJpbmdpZnkoY29uZmlnKVxyXG4gICAgXHR9KS5kb25lKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIFx0XHQvL1RPRE86IENhbiB3ZSBhdm9pZCByZS1jYWxsaW5nIHRoZSB0ZW1wbGF0ZSBieSBiaW5kaW5nIHRoZSBjaGFuZ2VzIGluIHRoZSAndmFsdWVzJyBmaWVsZD8gXHJcbiAgICBcdFx0c2VsZi4kZWwuaHRtbCh0ZW1wbGF0ZSh7XHJcblx0XHRcdFx0ZXJyb3I6IHVuZGVmaW5lZCxcclxuICAgIFx0XHRcdG1vZGVsOiBzZWxmLm1vZGVsLFxyXG4gICAgXHRcdFx0Y29udGV4dDogc2VsZi5jb250ZXh0LFxyXG4gICAgXHRcdFx0dmFsdWVzOiBkYXRhLnZhbHVlcyxcclxuICAgIFx0XHRcdG51bWJlck11bHRpcGxpZXI6IHNlbGYubnVtYmVyTXVsdGlwbGllclxyXG4gICAgXHRcdH0pKTtcclxuICAgIFx0XHRhcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00oJChcIi5kYXNoLXNldHRpbmdzLW1vZGFsXCIpKTtcclxuICAgIFx0fSkuZmFpbChmdW5jdGlvbih4aHIsIGVycikge1xyXG5cdFx0XHR2YXIgbXNnID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KS5lcnJvcjtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIEdldHRpbmcgY2hhcnQtdG9wcy1pbmZvLW1vZGFsIGZyb20gRVBcIiwgbXNnKTtcclxuXHRcdFx0c2VsZi4kZWwuaHRtbCh0ZW1wbGF0ZSh7XHJcblx0XHRcdFx0bW9kZWw6IHNlbGYubW9kZWwsXHJcblx0XHRcdFx0Y29udGV4dDogc2VsZi5jb250ZXh0LFxyXG5cdFx0XHRcdGVycm9yOiBlcnIsXHJcblx0XHRcdFx0bnVtYmVyTXVsdGlwbGllcjogc2VsZi5udW1iZXJNdWx0aXBsaWVyXHJcblx0XHRcdH0pKTtcclxuXHRcdH0pO1xyXG4gICAgXHRcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG59KTsiLCJ2YXIgZDMgPSByZXF1aXJlKCdkMycpO1xudmFyIENoYXJ0Vmlld0Jhc2UgPSByZXF1aXJlKCcuL2NoYXJ0LXZpZXctYmFzZScpO1xudmFyIE1vZGFsVmlldyA9IHJlcXVpcmUoJy4vY2hhcnQtdG9wcy1pbmZvLW1vZGFsJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFydFZpZXdCYXNlLmV4dGVuZCh7XG5cbiAgdWlEZWZhdWx0czoge1xuICAgIGFkanR5cGU6ICdGQUtFJyxcbiAgICBzaG93VG90YWw6IHRydWUsXG4gICAgc2hvd01lYXN1cmVzU2VsZWN0b3I6IHRydWUsXG4gICAgc2hvd1RvcExlZ2VuZHM6IHRydWUsXG4gICAgc2hvd0NvbW1vbkNoYXJ0QXJlYTogdHJ1ZSAgICBcbiAgfSxcbiAgXG4gIGNoYXJ0Vmlld3M6IFtcblx0J2JhcicsXG4gICAgJ3BpZScsXG4gICAgJ3RhYmxlJyAgICBcbiAgXSxcbiAgXG4gIG1vZGFsVmlldzogdW5kZWZpbmVkLFxuICBcbiAgLy9Eb250IHRyeSB0byBjYWxsIGluaXRpYWxpemUgaGVyZSBiZWNhdXNlIGl0IHRocm93cyBhICdNb2R1bGUgaW5pdGlhbGl6YXRpb24gZXJyb3InIDooKFxuICAvKmluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICB0aGlzLm1vZGFsVmlldyA9IG5ldyBNb2RhbFZpZXcoeyBhcHA6IG9wdGlvbnMuYXBwLCBjb2xsZWN0aW9uOiB0aGlzLm1vZGVsLmNvbGxlY3Rpb24gfSk7XG4gIH0sKi9cblxuICBkb3dubG9hZENoYXJ0T3B0aW9uczoge1xuICAgIHRyaW1MYWJlbHM6IGZhbHNlXG4gIH0sXG5cbiAgZ2V0VFRDb250ZW50OiBmdW5jdGlvbihjb250ZXh0KSB7XG5cdHZhciBvZlRvdGFsID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6b2YtdG90YWxcIixcIm9mIHRvdGFsXCIpO1xuXHR2YXIgdW5pdHMgPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKGFwcC5zZXR0aW5ncy5udW1iZXJNdWx0aXBsaWVyRGVzY3JpcHRpb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVuY3lOYW1lID0gXy5maW5kKGFwcC5zZXR0aW5ncy5nZXQoJzEnKS5nZXQoJ29wdGlvbnMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLmlkID09PSBzZWxmLm1vZGVsLmdldCgnY3VycmVuY3knKX0pLnZhbHVlO1xuICAgIHZhciBwZXJjZW50YWdlID0gY29udGV4dC55LnJhdyA+IDAgP1xuICAgICAgICBkMy5mb3JtYXQoJyUnKShjb250ZXh0LnkucmF3IC8gdGhpcy5tb2RlbC5nZXQoJ3RvdGFsUG9zaXRpdmUnKSkgKyAnPC9iPiZuYnNwPHNwYW4+JyArIG9mVG90YWw6XG4gICAgICAgIFwiXCI7XG4gICAgcmV0dXJuIHt0dDoge1xuICAgICAgaGVhZGluZzogY29udGV4dC54LnJhdyxcbiAgICAgIGJvZHlUZXh0OiAnPGI+JyArIGNvbnRleHQueS5mbXQgKyAnPC9iPiAnICsgY3VycmVuY3lOYW1lICsgJyAoJyArIHVuaXRzICsgJyknLFxuICAgICAgZm9vdGVyVGV4dDogJzxiPicgKyBwZXJjZW50YWdlICsgJzwvc3Bhbj4nXG4gICAgfX07XG4gIH0sXG5cbiAgY2hhcnRDbGlja0hhbmRsZXI6IGZ1bmN0aW9uKGNvbnRleHQpIHtcdCAgXG4gICAgLy8gY2xpY2tpbmcgb24gdGhlIFwib3RoZXJzXCIgYmFyIGxvYWRzIGZpdmUgbW9yZS5cbiAgICBpZiAoY29udGV4dC5kYXRhW2NvbnRleHQuc2VyaWVzLmluZGV4XVxuICAgICAgICAgICAgICAgLnZhbHVlc1tjb250ZXh0LnguaW5kZXhdLnNwZWNpYWwgPT09ICdvdGhlcnMnKSB7XG4gICAgICB0aGlzLm1vZGVsLnNldCgnbGltaXQnLCB0aGlzLm1vZGVsLmdldCgnbGltaXQnKSArIDUpOyAgICAgIFxuICAgICAgICB0aGlzLm1vZGVsLnNldCgnYmlnJywgdHJ1ZSk7ICAgICAgXG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGVsLmdldCgnc2hvd0NhdGVnb3JpZXNJbmZvJykgPT09IHRydWUpIHsgICAgXHRcbiAgICBcdHRoaXMubW9kYWxWaWV3ID0gbmV3IE1vZGFsVmlldyh7IGFwcDogYXBwLCBjb250ZXh0OiBjb250ZXh0LCBtb2RlbDogdGhpcy5tb2RlbCB9KTtcbiAgICBcdHRoaXMub3BlbkluZm9XaW5kb3coKTsgICAgXHQgICAgXHRcbiAgICB9XG4gIH0sXG4gIFxuICBvcGVuSW5mb1dpbmRvdzogZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHNwZWNpYWxDbGFzcyA9ICdkYXNoLXNldHRpbmdzLW1vZGFsJztcblx0ICB0aGlzLmFwcC5tb2RhbCgnQ2F0ZWdvcnkgRGV0YWlsJywge1xuXHRcdCAgc3BlY2lhbENsYXNzOiBzcGVjaWFsQ2xhc3MsXG5cdCAgICAgIGJvZHlFbDogdGhpcy5tb2RhbFZpZXcucmVuZGVyKCkuZWwsXG5cdCAgICAgIGkxOG5UaXRsZTogJ2FtcC5kYXNoYm9hcmQ6ZGFzaGJvYXJkLWNoYXJ0LXRvcHMtaW5mby1tb2RhbCdcblx0ICB9KTtcdCAgICBcblx0ICAvLyBUcmFuc2xhdGUgbW9kYWwgcG9wdXAuXG5cdCAgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKCQoXCIuXCIgKyBzcGVjaWFsQ2xhc3MpKTtcbiAgfVxuXG59KTtcbiIsIlxudmFyIERlZmVycmVkID0gcmVxdWlyZSgnanF1ZXJ5JykuRGVmZXJyZWQ7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZURhc2ggPSByZXF1aXJlKCcuLi9iYWNrYm9uZS1kYXNoJyk7XG52YXIgZ2V0Q2hhcnQgPSByZXF1aXJlKCcuLi9jaGFydHMvY2hhcnQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdWdseS91dGlsJyk7XG52YXIgRG93bmxvYWRWaWV3ID0gcmVxdWlyZSgnLi9kb3dubG9hZCcpO1xudmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcImNvbC14cy0xMiA8JSBpZiAoIW1vZGVsLmdldCgnYmlnJykpIHsgJT5jb2wtbWQtNjwlIH0gZWxzZSB7ICU+IGJpZy1jaGFydC08JT0gbW9kZWwuZ2V0KCdiaWdOJyklPiA8JSB9ICU+XFxcIj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLWNoYXJ0XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZyBmaXgtdGl0bGUtaGVpZ2h0XFxcIj5cXG4gICAgICA8JSBpZiAobW9kZWwuZ2V0KCdzaG93VG90YWwnKSA9PT0gdHJ1ZSkgeyAlPlxcblxcdCAgICAgIDxzcGFuIGNsYXNzPVxcXCJwdWxsLXJpZ2h0IGJpZy1udW1iZXJcXFwiPlxcblxcdCAgICAgICAgPGIgY2xhc3M9XFxcImNoYXJ0LXRvdGFsXFxcIj48L2I+XFxuXFx0ICAgICAgICA8c3BhbiBjbGFzcz1cXFwiY2hhcnQtY3VycmVuY3lcXFwiPjwvc3Bhbj5cXG5cXHQgICAgICA8L3NwYW4+XFxuICAgICAgPCUgfSAlPlxcbiAgICAgIDxkaXY+XFxuXFx0ICAgICAgPGgyIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjaGFydC08JT0gbW9kZWwuZ2V0KCduYW1lJykucmVwbGFjZSgvIC9nLCcnKSAlPlxcXCI+PCU9IG1vZGVsLmdldCgndGl0bGUnKSAlPjwvaDI+XFxuXFx0ICAgICAgPCUgaWYgKG1vZGVsLmdldCgnY2hhcnRUeXBlJykgPT09ICdmcmFnbWVudGF0aW9uJykgeyAlPlxcblxcdCAgICAgIFxcdDwlIHZhciBoZWxwX2ljb25fdGV4dCA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtaGVhdG1hcC1oZWxwLXRleHQtJyArIG1vZGVsLmdldCgnaGVhdG1hcF90eXBlJykpOyU+XFxuXFx0ICAgICAgXFx0PGltZyBzcmM9XFxcIi9URU1QTEFURS9hbXBUZW1wbGF0ZS9kYXNoYm9hcmQvYnVpbGQvaW1nL3F1ZXN0aW9ubWFyazEucG5nXFxcIiBjbGFzcz1cXFwicXVlc3Rpb25fbWFyayBudi1zZXJpZXNcXFwiIGRhdGEtdGl0bGU9XFxcIjwlPSBoZWxwX2ljb25fdGV4dCAlPlxcXCI+XFxuXFx0ICAgICAgPCUgfSAlPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXHRcXG4gICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY2hhcnQtY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDxoMyBjbGFzcz1cXFwiZGFzaC1jaGFydC1kaWFnbm9zdGljIHRleHQtY2VudGVyXFxcIj48L2gzPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZGFzaC1jaGFydC13cmFwIDwlPSAobW9kZWwuZ2V0KCdhbHRlcm5hdGl2ZUNvbnRhaW5lckNsYXNzJykgIT09IHVuZGVmaW5lZCA/IG1vZGVsLmdldCgnYWx0ZXJuYXRpdmVDb250YWluZXJDbGFzcycpIDogJycpJT5cXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGluayBidG4teHMgcHVsbC1yaWdodCByZXNldFxcXCIgc3R5bGU9XFxcImRpc3BsYXk6bm9uZVxcXCIgZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LXJlc2V0XFxcIj5yZXNldCBvdGhlcnM8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC13YXJuaW5nIG5lZ2F0aXZlLXZhbHVlcy1tZXNzYWdlXFxcIiByb2xlPVxcXCJhbGVydFxcXCI+XFxuICAgICAgICAgIDxzdHJvbmcgZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOm5lZ2F0aXZlcy12YWx1ZXNcXFwiPk5lZ2F0aXZlIHZhbHVlcyBhcmUgbm90IHJlcHJlc2VudGVkIGluIHRoaXMgY2hhcnQuPC9zdHJvbmc+PGJyPlxcbiAgICAgICAgICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6bmVnYXRpdmVzLXZhbHVlcy1wYXJhZ1xcXCI+UGxlYXNlIHN3aXRjaCB0byBiYXIgY2hhcnQgb3IgdGFibGUgdmlldyB0byB2aWV3IGFsbCB2YWx1ZXMuPC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtZm9vdGVyIGNsZWFyZml4XFxcIj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cFxcXCI+XFxuICAgICAgICAgIDwlIF8odmlld3MpLmVhY2goZnVuY3Rpb24odmlldykgeyAlPlxcbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBkYXRhLXZpZXc9XFxcIjwlPSB2aWV3ICU+XFxcIlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwiY2hhcnQtdmlldyBidG4gYnRuLXNtIGJ0bi08JT0gKHZpZXcgPT09IG1vZGVsLmdldCgndmlldycpKSA/ICdwcmltYXJ5JyA6ICdkZWZhdWx0JyAlPlxcXCI+XFxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi08JT0ge1xcbiAgICAgICAgICAgICAgICBiYXI6ICdzaWduYWwnLFxcbiAgICAgICAgICAgICAgICBtdWx0aWJhcjogJ3NpZ25hbCcsXFxuICAgICAgICAgICAgICAgIGhlYXRtYXA6ICdzdGF0cycsXFxuICAgICAgICAgICAgICAgIHBpZTogJ2FkanVzdCcsXFxuICAgICAgICAgICAgICAgIHRhYmxlOiAndGgtbGlzdCdcXG4gICAgICAgICAgICAgIH1bdmlld10gJT5cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgPCUgfSkgJT5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwXFxcIj5cXG4gICAgICAgICAgPGFcXG4gICAgICAgICAgICBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tZGVmYXVsdCBkb3dubG9hZFxcXCJcXG4gICAgICAgICAgICBkb3dubG9hZD1cXFwiQU1QIDwlPSBtb2RlbC5nZXQoJ3RpdGxlJykgJT4gLSA8JT0gKG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSAlPi5wbmdcXFwiXFxuICAgICAgICAgICAgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNsb3VkLWRvd25sb2FkXFxcIj48L3NwYW4+XFxuICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi08JT0gbW9kZWwuZ2V0KCdiaWcnKSA/ICdwcmltYXJ5JyA6ICdkZWZhdWx0JyAlPiBleHBhbmQgaGlkZGVuLXhzIGhpZGRlbi1zbVxcXCIgPCU9IG1vZGVsLmdldCgnZGlzYWJsZVJlc2l6ZScpID8gJ2Rpc2FibGVkJyA6ICcnJT4+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tZnVsbHNjcmVlblxcXCI+PC9zcGFuPlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgIDwvZGl2PjwhLS0gYnV0dG9ucyBpbiAucHVsbC1yaWdodCAtLT5cXG5cXG4gICAgICA8JSBpZiAobW9kZWwuZ2V0KCdhZGp0eXBlJykgJiYgbW9kZWwuZ2V0KCdzaG93TWVhc3VyZXNTZWxlY3RvcicpID09PSB0cnVlKSB7ICU+XFxuICAgICAgICA8Zm9ybSBjbGFzcz1cXFwiZm9ybS1pbmxpbmUgZGFzaC1mb3JtIGRhc2gtYWRqLXR5cGVcXFwiIHJvbGU9XFxcImZvcm1cXFwiPlxcbiAgICAgICAgICA8c2VsZWN0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgbGlrZS1idG4tc20gZnR5cGUtb3B0aW9uc1xcXCI+XFxuICAgICAgICAgICAgPG9wdGlvbj4uLi48L29wdGlvbj5cXG4gICAgICAgICAgICA8IS0tIGdldHMgcG9wdWxhdGVkIGFmdGVyIHNldHRpbmdzIGxvYWQgLS0+XFxuICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiY2hlYXQtbGluZWhlaWdodFxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9mb3JtPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgICBcXG4gICAgICA8JSBpZiAobW9kZWwuZ2V0KCdjaGFydFR5cGUnKSA9PT0gJ2ZyYWdtZW50YXRpb24nKSB7ICU+XFxuXFx0XFx0PGZvcm0gY2xhc3M9XFxcImZvcm0taW5saW5lIGRhc2gtZm9ybSBkYXNoLXhheGlzLW9wdGlvbnNcXFwiIHJvbGU9XFxcImZvcm1cXFwiPlxcbiAgICAgICAgXFx0PHNlbGVjdCBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGxpa2UtYnRuLXNtIHhheGlzLW9wdGlvbnNcXFwiPlxcbiAgICAgICAgICAgIFxcdDxvcHRpb24+Li4uPC9vcHRpb24+XFxuICAgICAgICAgICAgXFx0PCEtLSBnZXRzIHBvcHVsYXRlZCBhZnRlciBzZXR0aW5ncyBsb2FkIC0tPlxcbiAgICAgICAgICBcXHQ8L3NlbGVjdD5cXG4gICAgICAgICAgXFx0PHNwYW4gY2xhc3M9XFxcImNoZWF0LWxpbmVoZWlnaHRcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvZm9ybT5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tZGVmYXVsdCBoZWF0bWFwLXN3aXRjaFxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LXN3YXAtYXhlc1xcXCI+U3dhcCBBeGVzPC9zcGFuPlxcbiAgICAgICAgPC9idXR0b24+XFxuXFx0IDwlIH0gJT5cXG5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcImV4cG9ydC1tb2RhbFxcXCI+PC9kaXY+XFxuPC9kaXY+XCIpO1xuXG5cbnZhciBhZGpPcHRUZW1wbGF0ZSA9IF8udGVtcGxhdGUoJzxvcHRpb24gdmFsdWU9XCI8JT1vcHQuaWQlPlwiICcgK1xuICAnPCU9IGN1cnJlbnQgPyBzZWxlY3RlZD1cInNlbGVjdGVkXCIgOiBcXCdcXCcgJT4+PCU9b3B0Lm5hbWUlPjwvb3B0aW9uPicpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcblxuICB1aURlZmF1bHRzOiB7XG4gICAgYmlnOiBmYWxzZSxcbiAgICB2aWV3OiAnYmFyJ1xuICB9LFxuXG4gIGV2ZW50czoge1xuICAgICdjaGFuZ2UgLmRhc2gtYWRqLXR5cGUgc2VsZWN0JzogJ2NoYW5nZUFkalR5cGUnLFxuICAgICdjaGFuZ2UgLmRhc2gteGF4aXMtb3B0aW9ucyBzZWxlY3QnOiAnY2hhbmdlWEF4aXMnLFxuICAgICdjbGljayAucmVzZXQnOiAncmVzZXRMaW1pdCcsXG4gICAgJ2NsaWNrIC5jaGFydC12aWV3JzogJ2NoYW5nZUNoYXJ0VmlldycsXG4gICAgJ2NsaWNrIC5kb3dubG9hZCc6ICdkb3dubG9hZCcsXG4gICAgJ2NsaWNrIC5leHBhbmQnOiAnYmlnJyxcbiAgICAnY2xpY2sgLnJldHJ5JzogJ3JlbmRlcicsXG4gICAgJ2NsaWNrIC5oZWF0bWFwLXN3aXRjaCc6ICdoZWF0bWFwU3dpdGNoQXhpcydcbiAgfSxcblxuICBjaGFydFZpZXdzOiBbXG4gICAgJ2JhcicsXG4gICAgJ3BpZScsXG4gICAgJ2hlYXRtYXAnLFxuICAgICd0YWJsZScgICAgXG4gIF0sICBcbiAgXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICAgIHRoaXMubW9kZWwuc2V0KHRoaXMudWlEZWZhdWx0cyk7XG4gICAgdGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXRlV2FpdCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHRoaXMubWVzc2FnZSA9IG51bGw7XG4gICAgdGhpcy5zaG93Q2hhcnRQcm9taXNlID0gbmV3IERlZmVycmVkKCk7XG4gICAgdGhpcy5yZW5kZXJlZFByb21pc2UgPSBuZXcgRGVmZXJyZWQoKTtcblxuICAgIGlmICh0aGlzLmFwcC5zYXZlZERhc2hlcy5sZW5ndGgpIHtcbiAgICAgIC8vIGEgYml0IHNrZXRjaC4uLi5cbiAgICAgIHRoaXMuYXBwLnN0YXRlLmxvYWRQcm9taXNlLmFsd2F5cyh0aGlzLl9zdGF0ZVdhaXQucmVzb2x2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YXRlV2FpdC5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmFwcC5maWx0ZXIsICdhcHBseScsIHRoaXMudXBkYXRlRGF0YSk7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmFwcC5zZXR0aW5ncywgJ2NoYW5nZScsIHRoaXMudXBkYXRlRGF0YSk7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOmFkanR5cGUnLCB0aGlzLnJlbmRlcik7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOnhBeGlzQ29sdW1uJywgdGhpcy5yZW5kZXIpO1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZTpsaW1pdCcsIHRoaXMudXBkYXRlRGF0YSk7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlOnZpZXcnLCB0aGlzLnJlbmRlcik7XG5cbiAgICB0aGlzLmFwcC5zdGF0ZS5yZWdpc3Rlcih0aGlzLCAnY2hhcnQ6JyArIHRoaXMubW9kZWwudXJsLCB7XG4gICAgICBnZXQ6IF8ucGFydGlhbChfKHRoaXMubW9kZWwucGljaykuYmluZCh0aGlzLm1vZGVsKSwgJ2xpbWl0JywgJ2FkanR5cGUnLCAneEF4aXNDb2x1bW4nLCAndmlldycsICdiaWcnLCdzdGFja2VkJywnc2hvd1BsYW5uZWREaXNidXJzZW1lbnRzJywnc2hvd0FjdHVhbERpc2J1cnNlbWVudHMnLCdzZXJpZXNUb0V4Y2x1ZGUnLCAneExpbWl0JywgJ3lMaW1pdCcsICdzd2FwQXhlcycpLFxuICAgICAgc2V0OiBfKHRoaXMubW9kZWwuc2V0KS5iaW5kKHRoaXMubW9kZWwpLFxuICAgICAgZW1wdHk6IG51bGxcbiAgICB9KTtcblxuICAgIF8uYmluZEFsbCh0aGlzLCAnc2hvd0NoYXJ0JywgJ2ZhaWxMb2FkaW5nJywnaGlkZUV4cG9ydEluUHVibGljVmlldycpO1xuICAgIGlmICh0aGlzLmdldFRUQ29udGVudCkgeyBfLmJpbmRBbGwodGhpcywgJ2dldFRUQ29udGVudCcpOyB9XG4gICAgaWYgKHRoaXMuY2hhcnRDbGlja0hhbmRsZXIpIHsgXy5iaW5kQWxsKHRoaXMsICdjaGFydENsaWNrSGFuZGxlcicpOyB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR0aGlzLnJlbmRlcmVkUHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHZhciByZW5kZXJPcHRpb25zID0ge1xuICAgICAgdmlld3M6IHRoaXMuY2hhcnRWaWV3cyxcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgY2hhcnQ6IHRoaXMuY2hhcnRFbCxcbiAgICAgIHV0aWw6IHV0aWxcbiAgICB9O1xuICAgIFxuICAgICQud2hlbih0aGlzLl9zdGF0ZVdhaXQsIHRoaXMuYXBwLmZpbHRlci5sb2FkZWQsIHRoaXMuYXBwLnRyYW5zbGF0b3IucHJvbWlzZSkuZG9uZShmdW5jdGlvbigpIHtcbiAgICBcdHNlbGYuJGVsLmh0bWwodGVtcGxhdGUocmVuZGVyT3B0aW9ucykpO1xuICAgIFx0c2VsZi5oaWRlRXhwb3J0SW5QdWJsaWNWaWV3KCk7XG4gICAgXHRzZWxmLm1lc3NhZ2UgPSBzZWxmLiQoJy5kYXNoLWNoYXJ0LWRpYWdub3N0aWMnKTtcbiAgICBcdHNlbGYuY2hhcnRDb250YWluZXIgPSBzZWxmLiQoJy5kYXNoLWNoYXJ0LXdyYXAnKTtcblx0XG5cdCAgICBpZiAoc2VsZi5tb2RlbC5nZXQoJ2FkanR5cGUnKSAhPT0gdm9pZCAwKSB7ICAvLyB0aGlzIGNoYXJ0IGhhcyBhZGogc2V0dGluZ3Ncblx0ICAgIFx0c2VsZi5hcHAuc2V0dGluZ3MubG9hZCgpLmRvbmUoXyhmdW5jdGlvbigpIHtcblx0ICAgIFx0c2VsZi5yZW5kZXJlZCA9IHRydWU7XG5cdCAgICAgICAgdmFyIGFkalNldHRpbmdzID0gc2VsZi5hcHAuc2V0dGluZ3MuZ2V0KCcwJyk7ICAvLyBpZCBmb3IgRnVuZGluZyBUeXBlXG5cdCAgICAgICAgaWYgKCFhZGpTZXR0aW5ncykgeyBcblx0ICAgICAgICBcdHNlbGYuYXBwLnJlcG9ydCgnQ291bGQgbm90IGZpbmQgRnVuZGluZyBUeXBlIHNldHRpbmdzJyk7IFxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgXHRpZiAoc2VsZi5tb2RlbC5nZXQoJ2FkanR5cGUnKSA9PT0gJ0ZBS0UnKSB7XG5cdCAgICAgICAgXHRcdHNlbGYubW9kZWwuc2V0KCdhZGp0eXBlJywgYWRqU2V0dGluZ3MuZ2V0KCdkZWZhdWx0SWQnKSk7XG5cdCAgICAgICAgXHR9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHNlbGYuJCgnLmZ0eXBlLW9wdGlvbnMnKS5odG1sKFxuXHQgICAgICAgICAgXyhhZGpTZXR0aW5ncy5nZXQoJ29wdGlvbnMnKSkubWFwKGZ1bmN0aW9uKG9wdCkge1xuXHQgICAgICAgICAgICByZXR1cm4gYWRqT3B0VGVtcGxhdGUoe1xuXHQgICAgICAgICAgICAgIG9wdDogb3B0LFxuXHQgICAgICAgICAgICAgIGN1cnJlbnQ6IChvcHQuaWQgPT09IHRoaXMubW9kZWwuZ2V0KCdhZGp0eXBlJykpXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgfSwgc2VsZilcblx0ICAgICAgICApO1xuXHQgICAgICB9KS5iaW5kKHNlbGYpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdHNlbGYucmVuZGVyZWQgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgXG5cdCAgICAvLyBGb3IgaGVhdG1hcHMgYWRkIHNvbWUgZXh0cmEgY29tYm9zLlxuXHQgICAgaWYgKHNlbGYubW9kZWwuZ2V0KCdjaGFydFR5cGUnKSA9PT0gJ2ZyYWdtZW50YXRpb24nKSB7XG5cdCAgICBcdHZhciBoZWF0TWFwQ29uZmlncyA9IHNlbGYubW9kZWwuZ2V0KCdoZWF0bWFwX2NvbmZpZycpLm1vZGVsc1swXTtcblx0ICAgIFx0dmFyIHRoaXNIZWF0TWFwQ2hhcnQgPSBfLmZpbmQoaGVhdE1hcENvbmZpZ3MuZ2V0KCdjaGFydHMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLm5hbWUgPT09IHNlbGYubW9kZWwuZ2V0KCduYW1lJyl9KTtcblx0ICAgIFx0c2VsZi4kKCcueGF4aXMtb3B0aW9ucycpLmh0bWwoXG5cdCAgICBcdFx0Xyh0aGlzSGVhdE1hcENoYXJ0LnhDb2x1bW5zKS5tYXAoZnVuY3Rpb24oY29sSWQpIHtcblx0ICAgIFx0XHRcdHZhciBpdGVtID0gXy5maW5kKGhlYXRNYXBDb25maWdzLmdldCgnY29sdW1ucycpLCBmdW5jdGlvbihpdGVtLCBpKSB7IHJldHVybiBpID09PSBjb2xJZH0pO1xuXHQgICAgXHRcdFx0dmFyIG9wdCA9IHtpZDogaXRlbS5vcmlnTmFtZSwgbmFtZTogaXRlbS5uYW1lLCBzZWxlY3RlZDogZmFsc2UsIHZhbHVlOiBpdGVtLm9yaWdOYW1lfTtcblx0ICAgIFx0XHRcdHJldHVybiBhZGpPcHRUZW1wbGF0ZSh7XG5cdCAgICBcdFx0XHRcdG9wdDogb3B0LFxuXHQgICAgXHQgICAgICAgICAgICBjdXJyZW50OiAob3B0LmlkID09PSB0aGlzLm1vZGVsLmdldCgneEF4aXNDb2x1bW4nKSlcblx0ICAgIFx0ICAgICAgICB9KTtcblx0ICAgIFx0ICAgIH0sIHNlbGYpXG5cdCAgICBcdCk7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKHNlbGYuX3N0YXRlV2FpdC5zdGF0ZSgpICE9PSAncGVuZGluZycpIHtcblx0ICAgIFx0c2VsZi51cGRhdGVEYXRhKCk7XG5cdCAgICB9XG5cdFxuXHQgICAgc2VsZi5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00oc2VsZi5lbCk7XG5cdCAgICBzZWxmLnJlbmRlcmVkUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdXBkYXRlRGF0YTogZnVuY3Rpb24oKSB7XG5cdGlmKHRoaXMuYXBwLnJlbmRlcmVkICE9PSB0cnVlKSB7IHJldHVybjsgfSAgXG4gICAgaWYgKCF0aGlzLnJlbmRlcmVkKSB7IHJldHVybjsgfSAgLy8gc2hvcnQtY2lyY3VpdCBvbiBlYXJseSBmaWx0ZXJzIGFwcGx5IGV2ZW50XG4gICAgaWYgKHRoaXMuX3N0YXRlV2FpdC5zdGF0ZSgpID09PSAncGVuZGluZycpIHsgIC8vIHNob3J0LWNpcmN1aXQgdW50aWwgd2UgaGF2ZSBzdGF0ZVxuICAgICAgdGhpcy5tZXNzYWdlLmh0bWwoJ0xvYWRpbmcuLi4nKS5hdHRyKCdkYXRhLWkxOG4nLCAnYW1wLmRhc2hib2FyZDpjaGFydC1sb2FkaW5nLXNhdmVkLXNldHRpbmdzJyk7XG4gICAgICBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00oJCgnLmNoYXJ0LWNvbnRhaW5lcicpKTtcbiAgICAgIC8vdGhpcy5tZXNzYWdlLmZhZGVJbigxMDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2hvd0NoYXJ0UHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpOyAvLyBXZSBuZWVkIHRvIHJlaW5pdGlhbGl6ZSB0aGlzIHByb21pc2UuXG4gICAgdGhpcy5jaGFydENvbnRhaW5lci5lbXB0eSgpO1xuICAgIHRoaXMubWVzc2FnZS5odG1sKCc8c3BhbiBkYXRhLWkxOG49XCJhbXAuZGFzaGJvYXJkOmxvYWRpbmdcIj5Mb2FkaW5nLi4uPC9zcGFuPicpLmZhZGVJbigxMDApO1xuXG4gICAgdGhpcy5hcHAudHJhbnNsYXRvci5nZXRUcmFuc2xhdGlvbnMoKVxuICAgICAgLmRvbmUoXyhmdW5jdGlvbigpIHsgIC8vIGRlZmVyIGhlcmUgdG8gcHJldmVudCBhIHJhY2Ugd2l0aCB0cmFuc2xhdGlvbnMgbG9hZGluZ1xuXG4gICAgICAgIC8qIFRPRE86IERvIHdlIHJlYWxseSB3YW50IHRvIGxvY2FsaXplIHRoaXMgYW5kIHNsb3cgdGhpbmdzPyovXG4gICAgICAgIC8vdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00odGhpcy5lbCk7XG5cbiAgICAgICAgdGhpcy5tb2RlbC5mZXRjaCh7XG4gICAgICAgICAgdHlwZTogJ1BPU1QnLCAgLy8gVE9ETzogbW92ZSBmZXRjaCBvcHRpb25zIHRvIG1vZGVsP1xuICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHRoaXMuYXBwLmZpbHRlci5zZXJpYWxpemUoKSlcbiAgICAgICAgfSlcbiAgICAgICAgLmFsd2F5cyhfKGZ1bmN0aW9uKCkgeyAgfSkuYmluZCh0aGlzKSlcbiAgICAgICAgLmRvbmUodGhpcy5zaG93Q2hhcnQpXG4gICAgICAgIC5mYWlsKHRoaXMuZmFpbExvYWRpbmcpO1xuICAgICAgfSkuYmluZCh0aGlzKSlcbiAgICAgIC5mYWlsKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYXBwLnJlcG9ydCgnQ291bGQgbm90IGxvYWQgdHJhbnNsYXRpb25zJywgW1xuICAgICAgICAgICdSZWZyZXNoaW5nIHRoZSBwYWdlIG1heSBmaXggdGhlIGlzc3VlLiddKTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuXG4gIH0sXG5cbiAgc2hvd0NoYXJ0OiBmdW5jdGlvbigpIHtcblx0ICB0aGlzLnNob3dOZWdhdGl2ZUFsZXJ0KCk7XG5cdCAgXG4gICAgLy8gVE9ETzogd2h5IGFyZSB3ZSB0cmlnZ2VyaW5nIHR3aWNlIG9uIGxvYWQ/Pz9cbiAgICBpZiAoIXRoaXMubW9kZWwuaGFzRGF0YSgpKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UuaHRtbCgnTm8gRGF0YSBBdmFpbGFibGUnKS5hdHRyKCdkYXRhLWkxOG4nLCdhbXAuZGFzaGJvYXJkOmNoYXJ0LW5vLWRhdGEtYXZhaWxhYmxlJyk7XG4gICAgICBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVET00oJCgnLmNoYXJ0LWNvbnRhaW5lcicpKTtcbiAgICAgIHRoaXMucmVzZXROdW1iZXJzKCk7XG4gICAgICByZXR1cm47XG4gICAgfSAgICBcbiAgICB2YXIgY2hhcnQgPSBnZXRDaGFydCh0aGlzLm1vZGVsLmdldCgndmlldycpLCB0aGlzLm1vZGVsLmdldCgncHJvY2Vzc2VkJyksIHRoaXMuZ2V0Q2hhcnRPcHRpb25zKCksIHRoaXMubW9kZWwpO1xuICAgIHRoaXMuY2hhcnRDb250YWluZXIuaHRtbChjaGFydC5lbCk7XG5cbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2NoYXJ0VHlwZScpICE9PSAnZnJhZ21lbnRhdGlvbicpIHtcbiAgICBcdHRoaXMucmVuZGVyTnVtYmVycygpO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2NoYXJ0VHlwZScpICE9PSAnZnJhZ21lbnRhdGlvbicpIHtcblx0ICAgIHZhciBsaW1pdCA9IHRoaXMubW9kZWwuZ2V0KCdsaW1pdCcpO1xuXHQgICAgaWYgKGxpbWl0KSB7XG5cdCAgICAgIHRoaXMuJCgnLnJlc2V0JylbbGltaXQgPT09IHRoaXMubW9kZWwuZGVmYXVsdHMubGltaXQgPyAnaGlkZScgOiAnc2hvdyddKCk7XG5cdCAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdzaG93UmVzZXRCdXR0b24nKSkge1xuICAgICAgICBcdHRoaXMuJCgnLnJlc2V0Jykuc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICBcdHRoaXMuJCgnLnJlc2V0JykuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZS5zdG9wKCkuZmFkZU91dCgyMDApO1xuICAgIFxuICAgIHRoaXMuYmVhdXRpZnlMZWdlbmRzKHRoaXMpO1xuICAgIFxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgndmlldycpID09PSAnaGVhdG1hcCcpIHtcbiAgICBcdHRoaXMuaGFuZGxlSGVhdG1hcENsaWNrcygpO1xuICAgIH1cbiAgICAgICAgXG4gICAgdGhpcy5zaG93Q2hhcnRQcm9taXNlLnJlc29sdmUoKTtcbiAgfSxcbiAgXG4gIGhhbmRsZUhlYXRtYXBDbGlja3M6IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgb3RoZXJzID0gdGhpcy4kKFwiLmxlZ2VuZC1vdGhlcnNcIik7XG5cdCAgaWYgKG90aGVycykge1xuXHRcdCAgJChvdGhlcnMpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2dCkge1xuXHRcdFx0ICBzZWxmLm1vZGVsLnNldCgneUxpbWl0Jywgc2VsZi5tb2RlbC5nZXQoJ3lMaW1pdCcpICsgc2VsZi5tb2RlbC5nZXQoJ29yaWdpbmFsWUxpbWl0JykpO1xuXHRcdFx0ICBzZWxmLnVwZGF0ZURhdGEoKTtcblx0XHQgIH0pO1xuXHQgIH1cbiAgfSxcbiAgXG4gIHNob3dOZWdhdGl2ZUFsZXJ0OiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLm1vZGVsLmdldCgndmlldycpID09PSAncGllJyAmJiBfLmZpbmQodGhpcy5tb2RlbC5nZXQoJ3Byb2Nlc3NlZCcpWzBdLnZhbHVlcywgZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS55IDwgMDt9KSkge1xuICAgICAgdGhpcy4kKCcubmVnYXRpdmUtdmFsdWVzLW1lc3NhZ2UnKS5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJCgnLm5lZ2F0aXZlLXZhbHVlcy1tZXNzYWdlJykuaGlkZSgpO1xuICAgIH1cbiAgfSxcblxuICBnZXRDaGFydE9wdGlvbnM6IGZ1bmN0aW9uKCkge1x0ICBcbiAgICB2YXIgY28gPSBfKF8odGhpcy5jaGFydE9wdGlvbnMpLmNsb25lKCkgfHwge30pLmRlZmF1bHRzKHtcbiAgICAgIHRyaW1MYWJlbHM6ICF0aGlzLm1vZGVsLmdldCgnYmlnJyksXG4gICAgICBnZXRUVENvbnRlbnQ6IHRoaXMuZ2V0VFRDb250ZW50LFxuICAgICAgY2xpY2tIYW5kbGVyOiB0aGlzLmNoYXJ0Q2xpY2tIYW5kbGVyLFxuICAgICAgd2lkdGg6IHRoaXMuJCgnLnBhbmVsLWJvZHknKS53aWR0aCgpLFxuICAgICAgaGVpZ2h0OiB0aGlzLiQoJy5wYW5lbC1ib2R5JykuaGVpZ2h0KClcbiAgICAgIFxuICAgIH0pO1xuICAgIGlmKHRoaXMubW9kZWwuZ2V0KCd2aWV3JykgPT0gJ211bHRpYmFyJyl7XG4gIFx0ICBjby5zdGFja2VkID0gdGhpcy5tb2RlbC5nZXQoJ3N0YWNrZWQnKTtcbiAgXHR9XG4gICAgY28ubW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgIHJldHVybiBjbztcbiAgfSxcblxuICBmYWlsTG9hZGluZzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tZXNzYWdlLmh0bWwoJ0ZhaWxlZCB0byBsb2FkIGRhdGEgPHNtYWxsPicgKyBhcmd1bWVudHNbMl0gK1xuICAgICAgJyA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInJldHJ5IGJ0biBidG4td2FybmluZyBidG4tc21cIj4nICtcbiAgICAgICc8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tcmVmcmVzaFwiPjwvc3Bhbj4gUmV0cnk8L2J1dHRvbj48L3NtYWxsPicpLnNob3coKTtcbiAgICBjb25zb2xlLmVycm9yKCdmYWlsZWQgbG9hZGluZyBjaGFydCA6KCcsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgcmVuZGVyTnVtYmVyczogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCd0b3RhbCcpKSB7XG4gICAgXHR0aGlzLiQoJy5jaGFydC10b3RhbCcpLmh0bWwodXRpbC50cmFuc2xhdGVMYW5ndWFnZSh0aGlzLm1vZGVsLmdldCgnc3VtYXJpemVkVG90YWwnKSkpOyAvLyB0aGlzIHNoYWxsIHVzZSB0aGUgZm9ybWF0IGZyb20gdGhlIHNlcnZlciBhbmQgdHJhbnNsYXRlIGl0IGluIHRoZSBmcm9udCBlbmRcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjdXJyZW5jeU5hbWUgPSBfLmZpbmQoYXBwLnNldHRpbmdzLmdldCgnMScpLmdldCgnb3B0aW9ucycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0uaWQgPT09IHNlbGYubW9kZWwuZ2V0KCdjdXJyZW5jeScpfSkudmFsdWU7XG4gICAgdGhpcy4kKCcuY2hhcnQtY3VycmVuY3knKS5odG1sKGN1cnJlbmN5TmFtZSk7XG4gIH0sXG5cbiAgcmVzZXROdW1iZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiQoJy5jaGFydC10b3RhbCcpLmh0bWwoJycpO1xuICAgIHRoaXMuJCgnLmNoYXJ0LWN1cnJlbmN5JykuaHRtbCgnJyk7XG4gIH0sXG5cbiAgcmVzZXRMaW1pdDogZnVuY3Rpb24oKSB7XG5cdCAgaWYgKHRoaXMubW9kZWwuZ2V0KCdjaGFydFR5cGUnKSA9PT0gJ2ZyYWdtZW50YXRpb24nKSB7XG5cdFx0ICB0aGlzLm1vZGVsLnNldCgneUxpbWl0JywgdGhpcy5tb2RlbC5nZXQoJ29yaWdpbmFsWUxpbWl0JykpO1xuXHRcdCAgdGhpcy51cGRhdGVEYXRhKCk7XG5cdCAgfSBlbHNlIHtcblx0XHQgIHRoaXMubW9kZWwuc2V0KCdsaW1pdCcsIHRoaXMubW9kZWwuZGVmYXVsdHMubGltaXQpO1xuXHQgIH1cbiAgfSxcblxuICBjaGFuZ2VBZGpUeXBlOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG5ld1R5cGUgPSBlLmN1cnJlbnRUYXJnZXQudmFsdWU7XG4gICAgdGhpcy5tb2RlbC5zZXQoJ2FkanR5cGUnLCBuZXdUeXBlKTtcbiAgfSxcbiAgXG4gIGNoYW5nZVhBeGlzOiBmdW5jdGlvbihlKSB7XG5cdCAgdmFyIG5ld1R5cGUgPSBlLmN1cnJlbnRUYXJnZXQudmFsdWU7XG5cdCAgdGhpcy5tb2RlbC5zZXQoJ3hBeGlzQ29sdW1uJywgbmV3VHlwZSk7XG4gIH0sICBcblxuICBjaGFuZ2VDaGFydFZpZXc6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdmlldyA9IHV0aWwuZGF0YShlLmN1cnJlbnRUYXJnZXQsICd2aWV3Jyk7XG4gICAgdGhpcy5tb2RlbC5zZXQoJ3ZpZXcnLCB2aWV3KTtcbiAgICB0aGlzLmhpZGVFeHBvcnRJblB1YmxpY1ZpZXcoKTtcbiAgfSxcbiAgaGlkZUV4cG9ydEluUHVibGljVmlldzogZnVuY3Rpb24oKXtcblx0ICB2YXIgZWRpdGFibGVEYXRhRXhwb3J0U2V0dGluZyA9IHRoaXMuYXBwLnNldHRpbmdzLmdldCgnaGlkZS1lZGl0YWJsZS1leHBvcnQtZm9ybWF0cy1wdWJsaWMtdmlldycpO1xuXHQgIGlmKHRoaXMubW9kZWwuZ2V0KCd2aWV3JykgPT09ICd0YWJsZScgJiYgZWRpdGFibGVEYXRhRXhwb3J0U2V0dGluZyAmJiBlZGl0YWJsZURhdGFFeHBvcnRTZXR0aW5nLmdldCgnZGVmYXVsdElkJykgPT0gXCJ0cnVlXCIgJiYgdGhpcy5hcHAudXNlci5nZXQoJ2xvZ2dlZCcpID09IGZhbHNlICl7XG5cdFx0ICB0aGlzLiRlbC5maW5kKCcuZG93bmxvYWQnKS5oaWRlKCk7XG5cdCAgfWVsc2V7XG5cdFx0ICB0aGlzLiRlbC5maW5kKCcuZG93bmxvYWQnKS5zaG93KCk7XG5cdCAgfSAgXG4gIH0sICBcbiAgYmlnOiBmdW5jdGlvbigpIHtcbiAgICAvLyB0b2dnbGUgYmlnL3NtYWxsIGNoYXJ0cyBvbiBsYXJnZSBzY3JlZW5zXG4gICAgdGhpcy5tb2RlbC5zZXQoJ2JpZycsICF0aGlzLm1vZGVsLmdldCgnYmlnJykpO1xuICB9LFxuICBzZXRDbGVhcjogZnVuY3Rpb24oc2hvdWxkQnJlYWspIHtcbiAgICAvLyBsYXlvdXQgaGludHMsIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBieSAuL2NoYXJ0cy5qc1xuICAgIHRoaXMuJGVsW3Nob3VsZEJyZWFrID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKCdjbGVhcmZpeCcpO1xuICB9LFxuXG4gIGRvd25sb2FkOiBmdW5jdGlvbigpIHsgICAgIFxuXHR2YXIgY2hhcnRPcHRpb25zID0gXyh0aGlzLmdldENoYXJ0T3B0aW9ucygpKS5vbWl0KCdoZWlnaHQnLCAnd2lkdGgnKTtcdFxuICAgIHZhciBkb3dubG9hZFZpZXcgPSBuZXcgRG93bmxvYWRWaWV3KHtcbiAgICAgIGFwcDogdGhpcy5hcHAsXG4gICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgIGNoYXJ0T3B0aW9uczogY2hhcnRPcHRpb25zXG4gICAgfSk7XG4gICAgdmFyIHNwZWNpYWxDbGFzcyA9ICdkYXNoLWRvd25sb2FkLW1vZGFsJztcbiAgICB0aGlzLmFwcC5tb2RhbCgnRG93bmxvYWQgY2hhcnQnLCB7XG4gICAgICBib2R5RWw6IGRvd25sb2FkVmlldy5yZW5kZXIoKS5lbCxcbiAgICAgIHNwZWNpYWxDbGFzczogc3BlY2lhbENsYXNzLFxuICAgICAgaTE4blRpdGxlOiAnYW1wLmRhc2hib2FyZDpkb3dubG9hZC1kb3dubG9hZC1jaGFydCdcbiAgICB9KTtcbiAgICBcbiAgICAvLyBUcmFuc2xhdGUgbW9kYWwgcG9wdXAuXHRcbiAgIFx0YXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKCQoXCIuXCIgKyBzcGVjaWFsQ2xhc3MpKTtcbiAgfSxcbiAgXG4gIGhlYXRtYXBTd2l0Y2hBeGlzOiBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoaXMubW9kZWwuZ2V0KCdzd2FwQXhlcycpID09PSB0cnVlKSB7XG5cdFx0ICB0aGlzLm1vZGVsLnNldCgnc3dhcEF4ZXMnLCBmYWxzZSk7XG5cdCAgfSBlbHNlIHtcblx0XHQgIHRoaXMubW9kZWwuc2V0KCdzd2FwQXhlcycsIHRydWUpO1xuXHQgIH0gIFxuXHQgIHRoaXMudXBkYXRlRGF0YSgpO1xuICB9LFxuXG4gIC8vQU1QLTE4NjMwOiBIZXJlIHdlIHNldHVwIGEgc2ltcGxlIHRvb2x0aXAgZm9yIGVhY2ggbGVnZW5kIGVsZW1lbnQuXG4gIGJlYXV0aWZ5TGVnZW5kcyA6IGZ1bmN0aW9uKHNlbGYpIHtcdCAgXG5cdCAgdmFyIGhhc1ZhbHVlcyA9IGZhbHNlO1xuXHQgIHZhciBoYXNQcm9jZXNzZWQgPSBmYWxzZTtcblx0ICBpZihzZWxmLm1vZGVsICE9PSB1bmRlZmluZWQgJiYgc2VsZi5tb2RlbC5nZXQoJ3ZhbHVlcycpICE9PSB1bmRlZmluZWQgJiYgc2VsZi5tb2RlbC5nZXQoJ3ZhbHVlcycpLmxlbmd0aCA+IDApIHtcblx0XHQgIGhhc1ZhbHVlcyA9IHRydWU7XG5cdCAgfVxuXHQgIGlmKHNlbGYubW9kZWwgIT09IHVuZGVmaW5lZCAmJiBzZWxmLm1vZGVsLmdldCgncHJvY2Vzc2VkJykgIT09IHVuZGVmaW5lZCAmJiBzZWxmLm1vZGVsLmdldCgncHJvY2Vzc2VkJykubGVuZ3RoID4gMSkge1xuXHRcdCAgaGFzUHJvY2Vzc2VkID0gdHJ1ZTtcblx0ICB9XG5cdCAgXG5cdCAgLy8gSXRlcmF0ZSB0aGUgbGlzdCBvZiBsZWdlbmQgZWxlbWVudHMgaW4gRE9NIChvbmx5IGZvciB0aGlzIGNoYXJ0KSBhbmQgc2V0IGEgZGF0YSBlbGVtZW50IGNhbGxlZCAnZGF0YS10aXRsZScgdGhhdFxuXHQgIC8vIHdpbGwgYmUgdGhlbiB1c2VkIHdoZW4gYSBob3ZlciBldmVudCBpcyBmaXJlZC5cblx0ICAkKHRoaXMuJGVsKS5maW5kKFwiLm52LXNlcmllc1wiKS5lYWNoKGZ1bmN0aW9uKGksIGVsZW0pIHtcblx0XHQgIC8vIEhlYXRtYXBzIGRvbnQgbmVlZCBhIHNwZWNpYWwgcmVwcm9jZXNzaW5nLlxuXHRcdCAgaWYgKHNlbGYubW9kZWwuZ2V0KCd2aWV3JykgIT09ICdoZWF0bWFwJykge1xuXHRcdFx0ICBpZihoYXNWYWx1ZXMgJiYgIWhhc1Byb2Nlc3NlZCkge1xuXHRcdFx0XHQgIC8vIFRvcCBjaGFydHMuXG5cdFx0XHRcdCAgaWYoc2VsZi5tb2RlbC5nZXQoJ3ZhbHVlcycpW2ldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQgICQoZWxlbSkuZGF0YSgnZGF0YS10aXRsZScsIHNlbGYubW9kZWwuZ2V0KCd2YWx1ZXMnKVtpXS5uYW1lKTtcblx0XHRcdFx0ICB9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFRoaXMgdGhlIGxhc3QgbGVnZW5kIFwiT3RoZXJzXCIgKGRvZXNudCBjb21lIGluIHRoZSBkYXRhKS5cblx0XHRcdCAgICBcdCQoZWxlbSkuZGF0YSgnZGF0YS10aXRsZScsIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOmNoYXJ0LUZ1bmRpbmdUeXBlLW90aGVyc1wiLCBcIk90aGVyc1wiKSk7XG5cdFx0XHRcdCAgfVxuXHRcdFx0ICB9IGVsc2UgaWYoaGFzUHJvY2Vzc2VkKSB7XG5cdFx0XHRcdCAgLy8gQWlkIFByZWRpY3RhYmlsaXR5IGNoYXJ0cyBhbmQgRnVuZGluZyBUeXBlIGNoYXJ0cy5cblx0XHRcdFx0ICBpZihzZWxmLm1vZGVsLmdldCgncHJvY2Vzc2VkJylbaV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdCAgLy8gVGhlIGV4dHJhIGNoZWNrIGlzIGZvciBGVCBjaGFydHMgdGhhdCBoYXZlIG1vcmUgbGVnZW5kcyAoZ3JvdXBlZCwgc3RhY2tlZCwgZXRjKS5cblx0XHRcdFx0XHQgICQoZWxlbSkuZGF0YSgnZGF0YS10aXRsZScsIHNlbGYubW9kZWwuZ2V0KCdwcm9jZXNzZWQnKVtpXS5rZXkpO1xuXHRcdFx0XHQgIH1cblx0XHRcdCAgfVxuXHRcdCAgfVxuXHQgICAgXG5cdFx0ICAvLyBOb3cgYmluZCBOViB0b29sdGlwIG1lY2hhbmlzbSB0byBob3ZlciBldmVudCBmb3IgZWFjaCBsZWdlbmQuXG5cdFx0ICBpZigkKGVsZW0pLmRhdGEoJ2RhdGEtdGl0bGUnKSB8fCAkKGVsZW0pLmRhdGEoJ3RpdGxlJykpIHtcblx0XHRcdCAgJChlbGVtKS5ob3ZlcihmdW5jdGlvbigpIHtcblx0ICAgIFx0XHR2YXIgb2Zmc2V0ID0gJCh0aGlzKS5vZmZzZXQoKTtcdCAgICBcdFx0XG5cdCAgICBcdFx0Ly9UT0RPOiBDaGVjayB0aGUgZ2VuZXJhdGlvbiBvZiBoZWF0TWFwQ2hhcnQuanMgYW5kIHNlZSBpZiB3ZSBjYW4gc2V0IHRoZSAnZGF0YScgZmllbGQgdGhlIHNhbWUgd2F5IHRoYW4gb3RoZXIgY2hhcnRzLlxuXHQgICAgXHRcdHZhciB0aXRsZSA9ICQoZWxlbSkuZGF0YSgnZGF0YS10aXRsZScpID8gJChlbGVtKS5kYXRhKCdkYXRhLXRpdGxlJykgOiAkKGVsZW0pLmRhdGEoJ3RpdGxlJyk7XG5cdCAgICBcdFx0Ly9UT0RPOiBSZW1vdmUgaGFyZGNvZGVkIGh0bWwgYW5kIHVzZSBhIHRlbXBsYXRlLlxuXHQgICAgXHQgICAgbnYudG9vbHRpcC5zaG93KFtvZmZzZXQubGVmdCwgb2Zmc2V0LnRvcF0sIFwiPGRpdiBjbGFzcz0ncGFuZWwgcGFuZWwtcHJpbWFyeSBwYW5lbC1wb3BvdmVyJz48ZGl2IGNsYXNzPSdwYW5lbC1oZWFkaW5nJz5cIiArIHRpdGxlICsgXCI8L2Rpdj48L2Rpdj5cIik7XG5cdCAgICBcdCAgICAgICAgXG5cdCAgICBcdCAgICAvLyBUT0RPOiBGaW5kIGEgd2F5IHRvIHRyaWdnZXIgdGhlIG1vdXNlb3ZlciBvbiB0aGUgYmFyLlxuXHQgICAgXHQgICAgLy8gJCgkKHRoaXMpLmNsb3Nlc3QoJ3N2ZycpLmZpbmQoXCIubnYtZ3JvdXBzXCIpLmZpbmQoXCIubnYtYmFyXCIpW2ldKS50cmlnZ2VyKCdob3ZlcicpO1xuXHQgICAgXHQgICB9LCBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQgICBudi50b29sdGlwLmNsZWFudXAoKTtcblx0ICAgIFx0ICAgfSk7XG5cdFx0ICB9XG5cdCAgfSk7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZURhc2ggPSByZXF1aXJlKCcuLi9iYWNrYm9uZS1kYXNoJyk7XG5cbnZhciBUb3BzID0gcmVxdWlyZSgnLi4vbW9kZWxzL2NoYXJ0LXRvcHMnKTtcbnZhciBQcmVkaWN0YWJpbGl0eSA9IHJlcXVpcmUoJy4uL21vZGVscy9jaGFydC1haWQtcHJlZGljdGFiaWxpdHknKTtcbnZhciBGdW5kaW5nVHlwZSA9IHJlcXVpcmUoJy4uL21vZGVscy9jaGFydC1mdW5kaW5nLXR5cGUnKTtcbnZhciBIZWF0TWFwQ2hhcnQgPSByZXF1aXJlKCcuLi9tb2RlbHMvY2hhcnQtaGVhdG1hcHMnKTtcblxudmFyIFRvcHNDaGFydFZpZXcgPSByZXF1aXJlKCcuL2NoYXJ0LXRvcHMnKTtcbnZhciBIZWF0TWFwQ2hhcnRWaWV3ID0gcmVxdWlyZSgnLi9jaGFydC1oZWF0bWFwcycpO1xudmFyIFByZWRpY3RhYmlsaXR5Q2hhcnRWaWV3ID0gcmVxdWlyZSgnLi9jaGFydC1haWQtcHJlZGljdGFiaWxpdHknKTtcbnZhciBGdW5kaW5nVHlwZUNoYXJ0VmlldyA9IHJlcXVpcmUoJy4vY2hhcnQtZnVuZGluZy10eXBlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZURhc2guVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ3JvdycsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHA7XG4gICAgdGhpcy5jaGFydFZpZXdzID0gdGhpcy5jb2xsZWN0aW9uLm1hcChmdW5jdGlvbihjaGFydCkge1xuICAgICAgdmFyIENoYXJ0VmlldyA9IGNoYXJ0IGluc3RhbmNlb2YgVG9wcyA/IFRvcHNDaGFydFZpZXdcbiAgICAgICAgICAgICAgICAgICAgOiBjaGFydCBpbnN0YW5jZW9mIFByZWRpY3RhYmlsaXR5ID8gUHJlZGljdGFiaWxpdHlDaGFydFZpZXdcbiAgICAgICAgICAgICAgICAgICAgOiBjaGFydCBpbnN0YW5jZW9mIEZ1bmRpbmdUeXBlID8gRnVuZGluZ1R5cGVDaGFydFZpZXdcbiAgICAgICAgICAgICAgICAgICAgOiBjaGFydCBpbnN0YW5jZW9mIEhlYXRNYXBDaGFydCA/IEhlYXRNYXBDaGFydFZpZXdcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBDaGFydFZpZXcoeyBtb2RlbDogY2hhcnQsIGFwcDogdGhpcy5hcHAgfSk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5saXN0ZW5Ub09uY2UodGhpcy5hcHAuZmlsdGVyLCAnYXBwbHknLCB0aGlzLmFwcGx5RmlsdGVyKTtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ2NoYW5nZTpiaWcnLCB0aGlzLmluamVjdEJyZWFrcyk7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sICdjaGFuZ2U6YmlnTicsIHRoaXMucmVkcmF3Q29udGFpbmVyKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGVsLmh0bWwoXyh0aGlzLmNoYXJ0Vmlld3MpLm1hcChmdW5jdGlvbih2aWV3KSB7XG4gICAgICByZXR1cm4gdmlldy5yZW5kZXIoKS5lbDtcbiAgICB9KSk7XG4gICAgdGhpcy5pbmplY3RCcmVha3MoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBpbmplY3RCcmVha3M6IGZ1bmN0aW9uKGNoYXJ0TW9kZWwpIHtcbiAgICBfKHRoaXMuY2hhcnRWaWV3cykucmVkdWNlKGZ1bmN0aW9uKGJyZWFrQWZ0ZXIsIHRoaXNWaWV3KSB7XG4gICAgICB0aGlzVmlldy5zZXRDbGVhcihicmVha0FmdGVyKTtcbiAgICAgIGlmICghYnJlYWtBZnRlcikge1xuICAgICAgICByZXR1cm4gdGhpc1ZpZXcubW9kZWwuZ2V0KCdiaWcnKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG5cbiAgICBpZiAoY2hhcnRNb2RlbCkge1xuICAgICAgdmFyIGNoYXJ0VmlldyA9IF8odGhpcy5jaGFydFZpZXdzKS5maW5kKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHYubW9kZWwgPT09IGNoYXJ0TW9kZWw7XG4gICAgICB9KTtcbiAgICAgIGlmIChjaGFydFZpZXcpIHsgY2hhcnRWaWV3LnJlbmRlcigpOyB9XG4gICAgfVxuICB9LFxuICBcbiAgcmVkcmF3Q29udGFpbmVyOiBmdW5jdGlvbihjaGFydE1vZGVsKSB7XG5cdCAgaWYgKGNoYXJ0TW9kZWwpIHtcblx0XHQgIHZhciBjaGFydFZpZXcgPSBfKHRoaXMuY2hhcnRWaWV3cykuZmluZChmdW5jdGlvbih2KSB7XG5cdFx0XHQgIHJldHVybiB2Lm1vZGVsID09PSBjaGFydE1vZGVsO1xuXHQgICAgICB9KTtcblx0ICAgICAgaWYgKGNoYXJ0VmlldykgeyBcblx0ICAgIFx0ICBjaGFydFZpZXcucmVuZGVyKCk7IFxuXHQgICAgICB9XG5cdCAgfSBcbiAgfVxuXG59KTtcbiIsInZhciBCYWNrYm9uZURhc2ggPSByZXF1aXJlKCcuLi9iYWNrYm9uZS1kYXNoJyk7XG52YXIgRmlsdGVycyA9IHJlcXVpcmUoJy4vZmlsdGVycycpO1xudmFyIFNldHRpbmdzID0gcmVxdWlyZSgnLi9zZXR0aW5ncycpO1xudmFyIFNoYXJlID0gcmVxdWlyZSgnLi9zaGFyZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6ICdyb3cnLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwOyAgICBcbiAgICB0aGlzLnNldHRpbmdzID0gbmV3IFNldHRpbmdzKHsgYXBwOiB0aGlzLmFwcCB9KTtcbiAgICB0aGlzLmZpbHRlcnMgPSBuZXcgRmlsdGVycyh7IGFwcDogdGhpcy5hcHAgfSk7XG4gICAgdGhpcy5zaGFyZSA9IG5ldyBTaGFyZSh7IGFwcDogdGhpcy5hcHAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKFtcbiAgICAgIHRoaXMuZmlsdGVycy5yZW5kZXIoKS5lbCxcbiAgICAgIHRoaXMuc2V0dGluZ3MucmVuZGVyKCkuZWwsXG4gICAgICB0aGlzLnNoYXJlLnJlbmRlcigpLmVsXG4gICAgXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBiYWJ5ID0gcmVxdWlyZSgnYmFieXBhcnNlJyk7XG52YXIgY2FudmcgPSByZXF1aXJlKCcuLi8uLi91Z2x5L2xpYi1sb2FkLWhhY2tzJykuY2Fudmc7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3VnbHkvdXRpbCcpO1xuXG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcbnZhciBnZXRDaGFydCA9IHJlcXVpcmUoJy4uL2NoYXJ0cy9jaGFydCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91Z2x5L3V0aWwnKTtcbnZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8aDQgZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmRvd25sb2FkLXByZXZpZXdcXFwiPlByZXZpZXc6PC9oND5cXG5cXG48IS0tIFRoaXMgJ21vZGFsJyBkaXYgZml4ZXMgQU1QLTE5NTI1OiBJbiBGRiB3aGVuIHRoZSBjaGFydCBpcyBkcmF3biAoZm9yIGxlc3MgdGhhbiBhIHNlY29uZCkgaW4gJ3N2Zy13cmFwJywgc29tZXRpbWVzIHRoZSBtb3VzZSBjdXJzb3IgaXMgb3ZlciBvbmUgb2YgdGhlIGJhcnMgYW5kIHRyaWdnZXJzIHRoZSB0b29sdGlwLFxcbnRoYXQgcHJvY2VzcyBpcyBub3QgZnVsbHkgcGVyZm9ybWVkIHRodXMgcmVzdWx0aW5nIGluIGluY29tcGxldGUgaHRtbCB3aGljaCBpcyByZWplY3RlZCBieSB0aGUgYnJvd3NlciA6KCAgLS0+XFxuPGRpdiBjbGFzcz1cXFwibW9kYWwtcHJldmlldy1hcmVhXFxcIj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJwcmV2aWV3LWFyZWFcXFwiPlxcblxcdDxkaXYgY2xhc3M9XFxcInN2Zy13cmFwIGhpZGRlblxcXCI+XFxuICBcXHQ8L2Rpdj5cXG4gIFxcdDxkaXYgY2xhc3M9XFxcImNhbnZhcy13cmFwIGhpZGRlblxcXCI+XFxuICBcXHQ8L2Rpdj5cXG4gIFxcdDxkaXYgY2xhc3M9XFxcInRhYmxlLXdyYXAgaGlkZGVuXFxcIj5cXG4gIFxcdDwvZGl2PlxcbjwvZGl2PlxcblxcbjxkaXYgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj5cXG4gIDxhIGNsYXNzPVxcXCJidG4gYnRuLXN1Y2Nlc3MgZG93bmxvYWQtY2hhcnQgZGlzYWJsZWRcXFwiPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1kb3dubG9hZFxcXCI+PC9zcGFuPlxcbiAgICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6ZG93bmxvYWQtcmVuZGVyaW5nXFxcIiBjbGFzcz1cXFwid29yZFxcXCI+UmVuZGVyaW5nLi4uPC9zcGFuPlxcbiAgPC9hPlxcbjwvZGl2PlxcblwiKTtcblxudmFyIHByZXZpb3VzWExpbWl0ID0gbnVsbDtcbnZhciBwcmV2aW91c1lMaW1pdCA9IG51bGw7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICAgIHZhciB2YWx1ZXNMZW5ndGggPSB0aGlzLm1vZGVsLmdldCgndmFsdWVzJykgPyB0aGlzLm1vZGVsLmdldCgndmFsdWVzJykubGVuZ3RoIDogMDtcbiAgICB2YXIgaGVpZ2h0ID0gdXRpbC5jYWxjdWxhdGVDaGFydEhlaWdodCh2YWx1ZXNMZW5ndGgsIHRydWUpO1xuICAgIHRoaXMuZGFzaENoYXJ0T3B0aW9ucyA9IF8oe30pLmV4dGVuZChvcHRpb25zLmNoYXJ0T3B0aW9ucywge1xuICAgICAgaGVpZ2h0OiBoZWlnaHQsIC8vNDUwLCAgLy8gc3luYyB3aXRoIGNzcyEhIVxuICAgICAgd2lkdGg6ICQoJy5jb250YWluZXInKS53aWR0aCgpLFx0Ly8gc3luYyB3aXRoIGNzcyEhIVxuICAgICAgdHJpbUxhYmVsczogZmFsc2UsXG4gICAgICBudkNvbnRyb2xzOiBmYWxzZSAgICAgIFxuICAgIH0pO1xuICAgIFxuICAgIC8vIEhlYXRtYXBzIGV4cG9ydCBuZWVkIHRvIHNob3cgYWxsIGRhdGEgYXQgb25jZSBzbyB3ZSBmb3JjZSB0aGUgeC95IGxpbWl0cyBhbmQgcmUtcmVuZGVyIHRoZSBjaGFydC5cbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2NoYXJ0VHlwZScpID09PSAnZnJhZ21lbnRhdGlvbicpIHtcblx0ICAgIHByZXZpb3VzWExpbWl0ID0gdGhpcy5tb2RlbC5nZXQoJ3hMaW1pdCcpO1xuXHQgICAgcHJldmlvdXNZTGltaXQgPSB0aGlzLm1vZGVsLmdldCgneUxpbWl0Jyk7XG5cdCAgICB0aGlzLm1vZGVsLnNldCgneUxpbWl0JywgLTEpO1xuXHQgICAgdGhpcy5tb2RlbC5zZXQoJ3hMaW1pdCcsIC0xKTtcblx0ICAgIHRoaXMubW9kZWwuc2V0KCdzaG93RnVsbExlZ2VuZHMnLCB0cnVlKTtcblx0ICAgIHZhciBjaGFydCA9IF8uZmluZCh0aGlzLmFwcC52aWV3LmNoYXJ0cy5jaGFydFZpZXdzLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0ubW9kZWwuZ2V0KCduYW1lJykgPT09IHNlbGYubW9kZWwuZ2V0KCduYW1lJyl9KTtcblx0ICAgIGNoYXJ0LnJlbmRlcigpO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTsgICBcbiAgICB0aGlzLmNoYXJ0ID0gXy5maW5kKHNlbGYuYXBwLnZpZXcuY2hhcnRzLmNoYXJ0Vmlld3MsIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbS5tb2RlbC5nZXQoJ25hbWUnKSA9PT0gc2VsZi5tb2RlbC5nZXQoJ25hbWUnKX0pO1xuICAgIFxuXHQvLyBIZXJlIHdlIHdpbGwgZGVmaW5lIGFuIGludGVydmFsIHRoYXQgd2lsbCBjaGVjayBwZXJpb2RpY2FsbHkgaWYgdGhlIGJvb3RzdHJhcCBtb2RhbCBpcyBmdWxseSByZW5kZXJlZC5cblx0Ly8gSW4gdGhhdCBtb21lbnQgdGhlIGludGVydmFsIGlzIGZpbmlzaGVkIGFuZCB0aGUgY2hhcnQgaXMgcmVuZGVyZWQuXG5cdHZhciByZW5kZXJlZCA9IGZhbHNlOyAvLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBhdm9pZCB0cmlnZ2VyaW5nIHRoZSByZW5kZXIgcHJvY2VzcyB0d2ljZSBpbiBjYXNlIHRoZSBicm93c2VyIG1lc3MgdXAgdGhlIGludGVydmFsLlx0ICAgIFx0XG5cdHZhciBpbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcblx0XHRpZiAoJCgnLmRhc2gtZG93bmxvYWQtbW9kYWwnKS5jbG9zZXN0KCcuaW4nKS5sZW5ndGggPiAwKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG5cdFx0XHQvLyBXYWl0IGZvciB0aGUgY2hhcnQgaW4gdGhlIGRhc2hib2FyZCBwYWdlIHRvIGJlIGZ1bGx5IHJlbmRlcmVkLCB0aGlzIGhhcyBpbXBhY3Qgb25seSBvbiBoZWF0bWFwIGNoYXJ0cywgb24gdGhlIHJlc3QgaXMgdHJhbnNwYXJlbnQuXG5cdFx0XHQkLndoZW4oc2VsZi5jaGFydC5yZW5kZXJlZFByb21pc2UsIHNlbGYuY2hhcnQuc2hvd0NoYXJ0UHJvbWlzZSkuZG9uZShmdW5jdGlvbigpIHtcblx0ICAgIFx0XHRpZiAoc2VsZi5tb2RlbC5nZXQoJ2NoYXJ0VHlwZScpID09PSAnZnJhZ21lbnRhdGlvbicpIHtcblx0ICAgIFx0XHRcdC8vIFdlIGFkZCBhbiBldmVudCBmb3IgaGVhdG1hcHMgdG8gcmUtZHJhdyB0aGUgb3JpZ2luYWwgY2hhcnQuXG5cdCAgICBcdFx0ICAgICQoJy5kYXNoLWRvd25sb2FkLW1vZGFsJykuY2xvc2VzdCgnLmluJykub24oJ2hpZGUuYnMubW9kYWwnLCBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQgICAgXHRzZWxmLm1vZGVsLnNldCgneUxpbWl0JywgcHJldmlvdXNZTGltaXQpO1xuXHQgICAgXHRcdCAgICBcdHNlbGYubW9kZWwuc2V0KCd4TGltaXQnLCBwcmV2aW91c1hMaW1pdCk7XG5cdCAgICBcdFx0ICAgIFx0c2VsZi5tb2RlbC5zZXQoJ3Nob3dGdWxsTGVnZW5kcycsIGZhbHNlKTtcblx0XHRcdFx0XHRcdHNlbGYuY2hhcnQucmVuZGVyKCk7XG5cdCAgICBcdFx0ICAgIH0pO1xuXHQgICAgXHRcdH1cblx0XHRcdCAgICBpZiAoc2VsZi5tb2RlbC5nZXQoJ3ZpZXcnKSA9PT0gJ3RhYmxlJykge1xuXHRcdFx0ICAgIFx0c2VsZi5yZW5kZXJDU1Yoc2VsZi4kKCcucHJldmlldy1hcmVhIC50YWJsZS13cmFwJykucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpKTtcblx0XHRcdCAgICB9IGVsc2Uge1xuXHRcdFx0ICAgICAgICBudi50b29sdGlwLmNsZWFudXAoKTtcblx0XHRcdCAgICAgICAgaWYgKHJlbmRlcmVkID09PSBmYWxzZSkge1xuXHRcdFx0ICAgICAgICBcdHJlbmRlcmVkID0gdHJ1ZTtcblx0XHRcdCAgICAgICAgXHRzZWxmLnJlbmRlckNoYXJ0KHNlbGYuJCgnLnByZXZpZXctYXJlYSAuc3ZnLXdyYXAnKS5yZW1vdmVDbGFzcygnaGlkZGVuJyksXG5cdFx0XHQgICAgICAgIFx0XHRzZWxmLiQoJy5wcmV2aWV3LWFyZWEgLmNhbnZhcy13cmFwJyksIHNlbGYuY2hhcnQpO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgfVxuXHRcdFx0fSk7XG5cdFx0fVxuICAgIH0sIDEwMCk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVuZGVyQ2hhcnQ6IGZ1bmN0aW9uKHN2Z0NvbnRhaW5lciwgY2FudmFzQ29udGFpbmVyLCBjaGFydCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKF8odGhpcy5hcHAuYnJvd3Nlcklzc3VlcykuZmluZFdoZXJlKHtmZWF0dXJlOiAnY2FudmFzJ30pKSB7XG4gICAgICB0aGlzLmFwcC52aWV3RmFpbCh0aGlzLCAnQ2hhcnQgZXhwb3J0IHJlcXVpcmVzIGEgbW9kZXJuIHdlYiBicm93c2VyJyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChzZWxmLm1vZGVsLmdldCgnY2hhcnRUeXBlJykgPT09ICdmcmFnbWVudGF0aW9uJykge1xuICAgIFx0dmFyIHN2ZyA9ICQoJCgkKGNoYXJ0KVswXS5lbCkuZmluZChcInN2Z1wiKSlbMF0uZ2V0QkJveCgpO1xuXHQgICAgdGhpcy5kYXNoQ2hhcnRPcHRpb25zLmhlaWdodCA9IHN2Zy5oZWlnaHQgKyAxMDA7XG5cdCAgICB0aGlzLmRhc2hDaGFydE9wdGlvbnMud2lkdGggPSBzdmcud2lkdGggKyA4MDtcbiAgICB9XG4gICAgICAgIFxuICAgIHZhciB2aWV3ID0gdGhpcy5tb2RlbC5nZXQoJ3ZpZXcnKSxcbiAgICAgICAgZGF0YSA9IHRoaXMubW9kZWwuZ2V0KCdwcm9jZXNzZWQnKSxcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksXG4gICAgICAgIGNoYXJ0RWwgPSBnZXRDaGFydCh2aWV3LCBkYXRhLFxuICAgICAgICAgIF8oe30pLmV4dGVuZCh0aGlzLmRhc2hDaGFydE9wdGlvbnMsIHsgaGVpZ2h0OiB0aGlzLmRhc2hDaGFydE9wdGlvbnMuaGVpZ2h0IC0gNDIgfSkpLmVsO1xuXG4gICAgc3ZnQ29udGFpbmVyLmh0bWwoY2hhcnRFbCk7XG5cbiAgICB0aGlzLnByZXBhcmVDYW52YXMoY2FudmFzLCB0aGlzLmRhc2hDaGFydE9wdGlvbnMuaGVpZ2h0LCB0aGlzLmRhc2hDaGFydE9wdGlvbnMud2lkdGgpO1xuXG4gICAgdGhpcy5jaGFydFRvQ2FudmFzKGNoYXJ0RWwsIGNhbnZhcywgZnVuY3Rpb24oKSB7XG4gICAgICBzdmdDb250YWluZXIuaGlkZSgpO1xuICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1nLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgY2FudmFzQ29udGFpbmVyLmh0bWwoaW1nKTtcbiAgICAgICQoY2FudmFzQ29udGFpbmVyKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAkKCcubW9kYWwtcHJldmlldy1hcmVhJykucmVtb3ZlKCk7XG4gICAgICB0aGlzLm1ha2VEb3dubG9hZGFibGUoaW1nLnNyYywgJ2NoYXJ0JywgJy5wbmcnKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTY2FsZSB0aGUgbW9kYWwgY29ycmVjdGx5IGZvciBoZWF0bWFwcy5cbiAgICBpZiAoc2VsZi5tb2RlbC5nZXQoJ2NoYXJ0VHlwZScpID09PSAnZnJhZ21lbnRhdGlvbicpIHtcbiAgICBcdHZhciBtb2RhbCA9ICQoJy5kYXNoLWRvd25sb2FkLW1vZGFsJykuY2xvc2VzdCgnLmluJykuZmluZCgnLmRhc2gtZG93bmxvYWQtbW9kYWwnKTtcbiAgICBcdGlmICgkKHN2Z0NvbnRhaW5lcikud2lkdGgoKSA+ICQobW9kYWwpLndpZHRoKCkpIHtcbiAgICBcdFx0JChtb2RhbCkuZmluZCgnLnByZXZpZXctYXJlYScpLmNzcygnbWF4LXdpZHRoJywnOTAlJyk7XG4gICAgICAgIFx0JChtb2RhbCkuY2xvc2VzdCgnLmluJykuZmluZCgnLnByZXZpZXctYXJlYScpLmNzcygnb3ZlcmZsb3cnLCdhdXRvJyk7XG4gICAgXHR9XG4gICAgXHRpZiAoJChzdmdDb250YWluZXIpLmhlaWdodCgpID4gJCh3aW5kb3cpLmhlaWdodCgpKSB7XG4gICAgXHRcdCQobW9kYWwpLmZpbmQoJy5wcmV2aWV3LWFyZWEnKS5jc3MoJ21heC1oZWlnaHQnLCAoJCh3aW5kb3cpLmhlaWdodCgpIC0gMjcwKSArICdweCcpO1xuICAgICAgICBcdCQobW9kYWwpLmNsb3Nlc3QoJy5pbicpLmZpbmQoJy5wcmV2aWV3LWFyZWEnKS5jc3MoJ292ZXJmbG93JywnYXV0bycpO1xuICAgIFx0fVxuICAgIH1cbiAgfSxcblxuICBwcmVwYXJlQ2FudmFzOiBmdW5jdGlvbihjYW52YXMsIGgsIHcpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR2YXIgY3VycmVuY3kgPSBfLmZpbmQoYXBwLnNldHRpbmdzLmdldCgnMScpLmdldCgnb3B0aW9ucycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0uaWQgPT09IHNlbGYubW9kZWwuZ2V0KCdjdXJyZW5jeScpfSk7XG4gICAgdmFyIGN1cnJlbmN5TmFtZSA9IGN1cnJlbmN5ICE9PSB1bmRlZmluZWQgPyBjdXJyZW5jeS52YWx1ZSA6ICcnO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICBcdG1vbmV5Q29udGV4dCA9ICh0aGlzLm1vZGVsLmdldCgnc3VtYXJpemVkVG90YWwnKSAhPT0gdW5kZWZpbmVkID8gJzogJyArIHV0aWwudHJhbnNsYXRlTGFuZ3VhZ2UodGhpcy5tb2RlbC5nZXQoJ3N1bWFyaXplZFRvdGFsJykpICsgJyAnOiAnICcpICsgY3VycmVuY3lOYW1lLFxuICAgICAgICBhZGpUeXBlID0gdGhpcy5tb2RlbC5nZXQoJ2FkanR5cGUnKTsgICAgXG4gICAgaWYgKGFkalR5cGUpIHtcbiAgICAgICAgdmFyIHRybkFkalR5cGUgPSB0aGlzLmNoYXJ0LiRlbC5maW5kKCcuZnR5cGUtb3B0aW9ucyBvcHRpb246c2VsZWN0ZWQnKS50ZXh0KCk7XG4gICAgICAgIG1vbmV5Q29udGV4dCA9IHRybkFkalR5cGUgKyBtb25leUNvbnRleHQ7XG4gICAgfVxuXG4gICAgLy8gc2l6ZSB0aGUgY2FudmFzXG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3KTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoKTtcblxuICAgIC8vIG1ha2UgdGhlIGJhY2tncm91bmQgb3BhcXVlIHdoaXRlXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KDAsIDAsIHcsIGgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmZic7XG4gICAgY3R4LmZpbGwoKTtcblxuICAgIC8vIEFkZCB0aGUgY2hhcnQgdGl0bGVcbiAgICBjdHguZmlsbFN0eWxlID0gJyMxNjNmNjYnO1xuICAgIGN0eC5mb250ID0gJ2JvbGQgMjJweCBcIk9wZW4gU2Fuc1wiJztcbiAgICBjdHguZmlsbFRleHQodGhpcy5tb2RlbC5nZXQoJ3RpdGxlJykudG9VcHBlckNhc2UoKSwgMTAsIDEwICsgMjIpO1xuICAgIC8vIHdoYXQgbW9uZXkgYXJlIHdlIHRhbGtpbmcgYWJvdXQ/XG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjMzMzJztcbiAgICBpZiAoc2VsZi5tb2RlbC5nZXQoJ2NoYXJ0VHlwZScpID09PSAnZnJhZ21lbnRhdGlvbicpIHtcbiAgICBcdGN0eC5mb250ID0gJ25vcm1hbCAxNHB4IFwiT3BlbiBTYW5zXCInO1xuICAgIFx0Y3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICBcdGN0eC5maWxsVGV4dCh0cm5BZGpUeXBlLCAxMCwgNTApO1x0ICAgIFxuICAgIH0gZWxzZSB7ICAgIFxuICAgIFx0Y3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG5cdCAgICBjdHguZmlsbFRleHQobW9uZXlDb250ZXh0LCB3IC0gMTAsIDEwICsgMjIpO1xuXHQgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JzsgIC8vIHJlc2V0IGl0XG4gICAgfSAgICBcbiAgICAvLyByZXNldCBmb250IHRvIHNvbWV0aGluZyBub3JtYWwgKG52ZDMgdXNlcyBjc3MgdWdoLi4uKVxuICAgIGN0eC5mb250ID0gJ25vcm1hbCAxMnB4IFwic2Fucy1zZXJpZlwiJztcbiAgICBcbiAgICAkKCcubW9kYWwuaW4gLm1vZGFsLWRpYWxvZycpLndpZHRoKHcgKyA2MCk7XG4gIH0sXG5cbiAgY2hhcnRUb0NhbnZhczogZnVuY3Rpb24oc3ZnLCBjYW52YXMsIGNiKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0XG5cdGlmICh0aGlzLm1vZGVsLmdldCgnY2hhcnRUeXBlJykgPT09ICdmcmFnbWVudGF0aW9uJykge1xuXHRcdC8vIFRoaXMgaXMgd2hhdCBhcHBsaWVzIHRoZSBuZWNlc3Nhcnkgc3R5bGVzIHRvIHRoZSBjaGFydMK0cyBTVkcuXG5cdFx0dmFyIGNzcyA9IFwicmVjdC5ib3JkZXJlZCB7c3Ryb2tlOiAjRTZFNkU2O3N0cm9rZS13aWR0aDogMnB4O30gdGV4dC5tb25vIHtmb250LXNpemU6IDlwdDtmb250LWZhbWlseTogQXJpYWw7ZmlsbDogIzAwMDt9XCI7XG5cdCAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdCAgICBzLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuXHQgICAgcy5pbm5lckhUTUwgPSBcIjwhW0NEQVRBW1xcblwiICsgY3NzICsgXCJcXG5dXT5cIjtcblx0ICAgIHN2Zy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRlZnNcIilbMF0uYXBwZW5kQ2hpbGQocyk7XG5cdH1cblx0XG4gICAgdmFyIGJvdW5kQ0IgPSBfKGNiKS5iaW5kKHRoaXMpO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hcHAudHJ5VG8oZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbnZnKGNhbnZhcywgc3ZnLnBhcmVudE5vZGUuaW5uZXJIVE1MLCB7IC8vIG5vdGU6IHN2Zy5vdXRlckhUTUwgYnJlYWtzIElFXG4gICAgICAgICAgb2Zmc2V0WTogKChzZWxmLm1vZGVsLmdldCgnY2hhcnRUeXBlJykgIT09ICdmcmFnbWVudGF0aW9uJykgPyA0MiA6IDY1KSxcbiAgICAgICAgICBpZ25vcmVEaW1lbnNpb25zOiB0cnVlLFxuICAgICAgICAgIGlnbm9yZUNsZWFyOiB0cnVlLFxuICAgICAgICAgIGlnbm9yZU1vdXNlOiB0cnVlLFxuICAgICAgICAgIHJlbmRlckNhbGxiYWNrOiBib3VuZENCXG4gICAgICAgIH0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfS5iaW5kKHRoaXMpLCAxNTAwKTsgIC8vIHdlIGhhdmUgdG8gd2FpdCBmb3Igc3R1cGlkIG52ZDMuLi5cbiAgfSxcblxuICByZW5kZXJDU1Y6IGZ1bmN0aW9uKGNzdkNvbnRhaW5lcikge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHZhciBjdXJyZW5jeU5hbWUgPSBfLmZpbmQoYXBwLnNldHRpbmdzLmdldCgnMScpLmdldCgnb3B0aW9ucycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0uaWQgPT09IHNlbGYubW9kZWwuZ2V0KCdjdXJyZW5jeScpfSkudmFsdWU7XG4gICAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLmdldCgncHJvY2Vzc2VkJyksXG4gICAgICAgIGN1cnJlbmN5ID0gY3VycmVuY3lOYW1lLFxuICAgICAgICBhZGp0eXBlID0gdGhpcy5tb2RlbC5nZXQoJ2FkanR5cGUnKSB8fCBmYWxzZSxcbiAgICAgICAgY3N2VHJhbnNmb3JtZWQsXG4gICAgICAgIGhlYWRlclJvdyxcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHByZXZpZXc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleXMgPSBfKGRhdGEpLnBsdWNrKCdrZXknKTtcbiAgICBcbiAgICBpZiAoc2VsZi5tb2RlbC5nZXQoJ2NoYXJ0VHlwZScpICE9PSAnZnJhZ21lbnRhdGlvbicpIHtcblx0ICAgIC8vIHRhYmxlIG9mIGFsbCB0aGUgZGF0YVxuXHQgICAgY3N2VHJhbnNmb3JtZWQgPSBfKGRhdGEpXG5cdCAgICAgIC5jaGFpbigpXG5cdCAgICAgIC5wbHVjaygndmFsdWVzJylcblx0ICAgICAgLnRyYW5zcG9zZSgpXG5cdCAgICAgIC5tYXAoZnVuY3Rpb24ocm93KSB7XG5cdCAgICAgICAgcmV0dXJuIF8ocm93KS5yZWR1Y2UoZnVuY3Rpb24oY3N2Um93LCBjZWxsKSB7XG5cdCAgICAgICAgICBjc3ZSb3cucHVzaChjZWxsLnkpO1xuXHQgICAgICAgICAgcmV0dXJuIGNzdlJvdztcblx0ICAgICAgICB9LCBbcm93WzBdLnhdKTtcblx0ICAgICAgfSlcblx0ICAgICAgLm1hcChmdW5jdGlvbihyb3cpIHtcblx0ICAgICAgICByb3cucHVzaChjdXJyZW5jeSB8fCAnJyk7XG5cdCAgICAgICAgaWYgKGFkanR5cGUpIHtcblx0XHRcdFx0dmFyIHRybkFkalR5cGUgPSBzZWxmLmNoYXJ0LiRlbC5maW5kKCcuZnR5cGUtb3B0aW9ucyBvcHRpb246c2VsZWN0ZWQnKS50ZXh0KCk7XG5cdCAgICAgICAgICAgIHJvdy5wdXNoKHRybkFkalR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcm93O1xuXHQgICAgICB9KVxuXHQgICAgICAudmFsdWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjc3ZUcmFuc2Zvcm1lZCA9IF8ubWFwKHNlbGYubW9kZWwuZ2V0KFwibWF0cml4XCIpLCBmdW5jdGlvbihpdGVtWSwgaSkge1xuXHRcdFx0cmV0dXJuIF8ubWFwKGl0ZW1ZLCBmdW5jdGlvbihpdGVtWCwgaikge1xuXHRcdFx0XHRyZXR1cm4gW3NlbGYubW9kZWwuZ2V0KFwieURhdGFTZXRcIilbaV0sXG5cdFx0XHRcdFx0c2VsZi5tb2RlbC5nZXQoXCJ4RGF0YVNldFwiKVtqXSxcblx0XHRcdFx0XHRzZWxmLm1vZGVsLmdldChcIm1hdHJpeFwiKVtpXVtqXSA/IHNlbGYubW9kZWwuZ2V0KFwibWF0cml4XCIpW2ldW2pdLmR2IDogJycsXG5cdFx0XHRcdFx0c2VsZi5tb2RlbC5nZXQoXCJtYXRyaXhcIilbaV1bal0gPyBzZWxmLm1vZGVsLmdldChcIm1hdHJpeFwiKVtpXVtqXS5wIDogJydcblx0XHRcdFx0XVxuXHRcdFx0fSlcblx0XHR9KTtcblx0ICAgIGNzdlRyYW5zZm9ybWVkID0gW10uY29uY2F0LmFwcGx5KFtdLCBjc3ZUcmFuc2Zvcm1lZCk7XG5cdCAgICBjc3ZUcmFuc2Zvcm1lZCA9IF8uZWFjaChjc3ZUcmFuc2Zvcm1lZCwgZnVuY3Rpb24oaXRlbSkgeyBcblx0ICAgICAgICBpdGVtLnB1c2goY3VycmVuY3kpO1xuXHQgICAgICAgIGlmIChhZGp0eXBlKSB7XG5cdFx0XHRcdHZhciB0cm5BZGpUeXBlID0gc2VsZi5jaGFydC4kZWwuZmluZCgnLmZ0eXBlLW9wdGlvbnMgb3B0aW9uOnNlbGVjdGVkJykudGV4dCgpO1xuXHQgICAgICAgICAgICBpdGVtLnB1c2godHJuQWRqVHlwZSk7XG5cdCAgICAgICAgfVx0ICAgICAgICBcblx0ICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHByZXBlbmQgYSBoZWFkZXIgcm93XG4gICAgaGVhZGVyUm93ID0gW107XG4gICAgdmFyIGFtb3VudFRybiA9IHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpkb3dubG9hZC1hbW91bnQnLCAnQW1vdW50Jyk7XG4gICAgdmFyIGN1cnJlbmN5VHJuID0gdGhpcy5hcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmN1cnJlbmN5JywgJ0N1cnJlbmN5Jyk7XG4gICAgdmFyIHBlcmNlbnRhZ2VUcm4gPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6cGVyY2VudGFnZScsICdQZXJjZW50YWdlJyk7XG4gICAgdmFyIHR5cGVUcm4gPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6dHlwZScsICdUeXBlJyk7XG4gICAgdmFyIHllYXJUcm4gPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6eWVhcicsICdZZWFyJyk7XG5cblx0aWYgKHRoaXMubW9kZWwudXJsLmluZGV4T2YoJy90b3BzJykgPiAtMSkge1xuXHQgICAgaGVhZGVyUm93LnB1c2godGhpcy5tb2RlbC5nZXQoJ3RpdGxlJykpO1xuXHQgICAgaGVhZGVyUm93LnB1c2goYW1vdW50VHJuKTtcblx0ICAgIGhlYWRlclJvdy5wdXNoKGN1cnJlbmN5VHJuKTtcblx0ICAgIGhlYWRlclJvdy5wdXNoKHR5cGVUcm4pO1xuXHR9IGVsc2UgaWYgKHRoaXMubW9kZWwudXJsLmluZGV4T2YoJy9haWQtcHJlZGljdGFiaWxpdHknKSA+IC0xKSB7XG5cdCAgICBoZWFkZXJSb3cucHVzaCh5ZWFyVHJuKTtcblx0ICAgIF8uZWFjaChrZXlzLCBmdW5jdGlvbihpdGVtKSB7XG5cdCAgICBcdGhlYWRlclJvdy5wdXNoKGl0ZW0pO1xuXHQgICAgfSk7XG5cdCAgICBoZWFkZXJSb3cucHVzaChjdXJyZW5jeVRybik7XG5cdH0gZWxzZSBpZiAodGhpcy5tb2RlbC51cmwuaW5kZXhPZignL2Z0eXBlJykgPiAtMSkge1xuXHRcdGhlYWRlclJvdy5wdXNoKHllYXJUcm4pO1xuXHQgICAgXy5lYWNoKGtleXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICAgIFx0aGVhZGVyUm93LnB1c2goaXRlbSk7XG5cdCAgICB9KTtcblx0ICAgIGhlYWRlclJvdy5wdXNoKGN1cnJlbmN5VHJuKTtcblx0ICAgIGhlYWRlclJvdy5wdXNoKHR5cGVUcm4pO1xuXHR9IGVsc2UgaWYgKHRoaXMubW9kZWwuZ2V0KCdjaGFydFR5cGUnKSA9PT0gJ2ZyYWdtZW50YXRpb24nKSB7XG5cdFx0Ly8gRm9yIEFNUC0yMzU4Mjogd2UgZG9udCB3YW50IHRoZSBuYW1lIGZyb20gXCJzdW1tYXJ5XCIgYmVjYXVzZSB0aGF0cyB0aGUgb3JpZ05hbWUgYW5kIG5vdCBhbHdheXMgdGhlIHNhbWUgbmFtZSB0aGFuIHRoZSBYIGF4aXMgY29tYm8gc2VsZWN0b3IuIFxuXHRcdHZhciBmaXJzdENvbHVtbk5hbWUgPSBfLmZpbmQoc2VsZi5tb2RlbC5nZXQoJ2hlYXRtYXBfY29uZmlnJykubW9kZWxzWzBdLmdldCgnY29sdW1ucycpLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS5vcmlnTmFtZSA9PT0gc2VsZi5tb2RlbC5nZXQoJ3N1bW1hcnknKVswXTtcblx0XHR9KS5uYW1lOyBcblx0XHR2YXIgc2Vjb25kQ29sdW1uTmFtZSA9IF8uZmluZChzZWxmLm1vZGVsLmdldCgnaGVhdG1hcF9jb25maWcnKS5tb2RlbHNbMF0uZ2V0KCdjb2x1bW5zJyksIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHJldHVybiBpdGVtLm9yaWdOYW1lID09PSBzZWxmLm1vZGVsLmdldCgnc3VtbWFyeScpWzFdO1xuXHRcdH0pLm5hbWU7XG5cdFx0aGVhZGVyUm93LnB1c2goZmlyc3RDb2x1bW5OYW1lKTtcblx0XHRoZWFkZXJSb3cucHVzaChzZWNvbmRDb2x1bW5OYW1lKTtcblx0ICAgIGhlYWRlclJvdy5wdXNoKGFtb3VudFRybik7XG5cdCAgICBoZWFkZXJSb3cucHVzaChwZXJjZW50YWdlVHJuKTtcblx0ICAgIGhlYWRlclJvdy5wdXNoKGN1cnJlbmN5VHJuKTtcblx0ICAgIGhlYWRlclJvdy5wdXNoKHR5cGVUcm4pO1xuXHR9XG5cbiAgICBjc3ZUcmFuc2Zvcm1lZC51bnNoaWZ0KGhlYWRlclJvdyk7XG4gICAgLyogQWRkIHNlcD0sIGZvciBhdXRvbWF0aWMgRXhjZWwgc3VwcG9ydCBhdCB0aGUgdmVyeSB0b3Agb2YgdGhlIGZpbGUgd29ya3MgYnV0IGJyZWFrcyBCT00gdW5pY29kZS5cbiAgICAgKiBMZXQgdXMgdXNlIHRhYi1kZWxpbWl0ZWQgaW5zdGVhZC5cbiAgICAgKiAgVGhpcyB3ZWJzaXRlIHNob3dzIGEgY3N2IHdpdGggVGFiLWRlbGltaXRlZCwgdXRmMTZsZSB3aXRoIGEgQk9NIGhhcyBiZXN0IEV4Y2VsIHN1cHBvcnQgKHZpYSBTdGFja092ZXJmbG93KTpcbiAgICAgKiAgaHR0cDovL3dpa2kuc2NuLnNhcC5jb20vd2lraS9kaXNwbGF5L0FCQVAvQ1NWK3Rlc3RzK29mK2VuY29kaW5nK2FuZCtjb2x1bW4rc2VwYXJhdG9yXG4gICAgICovXG5cbiAgICB0ZXh0Q29udGVudCA9IGJhYnkudW5wYXJzZShjc3ZUcmFuc2Zvcm1lZCwge1xuICAgICAgZGVsaW1pdGVyOiAnOycsXG4gICAgICBlbmNvZGluZzogJ3V0Zi0xNicsXG4gICAgXHRxdW90ZXM6IHRydWVcbiAgICB9KTtcblxuICAgIHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHByZXZpZXcuc2V0QXR0cmlidXRlKCdjbGFzcycsICdjc3YtcHJldmlldycpO1xuICAgIHByZXZpZXcudmFsdWUgPSB0ZXh0Q29udGVudDtcbiAgICBjc3ZDb250YWluZXIuaHRtbChwcmV2aWV3KTtcblxuICAgIGlmICghdGhpcy5hcHAuaGFzSXNzdWUoJ2Rvd25sb2FkJykpIHtcbiAgICAgIHRleHRDb250ZW50ID0gdXRpbC50ZXh0QXNEYXRhVVJMKHRleHRDb250ZW50KTtcbiAgICB9XG5cbiAgICB3aW5kb3cuc2V0VGltZW91dChfKGZ1bmN0aW9uKCkgeyAgLy8gc3R1cGlkIGJvb3RzdHJhcCBtb2RhbHMuLi5cbiAgICAgIC8vIHRoaXMgc2V0VGltZW91dCBpcyBuZWVkZWQgZm9yIHRoZSBmbGFzaCBmYWxsYmFjayA6KFxuICAgICAgdGhpcy5tYWtlRG93bmxvYWRhYmxlKHRleHRDb250ZW50LCAnZGF0YScsICcuY3N2Jyk7XG4gICAgfSkuYmluZCh0aGlzKSwgMTAwKTtcbiAgfSxcblxuICBtYWtlRG93bmxvYWRhYmxlOiBmdW5jdGlvbihzdHVmZiwgd2hhdCwgZXh0KSB7XG5cdHZhciBtZXNzYWdlS2V5ID0gWydhbXAuZGFzaGJvYXJkOmNoYXJ0LScsIHRoaXMubW9kZWwuZ2V0KCduYW1lJykucmVwbGFjZSgvIC9nLCAnJyldLmpvaW4oJycpXG5cdHZhciB0cmFuc2xhdGVkTmFtZSA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMobWVzc2FnZUtleSwgdGhpcy5tb2RlbC5nZXQoJ25hbWUnKSk7XG4gICAgdmFyIGZpbGVOYW1lID0gdHJhbnNsYXRlZE5hbWUgKyBleHQsXG4gICAgICAgIGRsQnV0dG9uID0gdGhpcy4kKCcuZG93bmxvYWQtY2hhcnQnKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcbiAgICBkbEJ1dHRvbi5maW5kKCcud29yZCcpLnRleHQoJ0Rvd25sb2FkICcgKyB3aGF0KS5hdHRyKCdkYXRhLWkxOG4nLCAnYW1wLmRhc2hib2FyZDpkb3dubG9hZC1kb3dubG9hZC0nICsgd2hhdCk7XG4gICAgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKGRsQnV0dG9uKTtcblxuICAgIGlmICh0aGlzLmFwcC5oYXNJc3N1ZSgnZG93bmxvYWQnKSkge1xuICAgICAgaWYgKHRoaXMuYXBwLmhhc0lzc3VlKCdmbGFzaCcpKSB7XG4gICAgICAgIHRoaXMuYXBwLnJlcG9ydCgnWW91ciBicm93c2VyIGlzIG1pc3NpbmcgZmVhdHVyZXMgdG8gaW5pdGlhdGUgdGhlIGRvd25sb2FkJywgW1xuICAgICAgICAgICdZb3UgbWlnaHQgYmUgYWJsZSB0byBzYXZlIHRoaXMgY2hhcnQgbWFudWFsbHkgYnkgcmlnaHQtY2xpY2tpbmcgdGhlICcgK1xuICAgICAgICAgICdwcmV2aWV3IGFuZCBzZWxlY3RpbmcgXCJTYXZlIFBpY3R1cmUgQXMuLi4nXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBiYWQgYnJvd3NlciwgYnV0IGhhcyBmbGFzaCEgZmFsbGJhY2sgdG8gZG93bmxvYWRpZnlcbiAgICAgICAgdGhpcy5hcHAudHJ5VG8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgd2luZG93LkRvd25sb2FkaWZ5LmNyZWF0ZShkbEJ1dHRvblswXSwge1xuICAgICAgICAgICAgc3dmOiAnL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2NvbW1vbk1lZGlhL2Rvd25sb2FkaWZ5LnN3ZicsXG4gICAgICAgICAgICBkb3dubG9hZEltYWdlOiAnL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2NvbW1vbk1lZGlhL2Rvd25sb2FkLWJ1dHRvbi1zdGF0ZXMucG5nP3Jldj00JyxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgd2lkdGg6IDE3NixcbiAgICAgICAgICAgIGhlaWdodDogMzQsXG4gICAgICAgICAgICBmaWxlbmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICBkYXRhOiBzdHVmZlxuICAgICAgICAgICAgICAucmVwbGFjZSgnZGF0YTp0ZXh0L3BsYWluO2Jhc2U2NCwvLycsICcnKVxuICAgICAgICAgICAgICAucmVwbGFjZSgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LCcsICcnKSxcbiAgICAgICAgICAgIGRhdGFUeXBlOiBleHQgPT09ICcuY3N2JyA/ICdzdHJpbmcnIDogJ2Jhc2U2NCcsXG4gICAgICAgICAgICBhcHBlbmQ6IHRydWUsXG4gICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHAucmVwb3J0KCdDb3VsZCBub3QgZG93bmxvYWQgdGhlIGZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiQoJy5kb3dubG9hZC1jaGFydCcpXG4gICAgICAgIC5hdHRyKCdocmVmJywgc3R1ZmYpXG4gICAgICAgIC5hdHRyKCdkb3dubG9hZCcsIGZpbGVOYW1lKTtcbiAgICB9XG5cbiAgICAvLyBBTVAtMTk4MTNcbiAgICBpZiAoZXh0LmluZGV4T2YoJ2NzdicpICE9PSAtMSkge1xuICAgIFx0JCgnLm1vZGFsLXByZXZpZXctYXJlYScpLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuXG59KTtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xudmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuICA8aGVhZGVyIGNsYXNzPVxcXCJzcGFjZWQgdGV4dC1jZW50ZXJcXFwiPlxcbiAgICA8aDI+XFxuICAgICAgVGhlIGFwcGxpY2F0aW9uIGVuY291bnRlcmVkIGFuXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRleHQtZGFuZ2VyXFxcIj5lcnJvcjwvc3Bhbj5cXG4gICAgICA8c21hbGw+Oig8L3NtYWxsPlxcbiAgICA8L2gyPlxcbiAgICA8cD48JT0gZXJyICU+PC9wPlxcbiAgPC9oZWFkZXI+XFxuPC9kaXY+XFxuXCIpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgICB0aGlzLmVyciA9IG9wdGlvbnMuZXJyO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSh7IGVycjogdGhpcy5lcnIgfSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn0pO1xuXG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcbnZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMTIgY29sLW1kLTVcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicGFuZWxcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG4gICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRlZmF1bHQgcHVsbC1yaWdodCBzaG93LWZpbHRlcnNcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tZWRpdFxcXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmZpbHRlcnMtZWRpdFxcXCI+RWRpdCBmaWx0ZXJzPC9zcGFuPlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDxoMyBjbGFzcz1cXFwiaW5saW5lLWhlYWRpbmdcXFwiIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjp0aXRsZS1maWx0ZXJzXFxcIj5GaWx0ZXJzPC9oMz5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJhcHBsaWVkLWZpbHRlcnNcXFwiPlxcbiAgICAgICAgPGVtIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjpmaWx0ZXJzLWxvYWRpbmdcXFwiPkxvYWRpbmcuLi48L2VtPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgaWQ9XFxcImZpbHRlci1wb3B1cFxcXCI+PC9kaXY+XFxuXCIpO1xudmFyIHN1bW1hcnlUZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8JSBpZiAoIWNvdW50QXBwbGllZCkgeyAlPlxcbiAgPGVtIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLW5vbmUtYXBwbGllZFxcXCI+Tm8gZmlsdGVycyBhcHBsaWVkPC9lbT5cXG48JSB9IGVsc2UgeyAlPlxcbiAgPHNwYW4+XFxuICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gc2hvdy1maWx0ZXItZGV0YWlsc1xcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tZXllLW9wZW5cXFwiPjwvc3Bhbj5cXG4gICAgICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6ZmlsdGVycy1zaG93LXNldHRpbmdzXFxcIj5TaG93IGZpbHRlciBzZXR0aW5nczwvc3Bhbj5cXG4gICAgICAoPGI+PCU9IGNvdW50QXBwbGllZCAlPjwvYj4pXFxuICAgIDwvYnV0dG9uPlxcbiAgPC9zcGFuPlxcbjwlIH0gJT5cXG5cIik7XG52YXIgZGV0YWlsc1RlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXY+XFxuICA8aDQgY2xhc3M9XFxcImlubGluZS1oZWFkaW5nXFxcIiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6ZmlsdGVycy1hY3RpdmVcXFwiPkFjdGl2ZSBGaWx0ZXJzPC9oND5cXG4gIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tZGVmYXVsdCBoaWRlLWZpbHRlci1kZXRhaWxzXFxcIj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tZXllLWNsb3NlXFxcIj48L3NwYW4+XFxuICAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpmaWx0ZXJzLWhpZGUtZGV0YWlsc1xcXCI+SGlkZSBmaWx0ZXIgZGV0YWlsczwvc3Bhbj5cXG4gIDwvYnV0dG9uPlxcbjwvZGl2PlxcbjwlIF8oYXBwbGllZCkuZWFjaChmdW5jdGlvbihmaWx0ZXIpIHsgJT5cXG4gIDxoNT5cXG4gICAgPGEgaHJlZj1cXFwiI2ZpbHRlci1kZXRhaWwtPCU9IGZpbHRlci5pZCAlPlxcXCIgZGF0YS10b2dnbGU9XFxcImNvbGxhcHNlXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCI+PCU9IGZpbHRlci5uYW1lICU+PC9hPlxcbiAgICAoPCU9IGZpbHRlci5kZXRhaWwubGVuZ3RoICU+KVxcbiAgPC9oNT5cXG4gIDx1bCBpZD1cXFwiZmlsdGVyLWRldGFpbC08JT0gZmlsdGVyLmlkICU+XFxcIiBjbGFzcz1cXFwiY29sbGFwc2VcXFwiPlxcbiAgICA8JSBfKGZpbHRlci5kZXRhaWwpLmVhY2goZnVuY3Rpb24oZGV0YWlsKSB7ICU+XFxuICAgICAgPGxpPjwlPSBkZXRhaWwgJT48L2xpPlxcbiAgICA8JSB9KSAlPlxcbiAgPC91bD5cXG48JSB9KSAlPlwiKTtcbnZhciBmaWx0ZXJzVmlld0xvZyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uLy4uLy4uL3JlYW1wL3Rvb2xzL2xvZycpKCdhbXA6ZGFzaGJvYXJkczpmaWx0ZXJzOnZpZXcnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5zaG93LWZpbHRlcnMnOiAnc2hvd0ZpbHRlcicsXG4gICAgJ2NsaWNrIC5zaG93LWZpbHRlci1kZXRhaWxzJzogJ3Nob3dGaWx0ZXJEZXRhaWxzJyxcbiAgICAnY2xpY2sgLmhpZGUtZmlsdGVyLWRldGFpbHMnOiAnaGlkZUZpbHRlckRldGFpbHMnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuZmluaXNoZWRGaXJzdExvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5hcHAuZmlsdGVyLCAnY2FuY2VsJywgdGhpcy5oaWRlRmlsdGVyKTtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuYXBwLmZpbHRlciwgJ2FwcGx5JywgdGhpcy5hcHBseUZpbHRlcik7XG4gICAgdGhpcy5hcHAuc2V0dGluZ3MubG9hZCgpLmRvbmUoXyhmdW5jdGlvbigpIHtcbiAgICAgIC8vIEV4dHJhY3QgZGVmYXVsdCBkYXRlcyBmcm9tIEdsb2JhbCBTZXR0aW5ncy5cbiAgICAgIHZhciBibG9iID0ge307XG4gICAgICAvLyBBTVAtMTkyNTQsIEFNUC0yMDUzNzogb3ZlcnJpZGUgdGhlIFwiZGF0ZVwiIHJhbmdlIHdpdGggdGhlIERhc2hib2FyZHMtc3BlY2lmaWMgb25lIGZyb20gdGhlIHNldHRpbmdzIGJsb2IgKGEgaGFjay4uLilcbiAgICAgIHRoaXMuYXBwLmZpbHRlci5leHRyYWN0RGF0ZXModGhpcy5hcHAuc2V0dGluZ3MubW9kZWxzLCBibG9iLCAnZGFzaGJvYXJkLWRlZmF1bHQtbWluLWRhdGUnLCAnZGFzaGJvYXJkLWRlZmF1bHQtbWF4LWRhdGUnKTtcblxuICAgICAgdGhpcy5hcHAuZmlsdGVyLmxvYWRlZC5kb25lKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnZmlsdGVycyBsb2FkZWQnKTtcbiAgICAgICAgdGhpcy5hcHAuc3RhdGUucmVnaXN0ZXIodGhpcywgJ2ZpbHRlcnMnLCB7XG4gICAgICAgICAgLy8gbmFtZXNwYWNlIHNlcmlhbGl6ZWQgZmlsdGVycyBzbyB3ZSBjYW4gaG9vayBpbiBleHRyYSBzdGF0ZSB0byBzdG9yZVxuICAgICAgICAgIC8vIGxhdGVyIGlmIGRlc2lyZWQgKGFueXRoaW5nIGRhc2hib2FyZHMtdWkgcmVsYXRlZCwgZm9yIGV4YW1wbGUpXG4gICAgICAgICAgZ2V0OiBfKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmFwcC5maWx0ZXIuc2VyaWFsaXplKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkuYmluZCh0aGlzKSxcbiAgICAgICAgICBzZXQ6IF8oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChfLmlzRW1wdHkoc3RhdGUuZmlsdGVyKSl7ICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGZpbHRlcnNWaWV3TG9nLmxvZygnVXNpbmcgZGVmYXVsdCBmaWx0ZXIgZGF0ZXMuJyk7XG4gICAgICAgICAgICAgIC8vIEFNUC0yMTExODogRG9udCBvdmVycmlkZSBhbGwgZmlsdGVycywganVzdCBkYXRlcyBzZWN0aW9uLlxuICAgICAgICAgICAgICBzdGF0ZS5maWx0ZXIub3RoZXJGaWx0ZXJzID0gYmxvYi5vdGhlckZpbHRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcC5maWx0ZXIuZGVzZXJpYWxpemUoc3RhdGUuZmlsdGVyKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLmZpbHRlci5maW5pc2hlZEZpcnN0TG9hZCA9IHRydWU7XG4gICAgICAgICAgfSkuYmluZCh0aGlzKSxcbiAgICAgICAgICBlbXB0eToge1xuICAgICAgICAgICAgZmlsdGVyOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICB9KS5iaW5kKHRoaXMpKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKCkpO1xuICAgIHRoaXMuYXBwLmZpbHRlci5zZXRFbGVtZW50KHRoaXMuZWwucXVlcnlTZWxlY3RvcignI2ZpbHRlci1wb3B1cCcpKTtcbiAgICB0aGlzLmhpZGVGaWx0ZXIoKTtcbiAgICB0aGlzLmFwcC5maWx0ZXIubG9hZGVkXG4gICAgICAuZG9uZShfKHRoaXMucmVuZGVyQXBwbGllZCkuYmluZCh0aGlzKSlcbiAgICAgIC5mYWlsKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJCgnLmFwcGxpZWQtZmlsdGVycycpLmh0bWwoJzxzdHJvbmcgY2xhc3M9XCJ0ZXh0LWRhbmdlciBmaWx0ZXJzLWVyclwiPicgK1xuICAgICAgICAgICdGYWlsZWQgdG8gbG9hZCBmaWx0ZXJzPC9zdHJvbmc+IDxhIGhyZWY9XCJcIiBjbGFzcz1cImJ0biBidG4td2FybmluZyBidG4tc21cIj4nICtcbiAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXJlZnJlc2hcIj48L3NwYW4+IFJlZnJlc2ggcGFnZTwvYT4nKTtcbiAgICAgICAgdGhpcy4kKCdidXR0b24nKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbmRlckFwcGxpZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmaWx0ZXJzID0gdGhpcy5hcHAuZmlsdGVyLnNlcmlhbGl6ZVRvTW9kZWxzKCk7XG4gICAgdmFyIGNvdW50QXBwbGllZCA9IF8oZmlsdGVycy5jb2x1bW5GaWx0ZXJzKS5rZXlzKCkubGVuZ3RoO1xuICAgIGNvdW50QXBwbGllZCArPSBfKGZpbHRlcnMub3RoZXJGaWx0ZXJzKS5rZXlzKCkubGVuZ3RoO1xuICAgIHRoaXMuJCgnLmFwcGxpZWQtZmlsdGVycycpLmh0bWwoc3VtbWFyeVRlbXBsYXRlKHsgY291bnRBcHBsaWVkOiBjb3VudEFwcGxpZWQgfSkpO1xuICAgIHRoaXMuYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKHRoaXMuZWwpO1xuICB9LFxuXG4gIHNob3dGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYXBwLmZpbHRlci5zaG93RmlsdGVycygpO1xuICAgIHRoaXMuJCgnI2ZpbHRlci1wb3B1cCcpLnNob3coKTtcbiAgfSxcblxuICBoaWRlRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiQoJyNmaWx0ZXItcG9wdXAnKS5oaWRlKCk7XG4gIH0sXG5cbiAgYXBwbHlGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgIC8vIHRvZG86IGFjdHVhbGx5IGRvIGFuIGVmZmVjdCBmb3IgY2hhbmdlZCBmaWx0ZXJzLi4uXG4gICAgdGhpcy5oaWRlRmlsdGVyKCk7XG4gICAgdGhpcy5yZW5kZXJBcHBsaWVkKCk7XG4gIH0sXG5cbiAgc2hvd0ZpbHRlckRldGFpbHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmaWx0ZXJzID0gdGhpcy5hcHAuZmlsdGVyLnNlcmlhbGl6ZVRvTW9kZWxzKCk7XG4gICAgdmFyIGFwcGxpZWQgPSBfKGZpbHRlcnMuY29sdW1uRmlsdGVycykubWFwKGZ1bmN0aW9uKGZpbHRlciwga2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBmaWx0ZXIuZmlsdGVyTmFtZSB8fCBrZXksXG4gICAgICAgIGlkOiBrZXkucmVwbGFjZSgvW15cXHddL2csICcnKSwgLy8gcmVtb3ZlIGFueXRoaW5nIG5vbi1hbHBoYW51bVxuICAgICAgICBkZXRhaWw6IF8oZmlsdGVyKS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0KCduYW1lJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRvIGZpeCBwcm9ibGVtIHdpdGggZGF0ZXMuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IGtleSAmJiB2YWx1ZSAhPT0gZmlsdGVyLmZpbHRlck5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgaWYgKGZpbHRlcnMub3RoZXJGaWx0ZXJzKSB7XG4gICAgICBfLmVhY2goT2JqZWN0LmtleXMoZmlsdGVycy5vdGhlckZpbHRlcnMpLCBmdW5jdGlvbiAoZmlsdGVyS2V5KSB7XG4gICAgICAgICAgdmFyIGZpbHRlckZpZWxkID0gZmlsdGVycy5vdGhlckZpbHRlcnNbZmlsdGVyS2V5XTtcbiAgICAgICAgICB2YXIgZGF0ZVJhbmdlVGV4dCA9ICcnO1xuICAgICAgICAgIGlmKGZpbHRlcktleSA9PT0gJ2RhdGUnKSB7XG4gICAgICAgICAgICBkYXRlUmFuZ2VUZXh0ID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6ZGF0ZS1yYW5nZVwiLCBcIkRhdGUgUmFuZ2VcIik7XG4gICAgICAgICAgfSBlbHNlIGlmKGZpbHRlcktleSA9PT0gJ2NvbXB1dGVkWWVhcicpIHtcbiAgICAgICAgICAgIGRhdGVSYW5nZVRleHQgPSBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKFwiYW1wLmRhc2hib2FyZDpjb21wdXRlZFllYXJcIiwgXCJDb21wdXRlZCBZZWFyXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlUmFuZ2VUZXh0ID0gYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYyhcImFtcC5kYXNoYm9hcmQ6XCIgKyBmaWx0ZXJLZXkucmVwbGFjZSgvW15cXHddL2csICctJyksIGZpbHRlcktleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkZXRhaWwgPSBmaWx0ZXJGaWVsZC5tb2RlbFR5cGUgPT09ICdZRUFSLVNJTkdMRS1WQUxVRSc/IGZpbHRlckZpZWxkLnllYXI6IHRoaXMuYXBwLmZpbHRlci5mb3JtYXREYXRlKGZpbHRlckZpZWxkLnN0YXJ0KSArICcmbWRhc2g7JyArIHRoaXMuYXBwLmZpbHRlci5mb3JtYXREYXRlKGZpbHRlckZpZWxkLmVuZClcbiAgICAgICAgICBhcHBsaWVkLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGZpbHRlcktleS5yZXBsYWNlKC9bXlxcd10vZywgJy0nKSxcbiAgICAgICAgICAgIG5hbWU6IGRhdGVSYW5nZVRleHQsXG4gICAgICAgICAgICBkZXRhaWw6IFtkZXRhaWxdXG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy4kKCcuYXBwbGllZC1maWx0ZXJzJykuaHRtbChkZXRhaWxzVGVtcGxhdGUoeyBhcHBsaWVkOiBhcHBsaWVkIH0pKTtcbiAgICB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTSh0aGlzLmVsKTtcbiAgfSxcblxuICBoaWRlRmlsdGVyRGV0YWlsczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW5kZXJBcHBsaWVkKCk7XG4gIH1cblxufSk7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lRGFzaCA9IHJlcXVpcmUoJy4uL2JhY2tib25lLWRhc2gnKTtcblxudmFyIFN0YXRlTG9hZEVycm9yID0gcmVxdWlyZSgnYW1wLXN0YXRlL2luZGV4JykuU3RhdGVMb2FkRXJyb3I7XG5cbnZhciBDb250cm9scyA9IHJlcXVpcmUoJy4vY29udHJvbHMnKTtcbnZhciBDaGFydHNWaWV3ID0gcmVxdWlyZSgnLi9jaGFydHMnKTtcbnZhciBDaGFydHMgPSByZXF1aXJlKCcuLi9tb2RlbHMvY2hhcnRzLWNvbGxlY3Rpb24nKTtcbnZhciBib2lsZXJwbGF0ZSA9IHJlcXVpcmUoJ2FtcC1ib2lsZXJwbGF0ZScpO1xudmFyIEhlYXRNYXBDaGFydCA9IHJlcXVpcmUoJy4uL21vZGVscy9jaGFydC1oZWF0bWFwcycpO1xudmFyIFRvcHNDaGFydCA9IHJlcXVpcmUoJy4uL21vZGVscy9jaGFydC10b3BzJyk7XG52YXIgUHJlZGljdGFiaWxpdHlDaGFydCA9IHJlcXVpcmUoJy4uL21vZGVscy9jaGFydC1haWQtcHJlZGljdGFiaWxpdHknKTtcbnZhciBGdW5kaW5nVHlwZUNoYXJ0ID0gcmVxdWlyZSgnLi4vbW9kZWxzL2NoYXJ0LWZ1bmRpbmctdHlwZScpO1xuXG52YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKFwiPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG48L2Rpdj5cXG5cIik7XG52YXIgbW9kYWxUZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8ZGl2IGNsYXNzPVxcXCJtb2RhbCBmYWRlXFxcIiBpZD1cXFwiPCU9IG0uaWQgJT5cXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwiZGlhbG9nXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcIm15TW9kYWxMYWJlbFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZGlhbG9nIDwlPSBtLnNwZWNpYWxDbGFzcyAlPlxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWNvbnRlbnRcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWhlYWRlclxcXCI+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIj48c3BhbiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvc3Bhbj48c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6Y2xvc2VcXFwiIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5DbG9zZTwvc3Bhbj48L2J1dHRvbj5cXG4gICAgICAgIDxoNCBjbGFzcz1cXFwibW9kYWwtdGl0bGUgdGV4dC08JT0gbS50b25lICU+XFxcIiBkYXRhLWkxOG49XFxcIjwlPSBtLmkxOG5UaXRsZSAlPlxcXCI+PCU9IG0udGl0bGUgJT48L2g0PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHlcXFwiPlxcbiAgICAgICAgPCUgaWYgKG0uY29udGVudCkgeyAlPlxcbiAgICAgICAgICA8JT0gbS5jb250ZW50ICU+XFxuICAgICAgICA8JSB9ICU+XFxuICAgICAgICA8JSBpZiAobS5tZXNzYWdlcykgeyAlPlxcbiAgICAgICAgICA8JSBfKG0ubWVzc2FnZXMpLmVhY2goZnVuY3Rpb24obWVzc2FnZSkgeyAlPlxcbiAgICAgICAgICAgIDxwPjwlPSBtZXNzYWdlICU+PC9wPlxcbiAgICAgICAgICA8JSB9KSAlPlxcbiAgICAgICAgPCUgfSAlPlxcbiAgICAgIDwvZGl2PiAgICAgIFxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiKTtcblxudmFyIEVuYWJsZWRDaGFydHNDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vbW9kZWxzL2VuYWJsZWQtY2hhcnRzLWNvbGxlY3Rpb24nKTtcbnZhciBIZWF0bWFwc0NvbmZpZ0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9tb2RlbHMvaGVhdG1hcHMtY29uZmlnLWNvbGxlY3Rpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZURhc2guVmlldy5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICAgICAgICBcbiAgICB0aGlzLmFwcC5zZXR0aW5ncy5sb2FkKCk7ICAvLyBtYXliZSBzaG91bGQgZ28gaW4gcmVuZGVyIG9yIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBhbHJlYWR5IGRvIG90aGVyIGZldGNoZXMgb24gaW5pdCBzby4uLlxuICAgIHRoaXMuYXBwLnVzZXIuZmV0Y2goKTtcbiAgICB0aGlzLmNvbnRyb2xzID0gbmV3IENvbnRyb2xzKHsgYXBwOiB0aGlzLmFwcCB9KTtcblxuICAgIC8vIEFNUC0xOTU0NTogV2UgaW5zdGFudGlhdGUgdGhlIGNvbGxlY3Rpb24gb2YgZW5hYmxlZCBjaGFydHMgKGZyb20gRk0pIGFuZCB1c2UgaXQgdG8gZW5hYmxlIG9yIG5vdCBlYWNoIGNoYXJ0LlxuICAgIHZhciBlbmFibGVkQ2hhcnRzRk0gPSBuZXcgRW5hYmxlZENoYXJ0c0NvbGxlY3Rpb24oKTtcbiAgICBlbmFibGVkQ2hhcnRzRk0uZmV0Y2hEYXRhKCk7XG4gICAgXG4gICAgLy8gR2V0IGNvbmZpZyBvZiBhbGwgaGVhdG1hcHMgZnJvbSBiYWNrZW5kLlxuICAgIHZhciBoZWF0bWFwc0NvbmZpZ3MgPSBuZXcgSGVhdG1hcHNDb25maWdDb2xsZWN0aW9uKCk7XG4gICAgaGVhdG1hcHNDb25maWdzLmZldGNoRGF0YSgpO1xuICAgIFxuICAgIGlmKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdlcnJvcicpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVGhlIHNhbWUgZW5kcG9pbnQgd2lsbCBzZW5kIGFuIGVycm9yIGlmICdEQVNIQk9BUkRTJyBpcyBub3QgYWN0aXZlIGluIHRoZSBGZWF0dXJlIE1hbmFnZXIuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9ICcvJztcbiAgICB9XG4gICAgXG4gICAgdmFyIGNvbCA9IFtdO1xuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnVG9wIERvbm9ycyd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnVG9wIERvbm9yIEFnZW5jaWVzJywgYmlnOiBmYWxzZSwgdmlldzogJ2JhcicgfSxcbiAgXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvdG9wcy9kbycgfSkpO1xuICAgIH1cbiAgICBpZihfLmZpbmQoZW5hYmxlZENoYXJ0c0ZNLm1vZGVsc1swXS5nZXQoJ0RBU0hCT0FSRFMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtID09PSAgJ1RvcCBEb25vciBHcm91cCd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnVG9wIERvbm9yIEdyb3VwcycsIGJpZzogZmFsc2UsIHZpZXc6ICdiYXInIH0sXG4gIFx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL3RvcHMvZGcnIH0pKTtcbiAgICB9XG4gICAgaWYoXy5maW5kKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdEQVNIQk9BUkRTJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSA9PT0gICdUb3AgUmVnaW9ucyd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnVG9wIFJlZ2lvbnMnLCBiaWc6IGZhbHNlLCB2aWV3OiAnYmFyJyB9LFxuXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvdG9wcy9yZScgfSkpO1xuICAgIH1cbiAgICBpZihfLmZpbmQoZW5hYmxlZENoYXJ0c0ZNLm1vZGVsc1swXS5nZXQoJ0RBU0hCT0FSRFMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtID09PSAgJ1RvcCBTZWN0b3JzJ30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgVG9wc0NoYXJ0KFxuICBcdCAgICAgICAgICB7IG5hbWU6ICdUb3AgU2VjdG9ycycsIGJpZzogZmFsc2UsIHZpZXc6ICdiYXInIH0sXG5cdCAgICAgICAgICB7IGFwcDogdGhpcy5hcHAsIHVybDogJy9yZXN0L2Rhc2hib2FyZC90b3BzL3BzJyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnQWlkIFByZWRpY3RhYmlsaXR5J30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgUHJlZGljdGFiaWxpdHlDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnQWlkIFByZWRpY3RhYmlsaXR5JyB9LFxuXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvYWlkLXByZWRpY3RhYmlsaXR5JyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnRnVuZGluZyBUeXBlJ30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgRnVuZGluZ1R5cGVDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnRnVuZGluZyBUeXBlJyB9LFxuXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvZnR5cGUnIH0pKTtcbiAgICB9XG4gICAgaWYoXy5maW5kKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdEQVNIQk9BUkRTJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSA9PT0gICdSZXNwb25zaWJsZSBPcmdhbml6YXRpb25zJ30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgVG9wc0NoYXJ0KFxuICBcdCAgICAgICAgICB7IG5hbWU6ICdSZXNwb25zaWJsZSBPcmdhbml6YXRpb25zJywgYmlnOiBmYWxzZSwgdmlldzogJ2JhcicgfSxcblx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL3RvcHMvcm8nIH0pKTtcbiAgICB9XG4gICAgaWYoXy5maW5kKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdEQVNIQk9BUkRTJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSA9PT0gICdCZW5lZmljaWFyeSBBZ2VuY2llcyd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnQmVuZWZpY2lhcnkgQWdlbmNpZXMnLCBiaWc6IGZhbHNlLCB2aWV3OiAnYmFyJyB9LFxuXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvdG9wcy9iYScgfSkpO1xuICAgIH1cbiAgICBpZihfLmZpbmQoZW5hYmxlZENoYXJ0c0ZNLm1vZGVsc1swXS5nZXQoJ0RBU0hCT0FSRFMnKSwgZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtID09PSAgJ0V4ZWN1dGluZyBBZ2VuY2llcyd9KSkge1xuICAgIFx0Y29sLnB1c2gobmV3IFRvcHNDaGFydChcbiAgXHQgICAgICAgICAgeyBuYW1lOiAnRXhlY3V0aW5nIEFnZW5jaWVzJywgYmlnOiBmYWxzZSwgdmlldzogJ2JhcicgfSxcblx0ICAgICAgICAgIHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL3RvcHMvZWEnIH0pKTtcbiAgICB9XG4gICAgaWYoXy5maW5kKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdEQVNIQk9BUkRTJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSA9PT0gICdJbXBsZW1lbnRpbmcgQWdlbmNpZXMnfSkpIHtcbiAgICBcdGNvbC5wdXNoKG5ldyBUb3BzQ2hhcnQoXG4gIFx0ICAgICAgICAgIHsgbmFtZTogJ0ltcGxlbWVudGluZyBBZ2VuY2llcycsIGJpZzogZmFsc2UsIHZpZXc6ICdiYXInIH0sXG5cdCAgICAgICAgICB7IGFwcDogdGhpcy5hcHAsIHVybDogJy9yZXN0L2Rhc2hib2FyZC90b3BzL2lhJyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnUGVhY2UtYnVpbGRpbmcgYW5kIFN0YXRlLWJ1aWxkaW5nIEdvYWxzJ30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgVG9wc0NoYXJ0KFxuICAgIFx0XHRcdHsgbmFtZTogJ1BlYWNlLWJ1aWxkaW5nIGFuZCBTdGF0ZS1idWlsZGluZyBHb2FscycsIGJpZzogdHJ1ZSwgc2hvd0NhdGVnb3JpZXNJbmZvOiB0cnVlLCB2aWV3OiAncGllJyB9LFxuICAgIFx0XHRcdHsgYXBwOiB0aGlzLmFwcCwgdXJsOiAnL3Jlc3QvZGFzaGJvYXJkL3RvcHMvbmRkJyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnU2VjdG9yIEZyYWdtZW50YXRpb24nfSkpIHtcbiAgICBcdGNvbC5wdXNoKG5ldyBIZWF0TWFwQ2hhcnQoXG4gIFx0ICAgICAgICAgIHsgbmFtZTogJ0hlYXRNYXAgYnkgU2VjdG9yIGFuZCBEb25vciBHcm91cCcsIHRpdGxlOiAnU2VjdG9yIEZyYWdtZW50YXRpb24nLCBiaWc6IHRydWUsIHZpZXc6ICdoZWF0bWFwJywgaGVhdG1hcF9jb25maWc6IGhlYXRtYXBzQ29uZmlncywgaGVhdG1hcF90eXBlOiAnc2VjdG9yJyB9LFxuICBcdCAgICAgICAgICB7IGFwcDogdGhpcy5hcHAsIHVybDogJy9yZXN0L2Rhc2hib2FyZC9oZWF0LW1hcC9zZWMnIH0pKTtcbiAgICB9XG4gICAgaWYoXy5maW5kKGVuYWJsZWRDaGFydHNGTS5tb2RlbHNbMF0uZ2V0KCdEQVNIQk9BUkRTJyksIGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSA9PT0gICdMb2NhdGlvbiBGcmFnbWVudGF0aW9uJ30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgSGVhdE1hcENoYXJ0KFxuICBcdCAgICAgICAgICB7IG5hbWU6ICdIZWF0TWFwIGJ5IExvY2F0aW9uIGFuZCBEb25vciBHcm91cCcsIHRpdGxlOiAnTG9jYXRpb24gRnJhZ21lbnRhdGlvbicsIGJpZzogdHJ1ZSwgdmlldzogJ2hlYXRtYXAnLCBoZWF0bWFwX2NvbmZpZzogaGVhdG1hcHNDb25maWdzLCBoZWF0bWFwX3R5cGU6ICdsb2NhdGlvbicgfSxcbiAgXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvaGVhdC1tYXAvbG9jJyB9KSk7XG4gICAgfVxuICAgIGlmKF8uZmluZChlbmFibGVkQ2hhcnRzRk0ubW9kZWxzWzBdLmdldCgnREFTSEJPQVJEUycpLCBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gPT09ICAnUHJvZ3JhbSBGcmFnbWVudGF0aW9uJ30pKSB7XG4gICAgXHRjb2wucHVzaChuZXcgSGVhdE1hcENoYXJ0KFxuICBcdCAgICAgICAgICB7IG5hbWU6ICdIZWF0TWFwIGJ5IFByb2dyYW0gYW5kIERvbm9yIEdyb3VwJywgdGl0bGU6ICdQcm9ncmFtIEZyYWdtZW50YXRpb24nLCBiaWc6IHRydWUsIHZpZXc6ICdoZWF0bWFwJywgaGVhdG1hcF9jb25maWc6IGhlYXRtYXBzQ29uZmlncywgaGVhdG1hcF90eXBlOiAncHJvZ3JhbScgfSxcbiAgXHQgICAgICAgICAgeyBhcHA6IHRoaXMuYXBwLCB1cmw6ICcvcmVzdC9kYXNoYm9hcmQvaGVhdC1tYXAvcHJnJyB9KSk7XG4gICAgfVxuICAgICAgIFxuICAgIHZhciBjaGFydHNDb2xsZWN0aW9uID0gbmV3IENoYXJ0cyhjb2wsIHsgYXBwOiB0aGlzLmFwcCB9KTtcbiAgICB0aGlzLmNoYXJ0cyA9IG5ldyBDaGFydHNWaWV3KHtcbiAgICAgIGFwcDogdGhpcy5hcHAsXG4gICAgICBjb2xsZWN0aW9uOiBjaGFydHNDb2xsZWN0aW9uXG4gICAgfSk7XG4gICAgXG4gICAgLy9hdXRvLXJlbmRlcnMgdGhlIGxheW91dFxuICAgIHRoaXMuaGVhZGVyV2lkZ2V0ID0gbmV3IGJvaWxlcnBsYXRlLmxheW91dChcbiAgICAgIHtcbiAgICAgICAgY2FsbGVyOiAnREFTSEJPQVJEJ1xuXHQgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSgpKTtcbiAgICB0aGlzLiQoJy5jb250YWluZXInKS5odG1sKFtcbiAgICAgIHRoaXMuY29udHJvbHMucmVuZGVyKCkuZWwsXG4gICAgICB0aGlzLmNoYXJ0cy5yZW5kZXIoKS5lbCxcbiAgICBdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBtb2RhbDogZnVuY3Rpb24odGl0bGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXyh7XG4gICAgICB0aXRsZTogdGl0bGUsXG4gICAgICBpZDogXy51bmlxdWVJZCgnbW9kYWwnKVxuICAgIH0pLmV4dGVuZChvcHRpb25zKTtcbiAgICB0aGlzLiRlbC5wYXJlbnQoKS5hcHBlbmQobW9kYWxUZW1wbGF0ZSh7bTogb3B0aW9uc30pKTtcbiAgICB2YXIgdGhpc01vZGFsID0gdGhpcy4kZWwucGFyZW50KCkuZmluZCgnIycgKyBvcHRpb25zLmlkKTtcbiAgICBpZiAob3B0aW9ucy5ib2R5RWwpIHsgdGhpc01vZGFsLmZpbmQoJy5tb2RhbC1ib2R5JykuaHRtbChvcHRpb25zLmJvZHlFbCk7IH1cbiAgICB0aGlzTW9kYWwubW9kYWwoKTtcbiAgICByZXR1cm4gdGhpc01vZGFsWzBdOyAgLy8gdGhlIGFjdHVhbCBET00gZWxlbWVudFxuICB9XG5cbn0pO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZURhc2ggPSByZXF1aXJlKCcuLi9iYWNrYm9uZS1kYXNoJyk7XG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vLi4vLi4vcmVhbXAvdG9vbHMvbG9nJykoJ2FtcDpkYXNoYm9hcmRzOnNldHRpbmdzOm1vZGFsJyk7XG52YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKFwiPGRpdiBjbGFzcz1cXFwidGFiLWNvbnRlbnQgZmlsdGVyLW9wdGlvbnNcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwidGFiLXBhbmUgYWN0aXZlXFxcIj5cXG4gICAgPHVsIGNsYXNzPVxcXCJzdWItZmlsdGVycy10aXRsZXMgbmF2IG5hdi1waWxscyBuYXYtc3RhY2tlZFxcXCI+XFxuICAgICAgPCUgXyhzZXR0aW5ncy5nZXRWaXNpYmxlKCkpLmVhY2goZnVuY3Rpb24oc2V0dGluZykgeyAlPlxcbiAgICAgICAgPGxpIDwlPSBzZXR0aW5nLmlkID09PSBjdXJyZW50LmlkID8gJ2NsYXNzPVxcXCJhY3RpdmVcXFwiJyA6ICcnICU+PlxcbiAgICAgICAgICA8YSBjbGFzcz1cXFwic2V0dGluZy1zZWxlY3RcXFwiIGhyZWY9XFxcIiM8JT0gc2V0dGluZy5pZCAlPlxcXCI+PHNwYW4+PCU9IHNldHRpbmcuZ2V0KCduYW1lJykgJT48L3NwYW4+PC9hPlxcbiAgICAgICAgPC9saT5cXG4gICAgICA8JSB9KSAlPlxcbiAgICA8L3VsPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJzdWItZmlsdGVycy1jb250ZW50XFxcIj5cXG4gICAgICA8c2VsZWN0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgc2V0dGluZy12YWx1ZVxcXCI+XFxuICAgICAgICA8JSBfKGN1cnJlbnQuZ2V0KCdvcHRpb25zJykpLmVhY2goZnVuY3Rpb24ob3B0aW9uKSB7ICU+XFxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjwlPSBvcHRpb24uaWQgJT5cXFwiIDwlPSBvcHRpb24uc2VsZWN0ZWQgPyAnc2VsZWN0ZWQ9XFxcInNlbGVjdGVkXFxcIicgOiAnJyAlPj48JT0gb3B0aW9uLm5hbWUgJT48L29wdGlvbj5cXG4gICAgICAgIDwlIH0pICU+XFxuICAgICAgPC9zZWxlY3Q+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwibW9kYWwtZm9vdGVyXFxcIj5cXG5cXHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc3VjY2VzcyBhcHBseVxcXCIgZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmFwcGx5XFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIj5BcHBseTwvYnV0dG9uPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCIgZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmNsb3NlXFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIj5DbG9zZTwvYnV0dG9uPlxcbjwvZGl2PlxcblwiKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lRGFzaC5WaWV3LmV4dGVuZCh7XG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5zZXR0aW5nLXNlbGVjdCc6ICdzZWxlY3RTZXR0aW5nJyxcbiAgICAnY2hhbmdlIC5zZXR0aW5nLXZhbHVlJzogJ2NoYW5nZVNldHRpbmcnLFxuICAgICdjbGljayAuYXBwbHknOiAnYXBwbHlTZXR0aW5ncydcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcbiAgICBsb2dnZXIubG9nKFwiSW5pdGlhbGl6ZWQgd2l0aFwiLCBvcHRpb25zKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50KSB7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmFwcC5zZXR0aW5ncy5nZXRWaXNpYmxlKClbMF07XG4gICAgICBsb2dnZXIubG9nKFwiUmVuZGVyIHJlcXVlc3RlZCwgYnV0IHRoZXJlJ3Mgbm8gIGN1cnJlbnQgc2V0dGluZy4gVHJ5aW5nIHRvIGd1ZXNzIGl0XCIpO1xuICAgIH1cbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKHtcbiAgICAgIHNldHRpbmdzOiB0aGlzLmFwcC5zZXR0aW5ncyxcbiAgICAgIGN1cnJlbnQ6IHRoaXMuY3VycmVudFxuICAgIH0pKTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgbG9nZ2VyLm9uRGVidWcoZnVuY3Rpb24oKXtcbiAgICAgIGxvZ2dlci5sb2coXCJSZW5kZXJlZCB3aWR0aCBjdXJyZW50PVwiLCB0aGF0LmN1cnJlbnQudG9KU09OKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNlbGVjdFNldHRpbmc6IGZ1bmN0aW9uKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7ICAvLyBkb24ndCBjaGFuZ2UgVVJMXG4gICAgdmFyIHNldHRpbmdJZCA9IGUuY3VycmVudFRhcmdldC5oYXNoLnNsaWNlKDEpOyAgLy8gcmVtb3ZlcyAnIydcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmFwcC5zZXR0aW5ncy5nZXQoc2V0dGluZ0lkKTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgbG9nZ2VyLm9uRGVidWcoZnVuY3Rpb24oKXtcbiAgICAgIGxvZ2dlci5sb2coXCJDdXJyZW50IHNldHRpbmcgY2hhbmdlZCB0b1wiLCB0aGF0LmN1cnJlbnQudG9KU09OKCkpO1xuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH0sXG5cbiAgY2hhbmdlU2V0dGluZzogZnVuY3Rpb24oZSkge1xuICAgIHZhciBvcHRpb25JZCA9IGUuY3VycmVudFRhcmdldC52YWx1ZTtcbiAgICBsb2dnZXIubG9nKFwiQ2hhbmdpbmdcIiwgb3B0aW9uSWQsIFwic2V0dGluZ1wiKTsgXG4gICAgdGhpcy5jdXJyZW50LnNlbGVjdChvcHRpb25JZCwgZmFsc2UpO1xuICB9LFxuICBcbiAgYXBwbHlTZXR0aW5nczogZnVuY3Rpb24oZSkge1xuXHQgIHRoaXMuY3VycmVudC5hcHBseSgpO1xuICB9XG59KTtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xudmFyIE1vZGFsVmlldyA9IHJlcXVpcmUoJy4vc2V0dGluZ3MtbW9kYWwnKTtcbnZhciB0ZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMTIgY29sLXNtLTYgY29sLW1kLTNcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwicGFuZWxcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG4gICAgICA8aDMgZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOmRhc2hib2FyZC1zZXR0aW5nc1xcXCIgY2xhc3M9XFxcImlubGluZS1oZWFkaW5nXFxcIiBzdHlsZT1cXFwibWF4LXdpZHRoOiA1MHB4O292ZXJmbG93LXg6IHZpc2libGVcXFwiPlNldHRpbmdzPC9oMz5cXG4gICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRlZmF1bHQgcHVsbC1yaWdodCBkYXNoLXNldHRpbmdzLWJ1dHRvblxcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1lZGl0XFxcIj48L3NwYW4+XFxuICAgICAgICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6c2V0dGluZ3MtZWRpdFxcXCI+ZWRpdCBzZXR0aW5nczwvc3Bhbj5cXG4gICAgICA8L2J1dHRvbj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIik7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZURhc2guVmlldy5leHRlbmQoe1xuXG4gIGV2ZW50czoge1xuICAgICdjbGljayAuZGFzaC1zZXR0aW5ncy1idXR0b24nOiAnZWRpdFNldHRpbmdzJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICAgIHRoaXMubW9kYWxWaWV3ID0gbmV3IE1vZGFsVmlldyh7IGFwcDogdGhpcy5hcHAsIGNvbGxlY3Rpb246IHRoaXMuY29sbGVjdGlvbiB9KTtcblxuICAgIHRoaXMuYXBwLnNldHRpbmdzLl9sb2FkZWQuZG9uZShfKGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hcHAuc3RhdGUucmVnaXN0ZXIodGhpcywgJ3NldHRpbmdzJywge1xuICAgICAgICBnZXQ6IHRoaXMuYXBwLnNldHRpbmdzLnRvQVBJLFxuICAgICAgICBzZXQ6IHRoaXMuYXBwLnNldHRpbmdzLmZyb21TdGF0ZVxuICAgICAgfSk7XG4gICAgfSkuYmluZCh0aGlzKSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRlbC5odG1sKHRlbXBsYXRlKCkpOyAgXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZWRpdFNldHRpbmdzOiBmdW5jdGlvbigpIHtcblx0dmFyIHNwZWNpYWxDbGFzcyA9ICdkYXNoLXNldHRpbmdzLW1vZGFsJztcbiAgICB0aGlzLmFwcC5tb2RhbCgnU2V0dGluZ3MnLCB7XG4gICAgICBzcGVjaWFsQ2xhc3M6IHNwZWNpYWxDbGFzcyxcbiAgICAgIGJvZHlFbDogdGhpcy5tb2RhbFZpZXcucmVuZGVyKCkuZWwsXG4gICAgICBpMThuVGl0bGU6ICdhbXAuZGFzaGJvYXJkOmRhc2hib2FyZC1zZXR0aW5ncydcbiAgICB9KTtcbiAgICBcbiAgICAvLyBUcmFuc2xhdGUgbW9kYWwgcG9wdXAuXG4gICAgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKCQoXCIuXCIgKyBzcGVjaWFsQ2xhc3MpKTtcbiAgfVxuXG59KTtcbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmVEYXNoID0gcmVxdWlyZSgnLi4vYmFja2JvbmUtZGFzaCcpO1xudmFyIHRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcImNvbC14cy0xMiBjb2wtc20tNiBjb2wtbWQtNFxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJwYW5lbFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiPlxcbiAgICAgIDxoMyBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6c2hhcmUtZGFzaGJvYXJkLXRvcFxcXCIgY2xhc3M9XFxcImlubGluZS1oZWFkaW5nXFxcIj5TaGFyZTwvaDM+XFxuICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0IHB1bGwtcmlnaHQgZGFzaC1zaGFyZS1idXR0b25cXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tbGlua1xcXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOnNoYXJlLWxpbmtcXFwiPmxpbms8L3NwYW4+XFxuICAgICAgPC9idXR0b24+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwiZGFzaC1zaGFyZS1tb2RhbCBtb2RhbCBmYWRlXFxcIiBpZD1cXFwiPCU9IGRldGFpbHMuaWQgJT5cXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwiZGlhbG9nXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcIm15TW9kYWxMYWJlbFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZGlhbG9nXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFuZWwgcGFuZWwtcHJpbWFyeVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZyBmaXgtdGl0bGUtaGVpZ2h0XFxcIj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiY2xvc2VcXFwiIGRhdGEtZGlzbWlzcz1cXFwibW9kYWxcXFwiPjxzcGFuIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj4mdGltZXM7PC9zcGFuPjxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjbG9zZVxcXCIgY2xhc3M9XFxcInNyLW9ubHlcXFwiPkNsb3NlPC9zcGFuPjwvYnV0dG9uPlxcbiAgICAgICAgPHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOnNoYXJlLWRhc2hib2FyZFxcXCI+U2hhcmUgdGhpcyBkYXNoYm9hcmQgdmlldzwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXG4gICAgICAgIDxmb3JtIHJvbGU9XFxcImZvcm1cXFwiPlxcbiAgICAgICAgICA8bGFiZWwgZGF0YS1pMThuPVxcXCJhbXAuZGFzaGJvYXJkOnNoYXJlLWxpbmtcXFwiIGZvcj1cXFwiZGFzaC1zaGFyZS11cmxcXFwiPkxpbms8L2xhYmVsPlxcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidXJsXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBpZD1cXFwiZGFzaC1zaGFyZS11cmxcXFwiIC8+XFxuICAgICAgICA8L2Zvcm0+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicGFuZWwtZm9vdGVyXFxcIj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6Y2xvc2VcXFwiIGRhdGEtZGlzbWlzcz1cXFwibW9kYWxcXFwiPkNsb3NlPC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCIpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmVEYXNoLlZpZXcuZXh0ZW5kKHtcblxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLmRhc2gtc2hhcmUtYnV0dG9uJzogJ3NoYXJlJ1xuICB9LFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0ZW1wbGF0ZSh7IGRldGFpbHM6IHt9IH0pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzaGFyZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNhdmluZyA9IGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoXCJhbXAuZGFzaGJvYXJkOnNhdmluZy1zdGF0ZVwiLFwiU2F2aW5nIGRhc2hib2FyZCBzdGF0ZSwgcGxlYXNlIHdhaXQuLi5cIik7XG5cdCAgXG4gICAgdGhpcy4kKCcjZGFzaC1zaGFyZS11cmwnKVxuICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJylcbiAgICAgIC52YWwoc2F2aW5nKTtcblxuICAgIHZhciBzdGF0ZUJsb2IgPSB0aGlzLmFwcC5zdGF0ZS5mcmVlemUoKTtcblxuICAgIHRoaXMubGlzdGVuVG9PbmNlKHRoaXMuYXBwLnNhdmVkRGFzaGVzLCAncmVxdWVzdCcsIGZ1bmN0aW9uKG1vZGVsLCB4aHIpIHtcbiAgICAgIC8vIHRoaXMgaGFzIHRvIGJlIHNldCB1cCBiZWZvcmUgLmNyZWF0ZSwgc28gd2UgZG9uJ3QgbWlzcyBpdFxuICAgICAgeGhyXG4gICAgICAgIC5kb25lKF8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGlkID0gbW9kZWwuZ2V0KCdpZCcpO1xuICAgICAgICAgIHRoaXMuYXBwLnVybC5oYXNoKHRoaXMuYXBwLnN0YXRlLnRvSGFzaChpZCksIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgICAgIHRoaXMuJCgnI2Rhc2gtc2hhcmUtdXJsJylcbiAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpXG4gICAgICAgICAgICAudmFsKHRoaXMuYXBwLnVybC5mdWxsKCkpO1xuICAgICAgICB9KS5iaW5kKHRoaXMpKVxuICAgICAgICAuZmFpbChfKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuJCgnI2Rhc2gtc2hhcmUtdXJsJykudmFsKCdFcnJvcjogY291bGQgbm90IHNhdmUgZGFzaGJvYXJkIGZvciBzaGFyaW5nLicpO1xuICAgICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYXBwLnNhdmVkRGFzaGVzLmNyZWF0ZSh7ICAvLyBjcmVhdGUgZG9lcyBQT1NUXG4gICAgICB0aXRsZTogJ0Rhc2hib2FyZCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ1NhdmVkIGRhc2hib2FyZCcsXG4gICAgICBzdGF0ZUJsb2I6IHN0YXRlQmxvYlxuICAgIH0sIHsgYXBwOiB0aGlzLmFwcCB9KTtcblxuICAgIHRoaXMuJCgnLmRhc2gtc2hhcmUtbW9kYWwnKS5tb2RhbCgpO1xuICB9XG5cbn0pO1xuIiwiLy8gbnZkMyBnb2VzIGdsb2JhbCBzaWdoLi4uIG1ha2Ugc3VyZSBkMyBpcyBhbHJlYWR5IGdsb2JhbFxuLyogVE9ETzogaW4gdGhpcyB2ZXJzaW9uIG9mIG52ZDMgdjEuNy4xLCBtYWluIGlzIG5vdCBzcGVjaWZpZWQgaW4gcGFja2FnZS5qc29uLFxuIGlmIHdlIGV2ZXIgdXBncmFkZSB0byAxLjgrLCBjaGFuZ2UgdGhpcyBiYWNrIHRvIGp1c3QgcmVxdWlyZShudmQzKSAqL1xucmVxdWlyZSgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL252ZDMvYnVpbGQvbnYuZDMnKTtcblxuLy8gbG9hZCB1bmRlcnNjb3JlIG1peGluc1xucmVxdWlyZSgnLi91bmRlcnNjb3JlLXRyYW5zcG9zZScpO1xuXG4vLyBsb2FkIGNhbnZnIHN0dWZmXG53aW5kb3cuUkdCQ29sb3IgPSByZXF1aXJlKCcuL2xpYi1zcmMvcmdiY29sb3InKTtcbnJlcXVpcmUoJy4vbGliLXNyYy9jYW52ZycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYW52Zzogd2luZG93LmNhbnZnXG59O1xuIiwiLypcbiAqIGNhbnZnLmpzIC0gSmF2YXNjcmlwdCBTVkcgcGFyc2VyIGFuZCByZW5kZXJlciBvbiBDYW52YXNcbiAqIE1JVCBMaWNlbnNlZCBcbiAqIEdhYmUgTGVybmVyIChnYWJlbGVybmVyQGdtYWlsLmNvbSlcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9jYW52Zy9cbiAqXG4gKiBSZXF1aXJlczogcmdiY29sb3IuanMgLSBodHRwOi8vd3d3LnBocGllZC5jb20vcmdiLWNvbG9yLXBhcnNlci1pbi1qYXZhc2NyaXB0L1xuICovXG4oZnVuY3Rpb24oKXtcbiAgICAvLyBjYW52Zyh0YXJnZXQsIHMpXG4gICAgLy8gZW1wdHkgcGFyYW1ldGVyczogcmVwbGFjZSBhbGwgJ3N2ZycgZWxlbWVudHMgb24gcGFnZSB3aXRoICdjYW52YXMnIGVsZW1lbnRzXG4gICAgLy8gdGFyZ2V0OiBjYW52YXMgZWxlbWVudCBvciB0aGUgaWQgb2YgYSBjYW52YXMgZWxlbWVudFxuICAgIC8vIHM6IHN2ZyBzdHJpbmcsIHVybCB0byBzdmcgZmlsZSwgb3IgeG1sIGRvY3VtZW50XG4gICAgLy8gb3B0czogb3B0aW9uYWwgaGFzaCBvZiBvcHRpb25zXG4gICAgLy8gICAgICAgaWdub3JlTW91c2U6IHRydWUgPT4gaWdub3JlIG1vdXNlIGV2ZW50c1xuICAgIC8vICAgICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSA9PiBpZ25vcmUgYW5pbWF0aW9uc1xuICAgIC8vICAgICAgIGlnbm9yZURpbWVuc2lvbnM6IHRydWUgPT4gZG9lcyBub3QgdHJ5IHRvIHJlc2l6ZSBjYW52YXNcbiAgICAvLyAgICAgICBpZ25vcmVDbGVhcjogdHJ1ZSA9PiBkb2VzIG5vdCBjbGVhciBjYW52YXNcbiAgICAvLyAgICAgICBvZmZzZXRYOiBpbnQgPT4gZHJhd3MgYXQgYSB4IG9mZnNldFxuICAgIC8vICAgICAgIG9mZnNldFk6IGludCA9PiBkcmF3cyBhdCBhIHkgb2Zmc2V0XG4gICAgLy8gICAgICAgc2NhbGVXaWR0aDogaW50ID0+IHNjYWxlcyBob3Jpem9udGFsbHkgdG8gd2lkdGhcbiAgICAvLyAgICAgICBzY2FsZUhlaWdodDogaW50ID0+IHNjYWxlcyB2ZXJ0aWNhbGx5IHRvIGhlaWdodFxuICAgIC8vICAgICAgIHJlbmRlckNhbGxiYWNrOiBmdW5jdGlvbiA9PiB3aWxsIGNhbGwgdGhlIGZ1bmN0aW9uIGFmdGVyIHRoZSBmaXJzdCByZW5kZXIgaXMgY29tcGxldGVkXG4gICAgLy8gICAgICAgZm9yY2VSZWRyYXc6IGZ1bmN0aW9uID0+IHdpbGwgY2FsbCB0aGUgZnVuY3Rpb24gb24gZXZlcnkgZnJhbWUsIGlmIGl0IHJldHVybnMgdHJ1ZSwgd2lsbCByZWRyYXdcbiAgICB0aGlzLmNhbnZnID0gZnVuY3Rpb24gKHRhcmdldCwgcywgb3B0cykge1xuICAgICAgICAvLyBubyBwYXJhbWV0ZXJzXG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCAmJiBzID09IG51bGwgJiYgb3B0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgc3ZnVGFncyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHN2Z1RhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ZnVGFnID0gc3ZnVGFnc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIGMud2lkdGggPSBzdmdUYWcuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgYy5oZWlnaHQgPSBzdmdUYWcuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHN2Z1RhZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjLCBzdmdUYWcpO1xuICAgICAgICAgICAgICAgIHN2Z1RhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN2Z1RhZyk7XG4gICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChzdmdUYWcpO1xuICAgICAgICAgICAgICAgIGNhbnZnKGMsIGRpdi5pbm5lckhUTUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBzdG9yZSBjbGFzcyBvbiBjYW52YXNcbiAgICAgICAgaWYgKHRhcmdldC5zdmcgIT0gbnVsbCkgdGFyZ2V0LnN2Zy5zdG9wKCk7XG4gICAgICAgIHZhciBzdmcgPSBidWlsZChvcHRzIHx8IHt9KTtcbiAgICAgICAgLy8gb24gaS5lLiA4IGZvciBmbGFzaCBjYW52YXMsIHdlIGNhbid0IGFzc2lnbiB0aGUgcHJvcGVydHkgc28gY2hlY2sgZm9yIGl0XG4gICAgICAgIGlmICghKHRhcmdldC5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIHRhcmdldC5jaGlsZE5vZGVzWzBdLm5vZGVOYW1lID09ICdPQkpFQ1QnKSkgdGFyZ2V0LnN2ZyA9IHN2ZztcbiAgICAgICAgXG4gICAgICAgIHZhciBjdHggPSB0YXJnZXQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKHR5cGVvZihzLmRvY3VtZW50RWxlbWVudCkgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGxvYWQgZnJvbSB4bWwgZG9jXG4gICAgICAgICAgICBzdmcubG9hZFhtbERvYyhjdHgsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHMuc3Vic3RyKDAsMSkgPT0gJzwnKSB7XG4gICAgICAgICAgICAvLyBsb2FkIGZyb20geG1sIHN0cmluZ1xuICAgICAgICAgICAgc3ZnLmxvYWRYbWwoY3R4LCBzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGxvYWQgZnJvbSB1cmxcbiAgICAgICAgICAgIHN2Zy5sb2FkKGN0eCwgcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZChvcHRzKSB7XG4gICAgICAgIHZhciBzdmcgPSB7IG9wdHM6IG9wdHMgfTtcbiAgICAgICAgXG4gICAgICAgIHN2Zy5GUkFNRVJBVEUgPSAzMDtcbiAgICAgICAgc3ZnLk1BWF9WSVJUVUFMX1BJWEVMUyA9IDMwMDAwO1xuICAgICAgICBcbiAgICAgICAgc3ZnLmxvZyA9IGZ1bmN0aW9uKG1zZykge307XG4gICAgICAgIGlmIChzdmcub3B0c1snbG9nJ10gPT0gdHJ1ZSAmJiB0eXBlb2YoY29uc29sZSkgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHN2Zy5sb2cgPSBmdW5jdGlvbihtc2cpIHsgY29uc29sZS5sb2cobXNnKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIGdsb2JhbHNcbiAgICAgICAgc3ZnLmluaXQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgIHZhciB1bmlxdWVJZCA9IDA7XG4gICAgICAgICAgICBzdmcuVW5pcXVlSWQgPSBmdW5jdGlvbiAoKSB7IHVuaXF1ZUlkKys7IHJldHVybiAnY2FudmcnICsgdW5pcXVlSWQ7IH07XG4gICAgICAgICAgICBzdmcuRGVmaW5pdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHN2Zy5TdHlsZXMgPSB7fTtcbiAgICAgICAgICAgIHN2Zy5BbmltYXRpb25zID0gW107XG4gICAgICAgICAgICBzdmcuSW1hZ2VzID0gW107XG4gICAgICAgICAgICBzdmcuY3R4ID0gY3R4O1xuICAgICAgICAgICAgc3ZnLlZpZXdQb3J0ID0gbmV3IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3UG9ydHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLkNsZWFyID0gZnVuY3Rpb24oKSB7IHRoaXMudmlld1BvcnRzID0gW107IH1cbiAgICAgICAgICAgICAgICB0aGlzLlNldEN1cnJlbnQgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7IHRoaXMudmlld1BvcnRzLnB1c2goeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pOyB9XG4gICAgICAgICAgICAgICAgdGhpcy5SZW1vdmVDdXJyZW50ID0gZnVuY3Rpb24oKSB7IHRoaXMudmlld1BvcnRzLnBvcCgpOyB9XG4gICAgICAgICAgICAgICAgdGhpcy5DdXJyZW50ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpZXdQb3J0c1t0aGlzLnZpZXdQb3J0cy5sZW5ndGggLSAxXTsgfVxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuQ3VycmVudCgpLndpZHRoOyB9XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuQ3VycmVudCgpLmhlaWdodDsgfVxuICAgICAgICAgICAgICAgIHRoaXMuQ29tcHV0ZVNpemUgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkICE9IG51bGwgJiYgdHlwZW9mKGQpID09ICdudW1iZXInKSByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgPT0gJ3gnKSByZXR1cm4gdGhpcy53aWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCA9PSAneScpIHJldHVybiB0aGlzLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMud2lkdGgoKSwgMikgKyBNYXRoLnBvdyh0aGlzLmhlaWdodCgpLCAyKSkgLyBNYXRoLnNxcnQoMik7ICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLmluaXQoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGltYWdlcyBsb2FkZWRcbiAgICAgICAgc3ZnLkltYWdlc0xvYWRlZCA9IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzdmcuSW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdmcuSW1hZ2VzW2ldLmxvYWRlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmltXG4gICAgICAgIHN2Zy50cmltID0gZnVuY3Rpb24ocykgeyByZXR1cm4gcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7IH1cbiAgICAgICAgXG4gICAgICAgIC8vIGNvbXByZXNzIHNwYWNlc1xuICAgICAgICBzdmcuY29tcHJlc3NTcGFjZXMgPSBmdW5jdGlvbihzKSB7IHJldHVybiBzLnJlcGxhY2UoL1tcXHNcXHJcXHRcXG5dKy9nbSwnICcpOyB9XG4gICAgICAgIFxuICAgICAgICAvLyBhamF4XG4gICAgICAgIHN2Zy5hamF4ID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICB2YXIgQUpBWDtcbiAgICAgICAgICAgIGlmKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCl7QUpBWD1uZXcgWE1MSHR0cFJlcXVlc3QoKTt9XG4gICAgICAgICAgICBlbHNle0FKQVg9bmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7fVxuICAgICAgICAgICAgaWYoQUpBWCl7XG4gICAgICAgICAgICAgICBBSkFYLm9wZW4oJ0dFVCcsdXJsLGZhbHNlKTtcbiAgICAgICAgICAgICAgIEFKQVguc2VuZChudWxsKTtcbiAgICAgICAgICAgICAgIHJldHVybiBBSkFYLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IFxuICAgICAgICBcbiAgICAgICAgLy8gcGFyc2UgeG1sXG4gICAgICAgIHN2Zy5wYXJzZVhtbCA9IGZ1bmN0aW9uKHhtbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihXaW5kb3dzKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YoV2luZG93cy5EYXRhKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YoV2luZG93cy5EYXRhLlhtbCkgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgeG1sRG9jID0gbmV3IFdpbmRvd3MuRGF0YS5YbWwuRG9tLlhtbERvY3VtZW50KCk7XG4gICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gbmV3IFdpbmRvd3MuRGF0YS5YbWwuRG9tLlhtbExvYWRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnByb2hpYml0RHRkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgeG1sRG9jLmxvYWRYbWwoeG1sLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhtbERvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdpbmRvdy5ET01QYXJzZXIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWwsICd0ZXh0L3htbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB4bWwgPSB4bWwucmVwbGFjZSgvPCFET0NUWVBFIHN2Z1tePl0qPi8sICcnKTtcbiAgICAgICAgICAgICAgICB2YXIgeG1sRG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKTtcbiAgICAgICAgICAgICAgICB4bWxEb2MuYXN5bmMgPSAnZmFsc2UnO1xuICAgICAgICAgICAgICAgIHhtbERvYy5sb2FkWE1MKHhtbCk7IFxuICAgICAgICAgICAgICAgIHJldHVybiB4bWxEb2M7XG4gICAgICAgICAgICB9ICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzdmcuUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSAgIFxuICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUgIT0gbnVsbCAmJiB0aGlzLnZhbHVlICE9PSAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIG51bWVyaWNhbCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUubnVtVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBwYXJzZUZsb2F0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy52YWx1ZSArICcnKS5tYXRjaCgvJSQvKSkge1xuICAgICAgICAgICAgICAgICAgICBuID0gbiAvIDEwMC4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS52YWx1ZU9yRGVmYXVsdCA9IGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUubnVtVmFsdWVPckRlZmF1bHQgPSBmdW5jdGlvbihkZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGNvbG9yIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAvLyBhdWdtZW50IHRoZSBjdXJyZW50IGNvbG9yIHZhbHVlIHdpdGggdGhlIG9wYWNpdHlcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLmFkZE9wYWNpdHkgPSBmdW5jdGlvbihvcGFjaXR5UHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BhY2l0eVByb3AudmFsdWUgIT0gbnVsbCAmJiBvcGFjaXR5UHJvcC52YWx1ZSAhPSAnJyAmJiB0eXBlb2YodGhpcy52YWx1ZSk9PSdzdHJpbmcnKSB7IC8vIGNhbiBvbmx5IGFkZCBvcGFjaXR5IHRvIGNvbG9ycywgbm90IHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBuZXcgUkdCQ29sb3IodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3Iub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9ICdyZ2JhKCcgKyBjb2xvci5yICsgJywgJyArIGNvbG9yLmcgKyAnLCAnICsgY29sb3IuYiArICcsICcgKyBvcGFjaXR5UHJvcC5udW1WYWx1ZSgpICsgJyknO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3ZnLlByb3BlcnR5KHRoaXMubmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gZGVmaW5pdGlvbiBleHRlbnNpb25zXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBkZWZpbml0aW9uIGZyb20gdGhlIGRlZmluaXRpb25zIHRhYmxlXG4gICAgICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS5nZXREZWZpbml0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy52YWx1ZS5tYXRjaCgvIyhbXlxcKSdcIl0rKS8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSkgeyBuYW1lID0gbmFtZVsxXTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHsgbmFtZSA9IHRoaXMudmFsdWU7IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN2Zy5EZWZpbml0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS5pc1VybERlZmluaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuaW5kZXhPZigndXJsKCcpID09IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3ZnLlByb3BlcnR5LnByb3RvdHlwZS5nZXRGaWxsU3R5bGVEZWZpbml0aW9uID0gZnVuY3Rpb24oZSwgb3BhY2l0eVByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IHRoaXMuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gZ3JhZGllbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZiAhPSBudWxsICYmIGRlZi5jcmVhdGVHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZi5jcmVhdGVHcmFkaWVudChzdmcuY3R4LCBlLCBvcGFjaXR5UHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZiAhPSBudWxsICYmIGRlZi5jcmVhdGVQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLmdldEhyZWZBdHRyaWJ1dGUoKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB0ID0gZGVmLmF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZiA9IGRlZi5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdC5oYXNWYWx1ZSgpKSB7IGRlZi5hdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nLCB0cnVlKS52YWx1ZSA9IHB0LnZhbHVlOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmLmNyZWF0ZVBhdHRlcm4oc3ZnLmN0eCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gbGVuZ3RoIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLmdldERQSSA9IGZ1bmN0aW9uKHZpZXdQb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA5Ni4wOyAvLyBUT0RPOiBjb21wdXRlP1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLmdldEVNID0gZnVuY3Rpb24odmlld1BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVtID0gMTI7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9udFNpemUgPSBuZXcgc3ZnLlByb3BlcnR5KCdmb250U2l6ZScsIHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9udFNpemUuaGFzVmFsdWUoKSkgZW0gPSBmb250U2l6ZS50b1BpeGVscyh2aWV3UG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VW5pdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnZhbHVlKycnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9bMC05XFwuXFwtXS9nLCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGxlbmd0aCBhcyBwaXhlbHNcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLnRvUGl4ZWxzID0gZnVuY3Rpb24odmlld1BvcnQsIHByb2Nlc3NQZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnZhbHVlKycnO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvZW0kLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldEVNKHZpZXdQb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubWF0Y2goL2V4JC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogdGhpcy5nZXRFTSh2aWV3UG9ydCkgLyAyLjA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC9weCQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubWF0Y2goL3B0JC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogdGhpcy5nZXREUEkodmlld1BvcnQpICogKDEuMCAvIDcyLjApO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvcGMkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiAxNTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubWF0Y2goL2NtJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogdGhpcy5nZXREUEkodmlld1BvcnQpIC8gMi41NDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubWF0Y2goL21tJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogdGhpcy5nZXREUEkodmlld1BvcnQpIC8gMjUuNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubWF0Y2goL2luJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogdGhpcy5nZXREUEkodmlld1BvcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvJSQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIHN2Zy5WaWV3UG9ydC5Db21wdXRlU2l6ZSh2aWV3UG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5udW1WYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc1BlcmNlbnQgJiYgbiA8IDEuMCkgcmV0dXJuIG4gKiBzdmcuVmlld1BvcnQuQ29tcHV0ZVNpemUodmlld1BvcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRpbWUgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgdGltZSBhcyBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLnRvTWlsbGlzZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnZhbHVlKycnO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvcyQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1hdGNoKC9tcyQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGFuZ2xlIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGFuZ2xlIGFzIHJhZGlhbnNcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLnRvUmFkaWFucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gdGhpcy52YWx1ZSsnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubWF0Y2goL2RlZyQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIChNYXRoLlBJIC8gMTgwLjApO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvZ3JhZCQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIChNYXRoLlBJIC8gMjAwLjApO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5tYXRjaCgvcmFkJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIC8vIHRleHQgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgdGV4dCBiYXNlbGluZVxuICAgICAgICAgICAgICAgIHZhciB0ZXh0QmFzZWxpbmVNYXBwaW5nID0ge1xuICAgICAgICAgICAgICAgICAgICAnYmFzZWxpbmUnOiAnYWxwaGFiZXRpYycsXG4gICAgICAgICAgICAgICAgICAgICdiZWZvcmUtZWRnZSc6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1iZWZvcmUtZWRnZSc6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICAnbWlkZGxlJzogJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgICdjZW50cmFsJzogJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgICdhZnRlci1lZGdlJzogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWFmdGVyLWVkZ2UnOiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lkZW9ncmFwaGljJzogJ2lkZW9ncmFwaGljJyxcbiAgICAgICAgICAgICAgICAgICAgJ2FscGhhYmV0aWMnOiAnYWxwaGFiZXRpYycsXG4gICAgICAgICAgICAgICAgICAgICdoYW5naW5nJzogJ2hhbmdpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnbWF0aGVtYXRpY2FsJzogJ2FscGhhYmV0aWMnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzdmcuUHJvcGVydHkucHJvdG90eXBlLnRvVGV4dEJhc2VsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0QmFzZWxpbmVNYXBwaW5nW3RoaXMudmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgLy8gZm9udHNcbiAgICAgICAgc3ZnLkZvbnQgPSBuZXcgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5TdHlsZXMgPSAnbm9ybWFsfGl0YWxpY3xvYmxpcXVlfGluaGVyaXQnO1xuICAgICAgICAgICAgdGhpcy5WYXJpYW50cyA9ICdub3JtYWx8c21hbGwtY2Fwc3xpbmhlcml0JztcbiAgICAgICAgICAgIHRoaXMuV2VpZ2h0cyA9ICdub3JtYWx8Ym9sZHxib2xkZXJ8bGlnaHRlcnwxMDB8MjAwfDMwMHw0MDB8NTAwfDYwMHw3MDB8ODAwfDkwMHxpbmhlcml0JztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5DcmVhdGVGb250ID0gZnVuY3Rpb24oZm9udFN0eWxlLCBmb250VmFyaWFudCwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHksIGluaGVyaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGluaGVyaXQgIT0gbnVsbCA/IHRoaXMuUGFyc2UoaW5oZXJpdCkgOiB0aGlzLkNyZWF0ZUZvbnQoJycsICcnLCAnJywgJycsICcnLCBzdmcuY3R4LmZvbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBmb250RmFtaWx5IHx8IGYuZm9udEZhbWlseSwgXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBmb250U2l6ZSB8fCBmLmZvbnRTaXplLCBcbiAgICAgICAgICAgICAgICAgICAgZm9udFN0eWxlOiBmb250U3R5bGUgfHwgZi5mb250U3R5bGUsIFxuICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBmb250V2VpZ2h0IHx8IGYuZm9udFdlaWdodCwgXG4gICAgICAgICAgICAgICAgICAgIGZvbnRWYXJpYW50OiBmb250VmFyaWFudCB8fCBmLmZvbnRWYXJpYW50LFxuICAgICAgICAgICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3RoaXMuZm9udFN0eWxlLCB0aGlzLmZvbnRWYXJpYW50LCB0aGlzLmZvbnRXZWlnaHQsIHRoaXMuZm9udFNpemUsIHRoaXMuZm9udEZhbWlseV0uam9pbignICcpIH0gXG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5QYXJzZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBkID0gc3ZnLnRyaW0oc3ZnLmNvbXByZXNzU3BhY2VzKHMgfHwgJycpKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIHZhciBzZXQgPSB7IGZvbnRTaXplOiBmYWxzZSwgZm9udFN0eWxlOiBmYWxzZSwgZm9udFdlaWdodDogZmFsc2UsIGZvbnRWYXJpYW50OiBmYWxzZSB9XG4gICAgICAgICAgICAgICAgdmFyIGZmID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXQuZm9udFN0eWxlICYmIHRoYXQuU3R5bGVzLmluZGV4T2YoZFtpXSkgIT0gLTEpIHsgaWYgKGRbaV0gIT0gJ2luaGVyaXQnKSBmLmZvbnRTdHlsZSA9IGRbaV07IHNldC5mb250U3R5bGUgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzZXQuZm9udFZhcmlhbnQgJiYgdGhhdC5WYXJpYW50cy5pbmRleE9mKGRbaV0pICE9IC0xKSB7IGlmIChkW2ldICE9ICdpbmhlcml0JykgZi5mb250VmFyaWFudCA9IGRbaV07IHNldC5mb250U3R5bGUgPSBzZXQuZm9udFZhcmlhbnQgPSB0cnVlOyAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc2V0LmZvbnRXZWlnaHQgJiYgdGhhdC5XZWlnaHRzLmluZGV4T2YoZFtpXSkgIT0gLTEpIHsgaWYgKGRbaV0gIT0gJ2luaGVyaXQnKSBmLmZvbnRXZWlnaHQgPSBkW2ldOyBzZXQuZm9udFN0eWxlID0gc2V0LmZvbnRWYXJpYW50ID0gc2V0LmZvbnRXZWlnaHQgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzZXQuZm9udFNpemUpIHsgaWYgKGRbaV0gIT0gJ2luaGVyaXQnKSBmLmZvbnRTaXplID0gZFtpXS5zcGxpdCgnLycpWzBdOyBzZXQuZm9udFN0eWxlID0gc2V0LmZvbnRWYXJpYW50ID0gc2V0LmZvbnRXZWlnaHQgPSBzZXQuZm9udFNpemUgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyBpZiAoZFtpXSAhPSAnaW5oZXJpdCcpIGZmICs9IGRbaV07IH1cbiAgICAgICAgICAgICAgICB9IGlmIChmZiAhPSAnJykgZi5mb250RmFtaWx5ID0gZmY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gcG9pbnRzIGFuZCBwYXRoc1xuICAgICAgICBzdmcuVG9OdW1iZXJBcnJheSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHZhciBhID0gc3ZnLnRyaW0oc3ZnLmNvbXByZXNzU3BhY2VzKChzIHx8ICcnKS5yZXBsYWNlKC8sL2csICcgJykpKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gcGFyc2VGbG9hdChhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9ICAgICAgIFxuICAgICAgICBzdmcuUG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfSAgIFxuICAgICAgICAgICAgc3ZnLlBvaW50LnByb3RvdHlwZS5hbmdsZVRvID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHAueSAtIHRoaXMueSwgcC54IC0gdGhpcy54KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3ZnLlBvaW50LnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB2YXIgeHAgPSB0aGlzLnggKiB2WzBdICsgdGhpcy55ICogdlsyXSArIHZbNF07XG4gICAgICAgICAgICAgICAgdmFyIHlwID0gdGhpcy54ICogdlsxXSArIHRoaXMueSAqIHZbM10gKyB2WzVdO1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHhwO1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHlwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIHN2Zy5DcmVhdGVQb2ludCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHZhciBhID0gc3ZnLlRvTnVtYmVyQXJyYXkocyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN2Zy5Qb2ludChhWzBdLCBhWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuQ3JlYXRlUGF0aCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHZhciBhID0gc3ZnLlRvTnVtYmVyQXJyYXkocyk7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGEubGVuZ3RoOyBpKz0yKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5ldyBzdmcuUG9pbnQoYVtpXSwgYVtpKzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gYm91bmRpbmcgYm94XG4gICAgICAgIHN2Zy5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7IC8vIHBhc3MgaW4gaW5pdGlhbCBwb2ludHMgaWYgeW91IHdhbnRcbiAgICAgICAgICAgIHRoaXMueDEgPSBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgdGhpcy55MSA9IE51bWJlci5OYU47XG4gICAgICAgICAgICB0aGlzLngyID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgIHRoaXMueTIgPSBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueDE7IH1cbiAgICAgICAgICAgIHRoaXMueSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy55MTsgfVxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy54MiAtIHRoaXMueDE7IH1cbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnkyIC0gdGhpcy55MTsgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFkZFBvaW50ID0gZnVuY3Rpb24oeCwgeSkgeyAgICBcbiAgICAgICAgICAgICAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTih0aGlzLngxKSB8fCBpc05hTih0aGlzLngyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy54MSA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLngyID0geDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA8IHRoaXMueDEpIHRoaXMueDEgPSB4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCA+IHRoaXMueDIpIHRoaXMueDIgPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMueTEpIHx8IGlzTmFOKHRoaXMueTIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueTIgPSB5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh5IDwgdGhpcy55MSkgdGhpcy55MSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ID4gdGhpcy55MikgdGhpcy55MiA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFkZFggPSBmdW5jdGlvbih4KSB7IHRoaXMuYWRkUG9pbnQoeCwgbnVsbCk7IH1cbiAgICAgICAgICAgIHRoaXMuYWRkWSA9IGZ1bmN0aW9uKHkpIHsgdGhpcy5hZGRQb2ludChudWxsLCB5KTsgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFkZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oYmIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50KGJiLngxLCBiYi55MSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludChiYi54MiwgYmIueTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFkZFF1YWRyYXRpY0N1cnZlID0gZnVuY3Rpb24ocDB4LCBwMHksIHAxeCwgcDF5LCBwMngsIHAyeSkge1xuICAgICAgICAgICAgICAgIHZhciBjcDF4ID0gcDB4ICsgMi8zICogKHAxeCAtIHAweCk7IC8vIENQMSA9IFFQMCArIDIvMyAqKFFQMS1RUDApXG4gICAgICAgICAgICAgICAgdmFyIGNwMXkgPSBwMHkgKyAyLzMgKiAocDF5IC0gcDB5KTsgLy8gQ1AxID0gUVAwICsgMi8zICooUVAxLVFQMClcbiAgICAgICAgICAgICAgICB2YXIgY3AyeCA9IGNwMXggKyAxLzMgKiAocDJ4IC0gcDB4KTsgLy8gQ1AyID0gQ1AxICsgMS8zICooUVAyLVFQMClcbiAgICAgICAgICAgICAgICB2YXIgY3AyeSA9IGNwMXkgKyAxLzMgKiAocDJ5IC0gcDB5KTsgLy8gQ1AyID0gQ1AxICsgMS8zICooUVAyLVFQMClcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJlemllckN1cnZlKHAweCwgcDB5LCBjcDF4LCBjcDJ4LCBjcDF5LCBjcDJ5LCBwMngsIHAyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYWRkQmV6aWVyQ3VydmUgPSBmdW5jdGlvbihwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xuICAgICAgICAgICAgICAgIC8vIGZyb20gaHR0cDovL2Jsb2cuaGFja2Vycy1jYWZlLm5ldC8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG4gICAgICAgICAgICAgICAgdmFyIHAwID0gW3AweCwgcDB5XSwgcDEgPSBbcDF4LCBwMXldLCBwMiA9IFtwMngsIHAyeV0sIHAzID0gW3AzeCwgcDN5XTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50KHAwWzBdLCBwMFsxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludChwM1swXSwgcDNbMV0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPD0xOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBmdW5jdGlvbih0KSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KDEtdCwgMykgKiBwMFtpXVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAzICogTWF0aC5wb3coMS10LCAyKSAqIHQgKiBwMVtpXVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAzICogKDEtdCkgKiBNYXRoLnBvdyh0LCAyKSAqIHAyW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICArIE1hdGgucG93KHQsIDMpICogcDNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gNiAqIHAwW2ldIC0gMTIgKiBwMVtpXSArIDYgKiBwMltpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAtMyAqIHAwW2ldICsgOSAqIHAxW2ldIC0gOSAqIHAyW2ldICsgMyAqIHAzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IDMgKiBwMVtpXSAtIDMgKiBwMFtpXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiID09IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSAtYyAvIGI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB0aGlzLmFkZFgoZih0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkgdGhpcy5hZGRZKGYodCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBiMmFjID0gTWF0aC5wb3coYiwgMikgLSA0ICogYyAqIGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiMmFjIDwgMCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMCkgdGhpcy5hZGRYKGYodDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHRoaXMuYWRkWShmKHQxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB0aGlzLmFkZFgoZih0MikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkgdGhpcy5hZGRZKGYodDIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5pc1BvaW50SW5Cb3ggPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLngxIDw9IHggJiYgeCA8PSB0aGlzLngyICYmIHRoaXMueTEgPD0geSAmJiB5IDw9IHRoaXMueTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFkZFBvaW50KHgxLCB5MSk7XG4gICAgICAgICAgICB0aGlzLmFkZFBvaW50KHgyLCB5Mik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHRyYW5zZm9ybXNcbiAgICAgICAgc3ZnLlRyYW5zZm9ybSA9IGZ1bmN0aW9uKHYpIHsgICBcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuVHlwZSA9IHt9XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gdHJhbnNsYXRlXG4gICAgICAgICAgICB0aGlzLlR5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgIHRoaXMucCA9IHN2Zy5DcmVhdGVQb2ludChzKTsgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5wLnggfHwgMC4wLCB0aGlzLnAueSB8fCAwLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtMS4wICogdGhpcy5wLnggfHwgMC4wLCAtMS4wICogdGhpcy5wLnkgfHwgMC4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVRvUG9pbnQgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuYXBwbHlUcmFuc2Zvcm0oWzEsIDAsIDAsIDEsIHRoaXMucC54IHx8IDAuMCwgdGhpcy5wLnkgfHwgMC4wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyByb3RhdGVcbiAgICAgICAgICAgIHRoaXMuVHlwZS5yb3RhdGUgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBzdmcuVG9OdW1iZXJBcnJheShzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnYW5nbGUnLCBhWzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN4ID0gYVsxXSB8fCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuY3kgPSBhWzJdIHx8IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuY3gsIHRoaXMuY3kpO1xuICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKHRoaXMuYW5nbGUudG9SYWRpYW5zKCkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC10aGlzLmN4LCAtdGhpcy5jeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudW5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuY3gsIHRoaXMuY3kpO1xuICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKC0xLjAgKiB0aGlzLmFuZ2xlLnRvUmFkaWFucygpKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdGhpcy5jeCwgLXRoaXMuY3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VG9Qb2ludCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmFuZ2xlLnRvUmFkaWFucygpO1xuICAgICAgICAgICAgICAgICAgICBwLmFwcGx5VHJhbnNmb3JtKFsxLCAwLCAwLCAxLCB0aGlzLnAueCB8fCAwLjAsIHRoaXMucC55IHx8IDAuMF0pO1xuICAgICAgICAgICAgICAgICAgICBwLmFwcGx5VHJhbnNmb3JtKFtNYXRoLmNvcyhhKSwgTWF0aC5zaW4oYSksIC1NYXRoLnNpbihhKSwgTWF0aC5jb3MoYSksIDAsIDBdKTtcbiAgICAgICAgICAgICAgICAgICAgcC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgLXRoaXMucC54IHx8IDAuMCwgLXRoaXMucC55IHx8IDAuMF0pO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLlR5cGUuc2NhbGUgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gc3ZnLkNyZWF0ZVBvaW50KHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKHRoaXMucC54IHx8IDEuMCwgdGhpcy5wLnkgfHwgdGhpcy5wLnggfHwgMS4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxLjAgLyB0aGlzLnAueCB8fCAxLjAsIDEuMCAvIHRoaXMucC55IHx8IHRoaXMucC54IHx8IDEuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICBwLmFwcGx5VHJhbnNmb3JtKFt0aGlzLnAueCB8fCAwLjAsIDAsIDAsIHRoaXMucC55IHx8IDAuMCwgMCwgMF0pO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5UeXBlLm1hdHJpeCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm0gPSBzdmcuVG9OdW1iZXJBcnJheShzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0odGhpcy5tWzBdLCB0aGlzLm1bMV0sIHRoaXMubVsyXSwgdGhpcy5tWzNdLCB0aGlzLm1bNF0sIHRoaXMubVs1XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudW5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMubVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLm1bMl07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5tWzRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMubVsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm1bM107XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gdGhpcy5tWzVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGggPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGV0ID0gMSAvIChhKihlKmktZipoKS1iKihkKmktZipnKStjKihkKmgtZSpnKSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXQqKGUqaS1mKmgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0KihmKmctZCppKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldCooYypoLWIqaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXQqKGEqaS1jKmcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0KihiKmYtYyplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldCooYypkLWEqZilcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVRvUG9pbnQgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuYXBwbHlUcmFuc2Zvcm0odGhpcy5tKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLlR5cGUuU2tld0Jhc2UgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlID0gdGhhdC5UeXBlLm1hdHJpeDtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2Uocyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmdsZSA9IG5ldyBzdmcuUHJvcGVydHkoJ2FuZ2xlJywgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLlR5cGUuU2tld0Jhc2UucHJvdG90eXBlID0gbmV3IHRoaXMuVHlwZS5tYXRyaXg7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuVHlwZS5za2V3WCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2UgPSB0aGF0LlR5cGUuU2tld0Jhc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlKHMpO1xuICAgICAgICAgICAgICAgIHRoaXMubSA9IFsxLCAwLCBNYXRoLnRhbih0aGlzLmFuZ2xlLnRvUmFkaWFucygpKSwgMSwgMCwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLlR5cGUuc2tld1gucHJvdG90eXBlID0gbmV3IHRoaXMuVHlwZS5Ta2V3QmFzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5UeXBlLnNrZXdZID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZSA9IHRoYXQuVHlwZS5Ta2V3QmFzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2Uocyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tID0gWzEsIE1hdGgudGFuKHRoaXMuYW5nbGUudG9SYWRpYW5zKCkpLCAwLCAxLCAwLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuVHlwZS5za2V3WS5wcm90b3R5cGUgPSBuZXcgdGhpcy5UeXBlLlNrZXdCYXNlO1xuICAgICAgICBcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXNbaV0uYXBwbHkoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMudW5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9dGhpcy50cmFuc2Zvcm1zLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zW2ldLnVuYXBwbHkoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXBwbHlUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zW2ldLmFwcGx5VG9Qb2ludChwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBkYXRhID0gc3ZnLnRyaW0oc3ZnLmNvbXByZXNzU3BhY2VzKHYpKS5yZXBsYWNlKC9cXCkoW2EtekEtWl0pL2csICcpICQxJykucmVwbGFjZSgvXFwpKFxccz8sXFxzPykvZywnKSAnKS5zcGxpdCgvXFxzKD89W2Etel0pLyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gc3ZnLnRyaW0oZGF0YVtpXS5zcGxpdCgnKCcpWzBdKTtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGRhdGFbaV0uc3BsaXQoJygnKVsxXS5yZXBsYWNlKCcpJywnJyk7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG5ldyB0aGlzLlR5cGVbdHlwZV0ocyk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3Jtcy5wdXNoKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGFzcGVjdCByYXRpb1xuICAgICAgICBzdmcuQXNwZWN0UmF0aW8gPSBmdW5jdGlvbihjdHgsIGFzcGVjdFJhdGlvLCB3aWR0aCwgZGVzaXJlZFdpZHRoLCBoZWlnaHQsIGRlc2lyZWRIZWlnaHQsIG1pblgsIG1pblksIHJlZlgsIHJlZlkpIHtcbiAgICAgICAgICAgIC8vIGFzcGVjdCByYXRpbyAtIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlXG4gICAgICAgICAgICBhc3BlY3RSYXRpbyA9IHN2Zy5jb21wcmVzc1NwYWNlcyhhc3BlY3RSYXRpbyk7XG4gICAgICAgICAgICBhc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvLnJlcGxhY2UoL15kZWZlclxccy8sJycpOyAvLyBpZ25vcmUgZGVmZXJcbiAgICAgICAgICAgIHZhciBhbGlnbiA9IGFzcGVjdFJhdGlvLnNwbGl0KCcgJylbMF0gfHwgJ3hNaWRZTWlkJztcbiAgICAgICAgICAgIHZhciBtZWV0T3JTbGljZSA9IGFzcGVjdFJhdGlvLnNwbGl0KCcgJylbMV0gfHwgJ21lZXQnOyAgICAgICAgICAgICAgICAgIFxuICAgIFxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHNjYWxlXG4gICAgICAgICAgICB2YXIgc2NhbGVYID0gd2lkdGggLyBkZXNpcmVkV2lkdGg7XG4gICAgICAgICAgICB2YXIgc2NhbGVZID0gaGVpZ2h0IC8gZGVzaXJlZEhlaWdodDtcbiAgICAgICAgICAgIHZhciBzY2FsZU1pbiA9IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgIHZhciBzY2FsZU1heCA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgIGlmIChtZWV0T3JTbGljZSA9PSAnbWVldCcpIHsgZGVzaXJlZFdpZHRoICo9IHNjYWxlTWluOyBkZXNpcmVkSGVpZ2h0ICo9IHNjYWxlTWluOyB9XG4gICAgICAgICAgICBpZiAobWVldE9yU2xpY2UgPT0gJ3NsaWNlJykgeyBkZXNpcmVkV2lkdGggKj0gc2NhbGVNYXg7IGRlc2lyZWRIZWlnaHQgKj0gc2NhbGVNYXg7IH0gICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlZlggPSBuZXcgc3ZnLlByb3BlcnR5KCdyZWZYJywgcmVmWCk7XG4gICAgICAgICAgICByZWZZID0gbmV3IHN2Zy5Qcm9wZXJ0eSgncmVmWScsIHJlZlkpO1xuICAgICAgICAgICAgaWYgKHJlZlguaGFzVmFsdWUoKSAmJiByZWZZLmhhc1ZhbHVlKCkpIHsgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1zY2FsZU1pbiAqIHJlZlgudG9QaXhlbHMoJ3gnKSwgLXNjYWxlTWluICogcmVmWS50b1BpeGVscygneScpKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBhbGlnblxuICAgICAgICAgICAgICAgIGlmIChhbGlnbi5tYXRjaCgvXnhNaWQvKSAmJiAoKG1lZXRPclNsaWNlID09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PSBzY2FsZVkpIHx8IChtZWV0T3JTbGljZSA9PSAnc2xpY2UnICYmIHNjYWxlTWF4ID09IHNjYWxlWSkpKSBjdHgudHJhbnNsYXRlKHdpZHRoIC8gMi4wIC0gZGVzaXJlZFdpZHRoIC8gMi4wLCAwKTsgXG4gICAgICAgICAgICAgICAgaWYgKGFsaWduLm1hdGNoKC9ZTWlkJC8pICYmICgobWVldE9yU2xpY2UgPT0gJ21lZXQnICYmIHNjYWxlTWluID09IHNjYWxlWCkgfHwgKG1lZXRPclNsaWNlID09ICdzbGljZScgJiYgc2NhbGVNYXggPT0gc2NhbGVYKSkpIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0IC8gMi4wIC0gZGVzaXJlZEhlaWdodCAvIDIuMCk7IFxuICAgICAgICAgICAgICAgIGlmIChhbGlnbi5tYXRjaCgvXnhNYXgvKSAmJiAoKG1lZXRPclNsaWNlID09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PSBzY2FsZVkpIHx8IChtZWV0T3JTbGljZSA9PSAnc2xpY2UnICYmIHNjYWxlTWF4ID09IHNjYWxlWSkpKSBjdHgudHJhbnNsYXRlKHdpZHRoIC0gZGVzaXJlZFdpZHRoLCAwKTsgXG4gICAgICAgICAgICAgICAgaWYgKGFsaWduLm1hdGNoKC9ZTWF4JC8pICYmICgobWVldE9yU2xpY2UgPT0gJ21lZXQnICYmIHNjYWxlTWluID09IHNjYWxlWCkgfHwgKG1lZXRPclNsaWNlID09ICdzbGljZScgJiYgc2NhbGVNYXggPT0gc2NhbGVYKSkpIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0IC0gZGVzaXJlZEhlaWdodCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBzY2FsZVxuICAgICAgICAgICAgaWYgKGFsaWduID09ICdub25lJykgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG1lZXRPclNsaWNlID09ICdtZWV0JykgY3R4LnNjYWxlKHNjYWxlTWluLCBzY2FsZU1pbik7IFxuICAgICAgICAgICAgZWxzZSBpZiAobWVldE9yU2xpY2UgPT0gJ3NsaWNlJykgY3R4LnNjYWxlKHNjYWxlTWF4LCBzY2FsZU1heCk7ICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gdHJhbnNsYXRlXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKG1pblggPT0gbnVsbCA/IDAgOiAtbWluWCwgbWluWSA9PSBudWxsID8gMCA6IC1taW5ZKTsgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGVsZW1lbnRzXG4gICAgICAgIHN2Zy5FbGVtZW50ID0ge31cbiAgICAgICAgXG4gICAgICAgIHN2Zy5FbXB0eVByb3BlcnR5ID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnRU1QVFknLCAnJyk7XG4gICAgICAgIFxuICAgICAgICBzdmcuRWxlbWVudC5FbGVtZW50QmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHsgIFxuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCBjcmVhdGVJZk5vdEV4aXN0cykge1xuICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChhICE9IG51bGwpIHJldHVybiBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChjcmVhdGVJZk5vdEV4aXN0cyA9PSB0cnVlKSB7IGEgPSBuZXcgc3ZnLlByb3BlcnR5KG5hbWUsICcnKTsgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gYTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhIHx8IHN2Zy5FbXB0eVByb3BlcnR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldEhyZWZBdHRyaWJ1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhIGluIHRoaXMuYXR0cmlidXRlcykgeyBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEubWF0Y2goLzpocmVmJC8pKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1thXTsgXG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdmcuRW1wdHlQcm9wZXJ0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSBzdHlsZSwgY3Jhd2xzIHVwIG5vZGUgdHJlZVxuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZUlmTm90RXhpc3RzLCBza2lwQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnN0eWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAocyAhPSBudWxsKSByZXR1cm4gcztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuYXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChhICE9IG51bGwgJiYgYS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gYTsgLy8gbW92ZSB1cCB0byBtZSB0byBjYWNoZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHNraXBBbmNlc3RvcnMgIT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAocCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHMgPSBwLnN0eWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBzICE9IG51bGwgJiYgcHMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZUlmTm90RXhpc3RzID09IHRydWUpIHsgcyA9IG5ldyBzdmcuUHJvcGVydHkobmFtZSwgJycpOyB0aGlzLnN0eWxlc1tuYW1lXSA9IHM7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcyB8fCBzdmcuRW1wdHlQcm9wZXJ0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYmFzZSByZW5kZXJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgcmVuZGVyIGRpc3BsYXk9bm9uZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT0gJ25vbmUnKSByZXR1cm47XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgcmVuZGVyIHZpc2liaWxpdHk9aGlkZGVuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PSAnaGlkZGVuJykgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ21hc2snKS5oYXNWYWx1ZSgpKSB7IC8vIG1hc2tcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2sgPSB0aGlzLmF0dHJpYnV0ZSgnbWFzaycpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2sgIT0gbnVsbCkgbWFzay5hcHBseShjdHgsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0eWxlKCdmaWx0ZXInKS5oYXNWYWx1ZSgpKSB7IC8vIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5zdHlsZSgnZmlsdGVyJykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyICE9IG51bGwpIGZpbHRlci5hcHBseShjdHgsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENvbnRleHQoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihjdHgpOyAgIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpOyAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYmFzZSBzZXQgY29udGV4dFxuICAgICAgICAgICAgdGhpcy5zZXRDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgLy8gT1ZFUlJJREUgTUUhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGJhc2UgY2xlYXIgY29udGV4dFxuICAgICAgICAgICAgdGhpcy5jbGVhckNvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBPVkVSUklERSBNRSFcbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBiYXNlIHJlbmRlciBjaGlsZHJlblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkID0gZnVuY3Rpb24oY2hpbGROb2RlLCBjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZSkgY2hpbGQgPSBzdmcuQ3JlYXRlRWxlbWVudChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gJ3RpdGxlJykgeyB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobm9kZSAhPSBudWxsICYmIG5vZGUubm9kZVR5cGUgPT0gMSkgeyAvL0VMRU1FTlRfTk9ERVxuICAgICAgICAgICAgICAgIC8vIGFkZCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlLm5vZGVOYW1lXSA9IG5ldyBzdmcuUHJvcGVydHkoYXR0cmlidXRlLm5vZGVOYW1lLCBhdHRyaWJ1dGUubm9kZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRhZyBzdHlsZXNcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gc3ZnLlN0eWxlc1tub2RlLm5vZGVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gc3R5bGVzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBhZGQgY2xhc3Mgc3R5bGVzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdjbGFzcycpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBzdmcuY29tcHJlc3NTcGFjZXModGhpcy5hdHRyaWJ1dGUoJ2NsYXNzJykudmFsdWUpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajxjbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMgPSBzdmcuU3R5bGVzWycuJytjbGFzc2VzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gc3R5bGVzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHN2Zy5TdHlsZXNbbm9kZS5ub2RlTmFtZSsnLicrY2xhc3Nlc1tqXV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IHN0eWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gYWRkIGlkIHN0eWxlc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnaWQnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZXMgPSBzdmcuU3R5bGVzWycjJyArIHRoaXMuYXR0cmlidXRlKCdpZCcpLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gc3R5bGVzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGFkZCBpbmxpbmUgc3R5bGVzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdzdHlsZScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuYXR0cmlidXRlKCdzdHlsZScpLnZhbHVlLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdmcudHJpbShzdHlsZXNbaV0pICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2ldLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBzdmcudHJpbShzdHlsZVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3ZnLnRyaW0oc3R5bGVbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gbmV3IHN2Zy5Qcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICAgXG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgaWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ2lkJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ZnLkRlZmluaXRpb25zW3RoaXMuYXR0cmlidXRlKCdpZCcpLnZhbHVlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmcuRGVmaW5pdGlvbnNbdGhpcy5hdHRyaWJ1dGUoJ2lkJykudmFsdWVdID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBhZGQgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8bm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBub2RlLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT0gMSkgdGhpcy5hZGRDaGlsZChjaGlsZE5vZGUsIHRydWUpOyAvL0VMRU1FTlRfTk9ERVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYXB0dXJlVGV4dE5vZGVzICYmIChjaGlsZE5vZGUubm9kZVR5cGUgPT0gMyB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT0gNCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gY2hpbGROb2RlLm5vZGVWYWx1ZSB8fCBjaGlsZE5vZGUudGV4dCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdmcudHJpbShzdmcuY29tcHJlc3NTcGFjZXModGV4dCkpICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChuZXcgc3ZnLkVsZW1lbnQudHNwYW4oY2hpbGROb2RlKSwgZmFsc2UpOyAvLyBURVhUX05PREVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnNldENvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBmaWxsXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ2ZpbGwnKS5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnMgPSB0aGlzLnN0eWxlKCdmaWxsJykuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLCB0aGlzLnN0eWxlKCdmaWxsLW9wYWNpdHknKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcyAhPSBudWxsKSBjdHguZmlsbFN0eWxlID0gZnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3R5bGUoJ2ZpbGwnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxsU3R5bGUgPSB0aGlzLnN0eWxlKCdmaWxsJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxsU3R5bGUudmFsdWUgPT0gJ2N1cnJlbnRDb2xvcicpIGZpbGxTdHlsZS52YWx1ZSA9IHRoaXMuc3R5bGUoJ2NvbG9yJykudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAoZmlsbFN0eWxlLnZhbHVlID09ICdub25lJyA/ICdyZ2JhKDAsMCwwLDApJyA6IGZpbGxTdHlsZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdmaWxsLW9wYWNpdHknKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxsU3R5bGUgPSBuZXcgc3ZnLlByb3BlcnR5KCdmaWxsJywgY3R4LmZpbGxTdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZSA9IGZpbGxTdHlsZS5hZGRPcGFjaXR5KHRoaXMuc3R5bGUoJ2ZpbGwtb3BhY2l0eScpKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBzdHJva2VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnc3Ryb2tlJykuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZzID0gdGhpcy5zdHlsZSgnc3Ryb2tlJykuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLCB0aGlzLnN0eWxlKCdzdHJva2Utb3BhY2l0eScpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZzICE9IG51bGwpIGN0eC5zdHJva2VTdHlsZSA9IGZzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0eWxlKCdzdHJva2UnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJva2VTdHlsZSA9IHRoaXMuc3R5bGUoJ3N0cm9rZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Ryb2tlU3R5bGUudmFsdWUgPT0gJ2N1cnJlbnRDb2xvcicpIHN0cm9rZVN0eWxlLnZhbHVlID0gdGhpcy5zdHlsZSgnY29sb3InKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gKHN0cm9rZVN0eWxlLnZhbHVlID09ICdub25lJyA/ICdyZ2JhKDAsMCwwLDApJyA6IHN0cm9rZVN0eWxlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3Ryb2tlU3R5bGUgPSBuZXcgc3ZnLlByb3BlcnR5KCdzdHJva2UnLCBjdHguc3Ryb2tlU3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlLmFkZE9wYWNpdHkodGhpcy5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknKSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLXdpZHRoJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGluZVdpZHRoID0gdGhpcy5zdHlsZSgnc3Ryb2tlLXdpZHRoJykudG9QaXhlbHMoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG5ld0xpbmVXaWR0aCA9PSAwID8gMC4wMDEgOiBuZXdMaW5lV2lkdGg7IC8vIGJyb3dzZXJzIGRvbid0IHJlc3BlY3QgMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLWxpbmVjYXAnKS5oYXNWYWx1ZSgpKSBjdHgubGluZUNhcCA9IHRoaXMuc3R5bGUoJ3N0cm9rZS1saW5lY2FwJykudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ3N0cm9rZS1saW5lam9pbicpLmhhc1ZhbHVlKCkpIGN0eC5saW5lSm9pbiA9IHRoaXMuc3R5bGUoJ3N0cm9rZS1saW5lam9pbicpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdzdHJva2UtbWl0ZXJsaW1pdCcpLmhhc1ZhbHVlKCkpIGN0eC5taXRlckxpbWl0ID0gdGhpcy5zdHlsZSgnc3Ryb2tlLW1pdGVybGltaXQnKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScpLmhhc1ZhbHVlKCkgJiYgdGhpcy5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScpLnZhbHVlICE9ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2FwcyA9IHN2Zy5Ub051bWJlckFycmF5KHRoaXMuc3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoY3R4LnNldExpbmVEYXNoKSAhPSAndW5kZWZpbmVkJykgeyBjdHguc2V0TGluZURhc2goZ2Fwcyk7IH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mKGN0eC53ZWJraXRMaW5lRGFzaCkgIT0gJ3VuZGVmaW5lZCcpIHsgY3R4LndlYmtpdExpbmVEYXNoID0gZ2FwczsgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YoY3R4Lm1vekRhc2gpICE9ICd1bmRlZmluZWQnICYmICEoZ2Fwcy5sZW5ndGg9PTEgJiYgZ2Fwc1swXT09MCkpIHsgY3R4Lm1vekRhc2ggPSBnYXBzOyB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5zdHlsZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKS5udW1WYWx1ZU9yRGVmYXVsdCgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjdHgubGluZURhc2hPZmZzZXQpICE9ICd1bmRlZmluZWQnKSB7IGN0eC5saW5lRGFzaE9mZnNldCA9IG9mZnNldDsgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YoY3R4LndlYmtpdExpbmVEYXNoT2Zmc2V0KSAhPSAndW5kZWZpbmVkJykgeyBjdHgud2Via2l0TGluZURhc2hPZmZzZXQgPSBvZmZzZXQ7IH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mKGN0eC5tb3pEYXNoT2Zmc2V0KSAhPSAndW5kZWZpbmVkJykgeyBjdHgubW96RGFzaE9mZnNldCA9IG9mZnNldDsgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGZvbnRcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGN0eC5mb250KSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9IHN2Zy5Gb250LkNyZWF0ZUZvbnQoIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZSgnZm9udC1zdHlsZScpLnZhbHVlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUoJ2ZvbnQtdmFyaWFudCcpLnZhbHVlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUoJ2ZvbnQtd2VpZ2h0JykudmFsdWUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZSgnZm9udC1zaXplJykuaGFzVmFsdWUoKSA/IHRoaXMuc3R5bGUoJ2ZvbnQtc2l6ZScpLnRvUGl4ZWxzKCkgKyAncHgnIDogJycsIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZSgnZm9udC1mYW1pbHknKS52YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCd0cmFuc2Zvcm0nKS5oYXNWYWx1ZSgpKSB7IFxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gbmV3IHN2Zy5UcmFuc2Zvcm0odGhpcy5hdHRyaWJ1dGUoJ3RyYW5zZm9ybScpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmFwcGx5KGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGNsaXBcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnY2xpcC1wYXRoJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXAgPSB0aGlzLnN0eWxlKCdjbGlwLXBhdGgnLCBmYWxzZSwgdHJ1ZSkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcCAhPSBudWxsKSBjbGlwLmFwcGx5KGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIG9wYWNpdHlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnb3BhY2l0eScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5zdHlsZSgnb3BhY2l0eScpLm51bVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGgoY3R4KTtcbiAgICAgICAgICAgICAgICBzdmcuTW91c2UuY2hlY2tQYXRoKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5maWxsU3R5bGUgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUoJ2ZpbGwtcnVsZScpLnZhbHVlT3JEZWZhdWx0KCdpbmhlcml0JykgIT0gJ2luaGVyaXQnKSB7IGN0eC5maWxsKHRoaXMuc3R5bGUoJ2ZpbGwtcnVsZScpLnZhbHVlKTsgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgY3R4LmZpbGwoKTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3R4LnN0cm9rZVN0eWxlICE9ICcnKSBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIG1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMoKTtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VycyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdtYXJrZXItc3RhcnQnKS5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuc3R5bGUoJ21hcmtlci1zdGFydCcpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlci5yZW5kZXIoY3R4LCBtYXJrZXJzWzBdWzBdLCBtYXJrZXJzWzBdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZSgnbWFya2VyLW1pZCcpLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFya2VyID0gdGhpcy5zdHlsZSgnbWFya2VyLW1pZCcpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MTtpPG1hcmtlcnMubGVuZ3RoLTE7aSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyLnJlbmRlcihjdHgsIG1hcmtlcnNbaV1bMF0sIG1hcmtlcnNbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdtYXJrZXItZW5kJykuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLnN0eWxlKCdtYXJrZXItZW5kJykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyLnJlbmRlcihjdHgsIG1hcmtlcnNbbWFya2Vycy5sZW5ndGgtMV1bMF0sIG1hcmtlcnNbbWFya2Vycy5sZW5ndGgtMV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gc3ZnIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuc3ZnID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5iYXNlQ2xlYXJDb250ZXh0ID0gdGhpcy5jbGVhckNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZUNsZWFyQ29udGV4dChjdHgpO1xuICAgICAgICAgICAgICAgIHN2Zy5WaWV3UG9ydC5SZW1vdmVDdXJyZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYmFzZVNldENvbnRleHQgPSB0aGlzLnNldENvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLnNldENvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIHZhbHVlcyBhbmQgZGVmYXVsdHNcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gJ21pdGVyJztcbiAgICAgICAgICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IDQ7IFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoY3R4LmZvbnQpICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZih3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZvbnQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjdHguY2FudmFzKS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlU2V0Q29udGV4dChjdHgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgdmlldyBwb3J0XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIHRoaXMuYXR0cmlidXRlKCd4JywgdHJ1ZSkudmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgneScsIHRydWUpLnZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKSwgdGhpcy5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBzdmcuVmlld1BvcnQud2lkdGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc3ZnLlZpZXdQb3J0LmhlaWdodCgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJywgdHJ1ZSkudmFsdWUgPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcsIHRydWUpLnZhbHVlID0gJzEwMCUnO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YodGhpcy5yb290KSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgncmVmWCcpLmhhc1ZhbHVlKCkgJiYgdGhpcy5hdHRyaWJ1dGUoJ3JlZlknKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gLXRoaXMuYXR0cmlidXRlKCdyZWZYJykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSAtdGhpcy5hdHRyaWJ1dGUoJ3JlZlknKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ292ZXJmbG93JykudmFsdWVPckRlZmF1bHQoJ2hpZGRlbicpICE9ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8od2lkdGgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ZnLlZpZXdQb3J0LlNldEN1cnJlbnQod2lkdGgsIGhlaWdodCk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gdmlld2JveFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgndmlld0JveCcpLmhhc1ZhbHVlKCkpIHsgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3Qm94ID0gc3ZnLlRvTnVtYmVyQXJyYXkodGhpcy5hdHRyaWJ1dGUoJ3ZpZXdCb3gnKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5YID0gdmlld0JveFswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pblkgPSB2aWV3Qm94WzFdO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHZpZXdCb3hbMl07XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHZpZXdCb3hbM107XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzdmcuQXNwZWN0UmF0aW8oY3R4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS52YWx1ZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdmcuVmlld1BvcnQud2lkdGgoKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5WaWV3UG9ydC5oZWlnaHQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5ZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUoJ3JlZlgnKS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlKCdyZWZZJykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc3ZnLlZpZXdQb3J0LlJlbW92ZUN1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3ZnLlZpZXdQb3J0LlNldEN1cnJlbnQodmlld0JveFsyXSwgdmlld0JveFszXSk7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnN2Zy5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcblxuICAgICAgICAvLyByZWN0IGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQucmVjdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHJ4ID0gdGhpcy5hdHRyaWJ1dGUoJ3J4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgcnkgPSB0aGlzLmF0dHJpYnV0ZSgncnknKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgncngnKS5oYXNWYWx1ZSgpICYmICF0aGlzLmF0dHJpYnV0ZSgncnknKS5oYXNWYWx1ZSgpKSByeSA9IHJ4O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgncnknKS5oYXNWYWx1ZSgpICYmICF0aGlzLmF0dHJpYnV0ZSgncngnKS5oYXNWYWx1ZSgpKSByeCA9IHJ5O1xuICAgICAgICAgICAgICAgIHJ4ID0gTWF0aC5taW4ocngsIHdpZHRoIC8gMi4wKTtcbiAgICAgICAgICAgICAgICByeSA9IE1hdGgubWluKHJ5LCBoZWlnaHQgLyAyLjApO1xuICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHJ4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcnkpXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcnkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJ4LCB5ICsgaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyByeCwgeSArIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByeSlcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcnkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcngsIHkpXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3goeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5yZWN0LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBjaXJjbGUgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5jaXJjbGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciBjeCA9IHRoaXMuYXR0cmlidXRlKCdjeCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gdGhpcy5hdHRyaWJ1dGUoJ2N5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuYXR0cmlidXRlKCdyJykudG9QaXhlbHMoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoY3gsIGN5LCByLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7IFxuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KGN4IC0gciwgY3kgLSByLCBjeCArIHIsIGN5ICsgcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuY2lyY2xlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7IFxuXG4gICAgICAgIC8vIGVsbGlwc2UgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5lbGxpcHNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgS0FQUEEgPSA0ICogKChNYXRoLnNxcnQoMikgLSAxKSAvIDMpO1xuICAgICAgICAgICAgICAgIHZhciByeCA9IHRoaXMuYXR0cmlidXRlKCdyeCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHJ5ID0gdGhpcy5hdHRyaWJ1dGUoJ3J5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSB0aGlzLmF0dHJpYnV0ZSgnY3gnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciBjeSA9IHRoaXMuYXR0cmlidXRlKCdjeScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjeCwgY3kgLSByeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4ICsgKEtBUFBBICogcngpLCBjeSAtIHJ5LCAgY3ggKyByeCwgY3kgLSAoS0FQUEEgKiByeSksIGN4ICsgcngsIGN5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggKyByeCwgY3kgKyAoS0FQUEEgKiByeSksIGN4ICsgKEtBUFBBICogcngpLCBjeSArIHJ5LCBjeCwgY3kgKyByeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4IC0gKEtBUFBBICogcngpLCBjeSArIHJ5LCBjeCAtIHJ4LCBjeSArIChLQVBQQSAqIHJ5KSwgY3ggLSByeCwgY3kpO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCAtIHJ4LCBjeSAtIChLQVBQQSAqIHJ5KSwgY3ggLSAoS0FQUEEgKiByeCksIGN5IC0gcnksIGN4LCBjeSAtIHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveChjeCAtIHJ4LCBjeSAtIHJ5LCBjeCArIHJ4LCBjeSArIHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5lbGxpcHNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7ICAgICAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvLyBsaW5lIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQubGluZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRQb2ludHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgc3ZnLlBvaW50KHRoaXMuYXR0cmlidXRlKCd4MScpLnRvUGl4ZWxzKCd4JyksIHRoaXMuYXR0cmlidXRlKCd5MScpLnRvUGl4ZWxzKCd5JykpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgc3ZnLlBvaW50KHRoaXMuYXR0cmlidXRlKCd4MicpLnRvUGl4ZWxzKCd4JyksIHRoaXMuYXR0cmlidXRlKCd5MicpLnRvUGl4ZWxzKCd5JykpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzWzFdLngsIHBvaW50c1sxXS55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3gocG9pbnRzWzBdLngsIHBvaW50c1swXS55LCBwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldE1hcmtlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKTsgIFxuICAgICAgICAgICAgICAgIHZhciBhID0gcG9pbnRzWzBdLmFuZ2xlVG8ocG9pbnRzWzFdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1twb2ludHNbMF0sIGFdLCBbcG9pbnRzWzFdLCBhXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQubGluZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlOyAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgLy8gcG9seWxpbmUgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5wb2x5bGluZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wb2ludHMgPSBzdmcuQ3JlYXRlUGF0aCh0aGlzLmF0dHJpYnV0ZSgncG9pbnRzJykudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJiID0gbmV3IHN2Zy5Cb3VuZGluZ0JveCh0aGlzLnBvaW50c1swXS54LCB0aGlzLnBvaW50c1swXS55KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMucG9pbnRzWzBdLngsIHRoaXMucG9pbnRzWzBdLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTE7IGk8dGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmIuYWRkUG9pbnQodGhpcy5wb2ludHNbaV0ueCwgdGhpcy5wb2ludHNbaV0ueSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyh0aGlzLnBvaW50c1tpXS54LCB0aGlzLnBvaW50c1tpXS55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldE1hcmtlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLnBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKFt0aGlzLnBvaW50c1tpXSwgdGhpcy5wb2ludHNbaV0uYW5nbGVUbyh0aGlzLnBvaW50c1tpKzFdKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goW3RoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aC0xXSwgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aC0xXVsxXV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQucG9seWxpbmUucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZTsgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgLy8gcG9seWdvbiBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LnBvbHlnb24gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5wb2x5bGluZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5iYXNlUGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciBiYiA9IHRoaXMuYmFzZVBhdGgoY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnBvaW50c1swXS54LCB0aGlzLnBvaW50c1swXS55KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQucG9seWdvbi5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQucG9seWxpbmU7XG5cbiAgICAgICAgLy8gcGF0aCBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LnBhdGggPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmF0dHJpYnV0ZSgnZCcpLnZhbHVlO1xuICAgICAgICAgICAgLy8gVE9ETzogY29udmVydCB0byByZWFsIGxleGVyIGJhc2VkIG9uIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL3BhdGhzLmh0bWwjUGF0aERhdGFCTkZcbiAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoLywvZ20sJyAnKTsgLy8gZ2V0IHJpZCBvZiBhbGwgY29tbWFzXG4gICAgICAgICAgICBkID0gZC5yZXBsYWNlKC8oW01tWnpMbEhoVnZDY1NzUXFUdEFhXSkoW01tWnpMbEhoVnZDY1NzUXFUdEFhXSkvZ20sJyQxICQyJyk7IC8vIHNlcGFyYXRlIGNvbW1hbmRzIGZyb20gY29tbWFuZHNcbiAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoLyhbTW1aekxsSGhWdkNjU3NRcVR0QWFdKShbTW1aekxsSGhWdkNjU3NRcVR0QWFdKS9nbSwnJDEgJDInKTsgLy8gc2VwYXJhdGUgY29tbWFuZHMgZnJvbSBjb21tYW5kc1xuICAgICAgICAgICAgZCA9IGQucmVwbGFjZSgvKFtNbVp6TGxIaFZ2Q2NTc1FxVHRBYV0pKFteXFxzXSkvZ20sJyQxICQyJyk7IC8vIHNlcGFyYXRlIGNvbW1hbmRzIGZyb20gcG9pbnRzXG4gICAgICAgICAgICBkID0gZC5yZXBsYWNlKC8oW15cXHNdKShbTW1aekxsSGhWdkNjU3NRcVR0QWFdKS9nbSwnJDEgJDInKTsgLy8gc2VwYXJhdGUgY29tbWFuZHMgZnJvbSBwb2ludHNcbiAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoLyhbMC05XSkoWytcXC1dKS9nbSwnJDEgJDInKTsgLy8gc2VwYXJhdGUgZGlnaXRzIHdoZW4gbm8gY29tbWFcbiAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoLyhcXC5bMC05XSopKFxcLikvZ20sJyQxICQyJyk7IC8vIHNlcGFyYXRlIGRpZ2l0cyB3aGVuIG5vIGNvbW1hXG4gICAgICAgICAgICBkID0gZC5yZXBsYWNlKC8oW0FhXShcXHMrWzAtOV0rKXszfSlcXHMrKFswMV0pXFxzKihbMDFdKS9nbSwnJDEgJDMgJDQgJyk7IC8vIHNob3J0aGFuZCBlbGxpcHRpY2FsIGFyYyBwYXRoIHN5bnRheFxuICAgICAgICAgICAgZCA9IHN2Zy5jb21wcmVzc1NwYWNlcyhkKTsgLy8gY29tcHJlc3MgbXVsdGlwbGUgc3BhY2VzXG4gICAgICAgICAgICBkID0gc3ZnLnRyaW0oZCk7XG4gICAgICAgICAgICB0aGlzLlBhdGhQYXJzZXIgPSBuZXcgKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VucyA9IGQuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IG5ldyBzdmcuUG9pbnQoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbCA9IG5ldyBzdmcuUG9pbnQoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG5ldyBzdmcuUG9pbnQoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmlzRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmkgPj0gdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5pc0NvbW1hbmRPckVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0VuZCgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaSArIDFdLm1hdGNoKC9eW0EtWmEtel0kLykgIT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlbGF0aXZlQ29tbWFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2godGhpcy5jb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLmldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNjYWxhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmdldFRva2VuKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDb21tYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNDb21tYW5kID0gdGhpcy5jb21tYW5kO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmQgPSB0aGlzLmdldFRva2VuKCk7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0UG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgc3ZnLlBvaW50KHRoaXMuZ2V0U2NhbGFyKCksIHRoaXMuZ2V0U2NhbGFyKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlQWJzb2x1dGUocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QXNDb250cm9sUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmdldFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbCA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmdldEFzQ3VycmVudFBvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5nZXRQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDsgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNDb21tYW5kLnRvTG93ZXJDYXNlKCkgIT0gJ2MnICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQudG9Mb3dlckNhc2UoKSAhPSAncycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNDb21tYW5kLnRvTG93ZXJDYXNlKCkgIT0gJ3EnICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQudG9Mb3dlckNhc2UoKSAhPSAndCcgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZmxlY3QgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgc3ZnLlBvaW50KDIgKiB0aGlzLmN1cnJlbnQueCAtIHRoaXMuY29udHJvbC54LCAyICogdGhpcy5jdXJyZW50LnkgLSB0aGlzLmNvbnRyb2wueSk7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMubWFrZUFic29sdXRlID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JlbGF0aXZlQ29tbWFuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLnggKz0gdGhpcy5jdXJyZW50Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLnkgKz0gdGhpcy5jdXJyZW50Lnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkTWFya2VyID0gZnVuY3Rpb24ocCwgZnJvbSwgcHJpb3JUbykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGFzdCBhbmdsZSBpc24ndCBmaWxsZWQgaW4gYmVjYXVzZSB3ZSBkaWRuJ3QgaGF2ZSB0aGlzIHBvaW50IHlldCAuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByaW9yVG8gIT0gbnVsbCAmJiB0aGlzLmFuZ2xlcy5sZW5ndGggPiAwICYmIHRoaXMuYW5nbGVzW3RoaXMuYW5nbGVzLmxlbmd0aC0xXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlc1t0aGlzLmFuZ2xlcy5sZW5ndGgtMV0gPSB0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGgtMV0uYW5nbGVUbyhwcmlvclRvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1hcmtlckFuZ2xlKHAsIGZyb20gPT0gbnVsbCA/IG51bGwgOiBmcm9tLmFuZ2xlVG8ocCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE1hcmtlckFuZ2xlID0gZnVuY3Rpb24ocCwgYSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50cy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlcy5wdXNoKGEpO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmdldE1hcmtlclBvaW50cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5wb2ludHM7IH1cbiAgICAgICAgICAgICAgICB0aGlzLmdldE1hcmtlckFuZ2xlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5hbmdsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuZ2xlc1tpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaj1pKzE7IGo8dGhpcy5hbmdsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5nbGVzW2pdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGVzW2ldID0gdGhpcy5hbmdsZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbmdsZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoZCk7XG5cbiAgICAgICAgICAgIHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciBwcCA9IHRoaXMuUGF0aFBhcnNlcjtcbiAgICAgICAgICAgICAgICBwcC5yZXNldCgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGJiID0gbmV3IHN2Zy5Cb3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlICghcHAuaXNFbmQoKSkge1xuICAgICAgICAgICAgICAgICAgICBwcC5uZXh0Q29tbWFuZCgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBwLmNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHAuYWRkTWFya2VyKHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkUG9pbnQocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHgubW92ZVRvKHAueCwgcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBwLnN0YXJ0ID0gcHAuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcC5hZGRNYXJrZXIocCwgcHAuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJiLmFkZFBvaW50KHAueCwgcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIGN0eC5saW5lVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gcHAuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuYWRkTWFya2VyKHAsIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJiLmFkZFBvaW50KHAueCwgcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIGN0eC5saW5lVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdQID0gbmV3IHN2Zy5Qb2ludCgocHAuaXNSZWxhdGl2ZUNvbW1hbmQoKSA/IHBwLmN1cnJlbnQueCA6IDApICsgcHAuZ2V0U2NhbGFyKCksIHBwLmN1cnJlbnQueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuYWRkTWFya2VyKG5ld1AsIHBwLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmN1cnJlbnQgPSBuZXdQO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJiLmFkZFBvaW50KHBwLmN1cnJlbnQueCwgcHAuY3VycmVudC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIGN0eC5saW5lVG8ocHAuY3VycmVudC54LCBwcC5jdXJyZW50LnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdQID0gbmV3IHN2Zy5Qb2ludChwcC5jdXJyZW50LngsIChwcC5pc1JlbGF0aXZlQ29tbWFuZCgpID8gcHAuY3VycmVudC55IDogMCkgKyBwcC5nZXRTY2FsYXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAuYWRkTWFya2VyKG5ld1AsIHBwLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmN1cnJlbnQgPSBuZXdQO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJiLmFkZFBvaW50KHBwLmN1cnJlbnQueCwgcHAuY3VycmVudC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4ICE9IG51bGwpIGN0eC5saW5lVG8ocHAuY3VycmVudC54LCBwcC5jdXJyZW50LnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyID0gcHAuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcDEgPSBwcC5nZXRQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbnRybCA9IHBwLmdldEFzQ29udHJvbFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcC5hZGRNYXJrZXIoY3AsIGNudHJsLCBwMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkQmV6aWVyQ3VydmUoY3Vyci54LCBjdXJyLnksIHAxLngsIHAxLnksIGNudHJsLngsIGNudHJsLnksIGNwLngsIGNwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmJlemllckN1cnZlVG8ocDEueCwgcDEueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnIgPSBwcC5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwMSA9IHBwLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbnRybCA9IHBwLmdldEFzQ29udHJvbFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcC5hZGRNYXJrZXIoY3AsIGNudHJsLCBwMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkQmV6aWVyQ3VydmUoY3Vyci54LCBjdXJyLnksIHAxLngsIHAxLnksIGNudHJsLngsIGNudHJsLnksIGNwLngsIGNwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LmJlemllckN1cnZlVG8ocDEueCwgcDEueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnIgPSBwcC5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbnRybCA9IHBwLmdldEFzQ29udHJvbFBvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcC5hZGRNYXJrZXIoY3AsIGNudHJsLCBjbnRybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkUXVhZHJhdGljQ3VydmUoY3Vyci54LCBjdXJyLnksIGNudHJsLngsIGNudHJsLnksIGNwLngsIGNwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnIgPSBwcC5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbnRybCA9IHBwLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmNvbnRyb2wgPSBjbnRybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmFkZE1hcmtlcihjcCwgY250cmwsIGNudHJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYi5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyLngsIGN1cnIueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHgucXVhZHJhdGljQ3VydmVUbyhjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyciA9IHBwLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gcHAuZ2V0U2NhbGFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ5ID0gcHAuZ2V0U2NhbGFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhBeGlzUm90YXRpb24gPSBwcC5nZXRTY2FsYXIoKSAqIChNYXRoLlBJIC8gMTgwLjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXJnZUFyY0ZsYWcgPSBwcC5nZXRTY2FsYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3dlZXBGbGFnID0gcHAuZ2V0U2NhbGFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnNpb24gZnJvbSBlbmRwb2ludCB0byBjZW50ZXIgcGFyYW1ldGVyaXphdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHgxJywgeTEnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJwID0gbmV3IHN2Zy5Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiAoY3Vyci54IC0gY3AueCkgLyAyLjAgKyBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIChjdXJyLnkgLSBjcC55KSAvIDIuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLU1hdGguc2luKHhBeGlzUm90YXRpb24pICogKGN1cnIueCAtIGNwLngpIC8gMi4wICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiAoY3Vyci55IC0gY3AueSkgLyAyLjBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCByYWRpaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gTWF0aC5wb3coY3VycnAueCwyKS9NYXRoLnBvdyhyeCwyKStNYXRoLnBvdyhjdXJycC55LDIpL01hdGgucG93KHJ5LDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByeCAqPSBNYXRoLnNxcnQobCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ5ICo9IE1hdGguc3FydChsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3gnLCBjeSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IChsYXJnZUFyY0ZsYWcgPT0gc3dlZXBGbGFnID8gLTEgOiAxKSAqIE1hdGguc3FydChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChNYXRoLnBvdyhyeCwyKSpNYXRoLnBvdyhyeSwyKSktKE1hdGgucG93KHJ4LDIpKk1hdGgucG93KGN1cnJwLnksMikpLShNYXRoLnBvdyhyeSwyKSpNYXRoLnBvdyhjdXJycC54LDIpKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoTWF0aC5wb3cocngsMikqTWF0aC5wb3coY3VycnAueSwyKStNYXRoLnBvdyhyeSwyKSpNYXRoLnBvdyhjdXJycC54LDIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHMpKSBzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3BwID0gbmV3IHN2Zy5Qb2ludChzICogcnggKiBjdXJycC55IC8gcnksIHMgKiAtcnkgKiBjdXJycC54IC8gcngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN4LCBjeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZW50cCA9IG5ldyBzdmcuUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyLnggKyBjcC54KSAvIDIuMCArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogY3BwLnggLSBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIGNwcC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY3Vyci55ICsgY3AueSkgLyAyLjAgKyBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIGNwcC54ICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiBjcHAueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmVjdG9yIG1hZ25pdHVkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gZnVuY3Rpb24odikgeyByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHZbMF0sMikgKyBNYXRoLnBvdyh2WzFdLDIpKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJhdGlvIGJldHdlZW4gdHdvIHZlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGZ1bmN0aW9uKHUsIHYpIHsgcmV0dXJuICh1WzBdKnZbMF0rdVsxXSp2WzFdKSAvIChtKHUpKm0odikpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBmdW5jdGlvbih1LCB2KSB7IHJldHVybiAodVswXSp2WzFdIDwgdVsxXSp2WzBdID8gLTEgOiAxKSAqIE1hdGguYWNvcyhyKHUsdikpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbCBhbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhMSA9IGEoWzEsMF0sIFsoY3VycnAueC1jcHAueCkvcngsKGN1cnJwLnktY3BwLnkpL3J5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5nbGUgZGVsdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IFsoY3VycnAueC1jcHAueCkvcngsKGN1cnJwLnktY3BwLnkpL3J5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IFsoLWN1cnJwLngtY3BwLngpL3J4LCgtY3VycnAueS1jcHAueSkvcnldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZCA9IGEodSwgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIodSx2KSA8PSAtMSkgYWQgPSBNYXRoLlBJO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyKHUsdikgPj0gMSkgYWQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG1hcmtlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyID0gMSAtIHN3ZWVwRmxhZyA/IDEuMCA6IC0xLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFoID0gYTEgKyBkaXIgKiAoYWQgLyAyLjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYWxmV2F5ID0gbmV3IHN2Zy5Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudHAueCArIHJ4ICogTWF0aC5jb3MoYWgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50cC55ICsgcnkgKiBNYXRoLnNpbihhaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmFkZE1hcmtlckFuZ2xlKGhhbGZXYXksIGFoIC0gZGlyICogTWF0aC5QSSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBwLmFkZE1hcmtlckFuZ2xlKGNwLCBhaCAtIGRpciAqIE1hdGguUEkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIuYWRkUG9pbnQoY3AueCwgY3AueSk7IC8vIFRPRE86IHRoaXMgaXMgdG9vIG5haXZlLCBtYWtlIGl0IGJldHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSByeCA+IHJ5ID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IHJ4ID4gcnkgPyByeSAvIHJ4IDogMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNlbnRwLngsIGNlbnRwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKHhBeGlzUm90YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoc3gsIHN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCBhMSwgYTEgKyBhZCwgMSAtIHN3ZWVwRmxhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxL3N4LCAxL3N5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgteEF4aXNSb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWNlbnRwLngsIC1jZW50cC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPSBudWxsKSBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcC5jdXJyZW50ID0gcHAuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYmI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0TWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLlBhdGhQYXJzZXIuZ2V0TWFya2VyUG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlcyA9IHRoaXMuUGF0aFBhcnNlci5nZXRNYXJrZXJBbmdsZXMoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKFtwb2ludHNbaV0sIGFuZ2xlc1tpXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5wYXRoLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBwYXR0ZXJuIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQucGF0dGVybiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVBhdHRlcm4gPSBmdW5jdGlvbihjdHgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knLCB0cnVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxuICAgICAgICAgICAgICAgIHZhciB0ZW1wU3ZnID0gbmV3IHN2Zy5FbGVtZW50LnN2ZygpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1sndmlld0JveCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndmlld0JveCcsIHRoaXMuYXR0cmlidXRlKCd2aWV3Qm94JykudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snd2lkdGgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3dpZHRoJywgd2lkdGggKyAncHgnKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0JywgaGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzWyd0cmFuc2Zvcm0nXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3RyYW5zZm9ybScsIHRoaXMuYXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJykudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgYy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIGMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBjY3R4ID0gYy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkgJiYgdGhpcy5hdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNjdHgudHJhbnNsYXRlKHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnLCB0cnVlKSwgdGhpcy5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIDN4MyBncmlkIHNvIHdoZW4gd2UgdHJhbnNmb3JtIHRoZXJlJ3Mgbm8gd2hpdGUgc3BhY2Ugb24gZWRnZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4PS0xOyB4PD0xOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeT0tMTsgeTw9MTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjdHgudHJhbnNsYXRlKHggKiBjLndpZHRoLCB5ICogYy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5yZW5kZXIoY2N0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKGMsICdyZXBlYXQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5wYXR0ZXJuLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIG1hcmtlciBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50Lm1hcmtlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmJhc2VSZW5kZXIgPSB0aGlzLnJlbmRlcjtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4LCBwb2ludCwgYW5nbGUpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnb3JpZW50JykudmFsdWVPckRlZmF1bHQoJ2F1dG8nKSA9PSAnYXV0bycpIGN0eC5yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnbWFya2VyVW5pdHMnKS52YWx1ZU9yRGVmYXVsdCgnc3Ryb2tlV2lkdGgnKSA9PSAnc3Ryb2tlV2lkdGgnKSBjdHguc2NhbGUoY3R4LmxpbmVXaWR0aCwgY3R4LmxpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB2YXIgdGVtcFN2ZyA9IG5ldyBzdmcuRWxlbWVudC5zdmcoKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3ZpZXdCb3gnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3ZpZXdCb3gnLCB0aGlzLmF0dHJpYnV0ZSgndmlld0JveCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3JlZlgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3JlZlgnLCB0aGlzLmF0dHJpYnV0ZSgncmVmWCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3JlZlknXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3JlZlknLCB0aGlzLmF0dHJpYnV0ZSgncmVmWScpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3dpZHRoJ10gPSBuZXcgc3ZnLlByb3BlcnR5KCd3aWR0aCcsIHRoaXMuYXR0cmlidXRlKCdtYXJrZXJXaWR0aCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0JywgdGhpcy5hdHRyaWJ1dGUoJ21hcmtlckhlaWdodCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2ZpbGwnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ2ZpbGwnLCB0aGlzLmF0dHJpYnV0ZSgnZmlsbCcpLnZhbHVlT3JEZWZhdWx0KCdibGFjaycpKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3N0cm9rZSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnc3Ryb2tlJywgdGhpcy5hdHRyaWJ1dGUoJ3N0cm9rZScpLnZhbHVlT3JEZWZhdWx0KCdub25lJykpO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIHRlbXBTdmcucmVuZGVyKGN0eCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ21hcmtlclVuaXRzJykudmFsdWVPckRlZmF1bHQoJ3N0cm9rZVdpZHRoJykgPT0gJ3N0cm9rZVdpZHRoJykgY3R4LnNjYWxlKDEvY3R4LmxpbmVXaWR0aCwgMS9jdHgubGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ29yaWVudCcpLnZhbHVlT3JEZWZhdWx0KCdhdXRvJykgPT0gJ2F1dG8nKSBjdHgucm90YXRlKC1hbmdsZSk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtcG9pbnQueCwgLXBvaW50LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50Lm1hcmtlci5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBkZWZpbml0aW9ucyBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmRlZnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTsgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgLy8gTk9PUFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmRlZnMucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gYmFzZSBmb3IgZ3JhZGllbnRzXG4gICAgICAgIHN2Zy5FbGVtZW50LkdyYWRpZW50QmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50VW5pdHMgPSB0aGlzLmF0dHJpYnV0ZSgnZ3JhZGllbnRVbml0cycpLnZhbHVlT3JEZWZhdWx0KCdvYmplY3RCb3VuZGluZ0JveCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnN0b3BzID0gW107ICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT0gJ3N0b3AnKSB0aGlzLnN0b3BzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfSAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldEdyYWRpZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gT1ZFUlJJREUgTUUhXG4gICAgICAgICAgICB9ICAgICAgICAgICBcblxuICAgICAgICAgICAgdGhpcy5jcmVhdGVHcmFkaWVudCA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCwgcGFyZW50T3BhY2l0eVByb3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcHNDb250YWluZXIgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BzQ29udGFpbmVyID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgYWRkUGFyZW50T3BhY2l0eSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50T3BhY2l0eVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgc3ZnLlByb3BlcnR5KCdjb2xvcicsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwLmFkZE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3ApLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGcgPSB0aGlzLmdldEdyYWRpZW50KGN0eCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGcgPT0gbnVsbCkgcmV0dXJuIGFkZFBhcmVudE9wYWNpdHkoc3RvcHNDb250YWluZXIuc3RvcHNbc3RvcHNDb250YWluZXIuc3RvcHMubGVuZ3RoIC0gMV0uY29sb3IpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzdG9wc0NvbnRhaW5lci5zdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBnLmFkZENvbG9yU3RvcChzdG9wc0NvbnRhaW5lci5zdG9wc1tpXS5vZmZzZXQsIGFkZFBhcmVudE9wYWNpdHkoc3RvcHNDb250YWluZXIuc3RvcHNbaV0uY29sb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGFzIHRyYW5zZm9ybWVkIHBhdHRlcm4gb24gdGVtcG9yYXJ5IGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdFZpZXcgPSBzdmcuVmlld1BvcnQudmlld1BvcnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgc3ZnLkVsZW1lbnQucmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICByZWN0LmF0dHJpYnV0ZXNbJ3gnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3gnLCAtc3ZnLk1BWF9WSVJUVUFMX1BJWEVMUy8zLjApO1xuICAgICAgICAgICAgICAgICAgICByZWN0LmF0dHJpYnV0ZXNbJ3knXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3knLCAtc3ZnLk1BWF9WSVJUVUFMX1BJWEVMUy8zLjApO1xuICAgICAgICAgICAgICAgICAgICByZWN0LmF0dHJpYnV0ZXNbJ3dpZHRoJ10gPSBuZXcgc3ZnLlByb3BlcnR5KCd3aWR0aCcsIHN2Zy5NQVhfVklSVFVBTF9QSVhFTFMpO1xuICAgICAgICAgICAgICAgICAgICByZWN0LmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0Jywgc3ZnLk1BWF9WSVJUVUFMX1BJWEVMUyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgc3ZnLkVsZW1lbnQuZygpO1xuICAgICAgICAgICAgICAgICAgICBncm91cC5hdHRyaWJ1dGVzWyd0cmFuc2Zvcm0nXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3RyYW5zZm9ybScsIHRoaXMuYXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuY2hpbGRyZW4gPSBbIHJlY3QgXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wU3ZnID0gbmV3IHN2Zy5FbGVtZW50LnN2ZygpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3gnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3gnLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzWyd5J10gPSBuZXcgc3ZnLlByb3BlcnR5KCd5JywgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snd2lkdGgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3dpZHRoJywgcm9vdFZpZXcud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0Jywgcm9vdFZpZXcuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5jaGlsZHJlbiA9IFsgZ3JvdXAgXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSByb290Vmlldy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYy5oZWlnaHQgPSByb290Vmlldy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wQ3R4ID0gYy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQ3R4LmZpbGxTdHlsZSA9IGc7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdmcucmVuZGVyKHRlbXBDdHgpOyAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wQ3R4LmNyZWF0ZVBhdHRlcm4oYywgJ25vLXJlcGVhdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gZzsgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5HcmFkaWVudEJhc2UucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gbGluZWFyIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQubGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5HcmFkaWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0R3JhZGllbnQgPSBmdW5jdGlvbihjdHgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmIgPSB0aGlzLmdyYWRpZW50VW5pdHMgPT0gJ29iamVjdEJvdW5kaW5nQm94JyA/IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZSgneDEnKS5oYXNWYWx1ZSgpXG4gICAgICAgICAgICAgICAgICYmICF0aGlzLmF0dHJpYnV0ZSgneTEnKS5oYXNWYWx1ZSgpXG4gICAgICAgICAgICAgICAgICYmICF0aGlzLmF0dHJpYnV0ZSgneDInKS5oYXNWYWx1ZSgpXG4gICAgICAgICAgICAgICAgICYmICF0aGlzLmF0dHJpYnV0ZSgneTInKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlKCd4MScsIHRydWUpLnZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUoJ3kxJywgdHJ1ZSkudmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSgneDInLCB0cnVlKS52YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlKCd5MicsIHRydWUpLnZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciB4MSA9ICh0aGlzLmdyYWRpZW50VW5pdHMgPT0gJ29iamVjdEJvdW5kaW5nQm94JyBcbiAgICAgICAgICAgICAgICAgICAgPyBiYi54KCkgKyBiYi53aWR0aCgpICogdGhpcy5hdHRyaWJ1dGUoJ3gxJykubnVtVmFsdWUoKSBcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmF0dHJpYnV0ZSgneDEnKS50b1BpeGVscygneCcpKTtcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSAodGhpcy5ncmFkaWVudFVuaXRzID09ICdvYmplY3RCb3VuZGluZ0JveCcgXG4gICAgICAgICAgICAgICAgICAgID8gYmIueSgpICsgYmIuaGVpZ2h0KCkgKiB0aGlzLmF0dHJpYnV0ZSgneTEnKS5udW1WYWx1ZSgpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5hdHRyaWJ1dGUoJ3kxJykudG9QaXhlbHMoJ3knKSk7XG4gICAgICAgICAgICAgICAgdmFyIHgyID0gKHRoaXMuZ3JhZGllbnRVbml0cyA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnIFxuICAgICAgICAgICAgICAgICAgICA/IGJiLngoKSArIGJiLndpZHRoKCkgKiB0aGlzLmF0dHJpYnV0ZSgneDInKS5udW1WYWx1ZSgpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5hdHRyaWJ1dGUoJ3gyJykudG9QaXhlbHMoJ3gnKSk7XG4gICAgICAgICAgICAgICAgdmFyIHkyID0gKHRoaXMuZ3JhZGllbnRVbml0cyA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnIFxuICAgICAgICAgICAgICAgICAgICA/IGJiLnkoKSArIGJiLmhlaWdodCgpICogdGhpcy5hdHRyaWJ1dGUoJ3kyJykubnVtVmFsdWUoKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuYXR0cmlidXRlKCd5MicpLnRvUGl4ZWxzKCd5JykpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHgxID09IHgyICYmIHkxID09IHkyKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5saW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuR3JhZGllbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gcmFkaWFsIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQucmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5HcmFkaWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0R3JhZGllbnQgPSBmdW5jdGlvbihjdHgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmIgPSBlbGVtZW50LmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZSgnY3gnKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgnY3gnLCB0cnVlKS52YWx1ZSA9ICc1MCUnO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdHRyaWJ1dGUoJ2N5JykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ2N5JywgdHJ1ZSkudmFsdWUgPSAnNTAlJztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXR0cmlidXRlKCdyJykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ3InLCB0cnVlKS52YWx1ZSA9ICc1MCUnO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBjeCA9ICh0aGlzLmdyYWRpZW50VW5pdHMgPT0gJ29iamVjdEJvdW5kaW5nQm94JyBcbiAgICAgICAgICAgICAgICAgICAgPyBiYi54KCkgKyBiYi53aWR0aCgpICogdGhpcy5hdHRyaWJ1dGUoJ2N4JykubnVtVmFsdWUoKSBcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmF0dHJpYnV0ZSgnY3gnKS50b1BpeGVscygneCcpKTtcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSAodGhpcy5ncmFkaWVudFVuaXRzID09ICdvYmplY3RCb3VuZGluZ0JveCcgXG4gICAgICAgICAgICAgICAgICAgID8gYmIueSgpICsgYmIuaGVpZ2h0KCkgKiB0aGlzLmF0dHJpYnV0ZSgnY3knKS5udW1WYWx1ZSgpIFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuYXR0cmlidXRlKCdjeScpLnRvUGl4ZWxzKCd5JykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBmeCA9IGN4O1xuICAgICAgICAgICAgICAgIHZhciBmeSA9IGN5O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnZngnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ4ID0gKHRoaXMuZ3JhZGllbnRVbml0cyA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnIFxuICAgICAgICAgICAgICAgICAgICA/IGJiLngoKSArIGJiLndpZHRoKCkgKiB0aGlzLmF0dHJpYnV0ZSgnZngnKS5udW1WYWx1ZSgpIFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuYXR0cmlidXRlKCdmeCcpLnRvUGl4ZWxzKCd4JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ2Z5JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBmeSA9ICh0aGlzLmdyYWRpZW50VW5pdHMgPT0gJ29iamVjdEJvdW5kaW5nQm94JyBcbiAgICAgICAgICAgICAgICAgICAgPyBiYi55KCkgKyBiYi5oZWlnaHQoKSAqIHRoaXMuYXR0cmlidXRlKCdmeScpLm51bVZhbHVlKCkgXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5hdHRyaWJ1dGUoJ2Z5JykudG9QaXhlbHMoJ3knKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciByID0gKHRoaXMuZ3JhZGllbnRVbml0cyA9PSAnb2JqZWN0Qm91bmRpbmdCb3gnIFxuICAgICAgICAgICAgICAgICAgICA/IChiYi53aWR0aCgpICsgYmIuaGVpZ2h0KCkpIC8gMi4wICogdGhpcy5hdHRyaWJ1dGUoJ3InKS5udW1WYWx1ZSgpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5hdHRyaWJ1dGUoJ3InKS50b1BpeGVscygpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGZ4LCBmeSwgMCwgY3gsIGN5LCByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5yYWRpYWxHcmFkaWVudC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuR3JhZGllbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gZ3JhZGllbnQgc3RvcCBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LnN0b3AgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLmF0dHJpYnV0ZSgnb2Zmc2V0JykubnVtVmFsdWUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9mZnNldCA8IDApIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLm9mZnNldCA+IDEpIHRoaXMub2Zmc2V0ID0gMTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHN0b3BDb2xvciA9IHRoaXMuc3R5bGUoJ3N0b3AtY29sb3InKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKCdzdG9wLW9wYWNpdHknKS5oYXNWYWx1ZSgpKSBzdG9wQ29sb3IgPSBzdG9wQ29sb3IuYWRkT3BhY2l0eSh0aGlzLnN0eWxlKCdzdG9wLW9wYWNpdHknKSk7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gc3RvcENvbG9yLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnN0b3AucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gYW5pbWF0aW9uIGJhc2UgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5BbmltYXRlQmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdmcuQW5pbWF0aW9ucy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5iZWdpbiA9IHRoaXMuYXR0cmlidXRlKCdiZWdpbicpLnRvTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICB0aGlzLm1heER1cmF0aW9uID0gdGhpcy5iZWdpbiArIHRoaXMuYXR0cmlidXRlKCdkdXInKS50b01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldFByb3BlcnR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZVR5cGUgPSB0aGlzLmF0dHJpYnV0ZSgnYXR0cmlidXRlVHlwZScpLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gdGhpcy5hdHRyaWJ1dGUoJ2F0dHJpYnV0ZU5hbWUnKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlVHlwZSA9PSAnQ1NTJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuc3R5bGUoYXR0cmlidXRlTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5hdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgdHJ1ZSk7ICAgICAgICAgIFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsVW5pdHMgPSAnJztcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlZCA9IGZhbHNlOyAgICAgICBcblxuICAgICAgICAgICAgdGhpcy5jYWxjVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBPVkVSUklERSBNRSFcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihkZWx0YSkgeyBcbiAgICAgICAgICAgICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdGhpcy5nZXRQcm9wZXJ0eSgpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxVbml0cyA9IHRoaXMuZ2V0UHJvcGVydHkoKS5nZXRVbml0cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHBhc3QgdGhlIGVuZCB0aW1lXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHVyYXRpb24gPiB0aGlzLm1heER1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb3AgZm9yIGluZGVmaW5pdGVseSByZXBlYXRpbmcgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ3JlcGVhdENvdW50JykudmFsdWUgPT0gJ2luZGVmaW5pdGUnXG4gICAgICAgICAgICAgICAgICAgICB8fCB0aGlzLmF0dHJpYnV0ZSgncmVwZWF0RHVyJykudmFsdWUgPT0gJ2luZGVmaW5pdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gMC4wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hdHRyaWJ1dGUoJ2ZpbGwnKS52YWx1ZU9yRGVmYXVsdCgncmVtb3ZlJykgPT0gJ2ZyZWV6ZScgJiYgIXRoaXMuZnJvemVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5hbmltYXRpb25Gcm96ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgPSB0aGlzLmdldFByb3BlcnR5KCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hdHRyaWJ1dGUoJ2ZpbGwnKS52YWx1ZU9yRGVmYXVsdCgncmVtb3ZlJykgPT0gJ3JlbW92ZScgJiYgIXRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UHJvcGVydHkoKS52YWx1ZSA9IHRoaXMucGFyZW50LmFuaW1hdGlvbkZyb3plbiA/IHRoaXMucGFyZW50LmFuaW1hdGlvbkZyb3plblZhbHVlIDogdGhpcy5pbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24gKyBkZWx0YTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHBhc3QgdGhlIGJlZ2luIHRpbWVcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJlZ2luIDwgdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmNhbGNWYWx1ZSgpOyAvLyB0d2VlblxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCd0eXBlJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRyYW5zZm9ybSwgZXRjLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmF0dHJpYnV0ZSgndHlwZScpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0eXBlICsgJygnICsgbmV3VmFsdWUgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UHJvcGVydHkoKS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYXR0cmlidXRlKCdmcm9tJyk7XG4gICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5hdHRyaWJ1dGUoJ3RvJyk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHRoaXMuYXR0cmlidXRlKCd2YWx1ZXMnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlcy5oYXNWYWx1ZSgpKSB0aGlzLnZhbHVlcy52YWx1ZSA9IHRoaXMudmFsdWVzLnZhbHVlLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGZyYWN0aW9uIG9mIGR1cmF0aW9uIHdlJ3ZlIGNvdmVyZWRcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0geyBwcm9ncmVzczogKHRoaXMuZHVyYXRpb24gLSB0aGlzLmJlZ2luKSAvICh0aGlzLm1heER1cmF0aW9uIC0gdGhpcy5iZWdpbikgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHJldC5wcm9ncmVzcyAqICh0aGlzLnZhbHVlcy52YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxiID0gTWF0aC5mbG9vcihwKSwgdWIgPSBNYXRoLmNlaWwocCk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5mcm9tID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnZnJvbScsIHBhcnNlRmxvYXQodGhpcy52YWx1ZXMudmFsdWVbbGJdKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldC50byA9IG5ldyBzdmcuUHJvcGVydHkoJ3RvJywgcGFyc2VGbG9hdCh0aGlzLnZhbHVlcy52YWx1ZVt1Yl0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnByb2dyZXNzID0gKHAgLSBsYikgLyAodWIgLSBsYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXQuZnJvbSA9IHRoaXMuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnRvID0gdGhpcy50bztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LkFuaW1hdGVCYXNlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIGFuaW1hdGUgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5hbmltYXRlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuQW5pbWF0ZUJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY2FsY1ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gdHdlZW4gdmFsdWUgbGluZWFybHlcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBwLmZyb20ubnVtVmFsdWUoKSArIChwLnRvLm51bVZhbHVlKCkgLSBwLmZyb20ubnVtVmFsdWUoKSkgKiBwLnByb2dyZXNzOyBcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3VmFsdWUgKyB0aGlzLmluaXRpYWxVbml0cztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuYW5pbWF0ZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuQW5pbWF0ZUJhc2U7XG4gICAgICAgICAgICBcbiAgICAgICAgLy8gYW5pbWF0ZSBjb2xvciBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmFuaW1hdGVDb2xvciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkFuaW1hdGVCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGNWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5wcm9ncmVzcygpO1xuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gbmV3IFJHQkNvbG9yKHAuZnJvbS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHRvID0gbmV3IFJHQkNvbG9yKHAudG8udmFsdWUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChmcm9tLm9rICYmIHRvLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHR3ZWVuIGNvbG9yIGxpbmVhcmx5XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZnJvbS5yICsgKHRvLnIgLSBmcm9tLnIpICogcC5wcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBmcm9tLmcgKyAodG8uZyAtIGZyb20uZykgKiBwLnByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGZyb20uYiArICh0by5iIC0gZnJvbS5iKSAqIHAucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncmdiKCcrcGFyc2VJbnQociwxMCkrJywnK3BhcnNlSW50KGcsMTApKycsJytwYXJzZUludChiLDEwKSsnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZSgnZnJvbScpLnZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5hbmltYXRlQ29sb3IucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkFuaW1hdGVCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gYW5pbWF0ZSB0cmFuc2Zvcm0gZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5hbmltYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuQW5pbWF0ZUJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY2FsY1ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gdHdlZW4gdmFsdWUgbGluZWFybHlcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHN2Zy5Ub051bWJlckFycmF5KHAuZnJvbS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHRvID0gc3ZnLlRvTnVtYmVyQXJyYXkocC50by52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgKz0gZnJvbVtpXSArICh0b1tpXSAtIGZyb21baV0pICogcC5wcm9ncmVzcyArICcgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5hbmltYXRlVHJhbnNmb3JtLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5hbmltYXRlO1xuICAgICAgICBcbiAgICAgICAgLy8gZm9udCBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmZvbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcblxuICAgICAgICAgICAgdGhpcy5ob3JpekFkdlggPSB0aGlzLmF0dHJpYnV0ZSgnaG9yaXotYWR2LXgnKS5udW1WYWx1ZSgpOyAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5pc1JUTCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0FyYWJpYyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5mb250RmFjZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1pc3NpbmdHbHlwaCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmdseXBocyA9IFtdOyAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT0gJ2ZvbnQtZmFjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb250RmFjZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuc3R5bGUoJ2ZvbnQtZmFtaWx5JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnLkRlZmluaXRpb25zW2NoaWxkLnN0eWxlKCdmb250LWZhbWlseScpLnZhbHVlXSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PSAnbWlzc2luZy1nbHlwaCcpIHRoaXMubWlzc2luZ0dseXBoID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PSAnZ2x5cGgnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5hcmFiaWNGb3JtICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUlRMID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBcmFiaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZih0aGlzLmdseXBoc1tjaGlsZC51bmljb2RlXSkgPT0gJ3VuZGVmaW5lZCcpIHRoaXMuZ2x5cGhzW2NoaWxkLnVuaWNvZGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdseXBoc1tjaGlsZC51bmljb2RlXVtjaGlsZC5hcmFiaWNGb3JtXSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nbHlwaHNbY2hpbGQudW5pY29kZV0gPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gICBcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5mb250LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIGZvbnQtZmFjZSBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LmZvbnRmYWNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFzY2VudCA9IHRoaXMuYXR0cmlidXRlKCdhc2NlbnQnKS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZGVzY2VudCA9IHRoaXMuYXR0cmlidXRlKCdkZXNjZW50JykudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVuaXRzUGVyRW0gPSB0aGlzLmF0dHJpYnV0ZSgndW5pdHMtcGVyLWVtJykubnVtVmFsdWUoKTsgICAgICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuZm9udGZhY2UucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gbWlzc2luZy1nbHlwaCBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50Lm1pc3NpbmdnbHlwaCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LnBhdGg7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmhvcml6QWR2WCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQubWlzc2luZ2dseXBoLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5wYXRoO1xuICAgICAgICBcbiAgICAgICAgLy8gZ2x5cGggZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5nbHlwaCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LnBhdGg7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmhvcml6QWR2WCA9IHRoaXMuYXR0cmlidXRlKCdob3Jpei1hZHYteCcpLm51bVZhbHVlKCk7XG4gICAgICAgICAgICB0aGlzLnVuaWNvZGUgPSB0aGlzLmF0dHJpYnV0ZSgndW5pY29kZScpLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hcmFiaWNGb3JtID0gdGhpcy5hdHRyaWJ1dGUoJ2FyYWJpYy1mb3JtJykudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuZ2x5cGgucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LnBhdGg7XG4gICAgICAgIFxuICAgICAgICAvLyB0ZXh0IGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQudGV4dCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZVRleHROb2RlcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmJhc2VTZXRDb250ZXh0ID0gdGhpcy5zZXRDb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5zZXRDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlU2V0Q29udGV4dChjdHgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciB0ZXh0QmFzZWxpbmUgPSB0aGlzLnN0eWxlKCdkb21pbmFudC1iYXNlbGluZScpLnRvVGV4dEJhc2VsaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRCYXNlbGluZSA9PSBudWxsKSB0ZXh0QmFzZWxpbmUgPSB0aGlzLnN0eWxlKCdhbGlnbm1lbnQtYmFzZWxpbmUnKS50b1RleHRCYXNlbGluZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0QmFzZWxpbmUgIT0gbnVsbCkgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB2YXIgZm9udFNpemUgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1zaXplJykubnVtVmFsdWVPckRlZmF1bHQoc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3goeCwgeSAtIGZvbnRTaXplLCB4ICsgTWF0aC5mbG9vcihmb250U2l6ZSAqIDIuMCAvIDMuMCkgKiB0aGlzLmNoaWxkcmVuWzBdLmdldFRleHQoKS5sZW5ndGgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB0aGlzLnggKz0gdGhpcy5nZXRBbmNob3JEZWx0YShjdHgsIHRoaXMsIDApO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGQoY3R4LCB0aGlzLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0QW5jaG9yRGVsdGEgPSBmdW5jdGlvbiAoY3R4LCBwYXJlbnQsIHN0YXJ0SSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0QW5jaG9yID0gdGhpcy5zdHlsZSgndGV4dC1hbmNob3InKS52YWx1ZU9yRGVmYXVsdCgnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEFuY2hvciAhPSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9c3RhcnRJOyBpPHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiBzdGFydEkgJiYgY2hpbGQuYXR0cmlidXRlKCd4JykuaGFzVmFsdWUoKSkgYnJlYWs7IC8vIG5ldyBncm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggKz0gY2hpbGQubWVhc3VyZVRleHRSZWN1cnNpdmUoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgKiAodGV4dEFuY2hvciA9PSAnZW5kJyA/IHdpZHRoIDogd2lkdGggLyAyLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZCA9IGZ1bmN0aW9uKGN0eCwgcGFyZW50LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGUoJ3gnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnggPSBjaGlsZC5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpICsgdGhpcy5nZXRBbmNob3JEZWx0YShjdHgsIHBhcmVudCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGUoJ2R4JykuaGFzVmFsdWUoKSkgY2hpbGQueCArPSBjaGlsZC5hdHRyaWJ1dGUoJ2R4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZSgnZHgnKS5oYXNWYWx1ZSgpKSB0aGlzLnggKz0gdGhpcy5hdHRyaWJ1dGUoJ2R4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZSgnZHgnKS5oYXNWYWx1ZSgpKSB0aGlzLnggKz0gY2hpbGQuYXR0cmlidXRlKCdkeCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnggPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMueCA9IGNoaWxkLnggKyBjaGlsZC5tZWFzdXJlVGV4dChjdHgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnkgPSBjaGlsZC5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuYXR0cmlidXRlKCdkeScpLmhhc1ZhbHVlKCkpIGNoaWxkLnkgKz0gY2hpbGQuYXR0cmlidXRlKCdkeScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ2R5JykuaGFzVmFsdWUoKSkgdGhpcy55ICs9IHRoaXMuYXR0cmlidXRlKCdkeScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGUoJ2R5JykuaGFzVmFsdWUoKSkgdGhpcy55ICs9IGNoaWxkLmF0dHJpYnV0ZSgnZHknKS50b1BpeGVscygneScpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC55ID0gdGhpcy55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBjaGlsZC55O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxjaGlsZC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkKGN0eCwgY2hpbGQsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC50ZXh0LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gdGV4dCBiYXNlXG4gICAgICAgIHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0R2x5cGggPSBmdW5jdGlvbihmb250LCB0ZXh0LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0ZXh0W2ldO1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGZvbnQuaXNBcmFiaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyYWJpY0Zvcm0gPSAnaXNvbGF0ZWQnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGk9PTAgfHwgdGV4dFtpLTFdPT0nICcpICYmIGk8dGV4dC5sZW5ndGgtMiAmJiB0ZXh0W2krMV0hPScgJykgYXJhYmljRm9ybSA9ICd0ZXJtaW5hbCc7IFxuICAgICAgICAgICAgICAgICAgICBpZiAoaT4wICYmIHRleHRbaS0xXSE9JyAnICYmIGk8dGV4dC5sZW5ndGgtMiAmJiB0ZXh0W2krMV0hPScgJykgYXJhYmljRm9ybSA9ICdtZWRpYWwnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaT4wICYmIHRleHRbaS0xXSE9JyAnICYmIChpID09IHRleHQubGVuZ3RoLTEgfHwgdGV4dFtpKzFdPT0nICcpKSBhcmFiaWNGb3JtID0gJ2luaXRpYWwnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGZvbnQuZ2x5cGhzW2NdKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2x5cGggPSBmb250LmdseXBoc1tjXVthcmFiaWNGb3JtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnbHlwaCA9PSBudWxsICYmIGZvbnQuZ2x5cGhzW2NdLnR5cGUgPT0gJ2dseXBoJykgZ2x5cGggPSBmb250LmdseXBoc1tjXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGggPSBmb250LmdseXBoc1tjXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoID09IG51bGwpIGdseXBoID0gZm9udC5taXNzaW5nR2x5cGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdseXBoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbUZvbnQgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUZvbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9udFNpemUgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1zaXplJykubnVtVmFsdWVPckRlZmF1bHQoc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb250U3R5bGUgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1zdHlsZScpLnZhbHVlT3JEZWZhdWx0KHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1c3RvbUZvbnQuaXNSVEwpIHRleHQgPSB0ZXh0LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gc3ZnLlRvTnVtYmVyQXJyYXkodGhpcy5wYXJlbnQuYXR0cmlidXRlKCdkeCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2V0R2x5cGgoY3VzdG9tRm9udCwgdGV4dCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBmb250U2l6ZSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCAtc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGx3ID0gY3R4LmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBjdHgubGluZVdpZHRoICogY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtIC8gZm9udFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9udFN0eWxlID09ICdpdGFsaWMnKSBjdHgudHJhbnNmb3JtKDEsIDAsIC40LCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdseXBoLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvbnRTdHlsZSA9PSAnaXRhbGljJykgY3R4LnRyYW5zZm9ybSgxLCAwLCAtLjQsIDEsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGx3O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEvc2NhbGUsIC0xL3NjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXRoaXMueCwgLXRoaXMueSk7ICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnggKz0gZm9udFNpemUgKiAoZ2x5cGguaG9yaXpBZHZYIHx8IGN1c3RvbUZvbnQuaG9yaXpBZHZYKSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoZHhbaV0pICE9ICd1bmRlZmluZWQnICYmICFpc05hTihkeFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnggKz0gZHhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChjdHguZmlsbFN0eWxlICE9ICcnKSBjdHguZmlsbFRleHQoc3ZnLmNvbXByZXNzU3BhY2VzKHRoaXMuZ2V0VGV4dCgpKSwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgICAgIGlmIChjdHguc3Ryb2tlU3R5bGUgIT0gJycpIGN0eC5zdHJva2VUZXh0KHN2Zy5jb21wcmVzc1NwYWNlcyh0aGlzLmdldFRleHQoKSksIHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gT1ZFUlJJREUgTUVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlVGV4dFJlY3Vyc2l2ZSA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMubWVhc3VyZVRleHQoY3R4KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSB0aGlzLmNoaWxkcmVuW2ldLm1lYXN1cmVUZXh0UmVjdXJzaXZlKGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXN0b21Gb250ID0gdGhpcy5wYXJlbnQuc3R5bGUoJ2ZvbnQtZmFtaWx5JykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21Gb250ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5wYXJlbnQuc3R5bGUoJ2ZvbnQtc2l6ZScpLm51bVZhbHVlT3JEZWZhdWx0KHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVhc3VyZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXN0b21Gb250LmlzUlRMKSB0ZXh0ID0gdGV4dC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gc3ZnLlRvTnVtYmVyQXJyYXkodGhpcy5wYXJlbnQuYXR0cmlidXRlKCdkeCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2V0R2x5cGgoY3VzdG9tRm9udCwgdGV4dCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlICs9IChnbHlwaC5ob3JpekFkdlggfHwgY3VzdG9tRm9udC5ob3JpekFkdlgpICogZm9udFNpemUgLyBjdXN0b21Gb250LmZvbnRGYWNlLnVuaXRzUGVyRW07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGR4W2ldKSAhPSAndW5kZWZpbmVkJyAmJiAhaXNOYU4oZHhbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVhc3VyZSArPSBkeFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFRvTWVhc3VyZSA9IHN2Zy5jb21wcmVzc1NwYWNlcyh0aGlzLmdldFRleHQoKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjdHgubWVhc3VyZVRleHQpIHJldHVybiB0ZXh0VG9NZWFzdXJlLmxlbmd0aCAqIDEwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDb250ZXh0KGN0eCk7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRleHRUb01lYXN1cmUpLndpZHRoO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIHRzcGFuIFxuICAgICAgICBzdmcuRWxlbWVudC50c3BhbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZVRleHROb2RlcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5UZXh0RWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IG5vZGUubm9kZVZhbHVlIHx8IG5vZGUudGV4dCB8fCAnJztcbiAgICAgICAgICAgIHRoaXMuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQudHNwYW4ucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIHRyZWZcbiAgICAgICAgc3ZnLkVsZW1lbnQudHJlZiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gbnVsbCkgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW5bMF0uZ2V0VGV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnRyZWYucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTsgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvLyBhIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuYSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5oYXNUZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlICE9IDMpIHRoaXMuaGFzVGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGNvbnRhaW4gdGV4dFxuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5oYXNUZXh0ID8gbm9kZS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA6ICcnO1xuICAgICAgICAgICAgdGhpcy5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICAgICAgICAgIH0gICAgICAgXG5cbiAgICAgICAgICAgIHRoaXMuYmFzZVJlbmRlckNoaWxkcmVuID0gdGhpcy5yZW5kZXJDaGlsZHJlbjtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlciBhcyB0ZXh0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXNlUmVuZGVyQ2hpbGRyZW4oY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnRTaXplID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnZm9udFNpemUnLCBzdmcuRm9udC5QYXJzZShzdmcuY3R4LmZvbnQpLmZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgc3ZnLk1vdXNlLmNoZWNrQm91bmRpbmdCb3godGhpcywgbmV3IHN2Zy5Cb3VuZGluZ0JveCh0aGlzLngsIHRoaXMueSAtIGZvbnRTaXplLnRvUGl4ZWxzKCd5JyksIHRoaXMueCArIHRoaXMubWVhc3VyZVRleHQoY3R4KSwgdGhpcy55KSk7ICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlciBhcyB0ZW1wb3JhcnkgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBuZXcgc3ZnLkVsZW1lbnQuZygpO1xuICAgICAgICAgICAgICAgICAgICBnLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgZy5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBnLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgd2luZG93Lm9wZW4odGhpcy5nZXRIcmVmQXR0cmlidXRlKCkudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3ZnLmN0eC5jYW52YXMuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmEucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTsgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8vIGltYWdlIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuaW1hZ2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgaHJlZiA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGhyZWYgPT0gJycpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB2YXIgaXNTdmcgPSBocmVmLm1hdGNoKC9cXC5zdmckLylcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3ZnLkltYWdlcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghaXNTdmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICAgICAgICAgIGlmIChzdmcub3B0c1sndXNlQ09SUyddID09IHRydWUpIHsgdGhpcy5pbWcuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJzsgfVxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHsgc2VsZi5sb2FkZWQgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbWcub25lcnJvciA9IGZ1bmN0aW9uKCkgeyBzdmcubG9nKCdFUlJPUjogaW1hZ2UgXCInICsgaHJlZiArICdcIiBub3QgZm91bmQnKTsgc2VsZi5sb2FkZWQgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbWcuc3JjID0gaHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW1nID0gc3ZnLmFqYXgoaHJlZik7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5Jyk7ICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoID09IDAgfHwgaGVpZ2h0ID09IDApIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3ZnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3U3ZnKHRoaXMuaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHN2Zy5Bc3BlY3RSYXRpbyhjdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltZy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1nLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwKTsgXG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWcsIDAsIDApOyAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3goeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5pbWFnZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuZyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmIgPSBuZXcgc3ZnLkJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmIuYWRkQm91bmRpbmdCb3godGhpcy5jaGlsZHJlbltpXS5nZXRCb3VuZGluZ0JveCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5nLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xuXG4gICAgICAgIC8vIHN5bWJvbCBlbGVtZW50XG4gICAgICAgIHN2Zy5FbGVtZW50LnN5bWJvbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgLy8gTk8gUkVOREVSXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnN5bWJvbC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTsgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgIC8vIHN0eWxlIGVsZW1lbnRcbiAgICAgICAgc3ZnLkVsZW1lbnQuc3R5bGUgPSBmdW5jdGlvbihub2RlKSB7IFxuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHRleHQsIG9yIHNwYWNlcyB0aGVuIENEQVRBXG4gICAgICAgICAgICB2YXIgY3NzID0gJydcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY3NzICs9IG5vZGUuY2hpbGROb2Rlc1tpXS5ub2RlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjc3MgPSBjc3MucmVwbGFjZSgvKFxcL1xcKihbXipdfFtcXHJcXG5dfChcXCorKFteKlxcL118W1xcclxcbl0pKSkqXFwqK1xcLyl8KF5bXFxzXSpcXC9cXC8uKikvZ20sICcnKTsgLy8gcmVtb3ZlIGNvbW1lbnRzXG4gICAgICAgICAgICBjc3MgPSBzdmcuY29tcHJlc3NTcGFjZXMoY3NzKTsgLy8gcmVwbGFjZSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICB2YXIgY3NzRGVmcyA9IGNzcy5zcGxpdCgnfScpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGNzc0RlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ZnLnRyaW0oY3NzRGVmc1tpXSkgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzc0RlZiA9IGNzc0RlZnNbaV0uc3BsaXQoJ3snKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzc0NsYXNzZXMgPSBjc3NEZWZbMF0uc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzc1Byb3BzID0gY3NzRGVmWzFdLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajxjc3NDbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzQ2xhc3MgPSBzdmcudHJpbShjc3NDbGFzc2VzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3NDbGFzcyAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGs9MDsgazxjc3NQcm9wcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IGNzc1Byb3BzW2tdLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBjc3NQcm9wc1trXS5zdWJzdHIoMCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNzc1Byb3BzW2tdLnN1YnN0cihwcm9wICsgMSwgY3NzUHJvcHNba10ubGVuZ3RoIC0gcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbc3ZnLnRyaW0obmFtZSldID0gbmV3IHN2Zy5Qcm9wZXJ0eShzdmcudHJpbShuYW1lKSwgc3ZnLnRyaW0odmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdmcuU3R5bGVzW2Nzc0NsYXNzXSA9IHByb3BzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3NDbGFzcyA9PSAnQGZvbnQtZmFjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSBwcm9wc1snZm9udC1mYW1pbHknXS52YWx1ZS5yZXBsYWNlKC9cIi9nLCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyY3MgPSBwcm9wc1snc3JjJ10udmFsdWUuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcz0wOyBzPHNyY3MubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcmNzW3NdLmluZGV4T2YoJ2Zvcm1hdChcInN2Z1wiKScpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmxTdGFydCA9IHNyY3Nbc10uaW5kZXhPZigndXJsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybEVuZCA9IHNyY3Nbc10uaW5kZXhPZignKScsIHVybFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gc3Jjc1tzXS5zdWJzdHIodXJsU3RhcnQgKyA1LCB1cmxFbmQgLSB1cmxTdGFydCAtIDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSBzdmcucGFyc2VYbWwoc3ZnLmFqYXgodXJsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmb250Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZj0wOyBmPGZvbnRzLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb250ID0gc3ZnLkNyZWF0ZUVsZW1lbnQoZm9udHNbZl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdmcuRGVmaW5pdGlvbnNbZm9udEZhbWlseV0gPSBmb250O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5zdHlsZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgIFxuICAgICAgICAvLyB1c2UgZWxlbWVudCBcbiAgICAgICAgc3ZnLkVsZW1lbnQudXNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5iYXNlU2V0Q29udGV4dCA9IHRoaXMuc2V0Q29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZVNldENvbnRleHQoY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGUoJ3gnKS5oYXNWYWx1ZSgpKSBjdHgudHJhbnNsYXRlKHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKSwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCd5JykuaGFzVmFsdWUoKSkgY3R4LnRyYW5zbGF0ZSgwLCB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gbnVsbCkgZWxlbWVudC5wYXRoKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcFN2ZyA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudCBpbiBzeW1ib2wgY2FzZXMgKGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNVc2VFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFN2ZyA9IG5ldyBzdmcuRWxlbWVudC5zdmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTdmcudHlwZSA9ICdzdmcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzWyd2aWV3Qm94J10gPSBuZXcgc3ZnLlByb3BlcnR5KCd2aWV3Qm94JywgZWxlbWVudC5hdHRyaWJ1dGUoJ3ZpZXdCb3gnKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3ByZXNlcnZlQXNwZWN0UmF0aW8nXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCBlbGVtZW50LmF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlc1snb3ZlcmZsb3cnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ292ZXJmbG93JywgZWxlbWVudC5hdHRyaWJ1dGUoJ292ZXJmbG93JykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBTdmcudHlwZSA9PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgc3ltYm9sIG9yIHN2ZywgaW5oZXJpdCB3aWR0aC9oZWlnaHQgZnJvbSBtZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLmhhc1ZhbHVlKCkpIHRlbXBTdmcuYXR0cmlidXRlc1snd2lkdGgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3dpZHRoJywgdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0JywgdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkUGFyZW50ID0gdGVtcFN2Zy5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdmcucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN2Zy5wYXJlbnQgPSBvbGRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LnVzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIG1hc2sgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5tYXNrID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgYXMgdGVtcCBzdmcgICBcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPT0gMCAmJiBoZWlnaHQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmIgPSBuZXcgc3ZnLkJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYi5hZGRCb3VuZGluZ0JveCh0aGlzLmNoaWxkcmVuW2ldLmdldEJvdW5kaW5nQm94KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihiYi54MSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihiYi55MSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IE1hdGguZmxvb3IoYmIud2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLmZsb29yKGJiLmhlaWdodCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gdGVtcG9yYXJpbHkgcmVtb3ZlIG1hc2sgdG8gYXZvaWQgcmVjdXJzaW9uXG4gICAgICAgICAgICAgICAgdmFyIG1hc2sgPSBlbGVtZW50LmF0dHJpYnV0ZSgnbWFzaycpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cmlidXRlKCdtYXNrJykudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNNYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIGNNYXNrLndpZHRoID0geCArIHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjTWFzay5oZWlnaHQgPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFza0N0eCA9IGNNYXNrLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4obWFza0N0eCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIGMud2lkdGggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGMuaGVpZ2h0ID0geSArIGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBDdHggPSBjLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVuZGVyKHRlbXBDdHgpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDdHguZmlsbFN0eWxlID0gbWFza0N0eC5jcmVhdGVQYXR0ZXJuKGNNYXNrLCAnbm8tcmVwZWF0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBDdHguZmlsbFJlY3QoMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZW1wQ3R4LmNyZWF0ZVBhdHRlcm4oYywgJ25vLXJlcGVhdCcpO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gcmVhc3NpZ24gbWFza1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cmlidXRlKCdtYXNrJykudmFsdWUgPSBtYXNrOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgICAgICAvLyBOTyBSRU5ERVJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5tYXNrLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIGNsaXAgZWxlbWVudFxuICAgICAgICBzdmcuRWxlbWVudC5jbGlwUGF0aCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICAgICAgdGhpcy5iYXNlKG5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEJlZ2luUGF0aCA9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuYmVnaW5QYXRoO1xuICAgICAgICAgICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuYmVnaW5QYXRoID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBvbGRDbG9zZVBhdGggPSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmNsb3NlUGF0aDtcbiAgICAgICAgICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG9sZEJlZ2luUGF0aC5jYWxsKGN0eCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjaGlsZC5wYXRoKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuYXR0cmlidXRlKCd0cmFuc2Zvcm0nKS5oYXNWYWx1ZSgpKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybSA9IG5ldyBzdmcuVHJhbnNmb3JtKGNoaWxkLmF0dHJpYnV0ZSgndHJhbnNmb3JtJykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5hcHBseShjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQucGF0aChjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5jbG9zZVBhdGggPSBvbGRDbG9zZVBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7IHRyYW5zZm9ybS51bmFwcGx5KGN0eCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbGRDbG9zZVBhdGguY2FsbChjdHgpO1xuICAgICAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5iZWdpblBhdGggPSBvbGRCZWdpblBhdGg7XG4gICAgICAgICAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5jbG9zZVBhdGggPSBvbGRDbG9zZVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICAgICAgLy8gTk8gUkVOREVSXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuY2xpcFBhdGgucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuXG4gICAgICAgIC8vIGZpbHRlcnNcbiAgICAgICAgc3ZnLkVsZW1lbnQuZmlsdGVyID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgYXMgdGVtcCBzdmcgICBcbiAgICAgICAgICAgICAgICB2YXIgYmIgPSBlbGVtZW50LmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKGJiLngxKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IoYmIueTEpO1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IE1hdGguZmxvb3IoYmIud2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IE1hdGguZmxvb3IoYmIuaGVpZ2h0KCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gdGVtcG9yYXJpbHkgcmVtb3ZlIGZpbHRlciB0byBhdm9pZCByZWN1cnNpb25cbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gZWxlbWVudC5zdHlsZSgnZmlsdGVyJykudmFsdWU7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZSgnZmlsdGVyJykudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgcHggPSAwLCBweSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVmZCA9IHRoaXMuY2hpbGRyZW5baV0uZXh0cmFGaWx0ZXJEaXN0YW5jZSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBweCA9IE1hdGgubWF4KHB4LCBlZmQpO1xuICAgICAgICAgICAgICAgICAgICBweSA9IE1hdGgubWF4KHB5LCBlZmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIGMud2lkdGggPSB3aWR0aCArIDIqcHg7XG4gICAgICAgICAgICAgICAgYy5oZWlnaHQgPSBoZWlnaHQgKyAyKnB5O1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wQ3R4ID0gYy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIHRlbXBDdHgudHJhbnNsYXRlKC14ICsgcHgsIC15ICsgcHkpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVuZGVyKHRlbXBDdHgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgZmlsdGVyc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uYXBwbHkodGVtcEN0eCwgMCwgMCwgd2lkdGggKyAyKnB4LCBoZWlnaHQgKyAyKnB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIG9uIG1lXG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShjLCAwLCAwLCB3aWR0aCArIDIqcHgsIGhlaWdodCArIDIqcHksIHggLSBweCwgeSAtIHB5LCB3aWR0aCArIDIqcHgsIGhlaWdodCArIDIqcHkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIHJlYXNzaWduIGZpbHRlclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUoJ2ZpbHRlcicsIHRydWUpLnZhbHVlID0gZmlsdGVyOyAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgICAgIC8vIE5PIFJFTkRFUlxuICAgICAgICAgICAgfSAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5maWx0ZXIucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgc3ZnLkVsZW1lbnQuZmVNb3JwaG9sb2d5ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuYXBwbHkgPSBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5mZU1vcnBob2xvZ3kucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgc3ZnLkVsZW1lbnQuZmVDb21wb3NpdGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50LmZlQ29tcG9zaXRlLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIHN2Zy5FbGVtZW50LmZlQ29sb3JNYXRyaXggPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZShub2RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHN2Zy5Ub051bWJlckFycmF5KHRoaXMuYXR0cmlidXRlKCd2YWx1ZXMnKS52YWx1ZSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuYXR0cmlidXRlKCd0eXBlJykudmFsdWVPckRlZmF1bHQoJ21hdHJpeCcpKSB7IC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9maWx0ZXJzLmh0bWwjZmVDb2xvck1hdHJpeEVsZW1lbnRcbiAgICAgICAgICAgICAgICBjYXNlICdzYXR1cmF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gbWF0cml4WzBdO1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXggPSBbMC4yMTMrMC43ODcqcywwLjcxNS0wLjcxNSpzLDAuMDcyLTAuMDcyKnMsMCwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4yMTMtMC4yMTMqcywwLjcxNSswLjI4NSpzLDAuMDcyLTAuMDcyKnMsMCwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4yMTMtMC4yMTMqcywwLjcxNS0wLjcxNSpzLDAuMDcyKzAuOTI4KnMsMCwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwwLDAsMSwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwwLDAsMCwxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaHVlUm90YXRlJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBtYXRyaXhbMF0gKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gZnVuY3Rpb24gKG0xLG0yLG0zKSB7IHJldHVybiBtMSArIE1hdGguY29zKGEpKm0yICsgTWF0aC5zaW4oYSkqbTM7IH07XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCA9IFtjKDAuMjEzLDAuNzg3LC0wLjIxMyksYygwLjcxNSwtMC43MTUsLTAuNzE1KSxjKDAuMDcyLC0wLjA3MiwwLjkyOCksMCwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYygwLjIxMywtMC4yMTMsMC4xNDMpLGMoMC43MTUsMC4yODUsMC4xNDApLGMoMC4wNzIsLTAuMDcyLC0wLjI4MyksMCwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYygwLjIxMywtMC4yMTMsLTAuNzg3KSxjKDAuNzE1LC0wLjcxNSwwLjcxNSksYygwLjA3MiwwLjkyOCwwLjA3MiksMCwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwwLDAsMSwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwwLDAsMCwxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbHVtaW5hbmNlVG9BbHBoYSc6XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCA9IFswLDAsMCwwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMCwwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMCwwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjIxMjUsMC43MTU0LDAuMDcyMSwwLDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLDAsMCwwLDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gaW1HZXQoaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZ2JhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltZ1t5KndpZHRoKjQgKyB4KjQgKyByZ2JhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gaW1TZXQoaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZ2JhLCB2YWwpIHtcbiAgICAgICAgICAgICAgICBpbWdbeSp3aWR0aCo0ICsgeCo0ICsgcmdiYV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZ1bmN0aW9uIG0oaSwgdikge1xuICAgICAgICAgICAgICAgIHZhciBtaSA9IG1hdHJpeFtpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWkgKiAobWkgPCAwID8gdiAtIDI1NSA6IHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gYXNzdW1pbmcgeD09MCAmJiB5PT0wIGZvciBub3dcbiAgICAgICAgICAgICAgICB2YXIgc3JjRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgbSgwLHIpK20oMSxnKSttKDIsYikrbSgzLGEpK20oNCwxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEsIG0oNSxyKSttKDYsZykrbSg3LGIpK20oOCxhKSttKDksMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAyLCBtKDEwLHIpK20oMTEsZykrbSgxMixiKSttKDEzLGEpK20oMTQsMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAzLCBtKDE1LHIpK20oMTYsZykrbSgxNyxiKSttKDE4LGEpK20oMTksMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnB1dEltYWdlRGF0YShzcmNEYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC5mZUNvbG9yTWF0cml4LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcbiAgICAgICAgXG4gICAgICAgIHN2Zy5FbGVtZW50LmZlR2F1c3NpYW5CbHVyID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG4gICAgICAgICAgICB0aGlzLmJhc2Uobm9kZSk7XG5cbiAgICAgICAgICAgIHRoaXMuYmx1clJhZGl1cyA9IE1hdGguZmxvb3IodGhpcy5hdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicpLm51bVZhbHVlKCkpO1xuICAgICAgICAgICAgdGhpcy5leHRyYUZpbHRlckRpc3RhbmNlID0gdGhpcy5ibHVyUmFkaXVzO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzdGFja0JsdXJDYW52YXNSR0JBKSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBzdmcubG9nKCdFUlJPUjogU3RhY2tCbHVyLmpzIG11c3QgYmUgaW5jbHVkZWQgZm9yIGJsdXIgdG8gd29yaycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFN0YWNrQmx1ciByZXF1aXJlcyBjYW52YXMgYmUgb24gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICBjdHguY2FudmFzLmlkID0gc3ZnLlVuaXF1ZUlkKCk7XG4gICAgICAgICAgICAgICAgY3R4LmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY3R4LmNhbnZhcyk7XG4gICAgICAgICAgICAgICAgc3RhY2tCbHVyQ2FudmFzUkdCQShjdHguY2FudmFzLmlkLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0aGlzLmJsdXJSYWRpdXMpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY3R4LmNhbnZhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuZmVHYXVzc2lhbkJsdXIucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gdGl0bGUgZWxlbWVudCwgZG8gbm90aGluZ1xuICAgICAgICBzdmcuRWxlbWVudC50aXRsZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgfVxuICAgICAgICBzdmcuRWxlbWVudC50aXRsZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XG5cbiAgICAgICAgLy8gZGVzYyBlbGVtZW50LCBkbyBub3RoaW5nXG4gICAgICAgIHN2Zy5FbGVtZW50LmRlc2MgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLkVsZW1lbnQuZGVzYy5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7ICAgICAgIFxuICAgICAgICBcbiAgICAgICAgc3ZnLkVsZW1lbnQuTUlTU0lORyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHN2Zy5sb2coJ0VSUk9SOiBFbGVtZW50IFxcJycgKyBub2RlLm5vZGVOYW1lICsgJ1xcJyBub3QgeWV0IGltcGxlbWVudGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5FbGVtZW50Lk1JU1NJTkcucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xuICAgICAgICBcbiAgICAgICAgLy8gZWxlbWVudCBmYWN0b3J5XG4gICAgICAgIHN2Zy5DcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkgeyAgICBcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBub2RlLm5vZGVOYW1lLnJlcGxhY2UoL15bXjpdKzovLCcnKTsgLy8gcmVtb3ZlIG5hbWVzcGFjZVxuICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLnJlcGxhY2UoL1xcLS9nLCcnKTsgLy8gcmVtb3ZlIGRhc2hlc1xuICAgICAgICAgICAgdmFyIGUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihzdmcuRWxlbWVudFtjbGFzc05hbWVdKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGUgPSBuZXcgc3ZnLkVsZW1lbnRbY2xhc3NOYW1lXShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGUgPSBuZXcgc3ZnLkVsZW1lbnQuTUlTU0lORyhub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS50eXBlID0gbm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIC8vIGxvYWQgZnJvbSB1cmxcbiAgICAgICAgc3ZnLmxvYWQgPSBmdW5jdGlvbihjdHgsIHVybCkge1xuICAgICAgICAgICAgc3ZnLmxvYWRYbWwoY3R4LCBzdmcuYWpheCh1cmwpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gbG9hZCBmcm9tIHhtbFxuICAgICAgICBzdmcubG9hZFhtbCA9IGZ1bmN0aW9uKGN0eCwgeG1sKSB7XG4gICAgICAgICAgICBzdmcubG9hZFhtbERvYyhjdHgsIHN2Zy5wYXJzZVhtbCh4bWwpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3ZnLmxvYWRYbWxEb2MgPSBmdW5jdGlvbihjdHgsIGRvbSkge1xuICAgICAgICAgICAgc3ZnLmluaXQoY3R4KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG1hcFhZID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gY3R4LmNhbnZhcztcbiAgICAgICAgICAgICAgICB3aGlsZSAoZSkge1xuICAgICAgICAgICAgICAgICAgICBwLnggLT0gZS5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICBwLnkgLT0gZS5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBlLm9mZnNldFBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5zY3JvbGxYKSBwLnggKz0gd2luZG93LnNjcm9sbFg7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5zY3JvbGxZKSBwLnkgKz0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGJpbmQgbW91c2VcbiAgICAgICAgICAgIGlmIChzdmcub3B0c1snaWdub3JlTW91c2UnXSAhPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY3R4LmNhbnZhcy5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG1hcFhZKG5ldyBzdmcuUG9pbnQoZSAhPSBudWxsID8gZS5jbGllbnRYIDogZXZlbnQuY2xpZW50WCwgZSAhPSBudWxsID8gZS5jbGllbnRZIDogZXZlbnQuY2xpZW50WSkpO1xuICAgICAgICAgICAgICAgICAgICBzdmcuTW91c2Uub25jbGljayhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjdHguY2FudmFzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG1hcFhZKG5ldyBzdmcuUG9pbnQoZSAhPSBudWxsID8gZS5jbGllbnRYIDogZXZlbnQuY2xpZW50WCwgZSAhPSBudWxsID8gZS5jbGllbnRZIDogZXZlbnQuY2xpZW50WSkpO1xuICAgICAgICAgICAgICAgICAgICBzdmcuTW91c2Uub25tb3VzZW1vdmUocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIGUgPSBzdmcuQ3JlYXRlRWxlbWVudChkb20uZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgICAgICAgIGUucm9vdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gcmVuZGVyIGxvb3BcbiAgICAgICAgICAgIHZhciBpc0ZpcnN0UmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBkcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3ZnLlZpZXdQb3J0LkNsZWFyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5jYW52YXMucGFyZW50Tm9kZSkgc3ZnLlZpZXdQb3J0LlNldEN1cnJlbnQoY3R4LmNhbnZhcy5wYXJlbnROb2RlLmNsaWVudFdpZHRoLCBjdHguY2FudmFzLnBhcmVudE5vZGUuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChzdmcub3B0c1snaWdub3JlRGltZW5zaW9ucyddICE9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGNhbnZhcyBzaXplXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnN0eWxlKCd3aWR0aCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jYW52YXMud2lkdGggPSBlLnN0eWxlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2FudmFzLnN0eWxlLndpZHRoID0gY3R4LmNhbnZhcy53aWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuc3R5bGUoJ2hlaWdodCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jYW52YXMuaGVpZ2h0ID0gZS5zdHlsZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gY3R4LmNhbnZhcy5oZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjV2lkdGggPSBjdHguY2FudmFzLmNsaWVudFdpZHRoIHx8IGN0eC5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGNIZWlnaHQgPSBjdHguY2FudmFzLmNsaWVudEhlaWdodCB8fCBjdHguY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoc3ZnLm9wdHNbJ2lnbm9yZURpbWVuc2lvbnMnXSA9PSB0cnVlICYmIGUuc3R5bGUoJ3dpZHRoJykuaGFzVmFsdWUoKSAmJiBlLnN0eWxlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNXaWR0aCA9IGUuc3R5bGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgY0hlaWdodCA9IGUuc3R5bGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN2Zy5WaWV3UG9ydC5TZXRDdXJyZW50KGNXaWR0aCwgY0hlaWdodCk7ICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChzdmcub3B0c1snb2Zmc2V0WCddICE9IG51bGwpIGUuYXR0cmlidXRlKCd4JywgdHJ1ZSkudmFsdWUgPSBzdmcub3B0c1snb2Zmc2V0WCddO1xuICAgICAgICAgICAgICAgIGlmIChzdmcub3B0c1snb2Zmc2V0WSddICE9IG51bGwpIGUuYXR0cmlidXRlKCd5JywgdHJ1ZSkudmFsdWUgPSBzdmcub3B0c1snb2Zmc2V0WSddO1xuICAgICAgICAgICAgICAgIGlmIChzdmcub3B0c1snc2NhbGVXaWR0aCddICE9IG51bGwgfHwgc3ZnLm9wdHNbJ3NjYWxlSGVpZ2h0J10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJhdGlvID0gbnVsbCwgeVJhdGlvID0gbnVsbCwgdmlld0JveCA9IHN2Zy5Ub051bWJlckFycmF5KGUuYXR0cmlidXRlKCd2aWV3Qm94JykudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydzY2FsZVdpZHRoJ10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuYXR0cmlidXRlKCd3aWR0aCcpLmhhc1ZhbHVlKCkpIHhSYXRpbyA9IGUuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4JykgLyBzdmcub3B0c1snc2NhbGVXaWR0aCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzTmFOKHZpZXdCb3hbMl0pKSB4UmF0aW8gPSB2aWV3Qm94WzJdIC8gc3ZnLm9wdHNbJ3NjYWxlV2lkdGgnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydzY2FsZUhlaWdodCddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmF0dHJpYnV0ZSgnaGVpZ2h0JykuaGFzVmFsdWUoKSkgeVJhdGlvID0gZS5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5JykgLyBzdmcub3B0c1snc2NhbGVIZWlnaHQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc05hTih2aWV3Qm94WzNdKSkgeVJhdGlvID0gdmlld0JveFszXSAvIHN2Zy5vcHRzWydzY2FsZUhlaWdodCddO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhSYXRpbyA9PSBudWxsKSB7IHhSYXRpbyA9IHlSYXRpbzsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoeVJhdGlvID09IG51bGwpIHsgeVJhdGlvID0geFJhdGlvOyB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBlLmF0dHJpYnV0ZSgnd2lkdGgnLCB0cnVlKS52YWx1ZSA9IHN2Zy5vcHRzWydzY2FsZVdpZHRoJ107XG4gICAgICAgICAgICAgICAgICAgIGUuYXR0cmlidXRlKCdoZWlnaHQnLCB0cnVlKS52YWx1ZSA9IHN2Zy5vcHRzWydzY2FsZUhlaWdodCddO1xuICAgICAgICAgICAgICAgICAgICBlLmF0dHJpYnV0ZSgndHJhbnNmb3JtJywgdHJ1ZSkudmFsdWUgKz0gJyBzY2FsZSgnKygxLjAveFJhdGlvKSsnLCcrKDEuMC95UmF0aW8pKycpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBhbmQgcmVuZGVyXG4gICAgICAgICAgICAgICAgaWYgKHN2Zy5vcHRzWydpZ25vcmVDbGVhciddICE9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjV2lkdGgsIGNIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLnJlbmRlcihjdHgpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0UmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3RSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzdmcub3B0c1sncmVuZGVyQ2FsbGJhY2snXSkgPT0gJ2Z1bmN0aW9uJykgc3ZnLm9wdHNbJ3JlbmRlckNhbGxiYWNrJ10oZG9tKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHdhaXRpbmdGb3JJbWFnZXMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHN2Zy5JbWFnZXNMb2FkZWQoKSkge1xuICAgICAgICAgICAgICAgIHdhaXRpbmdGb3JJbWFnZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdmcuaW50ZXJ2YWxJRCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgICAgICB2YXIgbmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nRm9ySW1hZ2VzICYmIHN2Zy5JbWFnZXNMb2FkZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB3YWl0aW5nRm9ySW1hZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdXBkYXRlIGZyb20gbW91c2UgZXZlbnRzP1xuICAgICAgICAgICAgICAgIGlmIChzdmcub3B0c1snaWdub3JlTW91c2UnXSAhPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRVcGRhdGUgPSBuZWVkVXBkYXRlIHwgc3ZnLk1vdXNlLmhhc0V2ZW50cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdXBkYXRlIGZyb20gYW5pbWF0aW9ucz9cbiAgICAgICAgICAgICAgICBpZiAoc3ZnLm9wdHNbJ2lnbm9yZUFuaW1hdGlvbiddICE9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHN2Zy5BbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkVXBkYXRlID0gbmVlZFVwZGF0ZSB8IHN2Zy5BbmltYXRpb25zW2ldLnVwZGF0ZSgxMDAwIC8gc3ZnLkZSQU1FUkFURSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB1cGRhdGUgZnJvbSByZWRyYXc/XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzdmcub3B0c1snZm9yY2VSZWRyYXcnXSkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ZnLm9wdHNbJ2ZvcmNlUmVkcmF3J10oKSA9PSB0cnVlKSBuZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChuZWVkVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXcoKTsgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHN2Zy5Nb3VzZS5ydW5FdmVudHMoKTsgLy8gcnVuIGFuZCBjbGVhciBvdXIgZXZlbnRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCAvIHN2Zy5GUkFNRVJBVEUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzdmcuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHN2Zy5pbnRlcnZhbElEKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzdmcuaW50ZXJ2YWxJRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN2Zy5Nb3VzZSA9IG5ldyAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5oYXNFdmVudHMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZXZlbnRzLmxlbmd0aCAhPSAwOyB9XG4gICAgICAgIFxuICAgICAgICAgICAgdGhpcy5vbmNsaWNrID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goeyB0eXBlOiAnb25jbGljaycsIHg6IHgsIHk6IHksIFxuICAgICAgICAgICAgICAgICAgICBydW46IGZ1bmN0aW9uKGUpIHsgaWYgKGUub25jbGljaykgZS5vbmNsaWNrKCk7IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHsgdHlwZTogJ29ubW91c2Vtb3ZlJywgeDogeCwgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgcnVuOiBmdW5jdGlvbihlKSB7IGlmIChlLm9ubW91c2Vtb3ZlKSBlLm9ubW91c2Vtb3ZlKCk7IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jaGVja1BhdGggPSBmdW5jdGlvbihlbGVtZW50LCBjdHgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eC5pc1BvaW50SW5QYXRoICYmIGN0eC5pc1BvaW50SW5QYXRoKGUueCwgZS55KSkgdGhpcy5ldmVudEVsZW1lbnRzW2ldID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY2hlY2tCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGJiKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5ldmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYi5pc1BvaW50SW5Cb3goZS54LCBlLnkpKSB0aGlzLmV2ZW50RWxlbWVudHNbaV0gPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnJ1bkV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHN2Zy5jdHguY2FudmFzLnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZXZlbnRFbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucnVuKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGRvbmUgcnVubmluZywgY2xlYXJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cyA9IFtdOyBcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc3ZnO1xuICAgIH1cbn0pKCk7XG5cbmlmICh0eXBlb2YoQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSAhPSAndW5kZWZpbmVkJykge1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZHJhd1N2ZyA9IGZ1bmN0aW9uKHMsIGR4LCBkeSwgZHcsIGRoKSB7XG4gICAgICAgIGNhbnZnKHRoaXMuY2FudmFzLCBzLCB7IFxuICAgICAgICAgICAgaWdub3JlTW91c2U6IHRydWUsIFxuICAgICAgICAgICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLCBcbiAgICAgICAgICAgIGlnbm9yZURpbWVuc2lvbnM6IHRydWUsIFxuICAgICAgICAgICAgaWdub3JlQ2xlYXI6IHRydWUsIFxuICAgICAgICAgICAgb2Zmc2V0WDogZHgsIFxuICAgICAgICAgICAgb2Zmc2V0WTogZHksIFxuICAgICAgICAgICAgc2NhbGVXaWR0aDogZHcsIFxuICAgICAgICAgICAgc2NhbGVIZWlnaHQ6IGRoXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIi8vIGRlcGVuZGVuY3kgZm9yIGNhbnZnXG4vKipcbiAqIEEgY2xhc3MgdG8gcGFyc2UgY29sb3IgdmFsdWVzXG4gKiBAYXV0aG9yIFN0b3lhbiBTdGVmYW5vdiA8c3N0b29AZ21haWwuY29tPlxuICogQGxpbmsgICBodHRwOi8vd3d3LnBocGllZC5jb20vcmdiLWNvbG9yLXBhcnNlci1pbi1qYXZhc2NyaXB0L1xuICogQGxpY2Vuc2UgVXNlIGl0IGlmIHlvdSBsaWtlIGl0XG4gKi9cbmZ1bmN0aW9uIFJHQkNvbG9yKGNvbG9yX3N0cmluZylcbntcbiAgICB0aGlzLm9rID0gZmFsc2U7XG5cbiAgICAvLyBzdHJpcCBhbnkgbGVhZGluZyAjXG4gICAgaWYgKGNvbG9yX3N0cmluZy5jaGFyQXQoMCkgPT0gJyMnKSB7IC8vIHJlbW92ZSAjIGlmIGFueVxuICAgICAgICBjb2xvcl9zdHJpbmcgPSBjb2xvcl9zdHJpbmcuc3Vic3RyKDEsNik7XG4gICAgfVxuXG4gICAgY29sb3Jfc3RyaW5nID0gY29sb3Jfc3RyaW5nLnJlcGxhY2UoLyAvZywnJyk7XG4gICAgY29sb3Jfc3RyaW5nID0gY29sb3Jfc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBiZWZvcmUgZ2V0dGluZyBpbnRvIHJlZ2V4cHMsIHRyeSBzaW1wbGUgbWF0Y2hlc1xuICAgIC8vIGFuZCBvdmVyd3JpdGUgdGhlIGlucHV0XG4gICAgdmFyIHNpbXBsZV9jb2xvcnMgPSB7XG4gICAgICAgIGFsaWNlYmx1ZTogJ2YwZjhmZicsXG4gICAgICAgIGFudGlxdWV3aGl0ZTogJ2ZhZWJkNycsXG4gICAgICAgIGFxdWE6ICcwMGZmZmYnLFxuICAgICAgICBhcXVhbWFyaW5lOiAnN2ZmZmQ0JyxcbiAgICAgICAgYXp1cmU6ICdmMGZmZmYnLFxuICAgICAgICBiZWlnZTogJ2Y1ZjVkYycsXG4gICAgICAgIGJpc3F1ZTogJ2ZmZTRjNCcsXG4gICAgICAgIGJsYWNrOiAnMDAwMDAwJyxcbiAgICAgICAgYmxhbmNoZWRhbG1vbmQ6ICdmZmViY2QnLFxuICAgICAgICBibHVlOiAnMDAwMGZmJyxcbiAgICAgICAgYmx1ZXZpb2xldDogJzhhMmJlMicsXG4gICAgICAgIGJyb3duOiAnYTUyYTJhJyxcbiAgICAgICAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgICAgICAgY2FkZXRibHVlOiAnNWY5ZWEwJyxcbiAgICAgICAgY2hhcnRyZXVzZTogJzdmZmYwMCcsXG4gICAgICAgIGNob2NvbGF0ZTogJ2QyNjkxZScsXG4gICAgICAgIGNvcmFsOiAnZmY3ZjUwJyxcbiAgICAgICAgY29ybmZsb3dlcmJsdWU6ICc2NDk1ZWQnLFxuICAgICAgICBjb3Juc2lsazogJ2ZmZjhkYycsXG4gICAgICAgIGNyaW1zb246ICdkYzE0M2MnLFxuICAgICAgICBjeWFuOiAnMDBmZmZmJyxcbiAgICAgICAgZGFya2JsdWU6ICcwMDAwOGInLFxuICAgICAgICBkYXJrY3lhbjogJzAwOGI4YicsXG4gICAgICAgIGRhcmtnb2xkZW5yb2Q6ICdiODg2MGInLFxuICAgICAgICBkYXJrZ3JheTogJ2E5YTlhOScsXG4gICAgICAgIGRhcmtncmVlbjogJzAwNjQwMCcsXG4gICAgICAgIGRhcmtraGFraTogJ2JkYjc2YicsXG4gICAgICAgIGRhcmttYWdlbnRhOiAnOGIwMDhiJyxcbiAgICAgICAgZGFya29saXZlZ3JlZW46ICc1NTZiMmYnLFxuICAgICAgICBkYXJrb3JhbmdlOiAnZmY4YzAwJyxcbiAgICAgICAgZGFya29yY2hpZDogJzk5MzJjYycsXG4gICAgICAgIGRhcmtyZWQ6ICc4YjAwMDAnLFxuICAgICAgICBkYXJrc2FsbW9uOiAnZTk5NjdhJyxcbiAgICAgICAgZGFya3NlYWdyZWVuOiAnOGZiYzhmJyxcbiAgICAgICAgZGFya3NsYXRlYmx1ZTogJzQ4M2Q4YicsXG4gICAgICAgIGRhcmtzbGF0ZWdyYXk6ICcyZjRmNGYnLFxuICAgICAgICBkYXJrdHVycXVvaXNlOiAnMDBjZWQxJyxcbiAgICAgICAgZGFya3Zpb2xldDogJzk0MDBkMycsXG4gICAgICAgIGRlZXBwaW5rOiAnZmYxNDkzJyxcbiAgICAgICAgZGVlcHNreWJsdWU6ICcwMGJmZmYnLFxuICAgICAgICBkaW1ncmF5OiAnNjk2OTY5JyxcbiAgICAgICAgZG9kZ2VyYmx1ZTogJzFlOTBmZicsXG4gICAgICAgIGZlbGRzcGFyOiAnZDE5Mjc1JyxcbiAgICAgICAgZmlyZWJyaWNrOiAnYjIyMjIyJyxcbiAgICAgICAgZmxvcmFsd2hpdGU6ICdmZmZhZjAnLFxuICAgICAgICBmb3Jlc3RncmVlbjogJzIyOGIyMicsXG4gICAgICAgIGZ1Y2hzaWE6ICdmZjAwZmYnLFxuICAgICAgICBnYWluc2Jvcm86ICdkY2RjZGMnLFxuICAgICAgICBnaG9zdHdoaXRlOiAnZjhmOGZmJyxcbiAgICAgICAgZ29sZDogJ2ZmZDcwMCcsXG4gICAgICAgIGdvbGRlbnJvZDogJ2RhYTUyMCcsXG4gICAgICAgIGdyYXk6ICc4MDgwODAnLFxuICAgICAgICBncmVlbjogJzAwODAwMCcsXG4gICAgICAgIGdyZWVueWVsbG93OiAnYWRmZjJmJyxcbiAgICAgICAgaG9uZXlkZXc6ICdmMGZmZjAnLFxuICAgICAgICBob3RwaW5rOiAnZmY2OWI0JyxcbiAgICAgICAgaW5kaWFucmVkIDogJ2NkNWM1YycsXG4gICAgICAgIGluZGlnbyA6ICc0YjAwODInLFxuICAgICAgICBpdm9yeTogJ2ZmZmZmMCcsXG4gICAgICAgIGtoYWtpOiAnZjBlNjhjJyxcbiAgICAgICAgbGF2ZW5kZXI6ICdlNmU2ZmEnLFxuICAgICAgICBsYXZlbmRlcmJsdXNoOiAnZmZmMGY1JyxcbiAgICAgICAgbGF3bmdyZWVuOiAnN2NmYzAwJyxcbiAgICAgICAgbGVtb25jaGlmZm9uOiAnZmZmYWNkJyxcbiAgICAgICAgbGlnaHRibHVlOiAnYWRkOGU2JyxcbiAgICAgICAgbGlnaHRjb3JhbDogJ2YwODA4MCcsXG4gICAgICAgIGxpZ2h0Y3lhbjogJ2UwZmZmZicsXG4gICAgICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnZmFmYWQyJyxcbiAgICAgICAgbGlnaHRncmV5OiAnZDNkM2QzJyxcbiAgICAgICAgbGlnaHRncmVlbjogJzkwZWU5MCcsXG4gICAgICAgIGxpZ2h0cGluazogJ2ZmYjZjMScsXG4gICAgICAgIGxpZ2h0c2FsbW9uOiAnZmZhMDdhJyxcbiAgICAgICAgbGlnaHRzZWFncmVlbjogJzIwYjJhYScsXG4gICAgICAgIGxpZ2h0c2t5Ymx1ZTogJzg3Y2VmYScsXG4gICAgICAgIGxpZ2h0c2xhdGVibHVlOiAnODQ3MGZmJyxcbiAgICAgICAgbGlnaHRzbGF0ZWdyYXk6ICc3Nzg4OTknLFxuICAgICAgICBsaWdodHN0ZWVsYmx1ZTogJ2IwYzRkZScsXG4gICAgICAgIGxpZ2h0eWVsbG93OiAnZmZmZmUwJyxcbiAgICAgICAgbGltZTogJzAwZmYwMCcsXG4gICAgICAgIGxpbWVncmVlbjogJzMyY2QzMicsXG4gICAgICAgIGxpbmVuOiAnZmFmMGU2JyxcbiAgICAgICAgbWFnZW50YTogJ2ZmMDBmZicsXG4gICAgICAgIG1hcm9vbjogJzgwMDAwMCcsXG4gICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6ICc2NmNkYWEnLFxuICAgICAgICBtZWRpdW1ibHVlOiAnMDAwMGNkJyxcbiAgICAgICAgbWVkaXVtb3JjaGlkOiAnYmE1NWQzJyxcbiAgICAgICAgbWVkaXVtcHVycGxlOiAnOTM3MGQ4JyxcbiAgICAgICAgbWVkaXVtc2VhZ3JlZW46ICczY2IzNzEnLFxuICAgICAgICBtZWRpdW1zbGF0ZWJsdWU6ICc3YjY4ZWUnLFxuICAgICAgICBtZWRpdW1zcHJpbmdncmVlbjogJzAwZmE5YScsXG4gICAgICAgIG1lZGl1bXR1cnF1b2lzZTogJzQ4ZDFjYycsXG4gICAgICAgIG1lZGl1bXZpb2xldHJlZDogJ2M3MTU4NScsXG4gICAgICAgIG1pZG5pZ2h0Ymx1ZTogJzE5MTk3MCcsXG4gICAgICAgIG1pbnRjcmVhbTogJ2Y1ZmZmYScsXG4gICAgICAgIG1pc3R5cm9zZTogJ2ZmZTRlMScsXG4gICAgICAgIG1vY2Nhc2luOiAnZmZlNGI1JyxcbiAgICAgICAgbmF2YWpvd2hpdGU6ICdmZmRlYWQnLFxuICAgICAgICBuYXZ5OiAnMDAwMDgwJyxcbiAgICAgICAgb2xkbGFjZTogJ2ZkZjVlNicsXG4gICAgICAgIG9saXZlOiAnODA4MDAwJyxcbiAgICAgICAgb2xpdmVkcmFiOiAnNmI4ZTIzJyxcbiAgICAgICAgb3JhbmdlOiAnZmZhNTAwJyxcbiAgICAgICAgb3JhbmdlcmVkOiAnZmY0NTAwJyxcbiAgICAgICAgb3JjaGlkOiAnZGE3MGQ2JyxcbiAgICAgICAgcGFsZWdvbGRlbnJvZDogJ2VlZThhYScsXG4gICAgICAgIHBhbGVncmVlbjogJzk4ZmI5OCcsXG4gICAgICAgIHBhbGV0dXJxdW9pc2U6ICdhZmVlZWUnLFxuICAgICAgICBwYWxldmlvbGV0cmVkOiAnZDg3MDkzJyxcbiAgICAgICAgcGFwYXlhd2hpcDogJ2ZmZWZkNScsXG4gICAgICAgIHBlYWNocHVmZjogJ2ZmZGFiOScsXG4gICAgICAgIHBlcnU6ICdjZDg1M2YnLFxuICAgICAgICBwaW5rOiAnZmZjMGNiJyxcbiAgICAgICAgcGx1bTogJ2RkYTBkZCcsXG4gICAgICAgIHBvd2RlcmJsdWU6ICdiMGUwZTYnLFxuICAgICAgICBwdXJwbGU6ICc4MDAwODAnLFxuICAgICAgICByZWQ6ICdmZjAwMDAnLFxuICAgICAgICByb3N5YnJvd246ICdiYzhmOGYnLFxuICAgICAgICByb3lhbGJsdWU6ICc0MTY5ZTEnLFxuICAgICAgICBzYWRkbGVicm93bjogJzhiNDUxMycsXG4gICAgICAgIHNhbG1vbjogJ2ZhODA3MicsXG4gICAgICAgIHNhbmR5YnJvd246ICdmNGE0NjAnLFxuICAgICAgICBzZWFncmVlbjogJzJlOGI1NycsXG4gICAgICAgIHNlYXNoZWxsOiAnZmZmNWVlJyxcbiAgICAgICAgc2llbm5hOiAnYTA1MjJkJyxcbiAgICAgICAgc2lsdmVyOiAnYzBjMGMwJyxcbiAgICAgICAgc2t5Ymx1ZTogJzg3Y2VlYicsXG4gICAgICAgIHNsYXRlYmx1ZTogJzZhNWFjZCcsXG4gICAgICAgIHNsYXRlZ3JheTogJzcwODA5MCcsXG4gICAgICAgIHNub3c6ICdmZmZhZmEnLFxuICAgICAgICBzcHJpbmdncmVlbjogJzAwZmY3ZicsXG4gICAgICAgIHN0ZWVsYmx1ZTogJzQ2ODJiNCcsXG4gICAgICAgIHRhbjogJ2QyYjQ4YycsXG4gICAgICAgIHRlYWw6ICcwMDgwODAnLFxuICAgICAgICB0aGlzdGxlOiAnZDhiZmQ4JyxcbiAgICAgICAgdG9tYXRvOiAnZmY2MzQ3JyxcbiAgICAgICAgdHVycXVvaXNlOiAnNDBlMGQwJyxcbiAgICAgICAgdmlvbGV0OiAnZWU4MmVlJyxcbiAgICAgICAgdmlvbGV0cmVkOiAnZDAyMDkwJyxcbiAgICAgICAgd2hlYXQ6ICdmNWRlYjMnLFxuICAgICAgICB3aGl0ZTogJ2ZmZmZmZicsXG4gICAgICAgIHdoaXRlc21va2U6ICdmNWY1ZjUnLFxuICAgICAgICB5ZWxsb3c6ICdmZmZmMDAnLFxuICAgICAgICB5ZWxsb3dncmVlbjogJzlhY2QzMidcbiAgICB9O1xuICAgIGZvciAodmFyIGtleSBpbiBzaW1wbGVfY29sb3JzKSB7XG4gICAgICAgIGlmIChjb2xvcl9zdHJpbmcgPT0ga2V5KSB7XG4gICAgICAgICAgICBjb2xvcl9zdHJpbmcgPSBzaW1wbGVfY29sb3JzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZW1kIG9mIHNpbXBsZSB0eXBlLWluIGNvbG9yc1xuXG4gICAgLy8gYXJyYXkgb2YgY29sb3IgZGVmaW5pdGlvbiBvYmplY3RzXG4gICAgdmFyIGNvbG9yX2RlZnMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlOiAvXnJnYlxcKChcXGR7MSwzfSksXFxzKihcXGR7MSwzfSksXFxzKihcXGR7MSwzfSlcXCkkLyxcbiAgICAgICAgICAgIGV4YW1wbGU6IFsncmdiKDEyMywgMjM0LCA0NSknLCAncmdiKDI1NSwyMzQsMjQ1KSddLFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGJpdHMpe1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMV0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1szXSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByZTogL14oXFx3ezJ9KShcXHd7Mn0pKFxcd3syfSkkLyxcbiAgICAgICAgICAgIGV4YW1wbGU6IFsnIzAwZmYwMCcsICczMzY2OTknXSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChiaXRzKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzFdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMl0sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1szXSwgMTYpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcmU6IC9eKFxcd3sxfSkoXFx3ezF9KShcXHd7MX0pJC8sXG4gICAgICAgICAgICBleGFtcGxlOiBbJyNmYjAnLCAnZjBmJ10sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoYml0cyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1sxXSArIGJpdHNbMV0sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1syXSArIGJpdHNbMl0sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1szXSArIGJpdHNbM10sIDE2KVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdO1xuXG4gICAgLy8gc2VhcmNoIHRocm91Z2ggdGhlIGRlZmluaXRpb25zIHRvIGZpbmQgYSBtYXRjaFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JfZGVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmUgPSBjb2xvcl9kZWZzW2ldLnJlO1xuICAgICAgICB2YXIgcHJvY2Vzc29yID0gY29sb3JfZGVmc1tpXS5wcm9jZXNzO1xuICAgICAgICB2YXIgYml0cyA9IHJlLmV4ZWMoY29sb3Jfc3RyaW5nKTtcbiAgICAgICAgaWYgKGJpdHMpIHtcbiAgICAgICAgICAgIGNoYW5uZWxzID0gcHJvY2Vzc29yKGJpdHMpO1xuICAgICAgICAgICAgdGhpcy5yID0gY2hhbm5lbHNbMF07XG4gICAgICAgICAgICB0aGlzLmcgPSBjaGFubmVsc1sxXTtcbiAgICAgICAgICAgIHRoaXMuYiA9IGNoYW5uZWxzWzJdO1xuICAgICAgICAgICAgdGhpcy5vayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlL2NsZWFudXAgdmFsdWVzXG4gICAgdGhpcy5yID0gKHRoaXMuciA8IDAgfHwgaXNOYU4odGhpcy5yKSkgPyAwIDogKCh0aGlzLnIgPiAyNTUpID8gMjU1IDogdGhpcy5yKTtcbiAgICB0aGlzLmcgPSAodGhpcy5nIDwgMCB8fCBpc05hTih0aGlzLmcpKSA/IDAgOiAoKHRoaXMuZyA+IDI1NSkgPyAyNTUgOiB0aGlzLmcpO1xuICAgIHRoaXMuYiA9ICh0aGlzLmIgPCAwIHx8IGlzTmFOKHRoaXMuYikpID8gMCA6ICgodGhpcy5iID4gMjU1KSA/IDI1NSA6IHRoaXMuYik7XG5cbiAgICAvLyBzb21lIGdldHRlcnNcbiAgICB0aGlzLnRvUkdCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ3JnYignICsgdGhpcy5yICsgJywgJyArIHRoaXMuZyArICcsICcgKyB0aGlzLmIgKyAnKSc7XG4gICAgfVxuICAgIHRoaXMudG9IZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5yLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdmFyIGcgPSB0aGlzLmcudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgYiA9IHRoaXMuYi50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChyLmxlbmd0aCA9PSAxKSByID0gJzAnICsgcjtcbiAgICAgICAgaWYgKGcubGVuZ3RoID09IDEpIGcgPSAnMCcgKyBnO1xuICAgICAgICBpZiAoYi5sZW5ndGggPT0gMSkgYiA9ICcwJyArIGI7XG4gICAgICAgIHJldHVybiAnIycgKyByICsgZyArIGI7XG4gICAgfVxuXG4gICAgLy8gaGVscFxuICAgIHRoaXMuZ2V0SGVscFhNTCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgZXhhbXBsZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgLy8gYWRkIHJlZ2V4cHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcl9kZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXhhbXBsZSA9IGNvbG9yX2RlZnNbaV0uZXhhbXBsZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZXhhbXBsZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGV4YW1wbGVzW2V4YW1wbGVzLmxlbmd0aF0gPSBleGFtcGxlW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0eXBlLWluIGNvbG9yc1xuICAgICAgICBmb3IgKHZhciBzYyBpbiBzaW1wbGVfY29sb3JzKSB7XG4gICAgICAgICAgICBleGFtcGxlc1tleGFtcGxlcy5sZW5ndGhdID0gc2M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgeG1sLnNldEF0dHJpYnV0ZSgnaWQnLCAncmdiY29sb3ItZXhhbXBsZXMnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGFtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdF9pdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdF9jb2xvciA9IG5ldyBSR0JDb2xvcihleGFtcGxlc1tpXSk7XG4gICAgICAgICAgICAgICAgdmFyIGV4YW1wbGVfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZXhhbXBsZV9kaXYuc3R5bGUuY3NzVGV4dCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFyZ2luOiAzcHg7ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2JvcmRlcjogMXB4IHNvbGlkIGJsYWNrOyAnXG4gICAgICAgICAgICAgICAgICAgICAgICArICdiYWNrZ3JvdW5kOicgKyBsaXN0X2NvbG9yLnRvSGV4KCkgKyAnOyAnXG4gICAgICAgICAgICAgICAgICAgICAgICArICdjb2xvcjonICsgbGlzdF9jb2xvci50b0hleCgpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGV4YW1wbGVfZGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCd0ZXN0JykpO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0X2l0ZW1fdmFsdWUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcbiAgICAgICAgICAgICAgICAgICAgJyAnICsgZXhhbXBsZXNbaV0gKyAnIC0+ICcgKyBsaXN0X2NvbG9yLnRvUkdCKCkgKyAnIC0+ICcgKyBsaXN0X2NvbG9yLnRvSGV4KClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGxpc3RfaXRlbS5hcHBlbmRDaGlsZChleGFtcGxlX2Rpdik7XG4gICAgICAgICAgICAgICAgbGlzdF9pdGVtLmFwcGVuZENoaWxkKGxpc3RfaXRlbV92YWx1ZSk7XG4gICAgICAgICAgICAgICAgeG1sLmFwcGVuZENoaWxkKGxpc3RfaXRlbSk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2goZSl7fVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4bWw7XG5cbiAgICB9XG5cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJHQkNvbG9yO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbl8ubWl4aW4oe1xuICB0cmFuc3Bvc2U6IGZ1bmN0aW9uKGFycnMpIHtcbiAgICByZXR1cm4gXy56aXAuYXBwbHkoXywgYXJycyk7XG4gIH1cbn0pO1xuIiwiLy8gaG9wZWZ1bGx5IG5vdCB0aGF0IHVnbHksIGJ1dCBzZWVtZWQgYXMgZ29vZCBhIHBsYWNlIGFzIGFueSBmb3IgdGhpcyBzdHVmZi4uLlxuXG52YXIgZDMgPSByZXF1aXJlKCdkMycpO1xuXG5cbnZhciBmb3JtYXRLTUIgPSBmdW5jdGlvbihwcmVjaXNpb24sIGRlY2ltYWxTZXBhcmF0b3IpIHtcbiAgdmFyIGFwcCA9IHdpbmRvdy5hcHA7XG4gIHZhciBmb3JtYXRTSSA9IGQzLmZvcm1hdCgnLicgKyAocHJlY2lzaW9uIHx8IDMpICsgJ3MnKTtcbiAgZGVjaW1hbFNlcGFyYXRvciA9IGRlY2ltYWxTZXBhcmF0b3IgfHwgJy4nO1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0U0kodmFsdWUpXG4gICAgICAucmVwbGFjZSgnaycsIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtdGhvdXNhbmQnKSlcbiAgICAgIC5yZXBsYWNlKCdNJywgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC1taWxsaW9uJykpXG4gICAgICAucmVwbGFjZSgnRycsIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtYmlsbGlvbicpKSAgLy8gbm93IGp1c3QgbmVlZCB0byBjb252ZXJ0IEcgR2lnaWEgLT4gQiBCaWxsaW9uXG4gICAgICAucmVwbGFjZSgnVCcsIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtdHJpbGxpb24nKSlcbiAgICAgIC5yZXBsYWNlKCdQJywgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC1wZXRhJykpXG4gICAgICAucmVwbGFjZSgnRScsIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtZXhhJykpXG4gICAgICAucmVwbGFjZSgnLicsIGRlY2ltYWxTZXBhcmF0b3IpO1xuICB9O1xufTtcblxudmFyIHRyYW5zbGF0ZUxhbmd1YWdlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGFwcCA9IHdpbmRvdy5hcHA7XG4gIHJldHVybiB2YWx1ZVxuICAgIC5yZXBsYWNlKCdrJywgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC10aG91c2FuZCcpKVxuICAgIC5yZXBsYWNlKCdNJywgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC1taWxsaW9uJykpXG4gICAgLnJlcGxhY2UoJ0InLCBhcHAudHJhbnNsYXRvci50cmFuc2xhdGVTeW5jKCdhbXAuZGFzaGJvYXJkOmNoYXJ0LWJpbGxpb24nKSlcbiAgICAucmVwbGFjZSgnVCcsIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtdHJpbGxpb24nKSlcbiAgICAucmVwbGFjZSgnUCcsIGFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZVN5bmMoJ2FtcC5kYXNoYm9hcmQ6Y2hhcnQtcGV0YScpKVxuICAgIC5yZXBsYWNlKCdFJywgYXBwLnRyYW5zbGF0b3IudHJhbnNsYXRlU3luYygnYW1wLmRhc2hib2FyZDpjaGFydC1leGEnKSk7XG59O1xuXG52YXIgZm9ybWF0U2hvcnRUZXh0ID0gZnVuY3Rpb24obWF4V2lkdGgpIHtcbiAgdmFyIGVsbGlwc2VXaWR0aCA9IDE7XG4gIHJldHVybiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgaWYgKHRleHQubGVuZ3RoIC0gZWxsaXBzZVdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIG1heFdpZHRoIC0gZWxsaXBzZVdpZHRoKSArICcuLi4nO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn07XG5cblxudmFyIGNhdGVnb3J5Q29sb3VycyA9IGZ1bmN0aW9uKGNhdHMpIHtcbiAgLy8gZ2V0IGFuIGFwcHJvcHJpYXRlIGNvbG91ciBzY2FsZSBmb3IgdGhlIG51bWJlciBvZiBjYXRlZ29yaWVzIHdlIGFyZVxuICAvLyBkZWFsaW5nIHdpdGhcbiAgdmFyIGNvbG91cnMgPSBkMy5zY2FsZVsnY2F0ZWdvcnkyMCddKCkucmFuZ2UoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICByZXR1cm4gZC5jb2xvciB8fCAoZC5kYXRhICYmIGQuZGF0YS5jb2xvcikgfHwgY29sb3Vyc1tpICUgY29sb3Vycy5sZW5ndGhdO1xuICB9O1xufTtcblxuXG52YXIgdTE2bGU2NCA9IGZ1bmN0aW9uKHN0cikge1xuICAvLyBiYXNlNjQtZW5jb2RlIGEgc3RyaW5nIGFzIFVURi0xNi1MRSAoZm9yIE1TIEV4Y2VsLCBwcm9iYWJseSkuIEl0IHdpbGwgb25seVxuICAvLyB3b3JrIGZvciAyLWJ5dGUtd2lkZSB1dGYtMTYgY2hhcmFjdGVycywgYW5kIHdpbGwgYnJlYWsgYXQgdGhlIGZpcnN0IGhpbnRcbiAgLy8gb2YgYW55IDQtYnl0ZSBjaGFyLiBUd28gYnl0ZXMgY292ZXJzIHRoZSBCYXNpYyBNdWx0aW5pbmd1YWwgUGxhbmUsIHNvIHdlXG4gIC8vIHNob3VsZCBiZSBnb29kLlxuICB2YXIgdTE2bnVtLFxuICAgICAgYXNjaWlCeXRlUGFpclN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkUpO1xuICBhc2NpaUJ5dGVQYWlyU3RyaW5nICs9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChzdHIsIGZ1bmN0aW9uKGFjYywgY2hyKSB7XG4gICAgdTE2bnVtID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgLyoganNoaW50IGJpdHdpc2U6ZmFsc2UgKi9cbiAgICByZXR1cm4gYWNjICsgU3RyaW5nLmZyb21DaGFyQ29kZSh1MTZudW0gJiAweEZGKSArIFN0cmluZy5mcm9tQ2hhckNvZGUodTE2bnVtID4+IDgpO1xuICAgIC8qIGpzaGludCBiaXR3aXNlOnRydWUgKi9cbiAgfSwgJycpO1xuICByZXR1cm4gYnRvYShhc2NpaUJ5dGVQYWlyU3RyaW5nKTtcbn07XG5cblxudmFyIHRleHRBc0RhdGFVUkwgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuICdkYXRhOnRleHQvcGxhaW47YmFzZTY0LCcgKyB1MTZsZTY0KHN0cik7XG59O1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUFyZ3ModHJhbnNmb3JtZXIsIHdyYXBwZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIGFyZ3VtZW50cyAqLykge1xuICAgIHZhciB0cmFuc2Zvcm1lZEFyZ3MgPSB0cmFuc2Zvcm1lci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB3cmFwcGVkLmFwcGx5KG51bGwsIHRyYW5zZm9ybWVkQXJncyk7XG4gIH07XG59XG5cblxuZnVuY3Rpb24gdG9EYXNoZWQobmFtZSkge1xuICAvLyB0cmFuc2Zvcm0gbmFtZXNMaWtlVGhpcyB0byBuYW1lcy1saWtlLXRoaXNcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbih1KSB7XG4gICAgcmV0dXJuICctJyArIHUudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gZGF0YShlbCwgbmFtZSwgbmV3VmFsdWUpIHtcbiAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLScgKyB0b0Rhc2hlZChuYW1lKSk7XG4gIH1cbiAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLScgKyB0b0Rhc2hlZChuYW1lKSwgbmV3VmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBob3cgbXVjaCBoZWlnaHQgd2UgbmVlZCB0byBzaG93IGEgcmVhZGFibGUgY2hhcnQgd2l0aCBkaWZmZXJlbnQgbnVtYmVyIG9mIGxlZ2VuZHMuIFxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVDaGFydEhlaWdodChsZW5ndGgsIGlzRG93bmxvYWQsIG1vZGVsKSB7XG5cdHZhciBoZWlnaHQgPSBudWxsO1xuXHR2YXIgYmlnTiA9IG51bGw7XG5cdGlmIChsZW5ndGggPCAzMCkge1xuXHRcdGJpZ04gPSAnMCc7XG5cdFx0aWYgKGlzRG93bmxvYWQgPT09IHRydWUpIHtcblx0XHRcdGhlaWdodCA9IDQ1MDtcblx0XHR9XG5cdH0gZWxzZSBpZihsZW5ndGggPj0gMzAgJiYgbGVuZ3RoIDwgNDApIHtcblx0XHRpZiAoaXNEb3dubG9hZCA9PT0gdHJ1ZSkge1xuXHRcdFx0aGVpZ2h0ID0gNTUwO1xuXHRcdH0gIGVsc2Uge1xuXHRcdFx0aGVpZ2h0ID0gNDc1O1xuXHRcdH1cblx0XHRiaWdOID0gJzEnO1xuXHR9IGVsc2UgaWYobGVuZ3RoID49IDQwICYmIGxlbmd0aCA8IDUwKSB7XG5cdFx0aWYgKGlzRG93bmxvYWQgPT09IHRydWUpIHtcblx0XHRcdGhlaWdodCA9IDcwMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVpZ2h0ID0gNjI1O1xuXHRcdH1cblx0XHRiaWdOID0gJzInO1xuXHR9IGVsc2UgaWYobGVuZ3RoID49IDUwICYmIGxlbmd0aCA8IDYwKSB7XG5cdFx0aWYgKGlzRG93bmxvYWQgPT09IHRydWUpIHtcblx0XHRcdGhlaWdodCA9IDg1MDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVpZ2h0ID0gNzc1O1xuXHRcdH1cblx0XHRiaWdOID0gJzMnO1xuXHR9IGVsc2UgaWYobGVuZ3RoID49IDYwICYmIGxlbmd0aCA8IDcwKSB7XG5cdFx0aWYgKGlzRG93bmxvYWQgPT09IHRydWUpIHtcblx0XHRcdGhlaWdodCA9IDEwMDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlaWdodCA9IDkyNTtcblx0XHR9XG5cdFx0YmlnTiA9ICc0Jztcblx0fSBlbHNlIGlmKGxlbmd0aCA+PSA3MCAmJiBsZW5ndGggPCA4MCkge1xuXHRcdGlmIChpc0Rvd25sb2FkID09PSB0cnVlKSB7XG5cdFx0XHRoZWlnaHQgPSAxMTUwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWlnaHQgPSAxMDc1O1xuXHRcdH1cblx0XHRiaWdOID0gJzUnO1xuXHR9IGVsc2UgaWYobGVuZ3RoID49IDgwICYmIGxlbmd0aCA8IDkwKSB7XG5cdFx0aWYgKGlzRG93bmxvYWQgPT09IHRydWUpIHtcblx0XHRcdGhlaWdodCA9IDExNTA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlaWdodCA9IDEyMjU7XG5cdFx0fVxuXHRcdGJpZ04gPSAnNic7XHRcblx0fSBlbHNlIGlmKGxlbmd0aCA+PSA5MCkge1xuXHRcdC8vIFNlcmlvdXNseT8/Pz9cblx0XHRpZiAoaXNEb3dubG9hZCA9PT0gdHJ1ZSkge1xuXHRcdFx0aGVpZ2h0ID0gMTMwMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVpZ2h0ID0gMTM3NTtcblx0XHR9XG5cdFx0YmlnTiA9ICc3Jztcblx0fVxuXHRpZiAobW9kZWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdG1vZGVsLnNldCgnYmlnTicsIGJpZ04pO1xuXHR9XG5cdHJldHVybiBoZWlnaHRcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZm9ybWF0S01COiBmb3JtYXRLTUIsXG4gIHRyYW5zbGF0ZUxhbmd1YWdlOiB0cmFuc2xhdGVMYW5ndWFnZSxcbiAgZm9ybWF0U2hvcnRUZXh0OiBmb3JtYXRTaG9ydFRleHQsXG4gIGNhdGVnb3J5Q29sb3VyczogY2F0ZWdvcnlDb2xvdXJzLFxuICB1MTZsZTY0OiB1MTZsZTY0LFxuICB0ZXh0QXNEYXRhVVJMOiB0ZXh0QXNEYXRhVVJMLFxuICB0cmFuc2Zvcm1BcmdzOiB0cmFuc2Zvcm1BcmdzLFxuICBkYXRhOiBkYXRhLFxuICBjYWxjdWxhdGVDaGFydEhlaWdodDogY2FsY3VsYXRlQ2hhcnRIZWlnaHRcbn07XG4iLCIvKlxuXHRCYWJ5IFBhcnNlXG5cdHYwLjIuMVxuXHRodHRwczovL2dpdGh1Yi5jb20vUmljaC1IYXJyaXMvQmFieVBhcnNlXG5cblx0YmFzZWQgb24gUGFwYSBQYXJzZSB2My4wLjFcblx0aHR0cHM6Ly9naXRodWIuY29tL21ob2x0L1BhcGFQYXJzZVxuKi9cblxuXG4oZnVuY3Rpb24gKCBnbG9iYWwgKSB7XG5cblx0Ly8gQSBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHdoaWNoIHRvIGRyYXcgZGVmYXVsdCBzZXR0aW5nc1xuXHR2YXIgREVGQVVMVFMgPSB7XG5cdFx0ZGVsaW1pdGVyOiBcIlwiLFx0Ly8gZW1wdHk6IGF1dG8tZGV0ZWN0XG5cdFx0aGVhZGVyOiBmYWxzZSxcblx0XHRkeW5hbWljVHlwaW5nOiBmYWxzZSxcblx0XHRwcmV2aWV3OiAwLFxuXHRcdHN0ZXA6IHVuZGVmaW5lZCxcblx0XHRjb21tZW50czogZmFsc2UsXG5cdFx0Y29tcGxldGU6IHVuZGVmaW5lZCxcblx0XHRrZWVwRW1wdHlSb3dzOiBmYWxzZVxuXHR9O1xuXG5cdHZhciBCYWJ5ID0ge307XG5cdEJhYnkucGFyc2UgPSBDc3ZUb0pzb247XG5cdEJhYnkudW5wYXJzZSA9IEpzb25Ub0Nzdjtcblx0QmFieS5SRUNPUkRfU0VQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMCk7XG5cdEJhYnkuVU5JVF9TRVAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMxKTtcblx0QmFieS5CWVRFX09SREVSX01BUksgPSBcIlxcdWZlZmZcIjtcblx0QmFieS5CQURfREVMSU1JVEVSUyA9IFtcIlxcclwiLCBcIlxcblwiLCBcIlxcXCJcIiwgQmFieS5CWVRFX09SREVSX01BUktdO1xuXG5cblx0ZnVuY3Rpb24gQ3N2VG9Kc29uKF9pbnB1dCwgX2NvbmZpZylcblx0e1xuXHRcdHZhciBjb25maWcgPSBjb3B5QW5kVmFsaWRhdGVDb25maWcoX2NvbmZpZyk7XG5cdFx0dmFyIHBoID0gbmV3IFBhcnNlckhhbmRsZShjb25maWcpO1xuXHRcdHZhciByZXN1bHRzID0gcGgucGFyc2UoX2lucHV0KTtcblx0XHRpZiAoaXNGdW5jdGlvbihjb25maWcuY29tcGxldGUpKVxuXHRcdFx0Y29uZmlnLmNvbXBsZXRlKHJlc3VsdHMpO1xuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblxuXG5cblx0ZnVuY3Rpb24gSnNvblRvQ3N2KF9pbnB1dCwgX2NvbmZpZylcblx0e1xuXHRcdHZhciBfb3V0cHV0ID0gXCJcIjtcblx0XHR2YXIgX2ZpZWxkcyA9IFtdO1xuXG5cdFx0Ly8gRGVmYXVsdCBjb25maWd1cmF0aW9uXG5cdFx0dmFyIF9xdW90ZXMgPSBmYWxzZTtcdC8vIHdoZXRoZXIgdG8gc3Vycm91bmQgZXZlcnkgZGF0dW0gd2l0aCBxdW90ZXNcblx0XHR2YXIgX2RlbGltaXRlciA9IFwiLFwiO1x0Ly8gZGVsaW1pdGluZyBjaGFyYWN0ZXJcblx0XHR2YXIgX25ld2xpbmUgPSBcIlxcclxcblwiO1x0Ly8gbmV3bGluZSBjaGFyYWN0ZXIocylcblxuXHRcdHVucGFja0NvbmZpZygpO1xuXG5cdFx0aWYgKHR5cGVvZiBfaW5wdXQgPT09ICdzdHJpbmcnKVxuXHRcdFx0X2lucHV0ID0gSlNPTi5wYXJzZShfaW5wdXQpO1xuXG5cdFx0aWYgKF9pbnB1dCBpbnN0YW5jZW9mIEFycmF5KVxuXHRcdHtcblx0XHRcdGlmICghX2lucHV0Lmxlbmd0aCB8fCBfaW5wdXRbMF0gaW5zdGFuY2VvZiBBcnJheSlcblx0XHRcdFx0cmV0dXJuIHNlcmlhbGl6ZShudWxsLCBfaW5wdXQpO1xuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIF9pbnB1dFswXSA9PT0gJ29iamVjdCcpXG5cdFx0XHRcdHJldHVybiBzZXJpYWxpemUob2JqZWN0S2V5cyhfaW5wdXRbMF0pLCBfaW5wdXQpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgX2lucHV0ID09PSAnb2JqZWN0Jylcblx0XHR7XG5cdFx0XHRpZiAodHlwZW9mIF9pbnB1dC5kYXRhID09PSAnc3RyaW5nJylcblx0XHRcdFx0X2lucHV0LmRhdGEgPSBKU09OLnBhcnNlKF9pbnB1dC5kYXRhKTtcblxuXHRcdFx0aWYgKF9pbnB1dC5kYXRhIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghX2lucHV0LmZpZWxkcylcblx0XHRcdFx0XHRfaW5wdXQuZmllbGRzID0gX2lucHV0LmRhdGFbMF0gaW5zdGFuY2VvZiBBcnJheVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBfaW5wdXQuZmllbGRzXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IG9iamVjdEtleXMoX2lucHV0LmRhdGFbMF0pO1xuXG5cdFx0XHRcdGlmICghKF9pbnB1dC5kYXRhWzBdIGluc3RhbmNlb2YgQXJyYXkpICYmIHR5cGVvZiBfaW5wdXQuZGF0YVswXSAhPT0gJ29iamVjdCcpXG5cdFx0XHRcdFx0X2lucHV0LmRhdGEgPSBbX2lucHV0LmRhdGFdO1x0Ly8gaGFuZGxlcyBpbnB1dCBsaWtlIFsxLDIsM10gb3IgW1wiYXNkZlwiXVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2VyaWFsaXplKF9pbnB1dC5maWVsZHMgfHwgW10sIF9pbnB1dC5kYXRhIHx8IFtdKTtcblx0XHR9XG5cblx0XHQvLyBEZWZhdWx0IChhbnkgdmFsaWQgcGF0aHMgc2hvdWxkIHJldHVybiBiZWZvcmUgdGhpcylcblx0XHR0aHJvdyBcImV4Y2VwdGlvbjogVW5hYmxlIHRvIHNlcmlhbGl6ZSB1bnJlY29nbml6ZWQgaW5wdXRcIjtcblxuXG5cdFx0ZnVuY3Rpb24gdW5wYWNrQ29uZmlnKClcblx0XHR7XG5cdFx0XHRpZiAodHlwZW9mIF9jb25maWcgIT09ICdvYmplY3QnKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnXG5cdFx0XHRcdCYmIF9jb25maWcuZGVsaW1pdGVyLmxlbmd0aCA9PSAxXG5cdFx0XHRcdCYmIEJhYnkuQkFEX0RFTElNSVRFUlMuaW5kZXhPZihfY29uZmlnLmRlbGltaXRlcikgPT0gLTEpXG5cdFx0XHR7XG5cdFx0XHRcdF9kZWxpbWl0ZXIgPSBfY29uZmlnLmRlbGltaXRlcjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLnF1b3RlcyA9PT0gJ2Jvb2xlYW4nXG5cdFx0XHRcdHx8IF9jb25maWcucXVvdGVzIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0XHRcdF9xdW90ZXMgPSBfY29uZmlnLnF1b3RlcztcblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLm5ld2xpbmUgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRfbmV3bGluZSA9IF9jb25maWcubmV3bGluZTtcblx0XHR9XG5cblxuXHRcdC8vIFR1cm5zIGFuIG9iamVjdCdzIGtleXMgaW50byBhbiBhcnJheVxuXHRcdGZ1bmN0aW9uIG9iamVjdEtleXMob2JqKVxuXHRcdHtcblx0XHRcdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jylcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0dmFyIGtleXMgPSBbXTtcblx0XHRcdGZvciAodmFyIGtleSBpbiBvYmopXG5cdFx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdFx0cmV0dXJuIGtleXM7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGRvdWJsZSBmb3IgbG9vcCB0aGF0IGl0ZXJhdGVzIHRoZSBkYXRhIGFuZCB3cml0ZXMgb3V0IGEgQ1NWIHN0cmluZyBpbmNsdWRpbmcgaGVhZGVyIHJvd1xuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZShmaWVsZHMsIGRhdGEpXG5cdFx0e1xuXHRcdFx0dmFyIGNzdiA9IFwiXCI7XG5cblx0XHRcdGlmICh0eXBlb2YgZmllbGRzID09PSAnc3RyaW5nJylcblx0XHRcdFx0ZmllbGRzID0gSlNPTi5wYXJzZShmaWVsZHMpO1xuXHRcdFx0aWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcblx0XHRcdFx0ZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cblx0XHRcdHZhciBoYXNIZWFkZXIgPSBmaWVsZHMgaW5zdGFuY2VvZiBBcnJheSAmJiBmaWVsZHMubGVuZ3RoID4gMDtcblx0XHRcdHZhciBkYXRhS2V5ZWRCeUZpZWxkID0gIShkYXRhWzBdIGluc3RhbmNlb2YgQXJyYXkpO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBhIGhlYWRlciByb3csIHdyaXRlIGl0IGZpcnN0XG5cdFx0XHRpZiAoaGFzSGVhZGVyKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChpID4gMClcblx0XHRcdFx0XHRcdGNzdiArPSBfZGVsaW1pdGVyO1xuXHRcdFx0XHRcdGNzdiArPSBzYWZlKGZpZWxkc1tpXSwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRhdGEubGVuZ3RoID4gMClcblx0XHRcdFx0XHRjc3YgKz0gX25ld2xpbmU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZW4gd3JpdGUgb3V0IHRoZSBkYXRhXG5cdFx0XHRmb3IgKHZhciByb3cgPSAwOyByb3cgPCBkYXRhLmxlbmd0aDsgcm93KyspXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBtYXhDb2wgPSBoYXNIZWFkZXIgPyBmaWVsZHMubGVuZ3RoIDogZGF0YVtyb3ddLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtYXhDb2w7IGNvbCsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGNvbCA+IDApXG5cdFx0XHRcdFx0XHRjc3YgKz0gX2RlbGltaXRlcjtcblx0XHRcdFx0XHR2YXIgY29sSWR4ID0gaGFzSGVhZGVyICYmIGRhdGFLZXllZEJ5RmllbGQgPyBmaWVsZHNbY29sXSA6IGNvbDtcblx0XHRcdFx0XHRjc3YgKz0gc2FmZShkYXRhW3Jvd11bY29sSWR4XSwgY29sKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyb3cgPCBkYXRhLmxlbmd0aCAtIDEpXG5cdFx0XHRcdFx0Y3N2ICs9IF9uZXdsaW5lO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY3N2O1xuXHRcdH1cblxuXHRcdC8vIEVuY2xvc2VzIGEgdmFsdWUgYXJvdW5kIHF1b3RlcyBpZiBuZWVkZWQgKG1ha2VzIGEgdmFsdWUgc2FmZSBmb3IgQ1NWIGluc2VydGlvbilcblx0XHRmdW5jdGlvbiBzYWZlKHN0ciwgY29sKVxuXHRcdHtcblx0XHRcdGlmICh0eXBlb2Ygc3RyID09PSBcInVuZGVmaW5lZFwiKVxuXHRcdFx0XHRyZXR1cm4gXCJcIjtcblxuXHRcdFx0c3RyID0gc3RyLnRvU3RyaW5nKCkucmVwbGFjZSgvXCIvZywgJ1wiXCInKTtcblxuXHRcdFx0dmFyIG5lZWRzUXVvdGVzID0gKHR5cGVvZiBfcXVvdGVzID09PSAnYm9vbGVhbicgJiYgX3F1b3Rlcylcblx0XHRcdFx0XHRcdFx0fHwgKF9xdW90ZXMgaW5zdGFuY2VvZiBBcnJheSAmJiBfcXVvdGVzW2NvbF0pXG5cdFx0XHRcdFx0XHRcdHx8IGhhc0FueShzdHIsIEJhYnkuQkFEX0RFTElNSVRFUlMpXG5cdFx0XHRcdFx0XHRcdHx8IHN0ci5pbmRleE9mKF9kZWxpbWl0ZXIpID4gLTFcblx0XHRcdFx0XHRcdFx0fHwgc3RyLmNoYXJBdCgwKSA9PSAnICdcblx0XHRcdFx0XHRcdFx0fHwgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT0gJyAnO1xuXG5cdFx0XHRyZXR1cm4gbmVlZHNRdW90ZXMgPyAnXCInICsgc3RyICsgJ1wiJyA6IHN0cjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYXNBbnkoc3RyLCBzdWJzdHJpbmdzKVxuXHRcdHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic3RyaW5ncy5sZW5ndGg7IGkrKylcblx0XHRcdFx0aWYgKHN0ci5pbmRleE9mKHN1YnN0cmluZ3NbaV0pID4gLTEpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblxuXG5cblxuXG5cdC8vIFVzZSBvbmUgUGFyc2VySGFuZGxlIHBlciBlbnRpcmUgQ1NWIGZpbGUgb3Igc3RyaW5nXG5cdGZ1bmN0aW9uIFBhcnNlckhhbmRsZShfY29uZmlnKVxuXHR7XG5cdFx0Ly8gT25lIGdvYWwgaXMgdG8gbWluaW1pemUgdGhlIHVzZSBvZiByZWd1bGFyIGV4cHJlc3Npb25zLi4uXG5cdFx0dmFyIEZMT0FUID0gL15cXHMqLT8oXFxkKlxcLj9cXGQrfFxcZCtcXC4/XFxkKikoZVstK10/XFxkKyk/XFxzKiQvaTtcblxuXHRcdHZhciBfZGVsaW1pdGVyRXJyb3I7XHQvLyBUZW1wb3Jhcnkgc3RhdGUgYmV0d2VlbiBkZWxpbWl0ZXIgZGV0ZWN0aW9uIGFuZCBwcm9jZXNzaW5nIHJlc3VsdHNcblx0XHR2YXIgX2ZpZWxkcyA9IFtdO1x0XHQvLyBGaWVsZHMgYXJlIGZyb20gdGhlIGhlYWRlciByb3cgb2YgdGhlIGlucHV0LCBpZiB0aGVyZSBpcyBvbmVcblx0XHR2YXIgX3Jlc3VsdHMgPSB7XHRcdC8vIFRoZSBsYXN0IHJlc3VsdHMgcmV0dXJuZWQgZnJvbSB0aGUgcGFyc2VyXG5cdFx0XHRkYXRhOiBbXSxcblx0XHRcdGVycm9yczogW10sXG5cdFx0XHRtZXRhOiB7fVxuXHRcdH07XG5cdFx0X2NvbmZpZyA9IGNvcHkoX2NvbmZpZyk7XG5cblx0XHR0aGlzLnBhcnNlID0gZnVuY3Rpb24oaW5wdXQpXG5cdFx0e1xuXHRcdFx0X2RlbGltaXRlckVycm9yID0gZmFsc2U7XG5cdFx0XHRpZiAoIV9jb25maWcuZGVsaW1pdGVyKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgZGVsaW1HdWVzcyA9IGd1ZXNzRGVsaW1pdGVyKGlucHV0KTtcblx0XHRcdFx0aWYgKGRlbGltR3Vlc3Muc3VjY2Vzc2Z1bClcblx0XHRcdFx0XHRfY29uZmlnLmRlbGltaXRlciA9IGRlbGltR3Vlc3MuYmVzdERlbGltaXRlcjtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0X2RlbGltaXRlckVycm9yID0gdHJ1ZTtcdC8vIGFkZCBlcnJvciBhZnRlciBwYXJzaW5nIChvdGhlcndpc2UgaXQgd291bGQgYmUgb3ZlcndyaXR0ZW4pXG5cdFx0XHRcdFx0X2NvbmZpZy5kZWxpbWl0ZXIgPSBcIixcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVzdWx0cy5tZXRhLmRlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNGdW5jdGlvbihfY29uZmlnLnN0ZXApKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgdXNlclN0ZXAgPSBfY29uZmlnLnN0ZXA7XG5cdFx0XHRcdF9jb25maWcuc3RlcCA9IGZ1bmN0aW9uKHJlc3VsdHMsIHBhcnNlcilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdF9yZXN1bHRzID0gcmVzdWx0cztcblx0XHRcdFx0XHRpZiAobmVlZHNIZWFkZXJSb3coKSlcblx0XHRcdFx0XHRcdHByb2Nlc3NSZXN1bHRzKCk7XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0dXNlclN0ZXAocHJvY2Vzc1Jlc3VsdHMoKSwgcGFyc2VyKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0X3Jlc3VsdHMgPSBuZXcgUGFyc2VyKF9jb25maWcpLnBhcnNlKGlucHV0KTtcblx0XHRcdHJldHVybiBwcm9jZXNzUmVzdWx0cygpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzUmVzdWx0cygpXG5cdFx0e1xuXHRcdFx0aWYgKF9yZXN1bHRzICYmIF9kZWxpbWl0ZXJFcnJvcilcblx0XHRcdHtcblx0XHRcdFx0YWRkRXJyb3IoXCJEZWxpbWl0ZXJcIiwgXCJVbmRldGVjdGFibGVEZWxpbWl0ZXJcIiwgXCJVbmFibGUgdG8gYXV0by1kZXRlY3QgZGVsaW1pdGluZyBjaGFyYWN0ZXI7IGRlZmF1bHRlZCB0byBjb21tYVwiKTtcblx0XHRcdFx0X2RlbGltaXRlckVycm9yID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZWVkc0hlYWRlclJvdygpKVxuXHRcdFx0XHRmaWxsSGVhZGVyRmllbGRzKCk7XG5cblx0XHRcdHJldHVybiBhcHBseUhlYWRlckFuZER5bmFtaWNUeXBpbmcoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBuZWVkc0hlYWRlclJvdygpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9jb25maWcuaGVhZGVyICYmIF9maWVsZHMubGVuZ3RoID09IDA7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmlsbEhlYWRlckZpZWxkcygpXG5cdFx0e1xuXHRcdFx0aWYgKCFfcmVzdWx0cylcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IG5lZWRzSGVhZGVyUm93KCkgJiYgaSA8IF9yZXN1bHRzLmRhdGEubGVuZ3RoOyBpKyspXG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgX3Jlc3VsdHMuZGF0YVtpXS5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRfZmllbGRzLnB1c2goX3Jlc3VsdHMuZGF0YVtpXVtqXSk7XG5cdFx0XHRfcmVzdWx0cy5kYXRhLnNwbGljZSgwLCAxKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhcHBseUhlYWRlckFuZER5bmFtaWNUeXBpbmcoKVxuXHRcdHtcblx0XHRcdGlmICghX3Jlc3VsdHMgfHwgKCFfY29uZmlnLmhlYWRlciAmJiAhX2NvbmZpZy5keW5hbWljVHlwaW5nKSlcblx0XHRcdFx0cmV0dXJuIF9yZXN1bHRzO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IF9yZXN1bHRzLmRhdGEubGVuZ3RoOyBpKyspXG5cdFx0XHR7XG5cdFx0XHRcdHZhciByb3cgPSB7fTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBfcmVzdWx0cy5kYXRhW2ldLmxlbmd0aDsgaisrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKF9jb25maWcuZHluYW1pY1R5cGluZylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBfcmVzdWx0cy5kYXRhW2ldW2pdO1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlID09IFwidHJ1ZVwiKVxuXHRcdFx0XHRcdFx0XHRfcmVzdWx0cy5kYXRhW2ldW2pdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHZhbHVlID09IFwiZmFsc2VcIilcblx0XHRcdFx0XHRcdFx0X3Jlc3VsdHMuZGF0YVtpXVtqXSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRfcmVzdWx0cy5kYXRhW2ldW2pdID0gdHJ5UGFyc2VGbG9hdCh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKF9jb25maWcuaGVhZGVyKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChqID49IF9maWVsZHMubGVuZ3RoKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpZiAoIXJvd1tcIl9fcGFyc2VkX2V4dHJhXCJdKVxuXHRcdFx0XHRcdFx0XHRcdHJvd1tcIl9fcGFyc2VkX2V4dHJhXCJdID0gW107XG5cdFx0XHRcdFx0XHRcdHJvd1tcIl9fcGFyc2VkX2V4dHJhXCJdLnB1c2goX3Jlc3VsdHMuZGF0YVtpXVtqXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyb3dbX2ZpZWxkc1tqXV0gPSBfcmVzdWx0cy5kYXRhW2ldW2pdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChfY29uZmlnLmhlYWRlcilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdF9yZXN1bHRzLmRhdGFbaV0gPSByb3c7XG5cdFx0XHRcdFx0aWYgKGogPiBfZmllbGRzLmxlbmd0aClcblx0XHRcdFx0XHRcdGFkZEVycm9yKFwiRmllbGRNaXNtYXRjaFwiLCBcIlRvb01hbnlGaWVsZHNcIiwgXCJUb28gbWFueSBmaWVsZHM6IGV4cGVjdGVkIFwiICsgX2ZpZWxkcy5sZW5ndGggKyBcIiBmaWVsZHMgYnV0IHBhcnNlZCBcIiArIGosIGkpO1xuXHRcdFx0XHRcdGVsc2UgaWYgKGogPCBfZmllbGRzLmxlbmd0aClcblx0XHRcdFx0XHRcdGFkZEVycm9yKFwiRmllbGRNaXNtYXRjaFwiLCBcIlRvb0Zld0ZpZWxkc1wiLCBcIlRvbyBmZXcgZmllbGRzOiBleHBlY3RlZCBcIiArIF9maWVsZHMubGVuZ3RoICsgXCIgZmllbGRzIGJ1dCBwYXJzZWQgXCIgKyBqLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2NvbmZpZy5oZWFkZXIgJiYgX3Jlc3VsdHMubWV0YSk7XG5cdFx0XHRcdF9yZXN1bHRzLm1ldGEuZmllbGRzID0gX2ZpZWxkcztcblxuXHRcdFx0cmV0dXJuIF9yZXN1bHRzO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGd1ZXNzRGVsaW1pdGVyKGlucHV0KVxuXHRcdHtcblx0XHRcdHZhciBkZWxpbUNob2ljZXMgPSBbXCIsXCIsIFwiXFx0XCIsIFwifFwiLCBcIjtcIiwgQmFieS5SRUNPUkRfU0VQLCBCYWJ5LlVOSVRfU0VQXTtcblx0XHRcdHZhciBiZXN0RGVsaW0sIGJlc3REZWx0YSwgZmllbGRDb3VudFByZXZSb3c7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGVsaW1DaG9pY2VzLmxlbmd0aDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgZGVsaW0gPSBkZWxpbUNob2ljZXNbaV07XG5cdFx0XHRcdHZhciBkZWx0YSA9IDAsIGF2Z0ZpZWxkQ291bnQgPSAwO1xuXHRcdFx0XHRmaWVsZENvdW50UHJldlJvdyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHR2YXIgcHJldmlldyA9IG5ldyBQYXJzZXIoe1xuXHRcdFx0XHRcdGRlbGltaXRlcjogZGVsaW0sXG5cdFx0XHRcdFx0cHJldmlldzogMTBcblx0XHRcdFx0fSkucGFyc2UoaW5wdXQpO1xuXG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgcHJldmlldy5kYXRhLmxlbmd0aDsgaisrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGZpZWxkQ291bnQgPSBwcmV2aWV3LmRhdGFbal0ubGVuZ3RoO1xuXHRcdFx0XHRcdGF2Z0ZpZWxkQ291bnQgKz0gZmllbGRDb3VudDtcblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgZmllbGRDb3VudFByZXZSb3cgPT09ICd1bmRlZmluZWQnKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZpZWxkQ291bnRQcmV2Um93ID0gZmllbGRDb3VudDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChmaWVsZENvdW50ID4gMSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkZWx0YSArPSBNYXRoLmFicyhmaWVsZENvdW50IC0gZmllbGRDb3VudFByZXZSb3cpO1xuXHRcdFx0XHRcdFx0ZmllbGRDb3VudFByZXZSb3cgPSBmaWVsZENvdW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGF2Z0ZpZWxkQ291bnQgLz0gcHJldmlldy5kYXRhLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoKHR5cGVvZiBiZXN0RGVsdGEgPT09ICd1bmRlZmluZWQnIHx8IGRlbHRhIDwgYmVzdERlbHRhKVxuXHRcdFx0XHRcdCYmIGF2Z0ZpZWxkQ291bnQgPiAxLjk5KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YmVzdERlbHRhID0gZGVsdGE7XG5cdFx0XHRcdFx0YmVzdERlbGltID0gZGVsaW07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0X2NvbmZpZy5kZWxpbWl0ZXIgPSBiZXN0RGVsaW07XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN1Y2Nlc3NmdWw6ICEhYmVzdERlbGltLFxuXHRcdFx0XHRiZXN0RGVsaW1pdGVyOiBiZXN0RGVsaW1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cnlQYXJzZUZsb2F0KHZhbClcblx0XHR7XG5cdFx0XHR2YXIgaXNOdW1iZXIgPSBGTE9BVC50ZXN0KHZhbCk7XG5cdFx0XHRyZXR1cm4gaXNOdW1iZXIgPyBwYXJzZUZsb2F0KHZhbCkgOiB2YWw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkRXJyb3IodHlwZSwgY29kZSwgbXNnLCByb3cpXG5cdFx0e1xuXHRcdFx0X3Jlc3VsdHMuZXJyb3JzLnB1c2goe1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRjb2RlOiBjb2RlLFxuXHRcdFx0XHRtZXNzYWdlOiBtc2csXG5cdFx0XHRcdHJvdzogcm93XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXG5cblxuXG5cblxuXHRmdW5jdGlvbiBQYXJzZXIoY29uZmlnKVxuXHR7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBFTVBUWSA9IC9eXFxzKiQvO1xuXG5cdFx0dmFyIF9pbnB1dDtcdFx0Ly8gVGhlIGlucHV0IHRleHQgYmVpbmcgcGFyc2VkXG5cdFx0dmFyIF9kZWxpbWl0ZXI7XHQvLyBUaGUgZGVsaW1pdGluZyBjaGFyYWN0ZXJcblx0XHR2YXIgX2NvbW1lbnRzO1x0Ly8gQ29tbWVudCBjaGFyYWN0ZXIgKGRlZmF1bHQgJyMnKSBvciBib29sZWFuXG5cdFx0dmFyIF9zdGVwO1x0XHQvLyBUaGUgc3RlcCAoc3RyZWFtaW5nKSBmdW5jdGlvblxuXHRcdHZhciBfY2FsbGJhY2s7XHQvLyBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gZmluaXNoZWRcblx0XHR2YXIgX3ByZXZpZXc7XHQvLyBNYXhpbXVtIG51bWJlciBvZiBsaW5lcyAobm90IHJvd3MpIHRvIHBhcnNlXG5cdFx0dmFyIF9jaDtcdFx0Ly8gQ3VycmVudCBjaGFyYWN0ZXJcblx0XHR2YXIgX2k7XHRcdFx0Ly8gQ3VycmVudCBjaGFyYWN0ZXIncyBwb3NpdGlvbmFsIGluZGV4XG5cdFx0dmFyIF9pblF1b3RlcztcdC8vIFdoZXRoZXIgaW4gcXVvdGVzIG9yIG5vdFxuXHRcdHZhciBfbGluZU51bTtcdC8vIEN1cnJlbnQgbGluZSBudW1iZXIgKDEtYmFzZWQgaW5kZXhpbmcpXG5cdFx0dmFyIF9kYXRhO1x0XHQvLyBQYXJzZWQgZGF0YSAocmVzdWx0cylcblx0XHR2YXIgX2Vycm9ycztcdC8vIFBhcnNlIGVycm9yc1xuXHRcdHZhciBfcm93SWR4O1x0Ly8gQ3VycmVudCByb3cgaW5kZXggd2l0aGluIHJlc3VsdHMgKDAtYmFzZWQpXG5cdFx0dmFyIF9jb2xJZHg7XHQvLyBDdXJyZW50IGNvbCBpbmRleCB3aXRoaW4gcmVzdWx0IHJvdyAoMC1iYXNlZClcblx0XHR2YXIgX3J1bm5pbmdSb3dJZHg7XHRcdC8vIEN1bXVsYXRpdmUgcm93IGluZGV4LCB1c2VkIGJ5IHRoZSBwcmV2aWV3IGZlYXR1cmVcblx0XHR2YXIgX2Fib3J0ZWQgPSBmYWxzZTtcdC8vIEFib3J0IGZsYWdcblx0XHR2YXIgX3BhdXNlZCA9IGZhbHNlO1x0Ly8gUGF1c2UgZmxhZ1xuXG5cdFx0Ly8gVW5wYWNrIHRoZSBjb25maWcgb2JqZWN0XG5cdFx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXHRcdF9kZWxpbWl0ZXIgPSBjb25maWcuZGVsaW1pdGVyO1xuXHRcdF9jb21tZW50cyA9IGNvbmZpZy5jb21tZW50cztcblx0XHRfc3RlcCA9IGNvbmZpZy5zdGVwO1xuXHRcdF9wcmV2aWV3ID0gY29uZmlnLnByZXZpZXc7XG5cblx0XHQvLyBEZWxpbWl0ZXIgaW50ZWdyaXR5IGNoZWNrXG5cdFx0aWYgKHR5cGVvZiBfZGVsaW1pdGVyICE9PSAnc3RyaW5nJ1xuXHRcdFx0fHwgX2RlbGltaXRlci5sZW5ndGggIT0gMVxuXHRcdFx0fHwgQmFieS5CQURfREVMSU1JVEVSUy5pbmRleE9mKF9kZWxpbWl0ZXIpID4gLTEpXG5cdFx0XHRfZGVsaW1pdGVyID0gXCIsXCI7XG5cblx0XHQvLyBDb21tZW50IGNoYXJhY3RlciBpbnRlZ3JpdHkgY2hlY2tcblx0XHRpZiAoX2NvbW1lbnRzID09PSB0cnVlKVxuXHRcdFx0X2NvbW1lbnRzID0gXCIjXCI7XG5cdFx0ZWxzZSBpZiAodHlwZW9mIF9jb21tZW50cyAhPT0gJ3N0cmluZydcblx0XHRcdHx8IF9jb21tZW50cy5sZW5ndGggIT0gMVxuXHRcdFx0fHwgQmFieS5CQURfREVMSU1JVEVSUy5pbmRleE9mKF9jb21tZW50cykgPiAtMVxuXHRcdFx0fHwgX2NvbW1lbnRzID09IF9kZWxpbWl0ZXIpXG5cdFx0XHRfY29tbWVudHMgPSBmYWxzZTtcblxuXG5cdFx0dGhpcy5wYXJzZSA9IGZ1bmN0aW9uKGlucHV0KVxuXHRcdHtcblx0XHRcdGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKVxuXHRcdFx0XHR0aHJvdyBcIklucHV0IG11c3QgYmUgYSBzdHJpbmdcIjtcblx0XHRcdHJlc2V0KGlucHV0KTtcblx0XHRcdHJldHVybiBwYXJzZXJMb29wKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuYWJvcnQgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0X2Fib3J0ZWQgPSB0cnVlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwYXJzZXJMb29wKClcblx0XHR7XG5cdFx0XHR3aGlsZSAoX2kgPCBfaW5wdXQubGVuZ3RoKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoX2Fib3J0ZWQpIGJyZWFrO1xuXHRcdFx0XHRpZiAoX3ByZXZpZXcgPiAwICYmIF9ydW5uaW5nUm93SWR4ID49IF9wcmV2aWV3KSBicmVhaztcblx0XHRcdFx0aWYgKF9wYXVzZWQpIHJldHVybiBmaW5pc2hQYXJzaW5nKCk7XG5cblx0XHRcdFx0aWYgKF9jaCA9PSAnXCInKVxuXHRcdFx0XHRcdHBhcnNlUXVvdGVzKCk7XG5cdFx0XHRcdGVsc2UgaWYgKF9pblF1b3Rlcylcblx0XHRcdFx0XHRwYXJzZUluUXVvdGVzKCk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRwYXJzZU5vdEluUXVvdGVzKCk7XG5cblx0XHRcdFx0bmV4dENoYXIoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZpbmlzaFBhcnNpbmcoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBuZXh0Q2hhcigpXG5cdFx0e1xuXHRcdFx0X2krKztcblx0XHRcdF9jaCA9IF9pbnB1dFtfaV07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmluaXNoUGFyc2luZygpXG5cdFx0e1xuXHRcdFx0aWYgKF9hYm9ydGVkKVxuXHRcdFx0XHRhZGRFcnJvcihcIkFib3J0XCIsIFwiUGFyc2VBYm9ydFwiLCBcIlBhcnNpbmcgd2FzIGFib3J0ZWQgYnkgdGhlIHVzZXIncyBzdGVwIGZ1bmN0aW9uXCIpO1xuXHRcdFx0aWYgKF9pblF1b3Rlcylcblx0XHRcdFx0YWRkRXJyb3IoXCJRdW90ZXNcIiwgXCJNaXNzaW5nUXVvdGVzXCIsIFwiVW5lc2NhcGVkIG9yIG1pc21hdGNoZWQgcXVvdGVzXCIpO1xuXHRcdFx0ZW5kUm93KCk7XHQvLyBFbmQgb2YgaW5wdXQgaXMgYWxzbyBlbmQgb2YgdGhlIGxhc3Qgcm93XG5cdFx0XHRpZiAoIWlzRnVuY3Rpb24oX3N0ZXApKVxuXHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlUXVvdGVzKClcblx0XHR7XG5cdFx0XHRpZiAocXVvdGVzT25Cb3VuZGFyeSgpICYmICFxdW90ZXNFc2NhcGVkKCkpXG5cdFx0XHRcdF9pblF1b3RlcyA9ICFfaW5RdW90ZXM7XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHNhdmVDaGFyKCk7XG5cdFx0XHRcdGlmIChfaW5RdW90ZXMgJiYgcXVvdGVzRXNjYXBlZCgpKVxuXHRcdFx0XHRcdF9pKytcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGFkZEVycm9yKFwiUXVvdGVzXCIsIFwiVW5leHBlY3RlZFF1b3Rlc1wiLCBcIlVuZXhwZWN0ZWQgcXVvdGVzXCIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlSW5RdW90ZXMoKVxuXHRcdHtcblx0XHRcdGlmICh0d29DaGFyTGluZUJyZWFrKF9pKSB8fCBvbmVDaGFyTGluZUJyZWFrKF9pKSlcblx0XHRcdFx0X2xpbmVOdW0rKztcblx0XHRcdHNhdmVDaGFyKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VOb3RJblF1b3RlcygpXG5cdFx0e1xuXHRcdFx0aWYgKF9jaCA9PSBfZGVsaW1pdGVyKVxuXHRcdFx0XHRuZXdGaWVsZCgpO1xuXHRcdFx0ZWxzZSBpZiAodHdvQ2hhckxpbmVCcmVhayhfaSkpXG5cdFx0XHR7XG5cdFx0XHRcdG5ld1JvdygpO1xuXHRcdFx0XHRuZXh0Q2hhcigpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAob25lQ2hhckxpbmVCcmVhayhfaSkpXG5cdFx0XHRcdG5ld1JvdygpO1xuXHRcdFx0ZWxzZSBpZiAoaXNDb21tZW50U3RhcnQoKSlcblx0XHRcdFx0c2tpcExpbmUoKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0c2F2ZUNoYXIoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0NvbW1lbnRTdGFydCgpXG5cdFx0e1xuXHRcdFx0aWYgKCFfY29tbWVudHMpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0dmFyIGZpcnN0Q2hhck9mTGluZSA9IF9pID09IDBcblx0XHRcdFx0XHRcdFx0XHRcdHx8IG9uZUNoYXJMaW5lQnJlYWsoX2ktMSlcblx0XHRcdFx0XHRcdFx0XHRcdHx8IHR3b0NoYXJMaW5lQnJlYWsoX2ktMik7XG5cdFx0XHRyZXR1cm4gZmlyc3RDaGFyT2ZMaW5lICYmIF9pbnB1dFtfaV0gPT09IF9jb21tZW50cztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBza2lwTGluZSgpXG5cdFx0e1xuXHRcdFx0d2hpbGUgKCF0d29DaGFyTGluZUJyZWFrKF9pKVxuXHRcdFx0XHQmJiAhb25lQ2hhckxpbmVCcmVhayhfaSlcblx0XHRcdFx0JiYgX2kgPCBfaW5wdXQubGVuZ3RoKVxuXHRcdFx0e1xuXHRcdFx0XHRuZXh0Q2hhcigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNhdmVDaGFyKClcblx0XHR7XG5cdFx0XHRfZGF0YVtfcm93SWR4XVtfY29sSWR4XSArPSBfY2g7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbmV3RmllbGQoKVxuXHRcdHtcblx0XHRcdF9kYXRhW19yb3dJZHhdLnB1c2goXCJcIik7XG5cdFx0XHRfY29sSWR4ID0gX2RhdGFbX3Jvd0lkeF0ubGVuZ3RoIC0gMTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBuZXdSb3coKVxuXHRcdHtcblx0XHRcdGVuZFJvdygpO1xuXG5cdFx0XHRfbGluZU51bSsrO1xuXHRcdFx0X3J1bm5pbmdSb3dJZHgrKztcblx0XHRcdF9kYXRhLnB1c2goW10pO1xuXHRcdFx0X3Jvd0lkeCA9IF9kYXRhLmxlbmd0aCAtIDE7XG5cdFx0XHRuZXdGaWVsZCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuZFJvdygpXG5cdFx0e1xuXHRcdFx0dHJpbUVtcHR5TGFzdFJvdygpO1xuXHRcdFx0aWYgKGlzRnVuY3Rpb24oX3N0ZXApKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoX2RhdGFbX3Jvd0lkeF0pXG5cdFx0XHRcdFx0X3N0ZXAocmV0dXJuYWJsZSgpLCBzZWxmKTtcblx0XHRcdFx0Y2xlYXJFcnJvcnNBbmREYXRhKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpbUVtcHR5TGFzdFJvdygpXG5cdFx0e1xuXHRcdFx0aWYgKF9kYXRhW19yb3dJZHhdLmxlbmd0aCA9PSAxICYmIEVNUFRZLnRlc3QoX2RhdGFbX3Jvd0lkeF1bMF0pKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoY29uZmlnLmtlZXBFbXB0eVJvd3MpXG5cdFx0XHRcdFx0X2RhdGFbX3Jvd0lkeF0uc3BsaWNlKDAsIDEpO1x0Ly8gbGVhdmUgcm93LCBidXQgbm8gZmllbGRzXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRfZGF0YS5zcGxpY2UoX3Jvd0lkeCwgMSk7XHRcdC8vIGN1dCBvdXQgcm93IGVudGlyZWx5XG5cdFx0XHRcdF9yb3dJZHggPSBfZGF0YS5sZW5ndGggLSAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHR3b0NoYXJMaW5lQnJlYWsoaSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gaSA8IF9pbnB1dC5sZW5ndGggLSAxICYmXG5cdFx0XHRcdCgoX2lucHV0W2ldID09IFwiXFxyXCIgJiYgX2lucHV0W2krMV0gPT0gXCJcXG5cIilcblx0XHRcdFx0fHwgKF9pbnB1dFtpXSA9PSBcIlxcblwiICYmIF9pbnB1dFtpKzFdID09IFwiXFxyXCIpKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uZUNoYXJMaW5lQnJlYWsoaSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2lucHV0W2ldID09IFwiXFxyXCIgfHwgX2lucHV0W2ldID09IFwiXFxuXCI7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcXVvdGVzRXNjYXBlZCgpXG5cdFx0e1xuXHRcdFx0Ly8gUXVvdGVzIGFzIGRhdGEgY2Fubm90IGJlIG9uIGJvdW5kYXJ5LCBmb3IgZXhhbXBsZTogLFwiXCIsIGFyZSBub3QgZXNjYXBlZCBxdW90ZXNcblx0XHRcdHJldHVybiAhcXVvdGVzT25Cb3VuZGFyeSgpICYmIF9pIDwgX2lucHV0Lmxlbmd0aCAtIDEgJiYgX2lucHV0W19pKzFdID09ICdcIic7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcXVvdGVzT25Cb3VuZGFyeSgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuICghX2luUXVvdGVzICYmIGlzQm91bmRhcnkoX2ktMSkpIHx8IGlzQm91bmRhcnkoX2krMSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNCb3VuZGFyeShpKVxuXHRcdHtcblx0XHRcdGlmICh0eXBlb2YgaSAhPSAnbnVtYmVyJylcblx0XHRcdFx0aSA9IF9pO1xuXG5cdFx0XHR2YXIgY2ggPSBfaW5wdXRbaV07XG5cblx0XHRcdHJldHVybiAoaSA8PSAtMSB8fCBpID49IF9pbnB1dC5sZW5ndGgpXG5cdFx0XHRcdHx8IChjaCA9PSBfZGVsaW1pdGVyXG5cdFx0XHRcdFx0fHwgY2ggPT0gXCJcXHJcIlxuXHRcdFx0XHRcdHx8IGNoID09IFwiXFxuXCIpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEVycm9yKHR5cGUsIGNvZGUsIG1zZylcblx0XHR7XG5cdFx0XHRfZXJyb3JzLnB1c2goe1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRjb2RlOiBjb2RlLFxuXHRcdFx0XHRtZXNzYWdlOiBtc2csXG5cdFx0XHRcdGxpbmU6IF9saW5lTnVtLFxuXHRcdFx0XHRyb3c6IF9yb3dJZHgsXG5cdFx0XHRcdGluZGV4OiBfaVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzZXQoaW5wdXQpXG5cdFx0e1xuXHRcdFx0X2lucHV0ID0gaW5wdXQ7XG5cdFx0XHRfaW5RdW90ZXMgPSBmYWxzZTtcblx0XHRcdF9pID0gMCwgX3J1bm5pbmdSb3dJZHggPSAwLCBfbGluZU51bSA9IDE7XG5cdFx0XHRjbGVhckVycm9yc0FuZERhdGEoKTtcblx0XHRcdF9kYXRhID0gWyBbXCJcIl0gXTtcdC8vIHN0YXJ0aW5nIHBhcnNpbmcgcmVxdWlyZXMgYW4gZW1wdHkgZmllbGRcblx0XHRcdF9jaCA9IF9pbnB1dFtfaV07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2xlYXJFcnJvcnNBbmREYXRhKClcblx0XHR7XG5cdFx0XHRfZGF0YSA9IFtdO1xuXHRcdFx0X2Vycm9ycyA9IFtdO1xuXHRcdFx0X3Jvd0lkeCA9IDA7XG5cdFx0XHRfY29sSWR4ID0gMDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXR1cm5hYmxlKClcblx0XHR7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBfZGF0YSxcblx0XHRcdFx0ZXJyb3JzOiBfZXJyb3JzLFxuXHRcdFx0XHRtZXRhOiB7XG5cdFx0XHRcdFx0bGluZXM6IF9saW5lTnVtLFxuXHRcdFx0XHRcdGRlbGltaXRlcjogX2RlbGltaXRlcixcblx0XHRcdFx0XHRhYm9ydGVkOiBfYWJvcnRlZFxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlcGxhY2VzIGJhZCBjb25maWcgdmFsdWVzIHdpdGggZ29vZCwgZGVmYXVsdCBvbmVzXG5cdGZ1bmN0aW9uIGNvcHlBbmRWYWxpZGF0ZUNvbmZpZyhvcmlnQ29uZmlnKVxuXHR7XG5cdFx0aWYgKHR5cGVvZiBvcmlnQ29uZmlnICE9PSAnb2JqZWN0Jylcblx0XHRcdG9yaWdDb25maWcgPSB7fTtcblxuXHRcdHZhciBjb25maWcgPSBjb3B5KG9yaWdDb25maWcpO1xuXG5cdFx0aWYgKHR5cGVvZiBjb25maWcuZGVsaW1pdGVyICE9PSAnc3RyaW5nJ1xuXHRcdFx0fHwgY29uZmlnLmRlbGltaXRlci5sZW5ndGggIT0gMVxuXHRcdFx0fHwgQmFieS5CQURfREVMSU1JVEVSUy5pbmRleE9mKGNvbmZpZy5kZWxpbWl0ZXIpID4gLTEpXG5cdFx0XHRjb25maWcuZGVsaW1pdGVyID0gREVGQVVMVFMuZGVsaW1pdGVyO1xuXG5cdFx0aWYgKHR5cGVvZiBjb25maWcuaGVhZGVyICE9PSAnYm9vbGVhbicpXG5cdFx0XHRjb25maWcuaGVhZGVyID0gREVGQVVMVFMuaGVhZGVyO1xuXG5cdFx0aWYgKHR5cGVvZiBjb25maWcuZHluYW1pY1R5cGluZyAhPT0gJ2Jvb2xlYW4nKVxuXHRcdFx0Y29uZmlnLmR5bmFtaWNUeXBpbmcgPSBERUZBVUxUUy5keW5hbWljVHlwaW5nO1xuXG5cdFx0aWYgKHR5cGVvZiBjb25maWcucHJldmlldyAhPT0gJ251bWJlcicpXG5cdFx0XHRjb25maWcucHJldmlldyA9IERFRkFVTFRTLnByZXZpZXc7XG5cblx0XHRpZiAodHlwZW9mIGNvbmZpZy5zdGVwICE9PSAnZnVuY3Rpb24nKVxuXHRcdFx0Y29uZmlnLnN0ZXAgPSBERUZBVUxUUy5zdGVwO1xuXG5cdFx0aWYgKHR5cGVvZiBjb25maWcuY29tcGxldGUgIT09ICdmdW5jdGlvbicpXG5cdFx0XHRjb25maWcuY29tcGxldGUgPSBERUZBVUxUUy5jb21wbGV0ZTtcblxuXHRcdGlmICh0eXBlb2YgY29uZmlnLmtlZXBFbXB0eVJvd3MgIT09ICdib29sZWFuJylcblx0XHRcdGNvbmZpZy5rZWVwRW1wdHlSb3dzID0gREVGQVVMVFMua2VlcEVtcHR5Um93cztcblxuXHRcdHJldHVybiBjb25maWc7XG5cdH1cblxuXHRmdW5jdGlvbiBjb3B5KG9iailcblx0e1xuXHRcdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jylcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0dmFyIGNweSA9IG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gW10gOiB7fTtcblx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKVxuXHRcdFx0Y3B5W2tleV0gPSBjb3B5KG9ialtrZXldKTtcblx0XHRyZXR1cm4gY3B5O1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jKVxuXHR7XG5cdFx0cmV0dXJuIHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nO1xuXHR9XG5cblxuXG5cblxuXG5cdC8vIGV4cG9ydCB0byBOb2RlLi4uXG5cdGlmICggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBCYWJ5O1xuXHR9XG5cblx0Ly8gLi4ub3IgYXMgQU1EIG1vZHVsZS4uLlxuXHRlbHNlIGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdGRlZmluZSggZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFieTsgfSk7XG5cdH1cblxuXHQvLyAuLi5vciBhcyBicm93c2VyIGdsb2JhbFxuXHRlbHNlIHtcblx0XHRnbG9iYWwuQmFieSA9IEJhYnk7XG5cdH1cblxuXG5cbn0oIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyApKTtcbiIsIi8qIVxuICogbnVtZXJhbC5qc1xuICogdmVyc2lvbiA6IDEuNS4zXG4gKiBhdXRob3IgOiBBZGFtIERyYXBlclxuICogbGljZW5zZSA6IE1JVFxuICogaHR0cDovL2FkYW13ZHJhcGVyLmdpdGh1Yi5jb20vTnVtZXJhbC1qcy9cbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdGFudHNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgbnVtZXJhbCxcbiAgICAgICAgVkVSU0lPTiA9ICcxLjUuMycsXG4gICAgICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxhbmd1YWdlIGNvbmZpZyBmaWxlc1xuICAgICAgICBsYW5ndWFnZXMgPSB7fSxcbiAgICAgICAgY3VycmVudExhbmd1YWdlID0gJ2VuJyxcbiAgICAgICAgemVyb0Zvcm1hdCA9IG51bGwsXG4gICAgICAgIGRlZmF1bHRGb3JtYXQgPSAnMCwwJyxcbiAgICAgICAgLy8gY2hlY2sgZm9yIG5vZGVKU1xuICAgICAgICBoYXNNb2R1bGUgPSAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpO1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0cnVjdG9yc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gTnVtZXJhbCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTnVtZXJhbCAobnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG9mIHRvRml4ZWQoKSB0aGF0IHRyZWF0cyBmbG9hdHMgbW9yZSBsaWtlIGRlY2ltYWxzXG4gICAgICpcbiAgICAgKiBGaXhlcyBiaW5hcnkgcm91bmRpbmcgaXNzdWVzIChlZy4gKDAuNjE1KS50b0ZpeGVkKDIpID09PSAnMC42MScpIHRoYXQgcHJlc2VudFxuICAgICAqIHByb2JsZW1zIGZvciBhY2NvdW50aW5nLSBhbmQgZmluYW5jZS1yZWxhdGVkIHNvZnR3YXJlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRml4ZWQgKHZhbHVlLCBwcmVjaXNpb24sIHJvdW5kaW5nRnVuY3Rpb24sIG9wdGlvbmFscykge1xuICAgICAgICB2YXIgcG93ZXIgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKSxcbiAgICAgICAgICAgIG9wdGlvbmFsc1JlZ0V4cCxcbiAgICAgICAgICAgIG91dHB1dDtcbiAgICAgICAgICAgIFxuICAgICAgICAvL3JvdW5kaW5nRnVuY3Rpb24gPSAocm91bmRpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkID8gcm91bmRpbmdGdW5jdGlvbiA6IE1hdGgucm91bmQpO1xuICAgICAgICAvLyBNdWx0aXBseSB1cCBieSBwcmVjaXNpb24sIHJvdW5kIGFjY3VyYXRlbHksIHRoZW4gZGl2aWRlIGFuZCB1c2UgbmF0aXZlIHRvRml4ZWQoKTpcbiAgICAgICAgb3V0cHV0ID0gKHJvdW5kaW5nRnVuY3Rpb24odmFsdWUgKiBwb3dlcikgLyBwb3dlcikudG9GaXhlZChwcmVjaXNpb24pO1xuXG4gICAgICAgIGlmIChvcHRpb25hbHMpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsc1JlZ0V4cCA9IG5ldyBSZWdFeHAoJzB7MSwnICsgb3B0aW9uYWxzICsgJ30kJyk7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShvcHRpb25hbHNSZWdFeHAsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBGb3JtYXR0aW5nXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoYXQgdHlwZSBvZiBmb3JtYXR0aW5nIHdlIG5lZWQgdG8gZG9cbiAgICBmdW5jdGlvbiBmb3JtYXROdW1lcmFsIChuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG91dHB1dDtcblxuICAgICAgICAvLyBmaWd1cmUgb3V0IHdoYXQga2luZCBvZiBmb3JtYXQgd2UgYXJlIGRlYWxpbmcgd2l0aFxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyQnKSA+IC0xKSB7IC8vIGN1cnJlbmN5ISEhISFcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdEN1cnJlbmN5KG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJyUnKSA+IC0xKSB7IC8vIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdFBlcmNlbnRhZ2UobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignOicpID4gLTEpIHsgLy8gdGltZVxuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0VGltZShuLCBmb3JtYXQpO1xuICAgICAgICB9IGVsc2UgeyAvLyBwbGFpbiBvbCcgbnVtYmVycyBvciBieXRlc1xuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0TnVtYmVyKG4uX3ZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHN0cmluZ1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8vIHJldmVydCB0byBudW1iZXJcbiAgICBmdW5jdGlvbiB1bmZvcm1hdE51bWVyYWwgKG4sIHN0cmluZykge1xuICAgICAgICB2YXIgc3RyaW5nT3JpZ2luYWwgPSBzdHJpbmcsXG4gICAgICAgICAgICB0aG91c2FuZFJlZ0V4cCxcbiAgICAgICAgICAgIG1pbGxpb25SZWdFeHAsXG4gICAgICAgICAgICBiaWxsaW9uUmVnRXhwLFxuICAgICAgICAgICAgdHJpbGxpb25SZWdFeHAsXG4gICAgICAgICAgICBzdWZmaXhlcyA9IFsnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXSxcbiAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IGZhbHNlLFxuICAgICAgICAgICAgcG93ZXI7XG5cbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCc6JykgPiAtMSkge1xuICAgICAgICAgICAgbi5fdmFsdWUgPSB1bmZvcm1hdFRpbWUoc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdHJpbmcgPT09IHplcm9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBuLl92YWx1ZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLmRlY2ltYWwgIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFwuL2csJycpLnJlcGxhY2UobGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uZGVsaW1pdGVycy5kZWNpbWFsLCAnLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNlZSBpZiBhYmJyZXZpYXRpb25zIGFyZSB0aGVyZSBzbyB0aGF0IHdlIGNhbiBtdWx0aXBseSB0byB0aGUgY29ycmVjdCBudW1iZXJcbiAgICAgICAgICAgICAgICB0aG91c2FuZFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRob3VzYW5kICsgJyg/OlxcXFwpfChcXFxcJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArICcpPyg/OlxcXFwpKT8pPyQnKTtcbiAgICAgICAgICAgICAgICBtaWxsaW9uUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMubWlsbGlvbiArICcoPzpcXFxcKXwoXFxcXCcgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyAnKT8oPzpcXFxcKSk/KT8kJyk7XG4gICAgICAgICAgICAgICAgYmlsbGlvblJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLmJpbGxpb24gKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuICAgICAgICAgICAgICAgIHRyaWxsaW9uUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudHJpbGxpb24gKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2VlIGlmIGJ5dGVzIGFyZSB0aGVyZSBzbyB0aGF0IHdlIGNhbiBtdWx0aXBseSB0byB0aGUgY29ycmVjdCBudW1iZXJcbiAgICAgICAgICAgICAgICBmb3IgKHBvd2VyID0gMDsgcG93ZXIgPD0gc3VmZml4ZXMubGVuZ3RoOyBwb3dlcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IChzdHJpbmcuaW5kZXhPZihzdWZmaXhlc1twb3dlcl0pID4gLTEpID8gTWF0aC5wb3coMTAyNCwgcG93ZXIgKyAxKSA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlc011bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gc29tZSBtYXRoIHRvIGNyZWF0ZSBvdXIgbnVtYmVyXG4gICAgICAgICAgICAgICAgbi5fdmFsdWUgPSAoKGJ5dGVzTXVsdGlwbGllcikgPyBieXRlc011bHRpcGxpZXIgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2godGhvdXNhbmRSZWdFeHApKSA/IE1hdGgucG93KDEwLCAzKSA6IDEpICogKChzdHJpbmdPcmlnaW5hbC5tYXRjaChtaWxsaW9uUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgNikgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2goYmlsbGlvblJlZ0V4cCkpID8gTWF0aC5wb3coMTAsIDkpIDogMSkgKiAoKHN0cmluZ09yaWdpbmFsLm1hdGNoKHRyaWxsaW9uUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgMTIpIDogMSkgKiAoKHN0cmluZy5pbmRleE9mKCclJykgPiAtMSkgPyAwLjAxIDogMSkgKiAoKChzdHJpbmcuc3BsaXQoJy0nKS5sZW5ndGggKyBNYXRoLm1pbihzdHJpbmcuc3BsaXQoJygnKS5sZW5ndGgtMSwgc3RyaW5nLnNwbGl0KCcpJykubGVuZ3RoLTEpKSAlIDIpPyAxOiAtMSkgKiBOdW1iZXIoc3RyaW5nLnJlcGxhY2UoL1teMC05XFwuXSsvZywgJycpKTtcblxuICAgICAgICAgICAgICAgIC8vIHJvdW5kIGlmIHdlIGFyZSB0YWxraW5nIGFib3V0IGJ5dGVzXG4gICAgICAgICAgICAgICAgbi5fdmFsdWUgPSAoYnl0ZXNNdWx0aXBsaWVyKSA/IE1hdGguY2VpbChuLl92YWx1ZSkgOiBuLl92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbi5fdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0Q3VycmVuY3kgKG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgc3ltYm9sSW5kZXggPSBmb3JtYXQuaW5kZXhPZignJCcpLFxuICAgICAgICAgICAgb3BlblBhcmVuSW5kZXggPSBmb3JtYXQuaW5kZXhPZignKCcpLFxuICAgICAgICAgICAgbWludXNTaWduSW5kZXggPSBmb3JtYXQuaW5kZXhPZignLScpLFxuICAgICAgICAgICAgc3BhY2UgPSAnJyxcbiAgICAgICAgICAgIHNwbGljZUluZGV4LFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgb3IgYWZ0ZXIgY3VycmVuY3lcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgJCcpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyAkJywgJycpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCckICcpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyQgJywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyQnLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3JtYXQgdGhlIG51bWJlclxuICAgICAgICBvdXRwdXQgPSBmb3JtYXROdW1iZXIobi5fdmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgLy8gcG9zaXRpb24gdGhlIHN5bWJvbFxuICAgICAgICBpZiAoc3ltYm9sSW5kZXggPD0gMSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKCcoJykgPiAtMSB8fCBvdXRwdXQuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIHNwbGljZUluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sSW5kZXggPCBvcGVuUGFyZW5JbmRleCB8fCBzeW1ib2xJbmRleCA8IG1pbnVzU2lnbkluZGV4KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN5bWJvbCBhcHBlYXJzIGJlZm9yZSB0aGUgXCIoXCIgb3IgXCItXCJcbiAgICAgICAgICAgICAgICAgICAgc3BsaWNlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BsaWNlKHNwbGljZUluZGV4LCAwLCBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSArIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQZXJjZW50YWdlIChuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHNwYWNlID0gJycsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICB2YWx1ZSA9IG4uX3ZhbHVlICogMTAwO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgJVxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyAlJykgPiAtMSkge1xuICAgICAgICAgICAgc3BhY2UgPSAnICc7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnICUnLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnJScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dCA9IGZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKScpID4gLTEgKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgb3V0cHV0LnNwbGljZSgtMSwgMCwgc3BhY2UgKyAnJScpO1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgc3BhY2UgKyAnJSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFRpbWUgKG4pIHtcbiAgICAgICAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihuLl92YWx1ZS82MC82MCksXG4gICAgICAgICAgICBtaW51dGVzID0gTWF0aC5mbG9vcigobi5fdmFsdWUgLSAoaG91cnMgKiA2MCAqIDYwKSkvNjApLFxuICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgucm91bmQobi5fdmFsdWUgLSAoaG91cnMgKiA2MCAqIDYwKSAtIChtaW51dGVzICogNjApKTtcbiAgICAgICAgcmV0dXJuIGhvdXJzICsgJzonICsgKChtaW51dGVzIDwgMTApID8gJzAnICsgbWludXRlcyA6IG1pbnV0ZXMpICsgJzonICsgKChzZWNvbmRzIDwgMTApID8gJzAnICsgc2Vjb25kcyA6IHNlY29uZHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuZm9ybWF0VGltZSAoc3RyaW5nKSB7XG4gICAgICAgIHZhciB0aW1lQXJyYXkgPSBzdHJpbmcuc3BsaXQoJzonKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSAwO1xuICAgICAgICAvLyB0dXJuIGhvdXJzIGFuZCBtaW51dGVzIGludG8gc2Vjb25kcyBhbmQgYWRkIHRoZW0gYWxsIHVwXG4gICAgICAgIGlmICh0aW1lQXJyYXkubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAvLyBob3Vyc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyAoTnVtYmVyKHRpbWVBcnJheVswXSkgKiA2MCAqIDYwKTtcbiAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgKE51bWJlcih0aW1lQXJyYXlbMV0pICogNjApO1xuICAgICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyBOdW1iZXIodGltZUFycmF5WzJdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lQXJyYXkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAvLyBtaW51dGVzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzBdKSAqIDYwKTtcbiAgICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgTnVtYmVyKHRpbWVBcnJheVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlcihzZWNvbmRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXROdW1iZXIgKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG5lZ1AgPSBmYWxzZSxcbiAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlLFxuICAgICAgICAgICAgb3B0RGVjID0gZmFsc2UsXG4gICAgICAgICAgICBhYmJyID0gJycsXG4gICAgICAgICAgICBhYmJySyA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gdGhvdXNhbmRzXG4gICAgICAgICAgICBhYmJyTSA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gbWlsbGlvbnNcbiAgICAgICAgICAgIGFiYnJCID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byBiaWxsaW9uc1xuICAgICAgICAgICAgYWJiclQgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIHRyaWxsaW9uc1xuICAgICAgICAgICAgYWJickZvcmNlID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgYnl0ZXMgPSAnJyxcbiAgICAgICAgICAgIG9yZCA9ICcnLFxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnModmFsdWUpLFxuICAgICAgICAgICAgc3VmZml4ZXMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXSxcbiAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgIHBvd2VyLFxuICAgICAgICAgICAgdyxcbiAgICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAgIHRob3VzYW5kcyxcbiAgICAgICAgICAgIGQgPSAnJyxcbiAgICAgICAgICAgIG5lZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIG51bWJlciBpcyB6ZXJvIGFuZCBhIGN1c3RvbSB6ZXJvIGZvcm1hdCBoYXMgYmVlbiBzZXRcbiAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIHplcm9Gb3JtYXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvRm9ybWF0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2VlIGlmIHdlIHNob3VsZCB1c2UgcGFyZW50aGVzZXMgZm9yIG5lZ2F0aXZlIG51bWJlciBvciBpZiB3ZSBzaG91bGQgcHJlZml4IHdpdGggYSBzaWduXG4gICAgICAgICAgICAvLyBpZiBib3RoIGFyZSBwcmVzZW50IHdlIGRlZmF1bHQgdG8gcGFyZW50aGVzZXNcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignKCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBuZWdQID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignKycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXCsvZywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWUgaWYgYWJicmV2aWF0aW9uIGlzIHdhbnRlZFxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdhJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFiYnJldmlhdGlvbiBpcyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICBhYmJySyA9IGZvcm1hdC5pbmRleE9mKCdhSycpID49IDA7XG4gICAgICAgICAgICAgICAgYWJick0gPSBmb3JtYXQuaW5kZXhPZignYU0nKSA+PSAwO1xuICAgICAgICAgICAgICAgIGFiYnJCID0gZm9ybWF0LmluZGV4T2YoJ2FCJykgPj0gMDtcbiAgICAgICAgICAgICAgICBhYmJyVCA9IGZvcm1hdC5pbmRleE9mKCdhVCcpID49IDA7XG4gICAgICAgICAgICAgICAgYWJickZvcmNlID0gYWJicksgfHwgYWJick0gfHwgYWJickIgfHwgYWJiclQ7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIGEnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgYScsICcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnYScsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWJzID49IE1hdGgucG93KDEwLCAxMikgJiYgIWFiYnJGb3JjZSB8fCBhYmJyVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudHJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgMTIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgTWF0aC5wb3coMTAsIDEyKSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDkpICYmICFhYmJyRm9yY2UgfHwgYWJickIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMuYmlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCA5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCA5KSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDYpICYmICFhYmJyRm9yY2UgfHwgYWJick0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMubWlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCA2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCA2KSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDMpICYmICFhYmJyRm9yY2UgfHwgYWJickspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhvdXNhbmRcbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRob3VzYW5kO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VlIGlmIHdlIGFyZSBmb3JtYXR0aW5nIGJ5dGVzXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ2InKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIGInKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnIGInLCAnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ2InLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChwb3dlciA9IDA7IHBvd2VyIDw9IHN1ZmZpeGVzLmxlbmd0aDsgcG93ZXIrKykge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLnBvdygxMDI0LCBwb3dlcik7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IE1hdGgucG93KDEwMjQsIHBvd2VyKzEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPCBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMgKyBzdWZmaXhlc1twb3dlcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VlIGlmIG9yZGluYWwgaXMgd2FudGVkXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ28nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIG8nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyBvJywgJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdvJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9yZCA9IG9yZCArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLm9yZGluYWwodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ1suXScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvcHREZWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdbLl0nLCAnLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3ID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpWzBdO1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gZm9ybWF0LnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICB0aG91c2FuZHMgPSBmb3JtYXQuaW5kZXhPZignLCcpO1xuXG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbi5pbmRleE9mKCdbJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24ucmVwbGFjZSgnXScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uLnNwbGl0KCdbJyk7XG4gICAgICAgICAgICAgICAgICAgIGQgPSB0b0ZpeGVkKHZhbHVlLCAocHJlY2lzaW9uWzBdLmxlbmd0aCArIHByZWNpc2lvblsxXS5sZW5ndGgpLCByb3VuZGluZ0Z1bmN0aW9uLCBwcmVjaXNpb25bMV0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0gdG9GaXhlZCh2YWx1ZSwgcHJlY2lzaW9uLmxlbmd0aCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdyA9IGQuc3BsaXQoJy4nKVswXTtcblxuICAgICAgICAgICAgICAgIGlmIChkLnNwbGl0KCcuJylbMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLmRlY2ltYWwgKyBkLnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHREZWMgJiYgTnVtYmVyKGQuc2xpY2UoMSkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHcgPSB0b0ZpeGVkKHZhbHVlLCBudWxsLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9ybWF0IG51bWJlclxuICAgICAgICAgICAgaWYgKHcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB3ID0gdy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBuZWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhvdXNhbmRzID4gLTEpIHtcbiAgICAgICAgICAgICAgICB3ID0gdy50b1N0cmluZygpLnJlcGxhY2UoLyhcXGQpKD89KFxcZHszfSkrKD8hXFxkKSkvZywgJyQxJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmRlbGltaXRlcnMudGhvdXNhbmRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICB3ID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoKG5lZ1AgJiYgbmVnKSA/ICcoJyA6ICcnKSArICgoIW5lZ1AgJiYgbmVnKSA/ICctJyA6ICcnKSArICgoIW5lZyAmJiBzaWduZWQpID8gJysnIDogJycpICsgdyArIGQgKyAoKG9yZCkgPyBvcmQgOiAnJykgKyAoKGFiYnIpID8gYWJiciA6ICcnKSArICgoYnl0ZXMpID8gYnl0ZXMgOiAnJykgKyAoKG5lZ1AgJiYgbmVnKSA/ICcpJyA6ICcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgVG9wIExldmVsIEZ1bmN0aW9uc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIG51bWVyYWwgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKG51bWVyYWwuaXNOdW1lcmFsKGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAwIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICghTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBudW1lcmFsLmZuLnVuZm9ybWF0KGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTnVtZXJhbChOdW1iZXIoaW5wdXQpKTtcbiAgICB9O1xuXG4gICAgLy8gdmVyc2lvbiBudW1iZXJcbiAgICBudW1lcmFsLnZlcnNpb24gPSBWRVJTSU9OO1xuXG4gICAgLy8gY29tcGFyZSBudW1lcmFsIG9iamVjdFxuICAgIG51bWVyYWwuaXNOdW1lcmFsID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtZXJhbDtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbGFuZ3VhZ2VzIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxhbmd1YWdlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxhbmd1YWdlIGtleS5cbiAgICBudW1lcmFsLmxhbmd1YWdlID0gZnVuY3Rpb24gKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudExhbmd1YWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSAmJiAhdmFsdWVzKSB7XG4gICAgICAgICAgICBpZighbGFuZ3VhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2UgOiAnICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRMYW5ndWFnZSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMgfHwgIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICBsb2FkTGFuZ3VhZ2Uoa2V5LCB2YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWVyYWw7XG4gICAgfTtcbiAgICBcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgbG9hZGVkIGxhbmd1YWdlIGRhdGEuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnRcbiAgICAvLyBnbG9iYWwgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgIG51bWVyYWwubGFuZ3VhZ2VEYXRhID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2UgOiAnICsga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlc1trZXldO1xuICAgIH07XG5cbiAgICBudW1lcmFsLmxhbmd1YWdlKCdlbicsIHtcbiAgICAgICAgZGVsaW1pdGVyczoge1xuICAgICAgICAgICAgdGhvdXNhbmRzOiAnLCcsXG4gICAgICAgICAgICBkZWNpbWFsOiAnLidcbiAgICAgICAgfSxcbiAgICAgICAgYWJicmV2aWF0aW9uczoge1xuICAgICAgICAgICAgdGhvdXNhbmQ6ICdrJyxcbiAgICAgICAgICAgIG1pbGxpb246ICdtJyxcbiAgICAgICAgICAgIGJpbGxpb246ICdiJyxcbiAgICAgICAgICAgIHRyaWxsaW9uOiAndCdcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMDtcbiAgICAgICAgICAgIHJldHVybiAofn4gKG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVuY3k6IHtcbiAgICAgICAgICAgIHN5bWJvbDogJyQnXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG51bWVyYWwuemVyb0Zvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgemVyb0Zvcm1hdCA9IHR5cGVvZihmb3JtYXQpID09PSAnc3RyaW5nJyA/IGZvcm1hdCA6IG51bGw7XG4gICAgfTtcblxuICAgIG51bWVyYWwuZGVmYXVsdEZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgZGVmYXVsdEZvcm1hdCA9IHR5cGVvZihmb3JtYXQpID09PSAnc3RyaW5nJyA/IGZvcm1hdCA6ICcwLjAnO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEhlbHBlcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBsb2FkTGFuZ3VhZ2Uoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgbGFuZ3VhZ2VzW2tleV0gPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBGbG9hdGluZy1wb2ludCBoZWxwZXJzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gVGhlIGZsb2F0aW5nLXBvaW50IGhlbHBlciBmdW5jdGlvbnMgYW5kIGltcGxlbWVudGF0aW9uXG4gICAgLy8gYm9ycm93cyBoZWF2aWx5IGZyb20gc2luZnVsLmpzOiBodHRwOi8vZ3VpcG4uZ2l0aHViLmlvL3NpbmZ1bC5qcy9cblxuICAgIC8qKlxuICAgICAqIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdFxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L1JlZHVjZSNDb21wYXRpYmlsaXR5XG4gICAgICovXG4gICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBBcnJheS5wcm90b3R5cGUucmVkdWNlKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9pbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG51bGwgPT09IHRoaXMgfHwgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIG1vbWVudCBhbGwgbW9kZXJuIGJyb3dzZXJzLCB0aGF0IHN1cHBvcnQgc3RyaWN0IG1vZGUsIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgQXJyYXkucHJvdG90eXBlLnJlZHVjZS4gRm9yIGluc3RhbmNlLCBJRThcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBzdXBwb3J0IHN0cmljdCBtb2RlLCBzbyB0aGlzIGNoZWNrIGlzIGFjdHVhbGx5IHVzZWxlc3MuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBpc1ZhbHVlU2V0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0X2luaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICBpc1ZhbHVlU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGxlbmd0aCA+IGluZGV4OyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlLCB0aGlzW2luZGV4XSwgaW5kZXgsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsdWVTZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbXVsdGlwbGllciBuZWNlc3NhcnkgdG8gbWFrZSB4ID49IDEsXG4gICAgICogZWZmZWN0aXZlbHkgZWxpbWluYXRpbmcgbWlzY2FsY3VsYXRpb25zIGNhdXNlZCBieVxuICAgICAqIGZpbml0ZSBwcmVjaXNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbGllcih4KSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwLCBwYXJ0c1sxXS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cywgcmV0dXJucyB0aGUgbWF4aW11bVxuICAgICAqIG11bHRpcGxpZXIgdGhhdCBtdXN0IGJlIHVzZWQgdG8gbm9ybWFsaXplIGFuIG9wZXJhdGlvbiBpbnZvbHZpbmdcbiAgICAgKiBhbGwgb2YgdGhlbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3JyZWN0aW9uRmFjdG9yKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhcmdzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgICAgICAgICAgdmFyIG1wID0gbXVsdGlwbGllcihwcmV2KSxcbiAgICAgICAgICAgICAgICBtbiA9IG11bHRpcGxpZXIobmV4dCk7XG4gICAgICAgIHJldHVybiBtcCA+IG1uID8gbXAgOiBtbjtcbiAgICAgICAgfSwgLUluZmluaXR5KTtcbiAgICB9ICAgICAgICBcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBOdW1lcmFsIFByb3RvdHlwZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgbnVtZXJhbC5mbiA9IE51bWVyYWwucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNsb25lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0IDogZnVuY3Rpb24gKGlucHV0U3RyaW5nLCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtZXJhbCh0aGlzLCBcbiAgICAgICAgICAgICAgICAgIGlucHV0U3RyaW5nID8gaW5wdXRTdHJpbmcgOiBkZWZhdWx0Rm9ybWF0LCBcbiAgICAgICAgICAgICAgICAgIChyb3VuZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpID8gcm91bmRpbmdGdW5jdGlvbiA6IE1hdGgucm91bmRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bmZvcm1hdCA6IGZ1bmN0aW9uIChpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dFN0cmluZykgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7IFxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFN0cmluZzsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5mb3JtYXROdW1lcmFsKHRoaXMsIGlucHV0U3RyaW5nID8gaW5wdXRTdHJpbmcgOiBkZWZhdWx0Rm9ybWF0KTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZU9mIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IGNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtICsgY29yckZhY3RvciAqIGN1cnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt0aGlzLl92YWx1ZSwgdmFsdWVdLnJlZHVjZShjYmFjaywgMCkgLyBjb3JyRmFjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VidHJhY3QgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3Rvci5jYWxsKG51bGwsIHRoaXMuX3ZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gLSBjb3JyRmFjdG9yICogY3VycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3ZhbHVlXS5yZWR1Y2UoY2JhY2ssIHRoaXMuX3ZhbHVlICogY29yckZhY3RvcikgLyBjb3JyRmFjdG9yOyAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbXVsdGlwbHkgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3Vycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY2N1bSAqIGNvcnJGYWN0b3IpICogKGN1cnIgKiBjb3JyRmFjdG9yKSAvXG4gICAgICAgICAgICAgICAgICAgIChjb3JyRmFjdG9yICogY29yckZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt0aGlzLl92YWx1ZSwgdmFsdWVdLnJlZHVjZShjYmFjaywgMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaXZpZGUgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3Vycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY2N1bSAqIGNvcnJGYWN0b3IpIC8gKGN1cnIgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3RoaXMuX3ZhbHVlLCB2YWx1ZV0ucmVkdWNlKGNiYWNrKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpZmZlcmVuY2UgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhudW1lcmFsKHRoaXMuX3ZhbHVlKS5zdWJ0cmFjdCh2YWx1ZSkudmFsdWUoKSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEV4cG9zaW5nIE51bWVyYWxcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvLyBDb21tb25KUyBtb2R1bGUgaXMgZGVmaW5lZFxuICAgIGlmIChoYXNNb2R1bGUpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBudW1lcmFsO1xuICAgIH1cblxuICAgIC8qZ2xvYmFsIGVuZGVyOmZhbHNlICovXG4gICAgaWYgKHR5cGVvZiBlbmRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gaGVyZSwgYHRoaXNgIG1lYW5zIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyXG4gICAgICAgIC8vIGFkZCBgbnVtZXJhbGAgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAgICAgICAvLyBmb3IgQ2xvc3VyZSBDb21waWxlciAnYWR2YW5jZWQnIG1vZGVcbiAgICAgICAgdGhpc1snbnVtZXJhbCddID0gbnVtZXJhbDtcbiAgICB9XG5cbiAgICAvKmdsb2JhbCBkZWZpbmU6ZmFsc2UgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWw7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pLmNhbGwodGhpcyk7XG4iLCIvKiBudmQzIHZlcnNpb24gMS43LjEoaHR0cHM6Ly9naXRodWIuY29tL25vdnVzL252ZDMpIDIwMTUtMDItMDUgKi9cbihmdW5jdGlvbigpe1xuXG4vLyBzZXQgdXAgbWFpbiBudiBvYmplY3Qgb24gd2luZG93XG52YXIgbnYgPSB3aW5kb3cubnYgfHwge307XG53aW5kb3cubnYgPSBudjtcblxuLy8gdGhlIG1ham9yIGdsb2JhbCBvYmplY3RzIHVuZGVyIHRoZSBudiBuYW1lc3BhY2Vcbm52LmRldiA9IGZhbHNlOyAvL3NldCBmYWxzZSB3aGVuIGluIHByb2R1Y3Rpb25cbm52LnRvb2x0aXAgPSBudi50b29sdGlwIHx8IHt9OyAvLyBGb3IgdGhlIHRvb2x0aXAgc3lzdGVtXG5udi51dGlscyA9IG52LnV0aWxzIHx8IHt9OyAvLyBVdGlsaXR5IHN1YnN5c3RlbVxubnYubW9kZWxzID0gbnYubW9kZWxzIHx8IHt9OyAvL3N0b3JlcyBhbGwgdGhlIHBvc3NpYmxlIG1vZGVscy9jb21wb25lbnRzXG5udi5jaGFydHMgPSB7fTsgLy9zdG9yZXMgYWxsIHRoZSByZWFkeSB0byB1c2UgY2hhcnRzXG5udi5ncmFwaHMgPSBbXTsgLy9zdG9yZXMgYWxsIHRoZSBncmFwaHMgY3VycmVudGx5IG9uIHRoZSBwYWdlXG5udi5sb2dzID0ge307IC8vc3RvcmVzIHNvbWUgc3RhdGlzdGljcyBhbmQgcG90ZW50aWFsIGVycm9yIG1lc3NhZ2VzXG5cbm52LmRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3JlbmRlcl9zdGFydCcsICdyZW5kZXJfZW5kJyk7XG5cbi8vIEZ1bmN0aW9uIGJpbmQgcG9seWZpbGxcbi8vIE5lZWRlZCBPTkxZIGZvciBwaGFudG9tSlMgYXMgaXQncyBtaXNzaW5nIHVudGlsIHZlcnNpb24gMi4wIHdoaWNoIGlzIHVucmVsZWFzZWQgYXMgb2YgdGhpcyBjb21tZW50XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMDUyMlxuLy8gaHR0cDovL2thbmdheC5naXRodWIuaW8vY29tcGF0LXRhYmxlL2VzNS8jRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbi8vIHBoYW50b21KUyBpcyB1c2VkIGZvciBydW5uaW5nIHRoZSB0ZXN0IHN1aXRlXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAob1RoaXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNSBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICAgICAgICBmTk9QID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgICBmQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgJiYgb1RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBvVGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICAgICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG4gICAgICAgIHJldHVybiBmQm91bmQ7XG4gICAgfTtcbn1cblxuLy8gIERldmVsb3BtZW50IHJlbmRlciB0aW1lcnMgLSBkaXNhYmxlZCBpZiBkZXYgPSBmYWxzZVxuaWYgKG52LmRldikge1xuICAgIG52LmRpc3BhdGNoLm9uKCdyZW5kZXJfc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIG52LmxvZ3Muc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgfSk7XG5cbiAgICBudi5kaXNwYXRjaC5vbigncmVuZGVyX2VuZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgbnYubG9ncy5lbmRUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgICAgIG52LmxvZ3MudG90YWxUaW1lID0gbnYubG9ncy5lbmRUaW1lIC0gbnYubG9ncy5zdGFydFRpbWU7XG4gICAgICAgIG52LmxvZygndG90YWwnLCBudi5sb2dzLnRvdGFsVGltZSk7IC8vIHVzZWQgZm9yIGRldmVsb3BtZW50LCB0byBrZWVwIHRyYWNrIG9mIGdyYXBoIGdlbmVyYXRpb24gdGltZXNcbiAgICB9KTtcbn1cblxuLy8gTG9ncyBhbGwgYXJndW1lbnRzLCBhbmQgcmV0dXJucyB0aGUgbGFzdCBzbyB5b3UgY2FuIHRlc3QgdGhpbmdzIGluIHBsYWNlXG4vLyBOb3RlOiBpbiBJRTggY29uc29sZS5sb2cgaXMgYW4gb2JqZWN0IG5vdCBhIGZ1bmN0aW9uLCBhbmQgaWYgbW9kZXJuaXpyIGlzIHVzZWRcbi8vIHRoZW4gY2FsbGluZyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB3aXRoIHdpdGggYW55dGhpbmcgb3RoZXIgdGhhbiBhIGZ1bmN0aW9uXG4vLyBjYXVzZXMgYSBUeXBlRXJyb3IgdG8gYmUgdGhyb3duLlxubnYubG9nID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKG52LmRldiAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZyAmJiBjb25zb2xlLmxvZy5hcHBseSlcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICBlbHNlIGlmIChudi5kZXYgJiYgd2luZG93LmNvbnNvbGUgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09IFwiZnVuY3Rpb25cIiAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICAgICAgICB2YXIgbG9nID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSk7XG4gICAgICAgIGxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbn07XG5cbi8vIHByaW50IGNvbnNvbGUgd2FybmluZywgc2hvdWxkIGJlIHVzZWQgYnkgZGVwcmVjYXRlZCBmdW5jdGlvbnNcbm52LmRlcHJlY2F0ZWQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKG52LmRldiAmJiBjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2AnICsgbmFtZSArICdgIGhhcyBiZWVuIGRlcHJlY2F0ZWQuJyk7XG4gICAgfVxufTtcblxuLy8gcmVuZGVyIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcXVldWUgdXAgY2hhcnQgcmVuZGVyaW5nXG4vLyBpbiBub24tYmxvY2tpbmcgdGltZW91dCBmdW5jdGlvbnNcbm52LnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihzdGVwKSB7XG4gICAgLy8gbnVtYmVyIG9mIGdyYXBocyB0byBnZW5lcmF0ZSBpbiBlYWNoIHRpbWVvdXQgbG9vcFxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICBudi5yZW5kZXIuYWN0aXZlID0gdHJ1ZTtcbiAgICBudi5kaXNwYXRjaC5yZW5kZXJfc3RhcnQoKTtcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGFydCwgZ3JhcGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwICYmIChncmFwaCA9IG52LnJlbmRlci5xdWV1ZVtpXSk7IGkrKykge1xuICAgICAgICAgICAgY2hhcnQgPSBncmFwaC5nZW5lcmF0ZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBncmFwaC5jYWxsYmFjayA9PSB0eXBlb2YoRnVuY3Rpb24pKSBncmFwaC5jYWxsYmFjayhjaGFydCk7XG4gICAgICAgICAgICBudi5ncmFwaHMucHVzaChjaGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICBudi5yZW5kZXIucXVldWUuc3BsaWNlKDAsIGkpO1xuXG4gICAgICAgIGlmIChudi5yZW5kZXIucXVldWUubGVuZ3RoKSBzZXRUaW1lb3V0KGFyZ3VtZW50cy5jYWxsZWUsIDApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG52LmRpc3BhdGNoLnJlbmRlcl9lbmQoKTtcbiAgICAgICAgICAgIG52LnJlbmRlci5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIDApO1xufTtcblxubnYucmVuZGVyLmFjdGl2ZSA9IGZhbHNlO1xubnYucmVuZGVyLnF1ZXVlID0gW107XG5cbi8vIG1haW4gZnVuY3Rpb24gdG8gdXNlIHdoZW4gYWRkaW5nIGEgbmV3IGdyYXBoLCBzZWUgZXhhbXBsZXNcbm52LmFkZEdyYXBoID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IHR5cGVvZihGdW5jdGlvbikpIHtcbiAgICAgICAgb2JqID0ge2dlbmVyYXRlOiBhcmd1bWVudHNbMF0sIGNhbGxiYWNrOiBhcmd1bWVudHNbMV19O1xuICAgIH1cblxuICAgIG52LnJlbmRlci5xdWV1ZS5wdXNoKG9iaik7XG5cbiAgICBpZiAoIW52LnJlbmRlci5hY3RpdmUpIHtcbiAgICAgICAgbnYucmVuZGVyKCk7XG4gICAgfVxufTsvKiBVdGlsaXR5IGNsYXNzIHRvIGhhbmRsZSBjcmVhdGlvbiBvZiBhbiBpbnRlcmFjdGl2ZSBsYXllci5cbiBUaGlzIHBsYWNlcyBhIHJlY3RhbmdsZSBvbiB0b3Agb2YgdGhlIGNoYXJ0LiBXaGVuIHlvdSBtb3VzZSBtb3ZlIG92ZXIgaXQsIGl0IHNlbmRzIGEgZGlzcGF0Y2hcbiBjb250YWluaW5nIHRoZSBYLWNvb3JkaW5hdGUuIEl0IGNhbiBhbHNvIHJlbmRlciBhIHZlcnRpY2FsIGxpbmUgd2hlcmUgdGhlIG1vdXNlIGlzIGxvY2F0ZWQuXG5cbiBkaXNwYXRjaC5lbGVtZW50TW91c2Vtb3ZlIGlzIHRoZSBpbXBvcnRhbnQgZXZlbnQgdG8gbGF0Y2ggb250by4gIEl0IGlzIGZpcmVkIHdoZW5ldmVyIHRoZSBtb3VzZSBtb3ZlcyBvdmVyXG4gdGhlIHJlY3RhbmdsZS4gVGhlIGRpc3BhdGNoIGlzIGdpdmVuIG9uZSBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIG1vdXNlWC9ZIGxvY2F0aW9uLlxuIEl0IGFsc28gaGFzICdwb2ludFhWYWx1ZScsIHdoaWNoIGlzIHRoZSBjb252ZXJzaW9uIG9mIG1vdXNlWCB0byB0aGUgeC1heGlzIHNjYWxlLlxuICovXG5udi5pbnRlcmFjdGl2ZUd1aWRlbGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHRvb2x0aXAgPSBudi5tb2RlbHMudG9vbHRpcCgpO1xuXG4gICAgLy9QdWJsaWMgc2V0dGluZ3NcbiAgICB2YXIgd2lkdGggPSBudWxsO1xuICAgIHZhciBoZWlnaHQgPSBudWxsO1xuXG4gICAgLy9QbGVhc2UgcGFzcyBpbiB0aGUgYm91bmRpbmcgY2hhcnQncyB0b3AgYW5kIGxlZnQgbWFyZ2luc1xuICAgIC8vVGhpcyBpcyBpbXBvcnRhbnQgZm9yIGNhbGN1bGF0aW5nIHRoZSBjb3JyZWN0IG1vdXNlWC9ZIHBvc2l0aW9ucy5cbiAgICB2YXIgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMH1cbiAgICAgICAgLCB4U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIHlTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnZWxlbWVudE1vdXNlbW92ZScsICdlbGVtZW50TW91c2VvdXQnLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxjbGljaycpXG4gICAgICAgICwgc2hvd0d1aWRlTGluZSA9IHRydWU7XG4gICAgLy9NdXN0IHBhc3MgaW4gdGhlIGJvdW5kaW5nIGNoYXJ0J3MgPHN2Zz4gY29udGFpbmVyLlxuICAgIC8vVGhlIG1vdXNlbW92ZSBldmVudCBpcyBhdHRhY2hlZCB0byB0aGlzIGNvbnRhaW5lci5cbiAgICB2YXIgc3ZnQ29udGFpbmVyID0gbnVsbDtcblxuICAgIC8vIGNoZWNrIGlmIElFIGJ5IGxvb2tpbmcgZm9yIGFjdGl2ZVhcbiAgICB2YXIgaXNNU0lFID0gXCJBY3RpdmVYT2JqZWN0XCIgaW4gd2luZG93O1xuXG5cbiAgICBmdW5jdGlvbiBsYXllcihzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCB8fCA5NjApLCBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IDQwMCk7XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoXCJnLm52LXdyYXAubnYtaW50ZXJhY3RpdmVMaW5lTGF5ZXJcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcIiBudi13cmFwIG52LWludGVyYWN0aXZlTGluZUxheWVyXCIpO1xuICAgICAgICAgICAgd3JhcEVudGVyLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsXCJudi1pbnRlcmFjdGl2ZUd1aWRlTGluZVwiKTtcblxuICAgICAgICAgICAgaWYgKCFzdmdDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vdXNlSGFuZGxlcigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZDNtb3VzZSA9IGQzLm1vdXNlKHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBtb3VzZVggPSBkM21vdXNlWzBdO1xuICAgICAgICAgICAgICAgIHZhciBtb3VzZVkgPSBkM21vdXNlWzFdO1xuICAgICAgICAgICAgICAgIHZhciBzdWJ0cmFjdE1hcmdpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIG1vdXNlT3V0QW55UmVhc29uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGlzTVNJRSkge1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgRDMuanMgKG9yIG1heWJlIFNWRy5nZXRTY3JlZW5DVE0pIGhhcyBhIG5hc3R5IGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbiAgICAgICAgICAgICAgICAgICAgIGQzLm1vdXNlKCkgcmV0dXJucyBpbmNvcnJlY3QgWCxZIG1vdXNlIGNvb3JkaW5hdGVzIHdoZW4gbW91c2UgbW92aW5nXG4gICAgICAgICAgICAgICAgICAgICBvdmVyIGEgcmVjdCBpbiBJRSAxMC5cbiAgICAgICAgICAgICAgICAgICAgIEhvd2V2ZXIsIGQzLmV2ZW50Lm9mZnNldFgvWSBhbHNvIHJldHVybnMgdGhlIG1vdXNlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZSB0byB0aGUgdHJpZ2dlcmluZyA8cmVjdD4uIFNvIHdlIHVzZSBvZmZzZXRYL1kgb24gSUUuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBtb3VzZVggPSBkMy5ldmVudC5vZmZzZXRYO1xuICAgICAgICAgICAgICAgICAgICBtb3VzZVkgPSBkMy5ldmVudC5vZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICBPbiBJRSwgaWYgeW91IGF0dGFjaCBhIG1vdXNlIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSA8c3ZnPiBjb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgICBpdCB3aWxsIGFjdHVhbGx5IHRyaWdnZXIgaXQgZm9yIGFsbCB0aGUgY2hpbGQgZWxlbWVudHMgKGxpa2UgPHBhdGg+LCA8Y2lyY2xlPiwgZXRjKS5cbiAgICAgICAgICAgICAgICAgICAgIFdoZW4gdGhpcyBoYXBwZW5zIG9uIElFLCB0aGUgb2Zmc2V0WC9ZIGlzIHNldCB0byB3aGVyZSBldmVyIHRoZSBjaGlsZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICBpcyBsb2NhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgQXMgYSByZXN1bHQsIHdlIGRvIE5PVCBuZWVkIHRvIHN1YnRyYWN0IG1hcmdpbnMgdG8gZmlndXJlIG91dCB0aGUgbW91c2UgWC9ZXG4gICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiB1bmRlciB0aGlzIHNjZW5hcmlvLiBSZW1vdmluZyB0aGUgbGluZSBiZWxvdyAqd2lsbCogY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgIHRoZSBpbnRlcmFjdGl2ZSBsYXllciB0byBub3Qgd29yayByaWdodCBvbiBJRS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmKGQzLmV2ZW50LnRhcmdldC50YWdOYW1lICE9PSBcInN2Z1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdE1hcmdpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGQzLmV2ZW50LnRhcmdldC5jbGFzc05hbWUuYmFzZVZhbC5tYXRjaChcIm52LWxlZ2VuZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VPdXRBbnlSZWFzb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihzdWJ0cmFjdE1hcmdpbikge1xuICAgICAgICAgICAgICAgICAgICBtb3VzZVggLT0gbWFyZ2luLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlWSAtPSBtYXJnaW4udG9wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIElmIG1vdXNlWC9ZIGlzIG91dHNpZGUgb2YgdGhlIGNoYXJ0J3MgYm91bmRzLFxuICAgICAgICAgICAgICAgICB0cmlnZ2VyIGEgbW91c2VPdXQgZXZlbnQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlWCA8IDAgfHwgbW91c2VZIDwgMFxuICAgICAgICAgICAgICAgICAgICB8fCBtb3VzZVggPiBhdmFpbGFibGVXaWR0aCB8fCBtb3VzZVkgPiBhdmFpbGFibGVIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfHwgKGQzLmV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgZDMuZXZlbnQucmVsYXRlZFRhcmdldC5vd25lclNWR0VsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgfHwgbW91c2VPdXRBbnlSZWFzb25cbiAgICAgICAgICAgICAgICAgICAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTVNJRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQzLmV2ZW50LnJlbGF0ZWRUYXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBkMy5ldmVudC5yZWxhdGVkVGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgZDMuZXZlbnQucmVsYXRlZFRhcmdldC5jbGFzc05hbWUubWF0Y2godG9vbHRpcC5udlBvaW50ZXJFdmVudHNDbGFzcykpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VYOiBtb3VzZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZVk6IG1vdXNlWVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIucmVuZGVyR3VpZGVMaW5lKG51bGwpOyAvL2hpZGUgdGhlIGd1aWRlbGluZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50WFZhbHVlID0geFNjYWxlLmludmVydChtb3VzZVgpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW1vdmUoe1xuICAgICAgICAgICAgICAgICAgICBtb3VzZVg6IG1vdXNlWCxcbiAgICAgICAgICAgICAgICAgICAgbW91c2VZOiBtb3VzZVksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50WFZhbHVlOiBwb2ludFhWYWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9JZiB1c2VyIGRvdWJsZSBjbGlja3MgdGhlIGxheWVyLCBmaXJlIGEgZWxlbWVudERibGNsaWNrXG4gICAgICAgICAgICAgICAgaWYgKGQzLmV2ZW50LnR5cGUgPT09IFwiZGJsY2xpY2tcIikge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50RGJsY2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VYOiBtb3VzZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZVk6IG1vdXNlWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50WFZhbHVlOiBwb2ludFhWYWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB1c2VyIHNpbmdsZSBjbGlja3MgdGhlIGxheWVyLCBmaXJlIGVsZW1lbnRDbGlja1xuICAgICAgICAgICAgICAgIGlmIChkMy5ldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZVg6IG1vdXNlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlWTogbW91c2VZLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRYVmFsdWU6IHBvaW50WFZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3ZnQ29udGFpbmVyXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2Vtb3ZlXCIsbW91c2VIYW5kbGVyLCB0cnVlKVxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIgLG1vdXNlSGFuZGxlcix0cnVlKVxuICAgICAgICAgICAgICAgIC5vbihcImRibGNsaWNrXCIgLG1vdXNlSGFuZGxlcilcbiAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCBtb3VzZUhhbmRsZXIpXG4gICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIC8vRHJhd3MgYSB2ZXJ0aWNhbCBndWlkZWxpbmUgYXQgdGhlIGdpdmVuIFggcG9zdGlvbi5cbiAgICAgICAgICAgIGxheWVyLnJlbmRlckd1aWRlTGluZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNob3dHdWlkZUxpbmUpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHdyYXAuc2VsZWN0KFwiLm52LWludGVyYWN0aXZlR3VpZGVMaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKCh4ICE9IG51bGwpID8gW252LnV0aWxzLk5hTnRvWmVybyh4KV0gOiBbXSwgU3RyaW5nKTtcblxuICAgICAgICAgICAgICAgIGxpbmUuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibnYtZ3VpZGVsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDt9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7fSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCBhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwwKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBsaW5lLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsYXllci5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGxheWVyLnRvb2x0aXAgPSB0b29sdGlwO1xuXG4gICAgbGF5ZXIubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJnaW47XG4gICAgICAgIG1hcmdpbi50b3AgICAgPSB0eXBlb2YgXy50b3AgICAgIT0gJ3VuZGVmaW5lZCcgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfTtcblxuICAgIGxheWVyLndpZHRoID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aWR0aDtcbiAgICAgICAgd2lkdGggPSBfO1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfTtcblxuICAgIGxheWVyLmhlaWdodCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaGVpZ2h0O1xuICAgICAgICBoZWlnaHQgPSBfO1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfTtcblxuICAgIGxheWVyLnhTY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geFNjYWxlO1xuICAgICAgICB4U2NhbGUgPSBfO1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfTtcblxuICAgIGxheWVyLnNob3dHdWlkZUxpbmUgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dHdWlkZUxpbmU7XG4gICAgICAgIHNob3dHdWlkZUxpbmUgPSBfO1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfTtcblxuICAgIGxheWVyLnN2Z0NvbnRhaW5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3ZnQ29udGFpbmVyO1xuICAgICAgICBzdmdDb250YWluZXIgPSBfO1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfTtcblxuICAgIHJldHVybiBsYXllcjtcbn07XG5cbi8qIFV0aWxpdHkgY2xhc3MgdGhhdCB1c2VzIGQzLmJpc2VjdCB0byBmaW5kIHRoZSBpbmRleCBpbiBhIGdpdmVuIGFycmF5LCB3aGVyZSBhIHNlYXJjaCB2YWx1ZSBjYW4gYmUgaW5zZXJ0ZWQuXG4gVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBub3JtYWwgYmlzZWN0TGVmdDsgdGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgbmVhcmVzdCBpbmRleCB0byBpbnNlcnQgdGhlIHNlYXJjaCB2YWx1ZS5cblxuIEZvciBpbnN0YW5jZSwgbGV0cyBzYXkgeW91ciBhcnJheSBpcyBbMSwyLDMsNSwxMCwzMF0sIGFuZCB5b3Ugc2VhcmNoIGZvciAyOC5cbiBOb3JtYWwgZDMuYmlzZWN0TGVmdCB3aWxsIHJldHVybiA0LCBiZWNhdXNlIDI4IGlzIGluc2VydGVkIGFmdGVyIHRoZSBudW1iZXIgMTAuICBCdXQgaW50ZXJhY3RpdmVCaXNlY3Qgd2lsbCByZXR1cm4gNVxuIGJlY2F1c2UgMjggaXMgY2xvc2VyIHRvIDMwIHRoYW4gMTAuXG5cbiBVbml0IHRlc3RzIGNhbiBiZSBmb3VuZCBpbjogaW50ZXJhY3RpdmVCaXNlY3RUZXN0Lmh0bWxcblxuIEhhcyB0aGUgZm9sbG93aW5nIGtub3duIGlzc3VlczpcbiAqIFdpbGwgbm90IHdvcmsgaWYgdGhlIGRhdGEgcG9pbnRzIG1vdmUgYmFja3dhcmRzIChpZSwgMTAsOSw4LDcsIGV0Yykgb3IgaWYgdGhlIGRhdGEgcG9pbnRzIGFyZSBpbiByYW5kb20gb3JkZXIuXG4gKiBXb24ndCB3b3JrIGlmIHRoZXJlIGFyZSBkdXBsaWNhdGUgeCBjb29yZGluYXRlIHZhbHVlcy5cbiAqL1xubnYuaW50ZXJhY3RpdmVCaXNlY3QgPSBmdW5jdGlvbiAodmFsdWVzLCBzZWFyY2hWYWwsIHhBY2Nlc3Nvcikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICghICh2YWx1ZXMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeEFjY2Vzc29yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHhBY2Nlc3NvciA9IGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgcmV0dXJuIGQueDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiaXNlY3QgPSBkMy5iaXNlY3Rvcih4QWNjZXNzb3IpLmxlZnQ7XG4gICAgdmFyIGluZGV4ID0gZDMubWF4KFswLCBiaXNlY3QodmFsdWVzLHNlYXJjaFZhbCkgLSAxXSk7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHhBY2Nlc3Nvcih2YWx1ZXNbaW5kZXhdLCBpbmRleCk7XG5cbiAgICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3VycmVudFZhbHVlID0gaW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gc2VhcmNoVmFsKSB7XG4gICAgICAgIHJldHVybiBpbmRleDsgLy9mb3VuZCBleGFjdCBtYXRjaFxuICAgIH1cblxuICAgIHZhciBuZXh0SW5kZXggPSBkMy5taW4oW2luZGV4KzEsIHZhbHVlcy5sZW5ndGggLSAxXSk7XG4gICAgdmFyIG5leHRWYWx1ZSA9IHhBY2Nlc3Nvcih2YWx1ZXNbbmV4dEluZGV4XSwgbmV4dEluZGV4KTtcblxuICAgIGlmICh0eXBlb2YgbmV4dFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBuZXh0VmFsdWUgPSBuZXh0SW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKG5leHRWYWx1ZSAtIHNlYXJjaFZhbCkgPj0gTWF0aC5hYnMoY3VycmVudFZhbHVlIC0gc2VhcmNoVmFsKSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5leHRJbmRleFxuICAgIH1cbn07XG5cbi8qXG4gUmV0dXJucyB0aGUgaW5kZXggaW4gdGhlIGFycmF5IFwidmFsdWVzXCIgdGhhdCBpcyBjbG9zZXN0IHRvIHNlYXJjaFZhbC5cbiBPbmx5IHJldHVybnMgYW4gaW5kZXggaWYgc2VhcmNoVmFsIGlzIHdpdGhpbiBzb21lIFwidGhyZXNob2xkXCIuXG4gT3RoZXJ3aXNlLCByZXR1cm5zIG51bGwuXG4gKi9cbm52Lm5lYXJlc3RWYWx1ZUluZGV4ID0gZnVuY3Rpb24gKHZhbHVlcywgc2VhcmNoVmFsLCB0aHJlc2hvbGQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgeURpc3RNYXggPSBJbmZpbml0eSwgaW5kZXhUb0hpZ2hsaWdodCA9IG51bGw7XG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IE1hdGguYWJzKHNlYXJjaFZhbCAtIGQpO1xuICAgICAgICBpZiAoIGRlbHRhIDw9IHlEaXN0TWF4ICYmIGRlbHRhIDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICB5RGlzdE1heCA9IGRlbHRhO1xuICAgICAgICAgICAgaW5kZXhUb0hpZ2hsaWdodCA9IGk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaW5kZXhUb0hpZ2hsaWdodDtcbn07XG4vKiBUb29sdGlwIHJlbmRlcmluZyBtb2RlbCBmb3IgbnZkMyBjaGFydHMuXG4gd2luZG93Lm52Lm1vZGVscy50b29sdGlwIGlzIHRoZSB1cGRhdGVkLG5ldyB3YXkgdG8gcmVuZGVyIHRvb2x0aXBzLlxuXG4gd2luZG93Lm52LnRvb2x0aXAuc2hvdyBpcyB0aGUgb2xkIHRvb2x0aXAgY29kZS5cbiB3aW5kb3cubnYudG9vbHRpcC4qIGFsc28gaGFzIHZhcmlvdXMgaGVscGVyIG1ldGhvZHMuXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB3aW5kb3cubnYudG9vbHRpcCA9IHt9O1xuXG4gICAgLyogTW9kZWwgd2hpY2ggY2FuIGJlIGluc3RhbnRpYXRlZCB0byBoYW5kbGUgdG9vbHRpcCByZW5kZXJpbmcuXG4gICAgIEV4YW1wbGUgdXNhZ2U6XG4gICAgIHZhciB0aXAgPSBudi5tb2RlbHMudG9vbHRpcCgpLmdyYXZpdHkoJ3cnKS5kaXN0YW5jZSgyMylcbiAgICAgLmRhdGEobXlEYXRhT2JqZWN0KTtcblxuICAgICB0aXAoKTsgICAgLy9qdXN0IGludm9rZSB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gdG8gcmVuZGVyIHRvb2x0aXAuXG4gICAgICovXG4gICAgd2luZG93Lm52Lm1vZGVscy50b29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vSFRNTCBjb250ZW50cyBvZiB0aGUgdG9vbHRpcC4gIElmIG51bGwsIHRoZSBjb250ZW50IGlzIGdlbmVyYXRlZCB2aWEgdGhlIGRhdGEgdmFyaWFibGUuXG4gICAgICAgIHZhciBjb250ZW50ID0gbnVsbDtcblxuICAgICAgICAvKlxuICAgICAgICBUb29sdGlwIGRhdGEuIElmIGRhdGEgaXMgZ2l2ZW4gaW4gdGhlIHByb3BlciBmb3JtYXQsIGEgY29uc2lzdGVudCB0b29sdGlwIGlzIGdlbmVyYXRlZC5cbiAgICAgICAgRXhhbXBsZSBGb3JtYXQgb2YgZGF0YTpcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIkRhdGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBcIkF1Z3VzdCAyMDA5XCIsXG4gICAgICAgICAgICBzZXJpZXM6IFtcbiAgICAgICAgICAgICAgICB7a2V5OiBcIlNlcmllcyAxXCIsIHZhbHVlOiBcIlZhbHVlIDFcIiwgY29sb3I6IFwiIzAwMFwifSxcbiAgICAgICAgICAgICAgICB7a2V5OiBcIlNlcmllcyAyXCIsIHZhbHVlOiBcIlZhbHVlIDJcIiwgY29sb3I6IFwiIzAwZlwifVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcblxuICAgICAgICB2YXIgZ3Jhdml0eSA9ICd3JyAgIC8vQ2FuIGJlICduJywncycsJ2UnLCd3Jy4gRGV0ZXJtaW5lcyBob3cgdG9vbHRpcCBpcyBwb3NpdGlvbmVkLlxuICAgICAgICAgICAgLGRpc3RhbmNlID0gNTAgICAvL0Rpc3RhbmNlIHRvIG9mZnNldCB0b29sdGlwIGZyb20gdGhlIG1vdXNlIGxvY2F0aW9uLlxuICAgICAgICAgICAgLHNuYXBEaXN0YW5jZSA9IDI1ICAgLy9Ub2xlcmFuY2UgYWxsb3dlZCBiZWZvcmUgdG9vbHRpcCBpcyBtb3ZlZCBmcm9tIGl0cyBjdXJyZW50IHBvc2l0aW9uIChjcmVhdGVzICdzbmFwcGluZycgZWZmZWN0KVxuICAgICAgICAgICAgLCAgIGZpeGVkVG9wID0gbnVsbCAvL0lmIG5vdCBudWxsLCB0aGlzIGZpeGVzIHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAuXG4gICAgICAgICAgICAsICAgY2xhc3NlcyA9IG51bGwgIC8vQXR0YWNoZXMgYWRkaXRpb25hbCBDU1MgY2xhc3NlcyB0byB0aGUgdG9vbHRpcCBESVYgdGhhdCBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgLCAgIGNoYXJ0Q29udGFpbmVyID0gbnVsbCAgIC8vUGFyZW50IERJViwgb2YgdGhlIFNWRyBDb250YWluZXIgdGhhdCBob2xkcyB0aGUgY2hhcnQuXG4gICAgICAgICAgICAsICAgdG9vbHRpcEVsZW0gPSBudWxsICAvL2FjdHVhbCBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIHRvb2x0aXAuXG4gICAgICAgICAgICAsICAgcG9zaXRpb24gPSB7bGVmdDogbnVsbCwgdG9wOiBudWxsfSAgICAgIC8vUmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAgaW5zaWRlIGNoYXJ0Q29udGFpbmVyLlxuICAgICAgICAgICAgLCAgIGVuYWJsZWQgPSB0cnVlOyAgLy9UcnVlIC0+IHRvb2x0aXBzIGFyZSByZW5kZXJlZC4gRmFsc2UgLT4gZG9uJ3QgcmVuZGVyIHRvb2x0aXBzLlxuXG4gICAgICAgIC8vR2VuZXJhdGVzIGEgdW5pcXVlIGlkIHdoZW4geW91IGNyZWF0ZSBhIG5ldyB0b29sdGlwKCkgb2JqZWN0XG4gICAgICAgIHZhciBpZCA9IFwibnZ0b29sdGlwLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwKTtcblxuICAgICAgICAvL0NTUyBjbGFzcyB0byBzcGVjaWZ5IHdoZXRoZXIgZWxlbWVudCBzaG91bGQgbm90IGhhdmUgbW91c2UgZXZlbnRzLlxuICAgICAgICB2YXIgIG52UG9pbnRlckV2ZW50c0NsYXNzID0gXCJudi1wb2ludGVyLWV2ZW50cy1ub25lXCI7XG5cbiAgICAgICAgLy9Gb3JtYXQgZnVuY3Rpb24gZm9yIHRoZSB0b29sdGlwIHZhbHVlcyBjb2x1bW5cbiAgICAgICAgdmFyIHZhbHVlRm9ybWF0dGVyID0gZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfTtcblxuICAgICAgICAvL0Zvcm1hdCBmdW5jdGlvbiBmb3IgdGhlIHRvb2x0aXAgaGVhZGVyIHZhbHVlLlxuICAgICAgICB2YXIgaGVhZGVyRm9ybWF0dGVyID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9CeSBkZWZhdWx0LCB0aGUgdG9vbHRpcCBtb2RlbCByZW5kZXJzIGEgYmVhdXRpZnVsIHRhYmxlIGluc2lkZSBhIERJVi5cbiAgICAgICAgLy9Zb3UgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaWYgYSBjdXN0b20gdG9vbHRpcCBpcyBkZXNpcmVkLlxuICAgICAgICB2YXIgY29udGVudEdlbmVyYXRvciA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKSk7XG4gICAgICAgICAgICB2YXIgdGhlYWRFbnRlciA9IHRhYmxlLnNlbGVjdEFsbChcInRoZWFkXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW2RdKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpLmFwcGVuZChcInRoZWFkXCIpO1xuXG4gICAgICAgICAgICB0aGVhZEVudGVyLmFwcGVuZChcInRyXCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInRkXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjb2xzcGFuXCIsMylcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwic3Ryb25nXCIpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoXCJ4LXZhbHVlXCIsdHJ1ZSlcbiAgICAgICAgICAgICAgICAuaHRtbChoZWFkZXJGb3JtYXR0ZXIoZC52YWx1ZSkpO1xuXG4gICAgICAgICAgICB2YXIgdGJvZHlFbnRlciA9IHRhYmxlLnNlbGVjdEFsbChcInRib2R5XCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW2RdKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpLmFwcGVuZChcInRib2R5XCIpO1xuXG4gICAgICAgICAgICB2YXIgdHJvd0VudGVyID0gdGJvZHlFbnRlci5zZWxlY3RBbGwoXCJ0clwiKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihwKSB7IHJldHVybiBwLnNlcmllc30pXG4gICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0clwiKVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZChcImhpZ2hsaWdodFwiLCBmdW5jdGlvbihwKSB7IHJldHVybiBwLmhpZ2hsaWdodH0pO1xuXG4gICAgICAgICAgICB0cm93RW50ZXIuYXBwZW5kKFwidGRcIilcbiAgICAgICAgICAgICAgICAuY2xhc3NlZChcImxlZ2VuZC1jb2xvci1ndWlkZVwiLHRydWUpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImRpdlwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgZnVuY3Rpb24ocCkgeyByZXR1cm4gcC5jb2xvcn0pO1xuXG4gICAgICAgICAgICB0cm93RW50ZXIuYXBwZW5kKFwidGRcIilcbiAgICAgICAgICAgICAgICAuY2xhc3NlZChcImtleVwiLHRydWUpXG4gICAgICAgICAgICAgICAgLmh0bWwoZnVuY3Rpb24ocCkge3JldHVybiBwLmtleX0pO1xuXG4gICAgICAgICAgICB0cm93RW50ZXIuYXBwZW5kKFwidGRcIilcbiAgICAgICAgICAgICAgICAuY2xhc3NlZChcInZhbHVlXCIsdHJ1ZSlcbiAgICAgICAgICAgICAgICAuaHRtbChmdW5jdGlvbihwLGkpIHsgcmV0dXJuIHZhbHVlRm9ybWF0dGVyKHAudmFsdWUsaSkgfSk7XG5cblxuICAgICAgICAgICAgdHJvd0VudGVyLnNlbGVjdEFsbChcInRkXCIpLmVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIGlmIChwLmhpZ2hsaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3BhY2l0eVNjYWxlID0gZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKFswLDFdKS5yYW5nZShbXCIjZmZmXCIscC5jb2xvcl0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3BhY2l0eSA9IDAuNjtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJib3JkZXItYm90dG9tLWNvbG9yXCIsIG9wYWNpdHlTY2FsZShvcGFjaXR5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImJvcmRlci10b3AtY29sb3JcIiwgb3BhY2l0eVNjYWxlKG9wYWNpdHkpKVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBodG1sID0gdGFibGUubm9kZSgpLm91dGVySFRNTDtcbiAgICAgICAgICAgIGlmIChkLmZvb3RlciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGh0bWwgKz0gXCI8ZGl2IGNsYXNzPSdmb290ZXInPlwiICsgZC5mb290ZXIgKyBcIjwvZGl2PlwiO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGF0YVNlcmllc0V4aXN0cyA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGlmIChkICYmIGQuc2VyaWVzICYmIGQuc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL0luIHNpdHVhdGlvbnMgd2hlcmUgdGhlIGNoYXJ0IGlzIGluIGEgJ3ZpZXdCb3gnLCByZS1wb3NpdGlvbiB0aGUgdG9vbHRpcCBiYXNlZCBvbiBob3cgZmFyIGNoYXJ0IGlzIHpvb21lZC5cbiAgICAgICAgZnVuY3Rpb24gY29udmVydFZpZXdCb3hSYXRpbygpIHtcbiAgICAgICAgICAgIGlmIChjaGFydENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBzdmcgPSBkMy5zZWxlY3QoY2hhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGlmIChzdmcubm9kZSgpLnRhZ05hbWUgIT09IFwic3ZnXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ZnID0gc3ZnLnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdCb3ggPSAoc3ZnLm5vZGUoKSkgPyBzdmcuYXR0cigndmlld0JveCcpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodmlld0JveCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3Qm94ID0gdmlld0JveC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBwYXJzZUludChzdmcuc3R5bGUoJ3dpZHRoJykpIC8gdmlld0JveFsyXTtcblxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5sZWZ0ID0gcG9zaXRpb24ubGVmdCAqIHJhdGlvO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi50b3AgID0gcG9zaXRpb24udG9wICogcmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9DcmVhdGVzIG5ldyB0b29sdGlwIGNvbnRhaW5lciwgb3IgdXNlcyBleGlzdGluZyBvbmUgb24gRE9NLlxuICAgICAgICBmdW5jdGlvbiBnZXRUb29sdGlwQ29udGFpbmVyKG5ld0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciBib2R5O1xuICAgICAgICAgICAgaWYgKGNoYXJ0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGQzLnNlbGVjdChjaGFydENvbnRhaW5lcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBkMy5zZWxlY3QoXCJib2R5XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gYm9keS5zZWxlY3QoXCIubnZ0b29sdGlwXCIpO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5ub2RlKCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvL0NyZWF0ZSBuZXcgdG9vbHRpcCBkaXYgaWYgaXQgZG9lc24ndCBleGlzdCBvbiBET00uXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gYm9keS5hcHBlbmQoXCJkaXZcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm52dG9vbHRpcCBcIiArIChjbGFzc2VzPyBjbGFzc2VzOiBcInh5LXRvb2x0aXBcIikpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIixpZClcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5ub2RlKCkuaW5uZXJIVE1MID0gbmV3Q29udGVudDtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZShcInRvcFwiLDApLnN0eWxlKFwibGVmdFwiLDApLnN0eWxlKFwib3BhY2l0eVwiLDApO1xuICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbChcImRpdiwgdGFibGUsIHRkLCB0clwiKS5jbGFzc2VkKG52UG9pbnRlckV2ZW50c0NsYXNzLHRydWUpXG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NlZChudlBvaW50ZXJFdmVudHNDbGFzcyx0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXIubm9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9EcmF3IHRoZSB0b29sdGlwIG9udG8gdGhlIERPTS5cbiAgICAgICAgZnVuY3Rpb24gbnZ0b29sdGlwKCkge1xuICAgICAgICAgICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWRhdGFTZXJpZXNFeGlzdHMoZGF0YSkpIHJldHVybjtcblxuICAgICAgICAgICAgY29udmVydFZpZXdCb3hSYXRpbygpO1xuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICB2YXIgdG9wID0gKGZpeGVkVG9wICE9IG51bGwpID8gZml4ZWRUb3AgOiBwb3NpdGlvbi50b3A7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZ2V0VG9vbHRpcENvbnRhaW5lcihjb250ZW50R2VuZXJhdG9yKGRhdGEpKTtcbiAgICAgICAgICAgIHRvb2x0aXBFbGVtID0gY29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKGNoYXJ0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN2Z0NvbXAgPSBjaGFydENvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRSZWN0ID0gKHN2Z0NvbXApID8gc3ZnQ29tcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IGNoYXJ0Q29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdmdPZmZzZXQgPSB7bGVmdDowLHRvcDowfTtcbiAgICAgICAgICAgICAgICBpZiAoc3ZnQ29tcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ZnQm91bmQgPSBzdmdDb21wLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcnRCb3VuZCA9IGNoYXJ0Q29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ZnQm91bmRUb3AgPSBzdmdCb3VuZC50b3A7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9EZWZlbnNpdmUgY29kZS4gU29tZXRpbWVzLCBzdmdCb3VuZFRvcCBjYW4gYmUgYSByZWFsbHkgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgLy8gIG51bWJlciwgbGlrZSAtMTM0MjU0LiBUaGF0J3MgYSBidWcuXG4gICAgICAgICAgICAgICAgICAgIC8vICBJZiBzdWNoIGEgbnVtYmVyIGlzIGZvdW5kLCB1c2UgemVybyBpbnN0ZWFkLiBGaXJlRm94IGJ1ZyBvbmx5XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdmdCb3VuZFRvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJCb3VuZCA9IGNoYXJ0Q29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnQm91bmRUb3AgPSAoTWF0aC5hYnMoc3ZnQm91bmRUb3ApID4gY29udGFpbmVyQm91bmQuaGVpZ2h0KSA/IDAgOiBzdmdCb3VuZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdmdPZmZzZXQudG9wID0gTWF0aC5hYnMoc3ZnQm91bmRUb3AgLSBjaGFydEJvdW5kLnRvcCk7XG4gICAgICAgICAgICAgICAgICAgIHN2Z09mZnNldC5sZWZ0ID0gTWF0aC5hYnMoc3ZnQm91bmQubGVmdCAtIGNoYXJ0Qm91bmQubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vSWYgdGhlIHBhcmVudCBjb250YWluZXIgaXMgYW4gb3ZlcmZsb3cgPGRpdj4gd2l0aCBzY3JvbGxiYXJzLCBzdWJ0cmFjdCB0aGUgc2Nyb2xsIG9mZnNldHMuXG4gICAgICAgICAgICAgICAgLy9Zb3UgbmVlZCB0byBhbHNvIGFkZCBhbnkgb2Zmc2V0IGJldHdlZW4gdGhlIDxzdmc+IGVsZW1lbnQgYW5kIGl0cyBjb250YWluaW5nIDxkaXY+XG4gICAgICAgICAgICAgICAgLy9GaW5hbGx5LCBhZGQgYW55IG9mZnNldCBvZiB0aGUgY29udGFpbmluZyA8ZGl2PiBvbiB0aGUgd2hvbGUgcGFnZS5cbiAgICAgICAgICAgICAgICBsZWZ0ICs9IGNoYXJ0Q29udGFpbmVyLm9mZnNldExlZnQgKyBzdmdPZmZzZXQubGVmdCAtIDIqY2hhcnRDb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICB0b3AgKz0gY2hhcnRDb250YWluZXIub2Zmc2V0VG9wICsgc3ZnT2Zmc2V0LnRvcCAtIDIqY2hhcnRDb250YWluZXIuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc25hcERpc3RhbmNlICYmIHNuYXBEaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBNYXRoLmZsb29yKHRvcC9zbmFwRGlzdGFuY2UpICogc25hcERpc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBudi50b29sdGlwLmNhbGNUb29sdGlwUG9zaXRpb24oW2xlZnQsdG9wXSwgZ3Jhdml0eSwgZGlzdGFuY2UsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9XG5cbiAgICAgICAgbnZ0b29sdGlwLm52UG9pbnRlckV2ZW50c0NsYXNzID0gbnZQb2ludGVyRXZlbnRzQ2xhc3M7XG5cbiAgICAgICAgbnZ0b29sdGlwLmNvbnRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgY29udGVudCA9IF87XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vUmV0dXJucyB0b29sdGlwRWxlbS4uLm5vdCBhYmxlIHRvIHNldCBpdC5cbiAgICAgICAgbnZ0b29sdGlwLnRvb2x0aXBFbGVtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9vbHRpcEVsZW07XG4gICAgICAgIH07XG5cbiAgICAgICAgbnZ0b29sdGlwLmNvbnRlbnRHZW5lcmF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZW50R2VuZXJhdG9yO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29udGVudEdlbmVyYXRvciA9IF87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG52dG9vbHRpcC5kYXRhID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSBfO1xuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAuZ3Jhdml0eSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXZpdHk7XG4gICAgICAgICAgICBncmF2aXR5ID0gXztcbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgbnZ0b29sdGlwLmRpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGlzdGFuY2U7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IF87XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG52dG9vbHRpcC5zbmFwRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzbmFwRGlzdGFuY2U7XG4gICAgICAgICAgICBzbmFwRGlzdGFuY2UgPSBfO1xuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAuY2xhc3NlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsYXNzZXM7XG4gICAgICAgICAgICBjbGFzc2VzID0gXztcbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgbnZ0b29sdGlwLmNoYXJ0Q29udGFpbmVyID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2hhcnRDb250YWluZXI7XG4gICAgICAgICAgICBjaGFydENvbnRhaW5lciA9IF87XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG52dG9vbHRpcC5wb3NpdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVmdCA9ICh0eXBlb2YgXy5sZWZ0ICE9PSAndW5kZWZpbmVkJykgPyBfLmxlZnQgOiBwb3NpdGlvbi5sZWZ0O1xuICAgICAgICAgICAgcG9zaXRpb24udG9wID0gKHR5cGVvZiBfLnRvcCAhPT0gJ3VuZGVmaW5lZCcpID8gXy50b3AgOiBwb3NpdGlvbi50b3A7XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG52dG9vbHRpcC5maXhlZFRvcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZpeGVkVG9wO1xuICAgICAgICAgICAgZml4ZWRUb3AgPSBfO1xuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICBudnRvb2x0aXAuZW5hYmxlZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVuYWJsZWQ7XG4gICAgICAgICAgICBlbmFibGVkID0gXztcbiAgICAgICAgICAgIHJldHVybiBudnRvb2x0aXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgbnZ0b29sdGlwLnZhbHVlRm9ybWF0dGVyID0gZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWVGb3JtYXR0ZXI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZUZvcm1hdHRlciA9IF87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnZ0b29sdGlwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG52dG9vbHRpcC5oZWFkZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWFkZXJGb3JtYXR0ZXI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJGb3JtYXR0ZXIgPSBfO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICAgICAgfTtcblxuICAgICAgICAvL2lkKCkgaXMgYSByZWFkLW9ubHkgZnVuY3Rpb24uIFlvdSBjYW4ndCB1c2UgaXQgdG8gc2V0IHRoZSBpZC5cbiAgICAgICAgbnZ0b29sdGlwLmlkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICB9O1xuXG4gICAgLy9PcmlnaW5hbCB0b29sdGlwLnNob3cgZnVuY3Rpb24uIEtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgLy8gcG9zID0gW2xlZnQsdG9wXVxuICAgIG52LnRvb2x0aXAuc2hvdyA9IGZ1bmN0aW9uKHBvcywgY29udGVudCwgZ3Jhdml0eSwgZGlzdCwgcGFyZW50Q29udGFpbmVyLCBjbGFzc2VzKSB7XG5cbiAgICAgICAgLy9DcmVhdGUgbmV3IHRvb2x0aXAgZGl2IGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb24gRE9NLlxuICAgICAgICB2YXIgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9ICdudnRvb2x0aXAgJyArIChjbGFzc2VzID8gY2xhc3NlcyA6ICd4eS10b29sdGlwJyk7XG5cbiAgICAgICAgdmFyIGJvZHkgPSBwYXJlbnRDb250YWluZXI7XG4gICAgICAgIGlmICggIXBhcmVudENvbnRhaW5lciB8fCBwYXJlbnRDb250YWluZXIudGFnTmFtZS5tYXRjaCgvZ3xzdmcvaSkpIHtcbiAgICAgICAgICAgIC8vSWYgdGhlIHBhcmVudCBlbGVtZW50IGlzIGFuIFNWRyBlbGVtZW50LCBwbGFjZSB0b29sdGlwIGluIHRoZSA8Ym9keT4gZWxlbWVudC5cbiAgICAgICAgICAgIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICBjb250YWluZXIuc3R5bGUudG9wID0gMDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAvLyBDb250ZW50IGNhbiBhbHNvIGJlIGRvbSBlbGVtZW50XG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgICAgLy9JZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBhbiBvdmVyZmxvdyA8ZGl2PiB3aXRoIHNjcm9sbGJhcnMsIHN1YnRyYWN0IHRoZSBzY3JvbGwgb2Zmc2V0cy5cbiAgICAgICAgaWYgKHBhcmVudENvbnRhaW5lcikge1xuICAgICAgICAgICAgcG9zWzBdID0gcG9zWzBdIC0gcGFyZW50Q29udGFpbmVyLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICBwb3NbMV0gPSBwb3NbMV0gLSBwYXJlbnRDb250YWluZXIuc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIG52LnRvb2x0aXAuY2FsY1Rvb2x0aXBQb3NpdGlvbihwb3MsIGdyYXZpdHksIGRpc3QsIGNvbnRhaW5lcik7XG4gICAgfTtcblxuICAgIC8vTG9va3MgdXAgdGhlIGFuY2VzdHJ5IG9mIGEgRE9NIGVsZW1lbnQsIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBOT04tc3ZnIG5vZGUuXG4gICAgbnYudG9vbHRpcC5maW5kRmlyc3ROb25TVkdQYXJlbnQgPSBmdW5jdGlvbihFbGVtKSB7XG4gICAgICAgIHdoaWxlKEVsZW0udGFnTmFtZS5tYXRjaCgvXmd8c3ZnJC9pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgRWxlbSA9IEVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRWxlbTtcbiAgICB9O1xuXG4gICAgLy9GaW5kcyB0aGUgdG90YWwgb2Zmc2V0VG9wIG9mIGEgZ2l2ZW4gRE9NIGVsZW1lbnQuXG4gICAgLy9Mb29rcyB1cCB0aGUgZW50aXJlIGFuY2VzdHJ5IG9mIGFuIGVsZW1lbnQsIHVwIHRvIHRoZSBmaXJzdCByZWxhdGl2ZWx5IHBvc2l0aW9uZWQgZWxlbWVudC5cbiAgICBudi50b29sdGlwLmZpbmRUb3RhbE9mZnNldFRvcCA9IGZ1bmN0aW9uICggRWxlbSwgaW5pdGlhbFRvcCApIHtcbiAgICAgICAgdmFyIG9mZnNldFRvcCA9IGluaXRpYWxUb3A7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYoICFpc05hTiggRWxlbS5vZmZzZXRUb3AgKSApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRUb3AgKz0gKEVsZW0ub2Zmc2V0VG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSggRWxlbSA9IEVsZW0ub2Zmc2V0UGFyZW50ICk7XG4gICAgICAgIHJldHVybiBvZmZzZXRUb3A7XG4gICAgfTtcblxuICAgIC8vRmluZHMgdGhlIHRvdGFsIG9mZnNldExlZnQgb2YgYSBnaXZlbiBET00gZWxlbWVudC5cbiAgICAvL0xvb2tzIHVwIHRoZSBlbnRpcmUgYW5jZXN0cnkgb2YgYW4gZWxlbWVudCwgdXAgdG8gdGhlIGZpcnN0IHJlbGF0aXZlbHkgcG9zaXRpb25lZCBlbGVtZW50LlxuICAgIG52LnRvb2x0aXAuZmluZFRvdGFsT2Zmc2V0TGVmdCA9IGZ1bmN0aW9uICggRWxlbSwgaW5pdGlhbExlZnQpIHtcbiAgICAgICAgdmFyIG9mZnNldExlZnQgPSBpbml0aWFsTGVmdDtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiggIWlzTmFOKCBFbGVtLm9mZnNldExlZnQgKSApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ICs9IChFbGVtLm9mZnNldExlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlKCBFbGVtID0gRWxlbS5vZmZzZXRQYXJlbnQgKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldExlZnQ7XG4gICAgfTtcblxuICAgIC8vR2xvYmFsIHV0aWxpdHkgZnVuY3Rpb24gdG8gcmVuZGVyIGEgdG9vbHRpcCBvbiB0aGUgRE9NLlxuICAgIC8vcG9zID0gW2xlZnQsdG9wXSBjb29yZGluYXRlcyBvZiB3aGVyZSB0byBwbGFjZSB0aGUgdG9vbHRpcCwgcmVsYXRpdmUgdG8gdGhlIFNWRyBjaGFydCBjb250YWluZXIuXG4gICAgLy9ncmF2aXR5ID0gaG93IHRvIG9yaWVudCB0aGUgdG9vbHRpcFxuICAgIC8vZGlzdCA9IGhvdyBmYXIgYXdheSBmcm9tIHRoZSBtb3VzZSB0byBwbGFjZSB0b29sdGlwXG4gICAgLy9jb250YWluZXIgPSB0b29sdGlwIERJVlxuICAgIG52LnRvb2x0aXAuY2FsY1Rvb2x0aXBQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcywgZ3Jhdml0eSwgZGlzdCwgY29udGFpbmVyKSB7XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlSW50KGNvbnRhaW5lci5vZmZzZXRIZWlnaHQpLFxuICAgICAgICAgICAgd2lkdGggPSBwYXJzZUludChjb250YWluZXIub2Zmc2V0V2lkdGgpLFxuICAgICAgICAgICAgd2luZG93V2lkdGggPSBudi51dGlscy53aW5kb3dTaXplKCkud2lkdGgsXG4gICAgICAgICAgICB3aW5kb3dIZWlnaHQgPSBudi51dGlscy53aW5kb3dTaXplKCkuaGVpZ2h0LFxuICAgICAgICAgICAgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgIGxlZnQsIHRvcDtcblxuICAgICAgICB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aCA+PSBkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoID8gd2luZG93SGVpZ2h0IDogd2luZG93SGVpZ2h0IC0gMTY7XG4gICAgICAgIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVySGVpZ2h0ID49IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0ID8gd2luZG93V2lkdGggOiB3aW5kb3dXaWR0aCAtIDE2O1xuXG4gICAgICAgIGdyYXZpdHkgPSBncmF2aXR5IHx8ICdzJztcbiAgICAgICAgZGlzdCA9IGRpc3QgfHwgMjA7XG5cbiAgICAgICAgdmFyIHRvb2x0aXBUb3AgPSBmdW5jdGlvbiAoIEVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gbnYudG9vbHRpcC5maW5kVG90YWxPZmZzZXRUb3AoRWxlbSwgdG9wKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdG9vbHRpcExlZnQgPSBmdW5jdGlvbiAoIEVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gbnYudG9vbHRpcC5maW5kVG90YWxPZmZzZXRMZWZ0KEVsZW0sbGVmdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3dpdGNoIChncmF2aXR5KSB7XG4gICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICBsZWZ0ID0gcG9zWzBdIC0gd2lkdGggLSBkaXN0O1xuICAgICAgICAgICAgICAgIHRvcCA9IHBvc1sxXSAtIChoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgdExlZnQgPSB0b29sdGlwTGVmdChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHZhciB0VG9wID0gdG9vbHRpcFRvcChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0TGVmdCA8IHNjcm9sbExlZnQpIGxlZnQgPSBwb3NbMF0gKyBkaXN0ID4gc2Nyb2xsTGVmdCA/IHBvc1swXSArIGRpc3QgOiBzY3JvbGxMZWZ0IC0gdExlZnQgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIGlmICh0VG9wIDwgc2Nyb2xsVG9wKSB0b3AgPSBzY3JvbGxUb3AgLSB0VG9wICsgdG9wO1xuICAgICAgICAgICAgICAgIGlmICh0VG9wICsgaGVpZ2h0ID4gc2Nyb2xsVG9wICsgd2luZG93SGVpZ2h0KSB0b3AgPSBzY3JvbGxUb3AgKyB3aW5kb3dIZWlnaHQgLSB0VG9wICsgdG9wIC0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IHBvc1swXSArIGRpc3Q7XG4gICAgICAgICAgICAgICAgdG9wID0gcG9zWzFdIC0gKGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciB0TGVmdCA9IHRvb2x0aXBMZWZ0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIHRUb3AgPSB0b29sdGlwVG9wKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgaWYgKHRMZWZ0ICsgd2lkdGggPiB3aW5kb3dXaWR0aCkgbGVmdCA9IHBvc1swXSAtIHdpZHRoIC0gZGlzdDtcbiAgICAgICAgICAgICAgICBpZiAodFRvcCA8IHNjcm9sbFRvcCkgdG9wID0gc2Nyb2xsVG9wICsgNTtcbiAgICAgICAgICAgICAgICBpZiAodFRvcCArIGhlaWdodCA+IHNjcm9sbFRvcCArIHdpbmRvd0hlaWdodCkgdG9wID0gc2Nyb2xsVG9wICsgd2luZG93SGVpZ2h0IC0gdFRvcCArIHRvcCAtIGhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgIGxlZnQgPSBwb3NbMF0gLSAod2lkdGggLyAyKSAtIDU7XG4gICAgICAgICAgICAgICAgdG9wID0gcG9zWzFdICsgZGlzdDtcbiAgICAgICAgICAgICAgICB2YXIgdExlZnQgPSB0b29sdGlwTGVmdChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHZhciB0VG9wID0gdG9vbHRpcFRvcChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0TGVmdCA8IHNjcm9sbExlZnQpIGxlZnQgPSBzY3JvbGxMZWZ0ICsgNTtcbiAgICAgICAgICAgICAgICBpZiAodExlZnQgKyB3aWR0aCA+IHdpbmRvd1dpZHRoKSBsZWZ0ID0gbGVmdCAtIHdpZHRoLzIgKyA1O1xuICAgICAgICAgICAgICAgIGlmICh0VG9wICsgaGVpZ2h0ID4gc2Nyb2xsVG9wICsgd2luZG93SGVpZ2h0KSB0b3AgPSBzY3JvbGxUb3AgKyB3aW5kb3dIZWlnaHQgLSB0VG9wICsgdG9wIC0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IHBvc1swXSAtICh3aWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgIHRvcCA9IHBvc1sxXSAtIGhlaWdodCAtIGRpc3Q7XG4gICAgICAgICAgICAgICAgdmFyIHRMZWZ0ID0gdG9vbHRpcExlZnQoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgdFRvcCA9IHRvb2x0aXBUb3AoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBpZiAodExlZnQgPCBzY3JvbGxMZWZ0KSBsZWZ0ID0gc2Nyb2xsTGVmdCArIDU7XG4gICAgICAgICAgICAgICAgaWYgKHRMZWZ0ICsgd2lkdGggPiB3aW5kb3dXaWR0aCkgbGVmdCA9IGxlZnQgLSB3aWR0aC8yICsgNTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVG9wID4gdFRvcCkgdG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IHBvc1swXTtcbiAgICAgICAgICAgICAgICB0b3AgPSBwb3NbMV0gLSBkaXN0O1xuICAgICAgICAgICAgICAgIHZhciB0TGVmdCA9IHRvb2x0aXBMZWZ0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIHRUb3AgPSB0b29sdGlwVG9wKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQrJ3B4JztcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnRvcCA9IHRvcCsncHgnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuXG4gICAgLy9HbG9iYWwgdXRpbGl0eSBmdW5jdGlvbiB0byByZW1vdmUgdG9vbHRpcHMgZnJvbSB0aGUgRE9NLlxuICAgIG52LnRvb2x0aXAuY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIHRvb2x0aXBzLCBtYXJrIHRoZW0gZm9yIHJlbW92YWwgYnkgdGhpcyBjbGFzcyAoc28gb3RoZXJzIGNsZWFudXBzIHdvbid0IGZpbmQgaXQpXG4gICAgICAgIHZhciB0b29sdGlwcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ252dG9vbHRpcCcpO1xuICAgICAgICB2YXIgcHVyZ2luZyA9IFtdO1xuICAgICAgICB3aGlsZSh0b29sdGlwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHB1cmdpbmcucHVzaCh0b29sdGlwc1swXSk7XG4gICAgICAgICAgICB0b29sdGlwc1swXS5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSAnMCAhaW1wb3J0YW50JztcbiAgICAgICAgICAgIHRvb2x0aXBzWzBdLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgdG9vbHRpcHNbMF0uY2xhc3NOYW1lID0gJ252dG9vbHRpcC1wZW5kaW5nLXJlbW92YWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgd2hpbGUgKHB1cmdpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZU1lID0gcHVyZ2luZy5wb3AoKTtcbiAgICAgICAgICAgICAgICByZW1vdmVNZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJlbW92ZU1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICB9O1xuXG59KSgpO1xuXG5cbi8qXG5HZXRzIHRoZSBicm93c2VyIHdpbmRvdyBzaXplXG5cblJldHVybnMgb2JqZWN0IHdpdGggaGVpZ2h0IGFuZCB3aWR0aCBwcm9wZXJ0aWVzXG4gKi9cbm52LnV0aWxzLndpbmRvd1NpemUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBTYW5lIGRlZmF1bHRzXG4gICAgdmFyIHNpemUgPSB7d2lkdGg6IDY0MCwgaGVpZ2h0OiA0ODB9O1xuXG4gICAgLy8gRWFybGllciBJRSB1c2VzIERvYy5ib2R5XG4gICAgaWYgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCkge1xuICAgICAgICBzaXplLndpZHRoID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICAgICAgc2l6ZS5oZWlnaHQgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBJRSBjYW4gdXNlIGRlcGVuZGluZyBvbiBtb2RlIGl0IGlzIGluXG4gICAgaWYgKGRvY3VtZW50LmNvbXBhdE1vZGU9PSdDU1MxQ29tcGF0JyAmJlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiZcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoICkge1xuXG4gICAgICAgIHNpemUud2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIHNpemUuaGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBNb3N0IHJlY2VudCBicm93c2VycyB1c2VcbiAgICBpZiAod2luZG93LmlubmVyV2lkdGggJiYgd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgIHNpemUud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgc2l6ZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiAoc2l6ZSk7XG59O1xuXG5cbi8qXG5CaW5kcyBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2hlbiB3aW5kb3cgaXMgcmVzaXplZFxuICovXG5udi51dGlscy53aW5kb3dSZXNpemUgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBudi5sb2coXCJFUlJPUjogRmFpbGVkIHRvIGJpbmQgdG8gd2luZG93LnJlc2l6ZSB3aXRoOiBcIiwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIHJldHVybiBvYmplY3Qgd2l0aCBjbGVhciBmdW5jdGlvbiB0byByZW1vdmUgdGhlIHNpbmdsZSBhZGRlZCBjYWxsYmFjay5cbiAgICByZXR1cm4ge1xuICAgICAgICBjYWxsYmFjazogaGFuZGxlcixcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKlxuQmFja3dhcmRzIGNvbXBhdGlibGUgd2F5IHRvIGltcGxlbWVudCBtb3JlIGQzLWxpa2UgY29sb3Jpbmcgb2YgZ3JhcGhzLlxuSWYgcGFzc2VkIGFuIGFycmF5LCB3cmFwIGl0IGluIGEgZnVuY3Rpb24gd2hpY2ggaW1wbGVtZW50cyB0aGUgb2xkIGJlaGF2aW9yXG5FbHNlIHJldHVybiB3aGF0IHdhcyBwYXNzZWQgaW5cbiovXG5udi51dGlscy5nZXRDb2xvciA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgLy9pZiB5b3UgcGFzcyBpbiBub3RoaW5nLCBnZXQgZGVmYXVsdCBjb2xvcnMgYmFja1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnYudXRpbHMuZGVmYXVsdENvbG9yKCk7XG5cbiAgICAvL2lmIHBhc3NlZCBhbiBhcnJheSwgd3JhcCBpdCBpbiBhIGZ1bmN0aW9uXG4gICAgfSBlbHNlIGlmKGNvbG9yIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3JbaSAlIGNvbG9yLmxlbmd0aF07IH07XG5cbiAgICAvL2lmIHBhc3NlZCBhIGZ1bmN0aW9uLCByZXR1cm4gdGhlIGZ1bmN0aW9uLCBvciB3aGF0ZXZlciBpdCBtYXkgYmVcbiAgICAvL2V4dGVybmFsIGxpYnMsIHN1Y2ggYXMgYW5ndWxhcmpzLW52ZDMtZGlyZWN0aXZlcyB1c2UgdGhpc1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vY2FuJ3QgcmVhbGx5IGhlbHAgaXQgaWYgc29tZW9uZSBwYXNzZXMgcnViYmlzaCBhcyBjb2xvclxuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxufTtcblxuXG4vKlxuRGVmYXVsdCBjb2xvciBjaG9vc2VyIHVzZXMgdGhlIGluZGV4IG9mIGFuIG9iamVjdCBhcyBiZWZvcmUuXG4gKi9cbm52LnV0aWxzLmRlZmF1bHRDb2xvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb2xvcnMgPSBkMy5zY2FsZS5jYXRlZ29yeTIwKCkucmFuZ2UoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcnNbaSAlIGNvbG9ycy5sZW5ndGhdXG4gICAgfTtcbn07XG5cblxuLypcblJldHVybnMgYSBjb2xvciBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSByZXN1bHQgb2YgJ2dldEtleScgZm9yIGVhY2ggc2VyaWVzIGFuZFxubG9va3MgZm9yIGEgY29ycmVzcG9uZGluZyBjb2xvciBmcm9tIHRoZSBkaWN0aW9uYXJ5XG4qL1xubnYudXRpbHMuY3VzdG9tVGhlbWUgPSBmdW5jdGlvbihkaWN0aW9uYXJ5LCBnZXRLZXksIGRlZmF1bHRDb2xvcnMpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBzZXJpZXMua2V5IGlmIGdldEtleSBpcyB1bmRlZmluZWRcbiAgICBnZXRLZXkgPSBnZXRLZXkgfHwgZnVuY3Rpb24oc2VyaWVzKSB7IHJldHVybiBzZXJpZXMua2V5IH07XG4gICAgZGVmYXVsdENvbG9ycyA9IGRlZmF1bHRDb2xvcnMgfHwgZDMuc2NhbGUuY2F0ZWdvcnkyMCgpLnJhbmdlKCk7XG5cbiAgICAvLyBzdGFydCBhdCBlbmQgb2YgZGVmYXVsdCBjb2xvciBsaXN0IGFuZCB3YWxrIGJhY2sgdG8gaW5kZXggMFxuICAgIHZhciBkZWZJbmRleCA9IGRlZmF1bHRDb2xvcnMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNlcmllcywgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGdldEtleShzZXJpZXMpO1xuICAgICAgICBpZiAodHlwZW9mIGRpY3Rpb25hcnlba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGRpY3Rpb25hcnlba2V5XSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGRpY3Rpb25hcnlba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGljdGlvbmFyeVtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gbWF0Y2ggaW4gZGljdGlvbmFyeSwgdXNlIGEgZGVmYXVsdCBjb2xvclxuICAgICAgICAgICAgaWYgKCFkZWZJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIHVzZWQgYWxsIHRoZSBkZWZhdWx0IGNvbG9ycywgc3RhcnQgb3ZlclxuICAgICAgICAgICAgICAgIGRlZkluZGV4ID0gZGVmYXVsdENvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZJbmRleCA9IGRlZkluZGV4IC0gMTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Q29sb3JzW2RlZkluZGV4XTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5cbi8qXG5Gcm9tIHRoZSBQSkFYIGV4YW1wbGUgb24gZDNqcy5vcmcsIHdoaWxlIHRoaXMgaXMgbm90IHJlYWxseSBkaXJlY3RseSBuZWVkZWRcbml0J3MgYSB2ZXJ5IGNvb2wgbWV0aG9kIGZvciBkb2luZyBwamF4LCBJIG1heSBleHBhbmQgdXBvbiBpdCBhIGxpdHRsZSBiaXQsXG5vcGVuIHRvIHN1Z2dlc3Rpb25zIG9uIGFueXRoaW5nIHRoYXQgbWF5IGJlIHVzZWZ1bFxuKi9cbm52LnV0aWxzLnBqYXggPSBmdW5jdGlvbihsaW5rcywgY29udGVudCkge1xuXG4gICAgdmFyIGxvYWQgPSBmdW5jdGlvbihocmVmKSB7XG4gICAgICAgIGQzLmh0bWwoaHJlZiwgZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBkMy5zZWxlY3QoY29udGVudCkubm9kZSgpO1xuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChmcmFnbWVudCkuc2VsZWN0KGNvbnRlbnQpLm5vZGUoKSxcbiAgICAgICAgICAgICAgICB0YXJnZXQpO1xuICAgICAgICAgICAgbnYudXRpbHMucGpheChsaW5rcywgY29udGVudCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBkMy5zZWxlY3RBbGwobGlua3MpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHRoaXMuaHJlZiwgdGhpcy50ZXh0Q29udGVudCwgdGhpcy5ocmVmKTtcbiAgICAgICAgbG9hZCh0aGlzLmhyZWYpO1xuICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KHdpbmRvdykub24oXCJwb3BzdGF0ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGQzLmV2ZW50LnN0YXRlKSB7XG4gICAgICAgICAgICBsb2FkKGQzLmV2ZW50LnN0YXRlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKlxuRm9yIHdoZW4gd2Ugd2FudCB0byBhcHByb3hpbWF0ZSB0aGUgd2lkdGggaW4gcGl4ZWxzIGZvciBhbiBTVkc6dGV4dCBlbGVtZW50LlxuTW9zdCBjb21tb24gaW5zdGFuY2UgaXMgd2hlbiB0aGUgZWxlbWVudCBpcyBpbiBhIGRpc3BsYXk6bm9uZTsgY29udGFpbmVyLlxuRm9ydW1sYSBpcyA6IHRleHQubGVuZ3RoICogZm9udC1zaXplICogY29uc3RhbnRfZmFjdG9yXG4qL1xubnYudXRpbHMuY2FsY0FwcHJveFRleHRXaWR0aCA9IGZ1bmN0aW9uIChzdmdUZXh0RWxlbSkge1xuICAgIGlmICh0eXBlb2Ygc3ZnVGV4dEVsZW0uc3R5bGUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgJiYgdHlwZW9mIHN2Z1RleHRFbGVtLnRleHQgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICB2YXIgZm9udFNpemUgPSBwYXJzZUludChzdmdUZXh0RWxlbS5zdHlsZShcImZvbnQtc2l6ZVwiKS5yZXBsYWNlKFwicHhcIixcIlwiKSk7XG4gICAgICAgIHZhciB0ZXh0TGVuZ3RoID0gc3ZnVGV4dEVsZW0udGV4dCgpLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRleHRMZW5ndGggKiBmb250U2l6ZSAqIDAuNTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuXG5cbi8qXG5OdW1iZXJzIHRoYXQgYXJlIHVuZGVmaW5lZCwgbnVsbCBvciBOYU4sIGNvbnZlcnQgdGhlbSB0byB6ZXJvcy5cbiovXG5udi51dGlscy5OYU50b1plcm8gPSBmdW5jdGlvbihuKSB7XG4gICAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJ1xuICAgICAgICB8fCBpc05hTihuKVxuICAgICAgICB8fCBuID09PSBudWxsXG4gICAgICAgIHx8IG4gPT09IEluZmluaXR5XG4gICAgICAgIHx8IG4gPT09IC1JbmZpbml0eSkge1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn07XG5cbi8qXG5BZGQgYSB3YXkgdG8gd2F0Y2ggZm9yIGQzIHRyYW5zaXRpb24gZW5kcyB0byBkM1xuKi9cbmQzLnNlbGVjdGlvbi5wcm90b3R5cGUud2F0Y2hUcmFuc2l0aW9uID0gZnVuY3Rpb24ocmVuZGVyV2F0Y2gpe1xuICAgIHZhciBhcmdzID0gW3RoaXNdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiByZW5kZXJXYXRjaC50cmFuc2l0aW9uLmFwcGx5KHJlbmRlcldhdGNoLCBhcmdzKTtcbn07XG5cblxuLypcbkhlbHBlciBvYmplY3QgdG8gd2F0Y2ggd2hlbiBkMyBoYXMgcmVuZGVyZWQgc29tZXRoaW5nXG4qL1xubnYudXRpbHMucmVuZGVyV2F0Y2ggPSBmdW5jdGlvbihkaXNwYXRjaCwgZHVyYXRpb24pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgbnYudXRpbHMucmVuZGVyV2F0Y2gpKSB7XG4gICAgICAgIHJldHVybiBuZXcgbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcbiAgICB9XG5cbiAgICB2YXIgX2R1cmF0aW9uID0gZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGR1cmF0aW9uIDogMjUwO1xuICAgIHZhciByZW5kZXJTdGFjayA9IFtdO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMubW9kZWxzID0gZnVuY3Rpb24obW9kZWxzKSB7XG4gICAgICAgIG1vZGVscyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgbW9kZWxzLmZvckVhY2goZnVuY3Rpb24obW9kZWwpe1xuICAgICAgICAgICAgbW9kZWwuX19yZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgKGZ1bmN0aW9uKG0pe1xuICAgICAgICAgICAgICAgIG0uZGlzcGF0Y2gub24oJ3JlbmRlckVuZCcsIGZ1bmN0aW9uKGFyZyl7XG4gICAgICAgICAgICAgICAgICAgIG0uX19yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVuZGVyRW5kKCdtb2RlbCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkobW9kZWwpO1xuXG4gICAgICAgICAgICBpZiAocmVuZGVyU3RhY2suaW5kZXhPZihtb2RlbCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhY2sucHVzaChtb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlclN0YWNrID0gW107XG4gICAgfTtcblxuICAgIHRoaXMudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgYXJncywgZHVyYXRpb24pIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBhcmdzLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IF9kdXJhdGlvbiA6IDI1MDtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb24uX19yZW5kZXJlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGFjay5pbmRleE9mKHNlbGVjdGlvbikgPCAwKSB7XG4gICAgICAgICAgICByZW5kZXJTdGFjay5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5fX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5kZWxheSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5kdXJhdGlvbiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5fX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uLmV2ZXJ5KCBmdW5jdGlvbihkKXsgcmV0dXJuICFkLmxlbmd0aDsgfSApKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLl9fcmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uX19yZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbigpeyArK247IH0pXG4gICAgICAgICAgICAgICAgLmVhY2goJ2VuZCcsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLl9fcmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW5kZXJFbmQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnJlbmRlckVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmVuZGVyU3RhY2suZXZlcnkoIGZ1bmN0aW9uKGQpeyByZXR1cm4gZC5fX3JlbmRlcmVkOyB9ICkpIHtcbiAgICAgICAgICAgIHJlbmRlclN0YWNrLmZvckVhY2goIGZ1bmN0aW9uKGQpeyBkLl9fcmVuZGVyZWQgPSBmYWxzZTsgfSk7XG4gICAgICAgICAgICBkaXNwYXRjaC5yZW5kZXJFbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuXG4vKlxuVGFrZXMgbXVsdGlwbGUgb2JqZWN0cyBhbmQgY29tYmluZXMgdGhlbSBpbnRvIHRoZSBmaXJzdCBvbmUgKGRzdClcbmV4YW1wbGU6ICBudi51dGlscy5kZWVwRXh0ZW5kKHthOiAxfSwge2E6IDIsIGI6IDN9LCB7YzogNH0pO1xuZ2l2ZXM6ICB7YTogMiwgYjogMywgYzogNH1cbiovXG5udi51dGlscy5kZWVwRXh0ZW5kID0gZnVuY3Rpb24oZHN0KXtcbiAgICB2YXIgc291cmNlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBpc0FycmF5ID0gZHN0W2tleV0gaW5zdGFuY2VvZiBBcnJheTtcbiAgICAgICAgICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBkc3Rba2V5XSA9PT0gJ29iamVjdCc7XG4gICAgICAgICAgICB2YXIgc3JjT2JqID0gdHlwZW9mIHNvdXJjZVtrZXldID09PSAnb2JqZWN0JztcblxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0ICYmICFpc0FycmF5ICYmIHNyY09iaikge1xuICAgICAgICAgICAgICAgIG52LnV0aWxzLmRlZXBFeHRlbmQoZHN0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKlxuc3RhdGUgdXRpbGl0eSBvYmplY3QsIHVzZWQgdG8gdHJhY2sgZDMgc3RhdGVzIGluIHRoZSBtb2RlbHNcbiovXG5udi51dGlscy5zdGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIG52LnV0aWxzLnN0YXRlKSkge1xuICAgICAgICByZXR1cm4gbmV3IG52LnV0aWxzLnN0YXRlKCk7XG4gICAgfVxuICAgIHZhciBzdGF0ZSA9IHt9O1xuICAgIHZhciBfc2VsZiA9IHRoaXM7XG4gICAgdmFyIF9zZXRTdGF0ZSA9IGZ1bmN0aW9uKCl7fTtcbiAgICB2YXIgX2dldFN0YXRlID0gZnVuY3Rpb24oKXsgcmV0dXJuIHt9OyB9O1xuICAgIHZhciBpbml0ID0gbnVsbDtcbiAgICB2YXIgY2hhbmdlZCA9IG51bGw7XG5cbiAgICB0aGlzLmRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2NoYW5nZScsICdzZXQnKTtcblxuICAgIHRoaXMuZGlzcGF0Y2gub24oJ3NldCcsIGZ1bmN0aW9uKHN0YXRlKXtcbiAgICAgICAgX3NldFN0YXRlKHN0YXRlLCB0cnVlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24oZm4pe1xuICAgICAgICBfZ2V0U3RhdGUgPSBmbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0dGVyID0gZnVuY3Rpb24oZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oKXt9O1xuICAgICAgICB9XG4gICAgICAgIF9zZXRTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCB1cGRhdGUpe1xuICAgICAgICAgICAgZm4oc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihzdGF0ZSl7XG4gICAgICAgIGluaXQgPSBpbml0IHx8IHt9O1xuICAgICAgICBudi51dGlscy5kZWVwRXh0ZW5kKGluaXQsIHN0YXRlKTtcbiAgICB9O1xuXG4gICAgdmFyIF9zZXQgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBfZ2V0U3RhdGUoKTtcblxuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpID09PSBKU09OLnN0cmluZ2lmeShzdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKHN0YXRlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlW2tleV0gPSBzZXR0aW5nc1trZXldO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgIF9zZXRTdGF0ZShpbml0LCBmYWxzZSk7XG4gICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3NldC5jYWxsKHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoLmNoYW5nZShzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG59O1xuXG5cbi8qXG5TbmlwcGV0IG9mIGNvZGUgeW91IGNhbiBpbnNlcnQgaW50byBlYWNoIG52Lm1vZGVscy4qIHRvIGdpdmUgeW91IHRoZSBhYmlsaXR5IHRvXG5kbyB0aGluZ3MgbGlrZTpcbmNoYXJ0Lm9wdGlvbnMoe1xuICBzaG93WEF4aXM6IHRydWUsXG4gIHRvb2x0aXBzOiB0cnVlXG59KTtcblxuVG8gZW5hYmxlIGluIHRoZSBjaGFydDpcbmNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcbiovXG5udi51dGlscy5vcHRpb25zRnVuYyA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICBudi5kZXByZWNhdGVkKCdudi51dGlscy5vcHRpb25zRnVuYycpO1xuICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGQzLm1hcChhcmdzKS5mb3JFYWNoKChmdW5jdGlvbihrZXksdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1trZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qXG5udW1UaWNrczogIHJlcXVlc3RlZCBudW1iZXIgb2YgdGlja3NcbmRhdGE6ICB0aGUgY2hhcnQgZGF0YVxuXG5yZXR1cm5zIHRoZSBudW1iZXIgb2YgdGlja3MgdG8gYWN0dWFsbHkgdXNlIG9uIFggYXhpcywgYmFzZWQgb24gY2hhcnQgZGF0YVxudG8gYXZvaWQgZHVwbGljYXRlIHRpY2tzIHdpdGggdGhlIHNhbWUgdmFsdWVcbiovXG5udi51dGlscy5jYWxjVGlja3NYID0gZnVuY3Rpb24obnVtVGlja3MsIGRhdGEpIHtcbiAgICAvLyBmaW5kIG1heCBudW1iZXIgb2YgdmFsdWVzIGZyb20gYWxsIGRhdGEgc3RyZWFtc1xuICAgIHZhciBudW1WYWx1ZXMgPSAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKGk7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzdHJlYW1fbGVuID0gZGF0YVtpXSAmJiBkYXRhW2ldLnZhbHVlcyA/IGRhdGFbaV0udmFsdWVzLmxlbmd0aCA6IDA7XG4gICAgICAgIG51bVZhbHVlcyA9IHN0cmVhbV9sZW4gPiBudW1WYWx1ZXMgPyBzdHJlYW1fbGVuIDogbnVtVmFsdWVzO1xuICAgIH1cbiAgICBudi5sb2coXCJSZXF1ZXN0ZWQgbnVtYmVyIG9mIHRpY2tzOiBcIiwgbnVtVGlja3MpO1xuICAgIG52LmxvZyhcIkNhbGN1bGF0ZWQgbWF4IHZhbHVlcyB0byBiZTogXCIsIG51bVZhbHVlcyk7XG4gICAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgbW9yZSB0aWNrcyB0aGFuIHZhbHVlcyB0byBhdm9pZCBkdXBsaWNhdGVzXG4gICAgbnVtVGlja3MgPSBudW1UaWNrcyA+IG51bVZhbHVlcyA/IG51bVRpY2tzID0gbnVtVmFsdWVzIC0gMSA6IG51bVRpY2tzO1xuICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IG9uZSB0aWNrXG4gICAgbnVtVGlja3MgPSBudW1UaWNrcyA8IDEgPyAxIDogbnVtVGlja3M7XG4gICAgLy8gbWFrZSBzdXJlIGl0J3MgYW4gaW50ZWdlclxuICAgIG51bVRpY2tzID0gTWF0aC5mbG9vcihudW1UaWNrcyk7XG4gICAgbnYubG9nKFwiQ2FsY3VsYXRpbmcgdGljayBjb3VudCBhczogXCIsIG51bVRpY2tzKTtcbiAgICByZXR1cm4gbnVtVGlja3M7XG59O1xuXG5cbi8qXG5yZXR1cm5zIG51bWJlciBvZiB0aWNrcyB0byBhY3R1YWxseSB1c2Ugb24gWSBheGlzLCBiYXNlZCBvbiBjaGFydCBkYXRhXG4qL1xubnYudXRpbHMuY2FsY1RpY2tzWSA9IGZ1bmN0aW9uKG51bVRpY2tzLCBkYXRhKSB7XG4gICAgLy8gY3VycmVudGx5IHVzZXMgdGhlIHNhbWUgbG9naWMgYnV0IHdlIGNhbiBhZGp1c3QgaGVyZSBpZiBuZWVkZWQgbGF0ZXJcbiAgICByZXR1cm4gbnYudXRpbHMuY2FsY1RpY2tzWChudW1UaWNrcywgZGF0YSk7XG59O1xuXG5cbi8qXG5BZGQgYSBwYXJ0aWN1bGFyIG9wdGlvbiBmcm9tIGFuIG9wdGlvbnMgb2JqZWN0IG9udG8gY2hhcnRcbk9wdGlvbnMgZXhwb3NlZCBvbiBhIGNoYXJ0IGFyZSBhIGdldHRlci9zZXR0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGNoYXJ0XG5vbiBzZXQgdG8gbWltaWMgdHlwaWNhbCBkMyBvcHRpb24gY2hhaW5pbmcsIGUuZy4gc3ZnLm9wdGlvbjEoJ2EnKS5vcHRpb24yKCdiJyk7XG5cbm9wdGlvbiBvYmplY3RzIHNob3VsZCBiZSBnZW5lcmF0ZWQgdmlhIE9iamVjdC5jcmVhdGUoKSB0byBwcm92aWRlXG50aGUgb3B0aW9uIG9mIG1hbmlwdWxhdGluZyBkYXRhIHZpYSBnZXQvc2V0IGZ1bmN0aW9ucy5cbiovXG5udi51dGlscy5pbml0T3B0aW9uID0gZnVuY3Rpb24oY2hhcnQsIG5hbWUpIHtcbiAgICAvLyBpZiBpdCdzIGEgY2FsbCBvcHRpb24sIGp1c3QgY2FsbCBpdCBkaXJlY3RseSwgb3RoZXJ3aXNlIGRvIGdldC9zZXRcbiAgICBpZiAoY2hhcnQuX2NhbGxzICYmIGNoYXJ0Ll9jYWxsc1tuYW1lXSkge1xuICAgICAgICBjaGFydFtuYW1lXSA9IGNoYXJ0Ll9jYWxsc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaGFydFtuYW1lXSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjaGFydC5fb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIGNoYXJ0Ll9vcHRpb25zW25hbWVdID0gXztcbiAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5cbi8qXG5BZGQgYWxsIG9wdGlvbnMgaW4gYW4gb3B0aW9ucyBvYmplY3QgdG8gdGhlIGNoYXJ0XG4qL1xubnYudXRpbHMuaW5pdE9wdGlvbnMgPSBmdW5jdGlvbihjaGFydCkge1xuICAgIHZhciBvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjaGFydC5fb3B0aW9ucyB8fCB7fSk7XG4gICAgdmFyIGNhbGxzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2hhcnQuX2NhbGxzIHx8IHt9KTtcbiAgICBvcHMgPSBvcHMuY29uY2F0KGNhbGxzKTtcbiAgICBmb3IgKHZhciBpIGluIG9wcykge1xuICAgICAgICBudi51dGlscy5pbml0T3B0aW9uKGNoYXJ0LCBvcHNbaV0pO1xuICAgIH1cbn07XG5cblxuLypcbkluaGVyaXQgb3B0aW9ucyBmcm9tIGEgRDMgb2JqZWN0XG5kMy5yZWJpbmQgbWFrZXMgY2FsbGluZyB0aGUgZnVuY3Rpb24gb24gdGFyZ2V0IGFjdHVhbGx5IGNhbGwgaXQgb24gc291cmNlXG5BbHNvIHVzZSBfZDNvcHRpb25zIHNvIHdlIGNhbiB0cmFjayB3aGF0IHdlIGluaGVyaXQgZm9yIGRvY3VtZW50YXRpb24gYW5kIGNoYWluZWQgaW5oZXJpdGFuY2VcbiovXG5udi51dGlscy5pbmhlcml0T3B0aW9uc0QzID0gZnVuY3Rpb24odGFyZ2V0LCBkM19zb3VyY2UsIG9wbGlzdCkge1xuICAgIHRhcmdldC5fZDNvcHRpb25zID0gb3BsaXN0LmNvbmNhdCh0YXJnZXQuX2Qzb3B0aW9ucyB8fCBbXSk7XG4gICAgb3BsaXN0LnVuc2hpZnQoZDNfc291cmNlKTtcbiAgICBvcGxpc3QudW5zaGlmdCh0YXJnZXQpO1xuICAgIGQzLnJlYmluZC5hcHBseSh0aGlzLCBvcGxpc3QpO1xufTtcblxuXG4vKlxuUmVtb3ZlIGR1cGxpY2F0ZXMgZnJvbSBhbiBhcnJheVxuKi9cbm52LnV0aWxzLmFycmF5VW5pcXVlID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBhLnNvcnQoKS5maWx0ZXIoZnVuY3Rpb24oaXRlbSwgcG9zKSB7XG4gICAgICAgIHJldHVybiAhcG9zIHx8IGl0ZW0gIT0gYVtwb3MgLSAxXTtcbiAgICB9KTtcbn07XG5cblxuLypcbktlZXBzIGEgbGlzdCBvZiBjdXN0b20gc3ltYm9scyB0byBkcmF3IGZyb20gaW4gYWRkaXRpb24gdG8gZDMuc3ZnLnN5bWJvbFxuTmVjZXNzYXJ5IHNpbmNlIGQzIGRvZXNuJ3QgbGV0IHlvdSBleHRlbmQgaXRzIGxpc3QgLV8tXG5BZGQgbmV3IHN5bWJvbHMgYnkgZG9pbmcgbnYudXRpbHMuc3ltYm9scy5zZXQoJ25hbWUnLCBmdW5jdGlvbihzaXplKXsuLi59KTtcbiovXG5udi51dGlscy5zeW1ib2xNYXAgPSBkMy5tYXAoKTtcblxuXG4vKlxuUmVwbGFjZXMgZDMuc3ZnLnN5bWJvbCBzbyB0aGF0IHdlIGNhbiBsb29rIGJvdGggdGhlcmUgYW5kIG91ciBvd24gbWFwXG4gKi9cbm52LnV0aWxzLnN5bWJvbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0eXBlLFxuICAgICAgICBzaXplID0gNjQ7XG4gICAgZnVuY3Rpb24gc3ltYm9sKGQsaSkge1xuICAgICAgICB2YXIgdCA9IHR5cGUuY2FsbCh0aGlzLGQsaSk7XG4gICAgICAgIHZhciBzID0gc2l6ZS5jYWxsKHRoaXMsZCxpKTtcbiAgICAgICAgaWYgKGQzLnN2Zy5zeW1ib2xUeXBlcy5pbmRleE9mKHQpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGQzLnN2Zy5zeW1ib2woKS50eXBlKHQpLnNpemUocykoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudi51dGlscy5zeW1ib2xNYXAuZ2V0KHQpKHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bWJvbC50eXBlID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0eXBlO1xuICAgICAgICB0eXBlID0gZDMuZnVuY3RvcihfKTtcbiAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICB9O1xuICAgIHN5bWJvbC5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgICBzaXplID0gZDMuZnVuY3RvcihfKTtcbiAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICB9O1xuICAgIHJldHVybiBzeW1ib2w7XG59O1xuXG5cbi8qXG5Jbmhlcml0IG9wdGlvbiBnZXR0ZXIvc2V0dGVyIGZ1bmN0aW9ucyBmcm9tIHNvdXJjZSB0byB0YXJnZXRcbmQzLnJlYmluZCBtYWtlcyBjYWxsaW5nIHRoZSBmdW5jdGlvbiBvbiB0YXJnZXQgYWN0dWFsbHkgY2FsbCBpdCBvbiBzb3VyY2VcbkFsc28gdHJhY2sgdmlhIF9pbmhlcml0ZWQgYW5kIF9kM29wdGlvbnMgc28gd2UgY2FuIHRyYWNrIHdoYXQgd2UgaW5oZXJpdFxuZm9yIGRvY3VtZW50YXRpb24gZ2VuZXJhdGlvbiBwdXJwb3NlcyBhbmQgY2hhaW5lZCBpbmhlcml0YW5jZVxuKi9cbm52LnV0aWxzLmluaGVyaXRPcHRpb25zID0gZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAvLyBpbmhlcml0IGFsbCB0aGUgdGhpbmdzXG4gICAgdmFyIG9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZS5fb3B0aW9ucyB8fCB7fSk7XG4gICAgdmFyIGNhbGxzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlLl9jYWxscyB8fCB7fSk7XG4gICAgdmFyIGluaGVyaXRlZCA9IHNvdXJjZS5faW5oZXJpdGVkIHx8IFtdO1xuICAgIHZhciBkM29wcyA9IHNvdXJjZS5fZDNvcHRpb25zIHx8IFtdO1xuICAgIHZhciBhcmdzID0gb3BzLmNvbmNhdChjYWxscykuY29uY2F0KGluaGVyaXRlZCkuY29uY2F0KGQzb3BzKTtcbiAgICBhcmdzLnVuc2hpZnQoc291cmNlKTtcbiAgICBhcmdzLnVuc2hpZnQodGFyZ2V0KTtcbiAgICBkMy5yZWJpbmQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgLy8gcGFzcyBhbG9uZyB0aGUgbGlzdHMgdG8ga2VlcCB0cmFjayBvZiB0aGVtLCBkb24ndCBhbGxvdyBkdXBsaWNhdGVzXG4gICAgdGFyZ2V0Ll9pbmhlcml0ZWQgPSBudi51dGlscy5hcnJheVVuaXF1ZShvcHMuY29uY2F0KGNhbGxzKS5jb25jYXQoaW5oZXJpdGVkKS5jb25jYXQob3BzKS5jb25jYXQodGFyZ2V0Ll9pbmhlcml0ZWQgfHwgW10pKTtcbiAgICB0YXJnZXQuX2Qzb3B0aW9ucyA9IG52LnV0aWxzLmFycmF5VW5pcXVlKGQzb3BzLmNvbmNhdCh0YXJnZXQuX2Qzb3B0aW9ucyB8fCBbXSkpO1xufTtcblxuXG4vKlxuUnVucyBjb21tb24gaW5pdGlhbGl6ZSBjb2RlIG9uIHRoZSBzdmcgYmVmb3JlIHRoZSBjaGFydCBidWlsZHNcbiovXG5udi51dGlscy5pbml0U1ZHID0gZnVuY3Rpb24oc3ZnKSB7XG4gICAgc3ZnLmNsYXNzZWQoeydudmQzLXN2Zyc6dHJ1ZX0pO1xufTtudi5tb2RlbHMuYXhpcyA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgYXhpcyA9IGQzLnN2Zy5heGlzKCk7XG4gICAgdmFyIHNjYWxlID0gZDMuc2NhbGUubGluZWFyKCk7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAgICAgLCB3aWR0aCA9IDc1IC8vb25seSB1c2VkIGZvciB0aWNrTGFiZWwgY3VycmVudGx5XG4gICAgICAgICwgaGVpZ2h0ID0gNjAgLy9vbmx5IHVzZWQgZm9yIHRpY2tMYWJlbCBjdXJyZW50bHlcbiAgICAgICAgLCBheGlzTGFiZWxUZXh0ID0gbnVsbFxuICAgICAgICAsIHNob3dNYXhNaW4gPSB0cnVlIC8vVE9ETzogc2hvd01heE1pbiBzaG91bGQgYmUgZGlzYWJsZWQgb24gYWxsIG9yZGluYWwgc2NhbGVkIGF4ZXNcbiAgICAgICAgLCBoaWdobGlnaHRaZXJvID0gdHJ1ZVxuICAgICAgICAsIHJvdGF0ZUxhYmVscyA9IDBcbiAgICAgICAgLCByb3RhdGVZTGFiZWwgPSB0cnVlXG4gICAgICAgICwgc3RhZ2dlckxhYmVscyA9IGZhbHNlXG4gICAgICAgICwgaXNPcmRpbmFsID0gZmFsc2VcbiAgICAgICAgLCB0aWNrcyA9IG51bGxcbiAgICAgICAgLCBheGlzTGFiZWxEaXN0YW5jZSA9IDBcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3JlbmRlckVuZCcpXG4gICAgICAgICwgYXhpc1JlbmRlcmVkID0gZmFsc2VcbiAgICAgICAgLCBtYXhNaW5SZW5kZXJlZCA9IGZhbHNlXG4gICAgICAgIDtcbiAgICBheGlzXG4gICAgICAgIC5zY2FsZShzY2FsZSlcbiAgICAgICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAgICAgLnRpY2tGb3JtYXQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KVxuICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHNjYWxlMDtcbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1heGlzJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtYXhpcycpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKVxuXG4gICAgICAgICAgICBpZiAodGlja3MgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgYXhpcy50aWNrcyh0aWNrcyk7XG4gICAgICAgICAgICBlbHNlIGlmIChheGlzLm9yaWVudCgpID09ICd0b3AnIHx8IGF4aXMub3JpZW50KCkgPT0gJ2JvdHRvbScpXG4gICAgICAgICAgICAgICAgYXhpcy50aWNrcyhNYXRoLmFicyhzY2FsZS5yYW5nZSgpWzFdIC0gc2NhbGUucmFuZ2UoKVswXSkgLyAxMDApO1xuXG4gICAgICAgICAgICAvL1RPRE86IGNvbnNpZGVyIGNhbGN1bGF0aW5nIHdpZHRoL2hlaWdodCBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBsYWJlbCBpcyBhZGRlZCwgZm9yIHJlZmVyZW5jZSBpbiBjaGFydHMgdXNpbmcgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgIGcud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnYXhpcycpLmNhbGwoYXhpcyk7XG5cbiAgICAgICAgICAgIHNjYWxlMCA9IHNjYWxlMCB8fCBheGlzLnNjYWxlKCk7XG5cbiAgICAgICAgICAgIHZhciBmbXQgPSBheGlzLnRpY2tGb3JtYXQoKTtcbiAgICAgICAgICAgIGlmIChmbXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZtdCA9IHNjYWxlMC50aWNrRm9ybWF0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBheGlzTGFiZWwgPSBnLnNlbGVjdEFsbCgndGV4dC5udi1heGlzbGFiZWwnKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtheGlzTGFiZWxUZXh0IHx8IG51bGxdKTtcbiAgICAgICAgICAgIGF4aXNMYWJlbC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoYXhpcy5vcmllbnQoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIGF4aXNMYWJlbC5lbnRlcigpLmFwcGVuZCgndGV4dCcpLmF0dHIoJ2NsYXNzJywgJ252LWF4aXNsYWJlbCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlLnJhbmdlKCkubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NhbGUucmFuZ2UoKS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBzY2FsZS5yYW5nZSgpWzFdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IHNjYWxlLnJhbmdlKClbc2NhbGUucmFuZ2UoKS5sZW5ndGgtMV0rKHNjYWxlLnJhbmdlKClbMV0tc2NhbGUucmFuZ2UoKVswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXhpc0xhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgdy8yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dNYXhNaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzTWF4TWluID0gd3JhcC5zZWxlY3RBbGwoJ2cubnYtYXhpc01heE1pbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoc2NhbGUuZG9tYWluKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pbi5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWF4aXNNYXhNaW4nKS5hcHBlbmQoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4uZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIG52LnV0aWxzLk5hTnRvWmVybyhzY2FsZShkKSkgKyAnLDApJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0wLjVlbScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAtYXhpcy50aWNrUGFkZGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGZtdChkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnJyArIHYpLm1hdGNoKCdOYU4nKSA/ICcnIDogdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4ud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbWluLW1heCB0b3AnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIG52LnV0aWxzLk5hTnRvWmVybyhzY2FsZS5yYW5nZSgpW2ldKSArICcsMCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhMYWJlbE1hcmdpbiA9IGF4aXNMYWJlbERpc3RhbmNlICsgMzY7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhUZXh0V2lkdGggPSAzMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhUaWNrcyA9IGcuc2VsZWN0QWxsKCdnJykuc2VsZWN0KFwidGV4dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdGF0ZUxhYmVscyUzNjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQ2FsY3VsYXRlIHRoZSBsb25nZXN0IHhUaWNrIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICB4VGlja3MuZWFjaChmdW5jdGlvbihkLGkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYod2lkdGggPiBtYXhUZXh0V2lkdGgpIG1heFRleHRXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0NvbnZlcnQgdG8gcmFkaWFucyBiZWZvcmUgY2FsY3VsYXRpbmcgc2luLiBBZGQgMzAgdG8gbWFyZ2luIGZvciBoZWFsdGh5IHBhZGRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90YXRlTGFiZWxzKk1hdGguUEkvMTgwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeExhYmVsTWFyZ2luID0gKHNpbiA/IHNpbiptYXhUZXh0V2lkdGggOiBtYXhUZXh0V2lkdGgpKzMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9Sb3RhdGUgYWxsIHhUaWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgeFRpY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiAncm90YXRlKCcgKyByb3RhdGVMYWJlbHMgKyAnIDAsMCknIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIHJvdGF0ZUxhYmVscyUzNjAgPiAwID8gJ3N0YXJ0JyA6ICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWwuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICdudi1heGlzbGFiZWwnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZS5yYW5nZSgpLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjYWxlLnJhbmdlKCkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gc2NhbGUucmFuZ2UoKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBzY2FsZS5yYW5nZSgpW3NjYWxlLnJhbmdlKCkubGVuZ3RoLTFdKyhzY2FsZS5yYW5nZSgpWzFdLXNjYWxlLnJhbmdlKClbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF4aXNMYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHhMYWJlbE1hcmdpbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgdy8yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dNYXhNaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgKHNob3dNYXhNaW4gJiYgIWlzT3JkaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNNYXhNaW4gPSB3cmFwLnNlbGVjdEFsbCgnZy5udi1heGlzTWF4TWluJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy5kYXRhKHNjYWxlLmRvbWFpbigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKFtzY2FsZS5kb21haW4oKVswXSwgc2NhbGUuZG9tYWluKClbc2NhbGUuZG9tYWluKCkubGVuZ3RoIC0gMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4uZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1heGlzTWF4TWluJykuYXBwZW5kKCd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBudi51dGlscy5OYU50b1plcm8oKHNjYWxlKGQpICsgKGlzT3JkaW5hbCA/IHNjYWxlLnJhbmdlQmFuZCgpIC8gMiA6IDApKSkgKyAnLDApJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy43MWVtJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGF4aXMudGlja1BhZGRpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuICdyb3RhdGUoJyArIHJvdGF0ZUxhYmVscyArICcgMCwwKScgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgcm90YXRlTGFiZWxzID8gKHJvdGF0ZUxhYmVscyUzNjAgPiAwID8gJ3N0YXJ0JyA6ICdlbmQnKSA6ICdtaWRkbGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGZtdChkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnJyArIHYpLm1hdGNoKCdOYU4nKSA/ICcnIDogdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4ud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbWluLW1heCBib3R0b20nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIG52LnV0aWxzLk5hTnRvWmVybygoc2NhbGUoZCkgKyAoaXNPcmRpbmFsID8gc2NhbGUucmFuZ2VCYW5kKCkgLyAyIDogMCkpKSArICcsMCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWdnZXJMYWJlbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB4VGlja3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsJyArIChpICUgMiA9PSAwID8gJzAnIDogJzEyJykgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIGF4aXNMYWJlbC5lbnRlcigpLmFwcGVuZCgndGV4dCcpLmF0dHIoJ2NsYXNzJywgJ252LWF4aXNsYWJlbCcpO1xuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByb3RhdGVZTGFiZWwgPyAnbWlkZGxlJyA6ICdiZWdpbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgcm90YXRlWUxhYmVsID8gJ3JvdGF0ZSg5MCknIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHJvdGF0ZVlMYWJlbCA/ICgtTWF0aC5tYXgobWFyZ2luLnJpZ2h0LHdpZHRoKSArIDEyKSA6IC0xMCkgLy9UT0RPOiBjb25zaWRlciBjYWxjdWxhdGluZyB0aGlzIGJhc2VkIG9uIGxhcmdlc3QgdGljayB3aWR0aC4uLiBPUiBhdCBsZWFzdCBleHBvc2UgdGhpcyBvbiBjaGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCByb3RhdGVZTGFiZWwgPyAoc2NhbGUucmFuZ2UoKVswXSAvIDIpIDogYXhpcy50aWNrUGFkZGluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dNYXhNaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzTWF4TWluID0gd3JhcC5zZWxlY3RBbGwoJ2cubnYtYXhpc01heE1pbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoc2NhbGUuZG9tYWluKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pbi5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWF4aXNNYXhNaW4nKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pbi5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCcgKyBudi51dGlscy5OYU50b1plcm8oc2NhbGUoZCkpICsgJyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjMyZW0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGF4aXMudGlja1BhZGRpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBmbXQoZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoJycgKyB2KS5tYXRjaCgnTmFOJykgPyAnJyA6IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ21pbi1tYXggcmlnaHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwnICsgbnYudXRpbHMuTmFOdG9aZXJvKHNjYWxlLnJhbmdlKClbaV0pICsgJyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgIC8vRm9yIGR5bmFtaWNhbGx5IHBsYWNpbmcgdGhlIGxhYmVsLiBDYW4gYmUgdXNlZCB3aXRoIGR5bmFtaWNhbGx5LXNpemVkIGNoYXJ0IGF4aXMgbWFyZ2luc1xuICAgICAgICAgICAgICAgICAgICAgdmFyIHlUaWNrcyA9IGcuc2VsZWN0QWxsKCdnJykuc2VsZWN0KFwidGV4dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgIHlUaWNrcy5lYWNoKGZ1bmN0aW9uKGQsaSl7XG4gICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxQYWRkaW5nID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIGF4aXMudGlja1BhZGRpbmcoKSArIDE2O1xuICAgICAgICAgICAgICAgICAgICAgaWYobGFiZWxQYWRkaW5nID4gd2lkdGgpIHdpZHRoID0gbGFiZWxQYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWwuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICdudi1heGlzbGFiZWwnKTtcbiAgICAgICAgICAgICAgICAgICAgYXhpc0xhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgcm90YXRlWUxhYmVsID8gJ21pZGRsZScgOiAnZW5kJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCByb3RhdGVZTGFiZWwgPyAncm90YXRlKC05MCknIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHJvdGF0ZVlMYWJlbCA/ICgtTWF0aC5tYXgobWFyZ2luLmxlZnQsd2lkdGgpICsgMjUgLSAoYXhpc0xhYmVsRGlzdGFuY2UgfHwgMCkpIDogLTEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCByb3RhdGVZTGFiZWwgPyAoLXNjYWxlLnJhbmdlKClbMF0gLyAyKSA6IC1heGlzLnRpY2tQYWRkaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd01heE1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNNYXhNaW4gPSB3cmFwLnNlbGVjdEFsbCgnZy5udi1heGlzTWF4TWluJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShzY2FsZS5kb21haW4oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYXhpc01heE1pbicpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsJyArIG52LnV0aWxzLk5hTnRvWmVybyhzY2FsZTAoZCkpICsgJyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjMyZW0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIC1heGlzLnRpY2tQYWRkaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gZm10KGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCcnICsgdikubWF0Y2goJ05hTicpID8gJycgOiB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pbi53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdtaW4tbWF4IHJpZ2h0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsJyArIG52LnV0aWxzLk5hTnRvWmVybyhzY2FsZS5yYW5nZSgpW2ldKSArICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBheGlzTGFiZWwudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2hvd01heE1pbiAmJiAoYXhpcy5vcmllbnQoKSA9PT0gJ2xlZnQnIHx8IGF4aXMub3JpZW50KCkgPT09ICdyaWdodCcpKSB7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBpZiBtYXggYW5kIG1pbiBvdmVybGFwIG90aGVyIHZhbHVlcywgaWYgc28sIGhpZGUgdGhlIHZhbHVlcyB0aGF0IG92ZXJsYXBcbiAgICAgICAgICAgICAgICBnLnNlbGVjdEFsbCgnZycpIC8vIHRoZSBnJ3Mgd3JhcHBpbmcgZWFjaCB0aWNrXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgndGV4dCcpLmF0dHIoJ29wYWNpdHknLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZShkKSA8IHNjYWxlLnJhbmdlKClbMV0gKyAxMCB8fCBzY2FsZShkKSA+IHNjYWxlLnJhbmdlKClbMF0gLSAxMCkgeyAvLyAxMCBpcyBhc3N1bWluZyB0ZXh0IGhlaWdodCBpcyAxNi4uLiBpZiBkIGlzIDAsIGxlYXZlIGl0IVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkID4gMWUtMTAgfHwgZCA8IC0xZS0xMCkgLy8gYWNjb3VudHMgZm9yIG1pbm9yIGZsb2F0aW5nIHBvaW50IGVycm9ycy4uLiB0aG91Z2ggY291bGQgYmUgcHJvYmxlbWF0aWMgaWYgdGhlIHNjYWxlIGlzIEVYVFJFTUVMWSBTTUFMTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignb3BhY2l0eScsIDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgndGV4dCcpLmF0dHIoJ29wYWNpdHknLCAwKTsgLy8gRG9uJ3QgcmVtb3ZlIHRoZSBaRVJPIGxpbmUhIVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vaWYgTWF4IGFuZCBNaW4gPSAwIG9ubHkgc2hvdyBtaW4sIElzc3VlICMyODFcbiAgICAgICAgICAgICAgICBpZiAoc2NhbGUuZG9tYWluKClbMF0gPT0gc2NhbGUuZG9tYWluKClbMV0gJiYgc2NhbGUuZG9tYWluKClbMF0gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdEFsbCgnZy5udi1heGlzTWF4TWluJykuc3R5bGUoJ29wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpID8gMSA6IDBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvd01heE1pbiAmJiAoYXhpcy5vcmllbnQoKSA9PT0gJ3RvcCcgfHwgYXhpcy5vcmllbnQoKSA9PT0gJ2JvdHRvbScpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heE1pblJhbmdlID0gW107XG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3RBbGwoJ2cubnYtYXhpc01heE1pbicpXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSkgLy8gaT09IDEsIG1heCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhNaW5SYW5nZS5wdXNoKHNjYWxlKGQpIC0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIDQpICAvL2Fzc3VtaW5nIHRoZSBtYXggYW5kIG1pbiBsYWJlbHMgYXJlIGFzIHdpZGUgYXMgdGhlIG5leHQgdGljayAod2l0aCBhbiBleHRyYSA0IHBpeGVscyBqdXN0IGluIGNhc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSAvLyBpPT0wLCBtaW4gcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4TWluUmFuZ2UucHVzaChzY2FsZShkKSArIHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKyA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfWNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSkgLy8gaT09IDEsIG1heCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhNaW5SYW5nZS5wdXNoKHNjYWxlKGQpIC0gNCk7ICAvL2Fzc3VtaW5nIHRoZSBtYXggYW5kIG1pbiBsYWJlbHMgYXJlIGFzIHdpZGUgYXMgdGhlIG5leHQgdGljayAod2l0aCBhbiBleHRyYSA0IHBpeGVscyBqdXN0IGluIGNhc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSAvLyBpPT0wLCBtaW4gcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4TWluUmFuZ2UucHVzaChzY2FsZShkKSArIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgZydzIHdyYXBwaW5nIGVhY2ggdGlja1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0QWxsKCdnJykuZWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlKGQpIDwgbWF4TWluUmFuZ2VbMF0gfHwgc2NhbGUoZCkgPiBtYXhNaW5SYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPiAxZS0xMCB8fCBkIDwgLTFlLTEwKSAvLyBhY2NvdW50cyBmb3IgbWlub3IgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLi4uIHRob3VnaCBjb3VsZCBiZSBwcm9ibGVtYXRpYyBpZiB0aGUgc2NhbGUgaXMgRVhUUkVNRUxZIFNNQUxMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKS5yZW1vdmUoKTsgLy8gRG9uJ3QgcmVtb3ZlIHRoZSBaRVJPIGxpbmUhIVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaGlnaGxpZ2h0IHplcm8gbGluZSAuLi4gTWF5YmUgc2hvdWxkIG5vdCBiZSBhbiBvcHRpb24gYW5kIHNob3VsZCBqdXN0IGJlIGluIENTUz9cbiAgICAgICAgICAgIGlmIChoaWdobGlnaHRaZXJvKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3RBbGwoJy50aWNrJylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFwYXJzZUZsb2F0KE1hdGgucm91bmQodGhpcy5fX2RhdGFfXyAqIDEwMDAwMCkgLyAxMDAwMDAwKSAmJiAodGhpcy5fX2RhdGFfXyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB9KSAvL3RoaXMgaXMgYmVjYXVzZSBzb21ldGltZXMgdGhlIDAgdGljayBpcyBhIHZlcnkgc21hbGwgZnJhY3Rpb24sIFRPRE86IHRoaW5rIG9mIGNsZWFuZXIgdGVjaG5pcXVlXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCd6ZXJvJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgICAgICAgIHNjYWxlMCA9IHNjYWxlLmNvcHkoKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2F4aXMgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuYXhpcyA9IGF4aXM7XG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICBheGlzTGFiZWxEaXN0YW5jZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gYXhpc0xhYmVsRGlzdGFuY2U7fSwgc2V0OiBmdW5jdGlvbihfKXtheGlzTGFiZWxEaXN0YW5jZT1fO319LFxuICAgICAgICBzdGFnZ2VyTGFiZWxzOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc3RhZ2dlckxhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3N0YWdnZXJMYWJlbHM9Xzt9fSxcbiAgICAgICAgcm90YXRlTGFiZWxzOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJvdGF0ZUxhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3JvdGF0ZUxhYmVscz1fO319LFxuICAgICAgICByb3RhdGVZTGFiZWw6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcm90YXRlWUxhYmVsO30sIHNldDogZnVuY3Rpb24oXyl7cm90YXRlWUxhYmVsPV87fX0sXG4gICAgICAgIGhpZ2hsaWdodFplcm86ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoaWdobGlnaHRaZXJvO30sIHNldDogZnVuY3Rpb24oXyl7aGlnaGxpZ2h0WmVybz1fO319LFxuICAgICAgICBzaG93TWF4TWluOiAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd01heE1pbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dNYXhNaW49Xzt9fSxcbiAgICAgICAgYXhpc0xhYmVsOiAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGF4aXNMYWJlbFRleHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtheGlzTGFiZWxUZXh0PV87fX0sXG4gICAgICAgIGhlaWdodDogICAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgdGlja3M6ICAgICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRpY2tzO30sIHNldDogZnVuY3Rpb24oXyl7dGlja3M9Xzt9fSxcbiAgICAgICAgd2lkdGg6ICAgICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgIT09IHVuZGVmaW5lZCAgICA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICE9PSB1bmRlZmluZWQgID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgIT09IHVuZGVmaW5lZCAgID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb249XztcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHNjYWxlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzY2FsZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgc2NhbGUgPSBfO1xuICAgICAgICAgICAgYXhpcy5zY2FsZShzY2FsZSk7XG4gICAgICAgICAgICBpc09yZGluYWwgPSB0eXBlb2Ygc2NhbGUucmFuZ2VCYW5kcyA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zRDMoY2hhcnQsIHNjYWxlLCBbJ2RvbWFpbicsICdyYW5nZScsICdyYW5nZUJhbmQnLCAncmFuZ2VCYW5kcyddKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9uc0QzKGNoYXJ0LCBheGlzLCBbJ29yaWVudCcsICd0aWNrVmFsdWVzJywgJ3RpY2tTdWJkaXZpZGUnLCAndGlja1NpemUnLCAndGlja1BhZGRpbmcnLCAndGlja0Zvcm1hdCddKTtcbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9uc0QzKGNoYXJ0LCBzY2FsZSwgWydkb21haW4nLCAncmFuZ2UnLCAncmFuZ2VCYW5kJywgJ3JhbmdlQmFuZHMnXSk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG4vLyBDaGFydCBkZXNpZ24gYmFzZWQgb24gdGhlIHJlY29tbWVuZGF0aW9ucyBvZiBTdGVwaGVuIEZldy4gSW1wbGVtZW50YXRpb25cbi8vIGJhc2VkIG9uIHRoZSB3b3JrIG9mIENsaW50IEl2eSwgSmFtaWUgTG92ZSwgYW5kIEphc29uIERhdmllcy5cbi8vIGh0dHA6Ly9wcm9qZWN0cy5pbnN0YW50Y29nbml0aW9uLmNvbS9wcm90b3Zpcy9idWxsZXRjaGFydC9cblxubnYubW9kZWxzLmJ1bGxldCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAgICAgLCBvcmllbnQgPSAnbGVmdCcgLy8gVE9ETyB0b3AgJiBib3R0b21cbiAgICAgICAgLCByZXZlcnNlID0gZmFsc2VcbiAgICAgICAgLCByYW5nZXMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnJhbmdlcyB9XG4gICAgICAgICwgbWFya2VycyA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQubWFya2VycyA/IGQubWFya2VycyA6IFswXSB9XG4gICAgICAgICwgbWVhc3VyZXMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm1lYXN1cmVzIH1cbiAgICAgICAgLCByYW5nZUxhYmVscyA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQucmFuZ2VMYWJlbHMgPyBkLnJhbmdlTGFiZWxzIDogW10gfVxuICAgICAgICAsIG1hcmtlckxhYmVscyA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQubWFya2VyTGFiZWxzID8gZC5tYXJrZXJMYWJlbHMgOiBbXSAgfVxuICAgICAgICAsIG1lYXN1cmVMYWJlbHMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm1lYXN1cmVMYWJlbHMgPyBkLm1lYXN1cmVMYWJlbHMgOiBbXSAgfVxuICAgICAgICAsIGZvcmNlWCA9IFswXSAvLyBMaXN0IG9mIG51bWJlcnMgdG8gRm9yY2UgaW50byB0aGUgWCBzY2FsZSAoaWUuIDAsIG9yIGEgbWF4IC8gbWluLCBldGMuKVxuICAgICAgICAsIHdpZHRoID0gMzgwXG4gICAgICAgICwgaGVpZ2h0ID0gMzBcbiAgICAgICAgLCB0aWNrRm9ybWF0ID0gbnVsbFxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoWycjMWY3N2I0J10pXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnKVxuICAgICAgICA7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHZhciByYW5nZXogPSByYW5nZXMuY2FsbCh0aGlzLCBkLCBpKS5zbGljZSgpLnNvcnQoZDMuZGVzY2VuZGluZyksXG4gICAgICAgICAgICAgICAgbWFya2VyeiA9IG1hcmtlcnMuY2FsbCh0aGlzLCBkLCBpKS5zbGljZSgpLnNvcnQoZDMuZGVzY2VuZGluZyksXG4gICAgICAgICAgICAgICAgbWVhc3VyZXogPSBtZWFzdXJlcy5jYWxsKHRoaXMsIGQsIGkpLnNsaWNlKCkuc29ydChkMy5kZXNjZW5kaW5nKSxcbiAgICAgICAgICAgICAgICByYW5nZUxhYmVseiA9IHJhbmdlTGFiZWxzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICBtYXJrZXJMYWJlbHogPSBtYXJrZXJMYWJlbHMuY2FsbCh0aGlzLCBkLCBpKS5zbGljZSgpLFxuICAgICAgICAgICAgICAgIG1lYXN1cmVMYWJlbHogPSBtZWFzdXJlTGFiZWxzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBuZXcgeC1zY2FsZS5cbiAgICAgICAgICAgIHZhciB4MSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAgICAgLmRvbWFpbiggZDMuZXh0ZW50KGQzLm1lcmdlKFtmb3JjZVgsIHJhbmdlel0pKSApXG4gICAgICAgICAgICAgICAgLnJhbmdlKHJldmVyc2UgPyBbYXZhaWxhYmxlV2lkdGgsIDBdIDogWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBvbGQgeC1zY2FsZSwgaWYgdGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgICAgICAgICB2YXIgeDAgPSB0aGlzLl9fY2hhcnRfXyB8fCBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgICAgIC5kb21haW4oWzAsIEluZmluaXR5XSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoeDEucmFuZ2UoKSk7XG5cbiAgICAgICAgICAgIC8vIFN0YXNoIHRoZSBuZXcgc2NhbGUuXG4gICAgICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IHgxO1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2VNaW4gPSBkMy5taW4ocmFuZ2V6KSwgLy9yYW5nZXpbMl1cbiAgICAgICAgICAgICAgICByYW5nZU1heCA9IGQzLm1heChyYW5nZXopLCAvL3JhbmdlelswXVxuICAgICAgICAgICAgICAgIHJhbmdlQXZnID0gcmFuZ2V6WzFdO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtYnVsbGV0JykuZGF0YShbZF0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtYnVsbGV0Jyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdyZWN0JykuYXR0cignY2xhc3MnLCAnbnYtcmFuZ2UgbnYtcmFuZ2VNYXgnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ3JlY3QnKS5hdHRyKCdjbGFzcycsICdudi1yYW5nZSBudi1yYW5nZUF2ZycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgncmVjdCcpLmF0dHIoJ2NsYXNzJywgJ252LXJhbmdlIG52LXJhbmdlTWluJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdyZWN0JykuYXR0cignY2xhc3MnLCAnbnYtbWVhc3VyZScpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2NsYXNzJywgJ252LW1hcmtlclRyaWFuZ2xlJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgdmFyIHcwID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gTWF0aC5hYnMoeDAoZCkgLSB4MCgwKSkgfSwgLy8gVE9ETzogY291bGQgb3B0aW1pemUgYnkgcHJlY2FsY3VsYXRpbmcgeDAoMCkgYW5kIHgxKDApXG4gICAgICAgICAgICAgICAgdzEgPSBmdW5jdGlvbihkKSB7IHJldHVybiBNYXRoLmFicyh4MShkKSAtIHgxKDApKSB9O1xuICAgICAgICAgICAgdmFyIHhwMCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgPCAwID8geDAoZCkgOiB4MCgwKSB9LFxuICAgICAgICAgICAgICAgIHhwMSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgPCAwID8geDEoZCkgOiB4MSgwKSB9O1xuXG4gICAgICAgICAgICBnLnNlbGVjdCgncmVjdC5udi1yYW5nZU1heCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB3MShyYW5nZU1heCA+IDAgPyByYW5nZU1heCA6IHJhbmdlTWluKSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHhwMShyYW5nZU1heCA+IDAgPyByYW5nZU1heCA6IHJhbmdlTWluKSlcbiAgICAgICAgICAgICAgICAuZGF0dW0ocmFuZ2VNYXggPiAwID8gcmFuZ2VNYXggOiByYW5nZU1pbilcblxuICAgICAgICAgICAgZy5zZWxlY3QoJ3JlY3QubnYtcmFuZ2VBdmcnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdzEocmFuZ2VBdmcpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeHAxKHJhbmdlQXZnKSlcbiAgICAgICAgICAgICAgICAuZGF0dW0ocmFuZ2VBdmcpXG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCdyZWN0Lm52LXJhbmdlTWluJylcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHcxKHJhbmdlTWF4KSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHhwMShyYW5nZU1heCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdzEocmFuZ2VNYXggPiAwID8gcmFuZ2VNaW4gOiByYW5nZU1heCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4cDEocmFuZ2VNYXggPiAwID8gcmFuZ2VNaW4gOiByYW5nZU1heCkpXG4gICAgICAgICAgICAgICAgLmRhdHVtKHJhbmdlTWF4ID4gMCA/IHJhbmdlTWluIDogcmFuZ2VNYXgpXG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCdyZWN0Lm52LW1lYXN1cmUnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGNvbG9yKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQgLyAzKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgYXZhaWxhYmxlSGVpZ2h0IC8gMylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBtZWFzdXJleiA8IDAgP1xuICAgICAgICAgICAgICAgICAgICB4MSgwKSAtIHgxKG1lYXN1cmV6WzBdKVxuICAgICAgICAgICAgICAgICAgICA6IHgxKG1lYXN1cmV6WzBdKSAtIHgxKDApKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeHAxKG1lYXN1cmV6KSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZWFzdXJlelswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBtZWFzdXJlTGFiZWx6WzBdIHx8ICdDdXJyZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3gxKG1lYXN1cmV6WzBdKSwgYXZhaWxhYmxlSGVpZ2h0LzJdXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWVhc3VyZXpbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbWVhc3VyZUxhYmVselswXSB8fCAnQ3VycmVudCdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGgzID0gIGF2YWlsYWJsZUhlaWdodCAvIDY7XG4gICAgICAgICAgICBpZiAobWFya2VyelswXSkge1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0QWxsKCdwYXRoLm52LW1hcmtlclRyaWFuZ2xlJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgxKG1hcmtlcnpbMF0pICsgJywnICsgKGF2YWlsYWJsZUhlaWdodCAvIDIpICsgJyknIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgJ00wLCcgKyBoMyArICdMJyArIGgzICsgJywnICsgKC1oMykgKyAnICcgKyAoLWgzKSArICcsJyArICgtaDMpICsgJ1onKVxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1hcmtlcnpbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG1hcmtlckxhYmVselswXSB8fCAnUHJldmlvdXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3gxKG1hcmtlcnpbMF0pLCBhdmFpbGFibGVIZWlnaHQvMl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1hcmtlcnpbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG1hcmtlckxhYmVselswXSB8fCAnUHJldmlvdXMnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3RBbGwoJ3BhdGgubnYtbWFya2VyVHJpYW5nbGUnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3JhcC5zZWxlY3RBbGwoJy5udi1yYW5nZScpXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gcmFuZ2VMYWJlbHpbaV0gfHwgKCFpID8gXCJNYXhpbXVtXCIgOiBpID09IDEgPyBcIk1lYW5cIiA6IFwiTWluaW11bVwiKTtcblxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbeDEoZCksIGF2YWlsYWJsZUhlaWdodC8yXVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSByYW5nZUxhYmVseltpXSB8fCAoIWkgPyBcIk1heGltdW1cIiA6IGkgPT0gMSA/IFwiTWVhblwiIDogXCJNaW5pbXVtXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHJhbmdlczogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByYW5nZXM7fSwgc2V0OiBmdW5jdGlvbihfKXtyYW5nZXM9Xzt9fSwgLy8gcmFuZ2VzIChiYWQsIHNhdGlzZmFjdG9yeSwgZ29vZClcbiAgICAgICAgbWFya2VyczogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmtlcnM7fSwgc2V0OiBmdW5jdGlvbihfKXttYXJrZXJzPV87fX0sIC8vIG1hcmtlcnMgKHByZXZpb3VzLCBnb2FsKVxuICAgICAgICBtZWFzdXJlczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWVhc3VyZXM7fSwgc2V0OiBmdW5jdGlvbihfKXttZWFzdXJlcz1fO319LCAvLyBtZWFzdXJlcyAoYWN0dWFsLCBmb3JlY2FzdClcbiAgICAgICAgZm9yY2VYOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvcmNlWDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ZvcmNlWD1fO319LFxuICAgICAgICB3aWR0aDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICB0aWNrRm9ybWF0OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0aWNrRm9ybWF0O30sIHNldDogZnVuY3Rpb24oXyl7dGlja0Zvcm1hdD1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgb3JpZW50OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBvcmllbnQ7fSwgc2V0OiBmdW5jdGlvbihfKXsgLy8gbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tXG4gICAgICAgICAgICBvcmllbnQgPSBfO1xuICAgICAgICAgICAgcmV2ZXJzZSA9IG9yaWVudCA9PSAncmlnaHQnIHx8IG9yaWVudCA9PSAnYm90dG9tJztcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxuXG5cbi8vIENoYXJ0IGRlc2lnbiBiYXNlZCBvbiB0aGUgcmVjb21tZW5kYXRpb25zIG9mIFN0ZXBoZW4gRmV3LiBJbXBsZW1lbnRhdGlvblxuLy8gYmFzZWQgb24gdGhlIHdvcmsgb2YgQ2xpbnQgSXZ5LCBKYW1pZSBMb3ZlLCBhbmQgSmFzb24gRGF2aWVzLlxuLy8gaHR0cDovL3Byb2plY3RzLmluc3RhbnRjb2duaXRpb24uY29tL3Byb3RvdmlzL2J1bGxldGNoYXJ0L1xubnYubW9kZWxzLmJ1bGxldENoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBidWxsZXQgPSBudi5tb2RlbHMuYnVsbGV0KClcbiAgICAgICAgO1xuXG4gICAgdmFyIG9yaWVudCA9ICdsZWZ0JyAvLyBUT0RPIHRvcCAmIGJvdHRvbVxuICAgICAgICAsIHJldmVyc2UgPSBmYWxzZVxuICAgICAgICAsIG1hcmdpbiA9IHt0b3A6IDUsIHJpZ2h0OiA0MCwgYm90dG9tOiAyMCwgbGVmdDogMTIwfVxuICAgICAgICAsIHJhbmdlcyA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQucmFuZ2VzIH1cbiAgICAgICAgLCBtYXJrZXJzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5tYXJrZXJzID8gZC5tYXJrZXJzIDogWzBdIH1cbiAgICAgICAgLCBtZWFzdXJlcyA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQubWVhc3VyZXMgfVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IDU1XG4gICAgICAgICwgdGlja0Zvcm1hdCA9IG51bGxcbiAgICAgICAgLCB0b29sdGlwcyA9IHRydWVcbiAgICAgICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuICc8aDM+JyArIHggKyAnPC9oMz4nICtcbiAgICAgICAgICAgICAgICAnPHA+JyArIHkgKyAnPC9wPidcbiAgICAgICAgfVxuICAgICAgICAsIG5vRGF0YSA9ICdObyBEYXRhIEF2YWlsYWJsZS4nXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnKVxuICAgICAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSArIG1hcmdpbi5sZWZ0LFxuICAgICAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApICsgbWFyZ2luLnRvcCxcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0b29sdGlwKGUua2V5LCBlLmxhYmVsLCBlLnZhbHVlLCBlLCBjaGFydCk7XG5cbiAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBlLnZhbHVlIDwgMCA/ICdlJyA6ICd3JywgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHsgY2hhcnQoc2VsZWN0aW9uKSB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWQgfHwgIXJhbmdlcy5jYWxsKHRoaXMsIGQsIGkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAxOCArIG1hcmdpbi50b3AgKyBhdmFpbGFibGVIZWlnaHQgLyAyKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByYW5nZXogPSByYW5nZXMuY2FsbCh0aGlzLCBkLCBpKS5zbGljZSgpLnNvcnQoZDMuZGVzY2VuZGluZyksXG4gICAgICAgICAgICAgICAgbWFya2VyeiA9IG1hcmtlcnMuY2FsbCh0aGlzLCBkLCBpKS5zbGljZSgpLnNvcnQoZDMuZGVzY2VuZGluZyksXG4gICAgICAgICAgICAgICAgbWVhc3VyZXogPSBtZWFzdXJlcy5jYWxsKHRoaXMsIGQsIGkpLnNsaWNlKCkuc29ydChkMy5kZXNjZW5kaW5nKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWJ1bGxldENoYXJ0JykuZGF0YShbZF0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtYnVsbGV0Q2hhcnQnKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1idWxsZXRXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtdGl0bGVzJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbmV3IHgtc2NhbGUuXG4gICAgICAgICAgICB2YXIgeDEgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgICAgIC5kb21haW4oWzAsIE1hdGgubWF4KHJhbmdlelswXSwgbWFya2VyelswXSwgbWVhc3VyZXpbMF0pXSkgIC8vIFRPRE86IG5lZWQgdG8gYWxsb3cgZm9yY2VYIGFuZCBmb3JjZVksIGFuZCB4RG9tYWluLCB5RG9tYWluXG4gICAgICAgICAgICAgICAgLnJhbmdlKHJldmVyc2UgPyBbYXZhaWxhYmxlV2lkdGgsIDBdIDogWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBvbGQgeC1zY2FsZSwgaWYgdGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgICAgICAgICB2YXIgeDAgPSB0aGlzLl9fY2hhcnRfXyB8fCBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgICAgIC5kb21haW4oWzAsIEluZmluaXR5XSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoeDEucmFuZ2UoKSk7XG5cbiAgICAgICAgICAgIC8vIFN0YXNoIHRoZSBuZXcgc2NhbGUuXG4gICAgICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IHgxO1xuXG4gICAgICAgICAgICB2YXIgdzAgPSBmdW5jdGlvbihkKSB7IHJldHVybiBNYXRoLmFicyh4MChkKSAtIHgwKDApKSB9LCAvLyBUT0RPOiBjb3VsZCBvcHRpbWl6ZSBieSBwcmVjYWxjdWxhdGluZyB4MCgwKSBhbmQgeDEoMClcbiAgICAgICAgICAgICAgICB3MSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIE1hdGguYWJzKHgxKGQpIC0geDEoMCkpIH07XG5cbiAgICAgICAgICAgIHZhciB0aXRsZSA9IGdFbnRlci5zZWxlY3QoJy5udi10aXRsZXMnKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC02LCcgKyAoaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pIC8gMiArICcpJyk7XG4gICAgICAgICAgICB0aXRsZS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi10aXRsZScpXG4gICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50aXRsZTsgfSk7XG5cbiAgICAgICAgICAgIHRpdGxlLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LXN1YnRpdGxlJylcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMWVtJylcbiAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkLnN1YnRpdGxlOyB9KTtcblxuICAgICAgICAgICAgYnVsbGV0XG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuXG4gICAgICAgICAgICB2YXIgYnVsbGV0V3JhcCA9IGcuc2VsZWN0KCcubnYtYnVsbGV0V3JhcCcpO1xuICAgICAgICAgICAgZDMudHJhbnNpdGlvbihidWxsZXRXcmFwKS5jYWxsKGJ1bGxldCk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHRpY2sgZm9ybWF0LlxuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHRpY2tGb3JtYXQgfHwgeDEudGlja0Zvcm1hdCggYXZhaWxhYmxlV2lkdGggLyAxMDAgKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0aWNrIGdyb3Vwcy5cbiAgICAgICAgICAgIHZhciB0aWNrID0gZy5zZWxlY3RBbGwoJ2cubnYtdGljaycpXG4gICAgICAgICAgICAgICAgLmRhdGEoeDEudGlja3MoIGF2YWlsYWJsZVdpZHRoIC8gNTAgKSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0Q29udGVudCB8fCBmb3JtYXQoZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHRpY2tzIHdpdGggdGhlIG9sZCBzY2FsZSwgeDAuXG4gICAgICAgICAgICB2YXIgdGlja0VudGVyID0gdGljay5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LXRpY2snKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4MChkKSArICcsMCknIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNik7XG5cbiAgICAgICAgICAgIHRpY2tFbnRlci5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBhdmFpbGFibGVIZWlnaHQgKiA3IC8gNik7XG5cbiAgICAgICAgICAgIHRpY2tFbnRlci5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcxZW0nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgYXZhaWxhYmxlSGVpZ2h0ICogNyAvIDYpXG4gICAgICAgICAgICAgICAgLnRleHQoZm9ybWF0KTtcblxuICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiB0aGUgdXBkYXRpbmcgdGlja3MgdG8gdGhlIG5ldyBzY2FsZSwgeDEuXG4gICAgICAgICAgICB2YXIgdGlja1VwZGF0ZSA9IGQzLnRyYW5zaXRpb24odGljaylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeDEoZCkgKyAnLDApJyB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xuXG4gICAgICAgICAgICB0aWNrVXBkYXRlLnNlbGVjdCgnbGluZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGF2YWlsYWJsZUhlaWdodCAqIDcgLyA2KTtcblxuICAgICAgICAgICAgdGlja1VwZGF0ZS5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgYXZhaWxhYmxlSGVpZ2h0ICogNyAvIDYpO1xuXG4gICAgICAgICAgICAvLyBUcmFuc2l0aW9uIHRoZSBleGl0aW5nIHRpY2tzIHRvIHRoZSBuZXcgc2NhbGUsIHgxLlxuICAgICAgICAgICAgZDMudHJhbnNpdGlvbih0aWNrLmV4aXQoKSlcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeDEoZCkgKyAnLDApJyB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZS5rZXkgPSBkLnRpdGxlO1xuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwcykgc2hvd1Rvb2x0aXAoZSwgdGhhdC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGQzLnRpbWVyLmZsdXNoKCk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgYnVsbGV0LmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgYnVsbGV0LmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuYnVsbGV0ID0gYnVsbGV0O1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgcmFuZ2VzOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJhbmdlczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Jhbmdlcz1fO319LCAvLyByYW5nZXMgKGJhZCwgc2F0aXNmYWN0b3J5LCBnb29kKVxuICAgICAgICBtYXJrZXJzOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFya2Vyczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe21hcmtlcnM9Xzt9fSwgLy8gbWFya2VycyAocHJldmlvdXMsIGdvYWwpXG4gICAgICAgIG1lYXN1cmVzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtZWFzdXJlczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe21lYXN1cmVzPV87fX0sIC8vIG1lYXN1cmVzIChhY3R1YWwsIGZvcmVjYXN0KVxuICAgICAgICB3aWR0aDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICB0aWNrRm9ybWF0OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0aWNrRm9ybWF0O30sIHNldDogZnVuY3Rpb24oXyl7dGlja0Zvcm1hdD1fO319LFxuICAgICAgICB0b29sdGlwczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcHM7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwcz1fO319LFxuICAgICAgICB0b29sdGlwQ29udGVudDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXA9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIG9yaWVudDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gb3JpZW50O30sIHNldDogZnVuY3Rpb24oXyl7IC8vIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbVxuICAgICAgICAgICAgb3JpZW50ID0gXztcbiAgICAgICAgICAgIHJldmVyc2UgPSBvcmllbnQgPT0gJ3JpZ2h0JyB8fCBvcmllbnQgPT0gJ2JvdHRvbSc7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgYnVsbGV0KTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5cblxubnYubW9kZWxzLmN1bXVsYXRpdmVMaW5lQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIGxpbmVzID0gbnYubW9kZWxzLmxpbmUoKVxuICAgICAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICAgICAsIGNvbnRyb2xzID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgICAgICwgaW50ZXJhY3RpdmVMYXllciA9IG52LmludGVyYWN0aXZlR3VpZGVsaW5lKClcbiAgICAgICAgO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMzAsIGJvdHRvbTogNTAsIGxlZnQ6IDYwfVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcbiAgICAgICAgLCBzaG93WEF4aXMgPSB0cnVlXG4gICAgICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxuICAgICAgICAsIHJpZ2h0QWxpZ25ZQXhpcyA9IGZhbHNlXG4gICAgICAgICwgdG9vbHRpcHMgPSB0cnVlXG4gICAgICAgICwgc2hvd0NvbnRyb2xzID0gdHJ1ZVxuICAgICAgICAsIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lID0gZmFsc2VcbiAgICAgICAgLCByZXNjYWxlWSA9IHRydWVcbiAgICAgICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuICc8aDM+JyArIGtleSArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgICc8cD4nICsgIHkgKyAnIGF0ICcgKyB4ICsgJzwvcD4nXG4gICAgICAgIH1cbiAgICAgICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxuICAgICAgICAsIHkgLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnlTY2FsZSgpXG4gICAgICAgICwgaWQgPSBsaW5lcy5pZCgpXG4gICAgICAgICwgc3RhdGUgPSBudi51dGlscy5zdGF0ZSgpXG4gICAgICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICAgICAsIG5vRGF0YSA9ICdObyBEYXRhIEF2YWlsYWJsZS4nXG4gICAgICAgICwgYXZlcmFnZSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuYXZlcmFnZSB9XG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnLCAncmVuZGVyRW5kJylcbiAgICAgICAgLCB0cmFuc2l0aW9uRHVyYXRpb24gPSAyNTBcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICAsIG5vRXJyb3JDaGVjayA9IGZhbHNlICAvL2lmIHNldCB0byBUUlVFLCB3aWxsIGJ5cGFzcyBhbiBlcnJvciBjaGVjayBpbiB0aGUgaW5kZXhpZnkgZnVuY3Rpb24uXG4gICAgICAgIDtcblxuICAgIHN0YXRlLmluZGV4ID0gMDtcbiAgICBzdGF0ZS5yZXNjYWxlWSA9IHJlc2NhbGVZO1xuXG4gICAgeEF4aXNcbiAgICAgICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAgICAgLnRpY2tQYWRkaW5nKDcpXG4gICAgO1xuICAgIHlBeGlzXG4gICAgICAgIC5vcmllbnQoKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgIDtcblxuICAgIGNvbnRyb2xzLnVwZGF0ZVN0YXRlKGZhbHNlKTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIGR4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCBpbmRleCA9IHtpOiAwLCB4OiAwfVxuICAgICAgICAsIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKVxuICAgICAgICA7XG5cbiAgICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG4gICAgICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgICAgICB4ID0geEF4aXMudGlja0Zvcm1hdCgpKGxpbmVzLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIHkgPSB5QXhpcy50aWNrRm9ybWF0KCkobGluZXMueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgY29udGVudCA9IHRvb2x0aXAoZS5zZXJpZXMua2V5LCB4LCB5LCBlLCBjaGFydCk7XG5cbiAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBudWxsLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSxcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXguaSxcbiAgICAgICAgICAgICAgICByZXNjYWxlWTogcmVzY2FsZVlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlU2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pbmRleCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGluZGV4LmkgPSBzdGF0ZS5pbmRleDtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZXNjYWxlWSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJlc2NhbGVZID0gc3RhdGUucmVzY2FsZVk7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9ICFzdGF0ZS5hY3RpdmVbaV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHJlbmRlcldhdGNoLm1vZGVscyhsaW5lcyk7XG4gICAgICAgIGlmIChzaG93WEF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh4QXhpcyk7XG4gICAgICAgIGlmIChzaG93WUF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh5QXhpcyk7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NlZCgnbnYtY2hhcnQtJyArIGlkLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuY2FsbChjaGFydCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKGNoYXJ0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICAgLnNldHRlcihzdGF0ZVNldHRlcihkYXRhKSwgY2hhcnQudXBkYXRlKVxuICAgICAgICAgICAgICAgIC5nZXR0ZXIoc3RhdGVHZXR0ZXIoZGF0YSkpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBERVBSRUNBVEVEIHNldCBzdGF0ZS5kaXNhYmxlZGRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleERyYWcgPSBkMy5iZWhhdmlvci5kcmFnKClcbiAgICAgICAgICAgICAgICAub24oJ2RyYWdzdGFydCcsIGRyYWdTdGFydClcbiAgICAgICAgICAgICAgICAub24oJ2RyYWcnLCBkcmFnTW92ZSlcbiAgICAgICAgICAgICAgICAub24oJ2RyYWdlbmQnLCBkcmFnRW5kKTtcblxuXG4gICAgICAgICAgICBmdW5jdGlvbiBkcmFnU3RhcnQoZCxpKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KGNoYXJ0LmNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdjdXJzb3InLCAnZXctcmVzaXplJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRyYWdNb3ZlKGQsaSkge1xuICAgICAgICAgICAgICAgIGluZGV4LnggPSBkMy5ldmVudC54O1xuICAgICAgICAgICAgICAgIGluZGV4LmkgPSBNYXRoLnJvdW5kKGR4LmludmVydChpbmRleC54KSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlWmVybygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBkcmFnRW5kKGQsaSkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChjaGFydC5jb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnY3Vyc29yJywgJ2F1dG8nKTtcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBzdGF0ZSBhbmQgc2VuZCBzdGF0ZUNoYW5nZSB3aXRoIG5ldyBpbmRleFxuICAgICAgICAgICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXguaTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gbGluZXMueFNjYWxlKCk7XG4gICAgICAgICAgICB5ID0gbGluZXMueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIGlmICghcmVzY2FsZVkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzRG9tYWlucyA9IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzZXJpZXMpIHsgcmV0dXJuICFzZXJpZXMuZGlzYWJsZWQgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRpYWxEb21haW4gPSBkMy5leHRlbnQoc2VyaWVzLnZhbHVlcywgbGluZXMueSgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hY2NvdW50IGZvciBzZXJpZXMgYmVpbmcgZGlzYWJsZWQgd2hlbiBsb3NpbmcgOTUlIG9yIG1vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsRG9tYWluWzBdIDwgLS45NSkgaW5pdGlhbERvbWFpblswXSA9IC0uOTU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbml0aWFsRG9tYWluWzBdIC0gaW5pdGlhbERvbWFpblsxXSkgLyAoMSArIGluaXRpYWxEb21haW5bMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5pdGlhbERvbWFpblsxXSAtIGluaXRpYWxEb21haW5bMF0pIC8gKDEgKyBpbml0aWFsRG9tYWluWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVEb21haW4gPSBbXG4gICAgICAgICAgICAgICAgICAgIGQzLm1pbihzZXJpZXNEb21haW5zLCBmdW5jdGlvbihkKSB7IHJldHVybiBkWzBdIH0pLFxuICAgICAgICAgICAgICAgICAgICBkMy5tYXgoc2VyaWVzRG9tYWlucywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZFsxXSB9KVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBsaW5lcy55RG9tYWluKGNvbXBsZXRlRG9tYWluKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZXMueURvbWFpbihudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHguZG9tYWluKFswLCBkYXRhWzBdLnZhbHVlcy5sZW5ndGggLSAxXSkgLy9Bc3N1bWVzIGFsbCBzZXJpZXMgaGF2ZSBzYW1lIGxlbmd0aFxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgYXZhaWxhYmxlV2lkdGhdKVxuICAgICAgICAgICAgICAgIC5jbGFtcCh0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBpbmRleGlmeShpbmRleC5pLCBkYXRhKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGl2ZVBvaW50ZXJFdmVudHMgPSAodXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUpID8gXCJub25lXCIgOiBcImFsbFwiO1xuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtY3VtdWxhdGl2ZUxpbmUnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1jdW11bGF0aXZlTGluZScpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtaW50ZXJhY3RpdmUnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkgbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhY2tncm91bmQnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1saW5lc1dyYXAnKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsaW50ZXJhY3RpdmVQb2ludGVyRXZlbnRzKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1hdmdMaW5lc1dyYXAnKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1jb250cm9sc1dyYXAnKTtcblxuICAgICAgICAgICAgLy8gTGVnZW5kXG4gICAgICAgICAgICBpZiAoc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aChhdmFpbGFibGVXaWR0aCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICggbWFyZ2luLnRvcCAhPSBsZWdlbmQuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udHJvbHNcbiAgICAgICAgICAgIGlmIChzaG93Q29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHNEYXRhID0gW1xuICAgICAgICAgICAgICAgICAgICB7IGtleTogJ1JlLXNjYWxlIHktYXhpcycsIGRpc2FibGVkOiAhcmVzY2FsZVkgfVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBjb250cm9sc1xuICAgICAgICAgICAgICAgICAgICAud2lkdGgoMTQwKVxuICAgICAgICAgICAgICAgICAgICAuY29sb3IoWycjNDQ0JywgJyM0NDQnLCAnIzQ0NCddKVxuICAgICAgICAgICAgICAgICAgICAucmlnaHRBbGlnbihmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcmdpbih7dG9wOiA1LCByaWdodDogMCwgYm90dG9tOiA1LCBsZWZ0OiAyMH0pXG4gICAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250cm9sc1dyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oY29udHJvbHNEYXRhKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoLW1hcmdpbi50b3ApICsnKScpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGNvbnRyb2xzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2hvdyBlcnJvciBpZiBzZXJpZXMgZ29lcyBiZWxvdyAxMDAlXG4gICAgICAgICAgICB2YXIgdGVtcERpc2FibGVkID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50ZW1wRGlzYWJsZWQgfSk7XG5cbiAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcudGVtcERpc2FibGVkJykucmVtb3ZlKCk7IC8vY2xlYW4tdXAgYW5kIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICAgICAgaWYgKHRlbXBEaXNhYmxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cmFwLmFwcGVuZCgndGV4dCcpLmF0dHIoJ2NsYXNzJywgJ3RlbXBEaXNhYmxlZCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsICctLjcxZW0nKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KHRlbXBEaXNhYmxlZC5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXkgfSkuam9pbignLCAnKSArICcgdmFsdWVzIGNhbm5vdCBiZSBjYWxjdWxhdGVkIGZvciB0aGlzIHRpbWUgcGVyaW9kLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1NldCB1cCBpbnRlcmFjdGl2ZSBsYXllclxuICAgICAgICAgICAgaWYgKHVzZUludGVyYWN0aXZlR3VpZGVsaW5lKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAubWFyZ2luKHtsZWZ0Om1hcmdpbi5sZWZ0LHRvcDptYXJnaW4udG9wfSlcbiAgICAgICAgICAgICAgICAgICAgLnN2Z0NvbnRhaW5lcihjb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgIC54U2NhbGUoeCk7XG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoXCIubnYtaW50ZXJhY3RpdmVcIikuY2FsbChpbnRlcmFjdGl2ZUxheWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ0VudGVyLnNlbGVjdCgnLm52LWJhY2tncm91bmQnKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1iYWNrZ3JvdW5kIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICBsaW5lc1xuICAgICAgICAgICAgICAgIC8vLngoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0pXG4gICAgICAgICAgICAgICAgLnkoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5kaXNwbGF5LnkgfSlcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiAhZGF0YVtpXS50ZW1wRGlzYWJsZWQ7IH0pKTtcblxuICAgICAgICAgICAgdmFyIGxpbmVzV3JhcCA9IGcuc2VsZWN0KCcubnYtbGluZXNXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gICFkLmRpc2FibGVkICYmICFkLnRlbXBEaXNhYmxlZCB9KSk7XG5cbiAgICAgICAgICAgIGxpbmVzV3JhcC5jYWxsKGxpbmVzKTtcblxuICAgICAgICAgICAgLy9TdG9yZSBhIHNlcmllcyBpbmRleCBudW1iZXIgaW4gdGhlIGRhdGEgYXJyYXkuXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZC5zZXJpZXNJbmRleCA9IGk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGF2Z0xpbmVEYXRhID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhZC5kaXNhYmxlZCAmJiAhIWF2ZXJhZ2UoZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGF2Z0xpbmVzID0gZy5zZWxlY3QoXCIubnYtYXZnTGluZXNXcmFwXCIpLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuZGF0YShhdmdMaW5lRGF0YSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXk7IH0pO1xuXG4gICAgICAgICAgICB2YXIgZ2V0QXZnTGluZVkgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgLy9JZiBhdmVyYWdlIGxpbmVzIGdvIG9mZiB0aGUgc3ZnIGVsZW1lbnQsIGNsYW1wIHRoZW0gdG8gdGhlIHN2ZyBib3VuZHMuXG4gICAgICAgICAgICAgICAgdmFyIHlWYWwgPSB5KGF2ZXJhZ2UoZCkpO1xuICAgICAgICAgICAgICAgIGlmICh5VmFsIDwgMCkgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgaWYgKHlWYWwgPiBhdmFpbGFibGVIZWlnaHQpIHJldHVybiBhdmFpbGFibGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlWYWw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhdmdMaW5lcy5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLDIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5JywnMTAsMTAnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJyxmdW5jdGlvbiAoZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lcy5jb2xvcigpKGQsZC5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJyxhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBnZXRBdmdMaW5lWSlcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBnZXRBdmdMaW5lWSk7XG5cbiAgICAgICAgICAgIGF2Z0xpbmVzXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgICAgICAgIC8vSWYgYXZlcmFnZSBsaW5lcyBnbyBvZmZzY3JlZW4sIG1ha2UgdGhlbSB0cmFuc3BhcmVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgeVZhbCA9IHkoYXZlcmFnZShkKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFsIDwgMCB8fCB5VmFsID4gYXZhaWxhYmxlSGVpZ2h0KSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJyxhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBnZXRBdmdMaW5lWSlcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBnZXRBdmdMaW5lWSk7XG5cbiAgICAgICAgICAgIGF2Z0xpbmVzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgLy9DcmVhdGUgaW5kZXggbGluZVxuICAgICAgICAgICAgdmFyIGluZGV4TGluZSA9IGxpbmVzV3JhcC5zZWxlY3RBbGwoJy5udi1pbmRleExpbmUnKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtpbmRleF0pO1xuICAgICAgICAgICAgaW5kZXhMaW5lLmVudGVyKCkuYXBwZW5kKCdyZWN0JykuYXR0cignY2xhc3MnLCAnbnYtaW5kZXhMaW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAzKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgLTIpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAncmVkJylcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbC1vcGFjaXR5JywgLjUpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIixcImFsbFwiKVxuICAgICAgICAgICAgICAgIC5jYWxsKGluZGV4RHJhZyk7XG5cbiAgICAgICAgICAgIGluZGV4TGluZVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyBkeChkLmkpICsgJywwKScgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgQXhlc1xuICAgICAgICAgICAgaWYgKHNob3dYQXhpcykge1xuICAgICAgICAgICAgICAgIHhBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgICAudGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1goYXZhaWxhYmxlV2lkdGgvNzAsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB5LnJhbmdlKClbMF0gKyAnKScpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgICAgICAgICAgeUF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi15Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVplcm8oKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhMaW5lXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKFtpbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgLy9XaGVuIGRyYWdnaW5nIHRoZSBpbmRleCBsaW5lLCB0dXJuIG9mZiBsaW5lIHRyYW5zaXRpb25zLlxuICAgICAgICAgICAgICAgIC8vIFRoZW4gdHVybiB0aGVtIGJhY2sgb24gd2hlbiBkb25lIGRyYWdnaW5nLlxuICAgICAgICAgICAgICAgIHZhciBvbGREdXJhdGlvbiA9IGNoYXJ0LmR1cmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgY2hhcnQuZHVyYXRpb24oMCk7XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgY2hhcnQuZHVyYXRpb24ob2xkRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnLnNlbGVjdCgnLm52LWJhY2tncm91bmQgcmVjdCcpXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleC54ID0gZDMubW91c2UodGhpcylbMF07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LmkgPSBNYXRoLnJvdW5kKGR4LmludmVydChpbmRleC54KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHN0YXRlIGFuZCBzZW5kIHN0YXRlQ2hhbmdlIHdpdGggbmV3IGluZGV4XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXguaTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVplcm8oKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGluZXMuZGlzcGF0Y2gub24oJ2VsZW1lbnRDbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpbmRleC5pID0gZS5wb2ludEluZGV4O1xuICAgICAgICAgICAgICAgIGluZGV4LnggPSBkeChpbmRleC5pKTtcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBzdGF0ZSBhbmQgc2VuZCBzdGF0ZUNoYW5nZSB3aXRoIG5ldyBpbmRleFxuICAgICAgICAgICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXguaTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVaZXJvKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29udHJvbHMuZGlzcGF0Y2gub24oJ2xlZ2VuZENsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9ICFkLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIHJlc2NhbGVZID0gIWQuZGlzYWJsZWQ7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5yZXNjYWxlWSA9IHJlc2NhbGVZO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGxpbmVzLmNsZWFySGlnaGxpZ2h0cygpO1xuICAgICAgICAgICAgICAgIHZhciBzaW5nbGVQb2ludCwgcG9pbnRJbmRleCwgcG9pbnRYTG9jYXRpb24sIGFsbERhdGEgPSBbXTtcblxuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5zZXJpZXNJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXNlcmllcy5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXggPSBudi5pbnRlcmFjdGl2ZUJpc2VjdChzZXJpZXMudmFsdWVzLCBlLnBvaW50WFZhbHVlLCBjaGFydC54KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuaGlnaGxpZ2h0UG9pbnQoaSwgcG9pbnRJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBzZXJpZXMudmFsdWVzW3BvaW50SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2luZ2xlUG9pbnQgPT09ICd1bmRlZmluZWQnKSBzaW5nbGVQb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludFhMb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHBvaW50WExvY2F0aW9uID0gY2hhcnQueFNjYWxlKCkoY2hhcnQueCgpKHBvaW50LHBvaW50SW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBzZXJpZXMua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaGFydC55KCkocG9pbnQsIHBvaW50SW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcihzZXJpZXMsc2VyaWVzLnNlcmllc0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9IaWdobGlnaHQgdGhlIHRvb2x0aXAgZW50cnkgYmFzZWQgb24gd2hpY2ggcG9pbnQgdGhlIG1vdXNlIGlzIGNsb3Nlc3QgdG8uXG4gICAgICAgICAgICAgICAgaWYgKGFsbERhdGEubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeVZhbHVlID0gY2hhcnQueVNjYWxlKCkuaW52ZXJ0KGUubW91c2VZKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbkV4dGVudCA9IE1hdGguYWJzKGNoYXJ0LnlTY2FsZSgpLmRvbWFpbigpWzBdIC0gY2hhcnQueVNjYWxlKCkuZG9tYWluKClbMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhyZXNob2xkID0gMC4wMyAqIGRvbWFpbkV4dGVudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4VG9IaWdobGlnaHQgPSBudi5uZWFyZXN0VmFsdWVJbmRleChhbGxEYXRhLm1hcChmdW5jdGlvbihkKXtyZXR1cm4gZC52YWx1ZX0pLHlWYWx1ZSx0aHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhUb0hpZ2hsaWdodCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERhdGFbaW5kZXhUb0hpZ2hsaWdodF0uaGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0geEF4aXMudGlja0Zvcm1hdCgpKGNoYXJ0LngoKShzaW5nbGVQb2ludCxwb2ludEluZGV4KSwgcG9pbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci50b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIC5wb3NpdGlvbih7bGVmdDogcG9pbnRYTG9jYXRpb24gKyBtYXJnaW4ubGVmdCwgdG9wOiBlLm1vdXNlWSArIG1hcmdpbi50b3B9KVxuICAgICAgICAgICAgICAgICAgICAuY2hhcnRDb250YWluZXIodGhhdC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAuZW5hYmxlZCh0b29sdGlwcylcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlBeGlzLnRpY2tGb3JtYXQoKShkKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB4VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGFsbERhdGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkoKTtcblxuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIucmVuZGVyR3VpZGVMaW5lKHBvaW50WExvY2F0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKFwiZWxlbWVudE1vdXNlb3V0XCIsZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKCk7XG4gICAgICAgICAgICAgICAgbGluZXMuY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwcykgc2hvd1Rvb2x0aXAoZSwgdGhhdC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IGUuZGlzYWJsZWRbaV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuaW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LmkgPSBlLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpbmRleC54ID0gZHgoaW5kZXguaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaW5kZXggPSBlLmluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4TGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLnJlc2NhbGVZICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXNjYWxlWSA9IGUucmVzY2FsZVk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2N1bXVsYXRpdmVMaW5lQ2hhcnQgaW1tZWRpYXRlJyk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEZ1bmN0aW9uc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgaW5kZXhpZnlZR2V0dGVyID0gbnVsbDtcbiAgICAvKiBOb3JtYWxpemUgdGhlIGRhdGEgYWNjb3JkaW5nIHRvIGFuIGluZGV4IHBvaW50LiAqL1xuICAgIGZ1bmN0aW9uIGluZGV4aWZ5KGlkeCwgZGF0YSkge1xuICAgICAgICBpZiAoIWluZGV4aWZ5WUdldHRlcikgaW5kZXhpZnlZR2V0dGVyID0gbGluZXMueSgpO1xuICAgICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24obGluZSwgaSkge1xuICAgICAgICAgICAgaWYgKCFsaW5lLnZhbHVlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4VmFsdWUgPSBsaW5lLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgaWYgKGluZGV4VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHYgPSBpbmRleGlmeVlHZXR0ZXIoaW5kZXhWYWx1ZSwgaWR4KTtcblxuICAgICAgICAgICAgLy9UT0RPOiBpbXBsZW1lbnQgY2hlY2sgYmVsb3csIGFuZCBkaXNhYmxlIHNlcmllcyBpZiBzZXJpZXMgbG9zZXMgMTAwJSBvciBtb3JlIGNhdXNlIGRpdmlkZSBieSAwIGlzc3VlXG4gICAgICAgICAgICBpZiAodiA8IC0uOTUgJiYgIW5vRXJyb3JDaGVjaykge1xuICAgICAgICAgICAgICAgIC8vaWYgYSBzZXJpZXMgbG9zZXMgbW9yZSB0aGFuIDEwMCUsIGNhbGN1bGF0aW9ucyBmYWlsLi4gYW55dGhpbmcgY2xvc2UgY2FuIGNhdXNlIG1ham9yIGRpc3RvcnRpb24gKGJ1dCBpcyBtYXRoZW1hdGljYWxseSBjb3JyZWN0IHRpbGwgaXQgaGl0cyAxMDApXG5cbiAgICAgICAgICAgICAgICBsaW5lLnRlbXBEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUudGVtcERpc2FibGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGxpbmUudmFsdWVzID0gbGluZS52YWx1ZXMubWFwKGZ1bmN0aW9uKHBvaW50LCBwb2ludEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcG9pbnQuZGlzcGxheSA9IHsneSc6IChpbmRleGlmeVlHZXR0ZXIocG9pbnQsIHBvaW50SW5kZXgpIC0gdikgLyAoMSArIHYpIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0LmxpbmVzID0gbGluZXM7XG4gICAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICAgIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gICAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgICBjaGFydC5pbnRlcmFjdGl2ZUxheWVyID0gaW50ZXJhY3RpdmVMYXllcjtcbiAgICBjaGFydC5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgcmVzY2FsZVk6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByZXNjYWxlWTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Jlc2NhbGVZPV87fX0sXG4gICAgICAgIHNob3dDb250cm9sczogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dDb250cm9sczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dDb250cm9scz1fO319LFxuICAgICAgICBzaG93TGVnZW5kOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGVnZW5kO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xlZ2VuZD1fO319LFxuICAgICAgICBhdmVyYWdlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBhdmVyYWdlO30sIHNldDogZnVuY3Rpb24oXyl7YXZlcmFnZT1fO319LFxuICAgICAgICB0b29sdGlwczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcHM7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwcz1fO319LFxuICAgICAgICB0b29sdGlwQ29udGVudDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXA9Xzt9fSxcbiAgICAgICAgZGVmYXVsdFN0YXRlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZhdWx0U3RhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXtkZWZhdWx0U3RhdGU9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcbiAgICAgICAgc2hvd1hBeGlzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WEF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WEF4aXM9Xzt9fSxcbiAgICAgICAgc2hvd1lBeGlzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WUF4aXM9Xzt9fSxcbiAgICAgICAgbm9FcnJvckNoZWNrOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0Vycm9yQ2hlY2s7fSwgc2V0OiBmdW5jdGlvbihfKXtub0Vycm9yQ2hlY2s9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgICAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgICAgICB9fSxcbiAgICAgICAgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IF87XG4gICAgICAgICAgICBpZiAoXyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNoYXJ0LmludGVyYWN0aXZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51c2VWb3Jvbm9pKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfX0sXG4gICAgICAgIHJpZ2h0QWxpZ25ZQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmlnaHRBbGlnbllBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICByaWdodEFsaWduWUF4aXMgPSBfO1xuICAgICAgICAgICAgeUF4aXMub3JpZW50KCAoXykgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICAgICAgbGluZXMuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICAgICAgeEF4aXMuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICAgICAgeUF4aXMuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIGxpbmVzKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59Oy8vVE9ETzogY29uc2lkZXIgZGVwcmVjYXRpbmcgYnkgYWRkaW5nIG5lY2Vzc2FyeSBmZWF0dXJlcyB0byBtdWx0aUJhciBtb2RlbFxubnYubW9kZWxzLmRpc2NyZXRlQmFyID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gOTYwXG4gICAgICAgICwgaGVpZ2h0ID0gNTAwXG4gICAgICAgICwgaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgLy9DcmVhdGUgc2VtaS11bmlxdWUgSUQgaW4gY2FzZSB1c2VyIGRvZXNuJ3Qgc2VsZWN0IG9uZVxuICAgICAgICAsIHggPSBkMy5zY2FsZS5vcmRpbmFsKClcbiAgICAgICAgLCB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH1cbiAgICAgICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAgICAgLCBmb3JjZVkgPSBbMF0gLy8gMCBpcyBmb3JjZWQgYnkgZGVmYXVsdC4uIHRoaXMgbWFrZXMgc2Vuc2UgZm9yIHRoZSBtYWpvcml0eSBvZiBiYXIgZ3JhcGhzLi4uIHVzZXIgY2FuIGFsd2F5cyBkbyBjaGFydC5mb3JjZVkoW10pIHRvIHJlbW92ZVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBzaG93VmFsdWVzID0gZmFsc2VcbiAgICAgICAgLCB2YWx1ZUZvcm1hdCA9IGQzLmZvcm1hdCgnLC4yZicpXG4gICAgICAgICwgeERvbWFpblxuICAgICAgICAsIHlEb21haW5cbiAgICAgICAgLCB4UmFuZ2VcbiAgICAgICAgLCB5UmFuZ2VcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdjaGFydENsaWNrJywgJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsQ2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnLCdyZW5kZXJFbmQnKVxuICAgICAgICAsIHJlY3RDbGFzcyA9ICdkaXNjcmV0ZUJhcidcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciB4MCwgeTA7XG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy9hZGQgc2VyaWVzIGluZGV4IHRvIGVhY2ggZGF0YSBwb2ludCBmb3IgcmVmZXJlbmNlXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLCBpKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnNlcmllcyA9IGk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICAvLyByZW1hcCBhbmQgZmxhdHRlbiB0aGUgZGF0YSBmb3IgdXNlIGluIGNhbGN1bGF0aW5nIHRoZSBzY2FsZXMnIGRvbWFpbnNcbiAgICAgICAgICAgIHZhciBzZXJpZXNEYXRhID0gKHhEb21haW4gJiYgeURvbWFpbikgPyBbXSA6IC8vIGlmIHdlIGtub3cgeERvbWFpbiBhbmQgeURvbWFpbiwgbm8gbmVlZCB0byBjYWxjdWxhdGVcbiAgICAgICAgICAgICAgICBkYXRhLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBnZXRYKGQsaSksIHk6IGdldFkoZCxpKSwgeTA6IGQueTAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB4ICAgLmRvbWFpbih4RG9tYWluIHx8IGQzLm1lcmdlKHNlcmllc0RhdGEpLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfSkpXG4gICAgICAgICAgICAgICAgLnJhbmdlQmFuZHMoeFJhbmdlIHx8IFswLCBhdmFpbGFibGVXaWR0aF0sIC4xKTtcbiAgICAgICAgICAgIHkgICAuZG9tYWluKHlEb21haW4gfHwgZDMuZXh0ZW50KGQzLm1lcmdlKHNlcmllc0RhdGEpLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfSkuY29uY2F0KGZvcmNlWSkpKTtcblxuICAgICAgICAgICAgLy8gSWYgc2hvd1ZhbHVlcywgcGFkIHRoZSBZIGF4aXMgcmFuZ2UgdG8gYWNjb3VudCBmb3IgbGFiZWwgaGVpZ2h0XG4gICAgICAgICAgICBpZiAoc2hvd1ZhbHVlcykgeS5yYW5nZSh5UmFuZ2UgfHwgW2F2YWlsYWJsZUhlaWdodCAtICh5LmRvbWFpbigpWzBdIDwgMCA/IDEyIDogMCksIHkuZG9tYWluKClbMV0gPiAwID8gMTIgOiAwXSk7XG4gICAgICAgICAgICBlbHNlIHkucmFuZ2UoeVJhbmdlIHx8IFthdmFpbGFibGVIZWlnaHQsIDBdKTtcblxuICAgICAgICAgICAgLy9zdG9yZSBvbGQgc2NhbGVzIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgICAgIHgwID0geDAgfHwgeDtcbiAgICAgICAgICAgIHkwID0geTAgfHwgeS5jb3B5KCkucmFuZ2UoW3koMCkseSgwKV0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtZGlzY3JldGViYXInKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1kaXNjcmV0ZWJhcicpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWdyb3VwcycpO1xuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICAvL1RPRE86IGJ5IGRlZmluaXRpb24sIHRoZSBkaXNjcmV0ZSBiYXIgc2hvdWxkIG5vdCBoYXZlIG11bHRpcGxlIGdyb3Vwcywgd2lsbCBtb2RpZnkvcmVtb3ZlIGxhdGVyXG4gICAgICAgICAgICB2YXIgZ3JvdXBzID0gd3JhcC5zZWxlY3QoJy5udi1ncm91cHMnKS5zZWxlY3RBbGwoJy5udi1ncm91cCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9LCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmtleSB9KTtcbiAgICAgICAgICAgIGdyb3Vwcy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KTtcbiAgICAgICAgICAgIGdyb3Vwcy5leGl0KClcbiAgICAgICAgICAgICAgICAud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnZGlzY3JldGVCYXI6IGV4aXQgZ3JvdXBzJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMWUtNilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgZ3JvdXBzXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAnbnYtZ3JvdXAgbnYtc2VyaWVzLScgKyBpIH0pXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hvdmVyJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5ob3ZlciB9KTtcbiAgICAgICAgICAgIGdyb3Vwc1xuICAgICAgICAgICAgICAgIC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdkaXNjcmV0ZUJhcjogZ3JvdXBzJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIC43NSk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzID0gZ3JvdXBzLnNlbGVjdEFsbCgnZy5udi1iYXInKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzIH0pO1xuICAgICAgICAgICAgYmFycy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzRW50ZXIgPSBiYXJzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpLGopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArICh4KGdldFgoZCxpKSkgKyB4LnJhbmdlQmFuZCgpICogLjA1ICkgKyAnLCAnICsgeSgwKSArICcpJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGkpIHsgLy9UT0RPOiBmaWd1cmUgb3V0IHdoeSBqIHdvcmtzIGFib3ZlLCBidXQgbm90IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChkLGkpKSArICh4LnJhbmdlQmFuZCgpICogKGQuc2VyaWVzICsgLjUpIC8gZGF0YS5sZW5ndGgpLCB5KGdldFkoZCxpKSldLCAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhlIHZhbHVlIGFwcGVhcnMgdG8gYmUgc2hpZnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50Q2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChkLGkpKSArICh4LnJhbmdlQmFuZCgpICogKGQuc2VyaWVzICsgLjUpIC8gZGF0YS5sZW5ndGgpLCB5KGdldFkoZCxpKSldLCAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhlIHZhbHVlIGFwcGVhcnMgdG8gYmUgc2hpZnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudERibENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQsaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgoZCxpKSkgKyAoeC5yYW5nZUJhbmQoKSAqIChkLnNlcmllcyArIC41KSAvIGRhdGEubGVuZ3RoKSwgeShnZXRZKGQsaSkpXSwgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoZSB2YWx1ZSBhcHBlYXJzIHRvIGJlIHNoaWZ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJhcnNFbnRlci5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHgucmFuZ2VCYW5kKCkgKiAuOSAvIGRhdGEubGVuZ3RoIClcblxuICAgICAgICAgICAgaWYgKHNob3dWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBiYXJzRW50ZXIuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAgICAgYmFycy5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHZhbHVlRm9ybWF0KGdldFkoZCxpKSkgfSlcbiAgICAgICAgICAgICAgICAgICAgLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ2Rpc2NyZXRlQmFyOiBiYXJzIHRleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHgucmFuZ2VCYW5kKCkgKiAuOSAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRZKGQsaSkgPCAwID8geShnZXRZKGQsaSkpIC0geSgwKSArIDEyIDogLTQgfSlcblxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFycy5zZWxlY3RBbGwoJ3RleHQnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmFyc1xuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WShkLGkpIDwgMCA/ICdudi1iYXIgbmVnYXRpdmUnIDogJ252LWJhciBwb3NpdGl2ZScgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCxpKSB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsaSkgfSlcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCByZWN0Q2xhc3MpXG4gICAgICAgICAgICAgICAgLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ2Rpc2NyZXRlQmFyOiBiYXJzIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHgucmFuZ2VCYW5kKCkgKiAuOSAvIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGJhcnMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnZGlzY3JldGVCYXI6IGJhcnMnKVxuICAgICAgICAgICAgICAgIC8vLmRlbGF5KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gaSAqIDEyMDAgLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGggfSlcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0geChnZXRYKGQsaSkpICsgeC5yYW5nZUJhbmQoKSAqIC4wNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IGdldFkoZCxpKSA8IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoMCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KDApIC0geShnZXRZKGQsaSkpIDwgMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSAtIDEgOiAvL21ha2UgMSBweCBwb3NpdGl2ZSBiYXJzIHNob3cgdXAgYWJvdmUgeT0wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeShnZXRZKGQsaSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBsZWZ0ICsgJywgJyArIHRvcCArICcpJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIE1hdGgubWF4KE1hdGguYWJzKHkoZ2V0WShkLGkpKSAtIHkoKHlEb21haW4gJiYgeURvbWFpblswXSkgfHwgMCkpIHx8IDEpXG4gICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgLy9zdG9yZSBvbGQgc2NhbGVzIGZvciB1c2UgaW4gdHJhbnNpdGlvbnMgb24gdXBkYXRlXG4gICAgICAgICAgICB4MCA9IHguY29weSgpO1xuICAgICAgICAgICAgeTAgPSB5LmNvcHkoKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2Rpc2NyZXRlQmFyIGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIGZvcmNlWTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvcmNlWTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ZvcmNlWT1fO319LFxuICAgICAgICBzaG93VmFsdWVzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93VmFsdWVzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1ZhbHVlcz1fO319LFxuICAgICAgICB4OiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WD1fO319LFxuICAgICAgICB5OiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WT1fO319LFxuICAgICAgICB4U2NhbGU6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4O30sIHNldDogZnVuY3Rpb24oXyl7eD1fO319LFxuICAgICAgICB5U2NhbGU6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5O30sIHNldDogZnVuY3Rpb24oXyl7eT1fO319LFxuICAgICAgICB4RG9tYWluOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eERvbWFpbj1fO319LFxuICAgICAgICB5RG9tYWluOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eURvbWFpbj1fO319LFxuICAgICAgICB4UmFuZ2U6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt4UmFuZ2U9Xzt9fSxcbiAgICAgICAgeVJhbmdlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geVJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eVJhbmdlPV87fX0sXG4gICAgICAgIHZhbHVlRm9ybWF0OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB2YWx1ZUZvcm1hdDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3ZhbHVlRm9ybWF0PV87fX0sXG4gICAgICAgIGlkOiAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2lkPV87fX0sXG4gICAgICAgIHJlY3RDbGFzczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmVjdENsYXNzO30sIHNldDogZnVuY3Rpb24oXyl7cmVjdENsYXNzPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5udi5tb2RlbHMuZGlzY3JldGVCYXJDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgZGlzY3JldGViYXIgPSBudi5tb2RlbHMuZGlzY3JldGVCYXIoKVxuICAgICAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICA7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMTUsIHJpZ2h0OiAxMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9XG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoKVxuICAgICAgICAsIHNob3dYQXhpcyA9IHRydWVcbiAgICAgICAgLCBzaG93WUF4aXMgPSB0cnVlXG4gICAgICAgICwgcmlnaHRBbGlnbllBeGlzID0gZmFsc2VcbiAgICAgICAgLCBzdGFnZ2VyTGFiZWxzID0gZmFsc2VcbiAgICAgICAgLCB0b29sdGlwcyA9IHRydWVcbiAgICAgICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuICc8aDM+JyArIHggKyAnPC9oMz4nICtcbiAgICAgICAgICAgICAgICAnPHA+JyArICB5ICsgJzwvcD4nXG4gICAgICAgIH1cbiAgICAgICAgLCB4XG4gICAgICAgICwgeVxuICAgICAgICAsIG5vRGF0YSA9IFwiTm8gRGF0YSBBdmFpbGFibGUuXCJcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdiZWZvcmVVcGRhdGUnLCdyZW5kZXJFbmQnKVxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgIDtcblxuICAgIHhBeGlzXG4gICAgICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgICAgIC5oaWdobGlnaHRaZXJvKGZhbHNlKVxuICAgICAgICAuc2hvd01heE1pbihmYWxzZSlcbiAgICAgICAgLnRpY2tGb3JtYXQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KVxuICAgIDtcbiAgICB5QXhpc1xuICAgICAgICAub3JpZW50KChyaWdodEFsaWduWUF4aXMpID8gJ3JpZ2h0JyA6ICdsZWZ0JylcbiAgICAgICAgLnRpY2tGb3JtYXQoZDMuZm9ybWF0KCcsLjFmJykpXG4gICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG4gICAgICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgICAgICB4ID0geEF4aXMudGlja0Zvcm1hdCgpKGRpc2NyZXRlYmFyLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIHkgPSB5QXhpcy50aWNrRm9ybWF0KCkoZGlzY3JldGViYXIueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgY29udGVudCA9IHRvb2x0aXAoZS5zZXJpZXMua2V5LCB4LCB5LCBlLCBjaGFydCk7XG5cbiAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBlLnZhbHVlIDwgMCA/ICduJyA6ICdzJywgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gICAgfTtcblxuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCBkdXJhdGlvbik7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKGRpc2NyZXRlYmFyKTtcbiAgICAgICAgaWYgKHNob3dYQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHhBeGlzKTtcbiAgICAgICAgaWYgKHNob3dZQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHlBeGlzKTtcblxuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guYmVmb3JlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuY2FsbChjaGFydCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBkaXNjcmV0ZWJhci54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBkaXNjcmV0ZWJhci55U2NhbGUoKS5jbGFtcCh0cnVlKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWRpc2NyZXRlQmFyV2l0aEF4ZXMnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1kaXNjcmV0ZUJhcldpdGhBeGVzJykuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZGVmc0VudGVyID0gZ0VudGVyLmFwcGVuZCgnZGVmcycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJylcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtemVyb0xpbmUnKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG5cbiAgICAgICAgICAgIGcuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgaWYgKHJpZ2h0QWxpZ25ZQXhpcykge1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KFwiLm52LXkubnYtYXhpc1wiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGF2YWlsYWJsZVdpZHRoICsgXCIsMClcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG4gICAgICAgICAgICBkaXNjcmV0ZWJhclxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzV3JhcCA9IGcuc2VsZWN0KCcubnYtYmFyc1dyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSlcblxuICAgICAgICAgICAgYmFyc1dyYXAudHJhbnNpdGlvbigpLmNhbGwoZGlzY3JldGViYXIpO1xuXG5cbiAgICAgICAgICAgIGRlZnNFbnRlci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnbnYteC1sYWJlbC1jbGlwLScgKyBkaXNjcmV0ZWJhci5pZCgpKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJyNudi14LWxhYmVsLWNsaXAtJyArIGRpc2NyZXRlYmFyLmlkKCkgKyAnIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHgucmFuZ2VCYW5kKCkgKiAoc3RhZ2dlckxhYmVscyA/IDIgOiAxKSlcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTYpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAteC5yYW5nZUJhbmQoKSAvIChzdGFnZ2VyTGFiZWxzID8gMSA6IDIgKSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIEF4ZXNcbiAgICAgICAgICAgIGlmIChzaG93WEF4aXMpIHtcbiAgICAgICAgICAgICAgICB4QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoLzEwMCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICh5LnJhbmdlKClbMF0gKyAoKGRpc2NyZXRlYmFyLnNob3dWYWx1ZXMoKSAmJiB5LmRvbWFpbigpWzBdIDwgMCkgPyAxNiA6IDApKSArICcpJyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKS5jYWxsKHhBeGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciB4VGlja3MgPSBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLnNlbGVjdEFsbCgnZycpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFnZ2VyTGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuICd0cmFuc2xhdGUoMCwnICsgKGogJSAyID09IDAgPyAnNScgOiAnMTcnKSArICcpJyB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3dZQXhpcykge1xuICAgICAgICAgICAgICAgIHlBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgICAgICAgICAudGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1koYXZhaWxhYmxlSGVpZ2h0LzM2LCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJykuY2FsbCh5QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFplcm8gbGluZVxuICAgICAgICAgICAgZy5zZWxlY3QoXCIubnYtemVyb0xpbmUgbGluZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwwKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIixhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHkoMCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5KDApKVxuICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdkaXNjcmV0ZUJhciBjaGFydCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkaXNjcmV0ZWJhci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBkaXNjcmV0ZWJhci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQuZGlzY3JldGViYXIgPSBkaXNjcmV0ZWJhcjtcbiAgICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICAgIGNoYXJ0LnlBeGlzID0geUF4aXM7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzdGFnZ2VyTGFiZWxzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzdGFnZ2VyTGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7c3RhZ2dlckxhYmVscz1fO319LFxuICAgICAgICBzaG93WEF4aXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dYQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dYQXhpcz1fO319LFxuICAgICAgICBzaG93WUF4aXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dZQXhpcz1fO319LFxuICAgICAgICB0b29sdGlwczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcHM7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwcz1fO319LFxuICAgICAgICB0b29sdGlwQ29udGVudDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXA9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICAgICAgZGlzY3JldGViYXIuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICAgICAgeEF4aXMuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICAgICAgeUF4aXMuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgICAgIGRpc2NyZXRlYmFyLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHJpZ2h0QWxpZ25ZQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmlnaHRBbGlnbllBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICByaWdodEFsaWduWUF4aXMgPSBfO1xuICAgICAgICAgICAgeUF4aXMub3JpZW50KCAoXykgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBkaXNjcmV0ZWJhcik7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufVxuXG5udi5tb2RlbHMuZGlzdHJpYnV0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAgICAgLCB3aWR0aCA9IDQwMCAvL3RlY2huaWNhbGx5IHdpZHRoIG9yIGhlaWdodCBkZXBlbmRpbmcgb24geCBvciB5Li4uLlxuICAgICAgICAsIHNpemUgPSA4XG4gICAgICAgICwgYXhpcyA9ICd4JyAvLyAneCcgb3IgJ3knLi4uIGhvcml6b250YWwgb3IgdmVydGljYWxcbiAgICAgICAgLCBnZXREYXRhID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZFtheGlzXSB9ICAvLyBkZWZhdWx0cyBkLnggb3IgZC55XG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCBkb21haW5cbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3JlbmRlckVuZCcpXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHNjYWxlMDtcbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVMZW5ndGggPSB3aWR0aCAtIChheGlzID09PSAneCcgPyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCA6IG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKSxcbiAgICAgICAgICAgICAgICBuYXhpcyA9IGF4aXMgPT0gJ3gnID8gJ3knIDogJ3gnLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuXG4gICAgICAgICAgICBzY2FsZTAgPSBzY2FsZTAgfHwgc2NhbGU7XG5cbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi1kaXN0cmlidXRpb24nKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtZGlzdHJpYnV0aW9uJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJylcblxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAgICAgICB2YXIgZGlzdFdyYXAgPSBnLnNlbGVjdEFsbCgnZy5udi1kaXN0JylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0sIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQua2V5IH0pO1xuXG4gICAgICAgICAgICBkaXN0V3JhcC5lbnRlcigpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgZGlzdFdyYXBcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICdudi1kaXN0IG52LXNlcmllcy0nICsgaSB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvcihkLCBpKSB9KTtcblxuICAgICAgICAgICAgdmFyIGRpc3QgPSBkaXN0V3JhcC5zZWxlY3RBbGwoJ2xpbmUubnYtZGlzdCcgKyBheGlzKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzIH0pXG4gICAgICAgICAgICBkaXN0LmVudGVyKCkuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cihheGlzICsgJzEnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHNjYWxlMChnZXREYXRhKGQsaSkpIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoYXhpcyArICcyJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBzY2FsZTAoZ2V0RGF0YShkLGkpKSB9KVxuICAgICAgICAgICAgcmVuZGVyV2F0Y2gudHJhbnNpdGlvbihkaXN0V3JhcC5leGl0KCkuc2VsZWN0QWxsKCdsaW5lLm52LWRpc3QnICsgYXhpcyksICdkaXN0IGV4aXQnKVxuICAgICAgICAgICAgICAgIC8vIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuYXR0cihheGlzICsgJzEnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHNjYWxlKGdldERhdGEoZCxpKSkgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihheGlzICsgJzInLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHNjYWxlKGdldERhdGEoZCxpKSkgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMClcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICBkaXN0XG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAnbnYtZGlzdCcgKyBheGlzICsgJyBudi1kaXN0JyArIGF4aXMgKyAnLScgKyBpIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIobmF4aXMgKyAnMScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIobmF4aXMgKyAnMicsIHNpemUpO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gudHJhbnNpdGlvbihkaXN0LCAnZGlzdCcpXG4gICAgICAgICAgICAgICAgLy8gLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5hdHRyKGF4aXMgKyAnMScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gc2NhbGUoZ2V0RGF0YShkLGkpKSB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKGF4aXMgKyAnMicsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gc2NhbGUoZ2V0RGF0YShkLGkpKSB9KVxuXG5cbiAgICAgICAgICAgIHNjYWxlMCA9IHNjYWxlLmNvcHkoKTtcblxuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdkaXN0cmlidXRpb24gaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuXG4gICAgY2hhcnQubWFyZ2luID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXJnaW47XG4gICAgICAgIG1hcmdpbi50b3AgICAgPSB0eXBlb2YgXy50b3AgICAgIT0gJ3VuZGVmaW5lZCcgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgbWFyZ2luLmJvdHRvbSA9IHR5cGVvZiBfLmJvdHRvbSAhPSAndW5kZWZpbmVkJyA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQud2lkdGggPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgICAgICB3aWR0aCA9IF87XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQuYXhpcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYXhpcztcbiAgICAgICAgYXhpcyA9IF87XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgICAgc2l6ZSA9IF87XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQuZ2V0RGF0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ2V0RGF0YTtcbiAgICAgICAgZ2V0RGF0YSA9IGQzLmZ1bmN0b3IoXyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQuc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNjYWxlO1xuICAgICAgICBzY2FsZSA9IF87XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQuY29sb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbG9yO1xuICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfTtcblxuICAgIGNoYXJ0LmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkdXJhdGlvbjtcbiAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgIHJldHVybiBjaGFydDtcbn1cbi8vVE9ETzogY29uc2lkZXIgZGVwcmVjYXRpbmcgYW5kIHVzaW5nIG11bHRpYmFyIHdpdGggc2luZ2xlIHNlcmllcyBmb3IgdGhpc1xubnYubW9kZWxzLmhpc3RvcmljYWxCYXIgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICAgICAsIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApIC8vQ3JlYXRlIHNlbWktdW5pcXVlIElEIGluIGNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcbiAgICAgICAgLCB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH1cbiAgICAgICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAgICAgLCBmb3JjZVggPSBbXVxuICAgICAgICAsIGZvcmNlWSA9IFswXVxuICAgICAgICAsIHBhZERhdGEgPSBmYWxzZVxuICAgICAgICAsIGNsaXBFZGdlID0gdHJ1ZVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCB4RG9tYWluXG4gICAgICAgICwgeURvbWFpblxuICAgICAgICAsIHhSYW5nZVxuICAgICAgICAsIHlSYW5nZVxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2NoYXJ0Q2xpY2snLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxDbGljaycsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcsICdyZW5kZXJFbmQnKVxuICAgICAgICAsIGludGVyYWN0aXZlID0gdHJ1ZVxuICAgICAgICA7XG5cbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgMCk7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcblxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeC5kb21haW4oeERvbWFpbiB8fCBkMy5leHRlbnQoZGF0YVswXS52YWx1ZXMubWFwKGdldFgpLmNvbmNhdChmb3JjZVgpICkpO1xuXG4gICAgICAgICAgICBpZiAocGFkRGF0YSlcbiAgICAgICAgICAgICAgICB4LnJhbmdlKHhSYW5nZSB8fCBbYXZhaWxhYmxlV2lkdGggKiAuNSAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCwgYXZhaWxhYmxlV2lkdGggKiAoZGF0YVswXS52YWx1ZXMubGVuZ3RoIC0gLjUpICAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCBdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB4LnJhbmdlKHhSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgICAgICAgeS5kb21haW4oeURvbWFpbiB8fCBkMy5leHRlbnQoZGF0YVswXS52YWx1ZXMubWFwKGdldFkpLmNvbmNhdChmb3JjZVkpICkpXG4gICAgICAgICAgICAgICAgLnJhbmdlKHlSYW5nZSB8fCBbYXZhaWxhYmxlSGVpZ2h0LCAwXSk7XG5cbiAgICAgICAgICAgIC8vIElmIHNjYWxlJ3MgZG9tYWluIGRvbid0IGhhdmUgYSByYW5nZSwgc2xpZ2h0bHkgYWRqdXN0IHRvIG1ha2Ugb25lLi4uIHNvIGEgY2hhcnQgY2FuIHNob3cgYSBzaW5nbGUgZGF0YSBwb2ludFxuICAgICAgICAgICAgaWYgKHguZG9tYWluKClbMF0gPT09IHguZG9tYWluKClbMV0pXG4gICAgICAgICAgICAgICAgeC5kb21haW4oKVswXSA/XG4gICAgICAgICAgICAgICAgICAgIHguZG9tYWluKFt4LmRvbWFpbigpWzBdIC0geC5kb21haW4oKVswXSAqIDAuMDEsIHguZG9tYWluKClbMV0gKyB4LmRvbWFpbigpWzFdICogMC4wMV0pXG4gICAgICAgICAgICAgICAgICAgIDogeC5kb21haW4oWy0xLDFdKTtcblxuICAgICAgICAgICAgaWYgKHkuZG9tYWluKClbMF0gPT09IHkuZG9tYWluKClbMV0pXG4gICAgICAgICAgICAgICAgeS5kb21haW4oKVswXSA/XG4gICAgICAgICAgICAgICAgICAgIHkuZG9tYWluKFt5LmRvbWFpbigpWzBdICsgeS5kb21haW4oKVswXSAqIDAuMDEsIHkuZG9tYWluKClbMV0gLSB5LmRvbWFpbigpWzFdICogMC4wMV0pXG4gICAgICAgICAgICAgICAgICAgIDogeS5kb21haW4oWy0xLDFdKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWhpc3RvcmljYWxCYXItJyArIGlkKS5kYXRhKFtkYXRhWzBdLnZhbHVlc10pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtaGlzdG9yaWNhbEJhci0nICsgaWQpO1xuICAgICAgICAgICAgdmFyIGRlZnNFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2RlZnMnKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1iYXJzJyk7XG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guY2hhcnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZWZzRW50ZXIuYXBwZW5kKCdjbGlwUGF0aCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ252LWNoYXJ0LWNsaXAtcGF0aC0nICsgaWQpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpO1xuXG4gICAgICAgICAgICB3cmFwLnNlbGVjdCgnI252LWNoYXJ0LWNsaXAtcGF0aC0nICsgaWQgKyAnIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICBnLmF0dHIoJ2NsaXAtcGF0aCcsIGNsaXBFZGdlID8gJ3VybCgjbnYtY2hhcnQtY2xpcC1wYXRoLScgKyBpZCArICcpJyA6ICcnKTtcblxuICAgICAgICAgICAgdmFyIGJhcnMgPSB3cmFwLnNlbGVjdCgnLm52LWJhcnMnKS5zZWxlY3RBbGwoJy5udi1iYXInKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSwgZnVuY3Rpb24oZCxpKSB7cmV0dXJuIGdldFgoZCxpKX0pO1xuICAgICAgICAgICAgYmFycy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzRW50ZXIgPSBiYXJzLmVudGVyKCkuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDAgKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24oZCxpKSB7ICByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHkoTWF0aC5tYXgoMCwgZ2V0WShkLGkpKSkpIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKE1hdGguYWJzKHkoZ2V0WShkLGkpKSAtIHkoMCkpKSB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArICh4KGdldFgoZCxpKSkgLSBhdmFpbGFibGVXaWR0aCAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCAqIC40NSkgKyAnLDApJzsgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWludGVyYWN0aXZlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpLCB5KGdldFkoZCxpKSldLCAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhlIHZhbHVlIGFwcGVhcnMgdG8gYmUgc2hpZnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnRlcmFjdGl2ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZGF0YVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWludGVyYWN0aXZlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xhYmVsOiBkW2xhYmVsXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQsaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgoZCxpKSksIHkoZ2V0WShkLGkpKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW50ZXJhY3RpdmUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudERibENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbGFiZWw6IGRbbGFiZWxdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChkLGkpKSwgeShnZXRZKGQsaSkpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYmFyc1xuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvcihkLCBpKTsgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGksaikgeyByZXR1cm4gKGdldFkoZCxpKSA8IDAgPyAnbnYtYmFyIG5lZ2F0aXZlJyA6ICdudi1iYXIgcG9zaXRpdmUnKSArICcgbnYtYmFyLScgKyBqICsgJy0nICsgaSB9KVxuICAgICAgICAgICAgICAgIC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdiYXJzJylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyAoeChnZXRYKGQsaSkpIC0gYXZhaWxhYmxlV2lkdGggLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGggKiAuNDUpICsgJywwKSc7IH0pXG4gICAgICAgICAgICAgICAgLy9UT0RPOiBiZXR0ZXIgd2lkdGggY2FsY3VsYXRpb25zIHRoYXQgZG9uJ3QgYXNzdW1lIGFsd2F5cyB1bmlmb3JtIGRhdGEgc3BhY2luZzt3XG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGF2YWlsYWJsZVdpZHRoIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoKSAqIC45ICk7XG5cbiAgICAgICAgICAgIGJhcnMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnYmFycycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ2YWwgPSBnZXRZKGQsaSkgPCAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHkoMCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoMCkgLSB5KGdldFkoZCxpKSkgPCAxID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHkoMCkgLSAxIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHkoZ2V0WShkLGkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyhydmFsKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyhNYXRoLm1heChNYXRoLmFicyh5KGdldFkoZCxpKSkgLSB5KDApKSwxKSkgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdoaXN0b3JpY2FsQmFyIGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy9DcmVhdGUgbWV0aG9kcyB0byBhbGxvdyBvdXRzaWRlIGZ1bmN0aW9ucyB0byBoaWdobGlnaHQgYSBzcGVjaWZpYyBiYXIuXG4gICAgY2hhcnQuaGlnaGxpZ2h0UG9pbnQgPSBmdW5jdGlvbihwb2ludEluZGV4LCBpc0hvdmVyT3Zlcikge1xuICAgICAgICBkMy5zZWxlY3QoXCIubnYtaGlzdG9yaWNhbEJhci1cIiArIGlkKVxuICAgICAgICAgICAgLnNlbGVjdChcIi5udi1iYXJzIC5udi1iYXItMC1cIiArIHBvaW50SW5kZXgpXG4gICAgICAgICAgICAuY2xhc3NlZChcImhvdmVyXCIsIGlzSG92ZXJPdmVyKVxuICAgICAgICA7XG4gICAgfTtcblxuICAgIGNoYXJ0LmNsZWFySGlnaGxpZ2h0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkMy5zZWxlY3QoXCIubnYtaGlzdG9yaWNhbEJhci1cIiArIGlkKVxuICAgICAgICAgICAgLnNlbGVjdChcIi5udi1iYXJzIC5udi1iYXIuaG92ZXJcIilcbiAgICAgICAgICAgIC5jbGFzc2VkKFwiaG92ZXJcIiwgZmFsc2UpXG4gICAgICAgIDtcbiAgICB9O1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIGZvcmNlWDogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvcmNlWDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ZvcmNlWD1fO319LFxuICAgICAgICBmb3JjZVk6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVk7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVk9Xzt9fSxcbiAgICAgICAgcGFkRGF0YToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcGFkRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3BhZERhdGE9Xzt9fSxcbiAgICAgICAgeDogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFg9Xzt9fSxcbiAgICAgICAgeTogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFk9Xzt9fSxcbiAgICAgICAgeFNjYWxlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3g9Xzt9fSxcbiAgICAgICAgeVNjYWxlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3k9Xzt9fSxcbiAgICAgICAgeERvbWFpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geERvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hEb21haW49Xzt9fSxcbiAgICAgICAgeURvbWFpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geURvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lEb21haW49Xzt9fSxcbiAgICAgICAgeFJhbmdlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geFJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eFJhbmdlPV87fX0sXG4gICAgICAgIHlSYW5nZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lSYW5nZT1fO319LFxuICAgICAgICBjbGlwRWRnZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY2xpcEVkZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXtjbGlwRWRnZT1fO319LFxuICAgICAgICBpZDogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtpZD1fO319LFxuICAgICAgICBpbnRlcmFjdGl2ZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaW50ZXJhY3RpdmU7fSwgc2V0OiBmdW5jdGlvbihfKXtpbnRlcmFjdGl2ZT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5oaXN0b3JpY2FsQmFyQ2hhcnQgPSBmdW5jdGlvbihiYXJfbW9kZWwpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIGJhcnMgPSBiYXJfbW9kZWwgfHwgbnYubW9kZWxzLmhpc3RvcmljYWxCYXIoKVxuICAgICAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICAgICAsIGludGVyYWN0aXZlTGF5ZXIgPSBudi5pbnRlcmFjdGl2ZUd1aWRlbGluZSgpXG4gICAgICAgIDtcblxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogOTAsIGJvdHRvbTogNTAsIGxlZnQ6IDkwfVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgc2hvd0xlZ2VuZCA9IGZhbHNlXG4gICAgICAgICwgc2hvd1hBeGlzID0gdHJ1ZVxuICAgICAgICAsIHNob3dZQXhpcyA9IHRydWVcbiAgICAgICAgLCByaWdodEFsaWduWUF4aXMgPSBmYWxzZVxuICAgICAgICAsIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lID0gZmFsc2VcbiAgICAgICAgLCB0b29sdGlwcyA9IHRydWVcbiAgICAgICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuICc8aDM+JyArIGtleSArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgICc8cD4nICsgIHkgKyAnIGF0ICcgKyB4ICsgJzwvcD4nXG4gICAgICAgIH1cbiAgICAgICAgLCB4XG4gICAgICAgICwgeVxuICAgICAgICAsIHN0YXRlID0ge31cbiAgICAgICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgICAgICwgbm9EYXRhID0gJ05vIERhdGEgQXZhaWxhYmxlLidcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsICdyZW5kZXJFbmQnKVxuICAgICAgICAsIHRyYW5zaXRpb25EdXJhdGlvbiA9IDI1MFxuICAgICAgICA7XG5cbiAgICB4QXhpc1xuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAudGlja1BhZGRpbmcoNylcbiAgICA7XG4gICAgeUF4aXNcbiAgICAgICAgLm9yaWVudCggKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuXG4gICAgICAgIC8vIE5ldyBhZGRpdGlvbiB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgU1ZHIGlzIHNjYWxlZCB3aXRoIHZpZXdCb3gsIG1heSBtb3ZlIFRPRE86IGNvbnNpZGVyIGltcGxlbWVudGluZyBldmVyeXdoZXJlIGVsc2VcbiAgICAgICAgaWYgKG9mZnNldEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBzdmcgPSBkMy5zZWxlY3Qob2Zmc2V0RWxlbWVudCkuc2VsZWN0KCdzdmcnKTtcbiAgICAgICAgICAgIHZhciB2aWV3Qm94ID0gKHN2Zy5ub2RlKCkpID8gc3ZnLmF0dHIoJ3ZpZXdCb3gnKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAodmlld0JveCkge1xuICAgICAgICAgICAgICAgIHZpZXdCb3ggPSB2aWV3Qm94LnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gcGFyc2VJbnQoc3ZnLnN0eWxlKCd3aWR0aCcpKSAvIHZpZXdCb3hbMl07XG4gICAgICAgICAgICAgICAgZS5wb3NbMF0gPSBlLnBvc1swXSAqIHJhdGlvO1xuICAgICAgICAgICAgICAgIGUucG9zWzFdID0gZS5wb3NbMV0gKiByYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgICAgICB4ID0geEF4aXMudGlja0Zvcm1hdCgpKGJhcnMueCgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgeSA9IHlBeGlzLnRpY2tGb3JtYXQoKShiYXJzLnkoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0b29sdGlwKGUuc2VyaWVzLmtleSwgeCwgeSwgZSwgY2hhcnQpO1xuXG4gICAgICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgbnVsbCwgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gICAgfTtcbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgMCk7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLm1vZGVscyhiYXJzKTtcbiAgICAgICAgICAgIGlmIChzaG93WEF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh4QXhpcyk7XG4gICAgICAgICAgICBpZiAoc2hvd1lBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeUF4aXMpO1xuXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHsgY29udGFpbmVyLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pLmNhbGwoY2hhcnQpIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICAvL3NldCBzdGF0ZS5kaXNhYmxlZFxuICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG5cbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IG5vRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gYmFycy54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBiYXJzLnlTY2FsZSgpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtaGlzdG9yaWNhbEJhckNoYXJ0JykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtaGlzdG9yaWNhbEJhckNoYXJ0JykuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1iYXJzV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1pbnRlcmFjdGl2ZScpO1xuXG4gICAgICAgICAgICAvLyBMZWdlbmRcbiAgICAgICAgICAgIGlmIChzaG93TGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kLndpZHRoKGF2YWlsYWJsZVdpZHRoKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChsZWdlbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXJnaW4udG9wICE9IGxlZ2VuZC5oZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TZXQgdXAgaW50ZXJhY3RpdmUgbGF5ZXJcbiAgICAgICAgICAgIGlmICh1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSkge1xuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgLm1hcmdpbih7bGVmdDptYXJnaW4ubGVmdCwgdG9wOm1hcmdpbi50b3B9KVxuICAgICAgICAgICAgICAgICAgICAuc3ZnQ29udGFpbmVyKGNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgLnhTY2FsZSh4KTtcbiAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdChcIi5udi1pbnRlcmFjdGl2ZVwiKS5jYWxsKGludGVyYWN0aXZlTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFyc1xuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkIH0pKTtcblxuICAgICAgICAgICAgdmFyIGJhcnNXcmFwID0gZy5zZWxlY3QoJy5udi1iYXJzV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKTtcbiAgICAgICAgICAgIGJhcnNXcmFwLnRyYW5zaXRpb24oKS5jYWxsKGJhcnMpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBBeGVzXG4gICAgICAgICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgICAgICAgICAgeEF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgICAgICAgICAgeUF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi15Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBiYXJzLmNsZWFySGlnaGxpZ2h0cygpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZVBvaW50LCBwb2ludEluZGV4LCBwb2ludFhMb2NhdGlvbiwgYWxsRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5zZXJpZXNJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXNlcmllcy5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXggPSBudi5pbnRlcmFjdGl2ZUJpc2VjdChzZXJpZXMudmFsdWVzLCBlLnBvaW50WFZhbHVlLCBjaGFydC54KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFycy5oaWdobGlnaHRQb2ludChwb2ludEluZGV4LHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gc2VyaWVzLnZhbHVlc1twb2ludEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNpbmdsZVBvaW50ID09PSAndW5kZWZpbmVkJykgc2luZ2xlUG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRYTG9jYXRpb24gPT09ICd1bmRlZmluZWQnKSBwb2ludFhMb2NhdGlvbiA9IGNoYXJ0LnhTY2FsZSgpKGNoYXJ0LngoKShwb2ludCxwb2ludEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogc2VyaWVzLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2hhcnQueSgpKHBvaW50LCBwb2ludEluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3Ioc2VyaWVzLHNlcmllcy5zZXJpZXNJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VyaWVzLnZhbHVlc1twb2ludEluZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9IHhBeGlzLnRpY2tGb3JtYXQoKShjaGFydC54KCkoc2luZ2xlUG9pbnQscG9pbnRJbmRleCkpO1xuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIudG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAucG9zaXRpb24oe2xlZnQ6IHBvaW50WExvY2F0aW9uICsgbWFyZ2luLmxlZnQsIHRvcDogZS5tb3VzZVkgKyBtYXJnaW4udG9wfSlcbiAgICAgICAgICAgICAgICAgICAgLmNoYXJ0Q29udGFpbmVyKHRoYXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgLmVuYWJsZWQodG9vbHRpcHMpXG4gICAgICAgICAgICAgICAgICAgIC52YWx1ZUZvcm1hdHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5QXhpcy50aWNrRm9ybWF0KCkoZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBhbGxEYXRhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApKCk7XG5cbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLnJlbmRlckd1aWRlTGluZShwb2ludFhMb2NhdGlvbik7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKFwiZWxlbWVudE1vdXNlb3V0XCIsZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKCk7XG4gICAgICAgICAgICAgICAgYmFycy5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ2xlZ2VuZENsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9ICFkLmRpc2FibGVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcC5zZWxlY3RBbGwoJy5udi1zZXJpZXMnKS5jbGFzc2VkKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24udHJhbnNpdGlvbigpLmNhbGwoY2hhcnQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignbGVnZW5kRGJsY2xpY2snLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgLy9Eb3VibGUgY2xpY2tpbmcgc2hvdWxkIGFsd2F5cyBlbmFibGUgY3VycmVudCBzZXJpZXMsIGFuZCBkaXNhYmxlZCBhbGwgb3RoZXJzLlxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCdjaGFuZ2VTdGF0ZScsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdoaXN0b3JpY2FsQmFyQ2hhcnQgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgYmFycy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBiYXJzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0LmJhcnMgPSBiYXJzO1xuICAgIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbiAgICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICAgIGNoYXJ0LnlBeGlzID0geUF4aXM7XG4gICAgY2hhcnQuaW50ZXJhY3RpdmVMYXllciA9IGludGVyYWN0aXZlTGF5ZXI7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzaG93TGVnZW5kOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGVnZW5kO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xlZ2VuZD1fO319LFxuICAgICAgICBzaG93WEF4aXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dYQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dYQXhpcz1fO319LFxuICAgICAgICBzaG93WUF4aXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dZQXhpcz1fO319LFxuICAgICAgICB0b29sdGlwczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcHM7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwcz1fO319LFxuICAgICAgICB0b29sdGlwQ29udGVudDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXA9Xzt9fSxcbiAgICAgICAgZGVmYXVsdFN0YXRlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZhdWx0U3RhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXtkZWZhdWx0U3RhdGU9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgICAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgICAgICAgICAgYmFycy5jb2xvcihjb2xvcik7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb249XztcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgICB5QXhpcy5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICAgICAgeEF4aXMuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHJpZ2h0QWxpZ25ZQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmlnaHRBbGlnbllBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICByaWdodEFsaWduWUF4aXMgPSBfO1xuICAgICAgICAgICAgeUF4aXMub3JpZW50KCAoXykgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjaGFydC5pbnRlcmFjdGl2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgYmFycyk7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxuXG4vLyBvaGxjQ2hhcnQgaXMganVzdCBhIGhpc3RvcmljYWwgY2hhcnQgd2l0aCBvY2xjIGJhcnMgYW5kIHNvbWUgdHdlYWtzXG5udi5tb2RlbHMub2hsY0JhckNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoYXJ0ID0gbnYubW9kZWxzLmhpc3RvcmljYWxCYXJDaGFydChudi5tb2RlbHMub2hsY0JhcigpKTtcblxuICAgIC8vIHNwZWNpYWwgZGVmYXVsdCB0b29sdGlwIHNpbmNlIHdlIHNob3cgbXVsdGlwbGUgdmFsdWVzIHBlciB4XG4gICAgY2hhcnQudXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUodHJ1ZSk7XG4gICAgY2hhcnQuaW50ZXJhY3RpdmVMYXllci50b29sdGlwLmNvbnRlbnRHZW5lcmF0b3IoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAvLyB3ZSBhc3N1bWUgb25seSBvbmUgc2VyaWVzIGV4aXN0cyBmb3IgdGhpcyBjaGFydFxuICAgICAgICB2YXIgZCA9IGRhdGEuc2VyaWVzWzBdLmRhdGE7XG4gICAgICAgIC8vIG1hdGNoIGxpbmUgY29sb3JzIGFzIGRlZmluZWQgaW4gbnYuZDMuY3NzXG4gICAgICAgIHZhciBjb2xvciA9IGQub3BlbiA8IGQuY2xvc2UgPyBcIjJjYTAyY1wiIDogXCJkNjI3MjhcIjtcbiAgICAgICAgcmV0dXJuICcnICtcbiAgICAgICAgICAgICc8aDMgc3R5bGU9XCJjb2xvcjogIycgKyBjb2xvciArICdcIj4nICsgZGF0YS52YWx1ZSArICc8L2gzPicgK1xuICAgICAgICAgICAgJzx0YWJsZT4nICtcbiAgICAgICAgICAgICc8dHI+PHRkPm9wZW46PC90ZD48dGQ+JyArIGNoYXJ0LnlBeGlzLnRpY2tGb3JtYXQoKShkLm9wZW4pICsgJzwvdGQ+PC90cj4nICtcbiAgICAgICAgICAgICc8dHI+PHRkPmNsb3NlOjwvdGQ+PHRkPicgKyBjaGFydC55QXhpcy50aWNrRm9ybWF0KCkoZC5jbG9zZSkgKyAnPC90ZD48L3RyPicgK1xuICAgICAgICAgICAgJzx0cj48dGQ+aGlnaDwvdGQ+PHRkPicgKyBjaGFydC55QXhpcy50aWNrRm9ybWF0KCkoZC5oaWdoKSArICc8L3RkPjwvdHI+JyArXG4gICAgICAgICAgICAnPHRyPjx0ZD5sb3c6PC90ZD48dGQ+JyArIGNoYXJ0LnlBeGlzLnRpY2tGb3JtYXQoKShkLmxvdykgKyAnPC90ZD48L3RyPicgK1xuICAgICAgICAgICAgJzwvdGFibGU+JztcbiAgICB9KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O252Lm1vZGVscy5sZWdlbmQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDUsIHJpZ2h0OiAwLCBib3R0b206IDUsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSA0MDBcbiAgICAgICAgLCBoZWlnaHQgPSAyMFxuICAgICAgICAsIGdldEtleSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQua2V5IH1cbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgYWxpZ24gPSB0cnVlXG4gICAgICAgICwgcmlnaHRBbGlnbiA9IHRydWVcbiAgICAgICAgLCB1cGRhdGVTdGF0ZSA9IHRydWUgICAvL0lmIHRydWUsIGxlZ2VuZCB3aWxsIHVwZGF0ZSBkYXRhLmRpc2FibGVkIGFuZCB0cmlnZ2VyIGEgJ3N0YXRlQ2hhbmdlJyBkaXNwYXRjaC5cbiAgICAgICAgLCByYWRpb0J1dHRvbk1vZGUgPSBmYWxzZSAgIC8vSWYgdHJ1ZSwgY2xpY2tpbmcgbGVnZW5kIGl0ZW1zIHdpbGwgY2F1c2UgaXQgdG8gYmVoYXZlIGxpa2UgYSByYWRpbyBidXR0b24uIChvbmx5IG9uZSBjYW4gYmUgc2VsZWN0ZWQgYXQgYSB0aW1lKVxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2xlZ2VuZENsaWNrJywgJ2xlZ2VuZERibGNsaWNrJywgJ2xlZ2VuZE1vdXNlb3ZlcicsICdsZWdlbmRNb3VzZW91dCcsICdzdGF0ZUNoYW5nZScpXG4gICAgICAgIDtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi1sZWdlbmQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbGVnZW5kJykuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgdmFyIHNlcmllcyA9IGcuc2VsZWN0QWxsKCcubnYtc2VyaWVzJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuICAgICAgICAgICAgdmFyIHNlcmllc0VudGVyID0gc2VyaWVzLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtc2VyaWVzJylcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5sZWdlbmRNb3VzZW92ZXIoZCxpKTsgIC8vVE9ETzogTWFrZSBjb25zaXN0ZW50IHdpdGggb3RoZXIgZXZlbnQgb2JqZWN0c1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5sZWdlbmRNb3VzZW91dChkLGkpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5sZWdlbmRDbGljayhkLGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYWRpb0J1dHRvbk1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1JhZGlvIGJ1dHRvbiBtb2RlOiBzZXQgZXZlcnkgc2VyaWVzIHRvIGRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBhbmQgZW5hYmxlIHRoZSBjbGlja2VkIHNlcmllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzKSB7IHNlcmllcy5kaXNhYmxlZCA9IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gIWQuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZXZlcnkoZnVuY3Rpb24oc2VyaWVzKSB7IHJldHVybiBzZXJpZXMuZGlzYWJsZWR9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIE5WRDMgbGVnZW5kcyBpcywgaWYgZXZlcnkgc2luZ2xlIHNlcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBkaXNhYmxlZCwgdHVybiBhbGwgc2VyaWVzJyBiYWNrIG9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzKSB7IHNlcmllcy5kaXNhYmxlZCA9IGZhbHNlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmxlZ2VuZERibGNsaWNrKGQsaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBOVkQzIGxlZ2VuZHMsIHdoZW4gZG91YmxlIGNsaWNraW5nIG9uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHRvIHNldCBhbGwgb3RoZXIgc2VyaWVzJyB0byBmYWxzZSwgYW5kIG1ha2UgdGhlIGRvdWJsZSBjbGlja2VkIHNlcmllcyBlbmFibGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VyaWVzRW50ZXIuYXBwZW5kKCdjaXJjbGUnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgMilcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCdudi1sZWdlbmQtc3ltYm9sJylcbiAgICAgICAgICAgICAgICAuYXR0cigncicsIDUpO1xuICAgICAgICAgICAgc2VyaWVzRW50ZXIuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnc3RhcnQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ252LWxlZ2VuZC10ZXh0JylcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjMyZW0nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsICc4Jyk7XG4gICAgICAgICAgICBzZXJpZXMuY2xhc3NlZCgnbnYtZGlzYWJsZWQnLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmRpc2FibGVkIH0pO1xuICAgICAgICAgICAgc2VyaWVzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHNlcmllcy5zZWxlY3QoJ2NpcmNsZScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsaSl9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpIH0pO1xuICAgICAgICAgICAgc2VyaWVzLnNlbGVjdCgndGV4dCcpLnRleHQoZ2V0S2V5KTtcblxuICAgICAgICAgICAgLy9UT0RPOiBpbXBsZW1lbnQgZml4ZWQtd2lkdGggYW5kIG1heC13aWR0aCBvcHRpb25zIChtYXgtd2lkdGggaXMgZXNwZWNpYWxseSB1c2VmdWwgd2l0aCB0aGUgYWxpZ24gb3B0aW9uKVxuICAgICAgICAgICAgLy8gTkVXIEFMSUdOSU5HIENPREUsIFRPRE86IGNsZWFuIHVwXG4gICAgICAgICAgICBpZiAoYWxpZ24pIHtcblxuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNXaWR0aHMgPSBbXTtcbiAgICAgICAgICAgICAgICBzZXJpZXMuZWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFRleHQgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlVGV4dExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUZXh0TGVuZ3RoID0gbGVnZW5kVGV4dC5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGVnZW5kVGV4dCBpcyBkaXNwbGF5Om5vbmUnZCAobm9kZVRleHRMZW5ndGggPT0gMCksIHNpbXVsYXRlIGFuIGVycm9yIHNvIHdlIGFwcHJveGltYXRlLCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihub2RlVGV4dExlbmd0aCA8PSAwKSB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUZXh0TGVuZ3RoID0gbnYudXRpbHMuY2FsY0FwcHJveFRleHRXaWR0aChsZWdlbmRUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc1dpZHRocy5wdXNoKG5vZGVUZXh0TGVuZ3RoICsgMjgpOyAvLyAyOCBpcyB+IHRoZSB3aWR0aCBvZiB0aGUgY2lyY2xlIHBsdXMgc29tZSBwYWRkaW5nXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzUGVyUm93ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgbGVnZW5kV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5XaWR0aHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICggbGVnZW5kV2lkdGggPCBhdmFpbGFibGVXaWR0aCAmJiBzZXJpZXNQZXJSb3cgPCBzZXJpZXNXaWR0aHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoc1tzZXJpZXNQZXJSb3ddID0gc2VyaWVzV2lkdGhzW3Nlcmllc1BlclJvd107XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZFdpZHRoICs9IHNlcmllc1dpZHRoc1tzZXJpZXNQZXJSb3crK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNQZXJSb3cgPT09IDApIHNlcmllc1BlclJvdyA9IDE7IC8vbWluaW11bSBvZiBvbmUgc2VyaWVzIHBlciByb3dcblxuICAgICAgICAgICAgICAgIHdoaWxlICggbGVnZW5kV2lkdGggPiBhdmFpbGFibGVXaWR0aCAmJiBzZXJpZXNQZXJSb3cgPiAxICkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5XaWR0aHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzUGVyUm93LS07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzZXJpZXNXaWR0aHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJpZXNXaWR0aHNba10gPiAoY29sdW1uV2lkdGhzW2sgJSBzZXJpZXNQZXJSb3ddIHx8IDApIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5XaWR0aHNbayAlIHNlcmllc1BlclJvd10gPSBzZXJpZXNXaWR0aHNba107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZWdlbmRXaWR0aCA9IGNvbHVtbldpZHRocy5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyLCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2ICsgY3VyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgeFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjdXJYID0gMDsgaSA8IHNlcmllc1BlclJvdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHhQb3NpdGlvbnNbaV0gPSBjdXJYO1xuICAgICAgICAgICAgICAgICAgICBjdXJYICs9IGNvbHVtbldpZHRoc1tpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4UG9zaXRpb25zW2kgJSBzZXJpZXNQZXJSb3ddICsgJywnICsgKDUgKyBNYXRoLmZsb29yKGkgLyBzZXJpZXNQZXJSb3cpICogMjApICsgJyknO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vcG9zaXRpb24gbGVnZW5kIGFzIGZhciByaWdodCBhcyBwb3NzaWJsZSB3aXRoaW4gdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0QWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgZy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAod2lkdGggLSBtYXJnaW4ucmlnaHQgLSBsZWdlbmRXaWR0aCkgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGcuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwJyArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhlaWdodCA9IG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tICsgKE1hdGguY2VpbChzZXJpZXNXaWR0aHMubGVuZ3RoIC8gc2VyaWVzUGVyUm93KSAqIDIwKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZhciB5cG9zID0gNSxcbiAgICAgICAgICAgICAgICAgICAgbmV3eHBvcyA9IDUsXG4gICAgICAgICAgICAgICAgICAgIG1heHdpZHRoID0gMCxcbiAgICAgICAgICAgICAgICAgICAgeHBvcztcbiAgICAgICAgICAgICAgICBzZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCd0ZXh0Jykubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpICsgMjg7XG4gICAgICAgICAgICAgICAgICAgICAgICB4cG9zID0gbmV3eHBvcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoIDwgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQgKyB4cG9zICsgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3eHBvcyA9IHhwb3MgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlwb3MgKz0gMjA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld3hwb3MgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld3hwb3MgPiBtYXh3aWR0aCkgbWF4d2lkdGggPSBuZXd4cG9zO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeHBvcyArICcsJyArIHlwb3MgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9wb3NpdGlvbiBsZWdlbmQgYXMgZmFyIHJpZ2h0IGFzIHBvc3NpYmxlIHdpdGhpbiB0aGUgdG90YWwgd2lkdGhcbiAgICAgICAgICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICh3aWR0aCAtIG1hcmdpbi5yaWdodCAtIG1heHdpZHRoKSArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20gKyB5cG9zICsgMTU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAga2V5OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRLZXk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRLZXk9Xzt9fSxcbiAgICAgICAgYWxpZ246ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gYWxpZ247fSwgc2V0OiBmdW5jdGlvbihfKXthbGlnbj1fO319LFxuICAgICAgICByaWdodEFsaWduOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByaWdodEFsaWduO30sIHNldDogZnVuY3Rpb24oXyl7cmlnaHRBbGlnbj1fO319LFxuICAgICAgICB1cGRhdGVTdGF0ZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdXBkYXRlU3RhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXt1cGRhdGVTdGF0ZT1fO319LFxuICAgICAgICByYWRpb0J1dHRvbk1vZGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJhZGlvQnV0dG9uTW9kZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3JhZGlvQnV0dG9uTW9kZT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgIHNjYXR0ZXIgPSBudi5tb2RlbHMuc2NhdHRlcigpXG4gICAgICAgIDtcblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gOTYwXG4gICAgICAgICwgaGVpZ2h0ID0gNTAwXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKSAvLyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNvbG9yXG4gICAgICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9IC8vIGFjY2Vzc29yIHRvIGdldCB0aGUgeCB2YWx1ZSBmcm9tIGEgZGF0YSBwb2ludFxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfSAvLyBhY2Nlc3NvciB0byBnZXQgdGhlIHkgdmFsdWUgZnJvbSBhIGRhdGEgcG9pbnRcbiAgICAgICAgLCBkZWZpbmVkID0gZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhaXNOYU4oZ2V0WShkLGkpKSAmJiBnZXRZKGQsaSkgIT09IG51bGwgfSAvLyBhbGxvd3MgYSBsaW5lIHRvIGJlIG5vdCBjb250aW51b3VzIHdoZW4gaXQgaXMgbm90IGRlZmluZWRcbiAgICAgICAgLCBpc0FyZWEgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLmFyZWEgfSAvLyBkZWNpZGVzIGlmIGEgbGluZSBpcyBhbiBhcmVhIG9yIGp1c3QgYSBsaW5lXG4gICAgICAgICwgY2xpcEVkZ2UgPSBmYWxzZSAvLyBpZiB0cnVlLCBtYXNrcyBsaW5lcyB3aXRoaW4geCBhbmQgeSBzY2FsZVxuICAgICAgICAsIHggLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnhTY2FsZSgpXG4gICAgICAgICwgeSAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueVNjYWxlKClcbiAgICAgICAgLCBpbnRlcnBvbGF0ZSA9IFwibGluZWFyXCIgLy8gY29udHJvbHMgdGhlIGxpbmUgaW50ZXJwb2xhdGlvblxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnZWxlbWVudENsaWNrJywgJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JywgJ3JlbmRlckVuZCcpXG4gICAgICAgIDtcblxuICAgIHNjYXR0ZXJcbiAgICAgICAgLnBvaW50U2l6ZSgxNikgLy8gZGVmYXVsdCBzaXplXG4gICAgICAgIC5wb2ludERvbWFpbihbMTYsMjU2XSkgLy9zZXQgdG8gc3BlZWQgdXAgY2FsY3VsYXRpb24sIG5lZWRzIHRvIGJlIHVuc2V0IGlmIHRoZXJlIGlzIGEgY3VzdG9tIHNpemUgYWNjZXNzb3JcbiAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciB4MCwgeTAgLy91c2VkIHRvIHN0b3JlIHByZXZpb3VzIHNjYWxlc1xuICAgICAgICAsIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKVxuICAgICAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKHNjYXR0ZXIpO1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gc2NhdHRlci54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBzY2F0dGVyLnlTY2FsZSgpO1xuXG4gICAgICAgICAgICB4MCA9IHgwIHx8IHg7XG4gICAgICAgICAgICB5MCA9IHkwIHx8IHk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1saW5lJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtbGluZScpO1xuICAgICAgICAgICAgdmFyIGRlZnNFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2RlZnMnKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1ncm91cHMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1zY2F0dGVyV3JhcCcpO1xuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIHNjYXR0ZXJcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgc2NhdHRlcldyYXAgPSB3cmFwLnNlbGVjdCgnLm52LXNjYXR0ZXJXcmFwJyk7XG4gICAgICAgICAgICBzY2F0dGVyV3JhcC5jYWxsKHNjYXR0ZXIpO1xuXG4gICAgICAgICAgICBkZWZzRW50ZXIuYXBwZW5kKCdjbGlwUGF0aCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ252LWVkZ2UtY2xpcC0nICsgc2NhdHRlci5pZCgpKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgICAgICAgd3JhcC5zZWxlY3QoJyNudi1lZGdlLWNsaXAtJyArIHNjYXR0ZXIuaWQoKSArICcgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChhdmFpbGFibGVIZWlnaHQgPiAwKSA/IGF2YWlsYWJsZUhlaWdodCA6IDApO1xuXG4gICAgICAgICAgICBnICAgLmF0dHIoJ2NsaXAtcGF0aCcsIGNsaXBFZGdlID8gJ3VybCgjbnYtZWRnZS1jbGlwLScgKyBzY2F0dGVyLmlkKCkgKyAnKScgOiAnJyk7XG4gICAgICAgICAgICBzY2F0dGVyV3JhcFxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwRWRnZSA/ICd1cmwoI252LWVkZ2UtY2xpcC0nICsgc2NhdHRlci5pZCgpICsgJyknIDogJycpO1xuXG4gICAgICAgICAgICB2YXIgZ3JvdXBzID0gd3JhcC5zZWxlY3QoJy5udi1ncm91cHMnKS5zZWxlY3RBbGwoJy5udi1ncm91cCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9LCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmtleSB9KTtcbiAgICAgICAgICAgIGdyb3Vwcy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KTtcblxuICAgICAgICAgICAgZ3JvdXBzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgZ3JvdXBzXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAnbnYtZ3JvdXAgbnYtc2VyaWVzLScgKyBpIH0pXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hvdmVyJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5ob3ZlciB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSl7IHJldHVybiBjb2xvcihkLCBpKSB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKXsgcmV0dXJuIGNvbG9yKGQsIGkpfSk7XG4gICAgICAgICAgICBncm91cHMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbGluZTogZ3JvdXBzJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIC41KTtcblxuICAgICAgICAgICAgdmFyIGFyZWFQYXRocyA9IGdyb3Vwcy5zZWxlY3RBbGwoJ3BhdGgubnYtYXJlYScpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gaXNBcmVhKGQpID8gW2RdIDogW10gfSk7IC8vIHRoaXMgaXMgZG9uZSBkaWZmZXJlbnRseSB0aGFuIGxpbmVzIGJlY2F1c2UgSSBuZWVkIHRvIGNoZWNrIGlmIHNlcmllcyBpcyBhbiBhcmVhXG4gICAgICAgICAgICBhcmVhUGF0aHMuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1hcmVhJylcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQzLnN2Zy5hcmVhKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWZpbmVkKGRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAueChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh4MChnZXRYKGQsaSkpKSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnkwKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHkwKGdldFkoZCxpKSkpIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAueTEoZnVuY3Rpb24oZCxpKSB7IHJldHVybiB5MCggeS5kb21haW4oKVswXSA8PSAwID8geS5kb21haW4oKVsxXSA+PSAwID8gMCA6IHkuZG9tYWluKClbMV0gOiB5LmRvbWFpbigpWzBdICkgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLnkxKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geTAoMCkgfSkgLy9hc3N1bWluZyAwIGlzIHdpdGhpbiB5IGRvbWFpbi4uIG1heSBuZWVkIHRvIHR3ZWFrIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseSh0aGlzLCBbZC52YWx1ZXNdKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBzLmV4aXQoKS5zZWxlY3RBbGwoJ3BhdGgubnYtYXJlYScpXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBhcmVhUGF0aHMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbGluZTogYXJlYVBhdGhzJylcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQzLnN2Zy5hcmVhKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWZpbmVkKGRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAueChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh4KGdldFgoZCxpKSkpIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBudi51dGlscy5OYU50b1plcm8oeShnZXRZKGQsaSkpKSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnkxKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geSggeS5kb21haW4oKVswXSA8PSAwID8geS5kb21haW4oKVsxXSA+PSAwID8gMCA6IHkuZG9tYWluKClbMV0gOiB5LmRvbWFpbigpWzBdICkgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLnkxKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geTAoMCkgfSkgLy9hc3N1bWluZyAwIGlzIHdpdGhpbiB5IGRvbWFpbi4uIG1heSBuZWVkIHRvIHR3ZWFrIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseSh0aGlzLCBbZC52YWx1ZXNdKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgbGluZVBhdGhzID0gZ3JvdXBzLnNlbGVjdEFsbCgncGF0aC5udi1saW5lJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBbZC52YWx1ZXNdIH0pO1xuICAgICAgICAgICAgbGluZVBhdGhzLmVudGVyKCkuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtbGluZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLFxuICAgICAgICAgICAgICAgICAgICBkMy5zdmcubGluZSgpXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgLmRlZmluZWQoZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgLngoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBudi51dGlscy5OYU50b1plcm8oeDAoZ2V0WChkLGkpKSkgfSlcbiAgICAgICAgICAgICAgICAgICAgLnkoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBudi51dGlscy5OYU50b1plcm8oeTAoZ2V0WShkLGkpKSkgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxpbmVQYXRocy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdsaW5lOiBsaW5lUGF0aHMnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJyxcbiAgICAgICAgICAgICAgICAgICAgZDMuc3ZnLmxpbmUoKVxuICAgICAgICAgICAgICAgICAgICAuaW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUpXG4gICAgICAgICAgICAgICAgICAgIC5kZWZpbmVkKGRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIC54KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHgoZ2V0WChkLGkpKSkgfSlcbiAgICAgICAgICAgICAgICAgICAgLnkoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBudi51dGlscy5OYU50b1plcm8oeShnZXRZKGQsaSkpKSB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy9zdG9yZSBvbGQgc2NhbGVzIGZvciB1c2UgaW4gdHJhbnNpdGlvbnMgb24gdXBkYXRlXG4gICAgICAgICAgICB4MCA9IHguY29weSgpO1xuICAgICAgICAgICAgeTAgPSB5LmNvcHkoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnbGluZSBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0LnNjYXR0ZXIgPSBzY2F0dGVyO1xuICAgIC8vIFBhc3MgdGhyb3VnaCBldmVudHNcbiAgICBzY2F0dGVyLmRpc3BhdGNoLm9uKCdlbGVtZW50Q2xpY2snLCBmdW5jdGlvbigpeyBkaXNwYXRjaC5lbGVtZW50Q2xpY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSlcbiAgICBzY2F0dGVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyJywgZnVuY3Rpb24oKXsgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9KVxuICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dCcsIGZ1bmN0aW9uKCl7IGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9KVxuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgZGVmaW5lZDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGVmaW5lZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RlZmluZWQ9Xzt9fSxcbiAgICAgICAgaW50ZXJwb2xhdGU6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaW50ZXJwb2xhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXtpbnRlcnBvbGF0ZT1fO319LFxuICAgICAgICBjbGlwRWRnZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY2xpcEVkZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXtjbGlwRWRnZT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgICAgICBzY2F0dGVyLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGlzQXJlYToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaXNBcmVhO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBpc0FyZWEgPSBkMy5mdW5jdG9yKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgeDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZ2V0WCA9IF87XG4gICAgICAgICAgICBzY2F0dGVyLngoXyk7XG4gICAgICAgIH19LFxuICAgICAgICB5OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBnZXRZID0gXztcbiAgICAgICAgICAgIHNjYXR0ZXIueShfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgICAgICBzY2F0dGVyLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBzY2F0dGVyKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xubnYubW9kZWxzLmxpbmVDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbGluZXMgPSBudi5tb2RlbHMubGluZSgpXG4gICAgICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgICAgICwgaW50ZXJhY3RpdmVMYXllciA9IG52LmludGVyYWN0aXZlR3VpZGVsaW5lKClcbiAgICAgICAgO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMjAsIGJvdHRvbTogNTAsIGxlZnQ6IDYwfVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcbiAgICAgICAgLCBzaG93WEF4aXMgPSB0cnVlXG4gICAgICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxuICAgICAgICAsIHJpZ2h0QWxpZ25ZQXhpcyA9IGZhbHNlXG4gICAgICAgICwgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUgPSBmYWxzZVxuICAgICAgICAsIHRvb2x0aXBzID0gdHJ1ZVxuICAgICAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxoMz4nICsga2V5ICsgJzwvaDM+JyArXG4gICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICcgYXQgJyArIHggKyAnPC9wPidcbiAgICAgICAgfVxuICAgICAgICAsIHhcbiAgICAgICAgLCB5XG4gICAgICAgICwgc3RhdGUgPSBudi51dGlscy5zdGF0ZSgpXG4gICAgICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICAgICAsIG5vRGF0YSA9ICdObyBEYXRhIEF2YWlsYWJsZS4nXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnLCAncmVuZGVyRW5kJylcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICA7XG5cbiAgICB4QXhpc1xuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAudGlja1BhZGRpbmcoNylcbiAgICA7XG4gICAgeUF4aXNcbiAgICAgICAgLm9yaWVudCgocmlnaHRBbGlnbllBeGlzKSA/ICdyaWdodCcgOiAnbGVmdCcpXG4gICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG4gICAgICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgICAgICB4ID0geEF4aXMudGlja0Zvcm1hdCgpKGxpbmVzLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIHkgPSB5QXhpcy50aWNrRm9ybWF0KCkobGluZXMueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgY29udGVudCA9IHRvb2x0aXAoZS5zZXJpZXMua2V5LCB4LCB5LCBlLCBjaGFydCk7XG5cbiAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBudWxsLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcblxuICAgIHZhciBzdGF0ZUdldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZTogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlU2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hY3RpdmUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gIXN0YXRlLmFjdGl2ZVtpXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKGxpbmVzKTtcbiAgICAgICAgaWYgKHNob3dYQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHhBeGlzKTtcbiAgICAgICAgaWYgKHNob3dZQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHlBeGlzKTtcblxuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jYWxsKGNoYXJ0KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoY2hhcnQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgICAuc2V0dGVyKHN0YXRlU2V0dGVyKGRhdGEpLCBjaGFydC51cGRhdGUpXG4gICAgICAgICAgICAgICAgLmdldHRlcihzdGF0ZUdldHRlcihkYXRhKSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIERFUFJFQ0FURUQgc2V0IHN0YXRlLmRpc2FibGVkZGlzYWJsZWRcbiAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlW2tleV0gaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGlzcGxheSBub0RhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLmxlbmd0aCB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9EYXRhVGV4dCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5kYXRhKFtub0RhdGFdKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi1ub0RhdGEnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dFxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG1hcmdpbi50b3AgKyBhdmFpbGFibGVIZWlnaHQgLyAyKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gbGluZXMueFNjYWxlKCk7XG4gICAgICAgICAgICB5ID0gbGluZXMueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1saW5lQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1saW5lQ2hhcnQnKS5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZChcInJlY3RcIikuc3R5bGUoXCJvcGFjaXR5XCIsMCk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGluZXNXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWludGVyYWN0aXZlJyk7XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KFwicmVjdFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIixhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLChhdmFpbGFibGVIZWlnaHQgPiAwKSA/IGF2YWlsYWJsZUhlaWdodCA6IDApO1xuXG4gICAgICAgICAgICAvLyBMZWdlbmRcbiAgICAgICAgICAgIGlmIChzaG93TGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kLndpZHRoKGF2YWlsYWJsZVdpZHRoKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChsZWdlbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXJnaW4udG9wICE9IGxlZ2VuZC5oZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIGlmIChyaWdodEFsaWduWUF4aXMpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdChcIi5udi15Lm52LWF4aXNcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBhdmFpbGFibGVXaWR0aCArIFwiLDApXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1NldCB1cCBpbnRlcmFjdGl2ZSBsYXllclxuICAgICAgICAgICAgaWYgKHVzZUludGVyYWN0aXZlR3VpZGVsaW5lKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAubWFyZ2luKHtsZWZ0Om1hcmdpbi5sZWZ0LCB0b3A6bWFyZ2luLnRvcH0pXG4gICAgICAgICAgICAgICAgICAgIC5zdmdDb250YWluZXIoY29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAueFNjYWxlKHgpO1xuICAgICAgICAgICAgICAgIHdyYXAuc2VsZWN0KFwiLm52LWludGVyYWN0aXZlXCIpLmNhbGwoaW50ZXJhY3RpdmVMYXllcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmVzXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgfSkpO1xuXG5cbiAgICAgICAgICAgIHZhciBsaW5lc1dyYXAgPSBnLnNlbGVjdCgnLm52LWxpbmVzV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKTtcblxuICAgICAgICAgICAgbGluZXNXcmFwLmNhbGwobGluZXMpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBBeGVzXG4gICAgICAgICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgICAgICAgICAgeEF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWChhdmFpbGFibGVXaWR0aC8xMDAsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB5LnJhbmdlKClbMF0gKyAnKScpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgICAgICAgICAgeUF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi15Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgbGluZXMuY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZVBvaW50LCBwb2ludEluZGV4LCBwb2ludFhMb2NhdGlvbiwgYWxsRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5zZXJpZXNJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXNlcmllcy5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXggPSBudi5pbnRlcmFjdGl2ZUJpc2VjdChzZXJpZXMudmFsdWVzLCBlLnBvaW50WFZhbHVlLCBjaGFydC54KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuaGlnaGxpZ2h0UG9pbnQoaSwgcG9pbnRJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBzZXJpZXMudmFsdWVzW3BvaW50SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2luZ2xlUG9pbnQgPT09ICd1bmRlZmluZWQnKSBzaW5nbGVQb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludFhMb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHBvaW50WExvY2F0aW9uID0gY2hhcnQueFNjYWxlKCkoY2hhcnQueCgpKHBvaW50LHBvaW50SW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBzZXJpZXMua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaGFydC55KCkocG9pbnQsIHBvaW50SW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcihzZXJpZXMsc2VyaWVzLnNlcmllc0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vSGlnaGxpZ2h0IHRoZSB0b29sdGlwIGVudHJ5IGJhc2VkIG9uIHdoaWNoIHBvaW50IHRoZSBtb3VzZSBpcyBjbG9zZXN0IHRvLlxuICAgICAgICAgICAgICAgIGlmIChhbGxEYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlWYWx1ZSA9IGNoYXJ0LnlTY2FsZSgpLmludmVydChlLm1vdXNlWSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb21haW5FeHRlbnQgPSBNYXRoLmFicyhjaGFydC55U2NhbGUoKS5kb21haW4oKVswXSAtIGNoYXJ0LnlTY2FsZSgpLmRvbWFpbigpWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMDMgKiBkb21haW5FeHRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleFRvSGlnaGxpZ2h0ID0gbnYubmVhcmVzdFZhbHVlSW5kZXgoYWxsRGF0YS5tYXAoZnVuY3Rpb24oZCl7cmV0dXJuIGQudmFsdWV9KSx5VmFsdWUsdGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4VG9IaWdobGlnaHQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxEYXRhW2luZGV4VG9IaWdobGlnaHRdLmhpZ2hsaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9IHhBeGlzLnRpY2tGb3JtYXQoKShjaGFydC54KCkoc2luZ2xlUG9pbnQscG9pbnRJbmRleCkpO1xuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIudG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAucG9zaXRpb24oe2xlZnQ6IHBvaW50WExvY2F0aW9uICsgbWFyZ2luLmxlZnQsIHRvcDogZS5tb3VzZVkgKyBtYXJnaW4udG9wfSlcbiAgICAgICAgICAgICAgICAgICAgLmNoYXJ0Q29udGFpbmVyKHRoYXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgLmVuYWJsZWQodG9vbHRpcHMpXG4gICAgICAgICAgICAgICAgICAgIC52YWx1ZUZvcm1hdHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5QXhpcy50aWNrRm9ybWF0KCkoZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBhbGxEYXRhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApKCk7XG5cbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLnJlbmRlckd1aWRlTGluZShwb2ludFhMb2NhdGlvbik7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKCdlbGVtZW50Q2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50WExvY2F0aW9uLCBhbGxEYXRhID0gW107XG5cbiAgICAgICAgICAgICAgICBkYXRhLmZpbHRlcihmdW5jdGlvbihzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzZXJpZXMuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50SW5kZXggPSBudi5pbnRlcmFjdGl2ZUJpc2VjdChzZXJpZXMudmFsdWVzLCBlLnBvaW50WFZhbHVlLCBjaGFydC54KCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBzZXJpZXMudmFsdWVzW3BvaW50SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50WExvY2F0aW9uID09PSAndW5kZWZpbmVkJykgcG9pbnRYTG9jYXRpb24gPSBjaGFydC54U2NhbGUoKShjaGFydC54KCkocG9pbnQscG9pbnRJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeVBvcyA9IGNoYXJ0LnlTY2FsZSgpKGNoYXJ0LnkoKShwb2ludCxwb2ludEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIGFsbERhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBwb2ludEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbcG9pbnRYTG9jYXRpb24sIHlQb3NdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllcy5zZXJpZXNJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbGluZXMuZGlzcGF0Y2guZWxlbWVudENsaWNrKGFsbERhdGEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oXCJlbGVtZW50TW91c2VvdXRcIixmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCdjaGFuZ2VTdGF0ZScsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YS5sZW5ndGggPT09IGUuZGlzYWJsZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdsaW5lQ2hhcnQgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGluZXMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgbGluZXMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgICB9KTtcblxuICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICAgIH0pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQubGluZXMgPSBsaW5lcztcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgICBjaGFydC55QXhpcyA9IHlBeGlzO1xuICAgIGNoYXJ0LmludGVyYWN0aXZlTGF5ZXIgPSBpbnRlcmFjdGl2ZUxheWVyO1xuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzaG93TGVnZW5kOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGVnZW5kO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xlZ2VuZD1fO319LFxuICAgICAgICBzaG93WEF4aXM6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1hBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1hBeGlzPV87fX0sXG4gICAgICAgIHNob3dZQXhpczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1lBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1lBeGlzPV87fX0sXG4gICAgICAgIHRvb2x0aXBzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBzPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRlZmF1bHRTdGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RlZmF1bHRTdGF0ZT1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgICAgICBsaW5lcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB4QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB5QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgICAgIGxpbmVzLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHJpZ2h0QWxpZ25ZQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmlnaHRBbGlnbllBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICByaWdodEFsaWduWUF4aXMgPSBfO1xuICAgICAgICAgICAgeUF4aXMub3JpZW50KCByaWdodEFsaWduWUF4aXMgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUgPSBfO1xuICAgICAgICAgICAgaWYgKHVzZUludGVyYWN0aXZlR3VpZGVsaW5lKSB7XG4gICAgICAgICAgICAgICAgbGluZXMuaW50ZXJhY3RpdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGxpbmVzLnVzZVZvcm9ub2koZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIGxpbmVzKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xubnYubW9kZWxzLmxpbmVQbHVzQmFyQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIGxpbmVzID0gbnYubW9kZWxzLmxpbmUoKVxuICAgICAgICAsIGxpbmVzMiA9IG52Lm1vZGVscy5saW5lKClcbiAgICAgICAgLCBiYXJzID0gbnYubW9kZWxzLmhpc3RvcmljYWxCYXIoKVxuICAgICAgICAsIGJhcnMyID0gbnYubW9kZWxzLmhpc3RvcmljYWxCYXIoKVxuICAgICAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHgyQXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5MUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeTJBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHkzQXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5NEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgICAgICwgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICA7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAzMCwgYm90dG9tOiAzMCwgbGVmdDogNjB9XG4gICAgICAgICwgbWFyZ2luMiA9IHt0b3A6IDAsIHJpZ2h0OiAzMCwgYm90dG9tOiAyMCwgbGVmdDogNjB9XG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBzaG93TGVnZW5kID0gdHJ1ZVxuICAgICAgICAsIGZvY3VzRW5hYmxlID0gdHJ1ZVxuICAgICAgICAsIGZvY3VzU2hvd0F4aXNZID0gZmFsc2VcbiAgICAgICAgLCBmb2N1c1Nob3dBeGlzWCA9IHRydWVcbiAgICAgICAgLCBmb2N1c0hlaWdodCA9IDUwXG4gICAgICAgICwgZXh0ZW50XG4gICAgICAgICwgYnJ1c2hFeHRlbnQgPSBudWxsXG4gICAgICAgICwgdG9vbHRpcHMgPSB0cnVlXG4gICAgICAgICwgdG9vbHRpcCA9IGZ1bmN0aW9uKGtleSwgeCwgeSwgZSwgZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnPGgzPicgKyBrZXkgKyAnPC9oMz4nICtcbiAgICAgICAgICAgICAgICAnPHA+JyArICB5ICsgJyBhdCAnICsgeCArICc8L3A+JztcbiAgICAgICAgfVxuICAgICAgICAsIHhcbiAgICAgICAgLCB4MlxuICAgICAgICAsIHkxXG4gICAgICAgICwgeTJcbiAgICAgICAgLCB5M1xuICAgICAgICAsIHk0XG4gICAgICAgICwgbm9EYXRhID0gXCJObyBEYXRhIEF2YWlsYWJsZS5cIlxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ2JydXNoJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJylcbiAgICAgICAgLCB0cmFuc2l0aW9uRHVyYXRpb24gPSAwXG4gICAgICAgICwgc3RhdGUgPSBudi51dGlscy5zdGF0ZSgpXG4gICAgICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICAgICAsIGxlZ2VuZExlZnRBeGlzSGludCA9ICcgKGxlZnQgYXhpcyknXG4gICAgICAgICwgbGVnZW5kUmlnaHRBeGlzSGludCA9ICcgKHJpZ2h0IGF4aXMpJ1xuICAgICAgICA7XG5cbiAgICBsaW5lc1xuICAgICAgICAuY2xpcEVkZ2UodHJ1ZSlcbiAgICA7XG4gICAgbGluZXMyXG4gICAgICAgIC5pbnRlcmFjdGl2ZShmYWxzZSlcbiAgICA7XG4gICAgeEF4aXNcbiAgICAgICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAgICAgLnRpY2tQYWRkaW5nKDUpXG4gICAgO1xuICAgIHkxQXhpc1xuICAgICAgICAub3JpZW50KCdsZWZ0JylcbiAgICA7XG4gICAgeTJBeGlzXG4gICAgICAgIC5vcmllbnQoJ3JpZ2h0JylcbiAgICA7XG4gICAgeDJBeGlzXG4gICAgICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgICAgIC50aWNrUGFkZGluZyg1KVxuICAgIDtcbiAgICB5M0F4aXNcbiAgICAgICAgLm9yaWVudCgnbGVmdCcpXG4gICAgO1xuICAgIHk0QXhpc1xuICAgICAgICAub3JpZW50KCdyaWdodCcpXG4gICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG4gICAgICAgIGlmIChleHRlbnQpIHtcbiAgICAgICAgICAgIGUucG9pbnRJbmRleCArPSBNYXRoLmNlaWwoZXh0ZW50WzBdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQgfHwgMCApLFxuICAgICAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICAgICAgeCA9IHhBeGlzLnRpY2tGb3JtYXQoKShsaW5lcy54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICB5ID0gKGUuc2VyaWVzLmJhciA/IHkxQXhpcyA6IHkyQXhpcykudGlja0Zvcm1hdCgpKGxpbmVzLnkoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0b29sdGlwKGUuc2VyaWVzLmtleSwgeCwgeSwgZSwgY2hhcnQpO1xuXG4gICAgICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgZS52YWx1ZSA8IDAgPyAnbicgOiAncycsIG51bGwsIG9mZnNldEVsZW1lbnQpO1xuICAgIH07XG5cbiAgICB2YXIgc3RhdGVHZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZVNldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9ICFzdGF0ZS5hY3RpdmVbaV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodDEgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSAtIChmb2N1c0VuYWJsZSA/IGZvY3VzSGVpZ2h0IDogMCkgLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodDIgPSBmb2N1c0hlaWdodCAtIG1hcmdpbjIudG9wIC0gbWFyZ2luMi5ib3R0b207XG5cbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikuY2FsbChjaGFydCk7IH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICAgIC5zZXR0ZXIoc3RhdGVTZXR0ZXIoZGF0YSksIGNoYXJ0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAuZ2V0dGVyKHN0YXRlR2V0dGVyKGRhdGEpKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoKTtcblxuICAgICAgICAgICAgLy8gREVQUkVDQVRFRCBzZXQgc3RhdGUuZGlzYWJsZWRkaXNhYmxlZFxuICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG5cbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IE5vIERhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLmxlbmd0aCB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9EYXRhVGV4dCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5kYXRhKFtub0RhdGFdKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi1ub0RhdGEnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dFxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG1hcmdpbi50b3AgKyBhdmFpbGFibGVIZWlnaHQxIC8gMilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHZhciBkYXRhQmFycyA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkICYmIGQuYmFyIH0pO1xuICAgICAgICAgICAgdmFyIGRhdGFMaW5lcyA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmJhciB9KTsgLy8gcmVtb3ZlZCB0aGUgIWQuZGlzYWJsZWQgY2xhdXNlIGhlcmUgdG8gZml4IElzc3VlICMyNDBcblxuICAgICAgICAgICAgeCA9IGJhcnMueFNjYWxlKCk7XG4gICAgICAgICAgICB4MiA9IHgyQXhpcy5zY2FsZSgpO1xuICAgICAgICAgICAgeTEgPSBiYXJzLnlTY2FsZSgpO1xuICAgICAgICAgICAgeTIgPSBsaW5lcy55U2NhbGUoKTtcbiAgICAgICAgICAgIHkzID0gYmFyczIueVNjYWxlKCk7XG4gICAgICAgICAgICB5NCA9IGxpbmVzMi55U2NhbGUoKTtcblxuICAgICAgICAgICAgdmFyIHNlcmllczEgPSBkYXRhXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCAmJiBkLmJhciB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZ2V0WChkLGkpLCB5OiBnZXRZKGQsaSkgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc2VyaWVzMiA9IGRhdGFcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkICYmICFkLmJhciB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZ2V0WChkLGkpLCB5OiBnZXRZKGQsaSkgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB4LnJhbmdlKFswLCBhdmFpbGFibGVXaWR0aF0pO1xuXG4gICAgICAgICAgICB4MiAgLmRvbWFpbihkMy5leHRlbnQoZDMubWVyZ2Uoc2VyaWVzMS5jb25jYXQoc2VyaWVzMikpLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfSApKVxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWxpbmVQbHVzQmFyJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtbGluZVBsdXNCYXInKS5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcblxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgbWFpbiBjaGFydFxuICAgICAgICAgICAgdmFyIGZvY3VzRW50ZXIgPSBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZm9jdXMnKTtcbiAgICAgICAgICAgIGZvY3VzRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICAgICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkxIG52LWF4aXMnKTtcbiAgICAgICAgICAgIGZvY3VzRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteTIgbnYtYXhpcycpO1xuICAgICAgICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1iYXJzV3JhcCcpO1xuICAgICAgICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1saW5lc1dyYXAnKTtcblxuICAgICAgICAgICAgLy8gY29udGV4dCBjaGFydCBpcyB3aGVyZSB5b3UgY2FuIGZvY3VzIGluXG4gICAgICAgICAgICB2YXIgY29udGV4dEVudGVyID0gZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWNvbnRleHQnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15MSBudi1heGlzJyk7XG4gICAgICAgICAgICBjb250ZXh0RW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteTIgbnYtYXhpcycpO1xuICAgICAgICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG4gICAgICAgICAgICBjb250ZXh0RW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGluZXNXcmFwJyk7XG4gICAgICAgICAgICBjb250ZXh0RW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYnJ1c2hCYWNrZ3JvdW5kJyk7XG4gICAgICAgICAgICBjb250ZXh0RW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1icnVzaCcpO1xuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gTGVnZW5kXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBpZiAoc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aCggYXZhaWxhYmxlV2lkdGggLyAyICk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5tYXAoZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMub3JpZ2luYWxLZXkgPSBzZXJpZXMub3JpZ2luYWxLZXkgPT09IHVuZGVmaW5lZCA/IHNlcmllcy5rZXkgOiBzZXJpZXMub3JpZ2luYWxLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMua2V5ID0gc2VyaWVzLm9yaWdpbmFsS2V5ICsgKHNlcmllcy5iYXIgPyBsZWdlbmRMZWZ0QXhpc0hpbnQgOiBsZWdlbmRSaWdodEF4aXNIaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpZXM7XG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChsZWdlbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXJnaW4udG9wICE9IGxlZ2VuZC5oZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQxID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tIC0gZm9jdXNIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICggYXZhaWxhYmxlV2lkdGggLyAyICkgKyAnLCcgKyAoLW1hcmdpbi50b3ApICsnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBDb250ZXh0IGNoYXJ0IChmb2N1cyBjaGFydCkgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgLy8gaGlkZSBvciBzaG93IHRoZSBmb2N1cyBjb250ZXh0IGNoYXJ0XG4gICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQnKS5zdHlsZSgnZGlzcGxheScsIGZvY3VzRW5hYmxlID8gJ2luaXRpYWwnIDogJ25vbmUnKTtcblxuICAgICAgICAgICAgYmFyczJcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQyKVxuICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmIGRhdGFbaV0uYmFyXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbGluZXMyXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0MilcbiAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiAhZGF0YVtpXS5iYXJcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzMldyYXAgPSBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LWJhcnNXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YUJhcnMubGVuZ3RoID8gZGF0YUJhcnMgOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YWx1ZXM6IFtdfVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdmFyIGxpbmVzMldyYXAgPSBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LWxpbmVzV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKCFkYXRhTGluZXNbMF0uZGlzYWJsZWQgPyBkYXRhTGluZXMgOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YWx1ZXM6IFtdfVxuICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICggYXZhaWxhYmxlSGVpZ2h0MSArIG1hcmdpbi5ib3R0b20gKyBtYXJnaW4yLnRvcCkgKyAnKScpO1xuXG4gICAgICAgICAgICBiYXJzMldyYXAudHJhbnNpdGlvbigpLmNhbGwoYmFyczIpO1xuICAgICAgICAgICAgbGluZXMyV3JhcC50cmFuc2l0aW9uKCkuY2FsbChsaW5lczIpO1xuXG4gICAgICAgICAgICAvLyBjb250ZXh0IChmb2N1cyBjaGFydCkgYXhpcyBjb250cm9sc1xuICAgICAgICAgICAgaWYgKGZvY3VzU2hvd0F4aXNYKSB7XG4gICAgICAgICAgICAgICAgeDJBeGlzXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyhudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoIC8gMTAwLCBkYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQyLCAwKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkzLnJhbmdlKClbMF0gKyAnKScpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteC5udi1heGlzJykudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHgyQXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb2N1c1Nob3dBeGlzWSkge1xuICAgICAgICAgICAgICAgIHkzQXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeTMpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggYXZhaWxhYmxlSGVpZ2h0MiAvIDM2IClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuICAgICAgICAgICAgICAgIHk0QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeTQpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggYXZhaWxhYmxlSGVpZ2h0MiAvIDM2IClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKGRhdGFCYXJzLmxlbmd0aCA/IDAgOiAtYXZhaWxhYmxlV2lkdGgsIDApOyAvLyBTaG93IHRoZSB5MiBydWxlcyBvbmx5IGlmIHkxIGhhcyBub25lXG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LXkzLm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBkYXRhQmFycy5sZW5ndGggPyAxIDogMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeDIucmFuZ2UoKVswXSArICcpJyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250ZXh0IC5udi15Mi5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgZGF0YUxpbmVzLmxlbmd0aCA/IDEgOiAwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeDIucmFuZ2UoKVsxXSArICcsMCknKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteTEubnYtYXhpcycpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh5M0F4aXMpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteTIubnYtYXhpcycpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh5NEF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBCcnVzaFxuICAgICAgICAgICAgYnJ1c2gueCh4Mikub24oJ2JydXNoJywgb25CcnVzaCk7XG5cbiAgICAgICAgICAgIGlmIChicnVzaEV4dGVudCkgYnJ1c2guZXh0ZW50KGJydXNoRXh0ZW50KTtcblxuICAgICAgICAgICAgdmFyIGJydXNoQkcgPSBnLnNlbGVjdCgnLm52LWJydXNoQmFja2dyb3VuZCcpLnNlbGVjdEFsbCgnZycpXG4gICAgICAgICAgICAgICAgLmRhdGEoW2JydXNoRXh0ZW50IHx8IGJydXNoLmV4dGVudCgpXSk7XG5cbiAgICAgICAgICAgIHZhciBicnVzaEJHZW50ZXIgPSBicnVzaEJHLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJyk7XG5cbiAgICAgICAgICAgIGJydXNoQkdlbnRlci5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsZWZ0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQyKTtcblxuICAgICAgICAgICAgYnJ1c2hCR2VudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3JpZ2h0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQyKTtcblxuICAgICAgICAgICAgdmFyIGdCcnVzaCA9IGcuc2VsZWN0KCcubnYteC5udi1icnVzaCcpXG4gICAgICAgICAgICAgICAgLmNhbGwoYnJ1c2gpO1xuICAgICAgICAgICAgZ0JydXNoLnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLy8uYXR0cigneScsIC01KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQyKTtcbiAgICAgICAgICAgIGdCcnVzaC5zZWxlY3RBbGwoJy5yZXNpemUnKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdkJywgcmVzaXplUGF0aCk7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNoYXJ0IGZyb20gYSBzdGF0ZSBvYmplY3QgcGFzc2VkIHRvIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCdjaGFuZ2VTdGF0ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEZ1bmN0aW9uc1xuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgLy8gVGFrZW4gZnJvbSBjcm9zc2ZpbHRlciAoaHR0cDovL3NxdWFyZS5naXRodWIuY29tL2Nyb3NzZmlsdGVyLylcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc2l6ZVBhdGgoZCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gKyhkID09ICdlJyksXG4gICAgICAgICAgICAgICAgICAgIHggPSBlID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICB5ID0gYXZhaWxhYmxlSGVpZ2h0MiAvIDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNJyArICguNSAqIHgpICsgJywnICsgeVxuICAgICAgICAgICAgICAgICAgICArICdBNiw2IDAgMCAnICsgZSArICcgJyArICg2LjUgKiB4KSArICcsJyArICh5ICsgNilcbiAgICAgICAgICAgICAgICAgICAgKyAnVicgKyAoMiAqIHkgLSA2KVxuICAgICAgICAgICAgICAgICAgICArICdBNiw2IDAgMCAnICsgZSArICcgJyArICguNSAqIHgpICsgJywnICsgKDIgKiB5KVxuICAgICAgICAgICAgICAgICAgICArICdaJ1xuICAgICAgICAgICAgICAgICAgICArICdNJyArICgyLjUgKiB4KSArICcsJyArICh5ICsgOClcbiAgICAgICAgICAgICAgICAgICAgKyAnVicgKyAoMiAqIHkgLSA4KVxuICAgICAgICAgICAgICAgICAgICArICdNJyArICg0LjUgKiB4KSArICcsJyArICh5ICsgOClcbiAgICAgICAgICAgICAgICAgICAgKyAnVicgKyAoMiAqIHkgLSA4KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVCcnVzaEJHKCkge1xuICAgICAgICAgICAgICAgIGlmICghYnJ1c2guZW1wdHkoKSkgYnJ1c2guZXh0ZW50KGJydXNoRXh0ZW50KTtcbiAgICAgICAgICAgICAgICBicnVzaEJHXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKFticnVzaC5lbXB0eSgpID8geDIuZG9tYWluKCkgOiBicnVzaEV4dGVudF0pXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRXaWR0aCA9IHgyKGRbMF0pIC0geDIucmFuZ2UoKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFdpZHRoID0geDIucmFuZ2UoKVsxXSAtIHgyKGRbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgnLmxlZnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsICBsZWZ0V2lkdGggPCAwID8gMCA6IGxlZnRXaWR0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJy5yaWdodCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4MihkWzFdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCByaWdodFdpZHRoIDwgMCA/IDAgOiByaWdodFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uQnJ1c2goKSB7XG4gICAgICAgICAgICAgICAgYnJ1c2hFeHRlbnQgPSBicnVzaC5lbXB0eSgpID8gbnVsbCA6IGJydXNoLmV4dGVudCgpO1xuICAgICAgICAgICAgICAgIGV4dGVudCA9IGJydXNoLmVtcHR5KCkgPyB4Mi5kb21haW4oKSA6IGJydXNoLmV4dGVudCgpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmJydXNoKHtleHRlbnQ6IGV4dGVudCwgYnJ1c2g6IGJydXNofSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQnJ1c2hCRygpO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJlcGFyZSBNYWluIChGb2N1cykgQmFycyBhbmQgTGluZXNcbiAgICAgICAgICAgICAgICBiYXJzXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQxKVxuICAgICAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS5iYXIgfSkpO1xuXG4gICAgICAgICAgICAgICAgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodDEpXG4gICAgICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiAhZGF0YVtpXS5iYXIgfSkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzQmFyc1dyYXAgPSBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi1iYXJzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bSghZGF0YUJhcnMubGVuZ3RoID8gW3t2YWx1ZXM6W119XSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQmFyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGQua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkLnZhbHVlcy5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhcnMueCgpKGQsaSkgPj0gZXh0ZW50WzBdICYmIGJhcnMueCgpKGQsaSkgPD0gZXh0ZW50WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHZhciBmb2N1c0xpbmVzV3JhcCA9IGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LWxpbmVzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhTGluZXNbMF0uZGlzYWJsZWQgPyBbe3ZhbHVlczpbXX1dIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFMaW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGQua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkLnZhbHVlcy5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzLngoKShkLGkpID49IGV4dGVudFswXSAmJiBsaW5lcy54KCkoZCxpKSA8PSBleHRlbnRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIE1haW4gKEZvY3VzKSBYIEF4aXNcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUJhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBiYXJzLnhTY2FsZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBsaW5lcy54U2NhbGUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB4QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoLzEwMCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodDEsIDApO1xuXG4gICAgICAgICAgICAgICAgeEF4aXMuZG9tYWluKFtNYXRoLmNlaWwoZXh0ZW50WzBdKSwgTWF0aC5mbG9vcihleHRlbnRbMV0pXSk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBNYWluIChGb2N1cykgQmFycyBhbmQgTGluZXNcbiAgICAgICAgICAgICAgICBmb2N1c0JhcnNXcmFwLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pLmNhbGwoYmFycyk7XG4gICAgICAgICAgICAgICAgZm9jdXNMaW5lc1dyYXAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikuY2FsbChsaW5lcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXR1cCBhbmQgVXBkYXRlIE1haW4gKEZvY3VzKSBZIEF4ZXNcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB5MS5yYW5nZSgpWzBdICsgJyknKTtcblxuICAgICAgICAgICAgICAgIHkxQXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeTEpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQxLzM2LCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlV2lkdGgsIDApO1xuICAgICAgICAgICAgICAgIHkyQXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeTIpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQxLzM2LCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZShkYXRhQmFycy5sZW5ndGggPyAwIDogLWF2YWlsYWJsZVdpZHRoLCAwKTsgLy8gU2hvdyB0aGUgeTIgcnVsZXMgb25seSBpZiB5MSBoYXMgbm9uZVxuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1mb2N1cyAubnYteTEubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGRhdGFCYXJzLmxlbmd0aCA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi15Mi5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgZGF0YUxpbmVzLmxlbmd0aCAmJiAhZGF0YUxpbmVzWzBdLmRpc2FibGVkID8gMSA6IDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4LnJhbmdlKClbMV0gKyAnLDApJyk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi15MS5udi1heGlzJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeTFBeGlzKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi15Mi5udi1heGlzJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeTJBeGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb25CcnVzaCgpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGluZXMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgbGluZXMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgICB9KTtcblxuICAgIGJhcnMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgYmFycy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQubGluZXMgPSBsaW5lcztcbiAgICBjaGFydC5saW5lczIgPSBsaW5lczI7XG4gICAgY2hhcnQuYmFycyA9IGJhcnM7XG4gICAgY2hhcnQuYmFyczIgPSBiYXJzMjtcbiAgICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICAgIGNoYXJ0LngyQXhpcyA9IHgyQXhpcztcbiAgICBjaGFydC55MUF4aXMgPSB5MUF4aXM7XG4gICAgY2hhcnQueTJBeGlzID0geTJBeGlzO1xuICAgIGNoYXJ0LnkzQXhpcyA9IHkzQXhpcztcbiAgICBjaGFydC55NEF4aXMgPSB5NEF4aXM7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzaG93TGVnZW5kOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGVnZW5kO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xlZ2VuZD1fO319LFxuICAgICAgICB0b29sdGlwczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcHM7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwcz1fO319LFxuICAgICAgICB0b29sdGlwQ29udGVudDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXA9Xzt9fSxcbiAgICAgICAgYnJ1c2hFeHRlbnQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGJydXNoRXh0ZW50O30sIHNldDogZnVuY3Rpb24oXyl7YnJ1c2hFeHRlbnQ9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcbiAgICAgICAgZm9jdXNFbmFibGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvY3VzRW5hYmxlO30sIHNldDogZnVuY3Rpb24oXyl7Zm9jdXNFbmFibGU9Xzt9fSxcbiAgICAgICAgZm9jdXNIZWlnaHQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvY3VzSGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7Zm9jdXNIZWlnaHQ9Xzt9fSxcbiAgICAgICAgZm9jdXNTaG93QXhpc1g6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvY3VzU2hvd0F4aXNYO30sIHNldDogZnVuY3Rpb24oXyl7Zm9jdXNTaG93QXhpc1g9Xzt9fSxcbiAgICAgICAgZm9jdXNTaG93QXhpc1k6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvY3VzU2hvd0F4aXNZO30sIHNldDogZnVuY3Rpb24oXyl7Zm9jdXNTaG93QXhpc1k9Xzt9fSxcbiAgICAgICAgbGVnZW5kTGVmdEF4aXNIaW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsZWdlbmRMZWZ0QXhpc0hpbnQ7fSwgc2V0OiBmdW5jdGlvbihfKXtsZWdlbmRMZWZ0QXhpc0hpbnQ9Xzt9fSxcbiAgICAgICAgbGVnZW5kUmlnaHRBeGlzSGludDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGVnZW5kUmlnaHRBeGlzSGludDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2xlZ2VuZFJpZ2h0QXhpc0hpbnQ9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0cmFuc2l0aW9uRHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF87XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHg6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFg7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGdldFggPSBfO1xuICAgICAgICAgICAgbGluZXMueChfKTtcbiAgICAgICAgICAgIGxpbmVzMi54KF8pO1xuICAgICAgICAgICAgYmFycy54KF8pO1xuICAgICAgICAgICAgYmFyczIueChfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGdldFkgPSBfO1xuICAgICAgICAgICAgbGluZXMueShfKTtcbiAgICAgICAgICAgIGxpbmVzMi55KF8pO1xuICAgICAgICAgICAgYmFycy55KF8pO1xuICAgICAgICAgICAgYmFyczIueShfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBsaW5lcyk7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcbm52Lm1vZGVscy5saW5lV2l0aEZvY3VzQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIGxpbmVzID0gbnYubW9kZWxzLmxpbmUoKVxuICAgICAgICAsIGxpbmVzMiA9IG52Lm1vZGVscy5saW5lKClcbiAgICAgICAgLCB4QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB4MkF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeTJBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICAgICAsIGJydXNoID0gZDMuc3ZnLmJydXNoKClcbiAgICAgICAgO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMzAsIGJvdHRvbTogMzAsIGxlZnQ6IDYwfVxuICAgICAgICAsIG1hcmdpbjIgPSB7dG9wOiAwLCByaWdodDogMzAsIGJvdHRvbTogMjAsIGxlZnQ6IDYwfVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgaGVpZ2h0MiA9IDEwMFxuICAgICAgICAsIHhcbiAgICAgICAgLCB5XG4gICAgICAgICwgeDJcbiAgICAgICAgLCB5MlxuICAgICAgICAsIHNob3dMZWdlbmQgPSB0cnVlXG4gICAgICAgICwgYnJ1c2hFeHRlbnQgPSBudWxsXG4gICAgICAgICwgdG9vbHRpcHMgPSB0cnVlXG4gICAgICAgICwgdG9vbHRpcCA9IGZ1bmN0aW9uKGtleSwgeCwgeSwgZSwgZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnPGgzPicgKyBrZXkgKyAnPC9oMz4nICtcbiAgICAgICAgICAgICAgICAnPHA+JyArICB5ICsgJyBhdCAnICsgeCArICc8L3A+J1xuICAgICAgICB9XG4gICAgICAgICwgbm9EYXRhID0gXCJObyBEYXRhIEF2YWlsYWJsZS5cIlxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ2JydXNoJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJylcbiAgICAgICAgLCB0cmFuc2l0aW9uRHVyYXRpb24gPSAyNTBcbiAgICAgICAgLCBzdGF0ZSA9IG52LnV0aWxzLnN0YXRlKClcbiAgICAgICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgICAgIDtcblxuICAgIGxpbmVzXG4gICAgICAgIC5jbGlwRWRnZSh0cnVlKVxuICAgIDtcbiAgICBsaW5lczJcbiAgICAgICAgLmludGVyYWN0aXZlKGZhbHNlKVxuICAgIDtcbiAgICB4QXhpc1xuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAudGlja1BhZGRpbmcoNSlcbiAgICA7XG4gICAgeUF4aXNcbiAgICAgICAgLm9yaWVudCgnbGVmdCcpXG4gICAgO1xuICAgIHgyQXhpc1xuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAudGlja1BhZGRpbmcoNSlcbiAgICA7XG4gICAgeTJBeGlzXG4gICAgICAgIC5vcmllbnQoJ2xlZnQnKVxuICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuICAgICAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQgfHwgMCApLFxuICAgICAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICAgICAgeCA9IHhBeGlzLnRpY2tGb3JtYXQoKShsaW5lcy54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICB5ID0geUF4aXMudGlja0Zvcm1hdCgpKGxpbmVzLnkoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0b29sdGlwKGUuc2VyaWVzLmtleSwgeCwgeSwgZSwgY2hhcnQpO1xuXG4gICAgICAgIG52LnRvb2x0aXAuc2hvdyhbbGVmdCwgdG9wXSwgY29udGVudCwgbnVsbCwgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZUdldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZTogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlU2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hY3RpdmUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gIXN0YXRlLmFjdGl2ZVtpXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0MSA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tIC0gaGVpZ2h0MixcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQyID0gaGVpZ2h0MiAtIG1hcmdpbjIudG9wIC0gbWFyZ2luMi5ib3R0b207XG5cbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikuY2FsbChjaGFydCkgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICAgLnNldHRlcihzdGF0ZVNldHRlcihkYXRhKSwgY2hhcnQudXBkYXRlKVxuICAgICAgICAgICAgICAgIC5nZXR0ZXIoc3RhdGVHZXR0ZXIoZGF0YSkpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBERVBSRUNBVEVEIHNldCBzdGF0ZS5kaXNhYmxlZGRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodDEgLyAyKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeCA9IGxpbmVzLnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IGxpbmVzLnlTY2FsZSgpO1xuICAgICAgICAgICAgeDIgPSBsaW5lczIueFNjYWxlKCk7XG4gICAgICAgICAgICB5MiA9IGxpbmVzMi55U2NhbGUoKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWxpbmVXaXRoRm9jdXNDaGFydCcpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LWxpbmVXaXRoRm9jdXNDaGFydCcpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuXG4gICAgICAgICAgICB2YXIgZm9jdXNFbnRlciA9IGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1mb2N1cycpO1xuICAgICAgICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGZvY3VzRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJyk7XG4gICAgICAgICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxpbmVzV3JhcCcpO1xuXG4gICAgICAgICAgICB2YXIgY29udGV4dEVudGVyID0gZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWNvbnRleHQnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1saW5lc1dyYXAnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1icnVzaEJhY2tncm91bmQnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWJydXNoJyk7XG5cbiAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgaWYgKHNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBsZWdlbmQud2lkdGgoYXZhaWxhYmxlV2lkdGgpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodDEgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20gLSBoZWlnaHQyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxuICAgICAgICAgICAgbGluZXNcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQxKVxuICAgICAgICAgICAgICAgIC5jb2xvcihcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxpbmVzMlxuICAgICAgICAgICAgICAgIC5kZWZpbmVkKGxpbmVzLmRlZmluZWQoKSlcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQyKVxuICAgICAgICAgICAgICAgIC5jb2xvcihcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKCBhdmFpbGFibGVIZWlnaHQxICsgbWFyZ2luLmJvdHRvbSArIG1hcmdpbjIudG9wKSArICcpJylcblxuICAgICAgICAgICAgdmFyIGNvbnRleHRMaW5lc1dyYXAgPSBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LWxpbmVzV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuXG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKGNvbnRleHRMaW5lc1dyYXApLmNhbGwobGluZXMyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgTWFpbiAoRm9jdXMpIEF4ZXNcbiAgICAgICAgICAgIHhBeGlzXG4gICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoLzEwMCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0MSwgMCk7XG5cbiAgICAgICAgICAgIHlBeGlzXG4gICAgICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodDEvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgYXZhaWxhYmxlSGVpZ2h0MSArICcpJyk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIEJydXNoXG4gICAgICAgICAgICBicnVzaFxuICAgICAgICAgICAgICAgIC54KHgyKVxuICAgICAgICAgICAgICAgIC5vbignYnJ1c2gnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9XaGVuIGJydXNoaW5nLCB0dXJuIG9mZiB0cmFuc2l0aW9ucyBiZWNhdXNlIGNoYXJ0IG5lZWRzIHRvIGNoYW5nZSBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFRyYW5zaXRpb24gPSBjaGFydC5kdXJhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBjaGFydC5kdXJhdGlvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgb25CcnVzaCgpO1xuICAgICAgICAgICAgICAgICAgICBjaGFydC5kdXJhdGlvbihvbGRUcmFuc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGJydXNoRXh0ZW50KSBicnVzaC5leHRlbnQoYnJ1c2hFeHRlbnQpO1xuXG4gICAgICAgICAgICB2YXIgYnJ1c2hCRyA9IGcuc2VsZWN0KCcubnYtYnJ1c2hCYWNrZ3JvdW5kJykuc2VsZWN0QWxsKCdnJylcbiAgICAgICAgICAgICAgICAuZGF0YShbYnJ1c2hFeHRlbnQgfHwgYnJ1c2guZXh0ZW50KCldKVxuXG4gICAgICAgICAgICB2YXIgYnJ1c2hCR2VudGVyID0gYnJ1c2hCRy5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpO1xuXG4gICAgICAgICAgICBicnVzaEJHZW50ZXIuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGVmdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgMClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0Mik7XG5cbiAgICAgICAgICAgIGJydXNoQkdlbnRlci5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdyaWdodCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgMClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0Mik7XG5cbiAgICAgICAgICAgIHZhciBnQnJ1c2ggPSBnLnNlbGVjdCgnLm52LXgubnYtYnJ1c2gnKVxuICAgICAgICAgICAgICAgIC5jYWxsKGJydXNoKTtcbiAgICAgICAgICAgIGdCcnVzaC5zZWxlY3RBbGwoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC8vLmF0dHIoJ3knLCAtNSlcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0Mik7XG4gICAgICAgICAgICBnQnJ1c2guc2VsZWN0QWxsKCcucmVzaXplJykuYXBwZW5kKCdwYXRoJykuYXR0cignZCcsIHJlc2l6ZVBhdGgpO1xuXG4gICAgICAgICAgICBvbkJydXNoKCk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNlY29uZGFyeSAoQ29udGV4dCkgQXhlc1xuICAgICAgICAgICAgeDJBeGlzXG4gICAgICAgICAgICAgICAgLnNjYWxlKHgyKVxuICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWChhdmFpbGFibGVXaWR0aC8xMDAsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodDIsIDApO1xuXG4gICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeTIucmFuZ2UoKVswXSArICcpJyk7XG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteC5udi1heGlzJykpXG4gICAgICAgICAgICAgICAgLmNhbGwoeDJBeGlzKTtcblxuICAgICAgICAgICAgeTJBeGlzXG4gICAgICAgICAgICAgICAgLnNjYWxlKHkyKVxuICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQyLzM2LCBkYXRhKSApXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteS5udi1heGlzJykpXG4gICAgICAgICAgICAgICAgLmNhbGwoeTJBeGlzKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250ZXh0IC5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkyLnJhbmdlKClbMF0gKyAnKScpO1xuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCdjaGFuZ2VTdGF0ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBGdW5jdGlvbnNcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8vIFRha2VuIGZyb20gY3Jvc3NmaWx0ZXIgKGh0dHA6Ly9zcXVhcmUuZ2l0aHViLmNvbS9jcm9zc2ZpbHRlci8pXG4gICAgICAgICAgICBmdW5jdGlvbiByZXNpemVQYXRoKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9ICsoZCA9PSAnZScpLFxuICAgICAgICAgICAgICAgICAgICB4ID0gZSA/IDEgOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgeSA9IGF2YWlsYWJsZUhlaWdodDIgLyAzO1xuICAgICAgICAgICAgICAgIHJldHVybiAnTScgKyAoLjUgKiB4KSArICcsJyArIHlcbiAgICAgICAgICAgICAgICAgICAgKyAnQTYsNiAwIDAgJyArIGUgKyAnICcgKyAoNi41ICogeCkgKyAnLCcgKyAoeSArIDYpXG4gICAgICAgICAgICAgICAgICAgICsgJ1YnICsgKDIgKiB5IC0gNilcbiAgICAgICAgICAgICAgICAgICAgKyAnQTYsNiAwIDAgJyArIGUgKyAnICcgKyAoLjUgKiB4KSArICcsJyArICgyICogeSlcbiAgICAgICAgICAgICAgICAgICAgKyAnWidcbiAgICAgICAgICAgICAgICAgICAgKyAnTScgKyAoMi41ICogeCkgKyAnLCcgKyAoeSArIDgpXG4gICAgICAgICAgICAgICAgICAgICsgJ1YnICsgKDIgKiB5IC0gOClcbiAgICAgICAgICAgICAgICAgICAgKyAnTScgKyAoNC41ICogeCkgKyAnLCcgKyAoeSArIDgpXG4gICAgICAgICAgICAgICAgICAgICsgJ1YnICsgKDIgKiB5IC0gOCk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlQnJ1c2hCRygpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJydXNoLmVtcHR5KCkpIGJydXNoLmV4dGVudChicnVzaEV4dGVudCk7XG4gICAgICAgICAgICAgICAgYnJ1c2hCR1xuICAgICAgICAgICAgICAgICAgICAuZGF0YShbYnJ1c2guZW1wdHkoKSA/IHgyLmRvbWFpbigpIDogYnJ1c2hFeHRlbnRdKVxuICAgICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0V2lkdGggPSB4MihkWzBdKSAtIHgucmFuZ2UoKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFdpZHRoID0geC5yYW5nZSgpWzFdIC0geDIoZFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCcubGVmdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgIGxlZnRXaWR0aCA8IDAgPyAwIDogbGVmdFdpZHRoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgnLnJpZ2h0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHgyKGRbMV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHJpZ2h0V2lkdGggPCAwID8gMCA6IHJpZ2h0V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbkJydXNoKCkge1xuICAgICAgICAgICAgICAgIGJydXNoRXh0ZW50ID0gYnJ1c2guZW1wdHkoKSA/IG51bGwgOiBicnVzaC5leHRlbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW50ID0gYnJ1c2guZW1wdHkoKSA/IHgyLmRvbWFpbigpIDogYnJ1c2guZXh0ZW50KCk7XG5cbiAgICAgICAgICAgICAgICAvL1RoZSBicnVzaCBleHRlbnQgY2Fubm90IGJlIGxlc3MgdGhhbiBvbmUuICBJZiBpdCBpcywgZG9uJ3QgdXBkYXRlIHRoZSBsaW5lIGNoYXJ0LlxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhleHRlbnRbMF0gLSBleHRlbnRbMV0pIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmJydXNoKHtleHRlbnQ6IGV4dGVudCwgYnJ1c2g6IGJydXNofSk7XG5cblxuICAgICAgICAgICAgICAgIHVwZGF0ZUJydXNoQkcoKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBNYWluIChGb2N1cylcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXNMaW5lc1dyYXAgPSBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi1saW5lc1dyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oXG4gICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBkLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYTogZC5hcmVhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGQudmFsdWVzLmZpbHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lcy54KCkoZCxpKSA+PSBleHRlbnRbMF0gJiYgbGluZXMueCgpKGQsaSkgPD0gZXh0ZW50WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmb2N1c0xpbmVzV3JhcC50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGxpbmVzKTtcblxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIE1haW4gKEZvY3VzKSBBeGVzXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1mb2N1cyAubnYteC5udi1heGlzJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LXkubnYtYXhpcycpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQubGluZXMgPSBsaW5lcztcbiAgICBjaGFydC5saW5lczIgPSBsaW5lczI7XG4gICAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgICBjaGFydC55QXhpcyA9IHlBeGlzO1xuICAgIGNoYXJ0LngyQXhpcyA9IHgyQXhpcztcbiAgICBjaGFydC55MkF4aXMgPSB5MkF4aXM7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBmb2N1c0hlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDI7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQyPV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIGJydXNoRXh0ZW50OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBicnVzaEV4dGVudDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2JydXNoRXh0ZW50PV87fX0sXG4gICAgICAgIHRvb2x0aXBzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBzPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRlZmF1bHRTdGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RlZmF1bHRTdGF0ZT1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XG4gICAgICAgICAgICAvLyBsaW5lIGNvbG9yIGlzIGhhbmRsZWQgYWJvdmU/XG4gICAgICAgIH19LFxuICAgICAgICBpbnRlcnBvbGF0ZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGluZXMuaW50ZXJwb2xhdGUoKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbGluZXMuaW50ZXJwb2xhdGUoXyk7XG4gICAgICAgICAgICBsaW5lczIuaW50ZXJwb2xhdGUoXyk7XG4gICAgICAgIH19LFxuICAgICAgICB4VGlja0Zvcm1hdDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geEF4aXMueFRpY2tGb3JtYXQoKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgeEF4aXMueFRpY2tGb3JtYXQoXyk7XG4gICAgICAgICAgICB4MkF4aXMueFRpY2tGb3JtYXQoXyk7XG4gICAgICAgIH19LFxuICAgICAgICB5VGlja0Zvcm1hdDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geUF4aXMueVRpY2tGb3JtYXQoKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgeUF4aXMueVRpY2tGb3JtYXQoXyk7XG4gICAgICAgICAgICB5MkF4aXMueVRpY2tGb3JtYXQoXyk7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb249XztcbiAgICAgICAgICAgIHlBeGlzLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgICB4QXhpcy5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgeDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGluZXMueCgpO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBsaW5lcy54KF8pO1xuICAgICAgICAgICAgbGluZXMyLngoXyk7XG4gICAgICAgIH19LFxuICAgICAgICB5OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsaW5lcy55KCk7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGxpbmVzLnkoXyk7XG4gICAgICAgICAgICBsaW5lczIueShfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBsaW5lcyk7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLm11bHRpQmFyID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gOTYwXG4gICAgICAgICwgaGVpZ2h0ID0gNTAwXG4gICAgICAgICwgeCA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgICAgICAsIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApIC8vQ3JlYXRlIHNlbWktdW5pcXVlIElEIGluIGNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcbiAgICAgICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH1cbiAgICAgICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAgICAgLCBmb3JjZVkgPSBbMF0gLy8gMCBpcyBmb3JjZWQgYnkgZGVmYXVsdC4uIHRoaXMgbWFrZXMgc2Vuc2UgZm9yIHRoZSBtYWpvcml0eSBvZiBiYXIgZ3JhcGhzLi4uIHVzZXIgY2FuIGFsd2F5cyBkbyBjaGFydC5mb3JjZVkoW10pIHRvIHJlbW92ZVxuICAgICAgICAsIGNsaXBFZGdlID0gdHJ1ZVxuICAgICAgICAsIHN0YWNrZWQgPSBmYWxzZVxuICAgICAgICAsIHN0YWNrT2Zmc2V0ID0gJ3plcm8nIC8vIG9wdGlvbnMgaW5jbHVkZSAnc2lsaG91ZXR0ZScsICd3aWdnbGUnLCAnZXhwYW5kJywgJ3plcm8nLCBvciBhIGN1c3RvbSBmdW5jdGlvblxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBoaWRlYWJsZSA9IGZhbHNlXG4gICAgICAgICwgYmFyQ29sb3IgPSBudWxsIC8vIGFkZGluZyB0aGUgYWJpbGl0eSB0byBzZXQgdGhlIGNvbG9yIGZvciBlYWNoIHJhdGhlciB0aGFuIHRoZSB3aG9sZSBncm91cFxuICAgICAgICAsIGRpc2FibGVkIC8vIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBiYXJDb2xvciB0byBjb21tdW5pY2F0ZSBmcm9tIG11bHRpQmFySG9yaXpvbnRhbENoYXJ0IHdoYXQgc2VyaWVzIGFyZSBkaXNhYmxlZFxuICAgICAgICAsIGR1cmF0aW9uID0gNTAwXG4gICAgICAgICwgeERvbWFpblxuICAgICAgICAsIHlEb21haW5cbiAgICAgICAgLCB4UmFuZ2VcbiAgICAgICAgLCB5UmFuZ2VcbiAgICAgICAgLCBncm91cFNwYWNpbmcgPSAwLjFcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdjaGFydENsaWNrJywgJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsQ2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnLCAncmVuZGVyRW5kJylcbiAgICAgICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgeDAsIHkwIC8vdXNlZCB0byBzdG9yZSBwcmV2aW91cyBzY2FsZXNcbiAgICAgICAgLCByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCBkdXJhdGlvbilcbiAgICAgICAgO1xuXG4gICAgdmFyIGxhc3RfZGF0YWxlbmd0aCA9IDA7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gZGVmaW5lcyB0aGUgcmVxdWlyZW1lbnRzIGZvciByZW5kZXIgY29tcGxldGVcbiAgICAgICAgICAgIHZhciBlbmRGbiA9IGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZC5zZXJpZXMgPT09IGRhdGEubGVuZ3RoIC0gMSAmJiBpID09PSBkYXRhWzBdLnZhbHVlcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZihoaWRlYWJsZSAmJiBkYXRhLmxlbmd0aCkgaGlkZWFibGUgPSBbe1xuICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YVswXS52YWx1ZXMubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogZC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiAwLjAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9O31cbiAgICAgICAgICAgICAgICApfV07XG5cbiAgICAgICAgICAgIGlmIChzdGFja2VkKVxuICAgICAgICAgICAgICAgIGRhdGEgPSBkMy5sYXlvdXQuc3RhY2soKVxuICAgICAgICAgICAgICAgICAgICAub2Zmc2V0KHN0YWNrT2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAudmFsdWVzKGZ1bmN0aW9uKGQpeyByZXR1cm4gZC52YWx1ZXMgfSlcbiAgICAgICAgICAgICAgICAgICAgLnkoZ2V0WSlcbiAgICAgICAgICAgICAgICAoIWRhdGEubGVuZ3RoICYmIGhpZGVhYmxlID8gaGlkZWFibGUgOiBkYXRhKTtcblxuXG4gICAgICAgICAgICAvL2FkZCBzZXJpZXMgaW5kZXggdG8gZWFjaCBkYXRhIHBvaW50IGZvciByZWZlcmVuY2VcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQuc2VyaWVzID0gaTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBIQUNLIGZvciBuZWdhdGl2ZSB2YWx1ZSBzdGFja2luZ1xuICAgICAgICAgICAgaWYgKHN0YWNrZWQpXG4gICAgICAgICAgICAgICAgZGF0YVswXS52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zQmFzZSA9IDAsIG5lZ0Jhc2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGQudmFsdWVzW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICBmLnNpemUgPSBNYXRoLmFicyhmLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYueTwwKSAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYueTEgPSBuZWdCYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZ0Jhc2UgPSBuZWdCYXNlIC0gZi5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZi55MSA9IGYuc2l6ZSArIHBvc0Jhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zQmFzZSA9IHBvc0Jhc2UgKyBmLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIC8vIHJlbWFwIGFuZCBmbGF0dGVuIHRoZSBkYXRhIGZvciB1c2UgaW4gY2FsY3VsYXRpbmcgdGhlIHNjYWxlcycgZG9tYWluc1xuICAgICAgICAgICAgdmFyIHNlcmllc0RhdGEgPSAoeERvbWFpbiAmJiB5RG9tYWluKSA/IFtdIDogLy8gaWYgd2Uga25vdyB4RG9tYWluIGFuZCB5RG9tYWluLCBubyBuZWVkIHRvIGNhbGN1bGF0ZVxuICAgICAgICAgICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQudmFsdWVzLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IGdldFgoZCxpKSwgeTogZ2V0WShkLGkpLCB5MDogZC55MCwgeTE6IGQueTEgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB4LmRvbWFpbih4RG9tYWluIHx8IGQzLm1lcmdlKHNlcmllc0RhdGEpLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfSkpXG4gICAgICAgICAgICAgICAgLnJhbmdlQmFuZHMoeFJhbmdlIHx8IFswLCBhdmFpbGFibGVXaWR0aF0sIGdyb3VwU3BhY2luZyk7XG5cbiAgICAgICAgICAgIHkuZG9tYWluKHlEb21haW4gfHwgZDMuZXh0ZW50KGQzLm1lcmdlKHNlcmllc0RhdGEpLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBzdGFja2VkID8gKGQueSA+IDAgPyBkLnkxIDogZC55MSArIGQueSApIDogZC55IH0pLmNvbmNhdChmb3JjZVkpKSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoeVJhbmdlIHx8IFthdmFpbGFibGVIZWlnaHQsIDBdKTtcblxuICAgICAgICAgICAgLy8gSWYgc2NhbGUncyBkb21haW4gZG9uJ3QgaGF2ZSBhIHJhbmdlLCBzbGlnaHRseSBhZGp1c3QgdG8gbWFrZSBvbmUuLi4gc28gYSBjaGFydCBjYW4gc2hvdyBhIHNpbmdsZSBkYXRhIHBvaW50XG4gICAgICAgICAgICBpZiAoeC5kb21haW4oKVswXSA9PT0geC5kb21haW4oKVsxXSlcbiAgICAgICAgICAgICAgICB4LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgICAgICAgICAgeC5kb21haW4oW3guZG9tYWluKClbMF0gLSB4LmRvbWFpbigpWzBdICogMC4wMSwgeC5kb21haW4oKVsxXSArIHguZG9tYWluKClbMV0gKiAwLjAxXSlcbiAgICAgICAgICAgICAgICAgICAgOiB4LmRvbWFpbihbLTEsMV0pO1xuXG4gICAgICAgICAgICBpZiAoeS5kb21haW4oKVswXSA9PT0geS5kb21haW4oKVsxXSlcbiAgICAgICAgICAgICAgICB5LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgICAgICAgICAgeS5kb21haW4oW3kuZG9tYWluKClbMF0gKyB5LmRvbWFpbigpWzBdICogMC4wMSwgeS5kb21haW4oKVsxXSAtIHkuZG9tYWluKClbMV0gKiAwLjAxXSlcbiAgICAgICAgICAgICAgICAgICAgOiB5LmRvbWFpbihbLTEsMV0pO1xuXG4gICAgICAgICAgICB4MCA9IHgwIHx8IHg7XG4gICAgICAgICAgICB5MCA9IHkwIHx8IHk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1tdWx0aWJhcicpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LW11bHRpYmFyJyk7XG4gICAgICAgICAgICB2YXIgZGVmc0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZGVmcycpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKVxuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZ3JvdXBzJyk7XG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIGRlZnNFbnRlci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnbnYtZWRnZS1jbGlwLScgKyBpZClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0Jyk7XG4gICAgICAgICAgICB3cmFwLnNlbGVjdCgnI252LWVkZ2UtY2xpcC0nICsgaWQgKyAnIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICBnLmF0dHIoJ2NsaXAtcGF0aCcsIGNsaXBFZGdlID8gJ3VybCgjbnYtZWRnZS1jbGlwLScgKyBpZCArICcpJyA6ICcnKTtcblxuICAgICAgICAgICAgdmFyIGdyb3VwcyA9IHdyYXAuc2VsZWN0KCcubnYtZ3JvdXBzJykuc2VsZWN0QWxsKCcubnYtZ3JvdXAnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSwgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBpIH0pO1xuICAgICAgICAgICAgZ3JvdXBzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMWUtNilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDFlLTYpO1xuXG4gICAgICAgICAgICB2YXIgZXhpdFRyYW5zaXRpb24gPSByZW5kZXJXYXRjaFxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKGdyb3Vwcy5leGl0KCkuc2VsZWN0QWxsKCdyZWN0Lm52LWJhcicpLCAnbXVsdGliYXJFeGl0JywgTWF0aC5taW4oMTAwLCBkdXJhdGlvbikpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkKSB7IHJldHVybiAoc3RhY2tlZCA/IHkwKGQueTApIDogeTAoMCkpIHx8IDAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMClcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICBpZiAoZXhpdFRyYW5zaXRpb24uZGVsYXkpXG4gICAgICAgICAgICAgICAgZXhpdFRyYW5zaXRpb24uZGVsYXkoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWxheSA9IGkgKiAoZHVyYXRpb24gLyAobGFzdF9kYXRhbGVuZ3RoICsgMSkpIC0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGF5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBzXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAnbnYtZ3JvdXAgbnYtc2VyaWVzLScgKyBpIH0pXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hvdmVyJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5ob3ZlciB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSl7IHJldHVybiBjb2xvcihkLCBpKSB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKXsgcmV0dXJuIGNvbG9yKGQsIGkpIH0pO1xuICAgICAgICAgICAgZ3JvdXBzXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAwLjc1KTtcblxuICAgICAgICAgICAgdmFyIGJhcnMgPSBncm91cHMuc2VsZWN0QWxsKCdyZWN0Lm52LWJhcicpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gKGhpZGVhYmxlICYmICFkYXRhLmxlbmd0aCkgPyBoaWRlYWJsZS52YWx1ZXMgOiBkLnZhbHVlcyB9KTtcbiAgICAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICB2YXIgYmFyc0VudGVyID0gYmFycy5lbnRlcigpLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WShkLGkpIDwgMCA/ICdudi1iYXIgbmVnYXRpdmUnIDogJ252LWJhciBwb3NpdGl2ZSd9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uKGQsaSxqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA/IDAgOiAoaiAqIHgucmFuZ2VCYW5kKCkgLyBkYXRhLmxlbmd0aCApXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24oZCkgeyByZXR1cm4geTAoc3RhY2tlZCA/IGQueTAgOiAwKSB8fCAwIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB4LnJhbmdlQmFuZCgpIC8gKHN0YWNrZWQgPyAxIDogZGF0YS5sZW5ndGgpIClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeChnZXRYKGQsaSkpICsgJywwKSc7IH0pXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgYmFyc1xuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSxqKXsgcmV0dXJuIGNvbG9yKGQsIGosIGkpOyAgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSxqKXsgcmV0dXJuIGNvbG9yKGQsIGosIGkpOyB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7IC8vVE9ETzogZmlndXJlIG91dCB3aHkgaiB3b3JrcyBhYm92ZSwgYnV0IG5vdCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQsaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgoZCxpKSkgKyAoeC5yYW5nZUJhbmQoKSAqIChzdGFja2VkID8gZGF0YS5sZW5ndGggLyAyIDogZC5zZXJpZXMgKyAuNSkgLyBkYXRhLmxlbmd0aCksIHkoZ2V0WShkLGkpICsgKHN0YWNrZWQgPyBkLnkwIDogMCkpXSwgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoZSB2YWx1ZSBhcHBlYXJzIHRvIGJlIHNoaWZ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQsaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgoZCxpKSkgKyAoeC5yYW5nZUJhbmQoKSAqIChzdGFja2VkID8gZGF0YS5sZW5ndGggLyAyIDogZC5zZXJpZXMgKyAuNSkgLyBkYXRhLmxlbmd0aCksIHkoZ2V0WShkLGkpICsgKHN0YWNrZWQgPyBkLnkwIDogMCkpXSwgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoZSB2YWx1ZSBhcHBlYXJzIHRvIGJlIHNoaWZ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnREYmxDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpICsgKHgucmFuZ2VCYW5kKCkgKiAoc3RhY2tlZCA/IGRhdGEubGVuZ3RoIC8gMiA6IGQuc2VyaWVzICsgLjUpIC8gZGF0YS5sZW5ndGgpLCB5KGdldFkoZCxpKSArIChzdGFja2VkID8gZC55MCA6IDApKV0sICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgdmFsdWUgYXBwZWFycyB0byBiZSBzaGlmdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmFyc1xuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WShkLGkpIDwgMCA/ICdudi1iYXIgbmVnYXRpdmUnIDogJ252LWJhciBwb3NpdGl2ZSd9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoZ2V0WChkLGkpKSArICcsMCknOyB9KVxuXG4gICAgICAgICAgICBpZiAoYmFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVkKSBkaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBiYXJzXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiBkMy5yZ2IoYmFyQ29sb3IoZCxpKSkuZGFya2VyKCAgZGlzYWJsZWQubWFwKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gaSB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKXsgcmV0dXJuICFkaXNhYmxlZFtpXSAgfSlbal0gICApLnRvU3RyaW5nKCk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuIGQzLnJnYihiYXJDb2xvcihkLGkpKS5kYXJrZXIoICBkaXNhYmxlZC5tYXAoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBpIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpeyByZXR1cm4gIWRpc2FibGVkW2ldICB9KVtqXSAgICkudG9TdHJpbmcoKTsgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBiYXJTZWxlY3Rpb24gPVxuICAgICAgICAgICAgICAgIGJhcnMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbXVsdGliYXInLCBNYXRoLm1pbigyNTAsIGR1cmF0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKiBkdXJhdGlvbiAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc3RhY2tlZClcbiAgICAgICAgICAgICAgICBiYXJTZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5KChzdGFja2VkID8gZC55MSA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKHkoZC55ICsgKHN0YWNrZWQgPyBkLnkwIDogMCkpIC0geSgoc3RhY2tlZCA/IGQueTAgOiAwKSkpLDEpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPyAwIDogKGQuc2VyaWVzICogeC5yYW5nZUJhbmQoKSAvIGRhdGEubGVuZ3RoIClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgeC5yYW5nZUJhbmQoKSAvIChzdGFja2VkID8gMSA6IGRhdGEubGVuZ3RoKSApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJhclNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuc2VyaWVzICogeC5yYW5nZUJhbmQoKSAvIGRhdGEubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHgucmFuZ2VCYW5kKCkgLyBkYXRhLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRZKGQsaSkgPCAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KDApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSAtIHkoZ2V0WShkLGkpKSA8IDEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoMCkgLSAxIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KGdldFkoZCxpKSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKHkoZ2V0WShkLGkpKSAtIHkoMCkpLDEpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgICAgICAgIHgwID0geC5jb3B5KCk7XG4gICAgICAgICAgICB5MCA9IHkuY29weSgpO1xuXG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBsYXN0IGRhdGEgdmFsdWUgbGVuZ3RoIGZvciB0cmFuc2l0aW9uIGNhbGN1bGF0aW9uc1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gJiYgZGF0YVswXS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBsYXN0X2RhdGFsZW5ndGggPSBkYXRhWzBdLnZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdtdWx0aWJhciBpbW1lZGlhdGUnKTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgeDogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFg9Xzt9fSxcbiAgICAgICAgeTogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFk9Xzt9fSxcbiAgICAgICAgeFNjYWxlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3g9Xzt9fSxcbiAgICAgICAgeVNjYWxlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3k9Xzt9fSxcbiAgICAgICAgeERvbWFpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geERvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hEb21haW49Xzt9fSxcbiAgICAgICAgeURvbWFpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geURvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lEb21haW49Xzt9fSxcbiAgICAgICAgeFJhbmdlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geFJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eFJhbmdlPV87fX0sXG4gICAgICAgIHlSYW5nZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lSYW5nZT1fO319LFxuICAgICAgICBmb3JjZVk6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVk7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVk9Xzt9fSxcbiAgICAgICAgc3RhY2tlZDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc3RhY2tlZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3N0YWNrZWQ9Xzt9fSxcbiAgICAgICAgc3RhY2tPZmZzZXQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHN0YWNrT2Zmc2V0O30sIHNldDogZnVuY3Rpb24oXyl7c3RhY2tPZmZzZXQ9Xzt9fSxcbiAgICAgICAgY2xpcEVkZ2U6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNsaXBFZGdlO30sIHNldDogZnVuY3Rpb24oXyl7Y2xpcEVkZ2U9Xzt9fSxcbiAgICAgICAgZGlzYWJsZWQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRpc2FibGVkO30sIHNldDogZnVuY3Rpb24oXyl7ZGlzYWJsZWQ9Xzt9fSxcbiAgICAgICAgaWQ6ICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGlkO30sIHNldDogZnVuY3Rpb24oXyl7aWQ9Xzt9fSxcbiAgICAgICAgaGlkZWFibGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhpZGVhYmxlO30sIHNldDogZnVuY3Rpb24oXyl7aGlkZWFibGU9Xzt9fSxcbiAgICAgICAgZ3JvdXBTcGFjaW5nOntnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdyb3VwU3BhY2luZzt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dyb3VwU3BhY2luZz1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgYmFyQ29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBiYXJDb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgYmFyQ29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5tdWx0aUJhckNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtdWx0aWJhciA9IG52Lm1vZGVscy5tdWx0aUJhcigpXG4gICAgICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeUF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgICAgICwgY29udHJvbHMgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMjAsIGJvdHRvbTogNTAsIGxlZnQ6IDYwfVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgc2hvd0NvbnRyb2xzID0gdHJ1ZVxuICAgICAgICAsIGNvbnRyb2xMYWJlbHMgPSB7fVxuICAgICAgICAsIHNob3dMZWdlbmQgPSB0cnVlXG4gICAgICAgICwgc2hvd1hBeGlzID0gdHJ1ZVxuICAgICAgICAsIHNob3dZQXhpcyA9IHRydWVcbiAgICAgICAgLCByaWdodEFsaWduWUF4aXMgPSBmYWxzZVxuICAgICAgICAsIHJlZHVjZVhUaWNrcyA9IHRydWUgLy8gaWYgZmFsc2UgYSB0aWNrIHdpbGwgc2hvdyBmb3IgZXZlcnkgZGF0YSBwb2ludFxuICAgICAgICAsIHN0YWdnZXJMYWJlbHMgPSBmYWxzZVxuICAgICAgICAsIHJvdGF0ZUxhYmVscyA9IDBcbiAgICAgICAgLCB0b29sdGlwcyA9IHRydWVcbiAgICAgICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuICc8aDM+JyArIGtleSArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgICc8cD4nICsgIHkgKyAnIG9uICcgKyB4ICsgJzwvcD4nXG4gICAgICAgIH1cbiAgICAgICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxuICAgICAgICAsIHkgLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnlTY2FsZSgpXG4gICAgICAgICwgc3RhdGUgPSBudi51dGlscy5zdGF0ZSgpXG4gICAgICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICAgICAsIG5vRGF0YSA9IFwiTm8gRGF0YSBBdmFpbGFibGUuXCJcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsICdyZW5kZXJFbmQnKVxuICAgICAgICAsIGNvbnRyb2xXaWR0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2hvd0NvbnRyb2xzID8gMTgwIDogMCB9XG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgO1xuXG4gICAgc3RhdGUuc3RhY2tlZCA9IGZhbHNlIC8vIERFUFJFQ0FURUQgTWFpbnRhaW5lZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG4gICAgbXVsdGliYXJcbiAgICAgICAgLnN0YWNrZWQoZmFsc2UpXG4gICAgO1xuICAgIHhBeGlzXG4gICAgICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgICAgIC50aWNrUGFkZGluZyg3KVxuICAgICAgICAuaGlnaGxpZ2h0WmVybyh0cnVlKVxuICAgICAgICAuc2hvd01heE1pbihmYWxzZSlcbiAgICAgICAgLnRpY2tGb3JtYXQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KVxuICAgIDtcbiAgICB5QXhpc1xuICAgICAgICAub3JpZW50KChyaWdodEFsaWduWUF4aXMpID8gJ3JpZ2h0JyA6ICdsZWZ0JylcbiAgICAgICAgLnRpY2tGb3JtYXQoZDMuZm9ybWF0KCcsLjFmJykpXG4gICAgO1xuXG4gICAgY29udHJvbHMudXBkYXRlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XG4gICAgdmFyIHN0YWNrZWQgPSBmYWxzZTtcblxuICAgIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgICAgIHggPSB4QXhpcy50aWNrRm9ybWF0KCkobXVsdGliYXIueCgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgeSA9IHlBeGlzLnRpY2tGb3JtYXQoKShtdWx0aWJhci55KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIGUudmFsdWUgPCAwID8gJ24nIDogJ3MnLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSxcbiAgICAgICAgICAgICAgICBzdGFja2VkOiBzdGFja2VkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZVNldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc3RhY2tlZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHN0YWNrZWQgPSBzdGF0ZS5zdGFja2VkO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSAhc3RhdGUuYWN0aXZlW2ldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMobXVsdGliYXIpO1xuICAgICAgICBpZiAoc2hvd1hBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeEF4aXMpO1xuICAgICAgICBpZiAoc2hvd1lBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeUF4aXMpO1xuXG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jYWxsKGNoYXJ0KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGNoYXJ0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICAgIC5zZXR0ZXIoc3RhdGVTZXR0ZXIoZGF0YSksIGNoYXJ0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAuZ2V0dGVyKHN0YXRlR2V0dGVyKGRhdGEpKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoKTtcblxuICAgICAgICAgICAgLy8gREVQUkVDQVRFRCBzZXQgc3RhdGUuZGlzYWJsZWRkaXNhYmxlZFxuICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG5cbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IG5vRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gbXVsdGliYXIueFNjYWxlKCk7XG4gICAgICAgICAgICB5ID0gbXVsdGliYXIueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1tdWx0aUJhcldpdGhMZWdlbmQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1tdWx0aUJhcldpdGhMZWdlbmQnKS5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkgbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWNvbnRyb2xzV3JhcCcpO1xuXG4gICAgICAgICAgICAvLyBMZWdlbmRcbiAgICAgICAgICAgIGlmIChzaG93TGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kLndpZHRoKGF2YWlsYWJsZVdpZHRoIC0gY29udHJvbFdpZHRoKCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpYmFyLmJhckNvbG9yKCkpXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmNvbG9yID0gZDMucmdiKCcjY2NjJykuZGFya2VyKGkgKiAxLjUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgY29udHJvbFdpZHRoKCkgKyAnLCcgKyAoLW1hcmdpbi50b3ApICsnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb250cm9sc1xuICAgICAgICAgICAgaWYgKHNob3dDb250cm9scykge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sc0RhdGEgPSBbXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiBjb250cm9sTGFiZWxzLmdyb3VwZWQgfHwgJ0dyb3VwZWQnLCBkaXNhYmxlZDogbXVsdGliYXIuc3RhY2tlZCgpIH0sXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiBjb250cm9sTGFiZWxzLnN0YWNrZWQgfHwgJ1N0YWNrZWQnLCBkaXNhYmxlZDogIW11bHRpYmFyLnN0YWNrZWQoKSB9XG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIGNvbnRyb2xzLndpZHRoKGNvbnRyb2xXaWR0aCgpKS5jb2xvcihbJyM0NDQnLCAnIzQ0NCcsICcjNDQ0J10pO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udHJvbHNXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGNvbnRyb2xzRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChjb250cm9scyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcbiAgICAgICAgICAgIGlmIChyaWdodEFsaWduWUF4aXMpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdChcIi5udi15Lm52LWF4aXNcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBhdmFpbGFibGVXaWR0aCArIFwiLDApXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxuICAgICAgICAgICAgbXVsdGliYXJcbiAgICAgICAgICAgICAgICAuZGlzYWJsZWQoZGF0YS5tYXAoZnVuY3Rpb24oc2VyaWVzKSB7IHJldHVybiBzZXJpZXMuZGlzYWJsZWQgfSkpXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgfSkpO1xuXG5cbiAgICAgICAgICAgIHZhciBiYXJzV3JhcCA9IGcuc2VsZWN0KCcubnYtYmFyc1dyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSk7XG5cbiAgICAgICAgICAgIGJhcnNXcmFwLmNhbGwobXVsdGliYXIpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBBeGVzXG4gICAgICAgICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgICAgICAgICAgeEF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWChhdmFpbGFibGVXaWR0aC8xMDAsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB5LnJhbmdlKClbMF0gKyAnKScpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhUaWNrcyA9IGcuc2VsZWN0KCcubnYteC5udi1heGlzID4gZycpLnNlbGVjdEFsbCgnZycpO1xuXG4gICAgICAgICAgICAgICAgeFRpY2tzXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2xpbmUsIHRleHQnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0YWdnZXJMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldFRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFnZ2VyVXAgPSA1LCBzdGFnZ2VyRG93biA9IDE3OyAgLy9waXhlbHMgdG8gc3RhZ2dlciBieVxuICAgICAgICAgICAgICAgICAgICAvLyBJc3N1ZSAjMTQwXG4gICAgICAgICAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGksaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAgZ2V0VHJhbnNsYXRlKDAsIChqICUgMiA9PSAwID8gc3RhZ2dlclVwIDogc3RhZ2dlckRvd24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbEluQmV0d2VlblRpY2tzID0gZDMuc2VsZWN0QWxsKFwiLm52LXgubnYtYXhpcyAubnYtd3JhcCBnIGcgdGV4dFwiKVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGcuc2VsZWN0QWxsKFwiLm52LXgubnYtYXhpcyAubnYtYXhpc01heE1pbiB0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHJhbnNsYXRlKDAsIChpID09PSAwIHx8IHRvdGFsSW5CZXR3ZWVuVGlja3MgJSAyICE9PSAwKSA/IHN0YWdnZXJEb3duIDogc3RhZ2dlclVwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VYVGlja3MpXG4gICAgICAgICAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAlIE1hdGguY2VpbChkYXRhWzBdLnZhbHVlcy5sZW5ndGggLyAoYXZhaWxhYmxlV2lkdGggLyAxMDApKSAhPT0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0LCBsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApO1xuXG4gICAgICAgICAgICAgICAgaWYocm90YXRlTGFiZWxzKVxuICAgICAgICAgICAgICAgICAgICB4VGlja3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJy50aWNrIHRleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICdyb3RhdGUoJyArIHJvdGF0ZUxhYmVscyArICcgMCwwKScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgcm90YXRlTGFiZWxzID4gMCA/ICdzdGFydCcgOiAnZW5kJyk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLnNlbGVjdEFsbCgnZy5udi1heGlzTWF4TWluIHRleHQnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3dZQXhpcykge1xuICAgICAgICAgICAgICAgIHlBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgICAgICAgICAudGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1koYXZhaWxhYmxlSGVpZ2h0LzM2LCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeUF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb250cm9scy5kaXNwYXRjaC5vbignbGVnZW5kQ2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWQuZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb250cm9sc0RhdGEgPSBjb250cm9sc0RhdGEubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZC5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnR3JvdXBlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTdGFja2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpYmFyLnN0YWNrZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGFja2VkID0gbXVsdGliYXIuc3RhY2tlZCgpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcblxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IGUuZGlzYWJsZWRbaV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuc3RhY2tlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGliYXIuc3RhY2tlZChlLnN0YWNrZWQpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGFja2VkID0gZS5zdGFja2VkO1xuICAgICAgICAgICAgICAgICAgICBzdGFja2VkID0gZS5zdGFja2VkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnbXVsdGliYXJjaGFydCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBtdWx0aWJhci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBtdWx0aWJhci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICAgIH0pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQubXVsdGliYXIgPSBtdWx0aWJhcjtcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgICBjaGFydC55QXhpcyA9IHlBeGlzO1xuICAgIGNoYXJ0LnN0YXRlID0gc3RhdGU7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzaG93TGVnZW5kOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGVnZW5kO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xlZ2VuZD1fO319LFxuICAgICAgICBzaG93Q29udHJvbHM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dDb250cm9sczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dDb250cm9scz1fO319LFxuICAgICAgICBjb250cm9sTGFiZWxzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb250cm9sTGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7Y29udHJvbExhYmVscz1fO319LFxuICAgICAgICBzaG93WEF4aXM6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1hBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1hBeGlzPV87fX0sXG4gICAgICAgIHNob3dZQXhpczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1lBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1lBeGlzPV87fX0sXG4gICAgICAgIHRvb2x0aXBzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBzPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRlZmF1bHRTdGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RlZmF1bHRTdGF0ZT1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuICAgICAgICByZWR1Y2VYVGlja3M6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJlZHVjZVhUaWNrczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3JlZHVjZVhUaWNrcz1fO319LFxuICAgICAgICByb3RhdGVMYWJlbHM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJvdGF0ZUxhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3JvdGF0ZUxhYmVscz1fO319LFxuICAgICAgICBzdGFnZ2VyTGFiZWxzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzdGFnZ2VyTGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7c3RhZ2dlckxhYmVscz1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICBtdWx0aWJhci5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB4QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB5QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHJpZ2h0QWxpZ25ZQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmlnaHRBbGlnbllBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICByaWdodEFsaWduWUF4aXMgPSBfO1xuICAgICAgICAgICAgeUF4aXMub3JpZW50KCByaWdodEFsaWduWUF4aXMgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBtdWx0aWJhcik7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLm11bHRpQmFySG9yaXpvbnRhbCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAgICAgLCB3aWR0aCA9IDk2MFxuICAgICAgICAsIGhlaWdodCA9IDUwMFxuICAgICAgICAsIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApIC8vQ3JlYXRlIHNlbWktdW5pcXVlIElEIGluIGNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcbiAgICAgICAgLCB4ID0gZDMuc2NhbGUub3JkaW5hbCgpXG4gICAgICAgICwgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9XG4gICAgICAgICwgZ2V0WSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9XG4gICAgICAgICwgZ2V0WWVyciA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueUVyciB9XG4gICAgICAgICwgZm9yY2VZID0gWzBdIC8vIDAgaXMgZm9yY2VkIGJ5IGRlZmF1bHQuLiB0aGlzIG1ha2VzIHNlbnNlIGZvciB0aGUgbWFqb3JpdHkgb2YgYmFyIGdyYXBocy4uLiB1c2VyIGNhbiBhbHdheXMgZG8gY2hhcnQuZm9yY2VZKFtdKSB0byByZW1vdmVcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgYmFyQ29sb3IgPSBudWxsIC8vIGFkZGluZyB0aGUgYWJpbGl0eSB0byBzZXQgdGhlIGNvbG9yIGZvciBlYWNoIHJhdGhlciB0aGFuIHRoZSB3aG9sZSBncm91cFxuICAgICAgICAsIGRpc2FibGVkIC8vIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBiYXJDb2xvciB0byBjb21tdW5pY2F0ZSBmcm9tIG11bHRpQmFySG9yaXpvbnRhbENoYXJ0IHdoYXQgc2VyaWVzIGFyZSBkaXNhYmxlZFxuICAgICAgICAsIHN0YWNrZWQgPSBmYWxzZVxuICAgICAgICAsIHNob3dWYWx1ZXMgPSBmYWxzZVxuICAgICAgICAsIHNob3dCYXJMYWJlbHMgPSBmYWxzZVxuICAgICAgICAsIHZhbHVlUGFkZGluZyA9IDYwXG4gICAgICAgICwgdmFsdWVGb3JtYXQgPSBkMy5mb3JtYXQoJywuMmYnKVxuICAgICAgICAsIGRlbGF5ID0gMTIwMFxuICAgICAgICAsIHhEb21haW5cbiAgICAgICAgLCB5RG9tYWluXG4gICAgICAgICwgeFJhbmdlXG4gICAgICAgICwgeVJhbmdlXG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdjaGFydENsaWNrJywgJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsQ2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnLCdyZW5kZXJFbmQnKVxuICAgICAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciB4MCwgeTA7IC8vdXNlZCB0byBzdG9yZSBwcmV2aW91cyBzY2FsZXNcbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICBpZiAoc3RhY2tlZClcbiAgICAgICAgICAgICAgICBkYXRhID0gZDMubGF5b3V0LnN0YWNrKClcbiAgICAgICAgICAgICAgICAgICAgLm9mZnNldCgnemVybycpXG4gICAgICAgICAgICAgICAgICAgIC52YWx1ZXMoZnVuY3Rpb24oZCl7IHJldHVybiBkLnZhbHVlcyB9KVxuICAgICAgICAgICAgICAgICAgICAueShnZXRZKVxuICAgICAgICAgICAgICAgIChkYXRhKTtcblxuICAgICAgICAgICAgLy9hZGQgc2VyaWVzIGluZGV4IHRvIGVhY2ggZGF0YSBwb2ludCBmb3IgcmVmZXJlbmNlXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLCBpKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnNlcmllcyA9IGk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSEFDSyBmb3IgbmVnYXRpdmUgdmFsdWUgc3RhY2tpbmdcbiAgICAgICAgICAgIGlmIChzdGFja2VkKVxuICAgICAgICAgICAgICAgIGRhdGFbMF0udmFsdWVzLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc0Jhc2UgPSAwLCBuZWdCYXNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBkLnZhbHVlc1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgZi5zaXplID0gTWF0aC5hYnMoZi55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmLnk8MCkgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLnkxID0gbmVnQmFzZSAtIGYuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWdCYXNlID0gbmVnQmFzZSAtIGYuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYueTEgPSBwb3NCYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc0Jhc2UgPSBwb3NCYXNlICsgZi5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICAvLyByZW1hcCBhbmQgZmxhdHRlbiB0aGUgZGF0YSBmb3IgdXNlIGluIGNhbGN1bGF0aW5nIHRoZSBzY2FsZXMnIGRvbWFpbnNcbiAgICAgICAgICAgIHZhciBzZXJpZXNEYXRhID0gKHhEb21haW4gJiYgeURvbWFpbikgPyBbXSA6IC8vIGlmIHdlIGtub3cgeERvbWFpbiBhbmQgeURvbWFpbiwgbm8gbmVlZCB0byBjYWxjdWxhdGVcbiAgICAgICAgICAgICAgICBkYXRhLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBnZXRYKGQsaSksIHk6IGdldFkoZCxpKSwgeTA6IGQueTAsIHkxOiBkLnkxIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgeC5kb21haW4oeERvbWFpbiB8fCBkMy5tZXJnZShzZXJpZXNEYXRhKS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0pKVxuICAgICAgICAgICAgICAgIC5yYW5nZUJhbmRzKHhSYW5nZSB8fCBbMCwgYXZhaWxhYmxlSGVpZ2h0XSwgLjEpO1xuXG4gICAgICAgICAgICB5LmRvbWFpbih5RG9tYWluIHx8IGQzLmV4dGVudChkMy5tZXJnZShzZXJpZXNEYXRhKS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gc3RhY2tlZCA/IChkLnkgPiAwID8gZC55MSArIGQueSA6IGQueTEgKSA6IGQueSB9KS5jb25jYXQoZm9yY2VZKSkpXG5cbiAgICAgICAgICAgIGlmIChzaG93VmFsdWVzICYmICFzdGFja2VkKVxuICAgICAgICAgICAgICAgIHkucmFuZ2UoeVJhbmdlIHx8IFsoeS5kb21haW4oKVswXSA8IDAgPyB2YWx1ZVBhZGRpbmcgOiAwKSwgYXZhaWxhYmxlV2lkdGggLSAoeS5kb21haW4oKVsxXSA+IDAgPyB2YWx1ZVBhZGRpbmcgOiAwKSBdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB5LnJhbmdlKHlSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgICAgICAgeDAgPSB4MCB8fCB4O1xuICAgICAgICAgICAgeTAgPSB5MCB8fCBkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oeS5kb21haW4oKSkucmFuZ2UoW3koMCkseSgwKV0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtbXVsdGliYXJIb3Jpem9udGFsJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtbXVsdGliYXJIb3Jpem9udGFsJyk7XG4gICAgICAgICAgICB2YXIgZGVmc0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZGVmcycpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWdyb3VwcycpO1xuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICB2YXIgZ3JvdXBzID0gd3JhcC5zZWxlY3QoJy5udi1ncm91cHMnKS5zZWxlY3RBbGwoJy5udi1ncm91cCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9LCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGkgfSk7XG4gICAgICAgICAgICBncm91cHMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMWUtNik7XG4gICAgICAgICAgICBncm91cHMuZXhpdCgpLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ211bHRpYmFyaG9yaXpvbnRhbDogZXhpdCBncm91cHMnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMWUtNilcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICBncm91cHNcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICdudi1ncm91cCBudi1zZXJpZXMtJyArIGkgfSlcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaG92ZXInLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmhvdmVyIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCxpKXsgcmV0dXJuIGNvbG9yKGQsIGkpIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpeyByZXR1cm4gY29sb3IoZCwgaSkgfSk7XG4gICAgICAgICAgICBncm91cHMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbXVsdGliYXJob3Jpem9udGFsOiBncm91cHMnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgLjc1KTtcblxuICAgICAgICAgICAgdmFyIGJhcnMgPSBncm91cHMuc2VsZWN0QWxsKCdnLm52LWJhcicpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMgfSk7XG4gICAgICAgICAgICBiYXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgdmFyIGJhcnNFbnRlciA9IGJhcnMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGksaikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeTAoc3RhY2tlZCA/IGQueTAgOiAwKSArICcsJyArIChzdGFja2VkID8gMCA6IChqICogeC5yYW5nZUJhbmQoKSAvIGRhdGEubGVuZ3RoICkgKyB4KGdldFgoZCxpKSkpICsgJyknXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJhcnNFbnRlci5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHgucmFuZ2VCYW5kKCkgLyAoc3RhY2tlZCA/IDEgOiBkYXRhLmxlbmd0aCkgKVxuXG4gICAgICAgICAgICBiYXJzXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGkpIHsgLy9UT0RPOiBmaWd1cmUgb3V0IHdoeSBqIHdvcmtzIGFib3ZlLCBidXQgbm90IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogWyB5KGdldFkoZCxpKSArIChzdGFja2VkID8gZC55MCA6IDApKSwgeChnZXRYKGQsaSkpICsgKHgucmFuZ2VCYW5kKCkgKiAoc3RhY2tlZCA/IGRhdGEubGVuZ3RoIC8gMiA6IGQuc2VyaWVzICsgLjUpIC8gZGF0YS5sZW5ndGgpIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQsaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WShkLGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKGQsaSkpICsgKHgucmFuZ2VCYW5kKCkgKiAoc3RhY2tlZCA/IGRhdGEubGVuZ3RoIC8gMiA6IGQuc2VyaWVzICsgLjUpIC8gZGF0YS5sZW5ndGgpLCB5KGdldFkoZCxpKSArIChzdGFja2VkID8gZC55MCA6IDApKV0sICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGUgdmFsdWUgYXBwZWFycyB0byBiZSBzaGlmdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50RGJsQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZCxpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChkLGkpKSArICh4LnJhbmdlQmFuZCgpICogKHN0YWNrZWQgPyBkYXRhLmxlbmd0aCAvIDIgOiBkLnNlcmllcyArIC41KSAvIGRhdGEubGVuZ3RoKSwgeShnZXRZKGQsaSkgKyAoc3RhY2tlZCA/IGQueTAgOiAwKSldLCAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhlIHZhbHVlIGFwcGVhcnMgdG8gYmUgc2hpZnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGdldFllcnIoZGF0YVswXSwwKSkge1xuICAgICAgICAgICAgICAgIGJhcnNFbnRlci5hcHBlbmQoJ3BvbHlsaW5lJyk7XG5cbiAgICAgICAgICAgICAgICBiYXJzLnNlbGVjdCgncG9seWxpbmUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhlcnIgPSBnZXRZZXJyKGQsaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIG1pZCA9IDAuOCAqIHgucmFuZ2VCYW5kKCkgLyAoKHN0YWNrZWQgPyAxIDogZGF0YS5sZW5ndGgpICogMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ZXJyID0geGVyci5sZW5ndGggPyB4ZXJyIDogWy1NYXRoLmFicyh4ZXJyKSwgTWF0aC5hYnMoeGVycildO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGVyciA9IHhlcnIubWFwKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHkoZSkgLSB5KDApOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gW1t4ZXJyWzBdLC1taWRdLCBbeGVyclswXSxtaWRdLCBbeGVyclswXSwwXSwgW3hlcnJbMV0sMF0sIFt4ZXJyWzFdLC1taWRdLCBbeGVyclsxXSxtaWRdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLm1hcChmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aC5qb2luKCcsJykgfSkuam9pbignICcpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWlkID0geC5yYW5nZUJhbmQoKSAvICgoc3RhY2tlZCA/IDEgOiBkYXRhLmxlbmd0aCkgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoZ2V0WShkLGkpIDwgMCA/IDAgOiB5KGdldFkoZCxpKSkgLSB5KDApKSArICcsICcgKyBtaWQgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhcnNFbnRlci5hcHBlbmQoJ3RleHQnKTtcblxuICAgICAgICAgICAgaWYgKHNob3dWYWx1ZXMgJiYgIXN0YWNrZWQpIHtcbiAgICAgICAgICAgICAgICBiYXJzLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WShkLGkpIDwgMCA/ICdlbmQnIDogJ3N0YXJ0JyB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHgucmFuZ2VCYW5kKCkgLyAoZGF0YS5sZW5ndGggKiAyKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zMmVtJylcbiAgICAgICAgICAgICAgICAgICAgLmh0bWwoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHZhbHVlRm9ybWF0KGdldFkoZCxpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHllcnIgPSBnZXRZZXJyKGQsaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeWVyciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF5ZXJyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCArICcmcGx1c21uOycgKyB2YWx1ZUZvcm1hdChNYXRoLmFicyh5ZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCArICcrJyArIHZhbHVlRm9ybWF0KE1hdGguYWJzKHllcnJbMV0pKSArICctJyArIHZhbHVlRm9ybWF0KE1hdGguYWJzKHllcnJbMF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYmFycy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdtdWx0aWJhcmhvcml6b250YWw6IGJhcnMnKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyAtNCA6IHkoZ2V0WShkLGkpKSAtIHkoMCkgKyA0IH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhcnMuc2VsZWN0QWxsKCd0ZXh0JykudGV4dCgnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93QmFyTGFiZWxzICYmICFzdGFja2VkKSB7XG4gICAgICAgICAgICAgICAgYmFyc0VudGVyLmFwcGVuZCgndGV4dCcpLmNsYXNzZWQoJ252LWJhci1sYWJlbCcsdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYmFycy5zZWxlY3QoJ3RleHQubnYtYmFyLWxhYmVsJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRZKGQsaSkgPCAwID8gJ3N0YXJ0JyA6ICdlbmQnIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeC5yYW5nZUJhbmQoKSAvIChkYXRhLmxlbmd0aCAqIDIpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjMyZW0nKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFgoZCxpKSB9KTtcbiAgICAgICAgICAgICAgICBiYXJzLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ211bHRpYmFyaG9yaXpvbnRhbDogYmFycycpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3RleHQubnYtYmFyLWxhYmVsJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyB5KDApIC0geShnZXRZKGQsaSkpICsgNCA6IC00IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFycy5zZWxlY3RBbGwoJ3RleHQubnYtYmFyLWxhYmVsJykudGV4dCgnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhcnNcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyAnbnYtYmFyIG5lZ2F0aXZlJyA6ICdudi1iYXIgcG9zaXRpdmUnfSlcblxuICAgICAgICAgICAgaWYgKGJhckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlZCkgZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIHRydWUgfSk7XG4gICAgICAgICAgICAgICAgYmFyc1xuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGksaikgeyByZXR1cm4gZDMucmdiKGJhckNvbG9yKGQsaSkpLmRhcmtlciggIGRpc2FibGVkLm1hcChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGkgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSl7IHJldHVybiAhZGlzYWJsZWRbaV0gIH0pW2pdICAgKS50b1N0cmluZygpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiBkMy5yZ2IoYmFyQ29sb3IoZCxpKSkuZGFya2VyKCAgZGlzYWJsZWQubWFwKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gaSB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKXsgcmV0dXJuICFkaXNhYmxlZFtpXSAgfSlbal0gICApLnRvU3RyaW5nKCk7IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhY2tlZClcbiAgICAgICAgICAgICAgICBiYXJzLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ211bHRpYmFyaG9yaXpvbnRhbDogYmFycycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB5KGQueTEpICsgJywnICsgeChnZXRYKGQsaSkpICsgJyknXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh5KGdldFkoZCxpKSArIGQueTApIC0geShkLnkwKSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHgucmFuZ2VCYW5kKCkgKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBiYXJzLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ211bHRpYmFyaG9yaXpvbnRhbDogYmFycycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogc3RhY2tlZCBtdXN0IGJlIGFsbCBwb3NpdGl2ZSBvciBhbGwgbmVnYXRpdmUsIG5vdCBib3RoP1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdldFkoZCxpKSA8IDAgPyB5KGdldFkoZCxpKSkgOiB5KDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJywnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZC5zZXJpZXMgKiB4LnJhbmdlQmFuZCgpIC8gZGF0YS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4KGdldFgoZCxpKSkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJyknXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgeC5yYW5nZUJhbmQoKSAvIGRhdGEubGVuZ3RoIClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnMoeShnZXRZKGQsaSkpIC0geSgwKSksMSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vc3RvcmUgb2xkIHNjYWxlcyBmb3IgdXNlIGluIHRyYW5zaXRpb25zIG9uIHVwZGF0ZVxuICAgICAgICAgICAgeDAgPSB4LmNvcHkoKTtcbiAgICAgICAgICAgIHkwID0geS5jb3B5KCk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdtdWx0aWJhckhvcml6b250YWwgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICB4OiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WD1fO319LFxuICAgICAgICB5OiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WT1fO319LFxuICAgICAgICB5RXJyOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZZXJyO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WWVycj1fO319LFxuICAgICAgICB4U2NhbGU6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4O30sIHNldDogZnVuY3Rpb24oXyl7eD1fO319LFxuICAgICAgICB5U2NhbGU6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5O30sIHNldDogZnVuY3Rpb24oXyl7eT1fO319LFxuICAgICAgICB4RG9tYWluOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eERvbWFpbj1fO319LFxuICAgICAgICB5RG9tYWluOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eURvbWFpbj1fO319LFxuICAgICAgICB4UmFuZ2U6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt4UmFuZ2U9Xzt9fSxcbiAgICAgICAgeVJhbmdlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geVJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eVJhbmdlPV87fX0sXG4gICAgICAgIGZvcmNlWTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvcmNlWTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ZvcmNlWT1fO319LFxuICAgICAgICBzdGFja2VkOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzdGFja2VkO30sIHNldDogZnVuY3Rpb24oXyl7c3RhY2tlZD1fO319LFxuICAgICAgICBzaG93VmFsdWVzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93VmFsdWVzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1ZhbHVlcz1fO319LFxuICAgICAgICAvLyB0aGlzIHNob3dzIHRoZSBncm91cCBuYW1lLCBzZWVtcyBwb2ludGxlc3M/XG4gICAgICAgIC8vc2hvd0JhckxhYmVsczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0JhckxhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dCYXJMYWJlbHM9Xzt9fSxcbiAgICAgICAgZGlzYWJsZWQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkaXNhYmxlZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2Rpc2FibGVkPV87fX0sXG4gICAgICAgIGlkOiAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtpZD1fO319LFxuICAgICAgICB2YWx1ZUZvcm1hdDogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHZhbHVlRm9ybWF0O30sIHNldDogZnVuY3Rpb24oXyl7dmFsdWVGb3JtYXQ9Xzt9fSxcbiAgICAgICAgdmFsdWVQYWRkaW5nOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB2YWx1ZVBhZGRpbmc7fSwgc2V0OiBmdW5jdGlvbihfKXt2YWx1ZVBhZGRpbmc9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGJhckNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGJhckNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xubnYubW9kZWxzLm11bHRpQmFySG9yaXpvbnRhbENoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtdWx0aWJhciA9IG52Lm1vZGVscy5tdWx0aUJhckhvcml6b250YWwoKVxuICAgICAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKS5oZWlnaHQoMzApXG4gICAgICAgICwgY29udHJvbHMgPSBudi5tb2RlbHMubGVnZW5kKCkuaGVpZ2h0KDMwKVxuICAgICAgICA7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9XG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBzaG93Q29udHJvbHMgPSB0cnVlXG4gICAgICAgICwgY29udHJvbExhYmVscyA9IHt9XG4gICAgICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcbiAgICAgICAgLCBzaG93WEF4aXMgPSB0cnVlXG4gICAgICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxuICAgICAgICAsIHN0YWNrZWQgPSBmYWxzZVxuICAgICAgICAsIHRvb2x0aXBzID0gdHJ1ZVxuICAgICAgICAsIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxoMz4nICsga2V5ICsgJyAtICcgKyB4ICsgJzwvaDM+JyArXG4gICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICc8L3A+J1xuICAgICAgICB9XG4gICAgICAgICwgeCAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueFNjYWxlKClcbiAgICAgICAgLCB5IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC55U2NhbGUoKVxuICAgICAgICAsIHN0YXRlID0gbnYudXRpbHMuc3RhdGUoKVxuICAgICAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAgICAgLCBub0RhdGEgPSAnTm8gRGF0YSBBdmFpbGFibGUuJ1xuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJywgJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJywncmVuZGVyRW5kJylcbiAgICAgICAgLCBjb250cm9sV2lkdGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNob3dDb250cm9scyA/IDE4MCA6IDAgfVxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgIDtcblxuICAgIHN0YXRlLnN0YWNrZWQgPSBmYWxzZTsgLy8gREVQUkVDQVRFRCBNYWludGFpbmVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgICBtdWx0aWJhclxuICAgICAgICAuc3RhY2tlZChzdGFja2VkKVxuICAgIDtcbiAgICB4QXhpc1xuICAgICAgICAub3JpZW50KCdsZWZ0JylcbiAgICAgICAgLnRpY2tQYWRkaW5nKDUpXG4gICAgICAgIC5oaWdobGlnaHRaZXJvKGZhbHNlKVxuICAgICAgICAuc2hvd01heE1pbihmYWxzZSlcbiAgICAgICAgLnRpY2tGb3JtYXQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KVxuICAgIDtcbiAgICB5QXhpc1xuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAudGlja0Zvcm1hdChkMy5mb3JtYXQoJywuMWYnKSlcbiAgICA7XG5cbiAgICBjb250cm9scy51cGRhdGVTdGF0ZShmYWxzZSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgICAgIHggPSB4QXhpcy50aWNrRm9ybWF0KCkobXVsdGliYXIueCgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgeSA9IHlBeGlzLnRpY2tGb3JtYXQoKShtdWx0aWJhci55KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIGUudmFsdWUgPCAwID8gJ2UnIDogJ3cnLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSxcbiAgICAgICAgICAgICAgICBzdGFja2VkOiBzdGFja2VkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZVNldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc3RhY2tlZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHN0YWNrZWQgPSBzdGF0ZS5zdGFja2VkO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSAhc3RhdGUuYWN0aXZlW2ldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCBkdXJhdGlvbik7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKG11bHRpYmFyKTtcbiAgICAgICAgaWYgKHNob3dYQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHhBeGlzKTtcbiAgICAgICAgaWYgKHNob3dZQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHlBeGlzKTtcblxuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoY2hhcnQpIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICBzdGFja2VkID0gbXVsdGliYXIuc3RhY2tlZCgpO1xuXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICAgIC5zZXR0ZXIoc3RhdGVTZXR0ZXIoZGF0YSksIGNoYXJ0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAuZ2V0dGVyKHN0YXRlR2V0dGVyKGRhdGEpKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoKTtcblxuICAgICAgICAgICAgLy8gREVQUkVDQVRFRCBzZXQgc3RhdGUuZGlzYWJsZWRkaXNhYmxlZFxuICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG5cbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IE5vIERhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLmxlbmd0aCB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9EYXRhVGV4dCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5kYXRhKFtub0RhdGFdKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi1ub0RhdGEnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dFxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG1hcmdpbi50b3AgKyBhdmFpbGFibGVIZWlnaHQgLyAyKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeCA9IG11bHRpYmFyLnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IG11bHRpYmFyLnlTY2FsZSgpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtbXVsdGlCYXJIb3Jpem9udGFsQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1tdWx0aUJhckhvcml6b250YWxDaGFydCcpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJylcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtemVyb0xpbmUnKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1iYXJzV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1jb250cm9sc1dyYXAnKTtcblxuICAgICAgICAgICAgLy8gTGVnZW5kXG4gICAgICAgICAgICBpZiAoc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aChhdmFpbGFibGVXaWR0aCAtIGNvbnRyb2xXaWR0aCgpKTtcblxuICAgICAgICAgICAgICAgIGlmIChtdWx0aWJhci5iYXJDb2xvcigpKVxuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5jb2xvciA9IGQzLnJnYignI2NjYycpLmRhcmtlcihpICogMS41KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChsZWdlbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBtYXJnaW4udG9wICE9IGxlZ2VuZC5oZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGNvbnRyb2xXaWR0aCgpICsgJywnICsgKC1tYXJnaW4udG9wKSArJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udHJvbHNcbiAgICAgICAgICAgIGlmIChzaG93Q29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHNEYXRhID0gW1xuICAgICAgICAgICAgICAgICAgICB7IGtleTogY29udHJvbExhYmVscy5ncm91cGVkIHx8ICdHcm91cGVkJywgZGlzYWJsZWQ6IG11bHRpYmFyLnN0YWNrZWQoKSB9LFxuICAgICAgICAgICAgICAgICAgICB7IGtleTogY29udHJvbExhYmVscy5zdGFja2VkIHx8ICdTdGFja2VkJywgZGlzYWJsZWQ6ICFtdWx0aWJhci5zdGFja2VkKCkgfVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBjb250cm9scy53aWR0aChjb250cm9sV2lkdGgoKSkuY29sb3IoWycjNDQ0JywgJyM0NDQnLCAnIzQ0NCddKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRyb2xzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShjb250cm9sc0RhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJylcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoY29udHJvbHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG4gICAgICAgICAgICBtdWx0aWJhclxuICAgICAgICAgICAgICAgIC5kaXNhYmxlZChkYXRhLm1hcChmdW5jdGlvbihzZXJpZXMpIHsgcmV0dXJuIHNlcmllcy5kaXNhYmxlZCB9KSlcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzV3JhcCA9IGcuc2VsZWN0KCcubnYtYmFyc1dyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSk7XG5cbiAgICAgICAgICAgIGJhcnNXcmFwLnRyYW5zaXRpb24oKS5jYWxsKG11bHRpYmFyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgQXhlc1xuICAgICAgICAgICAgaWYgKHNob3dYQXhpcykge1xuICAgICAgICAgICAgICAgIHhBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgICAudGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1koYXZhaWxhYmxlSGVpZ2h0LzI0LCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKS5jYWxsKHhBeGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciB4VGlja3MgPSBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLnNlbGVjdEFsbCgnZycpO1xuXG4gICAgICAgICAgICAgICAgeFRpY2tzXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2xpbmUsIHRleHQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3dZQXhpcykge1xuICAgICAgICAgICAgICAgIHlBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgICAgICAgICAudGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1goYXZhaWxhYmxlV2lkdGgvMTAwLCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZUhlaWdodCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIGF2YWlsYWJsZUhlaWdodCArICcpJyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi15Lm52LWF4aXMnKS5jYWxsKHlBeGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gWmVybyBsaW5lXG4gICAgICAgICAgICBnLnNlbGVjdChcIi5udi16ZXJvTGluZSBsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB5KDApKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgeSgwKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCAtYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb250cm9scy5kaXNwYXRjaC5vbignbGVnZW5kQ2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWQuZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb250cm9sc0RhdGEgPSBjb250cm9sc0RhdGEubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZC5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnR3JvdXBlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTdGFja2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpYmFyLnN0YWNrZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGFja2VkID0gbXVsdGliYXIuc3RhY2tlZCgpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBzdGFja2VkID0gbXVsdGliYXIuc3RhY2tlZCgpO1xuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwcykgc2hvd1Rvb2x0aXAoZSwgdGhhdC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IGUuZGlzYWJsZWRbaV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuc3RhY2tlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGliYXIuc3RhY2tlZChlLnN0YWNrZWQpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGFja2VkID0gZS5zdGFja2VkO1xuICAgICAgICAgICAgICAgICAgICBzdGFja2VkID0gZS5zdGFja2VkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ211bHRpYmFyIGhvcml6b250YWwgY2hhcnQgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbXVsdGliYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgbXVsdGliYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgICB9KTtcbiAgICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0Lm11bHRpYmFyID0gbXVsdGliYXI7XG4gICAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICAgIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gICAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgICBjaGFydC5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgc2hvd0xlZ2VuZDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0xlZ2VuZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dMZWdlbmQ9Xzt9fSxcbiAgICAgICAgc2hvd0NvbnRyb2xzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93Q29udHJvbHM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93Q29udHJvbHM9Xzt9fSxcbiAgICAgICAgY29udHJvbExhYmVsczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29udHJvbExhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2NvbnRyb2xMYWJlbHM9Xzt9fSxcbiAgICAgICAgc2hvd1hBeGlzOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dYQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dYQXhpcz1fO319LFxuICAgICAgICBzaG93WUF4aXM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dZQXhpcz1fO319LFxuICAgICAgICB0b29sdGlwczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcHM7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwcz1fO319LFxuICAgICAgICB0b29sdGlwQ29udGVudDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXA9Xzt9fSxcbiAgICAgICAgZGVmYXVsdFN0YXRlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZhdWx0U3RhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXtkZWZhdWx0U3RhdGU9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICAgICAgbXVsdGliYXIuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICAgICAgeEF4aXMuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICAgICAgeUF4aXMuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgbXVsdGliYXIpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5udi5tb2RlbHMubXVsdGlDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9LFxuICAgICAgICBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpLFxuICAgICAgICB3aWR0aCA9IG51bGwsXG4gICAgICAgIGhlaWdodCA9IG51bGwsXG4gICAgICAgIHNob3dMZWdlbmQgPSB0cnVlLFxuICAgICAgICB0b29sdGlwcyA9IHRydWUsXG4gICAgICAgIHRvb2x0aXAgPSBmdW5jdGlvbihrZXksIHgsIHksIGUsIGdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxoMz4nICsga2V5ICsgJzwvaDM+JyArXG4gICAgICAgICAgICAgICAgJzxwPicgKyAgeSArICcgYXQgJyArIHggKyAnPC9wPidcbiAgICAgICAgfSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgbm9EYXRhID0gJ05vIERhdGEgQXZhaWxhYmxlLicsXG4gICAgICAgIHlEb21haW4xLFxuICAgICAgICB5RG9tYWluMixcbiAgICAgICAgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9LFxuICAgICAgICBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55fSxcbiAgICAgICAgaW50ZXJwb2xhdGUgPSAnbW9ub3RvbmUnXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKSxcbiAgICAgICAgeVNjYWxlMSA9IGQzLnNjYWxlLmxpbmVhcigpLFxuICAgICAgICB5U2NhbGUyID0gZDMuc2NhbGUubGluZWFyKCksXG5cbiAgICAgICAgbGluZXMxID0gbnYubW9kZWxzLmxpbmUoKS55U2NhbGUoeVNjYWxlMSksXG4gICAgICAgIGxpbmVzMiA9IG52Lm1vZGVscy5saW5lKCkueVNjYWxlKHlTY2FsZTIpLFxuXG4gICAgICAgIGJhcnMxID0gbnYubW9kZWxzLm11bHRpQmFyKCkuc3RhY2tlZChmYWxzZSkueVNjYWxlKHlTY2FsZTEpLFxuICAgICAgICBiYXJzMiA9IG52Lm1vZGVscy5tdWx0aUJhcigpLnN0YWNrZWQoZmFsc2UpLnlTY2FsZSh5U2NhbGUyKSxcblxuICAgICAgICBzdGFjazEgPSBudi5tb2RlbHMuc3RhY2tlZEFyZWEoKS55U2NhbGUoeVNjYWxlMSksXG4gICAgICAgIHN0YWNrMiA9IG52Lm1vZGVscy5zdGFja2VkQXJlYSgpLnlTY2FsZSh5U2NhbGUyKSxcblxuICAgICAgICB4QXhpcyA9IG52Lm1vZGVscy5heGlzKCkuc2NhbGUoeCkub3JpZW50KCdib3R0b20nKS50aWNrUGFkZGluZyg1KSxcbiAgICAgICAgeUF4aXMxID0gbnYubW9kZWxzLmF4aXMoKS5zY2FsZSh5U2NhbGUxKS5vcmllbnQoJ2xlZnQnKSxcbiAgICAgICAgeUF4aXMyID0gbnYubW9kZWxzLmF4aXMoKS5zY2FsZSh5U2NhbGUyKS5vcmllbnQoJ3JpZ2h0JyksXG5cbiAgICAgICAgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpLmhlaWdodCgzMCksXG4gICAgICAgIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJyk7XG5cbiAgICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG4gICAgICAgIHZhciBsZWZ0ID0gZS5wb3NbMF0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3AgfHwgMCksXG4gICAgICAgICAgICB4ID0geEF4aXMudGlja0Zvcm1hdCgpKGxpbmVzMS54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICB5ID0gKChlLnNlcmllcy55QXhpcyA9PSAyKSA/IHlBeGlzMiA6IHlBeGlzMSkudGlja0Zvcm1hdCgpKGxpbmVzMS55KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICBjb250ZW50ID0gdG9vbHRpcChlLnNlcmllcy5rZXksIHgsIHksIGUsIGNoYXJ0KTtcblxuICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnQsIHRvcF0sIGNvbnRlbnQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvZmZzZXRFbGVtZW50Lm9mZnNldFBhcmVudCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHsgY29udGFpbmVyLnRyYW5zaXRpb24oKS5jYWxsKGNoYXJ0KTsgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgICAgIHZhciBkYXRhTGluZXMxID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkLnR5cGUgPT0gJ2xpbmUnICYmIGQueUF4aXMgPT0gMX0pO1xuICAgICAgICAgICAgdmFyIGRhdGFMaW5lczIgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7cmV0dXJuIGQudHlwZSA9PSAnbGluZScgJiYgZC55QXhpcyA9PSAyfSk7XG4gICAgICAgICAgICB2YXIgZGF0YUJhcnMxID0gIGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gZC50eXBlID09ICdiYXInICAmJiBkLnlBeGlzID09IDF9KTtcbiAgICAgICAgICAgIHZhciBkYXRhQmFyczIgPSAgZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkLnR5cGUgPT0gJ2JhcicgICYmIGQueUF4aXMgPT0gMn0pO1xuICAgICAgICAgICAgdmFyIGRhdGFTdGFjazEgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7cmV0dXJuIGQudHlwZSA9PSAnYXJlYScgJiYgZC55QXhpcyA9PSAxfSk7XG4gICAgICAgICAgICB2YXIgZGF0YVN0YWNrMiA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gZC50eXBlID09ICdhcmVhJyAmJiBkLnlBeGlzID09IDJ9KTtcblxuICAgICAgICAgICAgLy8gRGlzcGxheSBub0RhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLmxlbmd0aCB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9EYXRhVGV4dCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5kYXRhKFtub0RhdGFdKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi1ub0RhdGEnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dFxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG1hcmdpbi50b3AgKyBhdmFpbGFibGVIZWlnaHQgLyAyKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXMxID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiAhZC5kaXNhYmxlZCAmJiBkLnlBeGlzID09IDF9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZC54LCB5OiBkLnkgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc2VyaWVzMiA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gIWQuZGlzYWJsZWQgJiYgZC55QXhpcyA9PSAyfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQudmFsdWVzLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IGQueCwgeTogZC55IH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgeCAgIC5kb21haW4oZDMuZXh0ZW50KGQzLm1lcmdlKHNlcmllczEuY29uY2F0KHNlcmllczIpKSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0gKSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy53cmFwLm11bHRpQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3dyYXAgbnZkMyBtdWx0aUNoYXJ0JykuYXBwZW5kKCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICd4IGF4aXMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICd5MSBheGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAneTIgYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2xpbmVzMVdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdsaW5lczJXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnYmFyczFXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnYmFyczJXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnc3RhY2sxV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3N0YWNrMldyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdsZWdlbmRXcmFwJyk7XG5cbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgdmFyIGNvbG9yX2FycmF5ID0gZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbaV0uY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBsZWdlbmQuY29sb3IoY29sb3JfYXJyYXkpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aCggYXZhaWxhYmxlV2lkdGggLyAyICk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLmxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5tYXAoZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMub3JpZ2luYWxLZXkgPSBzZXJpZXMub3JpZ2luYWxLZXkgPT09IHVuZGVmaW5lZCA/IHNlcmllcy5rZXkgOiBzZXJpZXMub3JpZ2luYWxLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMua2V5ID0gc2VyaWVzLm9yaWdpbmFsS2V5ICsgKHNlcmllcy55QXhpcyA9PSAxID8gJycgOiAnIChyaWdodCBheGlzKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllcztcbiAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLmxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKCBhdmFpbGFibGVXaWR0aCAvIDIgKSArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmVzMVxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuaW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGNvbG9yX2FycmF5LmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmIGRhdGFbaV0ueUF4aXMgPT0gMSAmJiBkYXRhW2ldLnR5cGUgPT0gJ2xpbmUnfSkpO1xuICAgICAgICAgICAgbGluZXMyXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSlcbiAgICAgICAgICAgICAgICAuY29sb3IoY29sb3JfYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS55QXhpcyA9PSAyICYmIGRhdGFbaV0udHlwZSA9PSAnbGluZSd9KSk7XG4gICAgICAgICAgICBiYXJzMVxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuY29sb3IoY29sb3JfYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS55QXhpcyA9PSAxICYmIGRhdGFbaV0udHlwZSA9PSAnYmFyJ30pKTtcbiAgICAgICAgICAgIGJhcnMyXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5jb2xvcihjb2xvcl9hcnJheS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiBkYXRhW2ldLnlBeGlzID09IDIgJiYgZGF0YVtpXS50eXBlID09ICdiYXInfSkpO1xuICAgICAgICAgICAgc3RhY2sxXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5jb2xvcihjb2xvcl9hcnJheS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiBkYXRhW2ldLnlBeGlzID09IDEgJiYgZGF0YVtpXS50eXBlID09ICdhcmVhJ30pKTtcbiAgICAgICAgICAgIHN0YWNrMlxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuY29sb3IoY29sb3JfYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS55QXhpcyA9PSAyICYmIGRhdGFbaV0udHlwZSA9PSAnYXJlYSd9KSk7XG5cbiAgICAgICAgICAgIGcuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgdmFyIGxpbmVzMVdyYXAgPSBnLnNlbGVjdCgnLmxpbmVzMVdyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShcbiAgICAgICAgICAgICAgICAgICAgZGF0YUxpbmVzMS5maWx0ZXIoZnVuY3Rpb24oZCl7cmV0dXJuICFkLmRpc2FibGVkfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGJhcnMxV3JhcCA9IGcuc2VsZWN0KCcuYmFyczFXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oXG4gICAgICAgICAgICAgICAgICAgIGRhdGFCYXJzMS5maWx0ZXIoZnVuY3Rpb24oZCl7cmV0dXJuICFkLmRpc2FibGVkfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHN0YWNrMVdyYXAgPSBnLnNlbGVjdCgnLnN0YWNrMVdyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShcbiAgICAgICAgICAgICAgICAgICAgZGF0YVN0YWNrMS5maWx0ZXIoZnVuY3Rpb24oZCl7cmV0dXJuICFkLmRpc2FibGVkfSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgbGluZXMyV3JhcCA9IGcuc2VsZWN0KCcubGluZXMyV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKFxuICAgICAgICAgICAgICAgICAgICBkYXRhTGluZXMyLmZpbHRlcihmdW5jdGlvbihkKXtyZXR1cm4gIWQuZGlzYWJsZWR9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgYmFyczJXcmFwID0gZy5zZWxlY3QoJy5iYXJzMldyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShcbiAgICAgICAgICAgICAgICAgICAgZGF0YUJhcnMyLmZpbHRlcihmdW5jdGlvbihkKXtyZXR1cm4gIWQuZGlzYWJsZWR9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgc3RhY2syV3JhcCA9IGcuc2VsZWN0KCcuc3RhY2syV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKFxuICAgICAgICAgICAgICAgICAgICBkYXRhU3RhY2syLmZpbHRlcihmdW5jdGlvbihkKXtyZXR1cm4gIWQuZGlzYWJsZWR9KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBleHRyYVZhbHVlMSA9IGRhdGFTdGFjazEubGVuZ3RoID8gZGF0YVN0YWNrMS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGEudmFsdWVzfSkucmVkdWNlKGZ1bmN0aW9uKGEsYil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubWFwKGZ1bmN0aW9uKGFWYWwsaSl7cmV0dXJuIHt4OiBhVmFsLngsIHk6IGFWYWwueSArIGJbaV0ueX19KVxuICAgICAgICAgICAgfSkuY29uY2F0KFt7eDowLCB5OjB9XSkgOiBbXVxuICAgICAgICAgICAgdmFyIGV4dHJhVmFsdWUyID0gZGF0YVN0YWNrMi5sZW5ndGggPyBkYXRhU3RhY2syLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYS52YWx1ZXN9KS5yZWR1Y2UoZnVuY3Rpb24oYSxiKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5tYXAoZnVuY3Rpb24oYVZhbCxpKXtyZXR1cm4ge3g6IGFWYWwueCwgeTogYVZhbC55ICsgYltpXS55fX0pXG4gICAgICAgICAgICB9KS5jb25jYXQoW3t4OjAsIHk6MH1dKSA6IFtdXG5cbiAgICAgICAgICAgIHlTY2FsZTEgLmRvbWFpbih5RG9tYWluMSB8fCBkMy5leHRlbnQoZDMubWVyZ2Uoc2VyaWVzMSkuY29uY2F0KGV4dHJhVmFsdWUxKSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH0gKSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIGF2YWlsYWJsZUhlaWdodF0pXG5cbiAgICAgICAgICAgIHlTY2FsZTIgLmRvbWFpbih5RG9tYWluMiB8fCBkMy5leHRlbnQoZDMubWVyZ2Uoc2VyaWVzMikuY29uY2F0KGV4dHJhVmFsdWUyKSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH0gKSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIGF2YWlsYWJsZUhlaWdodF0pXG5cbiAgICAgICAgICAgIGxpbmVzMS55RG9tYWluKHlTY2FsZTEuZG9tYWluKCkpXG4gICAgICAgICAgICBiYXJzMS55RG9tYWluKHlTY2FsZTEuZG9tYWluKCkpXG4gICAgICAgICAgICBzdGFjazEueURvbWFpbih5U2NhbGUxLmRvbWFpbigpKVxuXG4gICAgICAgICAgICBsaW5lczIueURvbWFpbih5U2NhbGUyLmRvbWFpbigpKVxuICAgICAgICAgICAgYmFyczIueURvbWFpbih5U2NhbGUyLmRvbWFpbigpKVxuICAgICAgICAgICAgc3RhY2syLnlEb21haW4oeVNjYWxlMi5kb21haW4oKSlcblxuICAgICAgICAgICAgaWYoZGF0YVN0YWNrMS5sZW5ndGgpe2QzLnRyYW5zaXRpb24oc3RhY2sxV3JhcCkuY2FsbChzdGFjazEpO31cbiAgICAgICAgICAgIGlmKGRhdGFTdGFjazIubGVuZ3RoKXtkMy50cmFuc2l0aW9uKHN0YWNrMldyYXApLmNhbGwoc3RhY2syKTt9XG5cbiAgICAgICAgICAgIGlmKGRhdGFCYXJzMS5sZW5ndGgpe2QzLnRyYW5zaXRpb24oYmFyczFXcmFwKS5jYWxsKGJhcnMxKTt9XG4gICAgICAgICAgICBpZihkYXRhQmFyczIubGVuZ3RoKXtkMy50cmFuc2l0aW9uKGJhcnMyV3JhcCkuY2FsbChiYXJzMik7fVxuXG4gICAgICAgICAgICBpZihkYXRhTGluZXMxLmxlbmd0aCl7ZDMudHJhbnNpdGlvbihsaW5lczFXcmFwKS5jYWxsKGxpbmVzMSk7fVxuICAgICAgICAgICAgaWYoZGF0YUxpbmVzMi5sZW5ndGgpe2QzLnRyYW5zaXRpb24obGluZXMyV3JhcCkuY2FsbChsaW5lczIpO31cblxuICAgICAgICAgICAgeEF4aXNcbiAgICAgICAgICAgICAgICAudGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1goYXZhaWxhYmxlV2lkdGgvMTAwLCBkYXRhKSApXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQsIDApO1xuXG4gICAgICAgICAgICBnLnNlbGVjdCgnLnguYXhpcycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgYXZhaWxhYmxlSGVpZ2h0ICsgJyknKTtcbiAgICAgICAgICAgIGQzLnRyYW5zaXRpb24oZy5zZWxlY3QoJy54LmF4aXMnKSlcbiAgICAgICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG5cbiAgICAgICAgICAgIHlBeGlzMVxuICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cblxuICAgICAgICAgICAgZDMudHJhbnNpdGlvbihnLnNlbGVjdCgnLnkxLmF4aXMnKSlcbiAgICAgICAgICAgICAgICAuY2FsbCh5QXhpczEpO1xuXG4gICAgICAgICAgICB5QXhpczJcbiAgICAgICAgICAgICAgICAudGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1koYXZhaWxhYmxlSGVpZ2h0LzM2LCBkYXRhKSApXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKGcuc2VsZWN0KCcueTIuYXhpcycpKVxuICAgICAgICAgICAgICAgIC5jYWxsKHlBeGlzMik7XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCcueTEuYXhpcycpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ252LWRpc2FibGVkJywgc2VyaWVzMS5sZW5ndGggPyBmYWxzZSA6IHRydWUpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHgucmFuZ2UoKVswXSArICcsMCknKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJy55Mi5heGlzJylcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnbnYtZGlzYWJsZWQnLCBzZXJpZXMyLmxlbmd0aCA/IGZhbHNlIDogdHJ1ZSlcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeC5yYW5nZSgpWzFdICsgJywwKScpO1xuXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsaW5lczEuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgbGluZXMxLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBsaW5lczIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgbGluZXMyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBiYXJzMS5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBiYXJzMS5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgYmFyczIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyAgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgYmFyczIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgICB9KTtcblxuICAgIHN0YWNrMS5kaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vZGlzYWJsZSB0b29sdGlwcyB3aGVuIHZhbHVlIH49IDBcbiAgICAgICAgLy8vLyBUT0RPOiBjb25zaWRlciByZW1vdmluZyBwb2ludHMgZnJvbSB2b3Jvbm9pIHRoYXQgaGF2ZSAwIHZhbHVlIGluc3RlYWQgb2YgdGhpcyBoYWNrXG4gICAgICAgIGlmICghTWF0aC5yb3VuZChzdGFjazEueSgpKGUucG9pbnQpICogMTAwKSkgeyAgLy8gMTAwIHdpbGwgbm90IGJlIGdvb2QgZm9yIHZlcnkgc21hbGwgbnVtYmVycy4uLiB3aWxsIGhhdmUgdG8gdGhpbmsgYWJvdXQgbWFraW5nIHRoaXMgdmFsdSBkeW5hbWljLCBiYXNlZCBvbiBkYXRhIHJhbmdlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBkMy5zZWxlY3RBbGwoJy5wb2ludC5ob3ZlcicpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXSxcbiAgICAgICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgc3RhY2sxLmRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgfSk7XG5cbiAgICBzdGFjazIuZGlzcGF0Y2gub24oJ3Rvb2x0aXBTaG93JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvL2Rpc2FibGUgdG9vbHRpcHMgd2hlbiB2YWx1ZSB+PSAwXG4gICAgICAgIC8vLy8gVE9ETzogY29uc2lkZXIgcmVtb3ZpbmcgcG9pbnRzIGZyb20gdm9yb25vaSB0aGF0IGhhdmUgMCB2YWx1ZSBpbnN0ZWFkIG9mIHRoaXMgaGFja1xuICAgICAgICBpZiAoIU1hdGgucm91bmQoc3RhY2syLnkoKShlLnBvaW50KSAqIDEwMCkpIHsgIC8vIDEwMCB3aWxsIG5vdCBiZSBnb29kIGZvciB2ZXJ5IHNtYWxsIG51bWJlcnMuLi4gd2lsbCBoYXZlIHRvIHRoaW5rIGFib3V0IG1ha2luZyB0aGlzIHZhbHUgZHluYW1pYywgYmFzZWQgb24gZGF0YSByYW5nZVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZDMuc2VsZWN0QWxsKCcucG9pbnQuaG92ZXInKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKSB9LCAwKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF0sXG4gICAgICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgICB9KTtcblxuICAgIHN0YWNrMi5kaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgbGluZXMxLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgICB9KTtcblxuICAgIGxpbmVzMS5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgbGluZXMyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgIG1hcmdpbi5sZWZ0LCBlLnBvc1sxXSArIG1hcmdpbi50b3BdO1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgICB9KTtcblxuICAgIGxpbmVzMi5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEdsb2JhbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQubGluZXMxID0gbGluZXMxO1xuICAgIGNoYXJ0LmxpbmVzMiA9IGxpbmVzMjtcbiAgICBjaGFydC5iYXJzMSA9IGJhcnMxO1xuICAgIGNoYXJ0LmJhcnMyID0gYmFyczI7XG4gICAgY2hhcnQuc3RhY2sxID0gc3RhY2sxO1xuICAgIGNoYXJ0LnN0YWNrMiA9IHN0YWNrMjtcbiAgICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICAgIGNoYXJ0LnlBeGlzMSA9IHlBeGlzMTtcbiAgICBjaGFydC55QXhpczIgPSB5QXhpczI7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzaG93TGVnZW5kOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGVnZW5kO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xlZ2VuZD1fO319LFxuICAgICAgICB5RG9tYWluMTogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5RG9tYWluMTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lEb21haW4xPV87fX0sXG4gICAgICAgIHlEb21haW4yOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5RG9tYWluMjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lEb21haW4yPV87fX0sXG4gICAgICAgIHRvb2x0aXBzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBzPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuICAgICAgICBpbnRlcnBvbGF0ZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaW50ZXJwb2xhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXtpbnRlcnBvbGF0ZT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHg6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFg7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGdldFggPSBfO1xuICAgICAgICAgICAgbGluZXMxLngoXyk7XG4gICAgICAgICAgICBiYXJzMS54KF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgeToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZ2V0WSA9IF87XG4gICAgICAgICAgICBsaW5lczEueShfKTtcbiAgICAgICAgICAgIGJhcnMxLnkoXyk7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5cbm52Lm1vZGVscy5vaGxjQmFyID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSAvL0NyZWF0ZSBzZW1pLXVuaXF1ZSBJRCBpbiBjYXNlIHVzZXIgZG9lc24ndCBzZWxlY3Qgb25lXG4gICAgICAgICwgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICwgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9XG4gICAgICAgICwgZ2V0WSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9XG4gICAgICAgICwgZ2V0T3BlbiA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQub3BlbiB9XG4gICAgICAgICwgZ2V0Q2xvc2UgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLmNsb3NlIH1cbiAgICAgICAgLCBnZXRIaWdoID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5oaWdoIH1cbiAgICAgICAgLCBnZXRMb3cgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLmxvdyB9XG4gICAgICAgICwgZm9yY2VYID0gW11cbiAgICAgICAgLCBmb3JjZVkgPSBbXVxuICAgICAgICAsIHBhZERhdGEgICAgID0gZmFsc2UgLy8gSWYgdHJ1ZSwgYWRkcyBoYWxmIGEgZGF0YSBwb2ludHMgd2lkdGggdG8gZnJvbnQgYW5kIGJhY2ssIGZvciBsaW5pbmcgdXAgYSBsaW5lIGNoYXJ0IHdpdGggYSBiYXIgY2hhcnRcbiAgICAgICAgLCBjbGlwRWRnZSA9IHRydWVcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgaW50ZXJhY3RpdmUgPSBmYWxzZVxuICAgICAgICAsIHhEb21haW5cbiAgICAgICAgLCB5RG9tYWluXG4gICAgICAgICwgeFJhbmdlXG4gICAgICAgICwgeVJhbmdlXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnLCAncmVuZGVyRW5kJywgJ2NoYXJ0Q2xpY2snLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxDbGljaycsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcpXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKVxuICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHguZG9tYWluKHhEb21haW4gfHwgZDMuZXh0ZW50KGRhdGFbMF0udmFsdWVzLm1hcChnZXRYKS5jb25jYXQoZm9yY2VYKSApKTtcblxuICAgICAgICAgICAgaWYgKHBhZERhdGEpXG4gICAgICAgICAgICAgICAgeC5yYW5nZSh4UmFuZ2UgfHwgW2F2YWlsYWJsZVdpZHRoICogLjUgLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGgsIGF2YWlsYWJsZVdpZHRoICogKGRhdGFbMF0udmFsdWVzLmxlbmd0aCAtIC41KSAgLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGggXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgeC5yYW5nZSh4UmFuZ2UgfHwgWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgICAgICAgIHkuZG9tYWluKHlEb21haW4gfHwgW1xuICAgICAgICAgICAgICAgICAgICBkMy5taW4oZGF0YVswXS52YWx1ZXMubWFwKGdldExvdykuY29uY2F0KGZvcmNlWSkpLFxuICAgICAgICAgICAgICAgICAgICBkMy5tYXgoZGF0YVswXS52YWx1ZXMubWFwKGdldEhpZ2gpLmNvbmNhdChmb3JjZVkpKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICkucmFuZ2UoeVJhbmdlIHx8IFthdmFpbGFibGVIZWlnaHQsIDBdKTtcblxuICAgICAgICAgICAgLy8gSWYgc2NhbGUncyBkb21haW4gZG9uJ3QgaGF2ZSBhIHJhbmdlLCBzbGlnaHRseSBhZGp1c3QgdG8gbWFrZSBvbmUuLi4gc28gYSBjaGFydCBjYW4gc2hvdyBhIHNpbmdsZSBkYXRhIHBvaW50XG4gICAgICAgICAgICBpZiAoeC5kb21haW4oKVswXSA9PT0geC5kb21haW4oKVsxXSlcbiAgICAgICAgICAgICAgICB4LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgICAgICAgICAgeC5kb21haW4oW3guZG9tYWluKClbMF0gLSB4LmRvbWFpbigpWzBdICogMC4wMSwgeC5kb21haW4oKVsxXSArIHguZG9tYWluKClbMV0gKiAwLjAxXSlcbiAgICAgICAgICAgICAgICAgICAgOiB4LmRvbWFpbihbLTEsMV0pO1xuXG4gICAgICAgICAgICBpZiAoeS5kb21haW4oKVswXSA9PT0geS5kb21haW4oKVsxXSlcbiAgICAgICAgICAgICAgICB5LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgICAgICAgICAgeS5kb21haW4oW3kuZG9tYWluKClbMF0gKyB5LmRvbWFpbigpWzBdICogMC4wMSwgeS5kb21haW4oKVsxXSAtIHkuZG9tYWluKClbMV0gKiAwLjAxXSlcbiAgICAgICAgICAgICAgICAgICAgOiB5LmRvbWFpbihbLTEsMV0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtb2hsY0JhcicpLmRhdGEoW2RhdGFbMF0udmFsdWVzXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1vaGxjQmFyJyk7XG4gICAgICAgICAgICB2YXIgZGVmc0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZGVmcycpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXRpY2tzJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5jaGFydENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlZnNFbnRlci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnbnYtY2hhcnQtY2xpcC1wYXRoLScgKyBpZClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0Jyk7XG5cbiAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcjbnYtY2hhcnQtY2xpcC1wYXRoLScgKyBpZCArICcgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIGcgICAuYXR0cignY2xpcC1wYXRoJywgY2xpcEVkZ2UgPyAndXJsKCNudi1jaGFydC1jbGlwLXBhdGgtJyArIGlkICsgJyknIDogJycpO1xuXG4gICAgICAgICAgICB2YXIgdGlja3MgPSB3cmFwLnNlbGVjdCgnLm52LXRpY2tzJykuc2VsZWN0QWxsKCcubnYtdGljaycpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcbiAgICAgICAgICAgIHRpY2tzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgdmFyIHRpY2tzRW50ZXIgPSB0aWNrcy5lbnRlcigpLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuIChnZXRPcGVuKGQsaSkgPiBnZXRDbG9zZShkLGkpID8gJ252LXRpY2sgbmVnYXRpdmUnIDogJ252LXRpY2sgcG9zaXRpdmUnKSArICcgbnYtdGljay0nICsgaiArICctJyArIGkgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IChhdmFpbGFibGVXaWR0aCAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCkgKiAuOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtMCwwbDAsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAoeShnZXRPcGVuKGQsaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB5KGdldEhpZ2goZCxpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICArICdsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAoLXcvMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJywwbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKHcvMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJywwbDAsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAoeShnZXRMb3coZCxpKSkgLSB5KGdldE9wZW4oZCxpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICArICdsMCwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh5KGdldENsb3NlKGQsaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB5KGdldExvdyhkLGkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2wnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh3LzIpXG4gICAgICAgICAgICAgICAgICAgICAgICArICcsMGwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICgtdy8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnLDB6JztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoZ2V0WChkLGkpKSArICcsJyArIHkoZ2V0SGlnaChkLGkpKSArICcpJzsgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gY29sb3JbMF07IH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gY29sb3JbMF07IH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwIClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQsaSkgeyAgcmV0dXJuIHkoTWF0aC5tYXgoMCwgZ2V0WShkLGkpKSkgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBNYXRoLmFicyh5KGdldFkoZCxpKSkgLSB5KDApKSB9KTtcblxuICAgICAgICAgICAgLy8gdGhlIGJhciBjb2xvcnMgYXJlIGNvbnRyb2xsZWQgYnkgQ1NTIGN1cnJlbnRseVxuICAgICAgICAgICAgdGlja3MuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGksaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZ2V0T3BlbihkLGkpID4gZ2V0Q2xvc2UoZCxpKSA/ICdudi10aWNrIG5lZ2F0aXZlJyA6ICdudi10aWNrIHBvc2l0aXZlJykgKyAnIG52LXRpY2stJyArIGogKyAnLScgKyBpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGQzLnRyYW5zaXRpb24odGlja3MpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeChnZXRYKGQsaSkpICsgJywnICsgeShnZXRIaWdoKGQsaSkpICsgJyknOyB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gKGF2YWlsYWJsZVdpZHRoIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoKSAqIC45O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ20wLDBsMCwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh5KGdldE9wZW4oZCxpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHkoZ2V0SGlnaChkLGkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2wnXG4gICAgICAgICAgICAgICAgICAgICAgICArICgtdy8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnLDBsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAody8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnLDBsMCwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh5KGdldExvdyhkLGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0geShnZXRPcGVuKGQsaSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnbDAsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAoeShnZXRDbG9zZShkLGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0geShnZXRMb3coZCxpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICArICdsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAody8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnLDBsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAoLXcvMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJywweic7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cblxuICAgIC8vQ3JlYXRlIG1ldGhvZHMgdG8gYWxsb3cgb3V0c2lkZSBmdW5jdGlvbnMgdG8gaGlnaGxpZ2h0IGEgc3BlY2lmaWMgYmFyLlxuICAgIGNoYXJ0LmhpZ2hsaWdodFBvaW50ID0gZnVuY3Rpb24ocG9pbnRJbmRleCwgaXNIb3Zlck92ZXIpIHtcbiAgICAgICAgY2hhcnQuY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICAgIGQzLnNlbGVjdChcIi5udi1vaGxjQmFyIC5udi10aWNrLTAtXCIgKyBwb2ludEluZGV4KVxuICAgICAgICAgICAgLmNsYXNzZWQoXCJob3ZlclwiLCBpc0hvdmVyT3ZlcilcbiAgICAgICAgO1xuICAgIH07XG5cbiAgICBjaGFydC5jbGVhckhpZ2hsaWdodHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiLm52LW9obGNCYXIgLm52LXRpY2suaG92ZXJcIilcbiAgICAgICAgICAgIC5jbGFzc2VkKFwiaG92ZXJcIiwgZmFsc2UpXG4gICAgICAgIDtcbiAgICB9O1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgeFNjYWxlOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHg7fSwgc2V0OiBmdW5jdGlvbihfKXt4PV87fX0sXG4gICAgICAgIHlTY2FsZTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5O30sIHNldDogZnVuY3Rpb24oXyl7eT1fO319LFxuICAgICAgICB4RG9tYWluOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geERvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hEb21haW49Xzt9fSxcbiAgICAgICAgeURvbWFpbjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt5RG9tYWluPV87fX0sXG4gICAgICAgIHhSYW5nZTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt4UmFuZ2U9Xzt9fSxcbiAgICAgICAgeVJhbmdlOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lSYW5nZT1fO319LFxuICAgICAgICBmb3JjZVg6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9yY2VYO30sIHNldDogZnVuY3Rpb24oXyl7Zm9yY2VYPV87fX0sXG4gICAgICAgIGZvcmNlWTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVk7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVk9Xzt9fSxcbiAgICAgICAgcGFkRGF0YTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHBhZERhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtwYWREYXRhPV87fX0sXG4gICAgICAgIGNsaXBFZGdlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjbGlwRWRnZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2NsaXBFZGdlPV87fX0sXG4gICAgICAgIGlkOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2lkPV87fX0sXG4gICAgICAgIGludGVyYWN0aXZlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpbnRlcmFjdGl2ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ludGVyYWN0aXZlPV87fX0sXG5cbiAgICAgICAgeDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFg7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRYPV87fX0sXG4gICAgICAgIHk6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WT1fO319LFxuICAgICAgICBvcGVuOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0T3BlbigpO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0T3Blbj1fO319LFxuICAgICAgICBjbG9zZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0Q2xvc2UoKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldENsb3NlPV87fX0sXG4gICAgICAgIGhpZ2g6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRIaWdoO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0SGlnaD1fO319LFxuICAgICAgICBsb3c6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0TG93O30sIHNldDogZnVuY3Rpb24oXyl7Z2V0TG93PV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxuLy8gQ29kZSBhZGFwdGVkIGZyb20gSmFzb24gRGF2aWVzJyBcIlBhcmFsbGVsIENvb3JkaW5hdGVzXCJcbi8vIGh0dHA6Ly9ibC5vY2tzLm9yZy9qYXNvbmRhdmllcy8xMzQxMjgxXG5cbm52Lm1vZGVscy5wYXJhbGxlbENvb3JkaW5hdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAzMCwgcmlnaHQ6IDEwLCBib3R0b206IDEwLCBsZWZ0OiAxMH1cbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgeCA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgICAgICAsIHkgPSB7fVxuICAgICAgICAsIGRpbWVuc2lvbnMgPSBbXVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBmaWx0ZXJzID0gW11cbiAgICAgICAgLCBhY3RpdmUgPSBbXVxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2JydXNoJylcbiAgICAgICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGFjdGl2ZSA9IGRhdGE7IC8vc2V0IGFsbCBhY3RpdmUgYmVmb3JlIGZpcnN0IGJydXNoIGNhbGxcblxuICAgICAgICAgICAgLy9UaGlzIGlzIGEgcGxhY2Vob2xkZXIgdW50aWwgdGhpcyBjaGFydCBpcyBtYWRlIHJlc2l6ZWFibGVcbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyB9O1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHgucmFuZ2VQb2ludHMoWzAsIGF2YWlsYWJsZVdpZHRoXSwgMSkuZG9tYWluKGRpbWVuc2lvbnMpO1xuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBsaXN0IG9mIGRpbWVuc2lvbnMgYW5kIGNyZWF0ZSBhIHNjYWxlIGZvciBlYWNoLlxuICAgICAgICAgICAgZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICB5W2RdID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihkMy5leHRlbnQoZGF0YSwgZnVuY3Rpb24ocCkgeyByZXR1cm4gK3BbZF07IH0pKVxuICAgICAgICAgICAgICAgICAgICAucmFuZ2UoW2F2YWlsYWJsZUhlaWdodCwgMF0pO1xuXG4gICAgICAgICAgICAgICAgeVtkXS5icnVzaCA9IGQzLnN2Zy5icnVzaCgpLnkoeVtkXSkub24oJ2JydXNoJywgYnJ1c2gpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQgIT0gJ25hbWUnO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1wYXJhbGxlbENvb3JkaW5hdGVzJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtcGFyYWxsZWxDb29yZGluYXRlcycpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXBhcmFsbGVsQ29vcmRpbmF0ZXNXcmFwJyk7XG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIHZhciBsaW5lID0gZDMuc3ZnLmxpbmUoKSxcbiAgICAgICAgICAgICAgICBheGlzID0gZDMuc3ZnLmF4aXMoKS5vcmllbnQoJ2xlZnQnKSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgIGZvcmVncm91bmQ7XG5cbiAgICAgICAgICAgIC8vIEFkZCBncmV5IGJhY2tncm91bmQgbGluZXMgZm9yIGNvbnRleHQuXG4gICAgICAgICAgICBiYWNrZ3JvdW5kID0gZ0VudGVyLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JhY2tncm91bmQnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHBhdGgpXG4gICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIC8vIEFkZCBibHVlIGZvcmVncm91bmQgbGluZXMgZm9yIGZvY3VzLlxuICAgICAgICAgICAgZm9yZWdyb3VuZCA9IGdFbnRlci5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdmb3JlZ3JvdW5kJylcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJylcbiAgICAgICAgICAgICAgICAuZGF0YShkYXRhKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBjb2xvcilcbiAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgLy8gQWRkIGEgZ3JvdXAgZWxlbWVudCBmb3IgZWFjaCBkaW1lbnNpb24uXG4gICAgICAgICAgICB2YXIgZGltZW5zaW9uID0gZy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKVxuICAgICAgICAgICAgICAgIC5kYXRhKGRpbWVuc2lvbnMpXG4gICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZGltZW5zaW9uJylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeChkKSArICcsMCknOyB9KTtcblxuICAgICAgICAgICAgLy8gQWRkIGFuIGF4aXMgYW5kIHRpdGxlLlxuICAgICAgICAgICAgZGltZW5zaW9uLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2F4aXMnKVxuICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQpIHsgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5W2RdKSk7IH0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAtOSlcbiAgICAgICAgICAgICAgICAudGV4dChTdHJpbmcpO1xuXG4gICAgICAgICAgICAvLyBBZGQgYW5kIHN0b3JlIGEgYnJ1c2ggZm9yIGVhY2ggYXhpcy5cbiAgICAgICAgICAgIGRpbWVuc2lvbi5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdicnVzaCcpXG4gICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCkgeyBkMy5zZWxlY3QodGhpcykuY2FsbCh5W2RdLmJydXNoKTsgfSlcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIC04KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDE2KTtcblxuICAgICAgICAgICAgLy8gUmV0dXJucyB0aGUgcGF0aCBmb3IgYSBnaXZlbiBkYXRhIHBvaW50LlxuICAgICAgICAgICAgZnVuY3Rpb24gcGF0aChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUoZGltZW5zaW9ucy5tYXAoZnVuY3Rpb24ocCkgeyByZXR1cm4gW3gocCksIHlbcF0oZFtwXSldOyB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZXMgYSBicnVzaCBldmVudCwgdG9nZ2xpbmcgdGhlIGRpc3BsYXkgb2YgZm9yZWdyb3VuZCBsaW5lcy5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGJydXNoKCkge1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVzID0gZGltZW5zaW9ucy5maWx0ZXIoZnVuY3Rpb24ocCkgeyByZXR1cm4gIXlbcF0uYnJ1c2guZW1wdHkoKTsgfSksXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMgPSBhY3RpdmVzLm1hcChmdW5jdGlvbihwKSB7IHJldHVybiB5W3BdLmJydXNoLmV4dGVudCgpOyB9KTtcblxuICAgICAgICAgICAgICAgIGZpbHRlcnMgPSBbXTsgLy9lcmFzZSBjdXJyZW50IGZpbHRlcnNcbiAgICAgICAgICAgICAgICBhY3RpdmVzLmZvckVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcnNbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb246IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnQ6IGV4dGVudHNbaV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYWN0aXZlID0gW107IC8vZXJhc2UgY3VycmVudCBhY3RpdmUgbGlzdFxuICAgICAgICAgICAgICAgIGZvcmVncm91bmQuc3R5bGUoJ2Rpc3BsYXknLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0FjdGl2ZSA9IGFjdGl2ZXMuZXZlcnkoZnVuY3Rpb24ocCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbaV1bMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGV4dGVudHNbaV1bMV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmUpIGFjdGl2ZS5wdXNoKGQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBY3RpdmUgPyBudWxsIDogJ25vbmUnO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guYnJ1c2goe1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIGRpbWVuc2lvbnM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRpbWVuc2lvbnM7fSwgc2V0OiBmdW5jdGlvbihfKXtkaW1lbnNpb25zPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSB0eXBlb2YgXy5yaWdodCAgIT0gJ3VuZGVmaW5lZCcgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSB0eXBlb2YgXy5ib3R0b20gIT0gJ3VuZGVmaW5lZCcgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcbm52Lm1vZGVscy5waWUgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSA1MDBcbiAgICAgICAgLCBoZWlnaHQgPSA1MDBcbiAgICAgICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH1cbiAgICAgICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAgICAgLCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSAvL0NyZWF0ZSBzZW1pLXVuaXF1ZSBJRCBpbiBjYXNlIHVzZXIgZG9lc24ndCBzZWxlY3Qgb25lXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHZhbHVlRm9ybWF0ID0gZDMuZm9ybWF0KCcsLjJmJylcbiAgICAgICAgLCBsYWJlbEZvcm1hdCA9IGQzLmZvcm1hdCgnJScpXG4gICAgICAgICwgc2hvd0xhYmVscyA9IHRydWVcbiAgICAgICAgLCBwaWVMYWJlbHNPdXRzaWRlID0gdHJ1ZVxuICAgICAgICAsIGRvbnV0TGFiZWxzT3V0c2lkZSA9IGZhbHNlXG4gICAgICAgICwgbGFiZWxUeXBlID0gXCJrZXlcIlxuICAgICAgICAsIGxhYmVsVGhyZXNob2xkID0gLjAyIC8vaWYgc2xpY2UgcGVyY2VudGFnZSBpcyB1bmRlciB0aGlzLCBkb24ndCBzaG93IGxhYmVsXG4gICAgICAgICwgZG9udXQgPSBmYWxzZVxuICAgICAgICAsIHRpdGxlID0gZmFsc2VcbiAgICAgICAgLCBncm93T25Ib3ZlciA9IHRydWVcbiAgICAgICAgLCB0aXRsZU9mZnNldCA9IDBcbiAgICAgICAgLCBsYWJlbFN1bmJlYW1MYXlvdXQgPSBmYWxzZVxuICAgICAgICAsIHN0YXJ0QW5nbGUgPSBmYWxzZVxuICAgICAgICAsIHBhZEFuZ2xlID0gZmFsc2VcbiAgICAgICAgLCBlbmRBbmdsZSA9IGZhbHNlXG4gICAgICAgICwgY29ybmVyUmFkaXVzID0gMFxuICAgICAgICAsIGRvbnV0UmF0aW8gPSAwLjVcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2NoYXJ0Q2xpY2snLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxDbGljaycsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcsICdyZW5kZXJFbmQnKVxuICAgICAgICA7XG5cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gY2hhcnQgZnVuY3Rpb25cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gpO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHRcbiAgICAgICAgICAgICAgICAsYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b21cbiAgICAgICAgICAgICAgICAscmFkaXVzID0gTWF0aC5taW4oYXZhaWxhYmxlV2lkdGgsIGF2YWlsYWJsZUhlaWdodCkgLyAyXG4gICAgICAgICAgICAgICAgLGFyY1JhZGl1cyA9IHJhZGl1cy0ocmFkaXVzIC8gNSlcbiAgICAgICAgICAgICAgICAsY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtd3JhcC5udi1waWUnKS5kYXRhKGRhdGEpO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsJ252ZDMgbnYtd3JhcCBudi1waWUgbnYtY2hhcnQtJyArIGlkKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG4gICAgICAgICAgICB2YXIgZ19waWUgPSBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcGllJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcGllTGFiZWxzJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtcGllJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgYXZhaWxhYmxlV2lkdGggLyAyICsgJywnICsgYXZhaWxhYmxlSGVpZ2h0IC8gMiArICcpJyk7XG4gICAgICAgICAgICBnLnNlbGVjdCgnLm52LXBpZUxhYmVscycpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGF2YWlsYWJsZVdpZHRoIC8gMiArICcsJyArIGF2YWlsYWJsZUhlaWdodCAvIDIgKyAnKScpO1xuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY29udGFpbmVyLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmNoYXJ0Q2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICB2YXIgYXJjID0gZDMuc3ZnLmFyYygpLm91dGVyUmFkaXVzKGFyY1JhZGl1cyk7XG4gICAgICAgICAgICB2YXIgYXJjT3ZlciA9IGQzLnN2Zy5hcmMoKS5vdXRlclJhZGl1cyhhcmNSYWRpdXMgKyA1KTtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0QW5nbGUpIHtcbiAgICAgICAgICAgICAgICBhcmMuc3RhcnRBbmdsZShzdGFydEFuZ2xlKTtcbiAgICAgICAgICAgICAgICBhcmNPdmVyLnN0YXJ0QW5nbGUoc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kQW5nbGUpIHtcbiAgICAgICAgICAgICAgICBhcmMuZW5kQW5nbGUoZW5kQW5nbGUpO1xuICAgICAgICAgICAgICAgIGFyY092ZXIuZW5kQW5nbGUoZW5kQW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvbnV0KSB7XG4gICAgICAgICAgICAgICAgYXJjLmlubmVyUmFkaXVzKHJhZGl1cyAqIGRvbnV0UmF0aW8pO1xuICAgICAgICAgICAgICAgIGFyY092ZXIuaW5uZXJSYWRpdXMocmFkaXVzICogZG9udXRSYXRpbyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHVwIHRoZSBQaWUgY2hhcnQgYW5kIGNob29zZSB0aGUgZGF0YSBlbGVtZW50XG4gICAgICAgICAgICB2YXIgcGllID0gZDMubGF5b3V0LnBpZSgpXG4gICAgICAgICAgICAgICAgLnNvcnQobnVsbClcbiAgICAgICAgICAgICAgICAudmFsdWUoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5kaXNhYmxlZCA/IDAgOiBnZXRZKGQpIH0pO1xuXG4gICAgICAgICAgICAvLyBwYWRBbmdsZSBhZGRlZCBpbiBkMyAzLjVcbiAgICAgICAgICAgIGlmIChwaWUucGFkQW5nbGUgJiYgcGFkQW5nbGUpIHtcbiAgICAgICAgICAgICAgICBwaWUucGFkQW5nbGUocGFkQW5nbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXJjLmNvcm5lclJhZGl1cyAmJiBjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBhcmMuY29ybmVyUmFkaXVzKGNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgYXJjT3Zlci5jb3JuZXJSYWRpdXMoY29ybmVyUmFkaXVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGl0bGUgaXMgc3BlY2lmaWVkIGFuZCBkb251dCwgcHV0IGl0IGluIHRoZSBtaWRkbGVcbiAgICAgICAgICAgIGlmIChkb251dCAmJiB0aXRsZSkge1xuICAgICAgICAgICAgICAgIHZhciB0aXRsZV9nID0gZ19waWUuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcGllJyk7XG5cbiAgICAgICAgICAgICAgICB0aXRsZV9nLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LXBpZS10aXRsZScpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIwLjM1ZW1cIikgLy8gdHJpY2sgdG8gdmVydGljYWxseSBjZW50ZXIgdGV4dFxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwgJysgdGl0bGVPZmZzZXQgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2xpY2VzID0gd3JhcC5zZWxlY3QoJy5udi1waWUnKS5zZWxlY3RBbGwoJy5udi1zbGljZScpLmRhdGEocGllKTtcbiAgICAgICAgICAgIHZhciBwaWVMYWJlbHMgPSB3cmFwLnNlbGVjdCgnLm52LXBpZUxhYmVscycpLnNlbGVjdEFsbCgnLm52LWxhYmVsJykuZGF0YShwaWUpO1xuXG4gICAgICAgICAgICBzbGljZXMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgcGllTGFiZWxzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgdmFyIGFlID0gc2xpY2VzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIGFlLmF0dHIoJ2NsYXNzJywgJ252LXNsaWNlJylcbiAgICAgICAgICAgIGFlLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGkpe1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChncm93T25Ib3Zlcikge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KFwicGF0aFwiKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig3MClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmNPdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXRYKGQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHBvczogW2QzLmV2ZW50LnBhZ2VYLCBkMy5ldmVudC5wYWdlWV0sXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWUub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3dPbkhvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoXCJwYXRoXCIpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXRYKGQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzbGljZXMuYXR0cignZmlsbCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gY29sb3IoZCwgaSk7IH0pXG4gICAgICAgICAgICBzbGljZXMuYXR0cignc3Ryb2tlJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvcihkLCBpKTsgfSk7XG5cbiAgICAgICAgICAgIHZhciBwYXRocyA9IGFlLmFwcGVuZCgncGF0aCcpLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBhdGhzLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBnZXRYKGQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRZKGQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICBwb3M6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGF0aHMub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudERibENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdldFgoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldFkoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHBvczogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzbGljZXMuc2VsZWN0KCdwYXRoJylcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBhcmMpXG4gICAgICAgICAgICAgICAgLmF0dHJUd2VlbignZCcsIGFyY1R3ZWVuKTtcblxuICAgICAgICAgICAgaWYgKHNob3dMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGRvZXMgdGhlIG5vcm1hbCBsYWJlbFxuICAgICAgICAgICAgICAgIHZhciBsYWJlbHNBcmMgPSBkMy5zdmcuYXJjKCkuaW5uZXJSYWRpdXMoMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGllTGFiZWxzT3V0c2lkZSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbHNBcmMgPSBhcmM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRvbnV0TGFiZWxzT3V0c2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbHNBcmMgPSBkMy5zdmcuYXJjKCkub3V0ZXJSYWRpdXMoYXJjLm91dGVyUmFkaXVzKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBpZUxhYmVscy5lbnRlcigpLmFwcGVuZChcImdcIikuY2xhc3NlZChcIm52LWxhYmVsXCIsdHJ1ZSkuZWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFN1bmJlYW1MYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLm91dGVyUmFkaXVzID0gYXJjUmFkaXVzICsgMTA7IC8vIFNldCBPdXRlciBDb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5pbm5lclJhZGl1cyA9IGFyY1JhZGl1cyArIDE1OyAvLyBTZXQgSW5uZXIgQ29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGVBbmdsZSA9IChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgKiAoMTgwIC8gTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChkLnN0YXJ0QW5nbGUrZC5lbmRBbmdsZSkvMiA8IE1hdGguUEkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlQW5nbGUgLT0gOTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlQW5nbGUgKz0gOTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBsYWJlbHNBcmMuY2VudHJvaWQoZCkgKyAnKSByb3RhdGUoJyArIHJvdGF0ZUFuZ2xlICsgJyknO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLm91dGVyUmFkaXVzID0gcmFkaXVzICsgMTA7IC8vIFNldCBPdXRlciBDb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5pbm5lclJhZGl1cyA9IHJhZGl1cyArIDE1OyAvLyBTZXQgSW5uZXIgQ29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBsYWJlbHNBcmMuY2VudHJvaWQoZCkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJyNmZmYnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJyNmZmYnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyeFwiLCAzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyeVwiLCAzKTtcblxuICAgICAgICAgICAgICAgICAgICBncm91cC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIGxhYmVsU3VuYmVhbUxheW91dCA/ICgoZC5zdGFydEFuZ2xlICsgZC5lbmRBbmdsZSkgLyAyIDwgTWF0aC5QSSA/ICdzdGFydCcgOiAnZW5kJykgOiAnbWlkZGxlJykgLy9jZW50ZXIgdGhlIHRleHQgb24gaXQncyBvcmlnaW4gb3IgYmVnaW4vZW5kIGlmIG9ydGhvZ29uYWwgYWxpZ25lZFxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJyMwMDAnKVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxMb2NhdGlvbkhhc2ggPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgYXZnSGVpZ2h0ID0gMTQ7XG4gICAgICAgICAgICAgICAgdmFyIGF2Z1dpZHRoID0gMTQwO1xuICAgICAgICAgICAgICAgIHZhciBjcmVhdGVIYXNoS2V5ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY29vcmRpbmF0ZXNbMF0vYXZnV2lkdGgpICogYXZnV2lkdGggKyAnLCcgKyBNYXRoLmZsb29yKGNvb3JkaW5hdGVzWzFdL2F2Z0hlaWdodCkgKiBhdmdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHBpZUxhYmVscy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsJ3BpZSBsYWJlbHMnKS5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFN1bmJlYW1MYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQub3V0ZXJSYWRpdXMgPSBhcmNSYWRpdXMgKyAxMDsgLy8gU2V0IE91dGVyIENvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuaW5uZXJSYWRpdXMgPSBhcmNSYWRpdXMgKyAxNTsgLy8gU2V0IElubmVyIENvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGVBbmdsZSA9IChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgKiAoMTgwIC8gTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGQuc3RhcnRBbmdsZStkLmVuZEFuZ2xlKS8yIDwgTWF0aC5QSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZUFuZ2xlIC09IDkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVBbmdsZSArPSA5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBsYWJlbHNBcmMuY2VudHJvaWQoZCkgKyAnKSByb3RhdGUoJyArIHJvdGF0ZUFuZ2xlICsgJyknO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5vdXRlclJhZGl1cyA9IHJhZGl1cyArIDEwOyAvLyBTZXQgT3V0ZXIgQ29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZC5pbm5lclJhZGl1cyA9IHJhZGl1cyArIDE1OyAvLyBTZXQgSW5uZXIgQ29vcmRpbmF0ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgIE92ZXJsYXBwaW5nIHBpZSBsYWJlbHMgYXJlIG5vdCBnb29kLiBXaGF0IHRoaXMgYXR0ZW1wdHMgdG8gZG8gaXMsIHByZXZlbnQgb3ZlcmxhcHBpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgRWFjaCBsYWJlbCBsb2NhdGlvbiBpcyBoYXNoZWQsIGFuZCBpZiBhIGhhc2ggY29sbGlzaW9uIG9jY3Vycywgd2UgYXNzdW1lIGFuIG92ZXJsYXAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgQWRqdXN0IHRoZSBsYWJlbCdzIHktcG9zaXRpb24gdG8gcmVtb3ZlIHRoZSBvdmVybGFwLlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gbGFiZWxzQXJjLmNlbnRyb2lkKGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZC52YWx1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2hLZXkgPSBjcmVhdGVIYXNoS2V5KGNlbnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsTG9jYXRpb25IYXNoW2hhc2hLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclsxXSAtPSBhdmdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsTG9jYXRpb25IYXNoW2NyZWF0ZUhhc2hLZXkoY2VudGVyKV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGNlbnRlciArICcpJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBwaWVMYWJlbHMuc2VsZWN0KFwiLm52LWxhYmVsIHRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIGxhYmVsU3VuYmVhbUxheW91dCA/ICgoZC5zdGFydEFuZ2xlICsgZC5lbmRBbmdsZSkgLyAyIDwgTWF0aC5QSSA/ICdzdGFydCcgOiAnZW5kJykgOiAnbWlkZGxlJykgLy9jZW50ZXIgdGhlIHRleHQgb24gaXQncyBvcmlnaW4gb3IgYmVnaW4vZW5kIGlmIG9ydGhvZ29uYWwgYWxpZ25lZFxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxUeXBlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImtleVwiIDogZ2V0WChkLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogZ2V0WShkLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGVyY2VudFwiOiBsYWJlbEZvcm1hdChwZXJjZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZC52YWx1ZSAmJiBwZXJjZW50ID4gbGFiZWxUaHJlc2hvbGQpID8gbGFiZWxUeXBlc1tsYWJlbFR5cGVdIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIENvbXB1dGVzIHRoZSBhbmdsZSBvZiBhbiBhcmMsIGNvbnZlcnRpbmcgZnJvbSByYWRpYW5zIHRvIGRlZ3JlZXMuXG4gICAgICAgICAgICBmdW5jdGlvbiBhbmdsZShkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSAoZC5zdGFydEFuZ2xlICsgZC5lbmRBbmdsZSkgKiA5MCAvIE1hdGguUEkgLSA5MDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA+IDkwID8gYSAtIDE4MCA6IGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFyY1R3ZWVuKGEpIHtcbiAgICAgICAgICAgICAgICBhLmVuZEFuZ2xlID0gaXNOYU4oYS5lbmRBbmdsZSkgPyAwIDogYS5lbmRBbmdsZTtcbiAgICAgICAgICAgICAgICBhLnN0YXJ0QW5nbGUgPSBpc05hTihhLnN0YXJ0QW5nbGUpID8gMCA6IGEuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbnV0KSBhLmlubmVyUmFkaXVzID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGQzLmludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBpKDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmMoaSh0KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdwaWUgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgc2hvd0xhYmVsczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0xhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dMYWJlbHM9Xzt9fSxcbiAgICAgICAgdGl0bGU6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdGl0bGU7fSwgc2V0OiBmdW5jdGlvbihfKXt0aXRsZT1fO319LFxuICAgICAgICB0aXRsZU9mZnNldDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdGl0bGVPZmZzZXQ7fSwgc2V0OiBmdW5jdGlvbihfKXt0aXRsZU9mZnNldD1fO319LFxuICAgICAgICBsYWJlbFRocmVzaG9sZDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGFiZWxUaHJlc2hvbGQ7fSwgc2V0OiBmdW5jdGlvbihfKXtsYWJlbFRocmVzaG9sZD1fO319LFxuICAgICAgICBsYWJlbEZvcm1hdDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGFiZWxGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKXtsYWJlbEZvcm1hdD1fO319LFxuICAgICAgICB2YWx1ZUZvcm1hdDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdmFsdWVGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKXt2YWx1ZUZvcm1hdD1fO319LFxuICAgICAgICB4OiAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WD1fO319LFxuICAgICAgICBpZDogICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2lkPV87fX0sXG4gICAgICAgIGVuZEFuZ2xlOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGVuZEFuZ2xlO30sIHNldDogZnVuY3Rpb24oXyl7ZW5kQW5nbGU9Xzt9fSxcbiAgICAgICAgc3RhcnRBbmdsZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc3RhcnRBbmdsZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3N0YXJ0QW5nbGU9Xzt9fSxcbiAgICAgICAgcGFkQW5nbGU6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcGFkQW5nbGU7fSwgc2V0OiBmdW5jdGlvbihfKXtwYWRBbmdsZT1fO319LFxuICAgICAgICBjb3JuZXJSYWRpdXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvcm5lclJhZGl1czt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2Nvcm5lclJhZGl1cz1fO319LFxuICAgICAgICBkb251dFJhdGlvOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRvbnV0UmF0aW87fSwgc2V0OiBmdW5jdGlvbihfKXtkb251dFJhdGlvPV87fX0sXG4gICAgICAgIHBpZUxhYmVsc091dHNpZGU6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcGllTGFiZWxzT3V0c2lkZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3BpZUxhYmVsc091dHNpZGU9Xzt9fSxcbiAgICAgICAgZG9udXRMYWJlbHNPdXRzaWRlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkb251dExhYmVsc091dHNpZGU7fSwgc2V0OiBmdW5jdGlvbihfKXtkb251dExhYmVsc091dHNpZGU9Xzt9fSxcbiAgICAgICAgbGFiZWxTdW5iZWFtTGF5b3V0OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsYWJlbFN1bmJlYW1MYXlvdXQ7fSwgc2V0OiBmdW5jdGlvbihfKXtsYWJlbFN1bmJlYW1MYXlvdXQ9Xzt9fSxcbiAgICAgICAgZG9udXQ6ICAgICAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkb251dDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RvbnV0PV87fX0sXG4gICAgICAgIGdyb3dPbkhvdmVyOiAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ3Jvd09uSG92ZXI7fSwgc2V0OiBmdW5jdGlvbihfKXtncm93T25Ib3Zlcj1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSB0eXBlb2YgXy50b3AgICAgIT0gJ3VuZGVmaW5lZCcgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gdHlwZW9mIF8ucmlnaHQgICE9ICd1bmRlZmluZWQnID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICB5OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBnZXRZPWQzLmZ1bmN0b3IoXyk7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yPW52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgbGFiZWxUeXBlOiAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsYWJlbFR5cGU7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGxhYmVsVHlwZT0gXyB8fCAna2V5JztcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O1xubnYubW9kZWxzLnBpZUNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBwaWUgPSBudi5tb2RlbHMucGllKCk7XG4gICAgdmFyIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKTtcblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAzMCwgcmlnaHQ6IDIwLCBib3R0b206IDIwLCBsZWZ0OiAyMH1cbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgdG9vbHRpcHMgPSB0cnVlXG4gICAgICAgICwgdG9vbHRpcCA9IGZ1bmN0aW9uKGtleSwgeSwgZSwgZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnPGgzIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogJ1xuICAgICAgICAgICAgICAgICsgZS5jb2xvciArICdcIj4nICsga2V5ICsgJzwvaDM+J1xuICAgICAgICAgICAgICAgICsgJzxwPicgKyAgeSArICc8L3A+JztcbiAgICAgICAgfVxuICAgICAgICAsIHN0YXRlID0gbnYudXRpbHMuc3RhdGUoKVxuICAgICAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAgICAgLCBub0RhdGEgPSBcIk5vIERhdGEgQXZhaWxhYmxlLlwiXG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsJ3JlbmRlckVuZCcpXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHNob3dUb29sdGlwID0gZnVuY3Rpb24oZSwgb2Zmc2V0RWxlbWVudCkge1xuICAgICAgICB2YXIgdG9vbHRpcExhYmVsID0gcGllLngoKShlLnBvaW50KTtcbiAgICAgICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggKG9mZnNldEVsZW1lbnQgJiYgb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0KSB8fCAwICksXG4gICAgICAgICAgICB0b3AgPSBlLnBvc1sxXSArICggKG9mZnNldEVsZW1lbnQgJiYgb2Zmc2V0RWxlbWVudC5vZmZzZXRUb3ApIHx8IDApLFxuICAgICAgICAgICAgeSA9IHBpZS52YWx1ZUZvcm1hdCgpKHBpZS55KCkoZS5wb2ludCkpLFxuICAgICAgICAgICAgY29udGVudCA9IHRvb2x0aXAodG9vbHRpcExhYmVsLCB5LCBlLCBjaGFydClcbiAgICAgICAgICAgIDtcbiAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBlLnZhbHVlIDwgMCA/ICduJyA6ICdzJywgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gICAgfTtcblxuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoKTtcblxuICAgIHZhciBzdGF0ZUdldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZTogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlU2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hY3RpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoc2VyaWVzLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9ICFzdGF0ZS5hY3RpdmVbaV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBDaGFydCBmdW5jdGlvblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKHBpZSk7XG5cbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSwgMTApIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JyksIDEwKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b21cbiAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIudHJhbnNpdGlvbigpLmNhbGwoY2hhcnQpOyB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgc3RhdGUuc2V0dGVyKHN0YXRlU2V0dGVyKGRhdGEpLCBjaGFydC51cGRhdGUpXG4gICAgICAgICAgICAgICAgLmdldHRlcihzdGF0ZUdldHRlcihkYXRhKSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vc2V0IHN0YXRlLmRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LXBpZUNoYXJ0JykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtcGllQ2hhcnQnKS5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXBpZVdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XG5cbiAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgaWYgKHNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBsZWdlbmQud2lkdGgoIGF2YWlsYWJsZVdpZHRoICkua2V5KHBpZS54KCkpO1xuXG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoLW1hcmdpbi50b3ApICsnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxuICAgICAgICAgICAgcGllLndpZHRoKGF2YWlsYWJsZVdpZHRoKS5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBwaWVXcmFwID0gZy5zZWxlY3QoJy5udi1waWVXcmFwJykuZGF0dW0oW2RhdGFdKTtcbiAgICAgICAgICAgIGQzLnRyYW5zaXRpb24ocGllV3JhcCkuY2FsbChwaWUpO1xuXG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0gbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBpZS5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNoYXJ0IGZyb20gYSBzdGF0ZSBvYmplY3QgcGFzc2VkIHRvIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCdjaGFuZ2VTdGF0ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ3BpZUNoYXJ0IGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHBpZS5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnBvcyA9IFtlLnBvc1swXSArICBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcFNob3coZSk7XG4gICAgfSk7XG5cbiAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgc2hvd1Rvb2x0aXAoZSk7XG4gICAgfSk7XG5cbiAgICBkaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBzKSBudi50b29sdGlwLmNsZWFudXAoKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5waWUgPSBwaWU7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgLy8gdXNlIE9iamVjdCBnZXQvc2V0IGZ1bmN0aW9uYWxpdHkgdG8gbWFwIGJldHdlZW4gdmFycyBhbmQgY2hhcnQgZnVuY3Rpb25zXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgbm9EYXRhOiAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCAgICAgICAgIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG4gICAgICAgIHRvb2x0aXBDb250ZW50OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sICAgICAgICBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXA9Xzt9fSxcbiAgICAgICAgdG9vbHRpcHM6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXBzO30sICAgICAgIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcHM9Xzt9fSxcbiAgICAgICAgc2hvd0xlZ2VuZDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgICAgIHNldDogZnVuY3Rpb24oXyl7c2hvd0xlZ2VuZD1fO319LFxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGVmYXVsdFN0YXRlO30sICAgc2V0OiBmdW5jdGlvbihfKXtkZWZhdWx0U3RhdGU9Xzt9fSxcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBjb2xvcjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gXztcbiAgICAgICAgICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XG4gICAgICAgICAgICBwaWUuY29sb3IoY29sb3IpO1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgIH19XG4gICAgfSk7XG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIHBpZSk7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5zY2F0dGVyID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gICAgICAgPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoICAgICAgICA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgICAgICAgPSBudWxsXG4gICAgICAgICwgY29sb3IgICAgICAgID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKCkgLy8gY2hvb3NlcyBjb2xvclxuICAgICAgICAsIGlkICAgICAgICAgICA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMCkgLy9DcmVhdGUgc2VtaS11bmlxdWUgSUQgaW5jYXNlIHVzZXIgZG9lc24ndCBzZWxlY3Qgb25lXG4gICAgICAgICwgeCAgICAgICAgICAgID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCB5ICAgICAgICAgICAgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIHogICAgICAgICAgICA9IGQzLnNjYWxlLmxpbmVhcigpIC8vbGluZWFyIGJlY2F1c2UgZDMuc3ZnLnNoYXBlLnNpemUgaXMgdHJlYXRlZCBhcyBhcmVhXG4gICAgICAgICwgZ2V0WCAgICAgICAgID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0gLy8gYWNjZXNzb3IgdG8gZ2V0IHRoZSB4IHZhbHVlXG4gICAgICAgICwgZ2V0WSAgICAgICAgID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH0gLy8gYWNjZXNzb3IgdG8gZ2V0IHRoZSB5IHZhbHVlXG4gICAgICAgICwgZ2V0U2l6ZSAgICAgID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zaXplIHx8IDF9IC8vIGFjY2Vzc29yIHRvIGdldCB0aGUgcG9pbnQgc2l6ZVxuICAgICAgICAsIGdldFNoYXBlICAgICA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc2hhcGUgfHwgJ2NpcmNsZScgfSAvLyBhY2Nlc3NvciB0byBnZXQgcG9pbnQgc2hhcGVcbiAgICAgICAgLCBmb3JjZVggICAgICAgPSBbXSAvLyBMaXN0IG9mIG51bWJlcnMgdG8gRm9yY2UgaW50byB0aGUgWCBzY2FsZSAoaWUuIDAsIG9yIGEgbWF4IC8gbWluLCBldGMuKVxuICAgICAgICAsIGZvcmNlWSAgICAgICA9IFtdIC8vIExpc3Qgb2YgbnVtYmVycyB0byBGb3JjZSBpbnRvIHRoZSBZIHNjYWxlXG4gICAgICAgICwgZm9yY2VTaXplICAgID0gW10gLy8gTGlzdCBvZiBudW1iZXJzIHRvIEZvcmNlIGludG8gdGhlIFNpemUgc2NhbGVcbiAgICAgICAgLCBpbnRlcmFjdGl2ZSAgPSB0cnVlIC8vIElmIHRydWUsIHBsb3RzIGEgdm9yb25vaSBvdmVybGF5IGZvciBhZHZhbmNlZCBwb2ludCBpbnRlcnNlY3Rpb25cbiAgICAgICAgLCBwb2ludEFjdGl2ZSAgPSBmdW5jdGlvbihkKSB7IHJldHVybiAhZC5ub3RBY3RpdmUgfSAvLyBhbnkgcG9pbnRzIHRoYXQgcmV0dXJuIGZhbHNlIHdpbGwgYmUgZmlsdGVyZWQgb3V0XG4gICAgICAgICwgcGFkRGF0YSAgICAgID0gZmFsc2UgLy8gSWYgdHJ1ZSwgYWRkcyBoYWxmIGEgZGF0YSBwb2ludHMgd2lkdGggdG8gZnJvbnQgYW5kIGJhY2ssIGZvciBsaW5pbmcgdXAgYSBsaW5lIGNoYXJ0IHdpdGggYSBiYXIgY2hhcnRcbiAgICAgICAgLCBwYWREYXRhT3V0ZXIgPSAuMSAvL291dGVyUGFkZGluZyB0byBpbWl0YXRlIG9yZGluYWwgc2NhbGUgb3V0ZXIgcGFkZGluZ1xuICAgICAgICAsIGNsaXBFZGdlICAgICA9IGZhbHNlIC8vIGlmIHRydWUsIG1hc2tzIHBvaW50cyB3aXRoaW4geCBhbmQgeSBzY2FsZVxuICAgICAgICAsIGNsaXBWb3Jvbm9pICA9IHRydWUgLy8gaWYgdHJ1ZSwgbWFza3MgZWFjaCBwb2ludCB3aXRoIGEgY2lyY2xlLi4uIGNhbiB0dXJuIG9mZiB0byBzbGlnaHRseSBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAgICAgICAsIGNsaXBSYWRpdXMgICA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMjUgfSAvLyBmdW5jdGlvbiB0byBnZXQgdGhlIHJhZGl1cyBmb3Igdm9yb25vaSBwb2ludCBjbGlwc1xuICAgICAgICAsIHhEb21haW4gICAgICA9IG51bGwgLy8gT3ZlcnJpZGUgeCBkb21haW4gKHNraXBzIHRoZSBjYWxjdWxhdGlvbiBmcm9tIGRhdGEpXG4gICAgICAgICwgeURvbWFpbiAgICAgID0gbnVsbCAvLyBPdmVycmlkZSB5IGRvbWFpblxuICAgICAgICAsIHhSYW5nZSAgICAgICA9IG51bGwgLy8gT3ZlcnJpZGUgeCByYW5nZVxuICAgICAgICAsIHlSYW5nZSAgICAgICA9IG51bGwgLy8gT3ZlcnJpZGUgeSByYW5nZVxuICAgICAgICAsIHNpemVEb21haW4gICA9IG51bGwgLy8gT3ZlcnJpZGUgcG9pbnQgc2l6ZSBkb21haW5cbiAgICAgICAgLCBzaXplUmFuZ2UgICAgPSBudWxsXG4gICAgICAgICwgc2luZ2xlUG9pbnQgID0gZmFsc2VcbiAgICAgICAgLCBkaXNwYXRjaCAgICAgPSBkMy5kaXNwYXRjaCgnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxDbGljaycsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcsICdyZW5kZXJFbmQnKVxuICAgICAgICAsIHVzZVZvcm9ub2kgICA9IHRydWVcbiAgICAgICAgLCBkdXJhdGlvbiAgICAgPSAyNTBcbiAgICAgICAgO1xuXG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciB4MCwgeTAsIHowIC8vIHVzZWQgdG8gc3RvcmUgcHJldmlvdXMgc2NhbGVzXG4gICAgICAgICwgdGltZW91dElEXG4gICAgICAgICwgbmVlZHNVcGRhdGUgPSBmYWxzZSAvLyBGbGFnIGZvciB3aGVuIHRoZSBwb2ludHMgYXJlIHZpc3VhbGx5IHVwZGF0aW5nLCBidXQgdGhlIGludGVyYWN0aXZlIGxheWVyIGlzIGJlaGluZCwgdG8gZGlzYWJsZSB0b29sdGlwc1xuICAgICAgICAsIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKVxuICAgICAgICA7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vYWRkIHNlcmllcyBpbmRleCB0byBlYWNoIGRhdGEgcG9pbnQgZm9yIHJlZmVyZW5jZVxuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgIHNlcmllcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5zZXJpZXMgPSBpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgLy8gcmVtYXAgYW5kIGZsYXR0ZW4gdGhlIGRhdGEgZm9yIHVzZSBpbiBjYWxjdWxhdGluZyB0aGUgc2NhbGVzJyBkb21haW5zXG4gICAgICAgICAgICB2YXIgc2VyaWVzRGF0YSA9ICh4RG9tYWluICYmIHlEb21haW4gJiYgc2l6ZURvbWFpbikgPyBbXSA6IC8vIGlmIHdlIGtub3cgeERvbWFpbiBhbmQgeURvbWFpbiBhbmQgc2l6ZURvbWFpbiwgbm8gbmVlZCB0byBjYWxjdWxhdGUuLi4uIGlmIFNpemUgaXMgY29uc3RhbnQgcmVtZW1iZXIgdG8gc2V0IHNpemVEb21haW4gdG8gc3BlZWQgdXAgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgICBkMy5tZXJnZShcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQudmFsdWVzLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBnZXRYKGQsaSksIHk6IGdldFkoZCxpKSwgc2l6ZTogZ2V0U2l6ZShkLGkpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgeCAgIC5kb21haW4oeERvbWFpbiB8fCBkMy5leHRlbnQoc2VyaWVzRGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54OyB9KS5jb25jYXQoZm9yY2VYKSkpXG5cbiAgICAgICAgICAgIGlmIChwYWREYXRhICYmIGRhdGFbMF0pXG4gICAgICAgICAgICAgICAgeC5yYW5nZSh4UmFuZ2UgfHwgWyhhdmFpbGFibGVXaWR0aCAqIHBhZERhdGFPdXRlciArICBhdmFpbGFibGVXaWR0aCkgLyAoMiAqZGF0YVswXS52YWx1ZXMubGVuZ3RoKSwgYXZhaWxhYmxlV2lkdGggLSBhdmFpbGFibGVXaWR0aCAqICgxICsgcGFkRGF0YU91dGVyKSAvICgyICogZGF0YVswXS52YWx1ZXMubGVuZ3RoKSAgXSk7XG4gICAgICAgICAgICAvL3gucmFuZ2UoW2F2YWlsYWJsZVdpZHRoICogLjUgLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGgsIGF2YWlsYWJsZVdpZHRoICogKGRhdGFbMF0udmFsdWVzLmxlbmd0aCAtIC41KSAgLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGggXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgeC5yYW5nZSh4UmFuZ2UgfHwgWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgICAgICAgIHkgICAuZG9tYWluKHlEb21haW4gfHwgZDMuZXh0ZW50KHNlcmllc0RhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9KS5jb25jYXQoZm9yY2VZKSkpXG4gICAgICAgICAgICAgICAgLnJhbmdlKHlSYW5nZSB8fCBbYXZhaWxhYmxlSGVpZ2h0LCAwXSk7XG5cbiAgICAgICAgICAgIHogICAuZG9tYWluKHNpemVEb21haW4gfHwgZDMuZXh0ZW50KHNlcmllc0RhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc2l6ZSB9KS5jb25jYXQoZm9yY2VTaXplKSkpXG4gICAgICAgICAgICAgICAgLnJhbmdlKHNpemVSYW5nZSB8fCBbMTYsIDI1Nl0pO1xuXG4gICAgICAgICAgICAvLyBJZiBzY2FsZSdzIGRvbWFpbiBkb24ndCBoYXZlIGEgcmFuZ2UsIHNsaWdodGx5IGFkanVzdCB0byBtYWtlIG9uZS4uLiBzbyBhIGNoYXJ0IGNhbiBzaG93IGEgc2luZ2xlIGRhdGEgcG9pbnRcbiAgICAgICAgICAgIGlmICh4LmRvbWFpbigpWzBdID09PSB4LmRvbWFpbigpWzFdIHx8IHkuZG9tYWluKClbMF0gPT09IHkuZG9tYWluKClbMV0pIHNpbmdsZVBvaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh4LmRvbWFpbigpWzBdID09PSB4LmRvbWFpbigpWzFdKVxuICAgICAgICAgICAgICAgIHguZG9tYWluKClbMF0gP1xuICAgICAgICAgICAgICAgICAgICB4LmRvbWFpbihbeC5kb21haW4oKVswXSAtIHguZG9tYWluKClbMF0gKiAwLjAxLCB4LmRvbWFpbigpWzFdICsgeC5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgICAgICAgICAgICA6IHguZG9tYWluKFstMSwxXSk7XG5cbiAgICAgICAgICAgIGlmICh5LmRvbWFpbigpWzBdID09PSB5LmRvbWFpbigpWzFdKVxuICAgICAgICAgICAgICAgIHkuZG9tYWluKClbMF0gP1xuICAgICAgICAgICAgICAgICAgICB5LmRvbWFpbihbeS5kb21haW4oKVswXSAtIHkuZG9tYWluKClbMF0gKiAwLjAxLCB5LmRvbWFpbigpWzFdICsgeS5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgICAgICAgICAgICA6IHkuZG9tYWluKFstMSwxXSk7XG5cbiAgICAgICAgICAgIGlmICggaXNOYU4oeC5kb21haW4oKVswXSkpIHtcbiAgICAgICAgICAgICAgICB4LmRvbWFpbihbLTEsMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGlzTmFOKHkuZG9tYWluKClbMF0pKSB7XG4gICAgICAgICAgICAgICAgeS5kb21haW4oWy0xLDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeDAgPSB4MCB8fCB4O1xuICAgICAgICAgICAgeTAgPSB5MCB8fCB5O1xuICAgICAgICAgICAgejAgPSB6MCB8fCB6O1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtc2NhdHRlcicpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LXNjYXR0ZXIgbnYtY2hhcnQtJyArIGlkICsgKHNpbmdsZVBvaW50ID8gJyBudi1zaW5nbGUtcG9pbnQnIDogJycpKTtcbiAgICAgICAgICAgIHZhciBkZWZzRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZ3JvdXBzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcG9pbnQtcGF0aHMnKTtcblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICBkZWZzRW50ZXIuYXBwZW5kKCdjbGlwUGF0aCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ252LWVkZ2UtY2xpcC0nICsgaWQpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpO1xuXG4gICAgICAgICAgICB3cmFwLnNlbGVjdCgnI252LWVkZ2UtY2xpcC0nICsgaWQgKyAnIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAoYXZhaWxhYmxlSGVpZ2h0ID4gMCkgPyBhdmFpbGFibGVIZWlnaHQgOiAwKTtcblxuICAgICAgICAgICAgZy5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwRWRnZSA/ICd1cmwoI252LWVkZ2UtY2xpcC0nICsgaWQgKyAnKScgOiAnJyk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUludGVyYWN0aXZlTGF5ZXIoKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWludGVyYWN0aXZlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRFbGVtZW50cztcblxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGQzLm1lcmdlKGRhdGEubWFwKGZ1bmN0aW9uKGdyb3VwLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXAudmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwb2ludCwgcG9pbnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAqQWRkaW5nIG5vaXNlIHRvIG1ha2UgZHVwbGljYXRlcyB2ZXJ5IHVubGlrZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICpJbmplY3Rpbmcgc2VyaWVzIGFuZCBwb2ludCBpbmRleCBmb3IgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICpBZGRpbmcgYSAnaml0dGVyJyB0byB0aGUgcG9pbnRzLCBiZWNhdXNlIHRoZXJlJ3MgYW4gaXNzdWUgaW4gZDMuZ2VvbS52b3Jvbm9pLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBYID0gZ2V0WChwb2ludCxwb2ludEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBZID0gZ2V0WShwb2ludCxwb2ludEluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3gocFgpKyBNYXRoLnJhbmRvbSgpICogMWUtNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KHBZKSsgTWF0aC5yYW5kb20oKSAqIDFlLTcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleCwgcG9pbnRdOyAvL3RlbXAgaGFjayB0byBhZGQgbm9pc2UgdW50aWxsIEkgdGhpbmsgb2YgYSBiZXR0ZXIgd2F5IHNvIHRoZXJlIGFyZSBubyBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHBvaW50QXJyYXksIHBvaW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50QWN0aXZlKHBvaW50QXJyYXlbNF0sIHBvaW50SW5kZXgpOyAvLyBJc3N1ZSAjMjM3Li4gbW92ZSBmaWx0ZXIgdG8gYWZ0ZXIgbWFwLCBzbyBwb2ludEluZGV4IGlzIGNvcnJlY3QhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy9pbmplY3Qgc2VyaWVzIGFuZCBwb2ludCBpbmRleCBmb3IgcmVmZXJlbmNlIGludG8gdm9yb25vaVxuICAgICAgICAgICAgICAgIGlmICh1c2VWb3Jvbm9pID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYodmVydGljZXMubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXNzdWUgIzI4MyAtIEFkZGluZyAyIGR1bW15IHBvaW50cyB0byB0aGUgdm9yb25vaSBiL2Mgdm9yb25vaSByZXF1aXJlcyBtaW4gMyBwb2ludHMgdG8gd29ya1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXMucHVzaChbeC5yYW5nZSgpWzBdIC0gMjAsIHkucmFuZ2UoKVswXSAtIDIwLCBudWxsLCBudWxsXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt4LnJhbmdlKClbMV0gKyAyMCwgeS5yYW5nZSgpWzFdICsgMjAsIG51bGwsIG51bGxdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goW3gucmFuZ2UoKVswXSAtIDIwLCB5LnJhbmdlKClbMF0gKyAyMCwgbnVsbCwgbnVsbF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXMucHVzaChbeC5yYW5nZSgpWzFdICsgMjAsIHkucmFuZ2UoKVsxXSAtIDIwLCBudWxsLCBudWxsXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIHZvcm9ub2kgc2VjdGlvbnMgZnJvbSBnb2luZyBtb3JlIHRoYW4gMTAgb3V0c2lkZSBvZiBncmFwaFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBvdmVybGFwIHdpdGggb3RoZXIgdGhpbmdzIGxpa2UgbGVnZW5kIGV0Y1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRzID0gZDMuZ2VvbS5wb2x5Z29uKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFstMTAsLTEwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFstMTAsaGVpZ2h0ICsgMTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3dpZHRoICsgMTAsaGVpZ2h0ICsgMTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3dpZHRoICsgMTAsLTEwXVxuICAgICAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdm9yb25vaSA9IGQzLmdlb20udm9yb25vaSh2ZXJ0aWNlcykubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiBib3VuZHMuY2xpcChkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2VyaWVzJzogdmVydGljZXNbaV1bMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BvaW50JzogdmVydGljZXNbaV1bM11cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbnVrZSBhbGwgdm9yb25vaSBwYXRocyBvbiByZWxvYWQgYW5kIHJlY3JlYXRlIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1wb2ludC1wYXRocycpLnNlbGVjdEFsbCgncGF0aCcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRQYXRocyA9IHdyYXAuc2VsZWN0KCcubnYtcG9pbnQtcGF0aHMnKS5zZWxlY3RBbGwoJ3BhdGgnKS5kYXRhKHZvcm9ub2kpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludFBhdGhzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJzdmc6cGF0aFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWQgfHwgIWQuZGF0YSB8fCBkLmRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ00gMCAwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk1cIiArIGQuZGF0YS5qb2luKFwiLFwiKSArIFwiWlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibnYtcGF0aC1cIitpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGlwLXBhdGhcIiwgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBcInVybCgjbnYtY2xpcC1cIitpK1wiKVwiOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhaW4gdGhlc2UgdG8gYWJvdmUgdG8gc2VlIHRoZSB2b3Jvbm9pIGVsZW1lbnRzIChnb29kIGZvciBkZWJ1Z2dpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy5zdHlsZShcImZpbGxcIiwgZDMucmdiKDIzMCwgMjMwLCAyMzApKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8uc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDAuNClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy5zdHlsZShcInN0cm9rZVwiLCBkMy5yZ2IoMjAwLDIwMCwyMDApKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcFZvcm9ub2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZvcm9ub2kgc2VjdGlvbnMgYXJlIGFscmVhZHkgc2V0IHRvIGNsaXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGNyZWF0ZSB0aGUgY2lyY2xlcyB3aXRoIHRoZSBJRHMgdGhleSBleHBlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGlwcyA9IHdyYXAuYXBwZW5kKFwic3ZnOmdcIikuYXR0cihcImlkXCIsIFwibnYtcG9pbnQtY2xpcHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwcy5zZWxlY3RBbGwoXCJjbGlwUGF0aFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKHZlcnRpY2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lbnRlcigpLmFwcGVuZChcInN2ZzpjbGlwUGF0aFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gXCJudi1jbGlwLVwiK2k7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwic3ZnOmNpcmNsZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMF07IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZFsxXTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncicsIGNsaXBSYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uKGQsbURpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllcyA9IGRhdGFbZC5zZXJpZXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJpZXMgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgID0gc2VyaWVzLnZhbHVlc1tkLnBvaW50XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbURpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKHBvaW50LCBkLnBvaW50KSkgKyBtYXJnaW4ubGVmdCwgeShnZXRZKHBvaW50LCBkLnBvaW50KSkgKyBtYXJnaW4udG9wXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogZC5wb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRQYXRoc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZUV2ZW50Q2FsbGJhY2soZCwgZGlzcGF0Y2guZWxlbWVudENsaWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRXZlbnRDYWxsYmFjayhkLCBkaXNwYXRjaC5lbGVtZW50RGJsQ2xpY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRXZlbnRDYWxsYmFjayhkLCBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRXZlbnRDYWxsYmFjayhkLCBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgLy8gYnJpbmcgZGF0YSBpbiBmb3JtIG5lZWRlZCBmb3IgY2xpY2sgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhV2l0aFBvaW50cyA9IHZlcnRpY2VzLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiBkLFxuICAgICAgICAgICAgICAgICAgICAgJ3Nlcmllcyc6IHZlcnRpY2VzW2ldWzJdLFxuICAgICAgICAgICAgICAgICAgICAgJ3BvaW50JzogdmVydGljZXNbaV1bM11cbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgZXZlbnQgaGFuZGxlcnMgdG8gcG9pbnRzIGluc3RlYWQgdm9yb25vaSBwYXRoc1xuICAgICAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LWdyb3VwcycpLnNlbGVjdEFsbCgnLm52LWdyb3VwJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5udi1wb2ludCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy5kYXRhKGRhdGFXaXRoUG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8uc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ2F1dG8nKSAvLyByZWNhdGl2YXRlIGV2ZW50cywgZGlzYWJsZWQgYnkgY3NzXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udi5sb2coJ3Rlc3QnLCBkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUgfHwgIWRhdGFbZC5zZXJpZXNdKSByZXR1cm4gMDsgLy9jaGVjayBpZiB0aGlzIGlzIGEgZHVtbXkgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWVzID0gZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ICA9IHNlcmllcy52YWx1ZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50Q2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgocG9pbnQsIGkpKSArIG1hcmdpbi5sZWZ0LCB5KGdldFkocG9pbnQsIGkpKSArIG1hcmdpbi50b3BdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkc1VwZGF0ZSB8fCAhZGF0YVtkLnNlcmllc10pIHJldHVybiAwOyAvL2NoZWNrIGlmIHRoaXMgaXMgYSBkdW1teSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSBkYXRhW2Quc2VyaWVzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgID0gc2VyaWVzLnZhbHVlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgocG9pbnQsIGkpKSArIG1hcmdpbi5sZWZ0LCB5KGdldFkocG9pbnQsIGkpKSArIG1hcmdpbi50b3BdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzVXBkYXRlIHx8ICFkYXRhW2Quc2VyaWVzXSkgcmV0dXJuIDA7IC8vY2hlY2sgaWYgdGhpcyBpcyBhIGR1bW15IHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllcyA9IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCAgPSBzZXJpZXMudmFsdWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgZ3JvdXBzID0gd3JhcC5zZWxlY3QoJy5udi1ncm91cHMnKS5zZWxlY3RBbGwoJy5udi1ncm91cCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9LCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmtleSB9KTtcbiAgICAgICAgICAgIGdyb3Vwcy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KTtcbiAgICAgICAgICAgIGdyb3Vwcy5leGl0KClcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICBncm91cHNcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICdudi1ncm91cCBudi1zZXJpZXMtJyArIGkgfSlcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaG92ZXInLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmhvdmVyIH0pO1xuICAgICAgICAgICAgZ3JvdXBzLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ3NjYXR0ZXI6IGdyb3VwcycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvcihkLCBpKSB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvcihkLCBpKSB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgLjUpO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHBvaW50c1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IGdyb3Vwcy5zZWxlY3RBbGwoJ3BhdGgubnYtcG9pbnQnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzIH0pO1xuICAgICAgICAgICAgcG9pbnRzLmVudGVyKCkuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoZCxpKSB7IHJldHVybiBkLmNvbG9yIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbiAoZCxpKSB7IHJldHVybiBkLmNvbG9yIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeDAoZ2V0WChkLGkpKSArICcsJyArIHkwKGdldFkoZCxpKSkgKyAnKSdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJyxcbiAgICAgICAgICAgICAgICAgICAgbnYudXRpbHMuc3ltYm9sKClcbiAgICAgICAgICAgICAgICAgICAgLnR5cGUoZ2V0U2hhcGUpXG4gICAgICAgICAgICAgICAgICAgIC5zaXplKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geihnZXRTaXplKGQsaSkpIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcG9pbnRzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGdyb3Vwcy5leGl0KCkuc2VsZWN0QWxsKCdwYXRoLm52LXBvaW50JylcbiAgICAgICAgICAgICAgICAud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnc2NhdHRlciBleGl0JylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4KGdldFgoZCxpKSkgKyAnLCcgKyB5KGdldFkoZCxpKSkgKyAnKSdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHBvaW50cy5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnbnYtcG9pbnQnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnbnYtcG9pbnQtJyArIGksIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdob3ZlcicsZmFsc2UpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb2ludHNcbiAgICAgICAgICAgICAgICAud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnc2NhdHRlciBwb2ludHMnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9udi5sb2coZCxpLGdldFgoZCxpKSwgeChnZXRYKGQsaSkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoZ2V0WChkLGkpKSArICcsJyArIHkoZ2V0WShkLGkpKSArICcpJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLFxuICAgICAgICAgICAgICAgICAgICBudi51dGlscy5zeW1ib2woKVxuICAgICAgICAgICAgICAgICAgICAudHlwZShnZXRTaGFwZSlcbiAgICAgICAgICAgICAgICAgICAgLnNpemUoZnVuY3Rpb24oZCxpKSB7IHJldHVybiB6KGdldFNpemUoZCxpKSkgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIERlbGF5IHVwZGF0aW5nIHRoZSBpbnZpc2libGUgaW50ZXJhY3RpdmUgbGF5ZXIgZm9yIHNtb290aGVyIGFuaW1hdGlvblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7IC8vIHN0b3AgcmVwZWF0IGNhbGxzIHRvIHVwZGF0ZUludGVyYWN0aXZlTGF5ZXJcbiAgICAgICAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQodXBkYXRlSW50ZXJhY3RpdmVMYXllciwgMzAwKTtcbiAgICAgICAgICAgIC8vdXBkYXRlSW50ZXJhY3RpdmVMYXllcigpO1xuXG4gICAgICAgICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgICAgICAgIHgwID0geC5jb3B5KCk7XG4gICAgICAgICAgICB5MCA9IHkuY29weSgpO1xuICAgICAgICAgICAgejAgPSB6LmNvcHkoKTtcblxuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdzY2F0dGVyIGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIC8vIHV0aWxpdHkgZnVuY3Rpb24gY2FsbHMgcHJvdmlkZWQgYnkgdGhpcyBjaGFydFxuICAgIGNoYXJ0Ll9jYWxscyA9IG5ldyBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGVhckhpZ2hsaWdodHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoXCIubnYtY2hhcnQtXCIgKyBpZCArIFwiIC5udi1wb2ludC5ob3ZlclwiKS5jbGFzc2VkKFwiaG92ZXJcIiwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0UG9pbnQgPSBmdW5jdGlvbiAoc2VyaWVzSW5kZXgsIHBvaW50SW5kZXgsIGlzSG92ZXJPdmVyKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIubnYtY2hhcnQtXCIgKyBpZCArIFwiIC5udi1zZXJpZXMtXCIgKyBzZXJpZXNJbmRleCArIFwiIC5udi1wb2ludC1cIiArIHBvaW50SW5kZXgpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoXCJob3ZlclwiLCBpc0hvdmVyT3Zlcik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIHRyaWdnZXIgY2FsbHMgZnJvbSBldmVudHMgdG9vXG4gICAgZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIucG9pbnQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIGlmIChpbnRlcmFjdGl2ZSkgY2hhcnQuX2NhbGxzLmhpZ2hsaWdodFBvaW50KGQuc2VyaWVzSW5kZXgsZC5wb2ludEluZGV4LHRydWUpO1xuICAgIH0pO1xuXG4gICAgZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC5wb2ludCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgaWYgKGludGVyYWN0aXZlKSBjaGFydC5fY2FsbHMuaGlnaGxpZ2h0UG9pbnQoZC5zZXJpZXNJbmRleCxkLnBvaW50SW5kZXgsZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHhTY2FsZTogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3g9Xzt9fSxcbiAgICAgICAgeVNjYWxlOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5O30sIHNldDogZnVuY3Rpb24oXyl7eT1fO319LFxuICAgICAgICBwb2ludFNjYWxlOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHo7fSwgc2V0OiBmdW5jdGlvbihfKXt6PV87fX0sXG4gICAgICAgIHhEb21haW46ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geERvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hEb21haW49Xzt9fSxcbiAgICAgICAgeURvbWFpbjogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eURvbWFpbj1fO319LFxuICAgICAgICBwb2ludERvbWFpbjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNpemVEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXtzaXplRG9tYWluPV87fX0sXG4gICAgICAgIHhSYW5nZTogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geFJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eFJhbmdlPV87fX0sXG4gICAgICAgIHlSYW5nZTogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geVJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eVJhbmdlPV87fX0sXG4gICAgICAgIHBvaW50UmFuZ2U6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2l6ZVJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7c2l6ZVJhbmdlPV87fX0sXG4gICAgICAgIGZvcmNlWDogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9yY2VYO30sIHNldDogZnVuY3Rpb24oXyl7Zm9yY2VYPV87fX0sXG4gICAgICAgIGZvcmNlWTogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9yY2VZO30sIHNldDogZnVuY3Rpb24oXyl7Zm9yY2VZPV87fX0sXG4gICAgICAgIGZvcmNlUG9pbnQ6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9yY2VTaXplO30sIHNldDogZnVuY3Rpb24oXyl7Zm9yY2VTaXplPV87fX0sXG4gICAgICAgIGludGVyYWN0aXZlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaW50ZXJhY3RpdmU7fSwgc2V0OiBmdW5jdGlvbihfKXtpbnRlcmFjdGl2ZT1fO319LFxuICAgICAgICBwb2ludEFjdGl2ZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHBvaW50QWN0aXZlO30sIHNldDogZnVuY3Rpb24oXyl7cG9pbnRBY3RpdmU9Xzt9fSxcbiAgICAgICAgcGFkRGF0YU91dGVyOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBwYWREYXRhT3V0ZXI7fSwgc2V0OiBmdW5jdGlvbihfKXtwYWREYXRhT3V0ZXI9Xzt9fSxcbiAgICAgICAgcGFkRGF0YTogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBwYWREYXRhO30sIHNldDogZnVuY3Rpb24oXyl7cGFkRGF0YT1fO319LFxuICAgICAgICBjbGlwRWRnZTogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNsaXBFZGdlO30sIHNldDogZnVuY3Rpb24oXyl7Y2xpcEVkZ2U9Xzt9fSxcbiAgICAgICAgY2xpcFZvcm9ub2k6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjbGlwVm9yb25vaTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2NsaXBWb3Jvbm9pPV87fX0sXG4gICAgICAgIGNsaXBSYWRpdXM6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY2xpcFJhZGl1czt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2NsaXBSYWRpdXM9Xzt9fSxcbiAgICAgICAgaWQ6ICAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2lkPV87fX0sXG5cblxuICAgICAgICAvLyBzaW1wbGUgZnVuY3RvciBvcHRpb25zXG4gICAgICAgIHg6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WCA9IGQzLmZ1bmN0b3IoXyk7fX0sXG4gICAgICAgIHk6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WSA9IGQzLmZ1bmN0b3IoXyk7fX0sXG4gICAgICAgIHBvaW50U2l6ZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0U2l6ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFNpemUgPSBkMy5mdW5jdG9yKF8pO319LFxuICAgICAgICBwb2ludFNoYXBlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRTaGFwZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFNoYXBlID0gZDMuZnVuY3RvcihfKTt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgdXNlVm9yb25vaToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdXNlVm9yb25vaTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgdXNlVm9yb25vaSA9IF87XG4gICAgICAgICAgICBpZiAodXNlVm9yb25vaSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjbGlwVm9yb25vaSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5zY2F0dGVyQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHNjYXR0ZXIgICAgICA9IG52Lm1vZGVscy5zY2F0dGVyKClcbiAgICAgICAgLCB4QXhpcyAgICAgICAgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeUF4aXMgICAgICAgID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIGxlZ2VuZCAgICAgICA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICAgICAsIGRpc3RYICAgICAgICA9IG52Lm1vZGVscy5kaXN0cmlidXRpb24oKVxuICAgICAgICAsIGRpc3RZICAgICAgICA9IG52Lm1vZGVscy5kaXN0cmlidXRpb24oKVxuICAgICAgICA7XG5cbiAgICB2YXIgbWFyZ2luICAgICAgID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiA1MCwgbGVmdDogNzV9XG4gICAgICAgICwgd2lkdGggICAgICAgID0gbnVsbFxuICAgICAgICAsIGhlaWdodCAgICAgICA9IG51bGxcbiAgICAgICAgLCBjb2xvciAgICAgICAgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHggICAgICAgICAgICA9IHNjYXR0ZXIueFNjYWxlKClcbiAgICAgICAgLCB5ICAgICAgICAgICAgPSBzY2F0dGVyLnlTY2FsZSgpXG4gICAgICAgICwgc2hvd0Rpc3RYICAgID0gZmFsc2VcbiAgICAgICAgLCBzaG93RGlzdFkgICAgPSBmYWxzZVxuICAgICAgICAsIHNob3dMZWdlbmQgICA9IHRydWVcbiAgICAgICAgLCBzaG93WEF4aXMgICAgPSB0cnVlXG4gICAgICAgICwgc2hvd1lBeGlzICAgID0gdHJ1ZVxuICAgICAgICAsIHJpZ2h0QWxpZ25ZQXhpcyA9IGZhbHNlXG4gICAgICAgICwgdG9vbHRpcHMgICAgID0gdHJ1ZVxuICAgICAgICAsIHRvb2x0aXBYICAgICA9IGZ1bmN0aW9uKGtleSwgeCwgeSkgeyByZXR1cm4gJzxzdHJvbmc+JyArIHggKyAnPC9zdHJvbmc+JyB9XG4gICAgICAgICwgdG9vbHRpcFkgICAgID0gZnVuY3Rpb24oa2V5LCB4LCB5KSB7IHJldHVybiAnPHN0cm9uZz4nICsgeSArICc8L3N0cm9uZz4nIH1cbiAgICAgICAgLCB0b29sdGlwICAgICAgPSBmdW5jdGlvbihrZXksIHgsIHksIGRhdGUpIHsgcmV0dXJuICc8aDM+JyArIGtleSArICc8L2gzPidcbiAgICAgICAgICAgICsgJzxwPicgKyBkYXRlICsgJzwvcD4nIH1cbiAgICAgICAgLCBzdGF0ZSA9IG52LnV0aWxzLnN0YXRlKClcbiAgICAgICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnLCAncmVuZGVyRW5kJylcbiAgICAgICAgLCBub0RhdGEgICAgICAgPSBcIk5vIERhdGEgQXZhaWxhYmxlLlwiXG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgO1xuXG4gICAgc2NhdHRlclxuICAgICAgICAueFNjYWxlKHgpXG4gICAgICAgIC55U2NhbGUoeSlcbiAgICA7XG4gICAgeEF4aXNcbiAgICAgICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAgICAgLnRpY2tQYWRkaW5nKDEwKVxuICAgIDtcbiAgICB5QXhpc1xuICAgICAgICAub3JpZW50KChyaWdodEFsaWduWUF4aXMpID8gJ3JpZ2h0JyA6ICdsZWZ0JylcbiAgICAgICAgLnRpY2tQYWRkaW5nKDEwKVxuICAgIDtcbiAgICBkaXN0WFxuICAgICAgICAuYXhpcygneCcpXG4gICAgO1xuICAgIGRpc3RZXG4gICAgICAgIC5heGlzKCd5JylcbiAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciB4MCwgeTBcbiAgICAgICAgLCByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCBkdXJhdGlvbik7XG5cbiAgICB2YXIgc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbihlLCBvZmZzZXRFbGVtZW50KSB7XG4gICAgICAgIC8vVE9ETzogbWFrZSB0b29sdGlwIHN0eWxlIGFuIG9wdGlvbiBiZXR3ZWVuIHNpbmdsZSBvciBkdWFsIG9uIGF4ZXMgKG1heWJlIG9uIGFsbCBjaGFydHMgd2l0aCBheGVzP1xuICAgICAgICB2YXIgbGVmdCA9IGUucG9zWzBdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldExlZnQgfHwgMCApLFxuICAgICAgICAgICAgdG9wID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICAgICAgbGVmdFggPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgICAgIHRvcFggPSB5LnJhbmdlKClbMF0gKyBtYXJnaW4udG9wICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgICAgIGxlZnRZID0geC5yYW5nZSgpWzBdICsgbWFyZ2luLmxlZnQgKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwICksXG4gICAgICAgICAgICB0b3BZID0gZS5wb3NbMV0gKyAoIG9mZnNldEVsZW1lbnQub2Zmc2V0VG9wIHx8IDApLFxuICAgICAgICAgICAgeFZhbCA9IHhBeGlzLnRpY2tGb3JtYXQoKShzY2F0dGVyLngoKShlLnBvaW50LCBlLnBvaW50SW5kZXgpKSxcbiAgICAgICAgICAgIHlWYWwgPSB5QXhpcy50aWNrRm9ybWF0KCkoc2NhdHRlci55KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSk7XG5cbiAgICAgICAgaWYoIHRvb2x0aXBYICE9IG51bGwgKVxuICAgICAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0WCwgdG9wWF0sIHRvb2x0aXBYKGUuc2VyaWVzLmtleSwgeFZhbCwgeVZhbCwgZSwgY2hhcnQpLCAnbicsIDEsIG9mZnNldEVsZW1lbnQsICd4LW52dG9vbHRpcCcpO1xuICAgICAgICBpZiggdG9vbHRpcFkgIT0gbnVsbCApXG4gICAgICAgICAgICBudi50b29sdGlwLnNob3coW2xlZnRZLCB0b3BZXSwgdG9vbHRpcFkoZS5zZXJpZXMua2V5LCB4VmFsLCB5VmFsLCBlLCBjaGFydCksICdlJywgMSwgb2Zmc2V0RWxlbWVudCwgJ3ktbnZ0b29sdGlwJyk7XG4gICAgICAgIGlmKCB0b29sdGlwICE9IG51bGwgKVxuICAgICAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCB0b29sdGlwKGUuc2VyaWVzLmtleSwgeFZhbCwgeVZhbCwgZS5wb2ludC50b29sdGlwLCBlLCBjaGFydCksIGUudmFsdWUgPCAwID8gJ24nIDogJ3MnLCBudWxsLCBvZmZzZXRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3RhdGVTZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSAhc3RhdGUuYWN0aXZlW2ldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMoc2NhdHRlcik7XG4gICAgICAgIGlmIChzaG93WEF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh4QXhpcyk7XG4gICAgICAgIGlmIChzaG93WUF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh5QXhpcyk7XG4gICAgICAgIGlmIChzaG93RGlzdFgpIHJlbmRlcldhdGNoLm1vZGVscyhkaXN0WCk7XG4gICAgICAgIGlmIChzaG93RGlzdFkpIHJlbmRlcldhdGNoLm1vZGVscyhkaXN0WSk7XG5cbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuY2FsbChjaGFydCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKGNoYXJ0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICAgIC5zZXR0ZXIoc3RhdGVTZXR0ZXIoZGF0YSksIGNoYXJ0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAuZ2V0dGVyKHN0YXRlR2V0dGVyKGRhdGEpKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoKTtcblxuICAgICAgICAgICAgLy8gREVQUkVDQVRFRCBzZXQgc3RhdGUuZGlzYWJsZWRkaXNhYmxlZFxuICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG5cbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IG5vRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ3NjYXR0ZXIgaW1tZWRpYXRlJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gc2NhdHRlci54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBzY2F0dGVyLnlTY2FsZSgpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtc2NhdHRlckNoYXJ0JykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtc2NhdHRlckNoYXJ0IG52LWNoYXJ0LScgKyBzY2F0dGVyLmlkKCkpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgLy8gYmFja2dyb3VuZCBmb3IgcG9pbnRlciBldmVudHNcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ3JlY3QnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LWJhY2tncm91bmQnKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtc2NhdHRlcldyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1yZWdyZXNzaW9uTGluZXNXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZGlzdFdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgaWYgKHJpZ2h0QWxpZ25ZQXhpcykge1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KFwiLm52LXkubnYtYXhpc1wiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGF2YWlsYWJsZVdpZHRoICsgXCIsMClcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgaWYgKHNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBsZWdlbmQud2lkdGgoIGF2YWlsYWJsZVdpZHRoIC8gMiApO1xuXG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKGF2YWlsYWJsZVdpZHRoIC8gMikgKyAnLCcgKyAoLW1hcmdpbi50b3ApICsnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxuICAgICAgICAgICAgc2NhdHRlclxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkIH0pKTtcblxuICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1zY2F0dGVyV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuICAgICAgICAgICAgICAgIC5jYWxsKHNjYXR0ZXIpO1xuXG5cbiAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcubnYtcmVncmVzc2lvbkxpbmVzV3JhcCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsaXAtcGF0aCcsICd1cmwoI252LWVkZ2UtY2xpcC0nICsgc2NhdHRlci5pZCgpICsgJyknKTtcblxuICAgICAgICAgICAgdmFyIHJlZ1dyYXAgPSB3cmFwLnNlbGVjdCgnLm52LXJlZ3Jlc3Npb25MaW5lc1dyYXAnKS5zZWxlY3RBbGwoJy5udi1yZWdMaW5lcycpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlZ1dyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1yZWdMaW5lcycpO1xuXG4gICAgICAgICAgICB2YXIgcmVnTGluZSA9IHJlZ1dyYXAuc2VsZWN0QWxsKCcubnYtcmVnTGluZScpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtkXVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZWdMaW5lLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJykuYXR0cignY2xhc3MnLCAnbnYtcmVnTGluZScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDApO1xuXG4gICAgICAgICAgICAvLyBkb24ndCBhZGQgbGluZXMgdW5sZXNzIHdlIGhhdmUgc2xvcGUgYW5kIGludGVyY2VwdCB0byB1c2VcbiAgICAgICAgICAgIHJlZ0xpbmUuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5pbnRlcmNlcHQgJiYgZC5zbG9wZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ3NjYXR0ZXJQbHVzTGluZUNoYXJ0OiByZWdsaW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4LnJhbmdlKClbMF0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeC5yYW5nZSgpWzFdKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5KHguZG9tYWluKClbMF0gKiBkLnNsb3BlICsgZC5pbnRlcmNlcHQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geSh4LmRvbWFpbigpWzFdICogZC5zbG9wZSArIGQuaW50ZXJjZXB0KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbiAoZCwgaSwgaikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3IoZCwgailcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGQuZGlzYWJsZWQgfHwgdHlwZW9mIGQuc2xvcGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkLmludGVyY2VwdCA9PT0gJ3VuZGVmaW5lZCcpID8gMCA6IDFcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgQXhlc1xuICAgICAgICAgICAgaWYgKHNob3dYQXhpcykge1xuICAgICAgICAgICAgICAgIHhBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgICAudGlja3MoIHhBeGlzLnRpY2tzKCkgPyB4QXhpcy50aWNrcygpIDogbnYudXRpbHMuY2FsY1RpY2tzWChhdmFpbGFibGVXaWR0aC8xMDAsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlSGVpZ2h0ICwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkucmFuZ2UoKVswXSArICcpJylcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgICAgICAgICAgeUF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggeUF4aXMudGlja3MoKSA/IHlBeGlzLnRpY2tzKCkgOiBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodC8zNiwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAoc2hvd0Rpc3RYKSB7XG4gICAgICAgICAgICAgICAgZGlzdFhcbiAgICAgICAgICAgICAgICAgICAgLmdldERhdGEoc2NhdHRlci54KCkpXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSk7XG4gICAgICAgICAgICAgICAgZ0VudGVyLnNlbGVjdCgnLm52LWRpc3RXcmFwJykuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LWRpc3RyaWJ1dGlvblgnKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWRpc3RyaWJ1dGlvblgnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB5LnJhbmdlKClbMF0gKyAnKScpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoZGlzdFgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvd0Rpc3RZKSB7XG4gICAgICAgICAgICAgICAgZGlzdFlcbiAgICAgICAgICAgICAgICAgICAgLmdldERhdGEoc2NhdHRlci55KCkpXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgfSkpO1xuICAgICAgICAgICAgICAgIGdFbnRlci5zZWxlY3QoJy5udi1kaXN0V3JhcCcpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1kaXN0cmlidXRpb25ZJyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1kaXN0cmlidXRpb25ZJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChyaWdodEFsaWduWUF4aXMgPyBhdmFpbGFibGVXaWR0aCA6IC1kaXN0WS5zaXplKCkgKSArICcsMCknKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGRpc3RZKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld1N0YXRlKVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0gbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICBzY2F0dGVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KCcubnYtY2hhcnQtJyArIHNjYXR0ZXIuaWQoKSArICcgLm52LXNlcmllcy0nICsgZS5zZXJpZXNJbmRleCArICcgLm52LWRpc3R4LScgKyBlLnBvaW50SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGUucG9zWzFdIC0gYXZhaWxhYmxlSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoJy5udi1jaGFydC0nICsgc2NhdHRlci5pZCgpICsgJyAubnYtc2VyaWVzLScgKyBlLnNlcmllc0luZGV4ICsgJyAubnYtZGlzdHktJyArIGUucG9pbnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZS5wb3NbMF0gKyBkaXN0WC5zaXplKCkpO1xuXG4gICAgICAgICAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC50b29sdGlwU2hvdyhlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBzKSBzaG93VG9vbHRpcChlLCB0aGF0LnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjaGFydCBmcm9tIGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0byBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vc3RvcmUgb2xkIHNjYWxlcyBmb3IgdXNlIGluIHRyYW5zaXRpb25zIG9uIHVwZGF0ZVxuICAgICAgICAgICAgeDAgPSB4LmNvcHkoKTtcbiAgICAgICAgICAgIHkwID0geS5jb3B5KCk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdzY2F0dGVyIHdpdGggbGluZSBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBzY2F0dGVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2gudG9vbHRpcEhpZGUoZSk7XG5cbiAgICAgICAgZDMuc2VsZWN0KCcubnYtY2hhcnQtJyArIHNjYXR0ZXIuaWQoKSArICcgLm52LXNlcmllcy0nICsgZS5zZXJpZXNJbmRleCArICcgLm52LWRpc3R4LScgKyBlLnBvaW50SW5kZXgpXG4gICAgICAgICAgICAuYXR0cigneTEnLCAwKTtcbiAgICAgICAgZDMuc2VsZWN0KCcubnYtY2hhcnQtJyArIHNjYXR0ZXIuaWQoKSArICcgLm52LXNlcmllcy0nICsgZS5zZXJpZXNJbmRleCArICcgLm52LWRpc3R5LScgKyBlLnBvaW50SW5kZXgpXG4gICAgICAgICAgICAuYXR0cigneDInLCBkaXN0WS5zaXplKCkpO1xuICAgIH0pO1xuICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwSGlkZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodG9vbHRpcHMpIG52LnRvb2x0aXAuY2xlYW51cCgpO1xuICAgIH0pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQuc2NhdHRlciA9IHNjYXR0ZXI7XG4gICAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICAgIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gICAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgICBjaGFydC5kaXN0WCA9IGRpc3RYO1xuICAgIGNoYXJ0LmRpc3RZID0gZGlzdFk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzaG93RGlzdFg6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93RGlzdFg7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93RGlzdFg9Xzt9fSxcbiAgICAgICAgc2hvd0Rpc3RZOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0Rpc3RZO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0Rpc3RZPV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIHNob3dYQXhpczogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dYQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dYQXhpcz1fO319LFxuICAgICAgICBzaG93WUF4aXM6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WUF4aXM9Xzt9fSxcbiAgICAgICAgdG9vbHRpcHM6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcHM7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwcz1fO319LFxuICAgICAgICB0b29sdGlwQ29udGVudDogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcD1fO319LFxuICAgICAgICB0b29sdGlwWENvbnRlbnQ6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0b29sdGlwWDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXBYPV87fX0sXG4gICAgICAgIHRvb2x0aXBZQ29udGVudDogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXBZO30sIHNldDogZnVuY3Rpb24oXyl7dG9vbHRpcFk9Xzt9fSxcbiAgICAgICAgZGVmYXVsdFN0YXRlOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGVmYXVsdFN0YXRlO30sIHNldDogZnVuY3Rpb24oXyl7ZGVmYXVsdFN0YXRlPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuICAgICAgICBkdXJhdGlvbjogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2R1cmF0aW9uPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICByaWdodEFsaWduWUF4aXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJpZ2h0QWxpZ25ZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICAgICAgICAgIHlBeGlzLm9yaWVudCggKF8pID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgICAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgICAgICAgICAgZGlzdFguY29sb3IoY29sb3IpO1xuICAgICAgICAgICAgZGlzdFkuY29sb3IoY29sb3IpO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIHNjYXR0ZXIpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5udi5tb2RlbHMuc3BhcmtsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAyLCByaWdodDogMCwgYm90dG9tOiAyLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gNDAwXG4gICAgICAgICwgaGVpZ2h0ID0gMzJcbiAgICAgICAgLCBhbmltYXRlID0gdHJ1ZVxuICAgICAgICAsIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoWycjMDAwJ10pXG4gICAgICAgICwgeERvbWFpblxuICAgICAgICAsIHlEb21haW5cbiAgICAgICAgLCB4UmFuZ2VcbiAgICAgICAgLCB5UmFuZ2VcbiAgICAgICAgO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggICAuZG9tYWluKHhEb21haW4gfHwgZDMuZXh0ZW50KGRhdGEsIGdldFggKSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoeFJhbmdlIHx8IFswLCBhdmFpbGFibGVXaWR0aF0pO1xuXG4gICAgICAgICAgICB5ICAgLmRvbWFpbih5RG9tYWluIHx8IGQzLmV4dGVudChkYXRhLCBnZXRZICkpXG4gICAgICAgICAgICAgICAgLnJhbmdlKHlSYW5nZSB8fCBbYXZhaWxhYmxlSGVpZ2h0LCAwXSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1zcGFya2xpbmUnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1zcGFya2xpbmUnKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKVxuXG4gICAgICAgICAgICB2YXIgcGF0aHMgPSB3cmFwLnNlbGVjdEFsbCgncGF0aCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gW2RdIH0pO1xuICAgICAgICAgICAgcGF0aHMuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKTtcbiAgICAgICAgICAgIHBhdGhzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHBhdGhzXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSkgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGQzLnN2Zy5saW5lKClcbiAgICAgICAgICAgICAgICAgICAgLngoZnVuY3Rpb24oZCxpKSB7IHJldHVybiB4KGdldFgoZCxpKSkgfSlcbiAgICAgICAgICAgICAgICAgICAgLnkoZnVuY3Rpb24oZCxpKSB7IHJldHVybiB5KGdldFkoZCxpKSkgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IEFkZCBDVVJSRU5UIGRhdGEgcG9pbnQgKE5lZWQgTWluLCBNYWMsIEN1cnJlbnQgLyBNb3N0IHJlY2VudClcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB3cmFwLnNlbGVjdEFsbCgnY2lyY2xlLm52LXBvaW50JylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5VmFsdWVzID0gZGF0YS5tYXAoZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gZ2V0WShkLGkpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcG9pbnRJbmRleChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wb2ludEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heFBvaW50ID0gcG9pbnRJbmRleCh5VmFsdWVzLmxhc3RJbmRleE9mKHkuZG9tYWluKClbMV0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblBvaW50ID0gcG9pbnRJbmRleCh5VmFsdWVzLmluZGV4T2YoeS5kb21haW4oKVswXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvaW50ID0gcG9pbnRJbmRleCh5VmFsdWVzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21pblBvaW50LCBtYXhQb2ludCwgY3VycmVudFBvaW50XS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtyZXR1cm4gZCAhPSBudWxsO30pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9pbnRzLmVudGVyKCkuYXBwZW5kKCdjaXJjbGUnKTtcbiAgICAgICAgICAgIHBvaW50cy5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICBwb2ludHNcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHgoZ2V0WChkLGQucG9pbnRJbmRleCkpIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiB5KGdldFkoZCxkLnBvaW50SW5kZXgpKSB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgMilcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFgoZCwgZC5wb2ludEluZGV4KSA9PSB4LmRvbWFpbigpWzFdID8gJ252LXBvaW50IG52LWN1cnJlbnRWYWx1ZScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFkoZCwgZC5wb2ludEluZGV4KSA9PSB5LmRvbWFpbigpWzBdID8gJ252LXBvaW50IG52LW1pblZhbHVlJyA6ICdudi1wb2ludCBudi1tYXhWYWx1ZSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHhEb21haW46ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geERvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hEb21haW49Xzt9fSxcbiAgICAgICAgeURvbWFpbjogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eURvbWFpbj1fO319LFxuICAgICAgICB4UmFuZ2U6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hSYW5nZT1fO319LFxuICAgICAgICB5UmFuZ2U6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lSYW5nZT1fO319LFxuICAgICAgICB4U2NhbGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHg7fSwgc2V0OiBmdW5jdGlvbihfKXt4PV87fX0sXG4gICAgICAgIHlTY2FsZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3k9Xzt9fSxcbiAgICAgICAgYW5pbWF0ZTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBhbmltYXRlO30sIHNldDogZnVuY3Rpb24oXyl7YW5pbWF0ZT1fO319LFxuXG4gICAgICAgIC8vZnVuY3RvciBvcHRpb25zXG4gICAgICAgIHg6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFg7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRYPWQzLmZ1bmN0b3IoXyk7fX0sXG4gICAgICAgIHk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRZPWQzLmZ1bmN0b3IoXyk7fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5zcGFya2xpbmVQbHVzID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBzcGFya2xpbmUgPSBudi5tb2RlbHMuc3BhcmtsaW5lKCk7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMTUsIHJpZ2h0OiAxMDAsIGJvdHRvbTogMTAsIGxlZnQ6IDUwfVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCB4XG4gICAgICAgICwgeVxuICAgICAgICAsIGluZGV4ID0gW11cbiAgICAgICAgLCBwYXVzZWQgPSBmYWxzZVxuICAgICAgICAsIHhUaWNrRm9ybWF0ID0gZDMuZm9ybWF0KCcscicpXG4gICAgICAgICwgeVRpY2tGb3JtYXQgPSBkMy5mb3JtYXQoJywuMmYnKVxuICAgICAgICAsIHNob3dWYWx1ZSA9IHRydWVcbiAgICAgICAgLCBhbGlnblZhbHVlID0gdHJ1ZVxuICAgICAgICAsIHJpZ2h0QWxpZ25WYWx1ZSA9IGZhbHNlXG4gICAgICAgICwgbm9EYXRhID0gXCJObyBEYXRhIEF2YWlsYWJsZS5cIlxuICAgICAgICA7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gKHdpZHRoICB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJykpIHx8IDk2MClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSAoaGVpZ2h0IHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnaGVpZ2h0JykpIHx8IDQwMClcbiAgICAgICAgICAgICAgICAgICAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNoYXJ0KHNlbGVjdGlvbikgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoW25vRGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dC5lbnRlcigpLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudmQzIG52LW5vRGF0YScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctLjdlbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJyk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbWFyZ2luLmxlZnQgKyBhdmFpbGFibGVXaWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgbWFyZ2luLnRvcCArIGF2YWlsYWJsZUhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHNwYXJrbGluZS55KCkoZGF0YVtkYXRhLmxlbmd0aC0xXSwgZGF0YS5sZW5ndGgtMSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeCA9IHNwYXJrbGluZS54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBzcGFya2xpbmUueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1zcGFya2xpbmVwbHVzJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtc3BhcmtsaW5lcGx1cycpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXNwYXJrbGluZVdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi12YWx1ZVdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1ob3ZlckFyZWEnKTtcblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxuICAgICAgICAgICAgdmFyIHNwYXJrbGluZVdyYXAgPSBnLnNlbGVjdCgnLm52LXNwYXJrbGluZVdyYXAnKTtcblxuICAgICAgICAgICAgc3BhcmtsaW5lLndpZHRoKGF2YWlsYWJsZVdpZHRoKS5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KTtcbiAgICAgICAgICAgIHNwYXJrbGluZVdyYXAuY2FsbChzcGFya2xpbmUpO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWVXcmFwID0gZy5zZWxlY3QoJy5udi12YWx1ZVdyYXAnKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlV3JhcC5zZWxlY3RBbGwoJy5udi1jdXJyZW50VmFsdWUnKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtjdXJyZW50VmFsdWVdKTtcblxuICAgICAgICAgICAgdmFsdWUuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICdudi1jdXJyZW50VmFsdWUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsIHJpZ2h0QWxpZ25WYWx1ZSA/IC04IDogOClcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjllbScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIHJpZ2h0QWxpZ25WYWx1ZSA/ICdlbmQnIDogJ3N0YXJ0Jyk7XG5cbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBhdmFpbGFibGVXaWR0aCArIChyaWdodEFsaWduVmFsdWUgPyBtYXJnaW4ucmlnaHQgOiAwKSlcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGFsaWduVmFsdWUgPyBmdW5jdGlvbihkKSB7IHJldHVybiB5KGQpIH0gOiAwKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHNwYXJrbGluZS5jb2xvcigpKGRhdGFbZGF0YS5sZW5ndGgtMV0sIGRhdGEubGVuZ3RoLTEpKVxuICAgICAgICAgICAgICAgIC50ZXh0KHlUaWNrRm9ybWF0KGN1cnJlbnRWYWx1ZSkpO1xuXG4gICAgICAgICAgICBnRW50ZXIuc2VsZWN0KCcubnYtaG92ZXJBcmVhJykuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIHNwYXJrbGluZUhvdmVyKVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgcGF1c2VkID0gIXBhdXNlZCB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbigpIHsgaW5kZXggPSBbXTsgdXBkYXRlVmFsdWVMaW5lKCk7IH0pO1xuXG4gICAgICAgICAgICBnLnNlbGVjdCgnLm52LWhvdmVyQXJlYSByZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgLW1hcmdpbi5sZWZ0ICsgJywnICsgLW1hcmdpbi50b3AgKyAnKScgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBhdmFpbGFibGVXaWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQgKyBtYXJnaW4udG9wKTtcblxuICAgICAgICAgICAgLy9pbmRleCBpcyBjdXJyZW50bHkgZ2xvYmFsICh3aXRoaW4gdGhlIGNoYXJ0KSwgbWF5IG9yIG1heSBub3Qga2VlcCBpdCB0aGF0IHdheVxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmFsdWVMaW5lKCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXVzZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciBob3ZlclZhbHVlID0gZy5zZWxlY3RBbGwoJy5udi1ob3ZlclZhbHVlJykuZGF0YShpbmRleClcblxuICAgICAgICAgICAgICAgIHZhciBob3ZlckVudGVyID0gaG92ZXJWYWx1ZS5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1ob3ZlclZhbHVlJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMCk7XG5cbiAgICAgICAgICAgICAgICBob3ZlclZhbHVlLmV4aXQoKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDI1MClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMClcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgaG92ZXJWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeChzcGFya2xpbmUueCgpKGRhdGFbZF0sZCkpICsgJywwKScgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbigyNTApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbmRleC5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGhvdmVyRW50ZXIuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgLW1hcmdpbi50b3ApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICBob3ZlckVudGVyLmFwcGVuZCgndGV4dCcpLmF0dHIoJ2NsYXNzJywgJ252LXhWYWx1ZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgLTYpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgLW1hcmdpbi50b3ApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjllbScpXG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWhvdmVyVmFsdWUgLm52LXhWYWx1ZScpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KHhUaWNrRm9ybWF0KHNwYXJrbGluZS54KCkoZGF0YVtpbmRleFswXV0sIGluZGV4WzBdKSkpO1xuXG4gICAgICAgICAgICAgICAgaG92ZXJFbnRlci5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICdudi15VmFsdWUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIDYpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgLW1hcmdpbi50b3ApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcuOWVtJylcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtaG92ZXJWYWx1ZSAubnYteVZhbHVlJylcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoeVRpY2tGb3JtYXQoc3BhcmtsaW5lLnkoKShkYXRhW2luZGV4WzBdXSwgaW5kZXhbMF0pKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNwYXJrbGluZUhvdmVyKCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXVzZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBkMy5tb3VzZSh0aGlzKVswXSAtIG1hcmdpbi5sZWZ0O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q2xvc2VzdEluZGV4KGRhdGEsIHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5hYnMoc3BhcmtsaW5lLngoKShkYXRhWzBdLCAwKSAtIHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzcGFya2xpbmUueCgpKGRhdGFbaV0sIGkpIC0geCkgPCBkaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoc3BhcmtsaW5lLngoKShkYXRhW2ldLCBpKSAtIHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3RJbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbmRleCA9IFtnZXRDbG9zZXN0SW5kZXgoZGF0YSwgTWF0aC5yb3VuZCh4LmludmVydChwb3MpKSldO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlTGluZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuc3BhcmtsaW5lID0gc3BhcmtsaW5lO1xuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHhUaWNrRm9ybWF0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geFRpY2tGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKXt4VGlja0Zvcm1hdD1fO319LFxuICAgICAgICB5VGlja0Zvcm1hdDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlUaWNrRm9ybWF0O30sIHNldDogZnVuY3Rpb24oXyl7eVRpY2tGb3JtYXQ9Xzt9fSxcbiAgICAgICAgc2hvd1ZhbHVlOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93VmFsdWU7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93VmFsdWU9Xzt9fSxcbiAgICAgICAgYWxpZ25WYWx1ZTogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBhbGlnblZhbHVlO30sIHNldDogZnVuY3Rpb24oXyl7YWxpZ25WYWx1ZT1fO319LFxuICAgICAgICByaWdodEFsaWduVmFsdWU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJpZ2h0QWxpZ25WYWx1ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3JpZ2h0QWxpZ25WYWx1ZT1fO319LFxuICAgICAgICBub0RhdGE6ICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIHNwYXJrbGluZSk7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLnN0YWNrZWRBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gOTYwXG4gICAgICAgICwgaGVpZ2h0ID0gNTAwXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKSAvLyBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlIGNvbG9yXG4gICAgICAgICwgaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApIC8vQ3JlYXRlIHNlbWktdW5pcXVlIElEIGluY2FzZSB1c2VyIGRvZXNuJ3Qgc2VsZXQgb25lXG4gICAgICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9IC8vIGFjY2Vzc29yIHRvIGdldCB0aGUgeCB2YWx1ZSBmcm9tIGEgZGF0YSBwb2ludFxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfSAvLyBhY2Nlc3NvciB0byBnZXQgdGhlIHkgdmFsdWUgZnJvbSBhIGRhdGEgcG9pbnRcbiAgICAgICAgLCBzdHlsZSA9ICdzdGFjaydcbiAgICAgICAgLCBvZmZzZXQgPSAnemVybydcbiAgICAgICAgLCBvcmRlciA9ICdkZWZhdWx0J1xuICAgICAgICAsIGludGVycG9sYXRlID0gJ2xpbmVhcicgIC8vIGNvbnRyb2xzIHRoZSBsaW5lIGludGVycG9sYXRpb25cbiAgICAgICAgLCBjbGlwRWRnZSA9IGZhbHNlIC8vIGlmIHRydWUsIG1hc2tzIGxpbmVzIHdpdGhpbiB4IGFuZCB5IHNjYWxlXG4gICAgICAgICwgeCAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueFNjYWxlKClcbiAgICAgICAgLCB5IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC55U2NhbGUoKVxuICAgICAgICAsIHNjYXR0ZXIgPSBudi5tb2RlbHMuc2NhdHRlcigpXG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgLCBkaXNwYXRjaCA9ICBkMy5kaXNwYXRjaCgndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnLCAnYXJlYUNsaWNrJywgJ2FyZWFNb3VzZW92ZXInLCAnYXJlYU1vdXNlb3V0JywncmVuZGVyRW5kJylcbiAgICAgICAgO1xuXG4gICAgLy8gc2NhdHRlciBpcyBpbnRlcmFjdGl2ZSBieSBkZWZhdWx0LCBidXQgdGhpcyBjaGFydCBpc24ndCBzbyBtdXN0IGRpc2FibGVcbiAgICBzY2F0dGVyLmludGVyYWN0aXZlKGZhbHNlKTtcblxuICAgIHNjYXR0ZXJcbiAgICAgICAgLnBvaW50U2l6ZSgyLjIpIC8vIGRlZmF1bHQgc2l6ZVxuICAgICAgICAucG9pbnREb21haW4oWzIuMiwgMi4yXSkgLy8gYWxsIHRoZSBzYW1lIHNpemUgYnkgZGVmYXVsdFxuICAgIDtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBvZmZzZXQ6XG4gICAgICogICAnd2lnZ2xlJyAoc3RyZWFtKVxuICAgICAqICAgJ3plcm8nIChzdGFja2VkKVxuICAgICAqICAgJ2V4cGFuZCcgKG5vcm1hbGl6ZSB0byAxMDAlKVxuICAgICAqICAgJ3NpbGhvdWV0dGUnIChzaW1wbGUgY2VudGVyZWQpXG4gICAgICpcbiAgICAgKiBvcmRlcjpcbiAgICAgKiAgICdpbnNpZGUtb3V0JyAoc3RyZWFtKVxuICAgICAqICAgJ2RlZmF1bHQnIChpbnB1dCBvcmRlcilcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMoc2NhdHRlcik7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20sXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBzY2F0dGVyLnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IHNjYXR0ZXIueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhUmF3ID0gZGF0YTtcbiAgICAgICAgICAgIC8vIEluamVjdGluZyBwb2ludCBpbmRleCBpbnRvIGVhY2ggcG9pbnQgYmVjYXVzZSBkMy5sYXlvdXQuc3RhY2soKS5vdXQgZG9lcyBub3QgZ2l2ZSBpbmRleFxuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGFzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICBhc2VyaWVzLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBhc2VyaWVzLnZhbHVlcyA9IGFzZXJpZXMudmFsdWVzLm1hcChmdW5jdGlvbihkLCBqKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuaW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICBkLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGRhdGFGaWx0ZXJlZCA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiAhc2VyaWVzLmRpc2FibGVkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRhdGEgPSBkMy5sYXlvdXQuc3RhY2soKVxuICAgICAgICAgICAgICAgIC5vcmRlcihvcmRlcilcbiAgICAgICAgICAgICAgICAub2Zmc2V0KG9mZnNldClcbiAgICAgICAgICAgICAgICAudmFsdWVzKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzIH0pICAvL1RPRE86IG1ha2UgdmFsdWVzIGN1c3RvbWl6ZWFibGUgaW4gRVZFUlkgbW9kZWwgaW4gdGhpcyBmYXNoaW9uXG4gICAgICAgICAgICAgICAgLngoZ2V0WClcbiAgICAgICAgICAgICAgICAueShnZXRZKVxuICAgICAgICAgICAgICAgIC5vdXQoZnVuY3Rpb24oZCwgeTAsIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlIZWlnaHQgPSAoZ2V0WShkKSA9PT0gMCkgPyAwIDogeTtcbiAgICAgICAgICAgICAgICAgICAgZC5kaXNwbGF5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeTogeUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwOiB5MFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAoZGF0YUZpbHRlcmVkKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LXN0YWNrZWRhcmVhJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtc3RhY2tlZGFyZWEnKTtcbiAgICAgICAgICAgIHZhciBkZWZzRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYXJlYVdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1zY2F0dGVyV3JhcCcpO1xuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIHNjYXR0ZXJcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLngoZ2V0WClcbiAgICAgICAgICAgICAgICAueShmdW5jdGlvbihkKSB7IHJldHVybiBkLmRpc3BsYXkueSArIGQuZGlzcGxheS55MCB9KVxuICAgICAgICAgICAgICAgIC5mb3JjZVkoWzBdKVxuICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgZC5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICB2YXIgc2NhdHRlcldyYXAgPSBnLnNlbGVjdCgnLm52LXNjYXR0ZXJXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YSk7XG5cbiAgICAgICAgICAgIHNjYXR0ZXJXcmFwLmNhbGwoc2NhdHRlcik7XG5cbiAgICAgICAgICAgIGRlZnNFbnRlci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnbnYtZWRnZS1jbGlwLScgKyBpZClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0Jyk7XG5cbiAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcjbnYtZWRnZS1jbGlwLScgKyBpZCArICcgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIGcuYXR0cignY2xpcC1wYXRoJywgY2xpcEVkZ2UgPyAndXJsKCNudi1lZGdlLWNsaXAtJyArIGlkICsgJyknIDogJycpO1xuXG4gICAgICAgICAgICB2YXIgYXJlYSA9IGQzLnN2Zy5hcmVhKClcbiAgICAgICAgICAgICAgICAueChmdW5jdGlvbihkLGkpICB7IHJldHVybiB4KGdldFgoZCxpKSkgfSlcbiAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geShkLmRpc3BsYXkueTApXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAueTEoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geShkLmRpc3BsYXkueSArIGQuZGlzcGxheS55MClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSk7XG5cbiAgICAgICAgICAgIHZhciB6ZXJvQXJlYSA9IGQzLnN2Zy5hcmVhKClcbiAgICAgICAgICAgICAgICAueChmdW5jdGlvbihkLGkpICB7IHJldHVybiB4KGdldFgoZCxpKSkgfSlcbiAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24oZCkgeyByZXR1cm4geShkLmRpc3BsYXkueTApIH0pXG4gICAgICAgICAgICAgICAgLnkxKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHkoZC5kaXNwbGF5LnkwKSB9KTtcblxuICAgICAgICAgICAgdmFyIHBhdGggPSBnLnNlbGVjdCgnLm52LWFyZWFXcmFwJykuc2VsZWN0QWxsKCdwYXRoLm52LWFyZWEnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgIHBhdGguZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ252LWFyZWEgbnYtYXJlYS0nICsgaSB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHplcm9BcmVhKGQudmFsdWVzLCBkLnNlcmllc0luZGV4KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5hcmVhTW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW2QzLmV2ZW50LnBhZ2VYLCBkMy5ldmVudC5wYWdlWV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXNJbmRleFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5hcmVhTW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGQua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbZDMuZXZlbnQucGFnZVgsIGQzLmV2ZW50LnBhZ2VZXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllc0luZGV4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmFyZWFDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFtkMy5ldmVudC5wYWdlWCwgZDMuZXZlbnQucGFnZVldLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBhdGguZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgcGF0aC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGQuc2VyaWVzSW5kZXgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSl7IHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGQuc2VyaWVzSW5kZXgpIH0pO1xuICAgICAgICAgICAgcGF0aC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsJ3N0YWNrZWRBcmVhIHBhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmVhKGQudmFsdWVzLGkpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIuYXJlYScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNoYXJ0LScgKyBpZCArICcgLm52LWFyZWEtJyArIGUuc2VyaWVzSW5kZXgpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC5hcmVhJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY2hhcnQtJyArIGlkICsgJyAubnYtYXJlYS0nICsgZS5zZXJpZXNJbmRleCkuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9TcGVjaWFsIG9mZnNldCBmdW5jdGlvbnNcbiAgICAgICAgICAgIGNoYXJ0LmQzX3N0YWNrZWRPZmZzZXRfc3RhY2tQZXJjZW50ID0gZnVuY3Rpb24oc3RhY2tEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzdGFja0RhdGEubGVuZ3RoLCAgICAvL0hvdyBtYW55IHNlcmllc1xuICAgICAgICAgICAgICAgICAgICBtID0gc3RhY2tEYXRhWzBdLmxlbmd0aCwgICAgIC8vaG93IG1hbnkgcG9pbnRzIHBlciBzZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgayA9IDEgLyBuLFxuICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgICAgICBvLFxuICAgICAgICAgICAgICAgICAgICB5MCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgeyAvL0xvb3BpbmcgdGhyb3VnaCBhbGwgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIG8gPSAwOyBpIDwgZGF0YVJhdy5sZW5ndGg7IGkrKykgeyAvL2xvb3BpbmcgdGhyb3VnaCBzZXJpZXMnXG4gICAgICAgICAgICAgICAgICAgICAgICBvICs9IGdldFkoZGF0YVJhd1tpXS52YWx1ZXNbal0pOyAgIC8vdG90YWwgdmFsdWUgb2YgYWxsIHBvaW50cyBhdCBhIGNlcnRpYW4gcG9pbnQgaW4gdGltZS5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvKSBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja0RhdGFbaV1bal1bMV0gLz0gbztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja0RhdGFbaV1bal1bMV0gPSBrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHkwW2pdID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4geTA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnc3RhY2tlZEFyZWEgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBzY2F0dGVyLmRpc3BhdGNoLm9uKCdlbGVtZW50Q2xpY2suYXJlYScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlzcGF0Y2guYXJlYUNsaWNrKGUpO1xuICAgIH0pO1xuICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wb3MgPSBbZS5wb3NbMF0gKyBtYXJnaW4ubGVmdCwgZS5wb3NbMV0gKyBtYXJnaW4udG9wXSxcbiAgICAgICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaXNwYXRjaC50b29sdGlwSGlkZShlKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gR2xvYmFsIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5zY2F0dGVyID0gc2NhdHRlcjtcblxuICAgIGNoYXJ0LmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcnBvbGF0ZTtcbiAgICAgICAgaW50ZXJwb2xhdGUgPSBfO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfTtcblxuICAgIGNoYXJ0LmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkdXJhdGlvbjtcbiAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgIHNjYXR0ZXIuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfTtcblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgY2xpcEVkZ2U6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNsaXBFZGdlO30sIHNldDogZnVuY3Rpb24oXyl7Y2xpcEVkZ2U9Xzt9fSxcbiAgICAgICAgb2Zmc2V0OiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG9mZnNldDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe29mZnNldD1fO319LFxuICAgICAgICBvcmRlcjogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gb3JkZXI7fSwgc2V0OiBmdW5jdGlvbihfKXtvcmRlcj1fO319LFxuICAgICAgICBpbnRlcnBvbGF0ZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaW50ZXJwb2xhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXtpbnRlcnBvbGF0ZT1fO319LFxuXG4gICAgICAgIC8vIHNpbXBsZSBmdW5jdG9yIG9wdGlvbnNcbiAgICAgICAgeDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFg7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRYID0gZDMuZnVuY3RvcihfKTt9fSxcbiAgICAgICAgeTogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRZID0gZDMuZnVuY3RvcihfKTt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIH19LFxuICAgICAgICBzdHlsZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc3R5bGU7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHN0eWxlID0gXztcbiAgICAgICAgICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdGFjayc6XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Lm9mZnNldCgnemVybycpO1xuICAgICAgICAgICAgICAgICAgICBjaGFydC5vcmRlcignZGVmYXVsdCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJlYW0nOlxuICAgICAgICAgICAgICAgICAgICBjaGFydC5vZmZzZXQoJ3dpZ2dsZScpO1xuICAgICAgICAgICAgICAgICAgICBjaGFydC5vcmRlcignaW5zaWRlLW91dCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJlYW0tY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQub2Zmc2V0KCdzaWxob3VldHRlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Lm9yZGVyKCdpbnNpZGUtb3V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGFuZCc6XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Lm9mZnNldCgnZXhwYW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Lm9yZGVyKCdkZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YWNrX3BlcmNlbnQnOlxuICAgICAgICAgICAgICAgICAgICBjaGFydC5vZmZzZXQoY2hhcnQuZDNfc3RhY2tlZE9mZnNldF9zdGFja1BlcmNlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjaGFydC5vcmRlcignZGVmYXVsdCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICAgICAgc2NhdHRlci5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgc2NhdHRlcik7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLnN0YWNrZWRBcmVhQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHN0YWNrZWQgPSBudi5tb2RlbHMuc3RhY2tlZEFyZWEoKVxuICAgICAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICAgICAsIGNvbnRyb2xzID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgICAgICwgaW50ZXJhY3RpdmVMYXllciA9IG52LmludGVyYWN0aXZlR3VpZGVsaW5lKClcbiAgICAgICAgO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMjUsIGJvdHRvbTogNTAsIGxlZnQ6IDYwfVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgc2hvd0NvbnRyb2xzID0gdHJ1ZVxuICAgICAgICAsIHNob3dMZWdlbmQgPSB0cnVlXG4gICAgICAgICwgc2hvd1hBeGlzID0gdHJ1ZVxuICAgICAgICAsIHNob3dZQXhpcyA9IHRydWVcbiAgICAgICAgLCByaWdodEFsaWduWUF4aXMgPSBmYWxzZVxuICAgICAgICAsIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lID0gZmFsc2VcbiAgICAgICAgLCB0b29sdGlwcyA9IHRydWVcbiAgICAgICAgLCB0b29sdGlwID0gZnVuY3Rpb24oa2V5LCB4LCB5LCBlLCBncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuICc8aDM+JyArIGtleSArICc8L2gzPicgK1xuICAgICAgICAgICAgICAgICc8cD4nICsgIHkgKyAnIG9uICcgKyB4ICsgJzwvcD4nXG4gICAgICAgIH1cbiAgICAgICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxuICAgICAgICAsIHkgLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnlTY2FsZSgpXG4gICAgICAgICwgeUF4aXNUaWNrRm9ybWF0ID0gZDMuZm9ybWF0KCcsLjJmJylcbiAgICAgICAgLCBzdGF0ZSA9IG52LnV0aWxzLnN0YXRlKClcbiAgICAgICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgICAgICwgbm9EYXRhID0gJ05vIERhdGEgQXZhaWxhYmxlLidcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsJ3JlbmRlckVuZCcpXG4gICAgICAgICwgY29udHJvbFdpZHRoID0gMjUwXG4gICAgICAgICwgY0RhdGEgPSBbJ1N0YWNrZWQnLCdTdHJlYW0nLCdFeHBhbmRlZCddXG4gICAgICAgICwgY29udHJvbExhYmVscyA9IHt9XG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgO1xuXG4gICAgc3RhdGUuc3R5bGUgPSBzdGFja2VkLnN0eWxlKCk7XG4gICAgeEF4aXMub3JpZW50KCdib3R0b20nKS50aWNrUGFkZGluZyg3KTtcbiAgICB5QXhpcy5vcmllbnQoKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKTtcblxuICAgIGNvbnRyb2xzLnVwZGF0ZVN0YXRlKGZhbHNlKTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gpO1xuICAgIHZhciBzdHlsZSA9IHN0YWNrZWQuc3R5bGUoKTtcblxuICAgIHZhciBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uKGUsIG9mZnNldEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBlLnBvc1swXSArICggb2Zmc2V0RWxlbWVudC5vZmZzZXRMZWZ0IHx8IDAgKSxcbiAgICAgICAgICAgIHRvcCA9IGUucG9zWzFdICsgKCBvZmZzZXRFbGVtZW50Lm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgICAgIHggPSB4QXhpcy50aWNrRm9ybWF0KCkoc3RhY2tlZC54KCkoZS5wb2ludCwgZS5wb2ludEluZGV4KSksXG4gICAgICAgICAgICB5ID0geUF4aXMudGlja0Zvcm1hdCgpKHN0YWNrZWQueSgpKGUucG9pbnQsIGUucG9pbnRJbmRleCkpLFxuICAgICAgICAgICAgY29udGVudCA9IHRvb2x0aXAoZS5zZXJpZXMua2V5LCB4LCB5LCBlLCBjaGFydCk7XG5cbiAgICAgICAgbnYudG9vbHRpcC5zaG93KFtsZWZ0LCB0b3BdLCBjb250ZW50LCBlLnZhbHVlIDwgMCA/ICduJyA6ICdzJywgbnVsbCwgb2Zmc2V0RWxlbWVudCk7XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZUdldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZTogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSksXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0YWNrZWQuc3R5bGUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3RhdGVTZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnN0eWxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdGF0ZS5zdHlsZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hY3RpdmUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gIXN0YXRlLmFjdGl2ZVtpXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKHN0YWNrZWQpO1xuICAgICAgICBpZiAoc2hvd1hBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeEF4aXMpO1xuICAgICAgICBpZiAoc2hvd1lBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeUF4aXMpO1xuXG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9ICh3aWR0aCAgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCd3aWR0aCcpKSB8fCA5NjApXG4gICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKGNoYXJ0KTsgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICAgLnNldHRlcihzdGF0ZVNldHRlcihkYXRhKSwgY2hhcnQudXBkYXRlKVxuICAgICAgICAgICAgICAgIC5nZXR0ZXIoc3RhdGVHZXR0ZXIoZGF0YSkpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBERVBSRUNBVEVEIHNldCBzdGF0ZS5kaXNhYmxlZFxuICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG5cbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IE5vIERhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLmxlbmd0aCB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9EYXRhVGV4dCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5kYXRhKFtub0RhdGFdKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi1ub0RhdGEnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLS43ZW0nKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgICAgICAgICAgbm9EYXRhVGV4dFxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIG1hcmdpbi5sZWZ0ICsgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIG1hcmdpbi50b3AgKyBhdmFpbGFibGVIZWlnaHQgLyAyKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeCA9IHN0YWNrZWQueFNjYWxlKCk7XG4gICAgICAgICAgICB5ID0gc3RhY2tlZC55U2NhbGUoKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LXN0YWNrZWRBcmVhQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1zdGFja2VkQXJlYUNoYXJ0JykuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoXCJyZWN0XCIpLnN0eWxlKFwib3BhY2l0eVwiLDApO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkgbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXN0YWNrZWRXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWNvbnRyb2xzV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWludGVyYWN0aXZlJyk7XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KFwicmVjdFwiKS5hdHRyKFwid2lkdGhcIixhdmFpbGFibGVXaWR0aCkuYXR0cihcImhlaWdodFwiLGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgaWYgKHNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVnZW5kV2lkdGggPSAoc2hvd0NvbnRyb2xzKSA/IGF2YWlsYWJsZVdpZHRoIC0gY29udHJvbFdpZHRoIDogYXZhaWxhYmxlV2lkdGg7XG5cbiAgICAgICAgICAgICAgICBsZWdlbmQud2lkdGgobGVnZW5kV2lkdGgpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpLmRhdHVtKGRhdGEpLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICggbWFyZ2luLnRvcCAhPSBsZWdlbmQuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoYXZhaWxhYmxlV2lkdGgtbGVnZW5kV2lkdGgpICsgJywnICsgKC1tYXJnaW4udG9wKSArJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udHJvbHNcbiAgICAgICAgICAgIGlmIChzaG93Q29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHNEYXRhID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGNvbnRyb2xMYWJlbHMuc3RhY2tlZCB8fCAnU3RhY2tlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhS2V5OiAnU3RhY2tlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogc3RhY2tlZC5zdHlsZSgpICE9ICdzdGFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3N0YWNrJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGNvbnRyb2xMYWJlbHMuc3RyZWFtIHx8ICdTdHJlYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YUtleTogJ1N0cmVhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogc3RhY2tlZC5zdHlsZSgpICE9ICdzdHJlYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdzdHJlYW0nXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogY29udHJvbExhYmVscy5leHBhbmRlZCB8fCAnRXhwYW5kZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YUtleTogJ0V4cGFuZGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBzdGFja2VkLnN0eWxlKCkgIT0gJ2V4cGFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2V4cGFuZCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBjb250cm9sTGFiZWxzLnN0YWNrX3BlcmNlbnQgfHwgJ1N0YWNrICUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YUtleTogJ1N0YWNrX1BlcmNlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHN0YWNrZWQuc3R5bGUoKSAhPSAnc3RhY2tfcGVyY2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3N0YWNrX3BlcmNlbnQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgY29udHJvbFdpZHRoID0gKGNEYXRhLmxlbmd0aC8zKSAqIDI2MDtcbiAgICAgICAgICAgICAgICBjb250cm9sc0RhdGEgPSBjb250cm9sc0RhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNEYXRhLmluZGV4T2YoZC5tZXRhS2V5KSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb250cm9sc1xuICAgICAgICAgICAgICAgICAgICAud2lkdGgoIGNvbnRyb2xXaWR0aCApXG4gICAgICAgICAgICAgICAgICAgIC5jb2xvcihbJyM0NDQnLCAnIzQ0NCcsICcjNDQ0J10pO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250cm9sc1dyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oY29udHJvbHNEYXRhKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChjb250cm9scyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gTWF0aC5tYXgoY29udHJvbHMuaGVpZ2h0KCksIGxlZ2VuZC5oZWlnaHQoKSkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBNYXRoLm1heChjb250cm9scy5oZWlnaHQoKSwgbGVnZW5kLmhlaWdodCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ2hlaWdodCcpKSB8fCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udHJvbHNXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TZXQgdXAgaW50ZXJhY3RpdmUgbGF5ZXJcbiAgICAgICAgICAgIGlmICh1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSkge1xuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgLm1hcmdpbih7bGVmdDogbWFyZ2luLmxlZnQsIHRvcDogbWFyZ2luLnRvcH0pXG4gICAgICAgICAgICAgICAgICAgIC5zdmdDb250YWluZXIoY29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAueFNjYWxlKHgpO1xuICAgICAgICAgICAgICAgIHdyYXAuc2VsZWN0KFwiLm52LWludGVyYWN0aXZlXCIpLmNhbGwoaW50ZXJhY3RpdmVMYXllcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YWNrZWRcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgc3RhY2tlZFdyYXAgPSBnLnNlbGVjdCgnLm52LXN0YWNrZWRXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YSk7XG5cbiAgICAgICAgICAgIHN0YWNrZWRXcmFwLnRyYW5zaXRpb24oKS5jYWxsKHN0YWNrZWQpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBBeGVzXG4gICAgICAgICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgICAgICAgICAgeEF4aXMuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoLzEwMCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVIZWlnaHQsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyBhdmFpbGFibGVIZWlnaHQgKyAnKScpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDApXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3dZQXhpcykge1xuICAgICAgICAgICAgICAgIHlBeGlzLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyhzdGFja2VkLm9mZnNldCgpID09ICd3aWdnbGUnID8gMCA6IG52LnV0aWxzLmNhbGNUaWNrc1koYXZhaWxhYmxlSGVpZ2h0LzM2LCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlV2lkdGgsIDApXG4gICAgICAgICAgICAgICAgICAgIC5zZXRUaWNrRm9ybWF0KCAoc3RhY2tlZC5zdHlsZSgpID09ICdleHBhbmQnIHx8IHN0YWNrZWQuc3R5bGUoKSA9PSAnc3RhY2tfcGVyY2VudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGQzLmZvcm1hdCgnJScpIDogeUF4aXNUaWNrRm9ybWF0KTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbigwKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIHN0YWNrZWQuZGlzcGF0Y2gub24oJ2FyZWFDbGljay50b2dnbGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gKGkgIT0gZS5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld1N0YXRlKVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0gbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29udHJvbHMuZGlzcGF0Y2gub24oJ2xlZ2VuZENsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkLmRpc2FibGVkKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBjb250cm9sc0RhdGEgPSBjb250cm9sc0RhdGEubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHN0YWNrZWQuc3R5bGUoZC5zdHlsZSk7XG5cblxuICAgICAgICAgICAgICAgIHN0YXRlLnN0eWxlID0gc3RhY2tlZC5zdHlsZSgpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcblxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc3RhY2tlZC5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlUG9pbnQsIHBvaW50SW5kZXgsIHBvaW50WExvY2F0aW9uLCBhbGxEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2VyaWVzLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleCA9IG52LmludGVyYWN0aXZlQmlzZWN0KHNlcmllcy52YWx1ZXMsIGUucG9pbnRYVmFsdWUsIGNoYXJ0LngoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja2VkLmhpZ2hsaWdodFBvaW50KGksIHBvaW50SW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gc2VyaWVzLnZhbHVlc1twb2ludEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNpbmdsZVBvaW50ID09PSAndW5kZWZpbmVkJykgc2luZ2xlUG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRYTG9jYXRpb24gPT09ICd1bmRlZmluZWQnKSBwb2ludFhMb2NhdGlvbiA9IGNoYXJ0LnhTY2FsZSgpKGNoYXJ0LngoKShwb2ludCxwb2ludEluZGV4KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgd2UgYXJlIGluICdleHBhbmQnIG1vZGUsIHVzZSB0aGUgc3RhY2tlZCBwZXJjZW50IHZhbHVlIGluc3RlYWQgb2YgcmF3IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBWYWx1ZSA9IChzdGFja2VkLnN0eWxlKCkgPT0gJ2V4cGFuZCcpID8gcG9pbnQuZGlzcGxheS55IDogY2hhcnQueSgpKHBvaW50LHBvaW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRvb2x0aXBWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3Ioc2VyaWVzLHNlcmllcy5zZXJpZXNJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tlZFZhbHVlOiBwb2ludC5kaXNwbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBhbGxEYXRhLnJldmVyc2UoKTtcblxuICAgICAgICAgICAgICAgIC8vSGlnaGxpZ2h0IHRoZSB0b29sdGlwIGVudHJ5IGJhc2VkIG9uIHdoaWNoIHN0YWNrIHRoZSBtb3VzZSBpcyBjbG9zZXN0IHRvLlxuICAgICAgICAgICAgICAgIGlmIChhbGxEYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlWYWx1ZSA9IGNoYXJ0LnlTY2FsZSgpLmludmVydChlLm1vdXNlWSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5RGlzdE1heCA9IEluZmluaXR5LCBpbmRleFRvSGlnaGxpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVG8gaGFuZGxlIHNpdHVhdGlvbiB3aGVyZSB0aGUgc3RhY2tlZCBhcmVhIGNoYXJ0IGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIHVzZSBhYnNvbHV0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vd2hlbiBjaGVja2luZyBpZiB0aGUgbW91c2UgWSB2YWx1ZSBpcyB3aXRoaW4gdGhlIHN0YWNrIGFyZWEuXG4gICAgICAgICAgICAgICAgICAgICAgICB5VmFsdWUgPSBNYXRoLmFicyh5VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRZMCA9IE1hdGguYWJzKHNlcmllcy5zdGFja2VkVmFsdWUueTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRZID0gTWF0aC5hYnMoc2VyaWVzLnN0YWNrZWRWYWx1ZS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeVZhbHVlID49IHN0YWNrZWRZMCAmJiB5VmFsdWUgPD0gKHN0YWNrZWRZICsgc3RhY2tlZFkwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFRvSGlnaGxpZ2h0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhUb0hpZ2hsaWdodCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF0YVtpbmRleFRvSGlnaGxpZ2h0XS5oaWdobGlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSB4QXhpcy50aWNrRm9ybWF0KCkoY2hhcnQueCgpKHNpbmdsZVBvaW50LHBvaW50SW5kZXgpKTtcblxuICAgICAgICAgICAgICAgIC8vSWYgd2UgYXJlIGluICdleHBhbmQnIG1vZGUsIGZvcmNlIHRoZSBmb3JtYXQgdG8gYmUgYSBwZXJjZW50YWdlLlxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZUZvcm1hdHRlciA9IChzdGFja2VkLnN0eWxlKCkgPT0gJ2V4cGFuZCcpID9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZCxpKSB7cmV0dXJuIGQzLmZvcm1hdChcIi4xJVwiKShkKTt9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZCxpKSB7cmV0dXJuIHlBeGlzLnRpY2tGb3JtYXQoKShkKTsgfTtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLnRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgLnBvc2l0aW9uKHtsZWZ0OiBwb2ludFhMb2NhdGlvbiArIG1hcmdpbi5sZWZ0LCB0b3A6IGUubW91c2VZICsgbWFyZ2luLnRvcH0pXG4gICAgICAgICAgICAgICAgICAgIC5jaGFydENvbnRhaW5lcih0aGF0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIC5lbmFibGVkKHRvb2x0aXBzKVxuICAgICAgICAgICAgICAgICAgICAudmFsdWVGb3JtYXR0ZXIodmFsdWVGb3JtYXR0ZXIpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBhbGxEYXRhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApKCk7XG5cbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLnJlbmRlckd1aWRlTGluZShwb2ludFhMb2NhdGlvbik7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKFwiZWxlbWVudE1vdXNlb3V0XCIsZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKCk7XG4gICAgICAgICAgICAgICAgc3RhY2tlZC5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCd0b29sdGlwU2hvdycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcHMpIHNob3dUb29sdGlwKGUsIHRoYXQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNoYXJ0IGZyb20gYSBzdGF0ZSBvYmplY3QgcGFzc2VkIHRvIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCdjaGFuZ2VTdGF0ZScsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YS5sZW5ndGggPT09IGUuZGlzYWJsZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5zdHlsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZC5zdHlsZShlLnN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBlLnN0eWxlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdzdGFja2VkIEFyZWEgY2hhcnQgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgc3RhY2tlZC5kaXNwYXRjaC5vbigndG9vbHRpcFNob3cnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucG9zID0gW2UucG9zWzBdICsgbWFyZ2luLmxlZnQsIGUucG9zWzFdICsgbWFyZ2luLnRvcF07XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBTaG93KGUpO1xuICAgIH0pO1xuXG4gICAgc3RhY2tlZC5kaXNwYXRjaC5vbigndG9vbHRpcEhpZGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKGUpO1xuICAgIH0pO1xuXG4gICAgZGlzcGF0Y2gub24oJ3Rvb2x0aXBIaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0b29sdGlwcykgbnYudG9vbHRpcC5jbGVhbnVwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5zdGFja2VkID0gc3RhY2tlZDtcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQuY29udHJvbHMgPSBjb250cm9scztcbiAgICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICAgIGNoYXJ0LnlBeGlzID0geUF4aXM7XG4gICAgY2hhcnQuaW50ZXJhY3RpdmVMYXllciA9IGludGVyYWN0aXZlTGF5ZXI7XG5cbiAgICB5QXhpcy5zZXRUaWNrRm9ybWF0ID0geUF4aXMudGlja0Zvcm1hdDtcblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgc2hvd0xlZ2VuZDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0xlZ2VuZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dMZWdlbmQ9Xzt9fSxcbiAgICAgICAgc2hvd1hBeGlzOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dYQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dYQXhpcz1fO319LFxuICAgICAgICBzaG93WUF4aXM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dZQXhpcz1fO319LFxuICAgICAgICB0b29sdGlwczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcHM7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwcz1fO319LFxuICAgICAgICB0b29sdGlwQ29udGVudDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Rvb2x0aXA9Xzt9fSxcbiAgICAgICAgZGVmYXVsdFN0YXRlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZhdWx0U3RhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXtkZWZhdWx0U3RhdGU9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcbiAgICAgICAgc2hvd0NvbnRyb2xzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93Q29udHJvbHM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93Q29udHJvbHM9Xzt9fSxcbiAgICAgICAgY29udHJvbExhYmVsczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29udHJvbExhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2NvbnRyb2xMYWJlbHM9Xzt9fSxcbiAgICAgICAgeUF4aXNUaWNrRm9ybWF0OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5QXhpc1RpY2tGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKXt5QXhpc1RpY2tGb3JtYXQ9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICAgICAgc3RhY2tlZC5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB4QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB5QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgICAgIHN0YWNrZWQuY29sb3IoY29sb3IpO1xuICAgICAgICB9fSxcbiAgICAgICAgcmlnaHRBbGlnbllBeGlzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByaWdodEFsaWduWUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHJpZ2h0QWxpZ25ZQXhpcyA9IF87XG4gICAgICAgICAgICB5QXhpcy5vcmllbnQoIHJpZ2h0QWxpZ25ZQXhpcyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICB9fSxcbiAgICAgICAgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9ICEhXztcbiAgICAgICAgICAgIGlmIChfKSB7XG4gICAgICAgICAgICAgICAgY2hhcnQuaW50ZXJhY3RpdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVzZVZvcm9ub2koZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIHN0YWNrZWQpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52LnZlcnNpb24gPSBcIjEuNy4xXCI7XG59KSgpOyIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuLy9sb2FkaW5nIGhhY2tzXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8vbG9hZGluZyBqcXVlcnkgaXMgY29sbGlkaW5nIGluIEdJUyBtb2R1bGUsIHNvIHdlIG9ubHkgbG9hZCBpdCBpZlxuLy9pdCBpcyBub3QgbG9hZGVkIG9yIGlmIHRoZXJlIGlzIGEganF1ZXJ5IGxvYWRlZCBidXQgdmVyc2lvbiBpcyBvbGRlciB0aGFuIDIueC54XG5pZiAod2luZG93LiQgPT0gdW5kZWZpbmVkIHx8ICQuZm4uanF1ZXJ5LnNwbGl0KCcgJylbMF0uc3BsaXQoJy4nKVswXSA8IDIpIHtcbiAgd2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0gQmFja2JvbmUuJCA9IGpRdWVyeTtcbn1cblxudmFyIGJvb3RzdHJhcF9lbmFibGVkID0gKHR5cGVvZiAkKCkubW9kYWwgPT0gJ2Z1bmN0aW9uJyk7XG5pZiAoYm9vdHN0cmFwX2VuYWJsZWQpIHtcbiAgcmVxdWlyZSgnYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwJyk7XG59XG5cbnZhciBNZW51VmlldyA9IHJlcXVpcmUoJy4vc3JjL3ZpZXdzL21lbnUtdmlldy5qcycpO1xudmFyIEhlYWRlckZvb3RlclZpZXcgPSByZXF1aXJlKCcuL3NyYy92aWV3cy9oZWFkZXItZm9vdGVyLXZpZXcuanMnKTtcbnZhciBUcmFuc2xhdG9yID0gcmVxdWlyZSgnYW1wLXRyYW5zbGF0ZScpO1xuXG5cbi8qIGV4YW1wbGUgb2YgdXNlXG4gKiB0aGlzLm1lbnVzID0gbmV3IE1lbnVzKHtcbiAqICAgdHJhbnNsYXRvcjogdGhpcy50cmFuc2xhdG9yLFxuICogICBjYWxsZXI6ICdHSVMnXG4gKiB9KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIFdpZGdldCgpIHtcbiAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbl8uZXh0ZW5kKFdpZGdldC5wcm90b3R5cGUsIEJhY2tib25lLkV2ZW50cywge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgc2hvd0Zvb3RlckFkbWluOiB0cnVlLFxuICAgICAgc2hvd0RHRm9vdGVyOiB0cnVlLFxuICAgICAgc2hvd0xvZ2luOiB0cnVlLFxuICAgICAgdXNlU2luZ2xlUm93SGVhZGVyOiBmYWxzZVxuICAgIH0pO1xuICAgIGlmIChfLmhhcyhvcHRpb25zLCAnc3luYycpKSB7XG4gICAgICBCYWNrYm9uZS5zeW5jID0gb3B0aW9ucy5zeW5jO1xuICAgIH1cbiAgICB2YXIgZGVmYXVsdEtleXMgPSBKU09OLnBhcnNlKFwie1xcblxcXCJhbXAuY29tbW9uOmZvb3RlclxcXCI6IFxcXCJEZXZlbG9wZWQgaW4gcGFydG5lcnNoaXAgd2l0aCBPRUNELCBVTkRQLCBXQiwgR292ZXJubWVudCBvZiBFdGhpb3BpYSBhbmQgREdGXFxcIixcXG5cXFwiYW1wLmNvbW1vbjp0aXRsZVxcXCI6IFxcXCJBTVAgVG9vbGJhclxcXCIsXFxuXFxcImFtcC5jb21tb246dGl0bGUtaGVscFxcXCI6IFxcXCJIZWxwXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpzdWJ0aXRsZS1hbXAtaGVscFxcXCI6IFxcXCJBTVAgSGVscFxcXCIsXFxuXFxcImFtcC5jb21tb246c3VidGl0bGUtZ2xvc3NhcnlcXFwiOiBcXFwiR2xvc3NhcnlcXFwiLFxcblxcXCJhbXAuY29tbW9uOnN1YnRpdGxlLWVtYWlsLXN1cHBvcnQtdGVhbVxcXCI6IFxcXCJFbWFpbCBTdXBwb3J0IFRlYW1cXFwiLFxcblxcXCJhbXAuY29tbW9uOnRpdGxlLWxvZ291dFxcXCI6IFxcXCJMb2cgT3V0XFxcIixcXG5cXFwiYW1wLmNvbW1vbjpwbGF0Zm9ybVxcXCI6IFxcXCJBaWQgTWFuYWdlbWVudCBQbGF0Zm9ybSAoQU1QKVxcXCIsXFxuXFxcIlt0aXRsZV1hbXAuY29tbW9uOnBsYXRmb3JtXFxcIjogXFxcIkFpZCBNYW5hZ2VtZW50IFBsYXRmb3JtXFxcIixcXG5cXFwiYW1wLmNvbW1vbjpwbGF0Zm9ybS1zaG9ydFxcXCI6IFxcXCJBTVBcXFwiLFxcblxcXCJhbXAuY29tbW9uOnRpdGxlLWxvZ2luXFxcIjogXFxcIkxvZ2luXFxcIixcXG5cXFwiYW1wLmRhc2hib2FyZDpjbG9zZVxcXCI6IFxcXCJDbG9zZVxcXCIsXFxuXFxcImFtcC5hYm91dDptb2RhbC50aXRsZVxcXCI6IFxcXCJBYm91dCBBTVBcXFwiLFxcblxcXCJhbXAuYWJvdXQ6Y3JlZGl0c1xcXCI6IFxcXCJEZXZlbG9wZWQgaW4gcGFydG5lcnNoaXAgd2l0aCBPRUNELCBVTkRQLCBXQiwgR292ZXJubWVudCBvZiBFdGhpb3BpYSBhbmQgRGV2ZWxvcG1lbnQgR2F0ZXdheSBGb3VuZGF0aW9uLlxcXCIsXFxuXFxcImFtcC5hYm91dDp0cmFkZW1hcmtcXFwiOiBcXFwiVGhlIERldmVsb3BtZW50IEdhdGV3YXkgYW5kIHRoZSBUaGUgRGV2ZWxvcG1lbnQgR2F0ZXdheSBsb2dvIGFyZSB0cmFkZW1hcmtzIGZvciBUaGUgRGV2ZWxvcG1lbnQgR2F0ZXdheSBGb3VuZGF0aW9uXFxcIixcXG5cXFwiYW1wLmFib3V0OnJpZ2h0c1xcXCI6IFxcXCJBbGwgUmlnaHRzIFJlc2VydmVkXFxcIixcXG5cXFwiYW1wLmFib3V0OnZlcnNpb25cXFwiOiBcXFwiVmVyc2lvblxcXCJcXG59XFxuXFxuXCIpO1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKHtcbiAgICAgIGRlZmF1bHRLZXlzOiBkZWZhdWx0S2V5c1xuICAgIH0pO1xuICAgIG9wdGlvbnMudHJhbnNsYXRvciA9IHRoaXMudHJhbnNsYXRvcjtcblxuICAgIHRoaXMubWVudSA9IG5ldyBNZW51VmlldyhvcHRpb25zKTtcbiAgICB0aGlzLmhlYWRlckZvb3RlciA9IG5ldyBIZWFkZXJGb290ZXJWaWV3KG9wdGlvbnMpO1xuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmhlYWRlckZvb3RlciwgJ2FsbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1lbnUsICdhbGwnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0pO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAkLndoZW4odGhpcy5tZW51Lm1lbnVSZW5kZXJlZCwgdGhpcy5oZWFkZXJGb290ZXIubGF5b3V0RmV0Y2hlZCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuaGVhZGVyRm9vdGVyLnJlZnJlc2hVc2VyU2VjdGlvbigpO1xuICAgICAgc2VsZi50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTShkb2N1bWVudCk7XG4gICAgICBpZiAoJC5mbi5kcm9wZG93biAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICQoJy5kcm9wZG93bi10b2dnbGUnKS5kcm9wZG93bigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbGF5b3V0OiBXaWRnZXRcbn07XG53aW5kb3cuYm9pbGVycGxhdGUgPSBXaWRnZXQ7XG4iLCIvKiFcbiAqIEJvb3RzdHJhcCB2My4zLjAgKGh0dHA6Ly9nZXRib290c3RyYXAuY29tKVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICovXG5cbmlmICh0eXBlb2YgalF1ZXJ5ID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnknKVxufVxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgdmFyIHZlcnNpb24gPSAkLmZuLmpxdWVyeS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJylcbiAgaWYgKCh2ZXJzaW9uWzBdIDwgMiAmJiB2ZXJzaW9uWzFdIDwgOSkgfHwgKHZlcnNpb25bMF0gPT0gMSAmJiB2ZXJzaW9uWzFdID09IDkgJiYgdmVyc2lvblsyXSA8IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5IHZlcnNpb24gMS45LjEgb3IgaGlnaGVyJylcbiAgfVxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogdHJhbnNpdGlvbi5qcyB2My4zLjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3RyYW5zaXRpb25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ1NTIFRSQU5TSVRJT04gU1VQUE9SVCAoU2hvdXRvdXQ6IGh0dHA6Ly93d3cubW9kZXJuaXpyLmNvbS8pXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmQoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYm9vdHN0cmFwJylcblxuICAgIHZhciB0cmFuc0VuZEV2ZW50TmFtZXMgPSB7XG4gICAgICBXZWJraXRUcmFuc2l0aW9uIDogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICAgTW96VHJhbnNpdGlvbiAgICA6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAgIE9UcmFuc2l0aW9uICAgICAgOiAnb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQnLFxuICAgICAgdHJhbnNpdGlvbiAgICAgICA6ICd0cmFuc2l0aW9uZW5kJ1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gdHJhbnNFbmRFdmVudE5hbWVzKSB7XG4gICAgICBpZiAoZWwuc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4geyBlbmQ6IHRyYW5zRW5kRXZlbnROYW1lc1tuYW1lXSB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlIC8vIGV4cGxpY2l0IGZvciBpZTggKCAgLl8uKVxuICB9XG5cbiAgLy8gaHR0cDovL2Jsb2cuYWxleG1hY2Nhdy5jb20vY3NzLXRyYW5zaXRpb25zXG4gICQuZm4uZW11bGF0ZVRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcbiAgICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgICB2YXIgJGVsID0gdGhpc1xuICAgICQodGhpcykub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7IGNhbGxlZCA9IHRydWUgfSlcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7IGlmICghY2FsbGVkKSAkKCRlbCkudHJpZ2dlcigkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQpIH1cbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkdXJhdGlvbilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgJChmdW5jdGlvbiAoKSB7XG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRW5kKClcblxuICAgIGlmICghJC5zdXBwb3J0LnRyYW5zaXRpb24pIHJldHVyblxuXG4gICAgJC5ldmVudC5zcGVjaWFsLmJzVHJhbnNpdGlvbkVuZCA9IHtcbiAgICAgIGJpbmRUeXBlOiAkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsXG4gICAgICBkZWxlZ2F0ZVR5cGU6ICQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxcbiAgICAgIGhhbmRsZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKHRoaXMpKSByZXR1cm4gZS5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBhbGVydC5qcyB2My4zLjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2FsZXJ0c1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEFMRVJUIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBkaXNtaXNzID0gJ1tkYXRhLWRpc21pc3M9XCJhbGVydFwiXSdcbiAgdmFyIEFsZXJ0ICAgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAkKGVsKS5vbignY2xpY2snLCBkaXNtaXNzLCB0aGlzLmNsb3NlKVxuICB9XG5cbiAgQWxlcnQuVkVSU0lPTiA9ICczLjMuMCdcblxuICBBbGVydC5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwXG5cbiAgQWxlcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgICAgPSAkKHRoaXMpXG4gICAgdmFyIHNlbGVjdG9yID0gJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKVxuXG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgJiYgc2VsZWN0b3IucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLywgJycpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB9XG5cbiAgICB2YXIgJHBhcmVudCA9ICQoc2VsZWN0b3IpXG5cbiAgICBpZiAoZSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBpZiAoISRwYXJlbnQubGVuZ3RoKSB7XG4gICAgICAkcGFyZW50ID0gJHRoaXMuY2xvc2VzdCgnLmFsZXJ0JylcbiAgICB9XG5cbiAgICAkcGFyZW50LnRyaWdnZXIoZSA9ICQuRXZlbnQoJ2Nsb3NlLmJzLmFsZXJ0JykpXG5cbiAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAkcGFyZW50LnJlbW92ZUNsYXNzKCdpbicpXG5cbiAgICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KCkge1xuICAgICAgLy8gZGV0YWNoIGZyb20gcGFyZW50LCBmaXJlIGV2ZW50IHRoZW4gY2xlYW4gdXAgZGF0YVxuICAgICAgJHBhcmVudC5kZXRhY2goKS50cmlnZ2VyKCdjbG9zZWQuYnMuYWxlcnQnKS5yZW1vdmUoKVxuICAgIH1cblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmICRwYXJlbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAkcGFyZW50XG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIHJlbW92ZUVsZW1lbnQpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChBbGVydC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICByZW1vdmVFbGVtZW50KClcbiAgfVxuXG5cbiAgLy8gQUxFUlQgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgPSAkdGhpcy5kYXRhKCdicy5hbGVydCcpXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuYWxlcnQnLCAoZGF0YSA9IG5ldyBBbGVydCh0aGlzKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dLmNhbGwoJHRoaXMpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmFsZXJ0XG5cbiAgJC5mbi5hbGVydCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmFsZXJ0LkNvbnN0cnVjdG9yID0gQWxlcnRcblxuXG4gIC8vIEFMRVJUIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5hbGVydC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uYWxlcnQgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBBTEVSVCBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay5icy5hbGVydC5kYXRhLWFwaScsIGRpc21pc3MsIEFsZXJ0LnByb3RvdHlwZS5jbG9zZSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogYnV0dG9uLmpzIHYzLjMuMFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jYnV0dG9uc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEJVVFRPTiBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgQnV0dG9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ICA9ICQoZWxlbWVudClcbiAgICB0aGlzLm9wdGlvbnMgICA9ICQuZXh0ZW5kKHt9LCBCdXR0b24uREVGQVVMVFMsIG9wdGlvbnMpXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZVxuICB9XG5cbiAgQnV0dG9uLlZFUlNJT04gID0gJzMuMy4wJ1xuXG4gIEJ1dHRvbi5ERUZBVUxUUyA9IHtcbiAgICBsb2FkaW5nVGV4dDogJ2xvYWRpbmcuLi4nXG4gIH1cblxuICBCdXR0b24ucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIGQgICAgPSAnZGlzYWJsZWQnXG4gICAgdmFyICRlbCAgPSB0aGlzLiRlbGVtZW50XG4gICAgdmFyIHZhbCAgPSAkZWwuaXMoJ2lucHV0JykgPyAndmFsJyA6ICdodG1sJ1xuICAgIHZhciBkYXRhID0gJGVsLmRhdGEoKVxuXG4gICAgc3RhdGUgPSBzdGF0ZSArICdUZXh0J1xuXG4gICAgaWYgKGRhdGEucmVzZXRUZXh0ID09IG51bGwpICRlbC5kYXRhKCdyZXNldFRleHQnLCAkZWxbdmFsXSgpKVxuXG4gICAgLy8gcHVzaCB0byBldmVudCBsb29wIHRvIGFsbG93IGZvcm1zIHRvIHN1Ym1pdFxuICAgIHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAkZWxbdmFsXShkYXRhW3N0YXRlXSA9PSBudWxsID8gdGhpcy5vcHRpb25zW3N0YXRlXSA6IGRhdGFbc3RhdGVdKVxuXG4gICAgICBpZiAoc3RhdGUgPT0gJ2xvYWRpbmdUZXh0Jykge1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWVcbiAgICAgICAgJGVsLmFkZENsYXNzKGQpLmF0dHIoZCwgZClcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0xvYWRpbmcpIHtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZVxuICAgICAgICAkZWwucmVtb3ZlQ2xhc3MoZCkucmVtb3ZlQXR0cihkKVxuICAgICAgfVxuICAgIH0sIHRoaXMpLCAwKVxuICB9XG5cbiAgQnV0dG9uLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoYW5nZWQgPSB0cnVlXG4gICAgdmFyICRwYXJlbnQgPSB0aGlzLiRlbGVtZW50LmNsb3Nlc3QoJ1tkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIl0nKVxuXG4gICAgaWYgKCRwYXJlbnQubGVuZ3RoKSB7XG4gICAgICB2YXIgJGlucHV0ID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbnB1dCcpXG4gICAgICBpZiAoJGlucHV0LnByb3AoJ3R5cGUnKSA9PSAncmFkaW8nKSB7XG4gICAgICAgIGlmICgkaW5wdXQucHJvcCgnY2hlY2tlZCcpICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2FjdGl2ZScpKSBjaGFuZ2VkID0gZmFsc2VcbiAgICAgICAgZWxzZSAkcGFyZW50LmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgIH1cbiAgICAgIGlmIChjaGFuZ2VkKSAkaW5wdXQucHJvcCgnY2hlY2tlZCcsICF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhY3RpdmUnKSkudHJpZ2dlcignY2hhbmdlJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLXByZXNzZWQnLCAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpXG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZWQpIHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpXG4gIH1cblxuXG4gIC8vIEJVVFRPTiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuYnV0dG9uJylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5idXR0b24nLCAoZGF0YSA9IG5ldyBCdXR0b24odGhpcywgb3B0aW9ucykpKVxuXG4gICAgICBpZiAob3B0aW9uID09ICd0b2dnbGUnKSBkYXRhLnRvZ2dsZSgpXG4gICAgICBlbHNlIGlmIChvcHRpb24pIGRhdGEuc2V0U3RhdGUob3B0aW9uKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5idXR0b25cblxuICAkLmZuLmJ1dHRvbiAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmJ1dHRvbi5Db25zdHJ1Y3RvciA9IEJ1dHRvblxuXG5cbiAgLy8gQlVUVE9OIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYnV0dG9uLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5idXR0b24gPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBCVVRUT04gREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmJ1dHRvbi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciAkYnRuID0gJChlLnRhcmdldClcbiAgICAgIGlmICghJGJ0bi5oYXNDbGFzcygnYnRuJykpICRidG4gPSAkYnRuLmNsb3Nlc3QoJy5idG4nKVxuICAgICAgUGx1Z2luLmNhbGwoJGJ0biwgJ3RvZ2dsZScpXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICB9KVxuICAgIC5vbignZm9jdXMuYnMuYnV0dG9uLmRhdGEtYXBpIGJsdXIuYnMuYnV0dG9uLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgJChlLnRhcmdldCkuY2xvc2VzdCgnLmJ0bicpLnRvZ2dsZUNsYXNzKCdmb2N1cycsIGUudHlwZSA9PSAnZm9jdXMnKVxuICAgIH0pXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGNhcm91c2VsLmpzIHYzLjMuMFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jY2Fyb3VzZWxcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDQVJPVVNFTCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgQ2Fyb3VzZWwgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgICAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy4kaW5kaWNhdG9ycyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmNhcm91c2VsLWluZGljYXRvcnMnKVxuICAgIHRoaXMub3B0aW9ucyAgICAgPSBvcHRpb25zXG4gICAgdGhpcy5wYXVzZWQgICAgICA9XG4gICAgdGhpcy5zbGlkaW5nICAgICA9XG4gICAgdGhpcy5pbnRlcnZhbCAgICA9XG4gICAgdGhpcy4kYWN0aXZlICAgICA9XG4gICAgdGhpcy4kaXRlbXMgICAgICA9IG51bGxcblxuICAgIHRoaXMub3B0aW9ucy5rZXlib2FyZCAmJiB0aGlzLiRlbGVtZW50Lm9uKCdrZXlkb3duLmJzLmNhcm91c2VsJywgJC5wcm94eSh0aGlzLmtleWRvd24sIHRoaXMpKVxuXG4gICAgdGhpcy5vcHRpb25zLnBhdXNlID09ICdob3ZlcicgJiYgISgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpICYmIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vbignbW91c2VlbnRlci5icy5jYXJvdXNlbCcsICQucHJveHkodGhpcy5wYXVzZSwgdGhpcykpXG4gICAgICAub24oJ21vdXNlbGVhdmUuYnMuY2Fyb3VzZWwnLCAkLnByb3h5KHRoaXMuY3ljbGUsIHRoaXMpKVxuICB9XG5cbiAgQ2Fyb3VzZWwuVkVSU0lPTiAgPSAnMy4zLjAnXG5cbiAgQ2Fyb3VzZWwuVFJBTlNJVElPTl9EVVJBVElPTiA9IDYwMFxuXG4gIENhcm91c2VsLkRFRkFVTFRTID0ge1xuICAgIGludGVydmFsOiA1MDAwLFxuICAgIHBhdXNlOiAnaG92ZXInLFxuICAgIHdyYXA6IHRydWUsXG4gICAga2V5Ym9hcmQ6IHRydWVcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgIGNhc2UgMzc6IHRoaXMucHJldigpOyBicmVha1xuICAgICAgY2FzZSAzOTogdGhpcy5uZXh0KCk7IGJyZWFrXG4gICAgICBkZWZhdWx0OiByZXR1cm5cbiAgICB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5jeWNsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZSB8fCAodGhpcy5wYXVzZWQgPSBmYWxzZSlcblxuICAgIHRoaXMuaW50ZXJ2YWwgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKVxuXG4gICAgdGhpcy5vcHRpb25zLmludGVydmFsXG4gICAgICAmJiAhdGhpcy5wYXVzZWRcbiAgICAgICYmICh0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoJC5wcm94eSh0aGlzLm5leHQsIHRoaXMpLCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5nZXRJdGVtSW5kZXggPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHRoaXMuJGl0ZW1zID0gaXRlbS5wYXJlbnQoKS5jaGlsZHJlbignLml0ZW0nKVxuICAgIHJldHVybiB0aGlzLiRpdGVtcy5pbmRleChpdGVtIHx8IHRoaXMuJGFjdGl2ZSlcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5nZXRJdGVtRm9yRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgYWN0aXZlKSB7XG4gICAgdmFyIGRlbHRhID0gZGlyZWN0aW9uID09ICdwcmV2JyA/IC0xIDogMVxuICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0SXRlbUluZGV4KGFjdGl2ZSlcbiAgICB2YXIgaXRlbUluZGV4ID0gKGFjdGl2ZUluZGV4ICsgZGVsdGEpICUgdGhpcy4kaXRlbXMubGVuZ3RoXG4gICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmVxKGl0ZW1JbmRleClcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgdGhhdCAgICAgICAgPSB0aGlzXG4gICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5nZXRJdGVtSW5kZXgodGhpcy4kYWN0aXZlID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXRlbS5hY3RpdmUnKSlcblxuICAgIGlmIChwb3MgPiAodGhpcy4kaXRlbXMubGVuZ3RoIC0gMSkgfHwgcG9zIDwgMCkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5zbGlkaW5nKSAgICAgICByZXR1cm4gdGhpcy4kZWxlbWVudC5vbmUoJ3NsaWQuYnMuY2Fyb3VzZWwnLCBmdW5jdGlvbiAoKSB7IHRoYXQudG8ocG9zKSB9KSAvLyB5ZXMsIFwic2xpZFwiXG4gICAgaWYgKGFjdGl2ZUluZGV4ID09IHBvcykgcmV0dXJuIHRoaXMucGF1c2UoKS5jeWNsZSgpXG5cbiAgICByZXR1cm4gdGhpcy5zbGlkZShwb3MgPiBhY3RpdmVJbmRleCA/ICduZXh0JyA6ICdwcmV2JywgdGhpcy4kaXRlbXMuZXEocG9zKSlcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZSB8fCAodGhpcy5wYXVzZWQgPSB0cnVlKVxuXG4gICAgaWYgKHRoaXMuJGVsZW1lbnQuZmluZCgnLm5leHQsIC5wcmV2JykubGVuZ3RoICYmICQuc3VwcG9ydC50cmFuc2l0aW9uKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKVxuICAgICAgdGhpcy5jeWNsZSh0cnVlKVxuICAgIH1cblxuICAgIHRoaXMuaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc2xpZGluZykgcmV0dXJuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUoJ25leHQnKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc2xpZGluZykgcmV0dXJuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUoJ3ByZXYnKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLnNsaWRlID0gZnVuY3Rpb24gKHR5cGUsIG5leHQpIHtcbiAgICB2YXIgJGFjdGl2ZSAgID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXRlbS5hY3RpdmUnKVxuICAgIHZhciAkbmV4dCAgICAgPSBuZXh0IHx8IHRoaXMuZ2V0SXRlbUZvckRpcmVjdGlvbih0eXBlLCAkYWN0aXZlKVxuICAgIHZhciBpc0N5Y2xpbmcgPSB0aGlzLmludGVydmFsXG4gICAgdmFyIGRpcmVjdGlvbiA9IHR5cGUgPT0gJ25leHQnID8gJ2xlZnQnIDogJ3JpZ2h0J1xuICAgIHZhciBmYWxsYmFjayAgPSB0eXBlID09ICduZXh0JyA/ICdmaXJzdCcgOiAnbGFzdCdcbiAgICB2YXIgdGhhdCAgICAgID0gdGhpc1xuXG4gICAgaWYgKCEkbmV4dC5sZW5ndGgpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLndyYXApIHJldHVyblxuICAgICAgJG5leHQgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pdGVtJylbZmFsbGJhY2tdKClcbiAgICB9XG5cbiAgICBpZiAoJG5leHQuaGFzQ2xhc3MoJ2FjdGl2ZScpKSByZXR1cm4gKHRoaXMuc2xpZGluZyA9IGZhbHNlKVxuXG4gICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSAkbmV4dFswXVxuICAgIHZhciBzbGlkZUV2ZW50ID0gJC5FdmVudCgnc2xpZGUuYnMuY2Fyb3VzZWwnLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICB9KVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzbGlkZUV2ZW50KVxuICAgIGlmIChzbGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuc2xpZGluZyA9IHRydWVcblxuICAgIGlzQ3ljbGluZyAmJiB0aGlzLnBhdXNlKClcblxuICAgIGlmICh0aGlzLiRpbmRpY2F0b3JzLmxlbmd0aCkge1xuICAgICAgdGhpcy4kaW5kaWNhdG9ycy5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICB2YXIgJG5leHRJbmRpY2F0b3IgPSAkKHRoaXMuJGluZGljYXRvcnMuY2hpbGRyZW4oKVt0aGlzLmdldEl0ZW1JbmRleCgkbmV4dCldKVxuICAgICAgJG5leHRJbmRpY2F0b3IgJiYgJG5leHRJbmRpY2F0b3IuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgfVxuXG4gICAgdmFyIHNsaWRFdmVudCA9ICQuRXZlbnQoJ3NsaWQuYnMuY2Fyb3VzZWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXQsIGRpcmVjdGlvbjogZGlyZWN0aW9uIH0pIC8vIHllcywgXCJzbGlkXCJcbiAgICBpZiAoJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnc2xpZGUnKSkge1xuICAgICAgJG5leHQuYWRkQ2xhc3ModHlwZSlcbiAgICAgICRuZXh0WzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuICAgICAgJGFjdGl2ZS5hZGRDbGFzcyhkaXJlY3Rpb24pXG4gICAgICAkbmV4dC5hZGRDbGFzcyhkaXJlY3Rpb24pXG4gICAgICAkYWN0aXZlXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkbmV4dC5yZW1vdmVDbGFzcyhbdHlwZSwgZGlyZWN0aW9uXS5qb2luKCcgJykpLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoWydhY3RpdmUnLCBkaXJlY3Rpb25dLmpvaW4oJyAnKSlcbiAgICAgICAgICB0aGF0LnNsaWRpbmcgPSBmYWxzZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKHNsaWRFdmVudClcbiAgICAgICAgICB9LCAwKVxuICAgICAgICB9KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQ2Fyb3VzZWwuVFJBTlNJVElPTl9EVVJBVElPTilcbiAgICB9IGVsc2Uge1xuICAgICAgJGFjdGl2ZS5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICRuZXh0LmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgdGhpcy5zbGlkaW5nID0gZmFsc2VcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgfVxuXG4gICAgaXNDeWNsaW5nICYmIHRoaXMuY3ljbGUoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQ0FST1VTRUwgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuY2Fyb3VzZWwnKVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQ2Fyb3VzZWwuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pXG4gICAgICB2YXIgYWN0aW9uICA9IHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycgPyBvcHRpb24gOiBvcHRpb25zLnNsaWRlXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuY2Fyb3VzZWwnLCAoZGF0YSA9IG5ldyBDYXJvdXNlbCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnbnVtYmVyJykgZGF0YS50byhvcHRpb24pXG4gICAgICBlbHNlIGlmIChhY3Rpb24pIGRhdGFbYWN0aW9uXSgpXG4gICAgICBlbHNlIGlmIChvcHRpb25zLmludGVydmFsKSBkYXRhLnBhdXNlKCkuY3ljbGUoKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5jYXJvdXNlbFxuXG4gICQuZm4uY2Fyb3VzZWwgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5jYXJvdXNlbC5Db25zdHJ1Y3RvciA9IENhcm91c2VsXG5cblxuICAvLyBDQVJPVVNFTCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uY2Fyb3VzZWwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmNhcm91c2VsID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQ0FST1VTRUwgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICB2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaHJlZlxuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgIHZhciAkdGFyZ2V0ID0gJCgkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpIHx8IChocmVmID0gJHRoaXMuYXR0cignaHJlZicpKSAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSkgLy8gc3RyaXAgZm9yIGllN1xuICAgIGlmICghJHRhcmdldC5oYXNDbGFzcygnY2Fyb3VzZWwnKSkgcmV0dXJuXG4gICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJHRhcmdldC5kYXRhKCksICR0aGlzLmRhdGEoKSlcbiAgICB2YXIgc2xpZGVJbmRleCA9ICR0aGlzLmF0dHIoJ2RhdGEtc2xpZGUtdG8nKVxuICAgIGlmIChzbGlkZUluZGV4KSBvcHRpb25zLmludGVydmFsID0gZmFsc2VcblxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbnMpXG5cbiAgICBpZiAoc2xpZGVJbmRleCkge1xuICAgICAgJHRhcmdldC5kYXRhKCdicy5jYXJvdXNlbCcpLnRvKHNsaWRlSW5kZXgpXG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMuY2Fyb3VzZWwuZGF0YS1hcGknLCAnW2RhdGEtc2xpZGVdJywgY2xpY2tIYW5kbGVyKVxuICAgIC5vbignY2xpY2suYnMuY2Fyb3VzZWwuZGF0YS1hcGknLCAnW2RhdGEtc2xpZGUtdG9dJywgY2xpY2tIYW5kbGVyKVxuXG4gICQod2luZG93KS5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCdbZGF0YS1yaWRlPVwiY2Fyb3VzZWxcIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkY2Fyb3VzZWwgPSAkKHRoaXMpXG4gICAgICBQbHVnaW4uY2FsbCgkY2Fyb3VzZWwsICRjYXJvdXNlbC5kYXRhKCkpXG4gICAgfSlcbiAgfSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogY29sbGFwc2UuanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNjb2xsYXBzZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENPTExBUFNFIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIENvbGxhcHNlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ICAgICAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgICAgID0gJC5leHRlbmQoe30sIENvbGxhcHNlLkRFRkFVTFRTLCBvcHRpb25zKVxuICAgIHRoaXMuJHRyaWdnZXIgICAgICA9ICQodGhpcy5vcHRpb25zLnRyaWdnZXIpLmZpbHRlcignW2hyZWY9XCIjJyArIGVsZW1lbnQuaWQgKyAnXCJdLCBbZGF0YS10YXJnZXQ9XCIjJyArIGVsZW1lbnQuaWQgKyAnXCJdJylcbiAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSBudWxsXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudCkge1xuICAgICAgdGhpcy4kcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLiRlbGVtZW50LCB0aGlzLiR0cmlnZ2VyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudG9nZ2xlKSB0aGlzLnRvZ2dsZSgpXG4gIH1cblxuICBDb2xsYXBzZS5WRVJTSU9OICA9ICczLjMuMCdcblxuICBDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzUwXG5cbiAgQ29sbGFwc2UuREVGQVVMVFMgPSB7XG4gICAgdG9nZ2xlOiB0cnVlLFxuICAgIHRyaWdnZXI6ICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXSdcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5kaW1lbnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc1dpZHRoID0gdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnd2lkdGgnKVxuICAgIHJldHVybiBoYXNXaWR0aCA/ICd3aWR0aCcgOiAnaGVpZ2h0J1xuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbmluZyB8fCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpbicpKSByZXR1cm5cblxuICAgIHZhciBhY3RpdmVzRGF0YVxuICAgIHZhciBhY3RpdmVzID0gdGhpcy4kcGFyZW50ICYmIHRoaXMuJHBhcmVudC5maW5kKCc+IC5wYW5lbCcpLmNoaWxkcmVuKCcuaW4sIC5jb2xsYXBzaW5nJylcblxuICAgIGlmIChhY3RpdmVzICYmIGFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICBhY3RpdmVzRGF0YSA9IGFjdGl2ZXMuZGF0YSgnYnMuY29sbGFwc2UnKVxuICAgICAgaWYgKGFjdGl2ZXNEYXRhICYmIGFjdGl2ZXNEYXRhLnRyYW5zaXRpb25pbmcpIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudCgnc2hvdy5icy5jb2xsYXBzZScpXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKHN0YXJ0RXZlbnQpXG4gICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgaWYgKGFjdGl2ZXMgJiYgYWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgIFBsdWdpbi5jYWxsKGFjdGl2ZXMsICdoaWRlJylcbiAgICAgIGFjdGl2ZXNEYXRhIHx8IGFjdGl2ZXMuZGF0YSgnYnMuY29sbGFwc2UnLCBudWxsKVxuICAgIH1cblxuICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmRpbWVuc2lvbigpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpW2RpbWVuc2lvbl0oMClcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgIHRoaXMuJHRyaWdnZXJcbiAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2VkJylcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDFcblxuICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZSBpbicpW2RpbWVuc2lvbl0oJycpXG4gICAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSAwXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC50cmlnZ2VyKCdzaG93bi5icy5jb2xsYXBzZScpXG4gICAgfVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuIGNvbXBsZXRlLmNhbGwodGhpcylcblxuICAgIHZhciBzY3JvbGxTaXplID0gJC5jYW1lbENhc2UoWydzY3JvbGwnLCBkaW1lbnNpb25dLmpvaW4oJy0nKSlcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsICQucHJveHkoY29tcGxldGUsIHRoaXMpKVxuICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKENvbGxhcHNlLlRSQU5TSVRJT05fRFVSQVRJT04pW2RpbWVuc2lvbl0odGhpcy4kZWxlbWVudFswXVtzY3JvbGxTaXplXSlcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmcgfHwgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJykpIHJldHVyblxuXG4gICAgdmFyIHN0YXJ0RXZlbnQgPSAkLkV2ZW50KCdoaWRlLmJzLmNvbGxhcHNlJylcbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc3RhcnRFdmVudClcbiAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb24oKVxuXG4gICAgdGhpcy4kZWxlbWVudFtkaW1lbnNpb25dKHRoaXMuJGVsZW1lbnRbZGltZW5zaW9uXSgpKVswXS5vZmZzZXRIZWlnaHRcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlIGluJylcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICB0aGlzLiR0cmlnZ2VyXG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlZCcpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMVxuXG4gICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMFxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgICAgLnRyaWdnZXIoJ2hpZGRlbi5icy5jb2xsYXBzZScpXG4gICAgfVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuIGNvbXBsZXRlLmNhbGwodGhpcylcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIFtkaW1lbnNpb25dKDApXG4gICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KGNvbXBsZXRlLCB0aGlzKSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OKVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzW3RoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJykgPyAnaGlkZScgOiAnc2hvdyddKClcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICQodGhpcy5vcHRpb25zLnBhcmVudClcbiAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXBhcmVudD1cIicgKyB0aGlzLm9wdGlvbnMucGFyZW50ICsgJ1wiXScpXG4gICAgICAuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudClcbiAgICAgICAgdGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJGVsZW1lbnQpLCAkZWxlbWVudClcbiAgICAgIH0sIHRoaXMpKVxuICAgICAgLmVuZCgpXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzID0gZnVuY3Rpb24gKCRlbGVtZW50LCAkdHJpZ2dlcikge1xuICAgIHZhciBpc09wZW4gPSAkZWxlbWVudC5oYXNDbGFzcygnaW4nKVxuXG4gICAgJGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIGlzT3BlbilcbiAgICAkdHJpZ2dlclxuICAgICAgLnRvZ2dsZUNsYXNzKCdjb2xsYXBzZWQnLCAhaXNPcGVuKVxuICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYXJnZXRGcm9tVHJpZ2dlcigkdHJpZ2dlcikge1xuICAgIHZhciBocmVmXG4gICAgdmFyIHRhcmdldCA9ICR0cmlnZ2VyLmF0dHIoJ2RhdGEtdGFyZ2V0JylcbiAgICAgIHx8IChocmVmID0gJHRyaWdnZXIuYXR0cignaHJlZicpKSAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG5cbiAgICByZXR1cm4gJCh0YXJnZXQpXG4gIH1cblxuXG4gIC8vIENPTExBUFNFIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmNvbGxhcHNlJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIENvbGxhcHNlLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuXG4gICAgICBpZiAoIWRhdGEgJiYgb3B0aW9ucy50b2dnbGUgJiYgb3B0aW9uID09ICdzaG93Jykgb3B0aW9ucy50b2dnbGUgPSBmYWxzZVxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5jb2xsYXBzZScsIChkYXRhID0gbmV3IENvbGxhcHNlKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5jb2xsYXBzZVxuXG4gICQuZm4uY29sbGFwc2UgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5jb2xsYXBzZS5Db25zdHJ1Y3RvciA9IENvbGxhcHNlXG5cblxuICAvLyBDT0xMQVBTRSBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uY29sbGFwc2Uubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmNvbGxhcHNlID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQ09MTEFQU0UgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMuY29sbGFwc2UuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuXG4gICAgaWYgKCEkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIHZhciAkdGFyZ2V0ID0gZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJHRoaXMpXG4gICAgdmFyIGRhdGEgICAgPSAkdGFyZ2V0LmRhdGEoJ2JzLmNvbGxhcHNlJylcbiAgICB2YXIgb3B0aW9uICA9IGRhdGEgPyAndG9nZ2xlJyA6ICQuZXh0ZW5kKHt9LCAkdGhpcy5kYXRhKCksIHsgdHJpZ2dlcjogdGhpcyB9KVxuXG4gICAgUGx1Z2luLmNhbGwoJHRhcmdldCwgb3B0aW9uKVxuICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBkcm9wZG93bi5qcyB2My4zLjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Ryb3Bkb3duc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERST1BET1dOIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBiYWNrZHJvcCA9ICcuZHJvcGRvd24tYmFja2Ryb3AnXG4gIHZhciB0b2dnbGUgICA9ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSdcbiAgdmFyIERyb3Bkb3duID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAkKGVsZW1lbnQpLm9uKCdjbGljay5icy5kcm9wZG93bicsIHRoaXMudG9nZ2xlKVxuICB9XG5cbiAgRHJvcGRvd24uVkVSU0lPTiA9ICczLjMuMCdcblxuICBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG5cbiAgICBpZiAoJHRoaXMuaXMoJy5kaXNhYmxlZCwgOmRpc2FibGVkJykpIHJldHVyblxuXG4gICAgdmFyICRwYXJlbnQgID0gZ2V0UGFyZW50KCR0aGlzKVxuICAgIHZhciBpc0FjdGl2ZSA9ICRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKVxuXG4gICAgY2xlYXJNZW51cygpXG5cbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICEkcGFyZW50LmNsb3Nlc3QoJy5uYXZiYXItbmF2JykubGVuZ3RoKSB7XG4gICAgICAgIC8vIGlmIG1vYmlsZSB3ZSB1c2UgYSBiYWNrZHJvcCBiZWNhdXNlIGNsaWNrIGV2ZW50cyBkb24ndCBkZWxlZ2F0ZVxuICAgICAgICAkKCc8ZGl2IGNsYXNzPVwiZHJvcGRvd24tYmFja2Ryb3BcIi8+JykuaW5zZXJ0QWZ0ZXIoJCh0aGlzKSkub24oJ2NsaWNrJywgY2xlYXJNZW51cylcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfVxuICAgICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdzaG93LmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgJHRoaXNcbiAgICAgICAgLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpXG5cbiAgICAgICRwYXJlbnRcbiAgICAgICAgLnRvZ2dsZUNsYXNzKCdvcGVuJylcbiAgICAgICAgLnRyaWdnZXIoJ3Nob3duLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldClcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIS8oMzh8NDB8Mjd8MzIpLy50ZXN0KGUud2hpY2gpKSByZXR1cm5cblxuICAgIHZhciAkdGhpcyA9ICQodGhpcylcblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGlmICgkdGhpcy5pcygnLmRpc2FibGVkLCA6ZGlzYWJsZWQnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHBhcmVudCAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgdmFyIGlzQWN0aXZlID0gJHBhcmVudC5oYXNDbGFzcygnb3BlbicpXG5cbiAgICBpZiAoKCFpc0FjdGl2ZSAmJiBlLndoaWNoICE9IDI3KSB8fCAoaXNBY3RpdmUgJiYgZS53aGljaCA9PSAyNykpIHtcbiAgICAgIGlmIChlLndoaWNoID09IDI3KSAkcGFyZW50LmZpbmQodG9nZ2xlKS50cmlnZ2VyKCdmb2N1cycpXG4gICAgICByZXR1cm4gJHRoaXMudHJpZ2dlcignY2xpY2snKVxuICAgIH1cblxuICAgIHZhciBkZXNjID0gJyBsaTpub3QoLmRpdmlkZXIpOnZpc2libGUgYSdcbiAgICB2YXIgJGl0ZW1zID0gJHBhcmVudC5maW5kKCdbcm9sZT1cIm1lbnVcIl0nICsgZGVzYyArICcsIFtyb2xlPVwibGlzdGJveFwiXScgKyBkZXNjKVxuXG4gICAgaWYgKCEkaXRlbXMubGVuZ3RoKSByZXR1cm5cblxuICAgIHZhciBpbmRleCA9ICRpdGVtcy5pbmRleChlLnRhcmdldClcblxuICAgIGlmIChlLndoaWNoID09IDM4ICYmIGluZGV4ID4gMCkgICAgICAgICAgICAgICAgIGluZGV4LS0gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cFxuICAgIGlmIChlLndoaWNoID09IDQwICYmIGluZGV4IDwgJGl0ZW1zLmxlbmd0aCAtIDEpIGluZGV4KysgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb3duXG4gICAgaWYgKCF+aW5kZXgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDBcblxuICAgICRpdGVtcy5lcShpbmRleCkudHJpZ2dlcignZm9jdXMnKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJNZW51cyhlKSB7XG4gICAgaWYgKGUgJiYgZS53aGljaCA9PT0gMykgcmV0dXJuXG4gICAgJChiYWNrZHJvcCkucmVtb3ZlKClcbiAgICAkKHRvZ2dsZSkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICAgICAgICA9ICQodGhpcylcbiAgICAgIHZhciAkcGFyZW50ICAgICAgID0gZ2V0UGFyZW50KCR0aGlzKVxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfVxuXG4gICAgICBpZiAoISRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKSkgcmV0dXJuXG5cbiAgICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnaGlkZS5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICR0aGlzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKVxuICAgICAgJHBhcmVudC5yZW1vdmVDbGFzcygnb3BlbicpLnRyaWdnZXIoJ2hpZGRlbi5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcmVudCgkdGhpcykge1xuICAgIHZhciBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIC8jW0EtWmEtel0vLnRlc3Qoc2VsZWN0b3IpICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgdmFyICRwYXJlbnQgPSBzZWxlY3RvciAmJiAkKHNlbGVjdG9yKVxuXG4gICAgcmV0dXJuICRwYXJlbnQgJiYgJHBhcmVudC5sZW5ndGggPyAkcGFyZW50IDogJHRoaXMucGFyZW50KClcbiAgfVxuXG5cbiAgLy8gRFJPUERPV04gUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgPSAkdGhpcy5kYXRhKCdicy5kcm9wZG93bicpXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuZHJvcGRvd24nLCAoZGF0YSA9IG5ldyBEcm9wZG93bih0aGlzKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dLmNhbGwoJHRoaXMpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmRyb3Bkb3duXG5cbiAgJC5mbi5kcm9wZG93biAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yID0gRHJvcGRvd25cblxuXG4gIC8vIERST1BET1dOIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5kcm9wZG93bi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uZHJvcGRvd24gPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBBUFBMWSBUTyBTVEFOREFSRCBEUk9QRE9XTiBFTEVNRU5UU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIGNsZWFyTWVudXMpXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsICcuZHJvcGRvd24gZm9ybScsIGZ1bmN0aW9uIChlKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCkgfSlcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgdG9nZ2xlLCBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsIHRvZ2dsZSwgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJ1tyb2xlPVwibWVudVwiXScsIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsICdbcm9sZT1cImxpc3Rib3hcIl0nLCBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93bilcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogbW9kYWwuanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNtb2RhbHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBNT0RBTCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgTW9kYWwgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyAgICAgICAgPSBvcHRpb25zXG4gICAgdGhpcy4kYm9keSAgICAgICAgICA9ICQoZG9jdW1lbnQuYm9keSlcbiAgICB0aGlzLiRlbGVtZW50ICAgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuJGJhY2tkcm9wICAgICAgPVxuICAgIHRoaXMuaXNTaG93biAgICAgICAgPSBudWxsXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCA9IDBcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVtb3RlKSB7XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5maW5kKCcubW9kYWwtY29udGVudCcpXG4gICAgICAgIC5sb2FkKHRoaXMub3B0aW9ucy5yZW1vdGUsICQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignbG9hZGVkLmJzLm1vZGFsJylcbiAgICAgICAgfSwgdGhpcykpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwuVkVSU0lPTiAgPSAnMy4zLjAnXG5cbiAgTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTiA9IDMwMFxuICBNb2RhbC5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwXG5cbiAgTW9kYWwuREVGQVVMVFMgPSB7XG4gICAgYmFja2Ryb3A6IHRydWUsXG4gICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgc2hvdzogdHJ1ZVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChfcmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmlzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhfcmVsYXRlZFRhcmdldClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyIGUgICAgPSAkLkV2ZW50KCdzaG93LmJzLm1vZGFsJywgeyByZWxhdGVkVGFyZ2V0OiBfcmVsYXRlZFRhcmdldCB9KVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAodGhpcy5pc1Nob3duIHx8IGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdGhpcy5pc1Nob3duID0gdHJ1ZVxuXG4gICAgdGhpcy5jaGVja1Njcm9sbGJhcigpXG4gICAgdGhpcy4kYm9keS5hZGRDbGFzcygnbW9kYWwtb3BlbicpXG5cbiAgICB0aGlzLnNldFNjcm9sbGJhcigpXG4gICAgdGhpcy5lc2NhcGUoKVxuXG4gICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcsICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLCAkLnByb3h5KHRoaXMuaGlkZSwgdGhpcykpXG5cbiAgICB0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhhdC4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpXG5cbiAgICAgIGlmICghdGhhdC4kZWxlbWVudC5wYXJlbnQoKS5sZW5ndGgpIHtcbiAgICAgICAgdGhhdC4kZWxlbWVudC5hcHBlbmRUbyh0aGF0LiRib2R5KSAvLyBkb24ndCBtb3ZlIG1vZGFscyBkb20gcG9zaXRpb25cbiAgICAgIH1cblxuICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAuc2hvdygpXG4gICAgICAgIC5zY3JvbGxUb3AoMClcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhhdC4kZWxlbWVudFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcbiAgICAgIH1cblxuICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAuYWRkQ2xhc3MoJ2luJylcbiAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpXG5cbiAgICAgIHRoYXQuZW5mb3JjZUZvY3VzKClcblxuICAgICAgdmFyIGUgPSAkLkV2ZW50KCdzaG93bi5icy5tb2RhbCcsIHsgcmVsYXRlZFRhcmdldDogX3JlbGF0ZWRUYXJnZXQgfSlcblxuICAgICAgdHJhbnNpdGlvbiA/XG4gICAgICAgIHRoYXQuJGVsZW1lbnQuZmluZCgnLm1vZGFsLWRpYWxvZycpIC8vIHdhaXQgZm9yIG1vZGFsIHRvIHNsaWRlIGluXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpLnRyaWdnZXIoZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKGUpXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBlID0gJC5FdmVudCgnaGlkZS5icy5tb2RhbCcpXG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmICghdGhpcy5pc1Nob3duIHx8IGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdGhpcy5pc1Nob3duID0gZmFsc2VcblxuICAgIHRoaXMuZXNjYXBlKClcblxuICAgICQoZG9jdW1lbnQpLm9mZignZm9jdXNpbi5icy5tb2RhbCcpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAucmVtb3ZlQ2xhc3MoJ2luJylcbiAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpXG4gICAgICAub2ZmKCdjbGljay5kaXNtaXNzLmJzLm1vZGFsJylcblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsICQucHJveHkodGhpcy5oaWRlTW9kYWwsIHRoaXMpKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgdGhpcy5oaWRlTW9kYWwoKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmVuZm9yY2VGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAkKGRvY3VtZW50KVxuICAgICAgLm9mZignZm9jdXNpbi5icy5tb2RhbCcpIC8vIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxuICAgICAgLm9uKCdmb2N1c2luLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy4kZWxlbWVudFswXSAhPT0gZS50YXJnZXQgJiYgIXRoaXMuJGVsZW1lbnQuaGFzKGUudGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcykpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuZXNjYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzU2hvd24gJiYgdGhpcy5vcHRpb25zLmtleWJvYXJkKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdrZXlkb3duLmRpc21pc3MuYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUud2hpY2ggPT0gMjcgJiYgdGhpcy5oaWRlKClcbiAgICAgIH0sIHRoaXMpKVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTaG93bikge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ2tleWRvd24uZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmhpZGVNb2RhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB0aGlzLiRlbGVtZW50LmhpZGUoKVxuICAgIHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC4kYm9keS5yZW1vdmVDbGFzcygnbW9kYWwtb3BlbicpXG4gICAgICB0aGF0LnJlc2V0U2Nyb2xsYmFyKClcbiAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignaGlkZGVuLmJzLm1vZGFsJylcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlbW92ZUJhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGJhY2tkcm9wICYmIHRoaXMuJGJhY2tkcm9wLnJlbW92ZSgpXG4gICAgdGhpcy4kYmFja2Ryb3AgPSBudWxsXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuYmFja2Ryb3AgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB2YXIgYW5pbWF0ZSA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/ICdmYWRlJyA6ICcnXG5cbiAgICBpZiAodGhpcy5pc1Nob3duICYmIHRoaXMub3B0aW9ucy5iYWNrZHJvcCkge1xuICAgICAgdmFyIGRvQW5pbWF0ZSA9ICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIGFuaW1hdGVcblxuICAgICAgdGhpcy4kYmFja2Ryb3AgPSAkKCc8ZGl2IGNsYXNzPVwibW9kYWwtYmFja2Ryb3AgJyArIGFuaW1hdGUgKyAnXCIgLz4nKVxuICAgICAgICAucHJlcGVuZFRvKHRoaXMuJGVsZW1lbnQpXG4gICAgICAgIC5vbignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCkgcmV0dXJuXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmJhY2tkcm9wID09ICdzdGF0aWMnXG4gICAgICAgICAgICA/IHRoaXMuJGVsZW1lbnRbMF0uZm9jdXMuY2FsbCh0aGlzLiRlbGVtZW50WzBdKVxuICAgICAgICAgICAgOiB0aGlzLmhpZGUuY2FsbCh0aGlzKVxuICAgICAgICB9LCB0aGlzKSlcblxuICAgICAgaWYgKGRvQW5pbWF0ZSkgdGhpcy4kYmFja2Ryb3BbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG5cbiAgICAgIHRoaXMuJGJhY2tkcm9wLmFkZENsYXNzKCdpbicpXG5cbiAgICAgIGlmICghY2FsbGJhY2spIHJldHVyblxuXG4gICAgICBkb0FuaW1hdGUgP1xuICAgICAgICB0aGlzLiRiYWNrZHJvcFxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNhbGxiYWNrKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIGNhbGxiYWNrKClcblxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTaG93biAmJiB0aGlzLiRiYWNrZHJvcCkge1xuICAgICAgdGhpcy4kYmFja2Ryb3AucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgICAgdmFyIGNhbGxiYWNrUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0LnJlbW92ZUJhY2tkcm9wKClcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgfVxuICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICAgdGhpcy4kYmFja2Ryb3BcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjYWxsYmFja1JlbW92ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjYWxsYmFja1JlbW92ZSgpXG5cbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmNoZWNrU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggPSB0aGlzLm1lYXN1cmVTY3JvbGxiYXIoKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm9keVBhZCA9IHBhcnNlSW50KCh0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcpIHx8IDApLCAxMClcbiAgICBpZiAodGhpcy5zY3JvbGxiYXJXaWR0aCkgdGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBib2R5UGFkICsgdGhpcy5zY3JvbGxiYXJXaWR0aClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZXNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcsICcnKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLm1lYXN1cmVTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7IC8vIHRoeCB3YWxzaFxuICAgIGlmIChkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoID49IHdpbmRvdy5pbm5lcldpZHRoKSByZXR1cm4gMFxuICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHNjcm9sbERpdi5jbGFzc05hbWUgPSAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnXG4gICAgdGhpcy4kYm9keS5hcHBlbmQoc2Nyb2xsRGl2KVxuICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aFxuICAgIHRoaXMuJGJvZHlbMF0ucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KVxuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aFxuICB9XG5cblxuICAvLyBNT0RBTCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24sIF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMubW9kYWwnKVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTW9kYWwuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMubW9kYWwnLCAoZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKF9yZWxhdGVkVGFyZ2V0KVxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5zaG93KSBkYXRhLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLm1vZGFsXG5cbiAgJC5mbi5tb2RhbCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLm1vZGFsLkNvbnN0cnVjdG9yID0gTW9kYWxcblxuXG4gIC8vIE1PREFMIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5tb2RhbC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4ubW9kYWwgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBNT0RBTCBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay5icy5tb2RhbC5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgdmFyIGhyZWYgICAgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICB2YXIgJHRhcmdldCA9ICQoJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSB8fCAoaHJlZiAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSkpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB2YXIgb3B0aW9uICA9ICR0YXJnZXQuZGF0YSgnYnMubW9kYWwnKSA/ICd0b2dnbGUnIDogJC5leHRlbmQoeyByZW1vdGU6ICEvIy8udGVzdChocmVmKSAmJiBocmVmIH0sICR0YXJnZXQuZGF0YSgpLCAkdGhpcy5kYXRhKCkpXG5cbiAgICBpZiAoJHRoaXMuaXMoJ2EnKSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAkdGFyZ2V0Lm9uZSgnc2hvdy5icy5tb2RhbCcsIGZ1bmN0aW9uIChzaG93RXZlbnQpIHtcbiAgICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVybiAvLyBvbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXG4gICAgICAkdGFyZ2V0Lm9uZSgnaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAkdGhpcy5pcygnOnZpc2libGUnKSAmJiAkdGhpcy50cmlnZ2VyKCdmb2N1cycpXG4gICAgICB9KVxuICAgIH0pXG4gICAgUGx1Z2luLmNhbGwoJHRhcmdldCwgb3B0aW9uLCB0aGlzKVxuICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0b29sdGlwLmpzIHYzLjMuMFxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdG9vbHRpcFxuICogSW5zcGlyZWQgYnkgdGhlIG9yaWdpbmFsIGpRdWVyeS50aXBzeSBieSBKYXNvbiBGcmFtZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE0IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFRPT0xUSVAgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBUb29sdGlwID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgICAgICAgPVxuICAgIHRoaXMub3B0aW9ucyAgICA9XG4gICAgdGhpcy5lbmFibGVkICAgID1cbiAgICB0aGlzLnRpbWVvdXQgICAgPVxuICAgIHRoaXMuaG92ZXJTdGF0ZSA9XG4gICAgdGhpcy4kZWxlbWVudCAgID0gbnVsbFxuXG4gICAgdGhpcy5pbml0KCd0b29sdGlwJywgZWxlbWVudCwgb3B0aW9ucylcbiAgfVxuXG4gIFRvb2x0aXAuVkVSU0lPTiAgPSAnMy4zLjAnXG5cbiAgVG9vbHRpcC5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwXG5cbiAgVG9vbHRpcC5ERUZBVUxUUyA9IHtcbiAgICBhbmltYXRpb246IHRydWUsXG4gICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICBzZWxlY3RvcjogZmFsc2UsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj48ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PjwvZGl2PicsXG4gICAgdHJpZ2dlcjogJ2hvdmVyIGZvY3VzJyxcbiAgICB0aXRsZTogJycsXG4gICAgZGVsYXk6IDAsXG4gICAgaHRtbDogZmFsc2UsXG4gICAgY29udGFpbmVyOiBmYWxzZSxcbiAgICB2aWV3cG9ydDoge1xuICAgICAgc2VsZWN0b3I6ICdib2R5JyxcbiAgICAgIHBhZGRpbmc6IDBcbiAgICB9XG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHR5cGUsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVuYWJsZWQgICA9IHRydWVcbiAgICB0aGlzLnR5cGUgICAgICA9IHR5cGVcbiAgICB0aGlzLiRlbGVtZW50ICA9ICQoZWxlbWVudClcbiAgICB0aGlzLm9wdGlvbnMgICA9IHRoaXMuZ2V0T3B0aW9ucyhvcHRpb25zKVxuICAgIHRoaXMuJHZpZXdwb3J0ID0gdGhpcy5vcHRpb25zLnZpZXdwb3J0ICYmICQodGhpcy5vcHRpb25zLnZpZXdwb3J0LnNlbGVjdG9yIHx8IHRoaXMub3B0aW9ucy52aWV3cG9ydClcblxuICAgIHZhciB0cmlnZ2VycyA9IHRoaXMub3B0aW9ucy50cmlnZ2VyLnNwbGl0KCcgJylcblxuICAgIGZvciAodmFyIGkgPSB0cmlnZ2Vycy5sZW5ndGg7IGktLTspIHtcbiAgICAgIHZhciB0cmlnZ2VyID0gdHJpZ2dlcnNbaV1cblxuICAgICAgaWYgKHRyaWdnZXIgPT0gJ2NsaWNrJykge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay4nICsgdGhpcy50eXBlLCB0aGlzLm9wdGlvbnMuc2VsZWN0b3IsICQucHJveHkodGhpcy50b2dnbGUsIHRoaXMpKVxuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9ICdtYW51YWwnKSB7XG4gICAgICAgIHZhciBldmVudEluICA9IHRyaWdnZXIgPT0gJ2hvdmVyJyA/ICdtb3VzZWVudGVyJyA6ICdmb2N1c2luJ1xuICAgICAgICB2YXIgZXZlbnRPdXQgPSB0cmlnZ2VyID09ICdob3ZlcicgPyAnbW91c2VsZWF2ZScgOiAnZm9jdXNvdXQnXG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbihldmVudEluICArICcuJyArIHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLnNlbGVjdG9yLCAkLnByb3h5KHRoaXMuZW50ZXIsIHRoaXMpKVxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKGV2ZW50T3V0ICsgJy4nICsgdGhpcy50eXBlLCB0aGlzLm9wdGlvbnMuc2VsZWN0b3IsICQucHJveHkodGhpcy5sZWF2ZSwgdGhpcykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLnNlbGVjdG9yID9cbiAgICAgICh0aGlzLl9vcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgeyB0cmlnZ2VyOiAnbWFudWFsJywgc2VsZWN0b3I6ICcnIH0pKSA6XG4gICAgICB0aGlzLmZpeFRpdGxlKClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldERlZmF1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUb29sdGlwLkRFRkFVTFRTXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMuZ2V0RGVmYXVsdHMoKSwgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpXG5cbiAgICBpZiAob3B0aW9ucy5kZWxheSAmJiB0eXBlb2Ygb3B0aW9ucy5kZWxheSA9PSAnbnVtYmVyJykge1xuICAgICAgb3B0aW9ucy5kZWxheSA9IHtcbiAgICAgICAgc2hvdzogb3B0aW9ucy5kZWxheSxcbiAgICAgICAgaGlkZTogb3B0aW9ucy5kZWxheVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXREZWxlZ2F0ZU9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgID0ge31cbiAgICB2YXIgZGVmYXVsdHMgPSB0aGlzLmdldERlZmF1bHRzKClcblxuICAgIHRoaXMuX29wdGlvbnMgJiYgJC5lYWNoKHRoaXMuX29wdGlvbnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoZGVmYXVsdHNba2V5XSAhPSB2YWx1ZSkgb3B0aW9uc1trZXldID0gdmFsdWVcbiAgICB9KVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBzZWxmID0gb2JqIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciA/XG4gICAgICBvYmogOiAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuXG4gICAgaWYgKHNlbGYgJiYgc2VsZi4kdGlwICYmIHNlbGYuJHRpcC5pcygnOnZpc2libGUnKSkge1xuICAgICAgc2VsZi5ob3ZlclN0YXRlID0gJ2luJ1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFzZWxmKSB7XG4gICAgICBzZWxmID0gbmV3IHRoaXMuY29uc3RydWN0b3Iob2JqLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXQpXG5cbiAgICBzZWxmLmhvdmVyU3RhdGUgPSAnaW4nXG5cbiAgICBpZiAoIXNlbGYub3B0aW9ucy5kZWxheSB8fCAhc2VsZi5vcHRpb25zLmRlbGF5LnNob3cpIHJldHVybiBzZWxmLnNob3coKVxuXG4gICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5ob3ZlclN0YXRlID09ICdpbicpIHNlbGYuc2hvdygpXG4gICAgfSwgc2VsZi5vcHRpb25zLmRlbGF5LnNob3cpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgc2VsZiA9IG9iaiBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IgP1xuICAgICAgb2JqIDogJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGlmICghc2VsZikge1xuICAgICAgc2VsZiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG9iai5jdXJyZW50VGFyZ2V0LCB0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKVxuICAgICAgJChvYmouY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgc2VsZilcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KVxuXG4gICAgc2VsZi5ob3ZlclN0YXRlID0gJ291dCdcblxuICAgIGlmICghc2VsZi5vcHRpb25zLmRlbGF5IHx8ICFzZWxmLm9wdGlvbnMuZGVsYXkuaGlkZSkgcmV0dXJuIHNlbGYuaGlkZSgpXG5cbiAgICBzZWxmLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmhvdmVyU3RhdGUgPT0gJ291dCcpIHNlbGYuaGlkZSgpXG4gICAgfSwgc2VsZi5vcHRpb25zLmRlbGF5LmhpZGUpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gJC5FdmVudCgnc2hvdy5icy4nICsgdGhpcy50eXBlKVxuXG4gICAgaWYgKHRoaXMuaGFzQ29udGVudCgpICYmIHRoaXMuZW5hYmxlZCkge1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICAgIHZhciBpbkRvbSA9ICQuY29udGFpbnModGhpcy4kZWxlbWVudFswXS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy4kZWxlbWVudFswXSlcbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8ICFpbkRvbSkgcmV0dXJuXG4gICAgICB2YXIgdGhhdCA9IHRoaXNcblxuICAgICAgdmFyICR0aXAgPSB0aGlzLnRpcCgpXG5cbiAgICAgIHZhciB0aXBJZCA9IHRoaXMuZ2V0VUlEKHRoaXMudHlwZSlcblxuICAgICAgdGhpcy5zZXRDb250ZW50KClcbiAgICAgICR0aXAuYXR0cignaWQnLCB0aXBJZClcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1kZXNjcmliZWRieScsIHRpcElkKVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbikgJHRpcC5hZGRDbGFzcygnZmFkZScpXG5cbiAgICAgIHZhciBwbGFjZW1lbnQgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlbWVudCA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudC5jYWxsKHRoaXMsICR0aXBbMF0sIHRoaXMuJGVsZW1lbnRbMF0pIDpcbiAgICAgICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudFxuXG4gICAgICB2YXIgYXV0b1Rva2VuID0gL1xccz9hdXRvP1xccz8vaVxuICAgICAgdmFyIGF1dG9QbGFjZSA9IGF1dG9Ub2tlbi50ZXN0KHBsYWNlbWVudClcbiAgICAgIGlmIChhdXRvUGxhY2UpIHBsYWNlbWVudCA9IHBsYWNlbWVudC5yZXBsYWNlKGF1dG9Ub2tlbiwgJycpIHx8ICd0b3AnXG5cbiAgICAgICR0aXBcbiAgICAgICAgLmRldGFjaCgpXG4gICAgICAgIC5jc3MoeyB0b3A6IDAsIGxlZnQ6IDAsIGRpc3BsYXk6ICdibG9jaycgfSlcbiAgICAgICAgLmFkZENsYXNzKHBsYWNlbWVudClcbiAgICAgICAgLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHRoaXMpXG5cbiAgICAgIHRoaXMub3B0aW9ucy5jb250YWluZXIgPyAkdGlwLmFwcGVuZFRvKHRoaXMub3B0aW9ucy5jb250YWluZXIpIDogJHRpcC5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KVxuXG4gICAgICB2YXIgcG9zICAgICAgICAgID0gdGhpcy5nZXRQb3NpdGlvbigpXG4gICAgICB2YXIgYWN0dWFsV2lkdGggID0gJHRpcFswXS5vZmZzZXRXaWR0aFxuICAgICAgdmFyIGFjdHVhbEhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICAgIGlmIChhdXRvUGxhY2UpIHtcbiAgICAgICAgdmFyIG9yZ1BsYWNlbWVudCA9IHBsYWNlbWVudFxuICAgICAgICB2YXIgJGNvbnRhaW5lciAgID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lciA/ICQodGhpcy5vcHRpb25zLmNvbnRhaW5lcikgOiB0aGlzLiRlbGVtZW50LnBhcmVudCgpXG4gICAgICAgIHZhciBjb250YWluZXJEaW0gPSB0aGlzLmdldFBvc2l0aW9uKCRjb250YWluZXIpXG5cbiAgICAgICAgcGxhY2VtZW50ID0gcGxhY2VtZW50ID09ICdib3R0b20nICYmIHBvcy5ib3R0b20gKyBhY3R1YWxIZWlnaHQgPiBjb250YWluZXJEaW0uYm90dG9tID8gJ3RvcCcgICAgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ3RvcCcgICAgJiYgcG9zLnRvcCAgICAtIGFjdHVhbEhlaWdodCA8IGNvbnRhaW5lckRpbS50b3AgICAgPyAnYm90dG9tJyA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAncmlnaHQnICAmJiBwb3MucmlnaHQgICsgYWN0dWFsV2lkdGggID4gY29udGFpbmVyRGltLndpZHRoICA/ICdsZWZ0JyAgIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICdsZWZ0JyAgICYmIHBvcy5sZWZ0ICAgLSBhY3R1YWxXaWR0aCAgPCBjb250YWluZXJEaW0ubGVmdCAgID8gJ3JpZ2h0JyAgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRcblxuICAgICAgICAkdGlwXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKG9yZ1BsYWNlbWVudClcbiAgICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KVxuICAgICAgfVxuXG4gICAgICB2YXIgY2FsY3VsYXRlZE9mZnNldCA9IHRoaXMuZ2V0Q2FsY3VsYXRlZE9mZnNldChwbGFjZW1lbnQsIHBvcywgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodClcblxuICAgICAgdGhpcy5hcHBseVBsYWNlbWVudChjYWxjdWxhdGVkT2Zmc2V0LCBwbGFjZW1lbnQpXG5cbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXZIb3ZlclN0YXRlID0gdGhhdC5ob3ZlclN0YXRlXG4gICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignc2hvd24uYnMuJyArIHRoYXQudHlwZSlcbiAgICAgICAgdGhhdC5ob3ZlclN0YXRlID0gbnVsbFxuXG4gICAgICAgIGlmIChwcmV2SG92ZXJTdGF0ZSA9PSAnb3V0JykgdGhhdC5sZWF2ZSh0aGF0KVxuICAgICAgfVxuXG4gICAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiR0aXAuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgICR0aXBcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjb21wbGV0ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVG9vbHRpcC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIGNvbXBsZXRlKClcbiAgICB9XG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5hcHBseVBsYWNlbWVudCA9IGZ1bmN0aW9uIChvZmZzZXQsIHBsYWNlbWVudCkge1xuICAgIHZhciAkdGlwICAgPSB0aGlzLnRpcCgpXG4gICAgdmFyIHdpZHRoICA9ICR0aXBbMF0ub2Zmc2V0V2lkdGhcbiAgICB2YXIgaGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgIC8vIG1hbnVhbGx5IHJlYWQgbWFyZ2lucyBiZWNhdXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpbmNsdWRlcyBkaWZmZXJlbmNlXG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlSW50KCR0aXAuY3NzKCdtYXJnaW4tdG9wJyksIDEwKVxuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VJbnQoJHRpcC5jc3MoJ21hcmdpbi1sZWZ0JyksIDEwKVxuXG4gICAgLy8gd2UgbXVzdCBjaGVjayBmb3IgTmFOIGZvciBpZSA4LzlcbiAgICBpZiAoaXNOYU4obWFyZ2luVG9wKSkgIG1hcmdpblRvcCAgPSAwXG4gICAgaWYgKGlzTmFOKG1hcmdpbkxlZnQpKSBtYXJnaW5MZWZ0ID0gMFxuXG4gICAgb2Zmc2V0LnRvcCAgPSBvZmZzZXQudG9wICArIG1hcmdpblRvcFxuICAgIG9mZnNldC5sZWZ0ID0gb2Zmc2V0LmxlZnQgKyBtYXJnaW5MZWZ0XG5cbiAgICAvLyAkLmZuLm9mZnNldCBkb2Vzbid0IHJvdW5kIHBpeGVsIHZhbHVlc1xuICAgIC8vIHNvIHdlIHVzZSBzZXRPZmZzZXQgZGlyZWN0bHkgd2l0aCBvdXIgb3duIGZ1bmN0aW9uIEItMFxuICAgICQub2Zmc2V0LnNldE9mZnNldCgkdGlwWzBdLCAkLmV4dGVuZCh7XG4gICAgICB1c2luZzogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICR0aXAuY3NzKHtcbiAgICAgICAgICB0b3A6IE1hdGgucm91bmQocHJvcHMudG9wKSxcbiAgICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKHByb3BzLmxlZnQpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSwgb2Zmc2V0KSwgMClcblxuICAgICR0aXAuYWRkQ2xhc3MoJ2luJylcblxuICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBwbGFjaW5nIHRpcCBpbiBuZXcgb2Zmc2V0IGNhdXNlZCB0aGUgdGlwIHRvIHJlc2l6ZSBpdHNlbGZcbiAgICB2YXIgYWN0dWFsV2lkdGggID0gJHRpcFswXS5vZmZzZXRXaWR0aFxuICAgIHZhciBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodFxuXG4gICAgaWYgKHBsYWNlbWVudCA9PSAndG9wJyAmJiBhY3R1YWxIZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICBvZmZzZXQudG9wID0gb2Zmc2V0LnRvcCArIGhlaWdodCAtIGFjdHVhbEhlaWdodFxuICAgIH1cblxuICAgIHZhciBkZWx0YSA9IHRoaXMuZ2V0Vmlld3BvcnRBZGp1c3RlZERlbHRhKHBsYWNlbWVudCwgb2Zmc2V0LCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KVxuXG4gICAgaWYgKGRlbHRhLmxlZnQpIG9mZnNldC5sZWZ0ICs9IGRlbHRhLmxlZnRcbiAgICBlbHNlIG9mZnNldC50b3AgKz0gZGVsdGEudG9wXG5cbiAgICB2YXIgaXNWZXJ0aWNhbCAgICAgICAgICA9IC90b3B8Ym90dG9tLy50ZXN0KHBsYWNlbWVudClcbiAgICB2YXIgYXJyb3dEZWx0YSAgICAgICAgICA9IGlzVmVydGljYWwgPyBkZWx0YS5sZWZ0ICogMiAtIHdpZHRoICsgYWN0dWFsV2lkdGggOiBkZWx0YS50b3AgKiAyIC0gaGVpZ2h0ICsgYWN0dWFsSGVpZ2h0XG4gICAgdmFyIGFycm93T2Zmc2V0UG9zaXRpb24gPSBpc1ZlcnRpY2FsID8gJ29mZnNldFdpZHRoJyA6ICdvZmZzZXRIZWlnaHQnXG5cbiAgICAkdGlwLm9mZnNldChvZmZzZXQpXG4gICAgdGhpcy5yZXBsYWNlQXJyb3coYXJyb3dEZWx0YSwgJHRpcFswXVthcnJvd09mZnNldFBvc2l0aW9uXSwgaXNWZXJ0aWNhbClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnJlcGxhY2VBcnJvdyA9IGZ1bmN0aW9uIChkZWx0YSwgZGltZW5zaW9uLCBpc0hvcml6b250YWwpIHtcbiAgICB0aGlzLmFycm93KClcbiAgICAgIC5jc3MoaXNIb3Jpem9udGFsID8gJ2xlZnQnIDogJ3RvcCcsIDUwICogKDEgLSBkZWx0YSAvIGRpbWVuc2lvbikgKyAnJScpXG4gICAgICAuY3NzKGlzSG9yaXpvbnRhbCA/ICd0b3AnIDogJ2xlZnQnLCAnJylcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICR0aXAgID0gdGhpcy50aXAoKVxuICAgIHZhciB0aXRsZSA9IHRoaXMuZ2V0VGl0bGUoKVxuXG4gICAgJHRpcC5maW5kKCcudG9vbHRpcC1pbm5lcicpW3RoaXMub3B0aW9ucy5odG1sID8gJ2h0bWwnIDogJ3RleHQnXSh0aXRsZSlcbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdmYWRlIGluIHRvcCBib3R0b20gbGVmdCByaWdodCcpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyICR0aXAgPSB0aGlzLnRpcCgpXG4gICAgdmFyIGUgICAgPSAkLkV2ZW50KCdoaWRlLmJzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgIGlmICh0aGF0LmhvdmVyU3RhdGUgIT0gJ2luJykgJHRpcC5kZXRhY2goKVxuICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieScpXG4gICAgICAgIC50cmlnZ2VyKCdoaWRkZW4uYnMuJyArIHRoYXQudHlwZSlcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICR0aXAucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJHRpcC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICR0aXBcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY29tcGxldGUpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChUb29sdGlwLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIGNvbXBsZXRlKClcblxuICAgIHRoaXMuaG92ZXJTdGF0ZSA9IG51bGxcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5maXhUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50XG4gICAgaWYgKCRlLmF0dHIoJ3RpdGxlJykgfHwgdHlwZW9mICgkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJykpICE9ICdzdHJpbmcnKSB7XG4gICAgICAkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJywgJGUuYXR0cigndGl0bGUnKSB8fCAnJykuYXR0cigndGl0bGUnLCAnJylcbiAgICB9XG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5oYXNDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpdGxlKClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCRlbGVtZW50KSB7XG4gICAgJGVsZW1lbnQgICA9ICRlbGVtZW50IHx8IHRoaXMuJGVsZW1lbnRcblxuICAgIHZhciBlbCAgICAgPSAkZWxlbWVudFswXVxuICAgIHZhciBpc0JvZHkgPSBlbC50YWdOYW1lID09ICdCT0RZJ1xuXG4gICAgdmFyIGVsUmVjdCAgICA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgaWYgKGVsUmVjdC53aWR0aCA9PSBudWxsKSB7XG4gICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBtaXNzaW5nIGluIElFOCwgc28gY29tcHV0ZSB0aGVtIG1hbnVhbGx5OyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2lzc3Vlcy8xNDA5M1xuICAgICAgZWxSZWN0ID0gJC5leHRlbmQoe30sIGVsUmVjdCwgeyB3aWR0aDogZWxSZWN0LnJpZ2h0IC0gZWxSZWN0LmxlZnQsIGhlaWdodDogZWxSZWN0LmJvdHRvbSAtIGVsUmVjdC50b3AgfSlcbiAgICB9XG4gICAgdmFyIGVsT2Zmc2V0ICA9IGlzQm9keSA/IHsgdG9wOiAwLCBsZWZ0OiAwIH0gOiAkZWxlbWVudC5vZmZzZXQoKVxuICAgIHZhciBzY3JvbGwgICAgPSB7IHNjcm9sbDogaXNCb2R5ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA6ICRlbGVtZW50LnNjcm9sbFRvcCgpIH1cbiAgICB2YXIgb3V0ZXJEaW1zID0gaXNCb2R5ID8geyB3aWR0aDogJCh3aW5kb3cpLndpZHRoKCksIGhlaWdodDogJCh3aW5kb3cpLmhlaWdodCgpIH0gOiBudWxsXG5cbiAgICByZXR1cm4gJC5leHRlbmQoe30sIGVsUmVjdCwgc2Nyb2xsLCBvdXRlckRpbXMsIGVsT2Zmc2V0KVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0Q2FsY3VsYXRlZE9mZnNldCA9IGZ1bmN0aW9uIChwbGFjZW1lbnQsIHBvcywgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCkge1xuICAgIHJldHVybiBwbGFjZW1lbnQgPT0gJ2JvdHRvbScgPyB7IHRvcDogcG9zLnRvcCArIHBvcy5oZWlnaHQsICAgbGVmdDogcG9zLmxlZnQgKyBwb3Mud2lkdGggLyAyIC0gYWN0dWFsV2lkdGggLyAyICB9IDpcbiAgICAgICAgICAgcGxhY2VtZW50ID09ICd0b3AnICAgID8geyB0b3A6IHBvcy50b3AgLSBhY3R1YWxIZWlnaHQsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoIC8gMiAtIGFjdHVhbFdpZHRoIC8gMiAgfSA6XG4gICAgICAgICAgIHBsYWNlbWVudCA9PSAnbGVmdCcgICA/IHsgdG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCAvIDIgLSBhY3R1YWxIZWlnaHQgLyAyLCBsZWZ0OiBwb3MubGVmdCAtIGFjdHVhbFdpZHRoIH0gOlxuICAgICAgICAvKiBwbGFjZW1lbnQgPT0gJ3JpZ2h0JyAqLyB7IHRvcDogcG9zLnRvcCArIHBvcy5oZWlnaHQgLyAyIC0gYWN0dWFsSGVpZ2h0IC8gMiwgbGVmdDogcG9zLmxlZnQgKyBwb3Mud2lkdGggICB9XG5cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YSA9IGZ1bmN0aW9uIChwbGFjZW1lbnQsIHBvcywgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCkge1xuICAgIHZhciBkZWx0YSA9IHsgdG9wOiAwLCBsZWZ0OiAwIH1cbiAgICBpZiAoIXRoaXMuJHZpZXdwb3J0KSByZXR1cm4gZGVsdGFcblxuICAgIHZhciB2aWV3cG9ydFBhZGRpbmcgPSB0aGlzLm9wdGlvbnMudmlld3BvcnQgJiYgdGhpcy5vcHRpb25zLnZpZXdwb3J0LnBhZGRpbmcgfHwgMFxuICAgIHZhciB2aWV3cG9ydERpbWVuc2lvbnMgPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMuJHZpZXdwb3J0KVxuXG4gICAgaWYgKC9yaWdodHxsZWZ0Ly50ZXN0KHBsYWNlbWVudCkpIHtcbiAgICAgIHZhciB0b3BFZGdlT2Zmc2V0ICAgID0gcG9zLnRvcCAtIHZpZXdwb3J0UGFkZGluZyAtIHZpZXdwb3J0RGltZW5zaW9ucy5zY3JvbGxcbiAgICAgIHZhciBib3R0b21FZGdlT2Zmc2V0ID0gcG9zLnRvcCArIHZpZXdwb3J0UGFkZGluZyAtIHZpZXdwb3J0RGltZW5zaW9ucy5zY3JvbGwgKyBhY3R1YWxIZWlnaHRcbiAgICAgIGlmICh0b3BFZGdlT2Zmc2V0IDwgdmlld3BvcnREaW1lbnNpb25zLnRvcCkgeyAvLyB0b3Agb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEudG9wID0gdmlld3BvcnREaW1lbnNpb25zLnRvcCAtIHRvcEVkZ2VPZmZzZXRcbiAgICAgIH0gZWxzZSBpZiAoYm90dG9tRWRnZU9mZnNldCA+IHZpZXdwb3J0RGltZW5zaW9ucy50b3AgKyB2aWV3cG9ydERpbWVuc2lvbnMuaGVpZ2h0KSB7IC8vIGJvdHRvbSBvdmVyZmxvd1xuICAgICAgICBkZWx0YS50b3AgPSB2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCAtIGJvdHRvbUVkZ2VPZmZzZXRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlZnRFZGdlT2Zmc2V0ICA9IHBvcy5sZWZ0IC0gdmlld3BvcnRQYWRkaW5nXG4gICAgICB2YXIgcmlnaHRFZGdlT2Zmc2V0ID0gcG9zLmxlZnQgKyB2aWV3cG9ydFBhZGRpbmcgKyBhY3R1YWxXaWR0aFxuICAgICAgaWYgKGxlZnRFZGdlT2Zmc2V0IDwgdmlld3BvcnREaW1lbnNpb25zLmxlZnQpIHsgLy8gbGVmdCBvdmVyZmxvd1xuICAgICAgICBkZWx0YS5sZWZ0ID0gdmlld3BvcnREaW1lbnNpb25zLmxlZnQgLSBsZWZ0RWRnZU9mZnNldFxuICAgICAgfSBlbHNlIGlmIChyaWdodEVkZ2VPZmZzZXQgPiB2aWV3cG9ydERpbWVuc2lvbnMud2lkdGgpIHsgLy8gcmlnaHQgb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEubGVmdCA9IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0ICsgdmlld3BvcnREaW1lbnNpb25zLndpZHRoIC0gcmlnaHRFZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbHRhXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGl0bGVcbiAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50XG4gICAgdmFyIG8gID0gdGhpcy5vcHRpb25zXG5cbiAgICB0aXRsZSA9ICRlLmF0dHIoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKVxuICAgICAgfHwgKHR5cGVvZiBvLnRpdGxlID09ICdmdW5jdGlvbicgPyBvLnRpdGxlLmNhbGwoJGVbMF0pIDogIG8udGl0bGUpXG5cbiAgICByZXR1cm4gdGl0bGVcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldFVJRCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBkbyBwcmVmaXggKz0gfn4oTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApXG4gICAgd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpXG4gICAgcmV0dXJuIHByZWZpeFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudGlwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy4kdGlwID0gdGhpcy4kdGlwIHx8ICQodGhpcy5vcHRpb25zLnRlbXBsYXRlKSlcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmFycm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy4kYXJyb3cgPSB0aGlzLiRhcnJvdyB8fCB0aGlzLnRpcCgpLmZpbmQoJy50b29sdGlwLWFycm93JykpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSAhdGhpcy5lbmFibGVkXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIGlmIChlKSB7XG4gICAgICBzZWxmID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUpXG4gICAgICBpZiAoIXNlbGYpIHtcbiAgICAgICAgc2VsZiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGUuY3VycmVudFRhcmdldCwgdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSlcbiAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHNlbGYpXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi50aXAoKS5oYXNDbGFzcygnaW4nKSA/IHNlbGYubGVhdmUoc2VsZikgOiBzZWxmLmVudGVyKHNlbGYpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgdGhpcy5oaWRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGVsZW1lbnQub2ZmKCcuJyArIHRoYXQudHlwZSkucmVtb3ZlRGF0YSgnYnMuJyArIHRoYXQudHlwZSlcbiAgICB9KVxuICB9XG5cblxuICAvLyBUT09MVElQIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICAgPSAkdGhpcy5kYXRhKCdicy50b29sdGlwJylcbiAgICAgIHZhciBvcHRpb25zICA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG4gICAgICB2YXIgc2VsZWN0b3IgPSBvcHRpb25zICYmIG9wdGlvbnMuc2VsZWN0b3JcblxuICAgICAgaWYgKCFkYXRhICYmIG9wdGlvbiA9PSAnZGVzdHJveScpIHJldHVyblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMudG9vbHRpcCcsIChkYXRhID0ge30pKVxuICAgICAgICBpZiAoIWRhdGFbc2VsZWN0b3JdKSBkYXRhW3NlbGVjdG9yXSA9IG5ldyBUb29sdGlwKHRoaXMsIG9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnRvb2x0aXAnLCAoZGF0YSA9IG5ldyBUb29sdGlwKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi50b29sdGlwXG5cbiAgJC5mbi50b29sdGlwICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4udG9vbHRpcC5Db25zdHJ1Y3RvciA9IFRvb2x0aXBcblxuXG4gIC8vIFRPT0xUSVAgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4udG9vbHRpcC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4udG9vbHRpcCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogcG9wb3Zlci5qcyB2My4zLjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3BvcG92ZXJzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gUE9QT1ZFUiBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIFBvcG92ZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuaW5pdCgncG9wb3ZlcicsIGVsZW1lbnQsIG9wdGlvbnMpXG4gIH1cblxuICBpZiAoISQuZm4udG9vbHRpcCkgdGhyb3cgbmV3IEVycm9yKCdQb3BvdmVyIHJlcXVpcmVzIHRvb2x0aXAuanMnKVxuXG4gIFBvcG92ZXIuVkVSU0lPTiAgPSAnMy4zLjAnXG5cbiAgUG9wb3Zlci5ERUZBVUxUUyA9ICQuZXh0ZW5kKHt9LCAkLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IuREVGQVVMVFMsIHtcbiAgICBwbGFjZW1lbnQ6ICdyaWdodCcsXG4gICAgdHJpZ2dlcjogJ2NsaWNrJyxcbiAgICBjb250ZW50OiAnJyxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj48aDMgY2xhc3M9XCJwb3BvdmVyLXRpdGxlXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1jb250ZW50XCI+PC9kaXY+PC9kaXY+J1xuICB9KVxuXG5cbiAgLy8gTk9URTogUE9QT1ZFUiBFWFRFTkRTIHRvb2x0aXAuanNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBQb3BvdmVyLnByb3RvdHlwZSA9ICQuZXh0ZW5kKHt9LCAkLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IucHJvdG90eXBlKVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9wb3ZlclxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmdldERlZmF1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQb3BvdmVyLkRFRkFVTFRTXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGlwICAgID0gdGhpcy50aXAoKVxuICAgIHZhciB0aXRsZSAgID0gdGhpcy5nZXRUaXRsZSgpXG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKVxuXG4gICAgJHRpcC5maW5kKCcucG9wb3Zlci10aXRsZScpW3RoaXMub3B0aW9ucy5odG1sID8gJ2h0bWwnIDogJ3RleHQnXSh0aXRsZSlcbiAgICAkdGlwLmZpbmQoJy5wb3BvdmVyLWNvbnRlbnQnKS5jaGlsZHJlbigpLmRldGFjaCgpLmVuZCgpWyAvLyB3ZSB1c2UgYXBwZW5kIGZvciBodG1sIG9iamVjdHMgdG8gbWFpbnRhaW4ganMgZXZlbnRzXG4gICAgICB0aGlzLm9wdGlvbnMuaHRtbCA/ICh0eXBlb2YgY29udGVudCA9PSAnc3RyaW5nJyA/ICdodG1sJyA6ICdhcHBlbmQnKSA6ICd0ZXh0J1xuICAgIF0oY29udGVudClcblxuICAgICR0aXAucmVtb3ZlQ2xhc3MoJ2ZhZGUgdG9wIGJvdHRvbSBsZWZ0IHJpZ2h0IGluJylcblxuICAgIC8vIElFOCBkb2Vzbid0IGFjY2VwdCBoaWRpbmcgdmlhIHRoZSBgOmVtcHR5YCBwc2V1ZG8gc2VsZWN0b3IsIHdlIGhhdmUgdG8gZG9cbiAgICAvLyB0aGlzIG1hbnVhbGx5IGJ5IGNoZWNraW5nIHRoZSBjb250ZW50cy5cbiAgICBpZiAoISR0aXAuZmluZCgnLnBvcG92ZXItdGl0bGUnKS5odG1sKCkpICR0aXAuZmluZCgnLnBvcG92ZXItdGl0bGUnKS5oaWRlKClcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmhhc0NvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLmdldENvbnRlbnQoKVxuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50XG4gICAgdmFyIG8gID0gdGhpcy5vcHRpb25zXG5cbiAgICByZXR1cm4gJGUuYXR0cignZGF0YS1jb250ZW50JylcbiAgICAgIHx8ICh0eXBlb2Ygby5jb250ZW50ID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgby5jb250ZW50LmNhbGwoJGVbMF0pIDpcbiAgICAgICAgICAgIG8uY29udGVudClcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmFycm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy4kYXJyb3cgPSB0aGlzLiRhcnJvdyB8fCB0aGlzLnRpcCgpLmZpbmQoJy5hcnJvdycpKVxuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUudGlwID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy4kdGlwKSB0aGlzLiR0aXAgPSAkKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSlcbiAgICByZXR1cm4gdGhpcy4kdGlwXG4gIH1cblxuXG4gIC8vIFBPUE9WRVIgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgICA9ICR0aGlzLmRhdGEoJ2JzLnBvcG92ZXInKVxuICAgICAgdmFyIG9wdGlvbnMgID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cbiAgICAgIHZhciBzZWxlY3RvciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zZWxlY3RvclxuXG4gICAgICBpZiAoIWRhdGEgJiYgb3B0aW9uID09ICdkZXN0cm95JykgcmV0dXJuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5wb3BvdmVyJywgKGRhdGEgPSB7fSkpXG4gICAgICAgIGlmICghZGF0YVtzZWxlY3Rvcl0pIGRhdGFbc2VsZWN0b3JdID0gbmV3IFBvcG92ZXIodGhpcywgb3B0aW9ucylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMucG9wb3ZlcicsIChkYXRhID0gbmV3IFBvcG92ZXIodGhpcywgb3B0aW9ucykpKVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnBvcG92ZXJcblxuICAkLmZuLnBvcG92ZXIgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5wb3BvdmVyLkNvbnN0cnVjdG9yID0gUG9wb3ZlclxuXG5cbiAgLy8gUE9QT1ZFUiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5wb3BvdmVyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5wb3BvdmVyID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBzY3JvbGxzcHkuanMgdjMuMy4wXG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNzY3JvbGxzcHlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBTQ1JPTExTUFkgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFNjcm9sbFNweShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHByb2Nlc3MgID0gJC5wcm94eSh0aGlzLnByb2Nlc3MsIHRoaXMpXG5cbiAgICB0aGlzLiRib2R5ICAgICAgICAgID0gJCgnYm9keScpXG4gICAgdGhpcy4kc2Nyb2xsRWxlbWVudCA9ICQoZWxlbWVudCkuaXMoJ2JvZHknKSA/ICQod2luZG93KSA6ICQoZWxlbWVudClcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgID0gJC5leHRlbmQoe30sIFNjcm9sbFNweS5ERUZBVUxUUywgb3B0aW9ucylcbiAgICB0aGlzLnNlbGVjdG9yICAgICAgID0gKHRoaXMub3B0aW9ucy50YXJnZXQgfHwgJycpICsgJyAubmF2IGxpID4gYSdcbiAgICB0aGlzLm9mZnNldHMgICAgICAgID0gW11cbiAgICB0aGlzLnRhcmdldHMgICAgICAgID0gW11cbiAgICB0aGlzLmFjdGl2ZVRhcmdldCAgID0gbnVsbFxuICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ICAgPSAwXG5cbiAgICB0aGlzLiRzY3JvbGxFbGVtZW50Lm9uKCdzY3JvbGwuYnMuc2Nyb2xsc3B5JywgcHJvY2VzcylcbiAgICB0aGlzLnJlZnJlc2goKVxuICAgIHRoaXMucHJvY2VzcygpXG4gIH1cblxuICBTY3JvbGxTcHkuVkVSU0lPTiAgPSAnMy4zLjAnXG5cbiAgU2Nyb2xsU3B5LkRFRkFVTFRTID0ge1xuICAgIG9mZnNldDogMTBcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUuZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRzY3JvbGxFbGVtZW50WzBdLnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heCh0aGlzLiRib2R5WzBdLnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodClcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2Zmc2V0TWV0aG9kID0gJ29mZnNldCdcbiAgICB2YXIgb2Zmc2V0QmFzZSAgID0gMFxuXG4gICAgaWYgKCEkLmlzV2luZG93KHRoaXMuJHNjcm9sbEVsZW1lbnRbMF0pKSB7XG4gICAgICBvZmZzZXRNZXRob2QgPSAncG9zaXRpb24nXG4gICAgICBvZmZzZXRCYXNlICAgPSB0aGlzLiRzY3JvbGxFbGVtZW50LnNjcm9sbFRvcCgpXG4gICAgfVxuXG4gICAgdGhpcy5vZmZzZXRzID0gW11cbiAgICB0aGlzLnRhcmdldHMgPSBbXVxuICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gdGhpcy5nZXRTY3JvbGxIZWlnaHQoKVxuXG4gICAgdmFyIHNlbGYgICAgID0gdGhpc1xuXG4gICAgdGhpcy4kYm9keVxuICAgICAgLmZpbmQodGhpcy5zZWxlY3RvcilcbiAgICAgIC5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGVsICAgPSAkKHRoaXMpXG4gICAgICAgIHZhciBocmVmICA9ICRlbC5kYXRhKCd0YXJnZXQnKSB8fCAkZWwuYXR0cignaHJlZicpXG4gICAgICAgIHZhciAkaHJlZiA9IC9eIy4vLnRlc3QoaHJlZikgJiYgJChocmVmKVxuXG4gICAgICAgIHJldHVybiAoJGhyZWZcbiAgICAgICAgICAmJiAkaHJlZi5sZW5ndGhcbiAgICAgICAgICAmJiAkaHJlZi5pcygnOnZpc2libGUnKVxuICAgICAgICAgICYmIFtbJGhyZWZbb2Zmc2V0TWV0aG9kXSgpLnRvcCArIG9mZnNldEJhc2UsIGhyZWZdXSkgfHwgbnVsbFxuICAgICAgfSlcbiAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXSB9KVxuICAgICAgLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9mZnNldHMucHVzaCh0aGlzWzBdKVxuICAgICAgICBzZWxmLnRhcmdldHMucHVzaCh0aGlzWzFdKVxuICAgICAgfSlcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2Nyb2xsVG9wICAgID0gdGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKSArIHRoaXMub3B0aW9ucy5vZmZzZXRcbiAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5nZXRTY3JvbGxIZWlnaHQoKVxuICAgIHZhciBtYXhTY3JvbGwgICAgPSB0aGlzLm9wdGlvbnMub2Zmc2V0ICsgc2Nyb2xsSGVpZ2h0IC0gdGhpcy4kc2Nyb2xsRWxlbWVudC5oZWlnaHQoKVxuICAgIHZhciBvZmZzZXRzICAgICAgPSB0aGlzLm9mZnNldHNcbiAgICB2YXIgdGFyZ2V0cyAgICAgID0gdGhpcy50YXJnZXRzXG4gICAgdmFyIGFjdGl2ZVRhcmdldCA9IHRoaXMuYWN0aXZlVGFyZ2V0XG4gICAgdmFyIGlcblxuICAgIGlmICh0aGlzLnNjcm9sbEhlaWdodCAhPSBzY3JvbGxIZWlnaHQpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpXG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbFRvcCA+PSBtYXhTY3JvbGwpIHtcbiAgICAgIHJldHVybiBhY3RpdmVUYXJnZXQgIT0gKGkgPSB0YXJnZXRzW3RhcmdldHMubGVuZ3RoIC0gMV0pICYmIHRoaXMuYWN0aXZhdGUoaSlcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlVGFyZ2V0ICYmIHNjcm9sbFRvcCA8IG9mZnNldHNbMF0pIHtcbiAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0ID0gbnVsbFxuICAgICAgcmV0dXJuIHRoaXMuY2xlYXIoKVxuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBhY3RpdmVUYXJnZXQgIT0gdGFyZ2V0c1tpXVxuICAgICAgICAmJiBzY3JvbGxUb3AgPj0gb2Zmc2V0c1tpXVxuICAgICAgICAmJiAoIW9mZnNldHNbaSArIDFdIHx8IHNjcm9sbFRvcCA8PSBvZmZzZXRzW2kgKyAxXSlcbiAgICAgICAgJiYgdGhpcy5hY3RpdmF0ZSh0YXJnZXRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGhpcy5hY3RpdmVUYXJnZXQgPSB0YXJnZXRcblxuICAgIHRoaXMuY2xlYXIoKVxuXG4gICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciArXG4gICAgICAgICdbZGF0YS10YXJnZXQ9XCInICsgdGFyZ2V0ICsgJ1wiXSwnICtcbiAgICAgICAgdGhpcy5zZWxlY3RvciArICdbaHJlZj1cIicgKyB0YXJnZXQgKyAnXCJdJ1xuXG4gICAgdmFyIGFjdGl2ZSA9ICQoc2VsZWN0b3IpXG4gICAgICAucGFyZW50cygnbGknKVxuICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuXG4gICAgaWYgKGFjdGl2ZS5wYXJlbnQoJy5kcm9wZG93bi1tZW51JykubGVuZ3RoKSB7XG4gICAgICBhY3RpdmUgPSBhY3RpdmVcbiAgICAgICAgLmNsb3Nlc3QoJ2xpLmRyb3Bkb3duJylcbiAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgIH1cblxuICAgIGFjdGl2ZS50cmlnZ2VyKCdhY3RpdmF0ZS5icy5zY3JvbGxzcHknKVxuICB9XG5cbiAgU2Nyb2xsU3B5LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAkKHRoaXMuc2VsZWN0b3IpXG4gICAgICAucGFyZW50c1VudGlsKHRoaXMub3B0aW9ucy50YXJnZXQsICcuYWN0aXZlJylcbiAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgfVxuXG5cbiAgLy8gU0NST0xMU1BZIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5zY3JvbGxzcHknKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnNjcm9sbHNweScsIChkYXRhID0gbmV3IFNjcm9sbFNweSh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uc2Nyb2xsc3B5XG5cbiAgJC5mbi5zY3JvbGxzcHkgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5zY3JvbGxzcHkuQ29uc3RydWN0b3IgPSBTY3JvbGxTcHlcblxuXG4gIC8vIFNDUk9MTFNQWSBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLnNjcm9sbHNweS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uc2Nyb2xsc3B5ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gU0NST0xMU1BZIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PT09PVxuXG4gICQod2luZG93KS5vbignbG9hZC5icy5zY3JvbGxzcHkuZGF0YS1hcGknLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnW2RhdGEtc3B5PVwic2Nyb2xsXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHNweSA9ICQodGhpcylcbiAgICAgIFBsdWdpbi5jYWxsKCRzcHksICRzcHkuZGF0YSgpKVxuICAgIH0pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHRhYi5qcyB2My4zLjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3RhYnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNCBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBUQUIgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBUYWIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuZWxlbWVudCA9ICQoZWxlbWVudClcbiAgfVxuXG4gIFRhYi5WRVJTSU9OID0gJzMuMy4wJ1xuXG4gIFRhYi5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwXG5cbiAgVGFiLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGhpcyAgICA9IHRoaXMuZWxlbWVudFxuICAgIHZhciAkdWwgICAgICA9ICR0aGlzLmNsb3Nlc3QoJ3VsOm5vdCguZHJvcGRvd24tbWVudSknKVxuICAgIHZhciBzZWxlY3RvciA9ICR0aGlzLmRhdGEoJ3RhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIGlmICgkdGhpcy5wYXJlbnQoJ2xpJykuaGFzQ2xhc3MoJ2FjdGl2ZScpKSByZXR1cm5cblxuICAgIHZhciAkcHJldmlvdXMgPSAkdWwuZmluZCgnLmFjdGl2ZTpsYXN0IGEnKVxuICAgIHZhciBoaWRlRXZlbnQgPSAkLkV2ZW50KCdoaWRlLmJzLnRhYicsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6ICR0aGlzWzBdXG4gICAgfSlcbiAgICB2YXIgc2hvd0V2ZW50ID0gJC5FdmVudCgnc2hvdy5icy50YWInLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiAkcHJldmlvdXNbMF1cbiAgICB9KVxuXG4gICAgJHByZXZpb3VzLnRyaWdnZXIoaGlkZUV2ZW50KVxuICAgICR0aGlzLnRyaWdnZXIoc2hvd0V2ZW50KVxuXG4gICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdmFyICR0YXJnZXQgPSAkKHNlbGVjdG9yKVxuXG4gICAgdGhpcy5hY3RpdmF0ZSgkdGhpcy5jbG9zZXN0KCdsaScpLCAkdWwpXG4gICAgdGhpcy5hY3RpdmF0ZSgkdGFyZ2V0LCAkdGFyZ2V0LnBhcmVudCgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAkcHJldmlvdXMudHJpZ2dlcih7XG4gICAgICAgIHR5cGU6ICdoaWRkZW4uYnMudGFiJyxcbiAgICAgICAgcmVsYXRlZFRhcmdldDogJHRoaXNbMF1cbiAgICAgIH0pXG4gICAgICAkdGhpcy50cmlnZ2VyKHtcbiAgICAgICAgdHlwZTogJ3Nob3duLmJzLnRhYicsXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6ICRwcmV2aW91c1swXVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgVGFiLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyICRhY3RpdmUgICAgPSBjb250YWluZXIuZmluZCgnPiAuYWN0aXZlJylcbiAgICB2YXIgdHJhbnNpdGlvbiA9IGNhbGxiYWNrXG4gICAgICAmJiAkLnN1cHBvcnQudHJhbnNpdGlvblxuICAgICAgJiYgKCgkYWN0aXZlLmxlbmd0aCAmJiAkYWN0aXZlLmhhc0NsYXNzKCdmYWRlJykpIHx8ICEhY29udGFpbmVyLmZpbmQoJz4gLmZhZGUnKS5sZW5ndGgpXG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgJGFjdGl2ZVxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgIC5maW5kKCc+IC5kcm9wZG93bi1tZW51ID4gLmFjdGl2ZScpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZW5kKClcbiAgICAgICAgLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpXG4gICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSlcblxuICAgICAgZWxlbWVudFxuICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgZWxlbWVudFswXS5vZmZzZXRXaWR0aCAvLyByZWZsb3cgZm9yIHRyYW5zaXRpb25cbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcygnaW4nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnZmFkZScpXG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LnBhcmVudCgnLmRyb3Bkb3duLW1lbnUnKSkge1xuICAgICAgICBlbGVtZW50XG4gICAgICAgICAgLmNsb3Nlc3QoJ2xpLmRyb3Bkb3duJylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgICAgICAuZW5kKClcbiAgICAgICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJylcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH1cblxuICAgICRhY3RpdmUubGVuZ3RoICYmIHRyYW5zaXRpb24gP1xuICAgICAgJGFjdGl2ZVxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBuZXh0KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVGFiLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIG5leHQoKVxuXG4gICAgJGFjdGl2ZS5yZW1vdmVDbGFzcygnaW4nKVxuICB9XG5cblxuICAvLyBUQUIgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMudGFiJylcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy50YWInLCAoZGF0YSA9IG5ldyBUYWIodGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnRhYlxuXG4gICQuZm4udGFiICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4udGFiLkNvbnN0cnVjdG9yID0gVGFiXG5cblxuICAvLyBUQUIgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09XG5cbiAgJC5mbi50YWIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnRhYiA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIFRBQiBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT1cblxuICB2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBQbHVnaW4uY2FsbCgkKHRoaXMpLCAnc2hvdycpXG4gIH1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMudGFiLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScsIGNsaWNrSGFuZGxlcilcbiAgICAub24oJ2NsaWNrLmJzLnRhYi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJwaWxsXCJdJywgY2xpY2tIYW5kbGVyKVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBhZmZpeC5qcyB2My4zLjBcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2FmZml4XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTQgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQUZGSVggQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIEFmZml4ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQWZmaXguREVGQVVMVFMsIG9wdGlvbnMpXG5cbiAgICB0aGlzLiR0YXJnZXQgPSAkKHRoaXMub3B0aW9ucy50YXJnZXQpXG4gICAgICAub24oJ3Njcm9sbC5icy5hZmZpeC5kYXRhLWFwaScsICQucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uLCB0aGlzKSlcbiAgICAgIC5vbignY2xpY2suYnMuYWZmaXguZGF0YS1hcGknLCAgJC5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wLCB0aGlzKSlcblxuICAgIHRoaXMuJGVsZW1lbnQgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuYWZmaXhlZCAgICAgID1cbiAgICB0aGlzLnVucGluICAgICAgICA9XG4gICAgdGhpcy5waW5uZWRPZmZzZXQgPSBudWxsXG5cbiAgICB0aGlzLmNoZWNrUG9zaXRpb24oKVxuICB9XG5cbiAgQWZmaXguVkVSU0lPTiAgPSAnMy4zLjAnXG5cbiAgQWZmaXguUkVTRVQgICAgPSAnYWZmaXggYWZmaXgtdG9wIGFmZml4LWJvdHRvbSdcblxuICBBZmZpeC5ERUZBVUxUUyA9IHtcbiAgICBvZmZzZXQ6IDAsXG4gICAgdGFyZ2V0OiB3aW5kb3dcbiAgfVxuXG4gIEFmZml4LnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIChzY3JvbGxIZWlnaHQsIGhlaWdodCwgb2Zmc2V0VG9wLCBvZmZzZXRCb3R0b20pIHtcbiAgICB2YXIgc2Nyb2xsVG9wICAgID0gdGhpcy4kdGFyZ2V0LnNjcm9sbFRvcCgpXG4gICAgdmFyIHBvc2l0aW9uICAgICA9IHRoaXMuJGVsZW1lbnQub2Zmc2V0KClcbiAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gdGhpcy4kdGFyZ2V0LmhlaWdodCgpXG5cbiAgICBpZiAob2Zmc2V0VG9wICE9IG51bGwgJiYgdGhpcy5hZmZpeGVkID09ICd0b3AnKSByZXR1cm4gc2Nyb2xsVG9wIDwgb2Zmc2V0VG9wID8gJ3RvcCcgOiBmYWxzZVxuXG4gICAgaWYgKHRoaXMuYWZmaXhlZCA9PSAnYm90dG9tJykge1xuICAgICAgaWYgKG9mZnNldFRvcCAhPSBudWxsKSByZXR1cm4gKHNjcm9sbFRvcCArIHRoaXMudW5waW4gPD0gcG9zaXRpb24udG9wKSA/IGZhbHNlIDogJ2JvdHRvbSdcbiAgICAgIHJldHVybiAoc2Nyb2xsVG9wICsgdGFyZ2V0SGVpZ2h0IDw9IHNjcm9sbEhlaWdodCAtIG9mZnNldEJvdHRvbSkgPyBmYWxzZSA6ICdib3R0b20nXG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxpemluZyAgID0gdGhpcy5hZmZpeGVkID09IG51bGxcbiAgICB2YXIgY29sbGlkZXJUb3AgICAgPSBpbml0aWFsaXppbmcgPyBzY3JvbGxUb3AgOiBwb3NpdGlvbi50b3BcbiAgICB2YXIgY29sbGlkZXJIZWlnaHQgPSBpbml0aWFsaXppbmcgPyB0YXJnZXRIZWlnaHQgOiBoZWlnaHRcblxuICAgIGlmIChvZmZzZXRUb3AgIT0gbnVsbCAmJiBjb2xsaWRlclRvcCA8PSBvZmZzZXRUb3ApIHJldHVybiAndG9wJ1xuICAgIGlmIChvZmZzZXRCb3R0b20gIT0gbnVsbCAmJiAoY29sbGlkZXJUb3AgKyBjb2xsaWRlckhlaWdodCA+PSBzY3JvbGxIZWlnaHQgLSBvZmZzZXRCb3R0b20pKSByZXR1cm4gJ2JvdHRvbSdcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgQWZmaXgucHJvdG90eXBlLmdldFBpbm5lZE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5waW5uZWRPZmZzZXQpIHJldHVybiB0aGlzLnBpbm5lZE9mZnNldFxuICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoQWZmaXguUkVTRVQpLmFkZENsYXNzKCdhZmZpeCcpXG4gICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKVxuICAgIHZhciBwb3NpdGlvbiAgPSB0aGlzLiRlbGVtZW50Lm9mZnNldCgpXG4gICAgcmV0dXJuICh0aGlzLnBpbm5lZE9mZnNldCA9IHBvc2l0aW9uLnRvcCAtIHNjcm9sbFRvcClcbiAgfVxuXG4gIEFmZml4LnByb3RvdHlwZS5jaGVja1Bvc2l0aW9uV2l0aEV2ZW50TG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uLCB0aGlzKSwgMSlcbiAgfVxuXG4gIEFmZml4LnByb3RvdHlwZS5jaGVja1Bvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSkgcmV0dXJuXG5cbiAgICB2YXIgaGVpZ2h0ICAgICAgID0gdGhpcy4kZWxlbWVudC5oZWlnaHQoKVxuICAgIHZhciBvZmZzZXQgICAgICAgPSB0aGlzLm9wdGlvbnMub2Zmc2V0XG4gICAgdmFyIG9mZnNldFRvcCAgICA9IG9mZnNldC50b3BcbiAgICB2YXIgb2Zmc2V0Qm90dG9tID0gb2Zmc2V0LmJvdHRvbVxuICAgIHZhciBzY3JvbGxIZWlnaHQgPSAkKCdib2R5JykuaGVpZ2h0KClcblxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9ICdvYmplY3QnKSAgICAgICAgIG9mZnNldEJvdHRvbSA9IG9mZnNldFRvcCA9IG9mZnNldFxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0VG9wID09ICdmdW5jdGlvbicpICAgIG9mZnNldFRvcCAgICA9IG9mZnNldC50b3AodGhpcy4kZWxlbWVudClcbiAgICBpZiAodHlwZW9mIG9mZnNldEJvdHRvbSA9PSAnZnVuY3Rpb24nKSBvZmZzZXRCb3R0b20gPSBvZmZzZXQuYm90dG9tKHRoaXMuJGVsZW1lbnQpXG5cbiAgICB2YXIgYWZmaXggPSB0aGlzLmdldFN0YXRlKHNjcm9sbEhlaWdodCwgaGVpZ2h0LCBvZmZzZXRUb3AsIG9mZnNldEJvdHRvbSlcblxuICAgIGlmICh0aGlzLmFmZml4ZWQgIT0gYWZmaXgpIHtcbiAgICAgIGlmICh0aGlzLnVucGluICE9IG51bGwpIHRoaXMuJGVsZW1lbnQuY3NzKCd0b3AnLCAnJylcblxuICAgICAgdmFyIGFmZml4VHlwZSA9ICdhZmZpeCcgKyAoYWZmaXggPyAnLScgKyBhZmZpeCA6ICcnKVxuICAgICAgdmFyIGUgICAgICAgICA9ICQuRXZlbnQoYWZmaXhUeXBlICsgJy5icy5hZmZpeCcpXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgIHRoaXMuYWZmaXhlZCA9IGFmZml4XG4gICAgICB0aGlzLnVucGluID0gYWZmaXggPT0gJ2JvdHRvbScgPyB0aGlzLmdldFBpbm5lZE9mZnNldCgpIDogbnVsbFxuXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5yZW1vdmVDbGFzcyhBZmZpeC5SRVNFVClcbiAgICAgICAgLmFkZENsYXNzKGFmZml4VHlwZSlcbiAgICAgICAgLnRyaWdnZXIoYWZmaXhUeXBlLnJlcGxhY2UoJ2FmZml4JywgJ2FmZml4ZWQnKSArICcuYnMuYWZmaXgnKVxuICAgIH1cblxuICAgIGlmIChhZmZpeCA9PSAnYm90dG9tJykge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmZzZXQoe1xuICAgICAgICB0b3A6IHNjcm9sbEhlaWdodCAtIGhlaWdodCAtIG9mZnNldEJvdHRvbVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuXG4gIC8vIEFGRklYIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmFmZml4JylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5hZmZpeCcsIChkYXRhID0gbmV3IEFmZml4KHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5hZmZpeFxuXG4gICQuZm4uYWZmaXggICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5hZmZpeC5Db25zdHJ1Y3RvciA9IEFmZml4XG5cblxuICAvLyBBRkZJWCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYWZmaXgubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmFmZml4ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQUZGSVggREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKHdpbmRvdykub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnW2RhdGEtc3B5PVwiYWZmaXhcIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkc3B5ID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgPSAkc3B5LmRhdGEoKVxuXG4gICAgICBkYXRhLm9mZnNldCA9IGRhdGEub2Zmc2V0IHx8IHt9XG5cbiAgICAgIGlmIChkYXRhLm9mZnNldEJvdHRvbSAhPSBudWxsKSBkYXRhLm9mZnNldC5ib3R0b20gPSBkYXRhLm9mZnNldEJvdHRvbVxuICAgICAgaWYgKGRhdGEub2Zmc2V0VG9wICAgICE9IG51bGwpIGRhdGEub2Zmc2V0LnRvcCAgICA9IGRhdGEub2Zmc2V0VG9wXG5cbiAgICAgIFBsdWdpbi5jYWxsKCRzcHksIGRhdGEpXG4gICAgfSlcbiAgfSlcblxufShqUXVlcnkpO1xuIiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBNZW51TW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvYW1wLW1lbnVzLW1vZGVsLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuICB1cmw6ICcvcmVzdC9zZWN1cml0eS9tZW51cycsXG4gIG1vZGVsOiBNZW51TW9kZWwsXG5cbiAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNhY2hlID0gZmFsc2U7XG4gICAgcmV0dXJuIEJhY2tib25lLk1vZGVsLnByb3RvdHlwZS5mZXRjaC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbn0pO1xuIiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICB1cmw6ICcvcmVzdC9zZWN1cml0eS9sYXlvdXQnLFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZW1haWw6IHVuZGVmaW5lZFxuICB9LFxuICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2FjaGUgPSBmYWxzZTtcbiAgICByZXR1cm4gQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH1cblxufSk7XG4iLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gIHVybDogJy9yZXN0L3NlY3VyaXR5L21lbnVzJyxcblxuICBkZWZhdWx0czoge1xuICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgIGNoaWxkcmVuOiBbXVxuICB9LFxuICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2FjaGUgPSBmYWxzZTtcbiAgICByZXR1cm4gQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLmZldGNoLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH1cblxufSk7XG4iLCJcclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBUZW1wbGF0ZSA9IFwiPGRpdiBjbGFzcz1cXFwibW9kYWwgZmFkZVxcXCIgaWQ9XFxcImFib3V0LXBvcHVwXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcImRpYWxvZ1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJteU1vZGFsTGFiZWxcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj5cXHJcXG48ZGl2IGNsYXNzPVxcXCJtb2RhbC1kaWFsb2dcXFwiPlxcclxcbiA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1jb250ZW50XFxcIj5cXHJcXG4gPGRpdiBjbGFzcz1cXFwibW9kYWwtaGVhZGVyXFxcIj5cXHJcXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiY2xvc2VcXFwiIGRhdGEtZGlzbWlzcz1cXFwibW9kYWxcXFwiPjxzcGFuIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj4mdGltZXM7PC9zcGFuPjxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmRhc2hib2FyZDpjbG9zZVxcXCIgY2xhc3M9XFxcInNyLW9ubHlcXFwiPkNsb3NlPC9zcGFuPjwvYnV0dG9uPlxcclxcbiAgICAgICAgPGg0IGNsYXNzPVxcXCJtb2RhbC10aXRsZSB0ZXh0LXByaW1hcnlcXFwiIGRhdGEtaTE4bj1cXFwiYW1wLmFib3V0Om1vZGFsLnRpdGxlXFxcIj5BYm91dCBBTVA8L2g0PlxcclxcbiA8L2Rpdj5cXHJcXG48dGFibGUgd2lkdGg9XFxcIjQ3NFxcXCIgYm9yZGVyPVxcXCIwXFxcIiBzdHlsZT1cXFwibWFyZ2luOjE1cHg7XFxcIj5cXHJcXG5cXHQ8dGJvZHk+PHRyPlxcclxcblxcdFxcdDx0ZCB3aWR0aD1cXFwiMjU3XFxcIj5cXHJcXG5cXHRcXHQ8cCBhbGlnbj1cXFwiY2VudGVyXFxcIiBzdHlsZT1cXFwiZm9udC1zaXplOiAxNnB4O1xcXCI+PHN0cm9uZz4mbmJzcDs8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5jb21tb246cGxhdGZvcm1cXFwiPkFpZCBNYW5hZ2VtZW50IFBsYXRmb3JtIChBTVApPC9zcGFuPjwvc3Ryb25nPjwvcD5cXHJcXG5cXHRcXHQ8cCBhbGlnbj1cXFwiY2VudGVyXFxcIj4gVmVyc2lvbiA8JT0gYW1wVmVyc2lvbiAlPjwvcD5cXHJcXG5cXHRcXHQ8L3RkPlxcclxcblxcdFxcdDx0ZCB3aWR0aD1cXFwiMjIwXFxcIj48aW1nIHdpZHRoPVxcXCIyMjBcXFwiIGhlaWdodD1cXFwiMTAwXFxcIiBzcmM9XFxcIi9URU1QTEFURS9hbXBUZW1wbGF0ZS9pbWdfMi9sb2dvLWRldmVsb3BtZW50LWdhdGV3YXkucG5nXFxcIj48L3RkPlxcclxcblxcdDwvdHI+XFxyXFxuXFx0PHRyPlxcclxcblxcdFxcdDx0ZCBjb2xzcGFuPVxcXCIyXFxcIj5cXHJcXG5cXHRcXHQ8cCAgc3R5bGU9XFxcImZvbnQtc2l6ZTogMTJweDtcXFwiPiZuYnNwOzxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjpwbGF0Zm9ybVxcXCI+QWlkIE1hbmFnZW1lbnQgUGxhdGZvcm0gKEFNUCk8L3NwYW4+XFxyXFxuXFx0XFx0IDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmFib3V0OnZlcnNpb25cXFwiPlZlcnNpb248L3NwYW4+IDwlPSBhbXBWZXJzaW9uICU+IDwlPSBidWlsZERhdGUgJT5cXHJcXG5cXHRcXHQ8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5hYm91dDpjcmVkaXRzXFxcIj5EZXZlbG9wZWQgaW4gcGFydG5lcnNoaXAgd2l0aCBPRUNELCBVTkRQLCBXQiwgR292ZXJubWVudCBvZiBFdGhpb3BpYSBhbmQgRGV2ZWxvcG1lbnQgR2F0ZXdheSBGb3VuZGF0aW9uPC9zcGFuPi5cXHJcXG5cXHRcXHQ8L3A+XFxyXFxuXFx0XFx0PC90ZD5cXHJcXG5cXHQ8L3RyPlxcclxcblxcdDx0cj5cXHJcXG5cXHRcXHQ8dGQgY29sc3Bhbj1cXFwiMlxcXCI+XFxyXFxuXFx0XFx0PHAgc3R5bGU9XFxcImZvbnQtc2l6ZTogMTJweDtcXFwiPlxcclxcblxcdFxcdDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmFib3V0OnRyYWRlbWFya1xcXCI+VGhlIERldmVsb3BtZW50IEdhdGV3YXkgYW5kIHRoZSBUaGUgRGV2ZWxvcG1lbnQgR2F0ZXdheSBsb2dvIGFyZSB0cmFkZW1hcmtzIGZvciBUaGUgRGV2ZWxvcG1lbnQgR2F0ZXdheSBGb3VuZGF0aW9uPC9zcGFuPi48c3BhbiBkYXRhLWkxOG49XFxcImFtcC5hYm91dDpyaWdodHNcXFwiPkFsbCBSaWdodHMgUmVzZXJ2ZWQ8L3NwYW4+LjwvcD5cXHJcXG5cXHRcXHQ8L3RkPlxcclxcblxcdDwvdHI+XFxyXFxuPC90Ym9keT48L3RhYmxlPlxcclxcbjwvZGl2PlxcclxcbjwvZGl2PlxcclxcbjwvZGl2PlwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgdGVtcGxhdGU6IF8udGVtcGxhdGUoVGVtcGxhdGUpLFxyXG4gIGlkOiAnYWJvdXRNb2RhbCcsXHJcbiAgXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdCAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcDtcclxuICAgIF8uYmluZEFsbCh0aGlzLCAncmVuZGVyJyk7XHJcblxyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcblx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdF8uZGVmYXVsdHMod2luZG93LCB7YW1wVmVyc2lvbjogXCIwXCIsIGJ1aWxkRGF0ZTogXCIwXCJ9KTtcclxuICAgIHRoaXMuJGVsLmh0bWwoc2VsZi50ZW1wbGF0ZSh7XHJcbiAgICAgIGFtcFZlcnNpb246IHdpbmRvdy5hbXBWZXJzaW9uLFxyXG4gICAgICBidWlsZERhdGU6IHdpbmRvdy5idWlsZERhdGVcclxuICAgIH0pKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBcclxufSk7XHJcblxyXG4iLCJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnJlcXVpcmUoJ2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcCcpO1xuXG52YXIgVGVtcGxhdGUgPSBcIjxzdHlsZT5cXHJcXG4gICAgLmZvb3RlclRleHQge1xcclxcbiAgICBwYWRkaW5nOiAwO1xcclxcbiAgICBmb250LWZhbWlseTogYXJpYWw7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTFweDtcXHJcXG4gICAgYm9yZGVyOiAwcHg7XFxyXFxuICAgIH1cXHJcXG4gICAgLmZvb3RlciB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM4QjhCOEI7XFxyXFxuICAgIGNvbG9yOiAjRkZGO1xcclxcbiAgICBtYXJnaW4tdG9wOiAwO1xcclxcbiAgICBwYWRkaW5nLWJvdHRvbTogMTBweDtcXHJcXG4gICAgcGFkZGluZy10b3A6IDEwcHg7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgfVxcclxcbiAgICAuZGdmX2Zvb3RlciB7XFxyXFxuICAgIGNvbG9yOiAjOEI4QjhCO1xcclxcbiAgICBsaW5lLWhlaWdodDogMThweDtcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOndoaXRlO1xcclxcbiAgICBwYWRkaW5nLXRvcDoxMHB4O1xcclxcbiAgICB9XFxyXFxuICAgIC5kZ2ZfZm9vdGVyIGltZyB7XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiAxOHB4O1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiA1cHg7XFxyXFxuICAgIH1cXHJcXG4gICAgLmxvYWRpbmd7ICAgXFxyXFxuICAgICAgbWFyZ2luOiAxMHB4IDIwcHggMTBweCAyMHB4O1xcclxcbiAgICB9XFxyXFxuICAgIFxcclxcbjwvc3R5bGU+XFxyXFxuXFxyXFxuPGRpdiBjbGFzcz1cXFwiZm9vdGVyIGZvb3RlclRleHRcXFwiPlxcclxcbiAgICBBTVAgPGI+PCU9ICBwcm9wZXJ0aWVzLmFtcFZlcnNpb24gJT48L2I+IGJ1aWxkIDxiPjwlPSAgcHJvcGVydGllcy5idWlsZERhdGUgJT48L2I+IC0gPCU9IHByb3BlcnRpZXMuZm9vdGVyVGV4dCAlPlxcclxcbiAgICA8JSBpZihzaG93QWRtaW5MaW5rcyA9PSB0cnVlICAmJiBwcm9wZXJ0aWVzLmFkbWluTGlua3MgIT0gdW5kZWZpbmVkKSB7ICU+XFxyXFxuICAgIDxhIGhyZWY9JzwlPSAgcHJvcGVydGllcy5hZG1pbkxpbmtzWzBdLnVybCAlPic+PCU9ICBwcm9wZXJ0aWVzLmFkbWluTGlua3NbMF0ubmFtZSAlPjwvYT5cXHJcXG4gICAgPGEgaHJlZj0nPCU9ICBwcm9wZXJ0aWVzLmFkbWluTGlua3NbMV0udXJsICU+Jz48JT0gIHByb3BlcnRpZXMuYWRtaW5MaW5rc1sxXS5uYW1lICU+PC9kaWdpOnRybj48L2E+XFxyXFxuICAgIDwlIH0gJT5cXHJcXG48L2Rpdj5cXHJcXG48JSBpZihzaG93REdGb290ZXIgPT0gdHJ1ZSkgIHsgJT5cXHJcXG48ZGl2IGNsYXNzPVxcXCJkZ2ZfZm9vdGVyIGZvb3RlclRleHRcXFwiPlxcclxcbiAgICA8aW1nIHNyYz1cXFwiL1RFTVBMQVRFL2FtcFRlbXBsYXRlL2ltZ18yL2RnZl9sb2dvX2JvdHRvbS5naWZcXFwiIGNsYXNzPVxcXCJkZ2ZfbG9nb19mb290ZXJcXFwiPlxcclxcbiAgICA8YnIvPlxcclxcbiAgICBEZXZlbG9wbWVudCBHYXRld2F5XFxyXFxuICAgIDxici8+XFxyXFxuICAgIDExMTAgVmVybW9udCBBdmUsIE5XLCBTdWl0ZSA1MDBcXHJcXG4gICAgPGJyLz5cXHJcXG4gICAgV2FzaGluZ3RvbiwgREMgMjAwMDUgVVNBXFxyXFxuICAgIDxici8+XFxyXFxuICAgIGluZm9AZGV2ZWxvcG1lbnRnYXRld2F5Lm9yZywgVGVsOiArMS4yMDIuNTcyLjkyMDAsIEZheDogKzEgMjAyLjU3Mi45MjkwXFxyXFxuPC9kaXY+XFxyXFxuPCUgfSAlPlxcclxcblxcclxcblxcclxcbjxkaXYgaWQ9XFxcInVzZXItcHJvZmlsZVxcXCIgY2xhc3M9XFxcIm1vZGFsIGZhZGVcXFwiIGlkPVxcXCJhYm91dC1wb3B1cFxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiByb2xlPVxcXCJkaWFsb2dcXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwibXlNb2RhbExhYmVsXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+XFxyXFxuPGRpdiBjbGFzcz1cXFwibW9kYWwtZGlhbG9nXFxcIj5cXHJcXG4gPGRpdiBjbGFzcz1cXFwibW9kYWwtY29udGVudFxcXCI+XFxyXFxuIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWhlYWRlclxcXCI+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIj48c3BhbiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvc3Bhbj48c3BhbiBkYXRhLWkxOG49XFxcImFtcC5kYXNoYm9hcmQ6Y2xvc2VcXFwiIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5DbG9zZTwvc3Bhbj48L2J1dHRvbj5cXHJcXG4gICAgICAgIDxoNCBjbGFzcz1cXFwibW9kYWwtdGl0bGUgdGV4dC1wcmltYXJ5XFxcIiBkYXRhLWkxOG49XFxcImFtcC5wcm9maWxlOm1vZGFsLnRpdGxlXFxcIj5NZW1iZXIgRGV0YWlsczwvaDQ+XFxyXFxuIDwvZGl2PlxcclxcbiA8ZGl2IGNsYXNzPVxcXCJ1c2VyLXByb2ZpbGUtY29udGVudFxcXCI+XFxyXFxuICAgPGRpdiBjbGFzcz0nbG9hZGluZycgZGF0YS1pMThuPVxcXCJhbXAucHJvZmlsZTptb2RhbC5sb2FkaW5nXFxcIj5Mb2FkaW5nLi4uPC9kaXY+XFxyXFxuIDwvZGl2PiBcXHJcXG4gPC9kaXY+XFxyXFxuIDwvZGl2PlxcclxcbiA8L2Rpdj5cXHJcXG48JSBpZihwcm9wZXJ0aWVzLnRyYWNraW5nRW5hYmxlZCA9PT0gdHJ1ZSkgeyAlPlxcclxcbjwhLS0gUGl3aWtcXHJcXG5TaXRlIGlkIGNhbiBiZSBjaGVja2VkIGhlcmU6IGh0dHA6Ly9zdGF0cy5hbXBzaXRlLm5ldC9pbmRleC5waHA/bW9kdWxlPVNpdGVzTWFuYWdlciZhY3Rpb249aW5kZXgmaWRTaXRlPTEmcGVyaW9kPXJhbmdlJmRhdGU9bGFzdDMwXFxyXFxuQWxzbyx0aGUgd2lraSBmb3IgcGl3aWs6IGh0dHBzOi8vd2lraS5kZ2ZvdW5kYXRpb24ub3JnL2Rpc3BsYXkvQU1QRE9DL0ludGVncmF0aW5nK0FNUCt3aXRoK1Bpd2lrXFxyXFxuLS0+XFxyXFxuPHNjcmlwdCB0eXBlPVxcXCJ0ZXh0L2phdmFzY3JpcHRcXFwiPlxcclxcblxcdCAgdmFyIF9wYXEgPSBfcGFxIHx8IFtdO1xcclxcbiAgICBpZiAod2luZG93LlBpd2lrQWxyZWFkeUZldGNoZWQgPT09IHVuZGVmaW5lZCApIHtcXHJcXG4gICAgICBfcGFxLnB1c2goWydzZXRVc2VySWQnLCBcXFwiPCU9IHByb3BlcnRpZXMuZW1haWwgJT5cXFwiXSk7XFxyXFxuICAgICAgX3BhcS5wdXNoKFsnc2V0Q3VzdG9tVmFyaWFibGUnLFxcclxcbiAgICAgICAgICAxLFxcclxcbiAgICAgICAgICBcXFwiV29ya3NwYWNlfFdJRFxcXCIsXFxyXFxuICAgICAgICAgIFxcXCI8JT0gcHJvcGVydGllcy53b3Jrc3BhY2UgJT58PCU9IHByb3BlcnRpZXMud29ya3NwYWNlSWQgJT5cXFwiLFxcclxcbiAgICAgICAgICBcXFwicGFnZVxcXCJdKTtcXHJcXG4gIFxcdCAgX3BhcS5wdXNoKFtcXFwidHJhY2tQYWdlVmlld1xcXCJdKTtcXHJcXG4gIFxcdCAgX3BhcS5wdXNoKFtcXFwiZW5hYmxlTGlua1RyYWNraW5nXFxcIl0pO1xcclxcblxcclxcbiAgICAgIC8qIFRESzoga2VlcCB0cmFjayBvZiB3aGV0aGVyIHdlIHB1dCB0aGUgc2NyaXB0IERPTSBub2RlIG9uIHRoZSBwYWdlIGFscmVhZHlcXHJcXG4gICAgICAgKiAgIGluIGNhc2UgdGhlIHBhZ2UgcmVwYXJzZXMgdGhpcyBqYXZhc2NyaXB0IG9uIGFub3RoZXIgbW9kaWZpY2F0aW9uLlxcclxcbiAgICAgICAqL1xcclxcbiAgICAgIHdpbmRvdy5QaXdpa0FscmVhZHlGZXRjaGVkID0gdHJ1ZTtcXHJcXG5cXHJcXG4gICAgICAvKiBTdG9jayBQaXdpayBjb2RlOiAqL1xcclxcbiAgXFx0ICAoZnVuY3Rpb24oKSB7XFxyXFxuICBcXHQgICAgdmFyIHU9XFxcIjwlPSAgcHJvcGVydGllcy50cmFja2luZ1VybCAlPlxcXCI7XFxyXFxuICBcXHQgICAgX3BhcS5wdXNoKFtcXFwic2V0VHJhY2tlclVybFxcXCIsIHUrXFxcInBpd2lrLnBocFxcXCJdKTtcXHJcXG4gIFxcdCAgICBfcGFxLnB1c2goW1xcXCJzZXRTaXRlSWRcXFwiLCBcXFwiPCU9cHJvcGVydGllcy5zaXRlSWQgJT5cXFwiXSk7XFxyXFxuICBcXHQgICAgdmFyIGQ9ZG9jdW1lbnQsIGc9ZC5jcmVhdGVFbGVtZW50KFxcXCJzY3JpcHRcXFwiKSwgcz1kLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJzY3JpcHRcXFwiKVswXTsgZy50eXBlPVxcXCJ0ZXh0L2phdmFzY3JpcHRcXFwiO1xcclxcbiAgXFx0ICAgIGcuZGVmZXI9dHJ1ZTsgZy5hc3luYz10cnVlOyBnLnNyYz11K1xcXCJwaXdpay5qc1xcXCI7IHMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZyxzKTtcXHJcXG4gIFxcdCAgfSkoKTtcXHJcXG4gICAgfVxcclxcblxcdDwvc2NyaXB0PlxcclxcbjwhLS0gRW5kIFBpd2lrIENvZGUgLS0+XFxyXFxuPCUgfSAlPlxcclxcblwiO1xudmFyIExheW91dE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL2FtcC1sYXlvdXQtbW9kZWwuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gIG1vZGVsOiBudWxsLFxuICB0ZW1wbGF0ZTogXy50ZW1wbGF0ZShUZW1wbGF0ZSksXG4gIGVsOiAnI2FtcC1mb290ZXInLFxuICBsYXlvdXRGZXRjaGVkOiBuZXcgJC5EZWZlcnJlZCgpLFxuICBzaG93QWRtaW5Gb290ZXI6IHRydWUsXG4gIHNob3dER0Zvb3RlcjogdHJ1ZSwgIFxuICBldmVudHM6IHtcblx0ICAgIFwiY2xpY2sgLnVzZXItdXJsXCI6IFwic2hvd1VzZXJQcm9maWxlXCJcbiAgfSxcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuc2hvd0FkbWluRm9vdGVyID0gb3B0aW9ucy5zaG93QWRtaW5Gb290ZXI7XG4gICAgdGhpcy5zaG93REdGb290ZXIgPSBvcHRpb25zLnNob3dER0Zvb3RlcjtcbiAgICB2YXIgbGF5b3V0TW9kZWwgPSBuZXcgTGF5b3V0TW9kZWwoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgbGF5b3V0TW9kZWwuZmV0Y2goKS50aGVuKGZ1bmN0aW9uKGxheW91dCkge1xuICAgICAgc2VsZi5tb2RlbCA9IGxheW91dDtcbiAgICAgIHdpbmRvdy5idWlsZERhdGUgPSBsYXlvdXQuYnVpbGREYXRlO1xuICAgICAgd2luZG93LmFtcFZlcnNpb24gPSBsYXlvdXQuYW1wVmVyc2lvbjtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICBzZWxmLmxheW91dEZldGNoZWQucmVzb2x2ZSgpO1xuICAgIH0pO1xuXG4gICAgLy9BTVAtMjA2NDY6IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCB0aGUgZW5kcG9pbnQgaGFzIHJlc3BvbmRlZC5cbiAgICB0aGlzLmxheW91dEZldGNoZWQuZG9uZShmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgfSk7XG4gICAgXy5iaW5kQWxsKHRoaXMsICdyZW5kZXInLCAncmVmcmVzaFVzZXJTZWN0aW9uJyk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgIHRoaXMucmVmcmVzaFVzZXJTZWN0aW9uKCk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUoe1xuICAgICAgICBwcm9wZXJ0aWVzOiBzZWxmLm1vZGVsLFxuICAgICAgICBzaG93QWRtaW5MaW5rczogc2VsZi5zaG93QWRtaW5Gb290ZXIsXG4gICAgICAgIHNob3dER0Zvb3Rlcjogc2VsZi5zaG93REdGb290ZXJcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlZnJlc2hVc2VyU2VjdGlvbjogZnVuY3Rpb24oKSB7XG5cdHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5tb2RlbC5sb2dnZWQgPT09IHRydWUpIHtcbiAgICAgICQoJy5jb250YWluZXItZmx1aWQnLCAkKCcjYW1wLWhlYWRlcicpKS50b2dnbGVDbGFzcygnYW1wVXNlckxvZ2dlZEluJyk7XG4gICAgICAkKCcjaGVhZGVyVXJsJykuYXR0cihcImhyZWZcIiwgXCIvYWltXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKCcjaGVhZGVyVXJsJykuYXR0cihcImhyZWZcIiwgXCIvXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlbC5lbWFpbCkgeyAgICBcdCBcbiAgICAgICQoXCIjaGVhZGVyLW5hbWVcIiApLmNsaWNrKGZ1bmN0aW9uKCkge1x0XHQgIFxuXHRcdCAgc2VsZi5zaG93VXNlclByb2ZpbGUoKTtcbiAgICAgIH0pO1xuICAgICAgJCgnI2hlYWRlci13b3Jrc3BhY2UnLCAkKCcjYW1wLWhlYWRlcicpKS50ZXh0KHRoaXMubW9kZWwud29ya3NwYWNlKTtcbiAgICAgICQoJyNoZWFkZXItd29ya3NwYWNlJywgJCgnI2FtcC1oZWFkZXInKSkucHJvcCgndGl0bGUnLCB0aGlzLm1vZGVsLndvcmtzcGFjZSk7XG4gICAgICAkKCcjaGVhZGVyLW5hbWUgI2hlYWRlci1maXJzdC1uYW1lJywgJCgnI2FtcC1oZWFkZXInKSkudGV4dCh0aGlzLm1vZGVsLmZpcnN0TmFtZSk7XG4gICAgICAkKCcjaGVhZGVyLW5hbWUgI2hlYWRlci1sYXN0LW5hbWUnLCAkKCcjYW1wLWhlYWRlcicpKS50ZXh0KHRoaXMubW9kZWwubGFzdE5hbWUpO1xuICAgIH1cblxuICB9LCAgXG4gIHNob3dVc2VyUHJvZmlsZTogZnVuY3Rpb24oKXtcblx0aWYgKHRoaXMubW9kZWwuZW1haWwpIHtcbiAgICAgICB2YXIgdXJsID0gJy9haW0vZGVmYXVsdC91c2VyUHJvZmlsZS5kb35lZGl0PXRydWV+aWQ9JyArIHRoaXMubW9kZWwudXNlcklkOyAgICAgICBcbiAgICAgICBpZighdGhpcy5wcm9maWxlTG9hZGVkICl7ICAgIFx0ICAgXG4gICAgICAgICAgJCgnLnVzZXItcHJvZmlsZS1jb250ZW50JykubG9hZCh1cmwpOyAgXG4gICAgICAgICAgdGhpcy5wcm9maWxlTG9hZGVkID0gdHJ1ZTtcbiAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgaWYgKHR5cGVvZiAkKCkubW9kYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICBcdCAgICAgICQubm9Db25mbGljdCgpO1xuICAgICAgIH0gICAgICAgXG4gICAgICAgJCgnI3VzZXItcHJvZmlsZScpLm1vZGFsKHtcbiAgICBcdCAgICAgIHNob3c6IHRydWUsXG4gICAgXHQgICAgICBiYWNrZHJvcDogZmFsc2VcbiAgICAgIH0pO1xuXHR9XG4gIH1cblxufSk7XG4iLCJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5yZXF1aXJlKCdib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG52YXIgVGVtcGxhdGUgPSBcIjwhLS0gaW5saW5lIHN0eWxlcyB1c2VkIHNvIHdlIGNhbiByZWxvY2F0ZSBhbXAtYm9pbGVycGxhdGUgbW9kdWxlLS0+XFxuPHN0eWxlPlxcbiAgLyogVGhpcyBkaXJlY3RvcnkgYW5kIHRoZW4gRGFzaGJvYXJkICYgR0lTIG5lZWRcXG4gICAqIHRvIGJlIHJlYnVpbHQgd2l0aCB0aGVpciByZXNwZWN0aXZlIGJyb3dzZXJpZnktcHJvY2Vzc2VzIHRvIHNlZVxcbiAgICogY2hhbmdlcyBmcm9tIHRoaXMgZmlsdGVyLXBvcHVwIGR1ZSB0byBicmZzLCBzZWUgcmVhZG1lLm1kXFxuICAgKi9cXG4gICNhbXAtaGVhZGVyIHtcXG4gICAgZm9udC1mYW1pbHk6IFxcXCJPcGVuIFNhbnNcXFwiLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWY7XFxuICB9XFxuICAjYW1wLWhlYWRlciAubmF2YmFyLWhlYWRlcj5idXR0b24ubmF2YmFyLXRvZ2dsZSB7XFxuICAgIC8qIGZpeCBjb250cmFjdGVkIG1lbnUgaWNvbiB0byBub3QgYmxvY2sgbWFwKi9cXG4gICAgcGFkZGluZzogMnB4O1xcbiAgICBtYXJnaW46IDRweDtcXG4gIH1cXG5cXG4gICNhbXAtaGVhZGVyIC5jb250YWluZXItZmx1aWQuYW1wVXNlckxvZ2dlZEluIHVsLmFtcFB1YmxpYyxcXG4gICNhbXAtaGVhZGVyIC5jb250YWluZXIuYW1wVXNlckxvZ2dlZEluIHVsLmFtcFB1YmxpYyB7XFxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG4gIH1cXG5cXG4gICNhbXAtaGVhZGVyIC5jb250YWluZXItZmx1aWQuYW1wVXNlckxvZ2dlZEluIHVsLmFtcFVzZXJMb2dnZWRJbixcXG4gICNhbXAtaGVhZGVyIC5jb250YWluZXIuYW1wVXNlckxvZ2dlZEluIHVsLmFtcFVzZXJMb2dnZWRJbiB7XFxuICAgIGRpc3BsYXk6IGluaGVyaXQgIWltcG9ydGFudDtcXG4gIH1cXG5cXG4gICNhbXAtaGVhZGVyIC5jb250YWluZXItZmx1aWQgdWwuYW1wUHVibGljLFxcbiAgI2FtcC1oZWFkZXIgLmNvbnRhaW5lciB1bC5hbXBQdWJsaWMge1xcbiAgICBkaXNwbGF5OiBpbmhlcml0ICFpbXBvcnRhbnQ7XFxuICB9XFxuXFxuICAjYW1wLWhlYWRlciAuY29udGFpbmVyLWZsdWlkIHVsLmFtcFVzZXJMb2dnZWRJbixcXG4gICNhbXAtaGVhZGVyIC5jb250YWluZXIgdWwuYW1wVXNlckxvZ2dlZEluIHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcbiAgfVxcblxcblxcbiAgZGl2I2FtcC1oZWFkZXIgbmF2IGRpdi5jb250YWluZXIsXFxuICBkaXYjYW1wLWhlYWRlciBuYXYgZGl2Lm5hdmJhci1jb2xsYXBzZSBhLFxcbiAgZGl2I2FtcC1oZWFkZXIgbmF2IGRpdi5jb250YWluZXItZmx1aWQsXFxuICBkaXYjYW1wLWhlYWRlciBuYXYgZGl2Lm5hdmJhci1jb2xsYXBzZSBhIHtcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgfVxcblxcbiAgZGl2I2FtcC1oZWFkZXIgLm5hdmJhci1icmFuZCB7XFxuICAgIGZvbnQtc2l6ZTogMTZweCAhaW1wb3J0YW50O1xcbiAgICBjb2xvcjogI0U2OTkyMztcXG4gICAgdGV4dC1zaGFkb3c6IDFweCAxcHggNXB4ICNDQ0M7XFxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XFxuICB9XFxuXFxuICBkaXYjYW1wLWhlYWRlciAuZG91YmxlLXJvdyAubmF2YmFyLWJyYW5kIHtcXG4gICAgcGFkZGluZy10b3A6IDhweDtcXG4gICAgaGVpZ2h0OiA0MXB4O1xcbiAgfVxcblxcbiAgLyogU2V2ZXJhbCBwbGFjZXMgaW4gQU1QIGluY2x1ZGUgdGhpbmdzIHRoYXQgd2lsbCBzZXQgdGhpc1xcbiAgICogYmFjayB0byBnaWdhbnRpYyBtYXJnaW5zLlxcbiAgICogOHB4IGZlZWxzIGxpa2UgZ2VuZXJvdXMgcGFkZGluZ1xcbiAgICogNXB4IGlzIHNsaWdodGx5IHRpZ2h0LlxcbiAgICpcXG4gICAqL1xcbiAgZGl2I2FtcC1oZWFkZXIgLnNpbmdsZS1yb3cgLm5hdiA+IGxpID4gYSB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDZweDtcXG4gICAgcGFkZGluZy1sZWZ0OiA2cHg7XFxuICB9XFxuICBkaXYjYW1wLWhlYWRlciAuZG91YmxlLXJvdyAubmF2ID4gbGkgPiBhe1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxMHB4O1xcbiAgICBwYWRkaW5nLWxlZnQ6IDEwcHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XFxuICAgIHBhZGRpbmctdG9wOiA5cHg7XFxuICB9XFxuXFxuICBkaXYjYW1wLWhlYWRlciAuZG91YmxlLXJvdyAjQW1wTWVudXMubmF2ID4gbGk6bnRoLWNoaWxkKDEpID4gYSB7XFxuICAgIC8qIEZvciBmaXJzdCBlbGVtZW50LCBlbGltaW5hdGUgcGFkZGluZyB0byBlbnN1cmUgaXMgZmx1c2guICovXFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gIH1cXG5cXG4gICAgZGl2I2FtcC1oZWFkZXIgLndvcmtzcGFjZS1uYW1lIHtcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICB9XFxuICAgIGRpdiNhbXAtaGVhZGVyIC51c2VyLXVybCB7XFxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgfVxcblxcbiAgLyogbGltaXQgc2l6ZSBvZiB0b3AgbGV2ZWwgbWVudSB0byBwcmV2ZW50IHRyYW5zbGF0aW9ucyB0aGF0IGFyZSB0b28gbG9uZ1xcbiAgICogQXBwbHkgdG8gYSBzcGFuIHNvIHRoYXQgdGhhdCBjYXJldCBkb2Vzbid0IGdldCBjaG9wcGVkIG9mZi5cXG4gICAqL1xcbiAgLyogbWF4LXdpZHRoOlxcbiAgICogMTQxcHggaXMgZ2VuZXJvdXMsIGZpdHMgw4lUVURFUyBFVCBET0NVTUVOVFNcXG4gICAqIDEyNHB4IGlzIG1pbmltdW0gdG8gaW5jbHVkZSAzIHdvcmRzIChNaW5pc3RyeSBvZiA/Py4uLilcXG4gICAqIDExN3B4IGZpdHMgVEFCTEVBVVggREUgQk9SRFxcbiAgICpcXG4gICAqIGRpdi5hbXBVc2VyTG9nZ2VkSW4gaW4gc2VsZWN0b3IgbWFrZXMgdGhpcyBlZmZlY3RpdmUgT05MWSB3aGVuIGxvZ2dlZCBpblxcbiAgICogc2luZ2xlLXJvdyBzZWxlY3RvciBvbmx5IHdoZW4gdXNpbmcgdGhhdCBtb2RlXFxuICAgKi9cXG4gICNhbXAtaGVhZGVyIGRpdi5hbXBVc2VyTG9nZ2VkSW4gLnNpbmdsZS1yb3cgdWwjQW1wTWVudXMgPiAuZHJvcGRvd24gPiBhID4gc3Bhbi5kcm9wZG93bi10ZXh0IHtcXG4gICAgbWF4LXdpZHRoOiAxNDFweDtcXG4gIH1cXG5cXG4gICNhbXAtaGVhZGVyIHVsI0FtcE1lbnVzID4gLmRyb3Bkb3duID4gYSA+IHNwYW4uZHJvcGRvd24tdGV4dCB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICAgIGNvbG9yOiAjM0U2Qzk0O1xcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xcbiAgfVxcblxcblxcbiAgI2FtcC1oZWFkZXIgdWwjQW1wTWVudXMgPiAuZHJvcGRvd24gPiBhID4gc3Bhbi5jYXJldCB7XFxuICAgIC8qIGJ1bXAgdXAgY2FyZXQgdG8gdGhlIGhlaWdodCBvZiB0aGUgdHJ1bmNhdGUtYWJsZSBpbmxpbmUtYmxvY2sgbmV4dCB0byBpdCAqL1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMTFweDtcXG4gICAgY29sb3I6IHJnYigxMSwgMTIsIDI2KTtcXG4gIH1cXG5cXG5cXG4gICNhbXAtaGVhZGVyIC5jb250YWluZXItZmx1aWQubm8tZ3V0dGVycyxcXG4gICNhbXAtaGVhZGVyIC5jb250YWluZXIubm8tZ3V0dGVycyB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDA7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gIH1cXG5cXG4gIC8qIE5vIGd1dHRlcnMgY3JlYXRlcyBzcGFjZSBmb3IgMSBncmlkc3F1YXJlIGxvZ28uXFxuICAgKiBodHRwOi8vanVsaWVubWVsaXNzYXMuY29tL25vLWd1dHRlci1jb2x1bW4tdHJpY2stZm9yLWJvb3RzdHJhcC9cXG4gICAqL1xcbiAgI2FtcC1oZWFkZXIgLmNvbnRhaW5lci1mbHVpZCAucm93Lm5vLWd1dHRlcnMsXFxuICAjYW1wLWhlYWRlciAuY29udGFpbmVyIC5yb3cubm8tZ3V0dGVycyB7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICB9XFxuICAjYW1wLWhlYWRlciAuY29udGFpbmVyLWZsdWlkIC5yb3cubm8tZ3V0dGVycyA+IFtjbGFzc149XFxcImNvbC1cXFwiXSxcXG4gICNhbXAtaGVhZGVyIC5jb250YWluZXItZmx1aWQgLnJvdy5uby1ndXR0ZXJzID4gW2NsYXNzKj1cXFwiIGNvbC1cXFwiXSxcXG4gICNhbXAtaGVhZGVyIC5jb250YWluZXIgLnJvdy5uby1ndXR0ZXJzID4gW2NsYXNzXj1cXFwiY29sLVxcXCJdLFxcbiAgI2FtcC1oZWFkZXIgLmNvbnRhaW5lciAucm93Lm5vLWd1dHRlcnMgPiBbY2xhc3MqPVxcXCJjb2wtXFxcIl0ge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAwO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICB9XFxuXFxuICAjYW1wLWhlYWRlciBuYXYgPiAuY29udGFpbmVyLWZsdWlkID4gZGl2LnJvdzpudGgtY2hpbGQoMSksXFxuICAjYW1wLWhlYWRlciBuYXYgPiAuY29udGFpbmVyID4gZGl2LnJvdzpudGgtY2hpbGQoMSkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGO1xcbiAgfVxcblxcbiAgI2FtcC1oZWFkZXIgbmF2ID4gLmNvbnRhaW5lciA+IGRpdi5yb3c6bnRoLWNoaWxkKDIpLFxcbiAgI2FtcC1oZWFkZXIgbmF2ID4gLmNvbnRhaW5lci1mbHVpZCA+IGRpdi5yb3c6bnRoLWNoaWxkKDIpIHtcXG4gICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNFREVERUQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGN0Y3Rjc7XFxuICB9XFxuXFxuICAjYW1wLWhlYWRlciAuY29udGFpbmVyLWZsdWlkLFxcbiAgI2FtcC1oZWFkZXIgLmNvbnRhaW5lciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkY7IC8qIEZpeGVzIGdyYXkgYXJlYSBpbiBndXR0ZXIgb2Ygc2luZ2xlLXJvdyAqL1xcbiAgfVxcblxcblxcbi8qIFRoZXJlIGlzIGEgc2Vjb25kIHNldCBvZiBndXR0ZXJzIG9uIHRoZSBuYXZiYXIgaXRzZWxmLiAqL1xcbiAgZGl2I2FtcC1oZWFkZXIgLm5hdmJhci1jb2xsYXBzZS5uby1ndXR0ZXJze1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAwO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICB9XFxuXFxuICAvKiBUaGVzZSBmb3VyIHN0eWxlcyBhdm9pZHMgc2V0dGluZyBoYXJkIG1heC13aWR0aHMgb24gdGhlc2UgaXRlbXMgKi9cXG4gICNhbXAtaGVhZGVyIC5hbXBMb2dnZWRJbk1lbnVzIHtcXG4gICAgd2lkdGg6IDk1JTsgLyogYWNjb3VudCBmb3Igc2Nyb2xsYmFyICovXFxuICAgIHRleHQtc2hhZG93OiAxcHggMXB4IDFweCAjQUFBO1xcbiAgfVxcblxcbiAgLyogZ2l2ZSBhIGJpdCBvZiBleHRyYSB3aWR0aCB0byB3b3Jrc3BhY2UgKi9cXG4gICNhbXAtaGVhZGVyIHVsLm5hdi5uYXZiYXItbmF2LmFtcExvZ2dlZEluTWVudXMgbGk6bnRoLWNoaWxkKDEpIHtcXG4gICAgICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIH1cXG4gIC8qIHVzZXIgbmFtZSAqL1xcbiAgI2FtcC1oZWFkZXIgdWwubmF2Lm5hdmJhci1uYXYuYW1wTG9nZ2VkSW5NZW51cyBsaTpudGgtY2hpbGQoMikge1xcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIH1cXG4gIC8qIExvZ291dCAqL1xcbiAgI2FtcC1oZWFkZXIgdWwubmF2Lm5hdmJhci1uYXYuYW1wTG9nZ2VkSW5NZW51cyBsaTpudGgtY2hpbGQoMykge1xcbiAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7IC8qIHByZXZlbnQgdHJhbnNsYXRpb25zIG9mIGxvZ291dCBmcm9tIHdyYXBwaW5nICovXFxuICB9XFxuXFxuICBkaXYjYW1wLWhlYWRlciBkaXYjbG9naW5jb250YWluZXIge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDE0MHB4OyAvKiBJRTkgZml4IHRoYXQgd29ya3MgZXZlcnl3aGVyZTogbWFrZSByb29tIGZvciBncmVlbiBsb2dpbiBidXR0b24gKi9cXG4gIH1cXG5cXG4gIGRpdiNhbXAtaGVhZGVyIC5sb2dpbl9oZXJlIHtcXG4gICAgbWFyZ2luLXRvcDogM3B4ICFpbXBvcnRhbnQ7IC8qIG92ZXJyaWRlIDcgb3RoZXIgc3BlY3MgaW4gYW1wLXdpY2tldCwgYW5kIHZhcmlvdXMgY29waWVzIG9mIGFtcC5jc3MgKi9cXG4gIH1cXG5cXG4gIGh0bWwuaWU5IGRpdiNhbXAtaGVhZGVyIC5sb2dpbl9oZXJlIHtcXG4gICAgbWFyZ2luLXRvcDogLTExcHggIWltcG9ydGFudDsgLyogb3ZlcnJpZGUgNyBvdGhlciBzcGVjcyBpbiBhbXAtd2lja2V0LCBhbmQgdmFyaW91cyBjb3BpZXMgb2YgYW1wLmNzcyAqL1xcbiAgfVxcblxcbiAgLyoqKioqKi9cXG4gIC5zY3JvbGxhYmxlLW1lbnUge1xcbiAgICBoZWlnaHQ6IGF1dG87XFxuICAgIG1heC1oZWlnaHQ6IDQwMHB4O1xcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICB9XFxuXFxuICAuZHJvcGRvd24tc3VibWVudSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG5cXG4gIC5kcm9wZG93bi1zdWJtZW51Pi5kcm9wZG93bi1tZW51IHtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAxMDAlO1xcbiAgICBtYXJnaW4tdG9wOiAtNnB4O1xcbiAgICBtYXJnaW4tbGVmdDogLTFweDtcXG4gICAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAwIDZweCA2cHggNnB4O1xcbiAgICAtbW96LWJvcmRlci1yYWRpdXM6IDAgNnB4IDZweCA2cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDAgNnB4IDZweCA2cHg7XFxuICB9XFxuXFxuICAuZHJvcGRvd24tc3VibWVudTpob3Zlcj4uZHJvcGRvd24tbWVudSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgfVxcblxcbiAgLmRyb3Bkb3duLXN1Ym1lbnU+YTphZnRlciB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBjb250ZW50OiBcXFwiIFxcXCI7XFxuICAgIGZsb2F0OiByaWdodDtcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLXdpZHRoOiA1cHggMCA1cHggNXB4O1xcbiAgICBib3JkZXItbGVmdC1jb2xvcjogI2NjY2NjYztcXG4gICAgbWFyZ2luLXRvcDogNXB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xMHB4O1xcbiAgfVxcblxcbiAgLmRyb3Bkb3duLXN1Ym1lbnU6aG92ZXI+YTphZnRlciB7XFxuICAgIGJvcmRlci1sZWZ0LWNvbG9yOiAjZmZmZmZmO1xcbiAgfVxcblxcbiAgLmRyb3Bkb3duLXN1Ym1lbnUucHVsbC1sZWZ0IHtcXG4gICAgZmxvYXQ6IG5vbmU7XFxuICB9XFxuXFxuICAuZHJvcGRvd24tc3VibWVudS5wdWxsLWxlZnQ+LmRyb3Bkb3duLW1lbnUge1xcbiAgICBsZWZ0OiAtMTAwJTtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxuICAgIC13ZWJraXQtYm9yZGVyLXJhZGl1czogNnB4IDAgNnB4IDZweDtcXG4gICAgLW1vei1ib3JkZXItcmFkaXVzOiA2cHggMCA2cHggNnB4O1xcbiAgICBib3JkZXItcmFkaXVzOiA2cHggMCA2cHggNnB4O1xcbiAgfVxcblxcbjwvc3R5bGU+XFxuPHNjcmlwdCB0eXBlPVxcXCJ0ZXh0L2phdmFzY3JpcHRcXFwiPlxcbiAgZnVuY3Rpb24gc3dpdGNoVHJhbnNsYXRpb24gKHVybCkge1xcbiAgICAkKCcjYmFja1VybCcpLnZhbChkb2N1bWVudC5sb2NhdGlvbi5ocmVmKTtcXG4gICAgZG9jdW1lbnQubW9kZVN3aXRjaEZvcm0uYWN0aW9uID0gdXJsO1xcbiAgICBkb2N1bWVudC5tb2RlU3dpdGNoRm9ybS5zdWJtaXQoKTtcXG4gIH1cXG48L3NjcmlwdD5cXG48Zm9ybSBuYW1lPVxcXCJtb2RlU3dpdGNoRm9ybVxcXCIgbWV0aG9kPVxcXCJwb3N0XFxcIiBhY3Rpb249XFxcIi90cmFuc2xhdGlvbi9zd2l0Y2hNb2RlLmRvXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+XFxuICA8aW5wdXQgdHlwZT1cXFwiaGlkZGVuXFxcIiBuYW1lPVxcXCJiYWNrVXJsXFxcIiBpZD1cXFwiYmFja1VybFxcXCIgdmFsdWU9XFxcIlxcXCI+XFxuPC9mb3JtPlxcbjwlXFxuLyoqKlxcbiAqIFNpbmdsZSBSb3cgSGVhZGVyIERlc2lnbiAodXNlZCB3aGVuIG9wdGlvbmFsbHkgcmVxdWVzdGVkOiBvbiBHSVMpXFxuICogVXNlZnVsIGZvciBmaXhlZCBoZWlnaHQgYXBwcy5cXG4gKlxcbiAqIENvbnRhaW5lci1mbHVpZCBzdHJ1Y3R1cmU6XFxuICogcm93XFxuICogIGNvbHVtbiBuYXZiYXItYnJhbmQgKGxvZ28pXFxuICogIGNvbHVtbiBuYXZiYXItY29sbGFwc2VcXG4gKiAgICBuZXN0ZWQgcm93OlxcbiAqICAgICAgY29sdW1ucyBBbXBNZW51cyAocHVibGljIG9yIGludGVybmFsIG1lbnVzIHNob3duIGFzIHByb3ZpZGVkIGJ5IEFQSSlcXG4gKiAgICAgIG5lc3RlZCByb3cgYW1wVXNlckxvZ2dlZEluTWVudXMgKHNob3duIHdoZW4gbG9nZ2VkIGluLCBpbmNsOiB3b3Jrc3BhY2UsIHVzZXIsIGxvZ291dCk6XFxuICogICAgICAgIDMgY29sdW1uc1xcbiAqICBsb2dpbl9oZXJlIChpZ25vcmVzIGJvb3RzdHJhcCBjb250YWluZXIgc3RydWN0dXJlOyBzaG93biB3aGVuIGxvZ2dlZCBvdXQpXFxuICogIGRpdiNsb2dpbmNvbnRhaW5lcjogaW5zZXJ0ZWQgYnkgalF1ZXJ5ICsgcmVuZGVyZWQgYnkgSlNQXFxuICoqKi9cXG5cXG4gIGlmICh1c2VTaW5nbGVSb3dIZWFkZXIpIHtcXG4gJT5cXG48bmF2IGNsYXNzPVxcXCJuYXZiYXIgbmF2YmFyLWRlZmF1bHQgc2luZ2xlLXJvd1xcXCIgcm9sZT1cXFwibmF2aWdhdGlvblxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXItZmx1aWRcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgbm8tZ3V0dGVyc1xcXCI+XFxuICAgICAgPCEtLSAuYW1wVXNlckxvZ2dlZEluIGhpZGVzIHB1YmxpYyB2ZXJzaW9uLS0+XFxuXFxuICAgICAgPCEtLSBCcmFuZCBhbmQgdG9nZ2xlIGdldCBncm91cGVkIGZvciBiZXR0ZXIgbW9iaWxlIGRpc3BsYXkgLS0+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWhlYWRlciBjb2wtc20tMVxcXCI+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIm5hdmJhci10b2dnbGVcXFwiIGRhdGEtdG9nZ2xlPVxcXCJjb2xsYXBzZVxcXCIgZGF0YS10YXJnZXQ9XFxcIiNicy1leGFtcGxlLW5hdmJhci1jb2xsYXBzZS0xXFxcIj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPlRvZ2dsZSBuYXZpZ2F0aW9uPC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbi1iYXJcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxhIGlkPVxcXCJoZWFkZXJVcmxcXFwiIGNsYXNzPVxcXCJuYXZiYXItYnJhbmRcXFwiIGhyZWY9XFxcIi9cXFwiIGRhdGEtaTE4bj1cXFwiW3RpdGxlXWFtcC5jb21tb246cGxhdGZvcm1cXFwiPlxcbiAgICAgICAgICA8c3Bhbj5cXG4gICAgICAgICAgICA8aW1nIGNsYXNzPVxcXCJmbGFnXFxcIiBzcmM9XFxcIi9haW0vZGVmYXVsdC9kaXNwbGF5RmxhZy5kb1xcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgd2lkdGg9XFxcIjMwXFxcIj5cXG4gICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBkYXRhLWkxOG49XFxcImFtcC5jb21tb246cGxhdGZvcm0tc2hvcnRcXFwiPkFNUDwvc3Bhbj48L2E+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLTExXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbGxhcHNlIG5hdmJhci1jb2xsYXBzZSByb3cgbm8tZ3V0dGVyc1xcXCIgaWQ9XFxcImJzLWV4YW1wbGUtbmF2YmFyLWNvbGxhcHNlLTFcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOCBjb2wtc20tMTBcXFwiPlxcbiAgICAgICAgICAgIDx1bCBpZD1cXFwiQW1wTWVudXNcXFwiIGNsYXNzPVxcXCJuYXYgbmF2YmFyLW5hdiBtZW51c1xcXCI+XFxuXFxuICAgICAgICAgICAgICA8IS0tIEZpbGUgLS0+XFxuXFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNCBjb2wtc20tMlxcXCI+XFxuICAgICAgICAgICAgICA8dWwgY2xhc3M9XFxcInJvdyBuby1ndXR0ZXJzIG5hdiBuYXZiYXItbmF2IGFtcFVzZXJMb2dnZWRJbiBhbXBMb2dnZWRJbk1lbnVzXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpIGlkPVxcXCJoZWFkZXItd29ya3NwYWNlLWxpXFxcIiBjbGFzcz1cXFwiY29sLXNtLTkgY29sLW1kLTZcXFwiPjxhIHRpdGxlPVxcXCJXb3Jrc3BhY2VcXFwiIGNsYXNzPVxcXCJ3b3Jrc3BhY2UtbmFtZVxcXCIgaWQ9XFxcImhlYWRlci13b3Jrc3BhY2VcXFwiPiZuYnNwOzwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgaWQ9XFxcImhlYWRlci1uYW1lXFxcIiBjbGFzcz1cXFwiaGlkZGVuLXhzIGhpZGRlbi1zbSBjb2wtbWQtNFxcXCI+XFxuICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcInVzZXItdXJsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPVxcXCJoZWFkZXItZmlyc3QtbmFtZVxcXCI+Jm5ic3A7PC9zcGFuPiZuYnNwOzxzcGFuIGlkPVxcXCJoZWFkZXItbGFzdC1uYW1lXFxcIj4mbmJzcDs8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgICA8bGkgaWQ9XFxcImhlYWRlci1sb2dvdXRcXFwiIGNsYXNzPVxcXCJjb2wtc20tMlxcXCI+PGEgZGF0YS1pMThuPVxcXCJhbXAuY29tbW9uOnRpdGxlLWxvZ291dFxcXCIgaHJlZj1cXFwiL2FpbS9qX3NwcmluZ19sb2dvdXRcXFwiID5Mb2dvdXQ8L2E+PC9saT5cXG4gICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgICA8JSBpZihzaG93TG9naW4pIHsgJT5cXG4gICAgICAgICAgICAgICAgPCUgaWYobG9naW5Ecm9wZG93bil7ICU+XFxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibG9naW5faGVyZVxcXCIgaWQ9XFxcInNob3dfbG9naW5fcG9wXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxvZ2luX2hlcmVfY29udFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgIDxhIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjp0aXRsZS1sb2dpblxcXCIgaHJlZj1cXFwiamF2YXNjcmlwdDp2b2lkKDApXFxcIj5Mb2dpbjwvYT5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8JSB9IGVsc2UgeyAlPlxcbiAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwibmF2IG5hdmJhci1uYXYgYW1wUHVibGljIG5hdmJhci1yaWdodFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGkgaWQ9XFxcImhlYWRlci1sb2dpblxcXCI+PGEgZGF0YS1pMThuPVxcXCJhbXAuY29tbW9uOnRpdGxlLWxvZ2luXFxcIiBocmVmPVxcXCIvbG9naW4uZG9cXFwiID5Mb2dpbjwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICAgIDwhLS0gZGl2I2xvZ2luY29udGFpbmVyIHdpdGggYW5jaG9ycyBnZXRzIGFwcGVuZGVkIGhlcmUgLS0+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgIDwvZGl2PlxcbiAgICA8IS0tIENvbGxlY3QgdGhlIG5hdiBsaW5rcywgZm9ybXMsIGFuZCBvdGhlciBjb250ZW50IGZvciB0b2dnbGluZyAtLT5cXG4gIDwvZGl2PjwhLS0gLy5jb250YWluZXItZmx1aWQgLS0+XFxuPC9uYXY+XFxuIDwlIH0gZWxzZSB7ICU+XFxuXFxuPCUgLyoqKlxcbiAqIERvdWJsZSBSb3cgSGVhZGVyIERlc2lnbiAodXNlZCBieSBkZWZhdWx0KVxcbiAqXFxuICogQ29udGFpbmVyLUZsdWlkIHN0cnVjdHVyZTpcXG4gKiByb3dcXG4gKiAgY29sdW1uIG5hdmJhci1icmFuZCAobG9nbylcXG4gKiAgY29sdW1uIG5hdmJhci1jb2xsYXBzZVxcbiAqICAgIG5lc3RlZCByb3c6XFxuICogICAgICAgIG5lc3RlZCByb3cgYW1wVXNlckxvZ2dlZEluTWVudXMgKHNob3duIHdoZW4gbG9nZ2VkIGluLCBpbmNsOiB3b3Jrc3BhY2UsIHVzZXIsIGxvZ291dCk6XFxuICAgICAgICAgICAgMyBjb2x1bW5zXFxuICogcm93XFxuICogICAgY29sdW1ucyBBbXBNZW51cyAocHVibGljIG9yIGludGVybmFsIG1lbnVzIHNob3duIGFzIHByb3ZpZGVkIGJ5IEFQSSlcXG4gKiAgbG9naW5faGVyZSAoaWdub3JlcyBib290c3RyYXAgY29udGFpbmVyIHN0cnVjdHVyZSwgc2hvd24gd2hlbiBsb2dnZWQgb3V0KVxcbiAqICBkaXYjbG9naW5jb250YWluZXI6IGluc2VydGVkIGJ5IGpRdWVyeSArIHJlbmRlcmVkIGJ5IEpTUFxcbiAqKiovICU+XFxuPG5hdiBjbGFzcz1cXFwibmF2YmFyIG5hdmJhci1kZWZhdWx0IGRvdWJsZS1yb3dcXFwiIHJvbGU9XFxcIm5hdmlnYXRpb25cXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyLWZsdWlkIG5vLWd1dHRlcnNcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgbm8tZ3V0dGVyc1xcXCI+XFxuICAgICAgPCEtLSAuYW1wVXNlckxvZ2dlZEluIGhpZGVzIHB1YmxpYyB2ZXJzaW9uLS0+XFxuXFxuICAgICAgPCEtLSBCcmFuZCBhbmQgdG9nZ2xlIGdldCBncm91cGVkIGZvciBiZXR0ZXIgbW9iaWxlIGRpc3BsYXkgLS0+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWhlYWRlciBjb2wtc20tMSBjb2wtc20tb2Zmc2V0LTFcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJuYXZiYXItdG9nZ2xlXFxcIiBkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiIGRhdGEtdGFyZ2V0PVxcXCIjYnMtZXhhbXBsZS1uYXZiYXItY29sbGFwc2UtMVxcXCI+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5Ub2dnbGUgbmF2aWdhdGlvbjwvc3Bhbj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uLWJhclxcXCI+PC9zcGFuPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbi1iYXJcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8YSBpZD1cXFwiaGVhZGVyVXJsXFxcIiBjbGFzcz1cXFwibmF2YmFyLWJyYW5kXFxcIiBocmVmPVxcXCIvXFxcIiBkYXRhLWkxOG49XFxcIlt0aXRsZV1hbXAuY29tbW9uOnBsYXRmb3JtXFxcIj5cXG4gICAgICAgICAgPHNwYW4+XFxuICAgICAgICAgICAgPGltZyBjbGFzcz1cXFwiZmxhZ1xcXCIgc3JjPVxcXCIvYWltL2RlZmF1bHQvZGlzcGxheUZsYWcuZG9cXFwiIGhlaWdodD1cXFwiMjBcXFwiIHdpZHRoPVxcXCIzMFxcXCI+XFxuICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgPHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuY29tbW9uOnBsYXRmb3JtLXNob3J0XFxcIj5BTVA8L3NwYW4+PC9hPlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS05XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbGxhcHNlIG5hdmJhci1jb2xsYXBzZSByb3cgbm8tZ3V0dGVyc1xcXCIgaWQ9XFxcImJzLWV4YW1wbGUtbmF2YmFyLWNvbGxhcHNlLTFcXFwiPlxcbiAgICAgICAgICA8IS0tIFRvIGNoYW5nZSB3b3Jrc3BhY2UvdXNlciB0cnVuY2F0aW9uIGxlbmd0aCwgZWRpdCB0aGUgb2Zmc2V0IGFuZCBncmlkIG51bWJlciBiZWxvdzotLT5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXNtLW9mZnNldC01IGNvbC1zbS03XFxcIj5cXG4gICAgICAgICAgICA8dWwgY2xhc3M9XFxcInJvdyBuby1ndXR0ZXJzIG5hdiBuYXZiYXItbmF2IGFtcFVzZXJMb2dnZWRJbiBhbXBMb2dnZWRJbk1lbnVzXFxcIj5cXG4gICAgICAgICAgICAgIDxsaSBpZD1cXFwiaGVhZGVyLXdvcmtzcGFjZS1saVxcXCIgY2xhc3M9XFxcImNvbC1zbS05IGNvbC1tZC02XFxcIj48YSB0aXRsZT1cXFwiV29ya3NwYWNlXFxcIiBjbGFzcz1cXFwid29ya3NwYWNlLW5hbWVcXFwiIGlkPVxcXCJoZWFkZXItd29ya3NwYWNlXFxcIj4mbmJzcDs8L2E+PC9saT5cXG4gICAgICAgICAgICAgIDxsaSBpZD1cXFwiaGVhZGVyLW5hbWVcXFwiIGNsYXNzPVxcXCJoaWRkZW4teHMgaGlkZGVuLXNtIGNvbC1tZC00XFxcIj5cXG4gICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcInVzZXItdXJsXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8c3BhbiBpZD1cXFwiaGVhZGVyLWZpcnN0LW5hbWVcXFwiPiZuYnNwOzwvc3Bhbj4mbmJzcDs8c3BhbiBpZD1cXFwiaGVhZGVyLWxhc3QtbmFtZVxcXCI+Jm5ic3A7PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgPGxpIGlkPVxcXCJoZWFkZXItbG9nb3V0XFxcIiBjbGFzcz1cXFwiY29sLXNtLTJcXFwiPjxhIGRhdGEtaTE4bj1cXFwiYW1wLmNvbW1vbjp0aXRsZS1sb2dvdXRcXFwiIGhyZWY9XFxcIi9haW0val9zcHJpbmdfbG9nb3V0XFxcIiA+TG9nb3V0PC9hPjwvbGk+XFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgICA8JSBpZihzaG93TG9naW4pIHsgJT5cXG4gICAgICAgICAgICAgIDwlIGlmKGxvZ2luRHJvcGRvd24peyAlPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsb2dpbl9oZXJlXFxcIiBpZD1cXFwic2hvd19sb2dpbl9wb3BcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxvZ2luX2hlcmVfY29udFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8YSBkYXRhLWkxOG49XFxcImFtcC5jb21tb246dGl0bGUtbG9naW5cXFwiIGhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKVxcXCI+TG9naW48L2E+XFxuICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgPCUgfSBlbHNlIHsgJT5cXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2YmFyLW5hdiBhbXBQdWJsaWMgbmF2YmFyLXJpZ2h0XFxcIj5cXG4gICAgICAgICAgICAgICAgICA8bGkgaWQ9XFxcImhlYWRlci1sb2dpblxcXCI+PGEgZGF0YS1pMThuPVxcXCJhbXAuY29tbW9uOnRpdGxlLWxvZ2luXFxcIiBocmVmPVxcXCIvbG9naW4uZG9cXFwiID5Mb2dpbjwvYT48L2xpPlxcbiAgICAgICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgICAgPCUgfSAlPlxcbiAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgICA8IS0tIGRpdiNsb2dpbmNvbnRhaW5lciB3aXRoIGFuY2hvcnMgZ2V0cyBhcHBlbmRlZCBoZXJlIC0tPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93IG5vLWd1dHRlcnNcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMSBjb2wtc20tb2Zmc2V0LTFcXFwiPlxcbiAgICAgICAgPHVsIGlkPVxcXCJBbXBNZW51c1xcXCIgY2xhc3M9XFxcIm5hdiBuYXZiYXItbmF2IG1lbnVzXFxcIj5cXG5cXG4gICAgICAgICAgPCEtLSBGaWxlIC0tPlxcblxcbiAgICAgICAgPC91bD5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj48L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDwhLS0gQ29sbGVjdCB0aGUgbmF2IGxpbmtzLCBmb3JtcywgYW5kIG90aGVyIGNvbnRlbnQgZm9yIHRvZ2dsaW5nIC0tPlxcbiAgPC9kaXY+PCEtLSAvLmNvbnRhaW5lci1mbHVpZCAtLT5cXG48L25hdj5cXG5cXG48JVxcbiAgfSAlPlxcblwiO1xudmFyIE1lbnVDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbnMvYW1wLW1lbnVzLWNvbGxlY3Rpb24uanMnKTtcbnZhciBNZW51TW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvYW1wLW1lbnVzLW1vZGVsLmpzJyk7XG5cbnZhciBTdWJtZW51VmlldyA9IHJlcXVpcmUoJy4vc3VibWVudS1jb21wb3NpdGV2aWV3LmpzJyk7XG52YXIgQWJvdXRWaWV3ID0gcmVxdWlyZSgnLi9hYm91dC12aWV3LmpzJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gIGVsOiAnI2FtcC1oZWFkZXInLFxuICBhcHBlbmRFbDogJyNBbXBNZW51cycsXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKFRlbXBsYXRlKSxcbiAgbWVudVJlbmRlcmVkOiBuZXcgJC5EZWZlcnJlZCgpLFxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgI3Nob3dfbG9naW5fcG9wJzogJ29wZW5Mb2dpbkJveCdcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jb2xsZWN0aW9uID0gbmV3IE1lbnVDb2xsZWN0aW9uKCk7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gb3B0aW9ucy50cmFuc2xhdG9yO1xuICAgIHRoaXMuc2hvd0xvZ2luID0gb3B0aW9ucy5zaG93TG9naW47XG4gICAgdGhpcy51c2VTaW5nbGVSb3dIZWFkZXIgPSBvcHRpb25zLnVzZVNpbmdsZVJvd0hlYWRlcjtcbiAgICB0aGlzLmxvZ2luRHJvcGRvd24gPSAhIW9wdGlvbnMubG9naW5Ecm9wZG93bjtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5jb2xsZWN0aW9uLmZldGNoKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgfSk7XG4gICAgdGhpcy5maXJzdFJlbmRlciA9IHRydWU7XG4gICAgdGhpcy5hYm91dCA9IG5ldyBBYm91dFZpZXcob3B0aW9ucyk7XG4gICAgXy5iaW5kQWxsKHRoaXMsICdhZGRPbmUnLCAnYWRkQWxsJywgJ3Nob3dBYm91dCcpO1xuXG4gIH0sXG5cbiAgYWRkQWxsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbGxlY3Rpb24uZWFjaCh0aGlzLmFkZE9uZSk7XG4gICAgdGhpcy5tZW51UmVuZGVyZWQucmVzb2x2ZSgpO1xuICB9LFxuXG4gIGFkZE9uZTogZnVuY3Rpb24obW9kZWwpIHtcbiAgICB2aWV3ID0gbmV3IFN1Ym1lbnVWaWV3KHtcbiAgICAgIG1vZGVsOiBtb2RlbFxuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuVG8odmlldywgJ3Nob3dBYm91dCcsIHRoaXMuc2hvd0Fib3V0KTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5saXN0ZW5Ubyh2aWV3LCAnc3dpdGNoTGFuZ3VhZ2UnLCBmdW5jdGlvbihsbmcpIHtcbiAgICAgIHNlbGYudHJhbnNsYXRvci5zZXRMYW5ndWFnZShsbmcubGFuZ3VhZ2UpLmFsd2F5cyhmdW5jdGlvbihkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xuICAgIFx0ICBpZiAodGV4dFN0YXR1cyAhPT0gXCJlcnJvclwiKSB7XG4gICAgXHRcdCAgbG9jYXRpb24ucmVsb2FkKCk7XG4gICAgXHQgIH0gZWxzZSB7XG4gICAgXHRcdCAgLy8gQU1QLTIxNzE0OiBGb3Igc29tZSB1bmtub3duIHJlYXNvbiB0aGVyZSBhcmUgMiBhc3luYyBjYWxscyB0byB0aGUgZW5kcG9pbnQgYW5kIEZGIHNvbWV0aW1lcyB0YWtlcyB0aGUgZXJyb3IgZnJvbSB0aGUgMXN0IGNhbGwuXG4gICAgICAgIFx0ICBzZWxmLnRyYW5zbGF0b3Iuc2V0TGFuZ3VhZ2UobG5nLmxhbmd1YWdlKS5hbHdheXMoZnVuY3Rpb24oZGF0YSwgdGV4dFN0YXR1cywganFYSFIpIHtcbiAgICBcdFx0XHQgIGxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIFx0XHQgIH0pO1xuICAgIFx0ICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2aWV3LnJlbmRlcigpO1xuICAgICQodGhpcy5hcHBlbmRFbCkuYXBwZW5kKHZpZXcuZWwpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLmZpcnN0UmVuZGVyKSB7XG4gICAgICB0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUoe1xuICAgICAgICBzaG93TG9naW46IHNlbGYuc2hvd0xvZ2luLFxuICAgICAgICBsb2dpbkRyb3Bkb3duOiBzZWxmLmxvZ2luRHJvcGRvd24sXG4gICAgICAgIHVzZVNpbmdsZVJvd0hlYWRlcjogc2VsZi51c2VTaW5nbGVSb3dIZWFkZXJcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuYWRkQWxsKCk7XG4gICAgICB0aGlzLmZpcnN0UmVuZGVyID0gZmFsc2U7XG4gICAgICAvL0FzaGFtZWQgc3RpbGwsIEknbSBmb3JjZWQgdG8gdGhpcywgYmVjYXVzZSB0aGUgZm9ybSBjb21lcyBmcm9tIGBsb2dpbldpZGdldDMuanNgIGFuZCBJJ20gdG9vIGFmcmFpZCB0byB0b3VjaCBpdFxuICAgICAgJCgnI3Nob3dfbG9naW5fcG9wX2JveCcpLmluc2VydEJlZm9yZSgnI3Nob3dfbG9naW5fcG9wJyk7XG4gICAgICAkKCcjbG9naW5jb250YWluZXInKS5pbnNlcnRBZnRlcignI3Nob3dfbG9naW5fcG9wJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2hvd0Fib3V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoJCgnI2Fib3V0LXBvcHVwJykubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMuJGVsLnBhcmVudCgpLmFwcGVuZCh0aGlzLmFib3V0LnJlbmRlcigpLmVsKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAkKCkubW9kYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICQubm9Db25mbGljdCgpO1xuICAgIH1cbiAgICAkKCcjYWJvdXQtcG9wdXAnKS5tb2RhbCh7XG4gICAgICBzaG93OiB0cnVlLFxuICAgICAgYmFja2Ryb3A6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZURPTSgkKCcjYWJvdXQtcG9wdXAnKVswXSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIG9wZW5Mb2dpbkJveDogZnVuY3Rpb24oKSB7XG4gICAgJChcImRpdiNzaG93X2xvZ2luX3BvcF9ib3hcIikuc2hvdygpO1xuICAgICQoXCIjal91c2VybmFtZVwiKS5mb2N1cygpO1xuICB9XG59KTtcbiIsIlxudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIFRlbXBsYXRlID0gXCI8JVxcbiAgLyogUHJlcGFyZSB0aGUgQSB0YWcgYXQgdG9wIGxldmVsIG1lbnVzICovXFxuICBpZiAoIW9iai51cmwpIHtcXG4gICAgICBvYmoudXJsID0gJyMnO1xcbiAgICAgIG9iai5jbGFzc05hbWUgPSAnZHJvcGRvd24tdG9nZ2xlJztcXG4gICAgICBvYmouZGF0YVRvZ2dsZSA9ICdkYXRhLXRvZ2dsZT1cXFwiZHJvcGRvd25cXFwiJztcXG4gICAgfVxcbiAgICBlbHNlIHtcXG4gICAgICBvYmouY2xhc3NOYW1lID0gJyc7XFxuICAgICAgb2JqLmRhdGFUb2dnbGUgPSAnJztcXG4gICAgfVxcblxcbiAgICBpZiAob2JqLnRhYikge1xcbiAgICAgIG9iai50YWJUYXJnZXQgPSAndGFyZ2V0PVxcXCJfYmxhbmtcXFwiJztcXG4gICAgfVxcbiAgICBlbHNlIHtcXG4gICAgICBvYmoudGFiVGFyZ2V0ID0gJyc7XFxuICAgIH1cXG4gICAgJT5cXG48JVxcbi8qIFRPRE8gZXNjYXBlIHRoZSBjb2RlIGluIEhUTUwgKi9cXG4lPlxcbjxhIGhyZWY9XFxcIjwlPSB1cmwgJT5cXFwiIGNsYXNzPVxcXCI8JT0gY2xhc3NOYW1lICU+XFxcIiA8JT0gZGF0YVRvZ2dsZSAlPiA8JT0gb2JqLnRhYlRhcmdldCAlPiA+XFxuICA8c3BhbiBjbGFzcz1cXFwiZHJvcGRvd24tdGV4dFxcXCIgdGl0bGU9XFxcIjwlPSBvYmoubmFtZS50cmltKCkgJT5cXFwiPjwlPSBvYmoubmFtZS50cmltKCkgJT4mbmJzcDs8L3NwYW4+PCUgaWYgKG9iai5jaGlsZHJlbiAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoID4gMCkgeyAlPjxzcGFuIGNsYXNzPVxcXCJjYXJldFxcXCI+PC9zcGFuPjwlIH0gJT5cXG48L2E+XFxuPCUgaWYgKG9iai5jaGlsZHJlbiAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7ICU+XFxuICA8dWwgY2xhc3M9XFxcImNoaWxkcmVuIGRyb3Bkb3duLW1lbnVcXFwiIHJvbGU9XFxcIm1lbnVcXFwiPlxcbiAgPCUgXy5lYWNoKG9iai5jaGlsZHJlbiwgZnVuY3Rpb24obW9kZWwpIHsgJT5cXG5cXG4gICAgPCVcXG4gICAgICAvKiBQcmVwYXJlIHRoZSBBIHRhZyBhdCBzZWNvbmQgbGV2ZWwgbWVudXMgKi9cXG4gICAgICBpZiAobW9kZWwuY2hpbGRyZW4gJiYgbW9kZWwuY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XFxuICAgICAgICBtb2RlbC5kcm9wZG93blN1Ym1lbnUgPSAnZHJvcGRvd24tc3VibWVudSc7XFxuICAgICAgIH07XFxuXFxuICAgICAgIGlmICghbW9kZWwudG9vbHRpcCkge1xcbiAgICAgICAgIG1vZGVsLnRvb2x0aXAgPSAnJztcXG4gICAgICAgfTtcXG4gICAgICAgdmFyIGVsZW1lbnRDbGFzcyA9ICcybmQtbGV2ZWwtaXRlbSc7XFxuICAgICAgIGlmIChtb2RlbC5sYW5ndWFnZSkge1xcblxcdFxcdFxcdCBlbGVtZW50Q2xhc3MgPSBlbGVtZW50Q2xhc3MrICcgbGFuZ3VhZ2UnO1xcblxcdCAgIH1cXG4gICAgICAgaWYgKG1vZGVsLnBvcHVwKSB7XFxuICAgICAgIFxcdCBlbGVtZW50Q2xhc3MgPSBlbGVtZW50Q2xhc3MgKyAnIHBvcHVwJztcXG4gICAgICAgfVxcbiAgICAgICBpZiAobW9kZWwudGFiKSB7XFxuICAgICAgICAgbW9kZWwudGFiVGFyZ2V0ID0gJ3RhcmdldD1cXFwiX2JsYW5rXFxcIic7XFxuICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgbW9kZWwudGFiVGFyZ2V0ID0gJyc7XFxuICAgICAgIH1cXG4gICAgICAgdmFyIGVsZW1lbnRVcmwgPSBtb2RlbC51cmw7XFxuICAgICAgIGlmIChtb2RlbC5wb3N0ID09PSB0cnVlKSB7XFxuICAgICAgICAgZWxlbWVudFVybCA9ICdqYXZhc2NyaXB0OnN3aXRjaFRyYW5zbGF0aW9uIChcXFwiJytlbGVtZW50VXJsKydcXFwiKSc7XFxuXFxuICAgICAgIH1cXG4gICAgICAgaWYgKCFtb2RlbC51cmwpIHtcXG4gICAgICAgIGVsZW1lbnRVcmwgPSAnamF2YXNjcmlwdDo7JztcXG4gICAgICAgfVxcbiAgICAgICAvKiBpZiBpdCBkb2Vzbid0IGhhdmUgY2hpbGRyZW4sIG5vciB1cmwuIHRoZW4gaXQgaXMgdGhlIEFib3V0ICovXFxuICAgICAgIGlmICghbW9kZWwudXJsICYmICFtb2RlbC5jaGlsZHJlbikge1xcbiAgICAgICBlbGVtZW50Q2xhc3MgPSBlbGVtZW50Q2xhc3MgKyAnIGFib3V0LWFtcCc7XFxuICAgICAgIH1cXG4gICAgJT5cXG5cXG4gICAgPGxpIGNsYXNzPSdkcm9wZG93biA8JT0gbW9kZWwuZHJvcGRvd25TdWJtZW51ICU+JyA+XFxuICAgIDxhIGhyZWY9JzwlPSAgZWxlbWVudFVybCAlPicgdGl0bGU9XFxcIjwlPSBtb2RlbC50b29sdGlwICU+XFxcIiBvbmNsaWNrPVxcXCJyZXR1cm4gY2FuRXhpdCgpXFxcIiBjbGFzcz1cXFwiPCU9IGVsZW1lbnRDbGFzcyAlPlxcXCIgPCU9IG1vZGVsLnRhYlRhcmdldCAlPiA+PCU9IG1vZGVsLm5hbWUgJT48L2E+XFxuXFxuICAgIDwlXFxuICAgICAgaWYgKG1vZGVsLmNoaWxkcmVuICYmIG1vZGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xcbiAgICAgJT5cXG5cXG4gICAgICA8dWwgY2xhc3M9XFxcImNoaWxkcmVuIGRyb3Bkb3duLW1lbnUgc2Nyb2xsYWJsZS1tZW51XFxcIiByb2xlPVxcXCJtZW51XFxcIj5cXG4gICAgICA8JSBfLmVhY2gobW9kZWwuY2hpbGRyZW4sIGZ1bmN0aW9uKHN1Ym1vZGVsKSB7ICU+XFxuXFxuICAgICAgICA8JVxcbiAgICAgICAgICAvKiBQcmVwYXJlIHRoZSBBIHRhZyBhdCB0aGlyZCBsZXZlbCBtZW51cyAqL1xcbiAgICAgICAgICBpZiAoIXN1Ym1vZGVsLnVybCkge1xcbiAgICAgICAgICAgIHN1Ym1vZGVsLnVybCA9ICcjJztcXG4gICAgICAgICAgfTtcXG5cXHRcXHQgIHZhciBpdGVtQ2xhc3MgPSAnM3JkLWxldmVsLWl0ZW0nO1xcblxcdFxcdCAgaWYgKHN1Ym1vZGVsLmxhbmd1YWdlKSB7XFxuXFx0XFx0XFx0IGl0ZW1DbGFzcyA9IGl0ZW1DbGFzcysgJyBsYW5ndWFnZSc7XFxuXFx0XFx0ICAgfVxcblxcdFxcdCAgaWYgKCFzdWJtb2RlbC50b29sdGlwKSB7XFxuICAgICAgICAgICAgc3VibW9kZWwudG9vbHRpcCA9ICcnO1xcbiAgICAgICAgICB9O1xcblxcbiAgICAgICAgICBpZiAoc3VibW9kZWwudGFiKSB7XFxuICAgICAgICAgICAgc3VibW9kZWwudGFiVGFyZ2V0PSd0YXJnZXQ9XFxcIl9ibGFua1xcXCInO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHN1Ym1vZGVsLnRhYlRhcmdldCA9ICcnO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgJT5cXG5cXG4gICAgICAgIDxsaSBjbGFzcz1cXFwibWVudS1pdGVtXFxcIj48YSBocmVmPVxcXCI8JT0gc3VibW9kZWwudXJsICU+XFxcIiBvbmNsaWNrPVxcXCJyZXR1cm4gY2FuRXhpdCgpXFxcIiBjbGFzcz1cXFwiPCU9IGl0ZW1DbGFzcyAlPlxcXCIgPCU9IHN1Ym1vZGVsLnRhYlRhcmdldCAlPiB0aXRsZT1cXFwiPCU9IHN1Ym1vZGVsLnRvb2x0aXAgJT5cXFwiPjwlPSBzdWJtb2RlbC5uYW1lICU+PC9hPjwvbGk+XFxuXFxuICAgICAgPCUgfSkgJT5cXG4gICAgICA8L3VsPlxcbiAgICA8JSB9ICU+XFxuXFxuICAgIDwvbGk+XFxuXFxuICA8JSB9KTsgJT5cXG4gIDwvdWw+XFxuPCUgfSU+XFxuPCEtLVxcbjxsaSBjbGFzcz1cXFwibWVudS1pdGVtIGRyb3Bkb3duIGRyb3Bkb3duLXN1Ym1lbnVcXFwiPjxhIGNsYXNzPVxcXCJkcm9wZG93bi10b2dnbGVcXFwiIGRhdGEtdG9nZ2xlPVxcXCJkcm9wZG93blxcXCI+XFxuPHVsIGNsYXNzPVxcXCJjaGlsZHJlbiBkcm9wZG93bi1tZW51IHNjcm9sbGFibGUtbWVudVxcXCIgcm9sZT1cXFwibWVudVxcXCI+XFxuICAgICAgPGxpIGNsYXNzPVxcXCJtZW51LWl0ZW0gZmlyc3Qtb2YtdHlwZVxcXCIgaWQ9XFxcInl1aS1nZW40XFxcIiBncm91cGluZGV4PVxcXCIwXFxcIiBpbmRleD1cXFwiMFxcXCI+XFxuICA8YSBjbGFzcz1cXFwieXVpYW1wbWVudWl0ZW1sYWJlbCB5dWltZW51aXRlbWxhYmVsXFxcIiBocmVmPVxcXCIvc2VsZWN0VGVhbS5kbz9pZD02ODBcXFwiIG9uY2xpY2s9XFxcInJldHVybiBjYW5FeGl0KClcXFwiPlxcbiAgICBBY2FkZW15IG9mIFNjaWVuY2VzXFxuICA8L2E+XFxuPC9saT4tLSE+XFxuXCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gIHRhZ05hbWU6ICdsaScsXG4gIGNsYXNzTmFtZTogJ2Ryb3Bkb3duJyxcbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5sYW5ndWFnZSc6ICdzd2l0Y2hMYW5ndWFnZScsXG4gICAgJ2NsaWNrIC5wb3B1cCc6ICdvcGVuUG9wdXAnLFxuICAgICdjbGljayAuYWJvdXQtYW1wJzogJ2Fib3V0J1xuICB9LFxuXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKFRlbXBsYXRlKSxcblxuICBpbml0aWFsaXplOmZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBfLmJpbmRBbGwodGhpcywgJ3JlbmRlcicsJ3N3aXRjaExhbmd1YWdlJywnYWJvdXQnKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHNlbGYubW9kZWwuYXR0cmlidXRlcykpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgc3dpdGNoTGFuZ3VhZ2U6ZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgIHZhciBpbmRleCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuaHJlZi5sYXN0SW5kZXhPZiAoJy8nKTtcblx0ICAgdmFyIGxuZyA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuaHJlZi5zdWJzdHIgKGluZGV4ICsxKTtcblx0ICAgLy9pZiB0aGUgU3dpdGhMYW5ndWFnZU1lbnUgZXhpc3RzLCBsZXQgdGhlIGpzcCBoYW5kbGUgaG93IHRvIGNoYW5nZSBsYW5ndWFnZS5cblx0ICAgLy9UT0RPIHRyaWdnZXIgYW4gZXZlbnQgYW5kIGhhbmRsZSBvbiB0aGUganNwXG5cdCAgIGlmICh0eXBlb2YgU3dpdGNoTGFuZ3VhZ2VNZW51ICE9PSAndW5kZWZpbmVkJyAmJiAkLmlzRnVuY3Rpb24oU3dpdGNoTGFuZ3VhZ2VNZW51KSkge1xuXHRcdCAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ICAgdmFyIHVybCA9IFwiL3RyYW5zbGF0aW9uL3N3aXRjaExhbmd1YWdlLmRvP2NvZGU9XCIrbG5nK1wiJnJmcj1cIjtcblx0XHQgICBTd2l0Y2hMYW5ndWFnZU1lbnUgKHVybCk7XG5cdCAgIH1cblx0ICAgZWxzZSB7XG5cdFx0ICAgdGhpcy50cmlnZ2VyICgnc3dpdGNoTGFuZ3VhZ2UnLHtsYW5ndWFnZTpsbmd9KTtcblx0ICAgfVxuXHQgICAvKnZhciBzZWxmID0gdGhpcztcblx0ICAgdGhpcy5UcmFuc2xhdG9yLnNldExhbmd1YWdlKGxuZykudGhlbihmdW5jdGlvbigpIHtcblx0XHQgICBzZWxmLlRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKGRvY3VtZW50KTsgXG4gICAgICAgfSk7Ki9cblx0ICBcbiAgIH0sXG4gICBvcGVuUG9wdXA6ZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgIHdpbmRvdy5uYW1lID0gXCJvcGVuZXJcIiArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHQgICB2YXIgd25kV2lkdGggPSA3Njg7IFxuXHQgICB2YXIgd25kSGVpZ2h0ID0gMTAyNDtcblx0ICAgdmFyIHQgPSAoKHNjcmVlbi53aWR0aCktNzY4KS8yO1xuXHQgICB2YXIgbCA9ICgoc2NyZWVuLmhlaWdodCktMTAyNCkvMjtcblx0ICAgdmFyIHdwYXJhbXMgPSBcImhlaWdodD1cIiArIHduZEhlaWdodCArIFwiLHdpZHRoPVwiICsgd25kV2lkdGggKyBcIix0b3A9XCIgKyBsICsgXCIsbGVmdD1cIiArIHQgK1wiLG1lbnViYXI9bm8sc2Nyb2xsYmFycz15ZXNcIjtcblx0ICAgcG9wdXBQb2ludGVyID0gd2luZG93Lm9wZW4oZXZlbnQuY3VycmVudFRhcmdldC5ocmVmLCBcImZvcnVtUG9wdXBcIiwgd3BhcmFtcyk7XG5cdCAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdCAgIHJldHVybiBwb3B1cFBvaW50ZXI7XG4gICB9LFxuICAgYWJvdXQ6ZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgIHRoaXMudHJpZ2dlciAoJ3Nob3dBYm91dCcse30pO1xuXHQgICByZXR1cm4gZmFsc2U7XG4gICB9XG5cbn0pO1xuXG4iLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiQzpcXFxcR2l0XFxcXGFtcFxcXFxURU1QTEFURVxcXFxhbXBUZW1wbGF0ZVxcXFxub2RlX21vZHVsZXNcXFxcYW1wLWJvaWxlcnBsYXRlXFxcXG5vZGVfbW9kdWxlc1xcXFxib290c3RyYXBcXFxcZGlzdFxcXFxqc1xcXFxib290c3RyYXAuanNcIikiLCJ2YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8qIVxuICogalF1ZXJ5IFVJIENvcmUgMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2NhdGVnb3J5L3VpLWNvcmUvXG4gKi9cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdXVpZCA9IDAsXG5cdHJ1bmlxdWVJZCA9IC9edWktaWQtXFxkKyQvO1xuXG4vLyAkLnVpIG1pZ2h0IGV4aXN0IGZyb20gY29tcG9uZW50cyB3aXRoIG5vIGRlcGVuZGVuY2llcywgZS5nLiwgJC51aS5wb3NpdGlvblxuJC51aSA9ICQudWkgfHwge307XG5cbiQuZXh0ZW5kKCAkLnVpLCB7XG5cdHZlcnNpb246IFwiMS4xMC40XCIsXG5cblx0a2V5Q29kZToge1xuXHRcdEJBQ0tTUEFDRTogOCxcblx0XHRDT01NQTogMTg4LFxuXHRcdERFTEVURTogNDYsXG5cdFx0RE9XTjogNDAsXG5cdFx0RU5EOiAzNSxcblx0XHRFTlRFUjogMTMsXG5cdFx0RVNDQVBFOiAyNyxcblx0XHRIT01FOiAzNixcblx0XHRMRUZUOiAzNyxcblx0XHROVU1QQURfQUREOiAxMDcsXG5cdFx0TlVNUEFEX0RFQ0lNQUw6IDExMCxcblx0XHROVU1QQURfRElWSURFOiAxMTEsXG5cdFx0TlVNUEFEX0VOVEVSOiAxMDgsXG5cdFx0TlVNUEFEX01VTFRJUExZOiAxMDYsXG5cdFx0TlVNUEFEX1NVQlRSQUNUOiAxMDksXG5cdFx0UEFHRV9ET1dOOiAzNCxcblx0XHRQQUdFX1VQOiAzMyxcblx0XHRQRVJJT0Q6IDE5MCxcblx0XHRSSUdIVDogMzksXG5cdFx0U1BBQ0U6IDMyLFxuXHRcdFRBQjogOSxcblx0XHRVUDogMzhcblx0fVxufSk7XG5cbi8vIHBsdWdpbnNcbiQuZm4uZXh0ZW5kKHtcblx0Zm9jdXM6IChmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGRlbGF5LCBmbiApIHtcblx0XHRcdHJldHVybiB0eXBlb2YgZGVsYXkgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHQkKCBlbGVtICkuZm9jdXMoKTtcblx0XHRcdFx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdFx0XHRcdGZuLmNhbGwoIGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBkZWxheSApO1xuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cdH0pKCAkLmZuLmZvY3VzICksXG5cblx0c2Nyb2xsUGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50O1xuXHRcdGlmICgoJC51aS5pZSAmJiAoLyhzdGF0aWN8cmVsYXRpdmUpLykudGVzdCh0aGlzLmNzcyhcInBvc2l0aW9uXCIpKSkgfHwgKC9hYnNvbHV0ZS8pLnRlc3QodGhpcy5jc3MoXCJwb3NpdGlvblwiKSkpIHtcblx0XHRcdHNjcm9sbFBhcmVudCA9IHRoaXMucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICgvKHJlbGF0aXZlfGFic29sdXRlfGZpeGVkKS8pLnRlc3QoJC5jc3ModGhpcyxcInBvc2l0aW9uXCIpKSAmJiAoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KCQuY3NzKHRoaXMsXCJvdmVyZmxvd1wiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteVwiKSskLmNzcyh0aGlzLFwib3ZlcmZsb3cteFwiKSk7XG5cdFx0XHR9KS5lcSgwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gKC8oYXV0b3xzY3JvbGwpLykudGVzdCgkLmNzcyh0aGlzLFwib3ZlcmZsb3dcIikrJC5jc3ModGhpcyxcIm92ZXJmbG93LXlcIikrJC5jc3ModGhpcyxcIm92ZXJmbG93LXhcIikpO1xuXHRcdFx0fSkuZXEoMCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvZml4ZWQvKS50ZXN0KHRoaXMuY3NzKFwicG9zaXRpb25cIikpIHx8ICFzY3JvbGxQYXJlbnQubGVuZ3RoID8gJChkb2N1bWVudCkgOiBzY3JvbGxQYXJlbnQ7XG5cdH0sXG5cblx0ekluZGV4OiBmdW5jdGlvbiggekluZGV4ICkge1xuXHRcdGlmICggekluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jc3MoIFwiekluZGV4XCIsIHpJbmRleCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHR2YXIgZWxlbSA9ICQoIHRoaXNbIDAgXSApLCBwb3NpdGlvbiwgdmFsdWU7XG5cdFx0XHR3aGlsZSAoIGVsZW0ubGVuZ3RoICYmIGVsZW1bIDAgXSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdC8vIElnbm9yZSB6LWluZGV4IGlmIHBvc2l0aW9uIGlzIHNldCB0byBhIHZhbHVlIHdoZXJlIHotaW5kZXggaXMgaWdub3JlZCBieSB0aGUgYnJvd3NlclxuXHRcdFx0XHQvLyBUaGlzIG1ha2VzIGJlaGF2aW9yIG9mIHRoaXMgZnVuY3Rpb24gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnNcblx0XHRcdFx0Ly8gV2ViS2l0IGFsd2F5cyByZXR1cm5zIGF1dG8gaWYgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZFxuXHRcdFx0XHRwb3NpdGlvbiA9IGVsZW0uY3NzKCBcInBvc2l0aW9uXCIgKTtcblx0XHRcdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdFx0XHQvLyBJRSByZXR1cm5zIDAgd2hlbiB6SW5kZXggaXMgbm90IHNwZWNpZmllZFxuXHRcdFx0XHRcdC8vIG90aGVyIGJyb3dzZXJzIHJldHVybiBhIHN0cmluZ1xuXHRcdFx0XHRcdC8vIHdlIGlnbm9yZSB0aGUgY2FzZSBvZiBuZXN0ZWQgZWxlbWVudHMgd2l0aCBhbiBleHBsaWNpdCB2YWx1ZSBvZiAwXG5cdFx0XHRcdFx0Ly8gPGRpdiBzdHlsZT1cInotaW5kZXg6IC0xMDtcIj48ZGl2IHN0eWxlPVwiei1pbmRleDogMDtcIj48L2Rpdj48L2Rpdj5cblx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlSW50KCBlbGVtLmNzcyggXCJ6SW5kZXhcIiApLCAxMCApO1xuXHRcdFx0XHRcdGlmICggIWlzTmFOKCB2YWx1ZSApICYmIHZhbHVlICE9PSAwICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtID0gZWxlbS5wYXJlbnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHR1bmlxdWVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXRoaXMuaWQgKSB7XG5cdFx0XHRcdHRoaXMuaWQgPSBcInVpLWlkLVwiICsgKCsrdXVpZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cmVtb3ZlVW5pcXVlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHJ1bmlxdWVJZC50ZXN0KCB0aGlzLmlkICkgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVBdHRyKCBcImlkXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIHNlbGVjdG9yc1xuZnVuY3Rpb24gZm9jdXNhYmxlKCBlbGVtZW50LCBpc1RhYkluZGV4Tm90TmFOICkge1xuXHR2YXIgbWFwLCBtYXBOYW1lLCBpbWcsXG5cdFx0bm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdGlmICggXCJhcmVhXCIgPT09IG5vZGVOYW1lICkge1xuXHRcdG1hcCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRtYXBOYW1lID0gbWFwLm5hbWU7XG5cdFx0aWYgKCAhZWxlbWVudC5ocmVmIHx8ICFtYXBOYW1lIHx8IG1hcC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm1hcFwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpbWcgPSAkKCBcImltZ1t1c2VtYXA9I1wiICsgbWFwTmFtZSArIFwiXVwiIClbMF07XG5cdFx0cmV0dXJuICEhaW1nICYmIHZpc2libGUoIGltZyApO1xuXHR9XG5cdHJldHVybiAoIC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdC8udGVzdCggbm9kZU5hbWUgKSA/XG5cdFx0IWVsZW1lbnQuZGlzYWJsZWQgOlxuXHRcdFwiYVwiID09PSBub2RlTmFtZSA/XG5cdFx0XHRlbGVtZW50LmhyZWYgfHwgaXNUYWJJbmRleE5vdE5hTiA6XG5cdFx0XHRpc1RhYkluZGV4Tm90TmFOKSAmJlxuXHRcdC8vIHRoZSBlbGVtZW50IGFuZCBhbGwgb2YgaXRzIGFuY2VzdG9ycyBtdXN0IGJlIHZpc2libGVcblx0XHR2aXNpYmxlKCBlbGVtZW50ICk7XG59XG5cbmZ1bmN0aW9uIHZpc2libGUoIGVsZW1lbnQgKSB7XG5cdHJldHVybiAkLmV4cHIuZmlsdGVycy52aXNpYmxlKCBlbGVtZW50ICkgJiZcblx0XHQhJCggZWxlbWVudCApLnBhcmVudHMoKS5hZGRCYWNrKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQuY3NzKCB0aGlzLCBcInZpc2liaWxpdHlcIiApID09PSBcImhpZGRlblwiO1xuXHRcdH0pLmxlbmd0aDtcbn1cblxuJC5leHRlbmQoICQuZXhwclsgXCI6XCIgXSwge1xuXHRkYXRhOiAkLmV4cHIuY3JlYXRlUHNldWRvID9cblx0XHQkLmV4cHIuY3JlYXRlUHNldWRvKGZ1bmN0aW9uKCBkYXRhTmFtZSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBkYXRhTmFtZSApO1xuXHRcdFx0fTtcblx0XHR9KSA6XG5cdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHRmdW5jdGlvbiggZWxlbSwgaSwgbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIG1hdGNoWyAzIF0gKTtcblx0XHR9LFxuXG5cdGZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGZvY3VzYWJsZSggZWxlbWVudCwgIWlzTmFOKCAkLmF0dHIoIGVsZW1lbnQsIFwidGFiaW5kZXhcIiApICkgKTtcblx0fSxcblxuXHR0YWJiYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHRhYkluZGV4ID0gJC5hdHRyKCBlbGVtZW50LCBcInRhYmluZGV4XCIgKSxcblx0XHRcdGlzVGFiSW5kZXhOYU4gPSBpc05hTiggdGFiSW5kZXggKTtcblx0XHRyZXR1cm4gKCBpc1RhYkluZGV4TmFOIHx8IHRhYkluZGV4ID49IDAgKSAmJiBmb2N1c2FibGUoIGVsZW1lbnQsICFpc1RhYkluZGV4TmFOICk7XG5cdH1cbn0pO1xuXG4vLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuaWYgKCAhJCggXCI8YT5cIiApLm91dGVyV2lkdGgoIDEgKS5qcXVlcnkgKSB7XG5cdCQuZWFjaCggWyBcIldpZHRoXCIsIFwiSGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0dmFyIHNpZGUgPSBuYW1lID09PSBcIldpZHRoXCIgPyBbIFwiTGVmdFwiLCBcIlJpZ2h0XCIgXSA6IFsgXCJUb3BcIiwgXCJCb3R0b21cIiBdLFxuXHRcdFx0dHlwZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdG9yaWcgPSB7XG5cdFx0XHRcdGlubmVyV2lkdGg6ICQuZm4uaW5uZXJXaWR0aCxcblx0XHRcdFx0aW5uZXJIZWlnaHQ6ICQuZm4uaW5uZXJIZWlnaHQsXG5cdFx0XHRcdG91dGVyV2lkdGg6ICQuZm4ub3V0ZXJXaWR0aCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQ6ICQuZm4ub3V0ZXJIZWlnaHRcblx0XHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWR1Y2UoIGVsZW0sIHNpemUsIGJvcmRlciwgbWFyZ2luICkge1xuXHRcdFx0JC5lYWNoKCBzaWRlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyB0aGlzICkgKSB8fCAwO1xuXHRcdFx0XHRpZiAoIGJvcmRlciApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgdGhpcyArIFwiV2lkdGhcIiApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hcmdpbiApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcIm1hcmdpblwiICsgdGhpcyApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2l6ZTtcblx0XHR9XG5cblx0XHQkLmZuWyBcImlubmVyXCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggc2l6ZSApIHtcblx0XHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJpbm5lclwiICsgbmFtZSBdLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmNzcyggdHlwZSwgcmVkdWNlKCB0aGlzLCBzaXplICkgKyBcInB4XCIgKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQkLmZuWyBcIm91dGVyXCIgKyBuYW1lXSA9IGZ1bmN0aW9uKCBzaXplLCBtYXJnaW4gKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzaXplICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJvdXRlclwiICsgbmFtZSBdLmNhbGwoIHRoaXMsIHNpemUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcykuY3NzKCB0eXBlLCByZWR1Y2UoIHRoaXMsIHNpemUsIHRydWUsIG1hcmdpbiApICsgXCJweFwiICk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcbmlmICggISQuZm4uYWRkQmFjayApIHtcblx0JC5mbi5hZGRCYWNrID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDEuNi4xLCAxLjYuMiAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTQxMylcbmlmICggJCggXCI8YT5cIiApLmRhdGEoIFwiYS1iXCIsIFwiYVwiICkucmVtb3ZlRGF0YSggXCJhLWJcIiApLmRhdGEoIFwiYS1iXCIgKSApIHtcblx0JC5mbi5yZW1vdmVEYXRhID0gKGZ1bmN0aW9uKCByZW1vdmVEYXRhICkge1xuXHRcdHJldHVybiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlRGF0YS5jYWxsKCB0aGlzLCAkLmNhbWVsQ2FzZSgga2V5ICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVEYXRhLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSggJC5mbi5yZW1vdmVEYXRhICk7XG59XG5cblxuXG5cblxuLy8gZGVwcmVjYXRlZFxuJC51aS5pZSA9ICEhL21zaWUgW1xcdy5dKy8uZXhlYyggbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpICk7XG5cbiQuc3VwcG9ydC5zZWxlY3RzdGFydCA9IFwib25zZWxlY3RzdGFydFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcbiQuZm4uZXh0ZW5kKHtcblx0ZGlzYWJsZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmluZCggKCAkLnN1cHBvcnQuc2VsZWN0c3RhcnQgPyBcInNlbGVjdHN0YXJ0XCIgOiBcIm1vdXNlZG93blwiICkgK1xuXHRcdFx0XCIudWktZGlzYWJsZVNlbGVjdGlvblwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9KTtcblx0fSxcblxuXHRlbmFibGVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnVuYmluZCggXCIudWktZGlzYWJsZVNlbGVjdGlvblwiICk7XG5cdH1cbn0pO1xuXG4kLmV4dGVuZCggJC51aSwge1xuXHQvLyAkLnVpLnBsdWdpbiBpcyBkZXByZWNhdGVkLiBVc2UgJC53aWRnZXQoKSBleHRlbnNpb25zIGluc3RlYWQuXG5cdHBsdWdpbjoge1xuXHRcdGFkZDogZnVuY3Rpb24oIG1vZHVsZSwgb3B0aW9uLCBzZXQgKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0cHJvdG8gPSAkLnVpWyBtb2R1bGUgXS5wcm90b3R5cGU7XG5cdFx0XHRmb3IgKCBpIGluIHNldCApIHtcblx0XHRcdFx0cHJvdG8ucGx1Z2luc1sgaSBdID0gcHJvdG8ucGx1Z2luc1sgaSBdIHx8IFtdO1xuXHRcdFx0XHRwcm90by5wbHVnaW5zWyBpIF0ucHVzaCggWyBvcHRpb24sIHNldFsgaSBdIF0gKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNhbGw6IGZ1bmN0aW9uKCBpbnN0YW5jZSwgbmFtZSwgYXJncyApIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRzZXQgPSBpbnN0YW5jZS5wbHVnaW5zWyBuYW1lIF07XG5cdFx0XHRpZiAoICFzZXQgfHwgIWluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlIHx8IGluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZS5vcHRpb25zWyBzZXRbIGkgXVsgMCBdIF0gKSB7XG5cdFx0XHRcdFx0c2V0WyBpIF1bIDEgXS5hcHBseSggaW5zdGFuY2UuZWxlbWVudCwgYXJncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIG9ubHkgdXNlZCBieSByZXNpemFibGVcblx0aGFzU2Nyb2xsOiBmdW5jdGlvbiggZWwsIGEgKSB7XG5cblx0XHQvL0lmIG92ZXJmbG93IGlzIGhpZGRlbiwgdGhlIGVsZW1lbnQgbWlnaHQgaGF2ZSBleHRyYSBjb250ZW50LCBidXQgdGhlIHVzZXIgd2FudHMgdG8gaGlkZSBpdFxuXHRcdGlmICggJCggZWwgKS5jc3MoIFwib3ZlcmZsb3dcIiApID09PSBcImhpZGRlblwiKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHNjcm9sbCA9ICggYSAmJiBhID09PSBcImxlZnRcIiApID8gXCJzY3JvbGxMZWZ0XCIgOiBcInNjcm9sbFRvcFwiLFxuXHRcdFx0aGFzID0gZmFsc2U7XG5cblx0XHRpZiAoIGVsWyBzY3JvbGwgXSA+IDAgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBkZXRlcm1pbmUgd2hpY2ggY2FzZXMgYWN0dWFsbHkgY2F1c2UgdGhpcyB0byBoYXBwZW5cblx0XHQvLyBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgdGhlIHNjcm9sbCBzZXQsIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvXG5cdFx0Ly8gc2V0IHRoZSBzY3JvbGxcblx0XHRlbFsgc2Nyb2xsIF0gPSAxO1xuXHRcdGhhcyA9ICggZWxbIHNjcm9sbCBdID4gMCApO1xuXHRcdGVsWyBzY3JvbGwgXSA9IDA7XG5cdFx0cmV0dXJuIGhhcztcblx0fVxufSk7XG5cbn0pKCBqUXVlcnkgKTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnJlcXVpcmUoJy4vY29yZScpO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBEYXRlcGlja2VyIDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9kYXRlcGlja2VyL1xuICpcbiAqIERlcGVuZHM6XG4gKlx0anF1ZXJ5LnVpLmNvcmUuanNcbiAqL1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZXh0ZW5kKCQudWksIHsgZGF0ZXBpY2tlcjogeyB2ZXJzaW9uOiBcIjEuMTAuNFwiIH0gfSk7XG5cbnZhciBQUk9QX05BTUUgPSBcImRhdGVwaWNrZXJcIixcblx0aW5zdEFjdGl2ZTtcblxuLyogRGF0ZSBwaWNrZXIgbWFuYWdlci5cbiAgIFVzZSB0aGUgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MsICQuZGF0ZXBpY2tlciwgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgZGF0ZSBwaWNrZXIuXG4gICBTZXR0aW5ncyBmb3IgKGdyb3VwcyBvZikgZGF0ZSBwaWNrZXJzIGFyZSBtYWludGFpbmVkIGluIGFuIGluc3RhbmNlIG9iamVjdCxcbiAgIGFsbG93aW5nIG11bHRpcGxlIGRpZmZlcmVudCBzZXR0aW5ncyBvbiB0aGUgc2FtZSBwYWdlLiAqL1xuXG5mdW5jdGlvbiBEYXRlcGlja2VyKCkge1xuXHR0aGlzLl9jdXJJbnN0ID0gbnVsbDsgLy8gVGhlIGN1cnJlbnQgaW5zdGFuY2UgaW4gdXNlXG5cdHRoaXMuX2tleUV2ZW50ID0gZmFsc2U7IC8vIElmIHRoZSBsYXN0IGV2ZW50IHdhcyBhIGtleSBldmVudFxuXHR0aGlzLl9kaXNhYmxlZElucHV0cyA9IFtdOyAvLyBMaXN0IG9mIGRhdGUgcGlja2VyIGlucHV0cyB0aGF0IGhhdmUgYmVlbiBkaXNhYmxlZFxuXHR0aGlzLl9kYXRlcGlja2VyU2hvd2luZyA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBwb3B1cCBwaWNrZXIgaXMgc2hvd2luZyAsIGZhbHNlIGlmIG5vdFxuXHR0aGlzLl9pbkRpYWxvZyA9IGZhbHNlOyAvLyBUcnVlIGlmIHNob3dpbmcgd2l0aGluIGEgXCJkaWFsb2dcIiwgZmFsc2UgaWYgbm90XG5cdHRoaXMuX21haW5EaXZJZCA9IFwidWktZGF0ZXBpY2tlci1kaXZcIjsgLy8gVGhlIElEIG9mIHRoZSBtYWluIGRhdGVwaWNrZXIgZGl2aXNpb25cblx0dGhpcy5faW5saW5lQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItaW5saW5lXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBpbmxpbmUgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2FwcGVuZENsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWFwcGVuZFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgYXBwZW5kIG1hcmtlciBjbGFzc1xuXHR0aGlzLl90cmlnZ2VyQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItdHJpZ2dlclwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgdHJpZ2dlciBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGlhbG9nQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItZGlhbG9nXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkaWFsb2cgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2Rpc2FibGVDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1kaXNhYmxlZFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgZGlzYWJsZWQgY292ZXJpbmcgbWFya2VyIGNsYXNzXG5cdHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzID0gXCJ1aS1kYXRlcGlja2VyLXVuc2VsZWN0YWJsZVwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgdW5zZWxlY3RhYmxlIGNlbGwgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2N1cnJlbnRDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1jdXJyZW50LWRheVwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBkYXkgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2RheU92ZXJDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1kYXlzLWNlbGwtb3ZlclwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgZGF5IGhvdmVyIG1hcmtlciBjbGFzc1xuXHR0aGlzLnJlZ2lvbmFsID0gW107IC8vIEF2YWlsYWJsZSByZWdpb25hbCBzZXR0aW5ncywgaW5kZXhlZCBieSBsYW5ndWFnZSBjb2RlXG5cdHRoaXMucmVnaW9uYWxbXCJcIl0gPSB7IC8vIERlZmF1bHQgcmVnaW9uYWwgc2V0dGluZ3Ncblx0XHRjbG9zZVRleHQ6IFwiRG9uZVwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIGNsb3NlIGxpbmtcblx0XHRwcmV2VGV4dDogXCJQcmV2XCIsIC8vIERpc3BsYXkgdGV4dCBmb3IgcHJldmlvdXMgbW9udGggbGlua1xuXHRcdG5leHRUZXh0OiBcIk5leHRcIiwgLy8gRGlzcGxheSB0ZXh0IGZvciBuZXh0IG1vbnRoIGxpbmtcblx0XHRjdXJyZW50VGV4dDogXCJUb2RheVwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIGN1cnJlbnQgbW9udGggbGlua1xuXHRcdG1vbnRoTmFtZXM6IFtcIkphbnVhcnlcIixcIkZlYnJ1YXJ5XCIsXCJNYXJjaFwiLFwiQXByaWxcIixcIk1heVwiLFwiSnVuZVwiLFxuXHRcdFx0XCJKdWx5XCIsXCJBdWd1c3RcIixcIlNlcHRlbWJlclwiLFwiT2N0b2JlclwiLFwiTm92ZW1iZXJcIixcIkRlY2VtYmVyXCJdLCAvLyBOYW1lcyBvZiBtb250aHMgZm9yIGRyb3AtZG93biBhbmQgZm9ybWF0dGluZ1xuXHRcdG1vbnRoTmFtZXNTaG9ydDogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdLCAvLyBGb3IgZm9ybWF0dGluZ1xuXHRcdGRheU5hbWVzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSwgLy8gRm9yIGZvcm1hdHRpbmdcblx0XHRkYXlOYW1lc1Nob3J0OiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXNNaW46IFtcIlN1XCIsXCJNb1wiLFwiVHVcIixcIldlXCIsXCJUaFwiLFwiRnJcIixcIlNhXCJdLCAvLyBDb2x1bW4gaGVhZGluZ3MgZm9yIGRheXMgc3RhcnRpbmcgYXQgU3VuZGF5XG5cdFx0d2Vla0hlYWRlcjogXCJXa1wiLCAvLyBDb2x1bW4gaGVhZGVyIGZvciB3ZWVrIG9mIHRoZSB5ZWFyXG5cdFx0ZGF0ZUZvcm1hdDogXCJtbS9kZC95eVwiLCAvLyBTZWUgZm9ybWF0IG9wdGlvbnMgb24gcGFyc2VEYXRlXG5cdFx0Zmlyc3REYXk6IDAsIC8vIFRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWssIFN1biA9IDAsIE1vbiA9IDEsIC4uLlxuXHRcdGlzUlRMOiBmYWxzZSwgLy8gVHJ1ZSBpZiByaWdodC10by1sZWZ0IGxhbmd1YWdlLCBmYWxzZSBpZiBsZWZ0LXRvLXJpZ2h0XG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSwgLy8gVHJ1ZSBpZiB0aGUgeWVhciBzZWxlY3QgcHJlY2VkZXMgbW9udGgsIGZhbHNlIGZvciBtb250aCB0aGVuIHllYXJcblx0XHR5ZWFyU3VmZml4OiBcIlwiIC8vIEFkZGl0aW9uYWwgdGV4dCB0byBhcHBlbmQgdG8gdGhlIHllYXIgaW4gdGhlIG1vbnRoIGhlYWRlcnNcblx0fTtcblx0dGhpcy5fZGVmYXVsdHMgPSB7IC8vIEdsb2JhbCBkZWZhdWx0cyBmb3IgYWxsIHRoZSBkYXRlIHBpY2tlciBpbnN0YW5jZXNcblx0XHRzaG93T246IFwiZm9jdXNcIiwgLy8gXCJmb2N1c1wiIGZvciBwb3B1cCBvbiBmb2N1cyxcblx0XHRcdC8vIFwiYnV0dG9uXCIgZm9yIHRyaWdnZXIgYnV0dG9uLCBvciBcImJvdGhcIiBmb3IgZWl0aGVyXG5cdFx0c2hvd0FuaW06IFwiZmFkZUluXCIsIC8vIE5hbWUgb2YgalF1ZXJ5IGFuaW1hdGlvbiBmb3IgcG9wdXBcblx0XHRzaG93T3B0aW9uczoge30sIC8vIE9wdGlvbnMgZm9yIGVuaGFuY2VkIGFuaW1hdGlvbnNcblx0XHRkZWZhdWx0RGF0ZTogbnVsbCwgLy8gVXNlZCB3aGVuIGZpZWxkIGlzIGJsYW5rOiBhY3R1YWwgZGF0ZSxcblx0XHRcdC8vICsvLW51bWJlciBmb3Igb2Zmc2V0IGZyb20gdG9kYXksIG51bGwgZm9yIHRvZGF5XG5cdFx0YXBwZW5kVGV4dDogXCJcIiwgLy8gRGlzcGxheSB0ZXh0IGZvbGxvd2luZyB0aGUgaW5wdXQgYm94LCBlLmcuIHNob3dpbmcgdGhlIGZvcm1hdFxuXHRcdGJ1dHRvblRleHQ6IFwiLi4uXCIsIC8vIFRleHQgZm9yIHRyaWdnZXIgYnV0dG9uXG5cdFx0YnV0dG9uSW1hZ2U6IFwiXCIsIC8vIFVSTCBmb3IgdHJpZ2dlciBidXR0b24gaW1hZ2Vcblx0XHRidXR0b25JbWFnZU9ubHk6IGZhbHNlLCAvLyBUcnVlIGlmIHRoZSBpbWFnZSBhcHBlYXJzIGFsb25lLCBmYWxzZSBpZiBpdCBhcHBlYXJzIG9uIGEgYnV0dG9uXG5cdFx0aGlkZUlmTm9QcmV2TmV4dDogZmFsc2UsIC8vIFRydWUgdG8gaGlkZSBuZXh0L3ByZXZpb3VzIG1vbnRoIGxpbmtzXG5cdFx0XHQvLyBpZiBub3QgYXBwbGljYWJsZSwgZmFsc2UgdG8ganVzdCBkaXNhYmxlIHRoZW1cblx0XHRuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0OiBmYWxzZSwgLy8gVHJ1ZSBpZiBkYXRlIGZvcm1hdHRpbmcgYXBwbGllZCB0byBwcmV2L3RvZGF5L25leHQgbGlua3Ncblx0XHRnb3RvQ3VycmVudDogZmFsc2UsIC8vIFRydWUgaWYgdG9kYXkgbGluayBnb2VzIGJhY2sgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5zdGVhZFxuXHRcdGNoYW5nZU1vbnRoOiBmYWxzZSwgLy8gVHJ1ZSBpZiBtb250aCBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XG5cdFx0Y2hhbmdlWWVhcjogZmFsc2UsIC8vIFRydWUgaWYgeWVhciBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XG5cdFx0eWVhclJhbmdlOiBcImMtMTA6YysxMFwiLCAvLyBSYW5nZSBvZiB5ZWFycyB0byBkaXNwbGF5IGluIGRyb3AtZG93bixcblx0XHRcdC8vIGVpdGhlciByZWxhdGl2ZSB0byB0b2RheSdzIHllYXIgKC1ubjorbm4pLCByZWxhdGl2ZSB0byBjdXJyZW50bHkgZGlzcGxheWVkIHllYXJcblx0XHRcdC8vIChjLW5uOmMrbm4pLCBhYnNvbHV0ZSAobm5ubjpubm5uKSwgb3IgYSBjb21iaW5hdGlvbiBvZiB0aGUgYWJvdmUgKG5ubm46LW4pXG5cdFx0c2hvd090aGVyTW9udGhzOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgdG8gbGVhdmUgYmxhbmtcblx0XHRzZWxlY3RPdGhlck1vbnRoczogZmFsc2UsIC8vIFRydWUgdG8gYWxsb3cgc2VsZWN0aW9uIG9mIGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgZm9yIHVuc2VsZWN0YWJsZVxuXHRcdHNob3dXZWVrOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IHdlZWsgb2YgdGhlIHllYXIsIGZhbHNlIHRvIG5vdCBzaG93IGl0XG5cdFx0Y2FsY3VsYXRlV2VlazogdGhpcy5pc284NjAxV2VlaywgLy8gSG93IHRvIGNhbGN1bGF0ZSB0aGUgd2VlayBvZiB0aGUgeWVhcixcblx0XHRcdC8vIHRha2VzIGEgRGF0ZSBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRoZSB3ZWVrIGZvciBpdFxuXHRcdHNob3J0WWVhckN1dG9mZjogXCIrMTBcIiwgLy8gU2hvcnQgeWVhciB2YWx1ZXMgPCB0aGlzIGFyZSBpbiB0aGUgY3VycmVudCBjZW50dXJ5LFxuXHRcdFx0Ly8gPiB0aGlzIGFyZSBpbiB0aGUgcHJldmlvdXMgY2VudHVyeSxcblx0XHRcdC8vIHN0cmluZyB2YWx1ZSBzdGFydGluZyB3aXRoIFwiK1wiIGZvciBjdXJyZW50IHllYXIgKyB2YWx1ZVxuXHRcdG1pbkRhdGU6IG51bGwsIC8vIFRoZSBlYXJsaWVzdCBzZWxlY3RhYmxlIGRhdGUsIG9yIG51bGwgZm9yIG5vIGxpbWl0XG5cdFx0bWF4RGF0ZTogbnVsbCwgLy8gVGhlIGxhdGVzdCBzZWxlY3RhYmxlIGRhdGUsIG9yIG51bGwgZm9yIG5vIGxpbWl0XG5cdFx0ZHVyYXRpb246IFwiZmFzdFwiLCAvLyBEdXJhdGlvbiBvZiBkaXNwbGF5L2Nsb3N1cmVcblx0XHRiZWZvcmVTaG93RGF5OiBudWxsLCAvLyBGdW5jdGlvbiB0aGF0IHRha2VzIGEgZGF0ZSBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoXG5cdFx0XHQvLyBbMF0gPSB0cnVlIGlmIHNlbGVjdGFibGUsIGZhbHNlIGlmIG5vdCwgWzFdID0gY3VzdG9tIENTUyBjbGFzcyBuYW1lKHMpIG9yIFwiXCIsXG5cdFx0XHQvLyBbMl0gPSBjZWxsIHRpdGxlIChvcHRpb25hbCksIGUuZy4gJC5kYXRlcGlja2VyLm5vV2Vla2VuZHNcblx0XHRiZWZvcmVTaG93OiBudWxsLCAvLyBGdW5jdGlvbiB0aGF0IHRha2VzIGFuIGlucHV0IGZpZWxkIGFuZFxuXHRcdFx0Ly8gcmV0dXJucyBhIHNldCBvZiBjdXN0b20gc2V0dGluZ3MgZm9yIHRoZSBkYXRlIHBpY2tlclxuXHRcdG9uU2VsZWN0OiBudWxsLCAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGEgZGF0ZSBpcyBzZWxlY3RlZFxuXHRcdG9uQ2hhbmdlTW9udGhZZWFyOiBudWxsLCAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBtb250aCBvciB5ZWFyIGlzIGNoYW5nZWRcblx0XHRvbkNsb3NlOiBudWxsLCAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBkYXRlcGlja2VyIGlzIGNsb3NlZFxuXHRcdG51bWJlck9mTW9udGhzOiAxLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHNob3cgYXQgYSB0aW1lXG5cdFx0c2hvd0N1cnJlbnRBdFBvczogMCwgLy8gVGhlIHBvc2l0aW9uIGluIG11bHRpcGUgbW9udGhzIGF0IHdoaWNoIHRvIHNob3cgdGhlIGN1cnJlbnQgbW9udGggKHN0YXJ0aW5nIGF0IDApXG5cdFx0c3RlcE1vbnRoczogMSwgLy8gTnVtYmVyIG9mIG1vbnRocyB0byBzdGVwIGJhY2svZm9yd2FyZFxuXHRcdHN0ZXBCaWdNb250aHM6IDEyLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHN0ZXAgYmFjay9mb3J3YXJkIGZvciB0aGUgYmlnIGxpbmtzXG5cdFx0YWx0RmllbGQ6IFwiXCIsIC8vIFNlbGVjdG9yIGZvciBhbiBhbHRlcm5hdGUgZmllbGQgdG8gc3RvcmUgc2VsZWN0ZWQgZGF0ZXMgaW50b1xuXHRcdGFsdEZvcm1hdDogXCJcIiwgLy8gVGhlIGRhdGUgZm9ybWF0IHRvIHVzZSBmb3IgdGhlIGFsdGVybmF0ZSBmaWVsZFxuXHRcdGNvbnN0cmFpbklucHV0OiB0cnVlLCAvLyBUaGUgaW5wdXQgaXMgY29uc3RyYWluZWQgYnkgdGhlIGN1cnJlbnQgZGF0ZSBmb3JtYXRcblx0XHRzaG93QnV0dG9uUGFuZWw6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgYnV0dG9uIHBhbmVsLCBmYWxzZSB0byBub3Qgc2hvdyBpdFxuXHRcdGF1dG9TaXplOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaXplIHRoZSBpbnB1dCBmb3IgdGhlIGRhdGUgZm9ybWF0LCBmYWxzZSB0byBsZWF2ZSBhcyBpc1xuXHRcdGRpc2FibGVkOiBmYWxzZSAvLyBUaGUgaW5pdGlhbCBkaXNhYmxlZCBzdGF0ZVxuXHR9O1xuXHQkLmV4dGVuZCh0aGlzLl9kZWZhdWx0cywgdGhpcy5yZWdpb25hbFtcIlwiXSk7XG5cdHRoaXMuZHBEaXYgPSBiaW5kSG92ZXIoJChcIjxkaXYgaWQ9J1wiICsgdGhpcy5fbWFpbkRpdklkICsgXCInIGNsYXNzPSd1aS1kYXRlcGlja2VyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLWFsbCc+PC9kaXY+XCIpKTtcbn1cblxuJC5leHRlbmQoRGF0ZXBpY2tlci5wcm90b3R5cGUsIHtcblx0LyogQ2xhc3MgbmFtZSBhZGRlZCB0byBlbGVtZW50cyB0byBpbmRpY2F0ZSBhbHJlYWR5IGNvbmZpZ3VyZWQgd2l0aCBhIGRhdGUgcGlja2VyLiAqL1xuXHRtYXJrZXJDbGFzc05hbWU6IFwiaGFzRGF0ZXBpY2tlclwiLFxuXG5cdC8vS2VlcCB0cmFjayBvZiB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyBkaXNwbGF5ZWQgKHNlZSAjNzA0Mylcblx0bWF4Um93czogNCxcblxuXHQvLyBUT0RPIHJlbmFtZSB0byBcIndpZGdldFwiIHdoZW4gc3dpdGNoaW5nIHRvIHdpZGdldCBmYWN0b3J5XG5cdF93aWRnZXREYXRlcGlja2VyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kcERpdjtcblx0fSxcblxuXHQvKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBzZXR0aW5ncyBmb3IgYWxsIGluc3RhbmNlcyBvZiB0aGUgZGF0ZSBwaWNrZXIuXG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXNlIGFzIGRlZmF1bHRzIChhbm9ueW1vdXMgb2JqZWN0KVxuXHQgKiBAcmV0dXJuIHRoZSBtYW5hZ2VyIG9iamVjdFxuXHQgKi9cblx0c2V0RGVmYXVsdHM6IGZ1bmN0aW9uKHNldHRpbmdzKSB7XG5cdFx0ZXh0ZW5kUmVtb3ZlKHRoaXMuX2RlZmF1bHRzLCBzZXR0aW5ncyB8fCB7fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyogQXR0YWNoIHRoZSBkYXRlIHBpY2tlciB0byBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXNlIGZvciB0aGlzIGRhdGUgcGlja2VyIGluc3RhbmNlIChhbm9ueW1vdXMpXG5cdCAqL1xuXHRfYXR0YWNoRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBzZXR0aW5ncykge1xuXHRcdHZhciBub2RlTmFtZSwgaW5saW5lLCBpbnN0O1xuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aW5saW5lID0gKG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIik7XG5cdFx0aWYgKCF0YXJnZXQuaWQpIHtcblx0XHRcdHRoaXMudXVpZCArPSAxO1xuXHRcdFx0dGFyZ2V0LmlkID0gXCJkcFwiICsgdGhpcy51dWlkO1xuXHRcdH1cblx0XHRpbnN0ID0gdGhpcy5fbmV3SW5zdCgkKHRhcmdldCksIGlubGluZSk7XG5cdFx0aW5zdC5zZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBzZXR0aW5ncyB8fCB7fSk7XG5cdFx0aWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIpIHtcblx0XHRcdHRoaXMuX2Nvbm5lY3REYXRlcGlja2VyKHRhcmdldCwgaW5zdCk7XG5cdFx0fSBlbHNlIGlmIChpbmxpbmUpIHtcblx0XHRcdHRoaXMuX2lubGluZURhdGVwaWNrZXIodGFyZ2V0LCBpbnN0KTtcblx0XHR9XG5cdH0sXG5cblx0LyogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9iamVjdC4gKi9cblx0X25ld0luc3Q6IGZ1bmN0aW9uKHRhcmdldCwgaW5saW5lKSB7XG5cdFx0dmFyIGlkID0gdGFyZ2V0WzBdLmlkLnJlcGxhY2UoLyhbXkEtWmEtejAtOV9cXC1dKS9nLCBcIlxcXFxcXFxcJDFcIik7IC8vIGVzY2FwZSBqUXVlcnkgbWV0YSBjaGFyc1xuXHRcdHJldHVybiB7aWQ6IGlkLCBpbnB1dDogdGFyZ2V0LCAvLyBhc3NvY2lhdGVkIHRhcmdldFxuXHRcdFx0c2VsZWN0ZWREYXk6IDAsIHNlbGVjdGVkTW9udGg6IDAsIHNlbGVjdGVkWWVhcjogMCwgLy8gY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdGRyYXdNb250aDogMCwgZHJhd1llYXI6IDAsIC8vIG1vbnRoIGJlaW5nIGRyYXduXG5cdFx0XHRpbmxpbmU6IGlubGluZSwgLy8gaXMgZGF0ZXBpY2tlciBpbmxpbmUgb3Igbm90XG5cdFx0XHRkcERpdjogKCFpbmxpbmUgPyB0aGlzLmRwRGl2IDogLy8gcHJlc2VudGF0aW9uIGRpdlxuXHRcdFx0YmluZEhvdmVyKCQoXCI8ZGl2IGNsYXNzPSdcIiArIHRoaXMuX2lubGluZUNsYXNzICsgXCIgdWktZGF0ZXBpY2tlciB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktaGVscGVyLWNsZWFyZml4IHVpLWNvcm5lci1hbGwnPjwvZGl2PlwiKSkpfTtcblx0fSxcblxuXHQvKiBBdHRhY2ggdGhlIGRhdGUgcGlja2VyIHRvIGFuIGlucHV0IGZpZWxkLiAqL1xuXHRfY29ubmVjdERhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCwgaW5zdCkge1xuXHRcdHZhciBpbnB1dCA9ICQodGFyZ2V0KTtcblx0XHRpbnN0LmFwcGVuZCA9ICQoW10pO1xuXHRcdGluc3QudHJpZ2dlciA9ICQoW10pO1xuXHRcdGlmIChpbnB1dC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fYXR0YWNobWVudHMoaW5wdXQsIGluc3QpO1xuXHRcdGlucHV0LmFkZENsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKS5rZXlkb3duKHRoaXMuX2RvS2V5RG93bikuXG5cdFx0XHRrZXlwcmVzcyh0aGlzLl9kb0tleVByZXNzKS5rZXl1cCh0aGlzLl9kb0tleVVwKTtcblx0XHR0aGlzLl9hdXRvU2l6ZShpbnN0KTtcblx0XHQkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUsIGluc3QpO1xuXHRcdC8vSWYgZGlzYWJsZWQgb3B0aW9uIGlzIHRydWUsIGRpc2FibGUgdGhlIGRhdGVwaWNrZXIgb25jZSBpdCBoYXMgYmVlbiBhdHRhY2hlZCB0byB0aGUgaW5wdXQgKHNlZSB0aWNrZXQgIzU2NjUpXG5cdFx0aWYoIGluc3Quc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlciggdGFyZ2V0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIE1ha2UgYXR0YWNobWVudHMgYmFzZWQgb24gc2V0dGluZ3MuICovXG5cdF9hdHRhY2htZW50czogZnVuY3Rpb24oaW5wdXQsIGluc3QpIHtcblx0XHR2YXIgc2hvd09uLCBidXR0b25UZXh0LCBidXR0b25JbWFnZSxcblx0XHRcdGFwcGVuZFRleHQgPSB0aGlzLl9nZXQoaW5zdCwgXCJhcHBlbmRUZXh0XCIpLFxuXHRcdFx0aXNSVEwgPSB0aGlzLl9nZXQoaW5zdCwgXCJpc1JUTFwiKTtcblxuXHRcdGlmIChpbnN0LmFwcGVuZCkge1xuXHRcdFx0aW5zdC5hcHBlbmQucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdGlmIChhcHBlbmRUZXh0KSB7XG5cdFx0XHRpbnN0LmFwcGVuZCA9ICQoXCI8c3BhbiBjbGFzcz0nXCIgKyB0aGlzLl9hcHBlbmRDbGFzcyArIFwiJz5cIiArIGFwcGVuZFRleHQgKyBcIjwvc3Bhbj5cIik7XG5cdFx0XHRpbnB1dFtpc1JUTCA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCJdKGluc3QuYXBwZW5kKTtcblx0XHR9XG5cblx0XHRpbnB1dC51bmJpbmQoXCJmb2N1c1wiLCB0aGlzLl9zaG93RGF0ZXBpY2tlcik7XG5cblx0XHRpZiAoaW5zdC50cmlnZ2VyKSB7XG5cdFx0XHRpbnN0LnRyaWdnZXIucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0c2hvd09uID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd09uXCIpO1xuXHRcdGlmIChzaG93T24gPT09IFwiZm9jdXNcIiB8fCBzaG93T24gPT09IFwiYm90aFwiKSB7IC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGluIHRoZSBtYXJrZWQgZmllbGRcblx0XHRcdGlucHV0LmZvY3VzKHRoaXMuX3Nob3dEYXRlcGlja2VyKTtcblx0XHR9XG5cdFx0aWYgKHNob3dPbiA9PT0gXCJidXR0b25cIiB8fCBzaG93T24gPT09IFwiYm90aFwiKSB7IC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGJ1dHRvbiBjbGlja2VkXG5cdFx0XHRidXR0b25UZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwiYnV0dG9uVGV4dFwiKTtcblx0XHRcdGJ1dHRvbkltYWdlID0gdGhpcy5fZ2V0KGluc3QsIFwiYnV0dG9uSW1hZ2VcIik7XG5cdFx0XHRpbnN0LnRyaWdnZXIgPSAkKHRoaXMuX2dldChpbnN0LCBcImJ1dHRvbkltYWdlT25seVwiKSA/XG5cdFx0XHRcdCQoXCI8aW1nLz5cIikuYWRkQ2xhc3ModGhpcy5fdHJpZ2dlckNsYXNzKS5cblx0XHRcdFx0XHRhdHRyKHsgc3JjOiBidXR0b25JbWFnZSwgYWx0OiBidXR0b25UZXh0LCB0aXRsZTogYnV0dG9uVGV4dCB9KSA6XG5cdFx0XHRcdCQoXCI8YnV0dG9uIHR5cGU9J2J1dHRvbic+PC9idXR0b24+XCIpLmFkZENsYXNzKHRoaXMuX3RyaWdnZXJDbGFzcykuXG5cdFx0XHRcdFx0aHRtbCghYnV0dG9uSW1hZ2UgPyBidXR0b25UZXh0IDogJChcIjxpbWcvPlwiKS5hdHRyKFxuXHRcdFx0XHRcdHsgc3JjOmJ1dHRvbkltYWdlLCBhbHQ6YnV0dG9uVGV4dCwgdGl0bGU6YnV0dG9uVGV4dCB9KSkpO1xuXHRcdFx0aW5wdXRbaXNSVEwgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiXShpbnN0LnRyaWdnZXIpO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmNsaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9PT0gaW5wdXRbMF0pIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCAhPT0gaW5wdXRbMF0pIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlcihpbnB1dFswXSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlcihpbnB1dFswXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEFwcGx5IHRoZSBtYXhpbXVtIGxlbmd0aCBmb3IgdGhlIGRhdGUgZm9ybWF0LiAqL1xuXHRfYXV0b1NpemU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHRpZiAodGhpcy5fZ2V0KGluc3QsIFwiYXV0b1NpemVcIikgJiYgIWluc3QuaW5saW5lKSB7XG5cdFx0XHR2YXIgZmluZE1heCwgbWF4LCBtYXhJLCBpLFxuXHRcdFx0XHRkYXRlID0gbmV3IERhdGUoMjAwOSwgMTIgLSAxLCAyMCksIC8vIEVuc3VyZSBkb3VibGUgZGlnaXRzXG5cdFx0XHRcdGRhdGVGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgXCJkYXRlRm9ybWF0XCIpO1xuXG5cdFx0XHRpZiAoZGF0ZUZvcm1hdC5tYXRjaCgvW0RNXS8pKSB7XG5cdFx0XHRcdGZpbmRNYXggPSBmdW5jdGlvbihuYW1lcykge1xuXHRcdFx0XHRcdG1heCA9IDA7XG5cdFx0XHRcdFx0bWF4SSA9IDA7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAobmFtZXNbaV0ubGVuZ3RoID4gbWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1heCA9IG5hbWVzW2ldLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0bWF4SSA9IGk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXhJO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRkYXRlLnNldE1vbnRoKGZpbmRNYXgodGhpcy5fZ2V0KGluc3QsIChkYXRlRm9ybWF0Lm1hdGNoKC9NTS8pID9cblx0XHRcdFx0XHRcIm1vbnRoTmFtZXNcIiA6IFwibW9udGhOYW1lc1Nob3J0XCIpKSkpO1xuXHRcdFx0XHRkYXRlLnNldERhdGUoZmluZE1heCh0aGlzLl9nZXQoaW5zdCwgKGRhdGVGb3JtYXQubWF0Y2goL0RELykgP1xuXHRcdFx0XHRcdFwiZGF5TmFtZXNcIiA6IFwiZGF5TmFtZXNTaG9ydFwiKSkpICsgMjAgLSBkYXRlLmdldERheSgpKTtcblx0XHRcdH1cblx0XHRcdGluc3QuaW5wdXQuYXR0cihcInNpemVcIiwgdGhpcy5fZm9ybWF0RGF0ZShpbnN0LCBkYXRlKS5sZW5ndGgpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBBdHRhY2ggYW4gaW5saW5lIGRhdGUgcGlja2VyIHRvIGEgZGl2LiAqL1xuXHRfaW5saW5lRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBpbnN0KSB7XG5cdFx0dmFyIGRpdlNwYW4gPSAkKHRhcmdldCk7XG5cdFx0aWYgKGRpdlNwYW4uaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGRpdlNwYW4uYWRkQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpLmFwcGVuZChpbnN0LmRwRGl2KTtcblx0XHQkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUsIGluc3QpO1xuXHRcdHRoaXMuX3NldERhdGUoaW5zdCwgdGhpcy5fZ2V0RGVmYXVsdERhdGUoaW5zdCksIHRydWUpO1xuXHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdC8vSWYgZGlzYWJsZWQgb3B0aW9uIGlzIHRydWUsIGRpc2FibGUgdGhlIGRhdGVwaWNrZXIgYmVmb3JlIHNob3dpbmcgaXQgKHNlZSB0aWNrZXQgIzU2NjUpXG5cdFx0aWYoIGluc3Quc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlciggdGFyZ2V0ICk7XG5cdFx0fVxuXHRcdC8vIFNldCBkaXNwbGF5OmJsb2NrIGluIHBsYWNlIG9mIGluc3QuZHBEaXYuc2hvdygpIHdoaWNoIHdvbid0IHdvcmsgb24gZGlzY29ubmVjdGVkIGVsZW1lbnRzXG5cdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5dWkuY29tL3RpY2tldC83NTUyIC0gQSBEYXRlcGlja2VyIGNyZWF0ZWQgb24gYSBkZXRhY2hlZCBkaXYgaGFzIHplcm8gaGVpZ2h0XG5cdFx0aW5zdC5kcERpdi5jc3MoIFwiZGlzcGxheVwiLCBcImJsb2NrXCIgKTtcblx0fSxcblxuXHQvKiBQb3AtdXAgdGhlIGRhdGUgcGlja2VyIGluIGEgXCJkaWFsb2dcIiBib3guXG5cdCAqIEBwYXJhbSAgaW5wdXQgZWxlbWVudCAtIGlnbm9yZWRcblx0ICogQHBhcmFtICBkYXRlXHRzdHJpbmcgb3IgRGF0ZSAtIHRoZSBpbml0aWFsIGRhdGUgdG8gZGlzcGxheVxuXHQgKiBAcGFyYW0gIG9uU2VsZWN0ICBmdW5jdGlvbiAtIHRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkXG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHVwZGF0ZSB0aGUgZGlhbG9nIGRhdGUgcGlja2VyIGluc3RhbmNlJ3Mgc2V0dGluZ3MgKGFub255bW91cyBvYmplY3QpXG5cdCAqIEBwYXJhbSAgcG9zIGludFsyXSAtIGNvb3JkaW5hdGVzIGZvciB0aGUgZGlhbG9nJ3MgcG9zaXRpb24gd2l0aGluIHRoZSBzY3JlZW4gb3Jcblx0ICpcdFx0XHRcdFx0ZXZlbnQgLSB3aXRoIHgveSBjb29yZGluYXRlcyBvclxuXHQgKlx0XHRcdFx0XHRsZWF2ZSBlbXB0eSBmb3IgZGVmYXVsdCAoc2NyZWVuIGNlbnRyZSlcblx0ICogQHJldHVybiB0aGUgbWFuYWdlciBvYmplY3Rcblx0ICovXG5cdF9kaWFsb2dEYXRlcGlja2VyOiBmdW5jdGlvbihpbnB1dCwgZGF0ZSwgb25TZWxlY3QsIHNldHRpbmdzLCBwb3MpIHtcblx0XHR2YXIgaWQsIGJyb3dzZXJXaWR0aCwgYnJvd3NlckhlaWdodCwgc2Nyb2xsWCwgc2Nyb2xsWSxcblx0XHRcdGluc3QgPSB0aGlzLl9kaWFsb2dJbnN0OyAvLyBpbnRlcm5hbCBpbnN0YW5jZVxuXG5cdFx0aWYgKCFpbnN0KSB7XG5cdFx0XHR0aGlzLnV1aWQgKz0gMTtcblx0XHRcdGlkID0gXCJkcFwiICsgdGhpcy51dWlkO1xuXHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQgPSAkKFwiPGlucHV0IHR5cGU9J3RleHQnIGlkPSdcIiArIGlkICtcblx0XHRcdFx0XCInIHN0eWxlPSdwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMHB4OyB3aWR0aDogMHB4OycvPlwiKTtcblx0XHRcdHRoaXMuX2RpYWxvZ0lucHV0LmtleWRvd24odGhpcy5fZG9LZXlEb3duKTtcblx0XHRcdCQoXCJib2R5XCIpLmFwcGVuZCh0aGlzLl9kaWFsb2dJbnB1dCk7XG5cdFx0XHRpbnN0ID0gdGhpcy5fZGlhbG9nSW5zdCA9IHRoaXMuX25ld0luc3QodGhpcy5fZGlhbG9nSW5wdXQsIGZhbHNlKTtcblx0XHRcdGluc3Quc2V0dGluZ3MgPSB7fTtcblx0XHRcdCQuZGF0YSh0aGlzLl9kaWFsb2dJbnB1dFswXSwgUFJPUF9OQU1FLCBpbnN0KTtcblx0XHR9XG5cdFx0ZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIHNldHRpbmdzIHx8IHt9KTtcblx0XHRkYXRlID0gKGRhdGUgJiYgZGF0ZS5jb25zdHJ1Y3RvciA9PT0gRGF0ZSA/IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgZGF0ZSkgOiBkYXRlKTtcblx0XHR0aGlzLl9kaWFsb2dJbnB1dC52YWwoZGF0ZSk7XG5cblx0XHR0aGlzLl9wb3MgPSAocG9zID8gKHBvcy5sZW5ndGggPyBwb3MgOiBbcG9zLnBhZ2VYLCBwb3MucGFnZVldKSA6IG51bGwpO1xuXHRcdGlmICghdGhpcy5fcG9zKSB7XG5cdFx0XHRicm93c2VyV2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG5cdFx0XHRicm93c2VySGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcblx0XHRcdHNjcm9sbFggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XG5cdFx0XHRzY3JvbGxZID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcblx0XHRcdHRoaXMuX3BvcyA9IC8vIHNob3VsZCB1c2UgYWN0dWFsIHdpZHRoL2hlaWdodCBiZWxvd1xuXHRcdFx0XHRbKGJyb3dzZXJXaWR0aCAvIDIpIC0gMTAwICsgc2Nyb2xsWCwgKGJyb3dzZXJIZWlnaHQgLyAyKSAtIDE1MCArIHNjcm9sbFldO1xuXHRcdH1cblxuXHRcdC8vIG1vdmUgaW5wdXQgb24gc2NyZWVuIGZvciBmb2N1cywgYnV0IGhpZGRlbiBiZWhpbmQgZGlhbG9nXG5cdFx0dGhpcy5fZGlhbG9nSW5wdXQuY3NzKFwibGVmdFwiLCAodGhpcy5fcG9zWzBdICsgMjApICsgXCJweFwiKS5jc3MoXCJ0b3BcIiwgdGhpcy5fcG9zWzFdICsgXCJweFwiKTtcblx0XHRpbnN0LnNldHRpbmdzLm9uU2VsZWN0ID0gb25TZWxlY3Q7XG5cdFx0dGhpcy5faW5EaWFsb2cgPSB0cnVlO1xuXHRcdHRoaXMuZHBEaXYuYWRkQ2xhc3ModGhpcy5fZGlhbG9nQ2xhc3MpO1xuXHRcdHRoaXMuX3Nob3dEYXRlcGlja2VyKHRoaXMuX2RpYWxvZ0lucHV0WzBdKTtcblx0XHRpZiAoJC5ibG9ja1VJKSB7XG5cdFx0XHQkLmJsb2NrVUkodGhpcy5kcERpdik7XG5cdFx0fVxuXHRcdCQuZGF0YSh0aGlzLl9kaWFsb2dJbnB1dFswXSwgUFJPUF9OQU1FLCBpbnN0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiBEZXRhY2ggYSBkYXRlcGlja2VyIGZyb20gaXRzIGNvbnRyb2wuXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfZGVzdHJveURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBub2RlTmFtZSxcblx0XHRcdCR0YXJnZXQgPSAkKHRhcmdldCksXG5cdFx0XHRpbnN0ID0gJC5kYXRhKHRhcmdldCwgUFJPUF9OQU1FKTtcblxuXHRcdGlmICghJHRhcmdldC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdCQucmVtb3ZlRGF0YSh0YXJnZXQsIFBST1BfTkFNRSk7XG5cdFx0aWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIpIHtcblx0XHRcdGluc3QuYXBwZW5kLnJlbW92ZSgpO1xuXHRcdFx0aW5zdC50cmlnZ2VyLnJlbW92ZSgpO1xuXHRcdFx0JHRhcmdldC5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuXG5cdFx0XHRcdHVuYmluZChcImZvY3VzXCIsIHRoaXMuX3Nob3dEYXRlcGlja2VyKS5cblx0XHRcdFx0dW5iaW5kKFwia2V5ZG93blwiLCB0aGlzLl9kb0tleURvd24pLlxuXHRcdFx0XHR1bmJpbmQoXCJrZXlwcmVzc1wiLCB0aGlzLl9kb0tleVByZXNzKS5cblx0XHRcdFx0dW5iaW5kKFwia2V5dXBcIiwgdGhpcy5fZG9LZXlVcCk7XG5cdFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJkaXZcIiB8fCBub2RlTmFtZSA9PT0gXCJzcGFuXCIpIHtcblx0XHRcdCR0YXJnZXQucmVtb3ZlQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpLmVtcHR5KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEVuYWJsZSB0aGUgZGF0ZSBwaWNrZXIgdG8gYSBqUXVlcnkgc2VsZWN0aW9uLlxuXHQgKiBAcGFyYW0gIHRhcmdldFx0ZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKi9cblx0X2VuYWJsZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBub2RlTmFtZSwgaW5saW5lLFxuXHRcdFx0JHRhcmdldCA9ICQodGFyZ2V0KSxcblx0XHRcdGluc3QgPSAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXG5cdFx0aWYgKCEkdGFyZ2V0Lmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIpIHtcblx0XHRcdHRhcmdldC5kaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlcihcImJ1dHRvblwiKS5cblx0XHRcdFx0ZWFjaChmdW5jdGlvbigpIHsgdGhpcy5kaXNhYmxlZCA9IGZhbHNlOyB9KS5lbmQoKS5cblx0XHRcdFx0ZmlsdGVyKFwiaW1nXCIpLmNzcyh7b3BhY2l0eTogXCIxLjBcIiwgY3Vyc29yOiBcIlwifSk7XG5cdFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJkaXZcIiB8fCBub2RlTmFtZSA9PT0gXCJzcGFuXCIpIHtcblx0XHRcdGlubGluZSA9ICR0YXJnZXQuY2hpbGRyZW4oXCIuXCIgKyB0aGlzLl9pbmxpbmVDbGFzcyk7XG5cdFx0XHRpbmxpbmUuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWRpc2FibGVkXCIpO1xuXHRcdFx0aW5saW5lLmZpbmQoXCJzZWxlY3QudWktZGF0ZXBpY2tlci1tb250aCwgc2VsZWN0LnVpLWRhdGVwaWNrZXIteWVhclwiKS5cblx0XHRcdFx0cHJvcChcImRpc2FibGVkXCIsIGZhbHNlKTtcblx0XHR9XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHMgPSAkLm1hcCh0aGlzLl9kaXNhYmxlZElucHV0cyxcblx0XHRcdGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT09IHRhcmdldCA/IG51bGwgOiB2YWx1ZSk7IH0pOyAvLyBkZWxldGUgZW50cnlcblx0fSxcblxuXHQvKiBEaXNhYmxlIHRoZSBkYXRlIHBpY2tlciB0byBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfZGlzYWJsZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBub2RlTmFtZSwgaW5saW5lLFxuXHRcdFx0JHRhcmdldCA9ICQodGFyZ2V0KSxcblx0XHRcdGluc3QgPSAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXG5cdFx0aWYgKCEkdGFyZ2V0Lmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIpIHtcblx0XHRcdHRhcmdldC5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpbnN0LnRyaWdnZXIuZmlsdGVyKFwiYnV0dG9uXCIpLlxuXHRcdFx0XHRlYWNoKGZ1bmN0aW9uKCkgeyB0aGlzLmRpc2FibGVkID0gdHJ1ZTsgfSkuZW5kKCkuXG5cdFx0XHRcdGZpbHRlcihcImltZ1wiKS5jc3Moe29wYWNpdHk6IFwiMC41XCIsIGN1cnNvcjogXCJkZWZhdWx0XCJ9KTtcblx0XHR9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIikge1xuXHRcdFx0aW5saW5lID0gJHRhcmdldC5jaGlsZHJlbihcIi5cIiArIHRoaXMuX2lubGluZUNsYXNzKTtcblx0XHRcdGlubGluZS5jaGlsZHJlbigpLmFkZENsYXNzKFwidWktc3RhdGUtZGlzYWJsZWRcIik7XG5cdFx0XHRpbmxpbmUuZmluZChcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIpLlxuXHRcdFx0XHRwcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gJC5tYXAodGhpcy5fZGlzYWJsZWRJbnB1dHMsXG5cdFx0XHRmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gKHZhbHVlID09PSB0YXJnZXQgPyBudWxsIDogdmFsdWUpOyB9KTsgLy8gZGVsZXRlIGVudHJ5XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHNbdGhpcy5fZGlzYWJsZWRJbnB1dHMubGVuZ3RoXSA9IHRhcmdldDtcblx0fSxcblxuXHQvKiBJcyB0aGUgZmlyc3QgZmllbGQgaW4gYSBqUXVlcnkgY29sbGVjdGlvbiBkaXNhYmxlZCBhcyBhIGRhdGVwaWNrZXI/XG5cdCAqIEBwYXJhbSAgdGFyZ2V0XHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEByZXR1cm4gYm9vbGVhbiAtIHRydWUgaWYgZGlzYWJsZWQsIGZhbHNlIGlmIGVuYWJsZWRcblx0ICovXG5cdF9pc0Rpc2FibGVkRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kaXNhYmxlZElucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuX2Rpc2FibGVkSW5wdXRzW2ldID09PSB0YXJnZXQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKiBSZXRyaWV2ZSB0aGUgaW5zdGFuY2UgZGF0YSBmb3IgdGhlIHRhcmdldCBjb250cm9sLlxuXHQgKiBAcGFyYW0gIHRhcmdldCAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKiBAcmV0dXJuICBvYmplY3QgLSB0aGUgYXNzb2NpYXRlZCBpbnN0YW5jZSBkYXRhXG5cdCAqIEB0aHJvd3MgIGVycm9yIGlmIGEgalF1ZXJ5IHByb2JsZW0gZ2V0dGluZyBkYXRhXG5cdCAqL1xuXHRfZ2V0SW5zdDogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXHRcdH1cblx0XHRjYXRjaCAoZXJyKSB7XG5cdFx0XHR0aHJvdyBcIk1pc3NpbmcgaW5zdGFuY2UgZGF0YSBmb3IgdGhpcyBkYXRlcGlja2VyXCI7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFVwZGF0ZSBvciByZXRyaWV2ZSB0aGUgc2V0dGluZ3MgZm9yIGEgZGF0ZSBwaWNrZXIgYXR0YWNoZWQgdG8gYW4gaW5wdXQgZmllbGQgb3IgZGl2aXNpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0ICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgbmFtZVx0b2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1cGRhdGUgb3Jcblx0ICpcdFx0XHRcdHN0cmluZyAtIHRoZSBuYW1lIG9mIHRoZSBzZXR0aW5nIHRvIGNoYW5nZSBvciByZXRyaWV2ZSxcblx0ICpcdFx0XHRcdHdoZW4gcmV0cmlldmluZyBhbHNvIFwiYWxsXCIgZm9yIGFsbCBpbnN0YW5jZSBzZXR0aW5ncyBvclxuXHQgKlx0XHRcdFx0XCJkZWZhdWx0c1wiIGZvciBhbGwgZ2xvYmFsIGRlZmF1bHRzXG5cdCAqIEBwYXJhbSAgdmFsdWUgICBhbnkgLSB0aGUgbmV3IHZhbHVlIGZvciB0aGUgc2V0dGluZ1xuXHQgKlx0XHRcdFx0KG9taXQgaWYgYWJvdmUgaXMgYW4gb2JqZWN0IG9yIHRvIHJldHJpZXZlIGEgdmFsdWUpXG5cdCAqL1xuXHRfb3B0aW9uRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuXHRcdHZhciBzZXR0aW5ncywgZGF0ZSwgbWluRGF0ZSwgbWF4RGF0ZSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0cmV0dXJuIChuYW1lID09PSBcImRlZmF1bHRzXCIgPyAkLmV4dGVuZCh7fSwgJC5kYXRlcGlja2VyLl9kZWZhdWx0cykgOlxuXHRcdFx0XHQoaW5zdCA/IChuYW1lID09PSBcImFsbFwiID8gJC5leHRlbmQoe30sIGluc3Quc2V0dGluZ3MpIDpcblx0XHRcdFx0dGhpcy5fZ2V0KGluc3QsIG5hbWUpKSA6IG51bGwpKTtcblx0XHR9XG5cblx0XHRzZXR0aW5ncyA9IG5hbWUgfHwge307XG5cdFx0aWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRzZXR0aW5ncyA9IHt9O1xuXHRcdFx0c2V0dGluZ3NbbmFtZV0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoaW5zdCkge1xuXHRcdFx0aWYgKHRoaXMuX2N1ckluc3QgPT09IGluc3QpIHtcblx0XHRcdFx0dGhpcy5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0ZGF0ZSA9IHRoaXMuX2dldERhdGVEYXRlcGlja2VyKHRhcmdldCwgdHJ1ZSk7XG5cdFx0XHRtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1pblwiKTtcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWF4XCIpO1xuXHRcdFx0ZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIHNldHRpbmdzKTtcblx0XHRcdC8vIHJlZm9ybWF0IHRoZSBvbGQgbWluRGF0ZS9tYXhEYXRlIHZhbHVlcyBpZiBkYXRlRm9ybWF0IGNoYW5nZXMgYW5kIGEgbmV3IG1pbkRhdGUvbWF4RGF0ZSBpc24ndCBwcm92aWRlZFxuXHRcdFx0aWYgKG1pbkRhdGUgIT09IG51bGwgJiYgc2V0dGluZ3MuZGF0ZUZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLm1pbkRhdGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpbnN0LnNldHRpbmdzLm1pbkRhdGUgPSB0aGlzLl9mb3JtYXREYXRlKGluc3QsIG1pbkRhdGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1heERhdGUgIT09IG51bGwgJiYgc2V0dGluZ3MuZGF0ZUZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLm1heERhdGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpbnN0LnNldHRpbmdzLm1heERhdGUgPSB0aGlzLl9mb3JtYXREYXRlKGluc3QsIG1heERhdGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBcImRpc2FibGVkXCIgaW4gc2V0dGluZ3MgKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGlzYWJsZURhdGVwaWNrZXIodGFyZ2V0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9lbmFibGVEYXRlcGlja2VyKHRhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2F0dGFjaG1lbnRzKCQodGFyZ2V0KSwgaW5zdCk7XG5cdFx0XHR0aGlzLl9hdXRvU2l6ZShpbnN0KTtcblx0XHRcdHRoaXMuX3NldERhdGUoaW5zdCwgZGF0ZSk7XG5cdFx0XHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBjaGFuZ2UgbWV0aG9kIGRlcHJlY2F0ZWRcblx0X2NoYW5nZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLl9vcHRpb25EYXRlcGlja2VyKHRhcmdldCwgbmFtZSwgdmFsdWUpO1xuXHR9LFxuXG5cdC8qIFJlZHJhdyB0aGUgZGF0ZSBwaWNrZXIgYXR0YWNoZWQgdG8gYW4gaW5wdXQgZmllbGQgb3IgZGl2aXNpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0ICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqL1xuXHRfcmVmcmVzaERhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmIChpbnN0KSB7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBTZXQgdGhlIGRhdGVzIGZvciBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSAgdGFyZ2V0IGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBkYXRlXHREYXRlIC0gdGhlIG5ldyBkYXRlXG5cdCAqL1xuXHRfc2V0RGF0ZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCwgZGF0ZSkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmIChpbnN0KSB7XG5cdFx0XHR0aGlzLl9zZXREYXRlKGluc3QsIGRhdGUpO1xuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcblx0XHR9XG5cdH0sXG5cblx0LyogR2V0IHRoZSBkYXRlKHMpIGZvciB0aGUgZmlyc3QgZW50cnkgaW4gYSBqUXVlcnkgc2VsZWN0aW9uLlxuXHQgKiBAcGFyYW0gIHRhcmdldCBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgbm9EZWZhdWx0IGJvb2xlYW4gLSB0cnVlIGlmIG5vIGRlZmF1bHQgZGF0ZSBpcyB0byBiZSB1c2VkXG5cdCAqIEByZXR1cm4gRGF0ZSAtIHRoZSBjdXJyZW50IGRhdGVcblx0ICovXG5cdF9nZXREYXRlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBub0RlZmF1bHQpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblx0XHRpZiAoaW5zdCAmJiAhaW5zdC5pbmxpbmUpIHtcblx0XHRcdHRoaXMuX3NldERhdGVGcm9tRmllbGQoaW5zdCwgbm9EZWZhdWx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIChpbnN0ID8gdGhpcy5fZ2V0RGF0ZShpbnN0KSA6IG51bGwpO1xuXHR9LFxuXG5cdC8qIEhhbmRsZSBrZXlzdHJva2VzLiAqL1xuXHRfZG9LZXlEb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBvblNlbGVjdCwgZGF0ZVN0ciwgc2VsLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpLFxuXHRcdFx0aGFuZGxlZCA9IHRydWUsXG5cdFx0XHRpc1JUTCA9IGluc3QuZHBEaXYuaXMoXCIudWktZGF0ZXBpY2tlci1ydGxcIik7XG5cblx0XHRpbnN0Ll9rZXlFdmVudCA9IHRydWU7XG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcpIHtcblx0XHRcdHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuXHRcdFx0XHRjYXNlIDk6ICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBoaWRlIG9uIHRhYiBvdXRcblx0XHRcdFx0Y2FzZSAxMzogc2VsID0gJChcInRkLlwiICsgJC5kYXRlcGlja2VyLl9kYXlPdmVyQ2xhc3MgKyBcIjpub3QoLlwiICtcblx0XHRcdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fY3VycmVudENsYXNzICsgXCIpXCIsIGluc3QuZHBEaXYpO1xuXHRcdFx0XHRcdFx0aWYgKHNlbFswXSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdERheShldmVudC50YXJnZXQsIGluc3Quc2VsZWN0ZWRNb250aCwgaW5zdC5zZWxlY3RlZFllYXIsIHNlbFswXSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG9uU2VsZWN0ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJvblNlbGVjdFwiKTtcblx0XHRcdFx0XHRcdGlmIChvblNlbGVjdCkge1xuXHRcdFx0XHRcdFx0XHRkYXRlU3RyID0gJC5kYXRlcGlja2VyLl9mb3JtYXREYXRlKGluc3QpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIHRyaWdnZXIgY3VzdG9tIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHRcdG9uU2VsZWN0LmFwcGx5KChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwpLCBbZGF0ZVN0ciwgaW5zdF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGRvbid0IHN1Ym1pdCB0aGUgZm9ybVxuXHRcdFx0XHRjYXNlIDI3OiAkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gaGlkZSBvbiBlc2NhcGVcblx0XHRcdFx0Y2FzZSAzMzogJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHQtJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIpIDpcblx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic3RlcE1vbnRoc1wiKSksIFwiTVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBwcmV2aW91cyBtb250aC95ZWFyIG9uIHBhZ2UgdXAvKyBjdHJsXG5cdFx0XHRcdGNhc2UgMzQ6ICQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIChldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwic3RlcEJpZ01vbnRoc1wiKSA6XG5cdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBNb250aHNcIikpLCBcIk1cIik7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gbmV4dCBtb250aC95ZWFyIG9uIHBhZ2UgZG93bi8rIGN0cmxcblx0XHRcdFx0Y2FzZSAzNTogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2NsZWFyRGF0ZShldmVudC50YXJnZXQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBjbGVhciBvbiBjdHJsIG9yIGNvbW1hbmQgK2VuZFxuXHRcdFx0XHRjYXNlIDM2OiBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ290b1RvZGF5KGV2ZW50LnRhcmdldCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGN1cnJlbnQgb24gY3RybCBvciBjb21tYW5kICtob21lXG5cdFx0XHRcdGNhc2UgMzc6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGlzUlRMID8gKzEgOiAtMSksIFwiRFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHQvLyAtMSBkYXkgb24gY3RybCBvciBjb21tYW5kICtsZWZ0XG5cdFx0XHRcdFx0XHRpZiAoZXZlbnQub3JpZ2luYWxFdmVudC5hbHRLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHRcdC0kLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBCaWdNb250aHNcIikgOlxuXHRcdFx0XHRcdFx0XHRcdC0kLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInN0ZXBNb250aHNcIikpLCBcIk1cIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBuZXh0IG1vbnRoL3llYXIgb24gYWx0ICtsZWZ0IG9uIE1hY1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMzg6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgLTcsIFwiRFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gLTEgd2VlayBvbiBjdHJsIG9yIGNvbW1hbmQgK3VwXG5cdFx0XHRcdGNhc2UgMzk6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGlzUlRMID8gLTEgOiArMSksIFwiRFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHQvLyArMSBkYXkgb24gY3RybCBvciBjb21tYW5kICtyaWdodFxuXHRcdFx0XHRcdFx0aWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQuYWx0S2V5KSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIChldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0XHQrJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIpIDpcblx0XHRcdFx0XHRcdFx0XHQrJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzdGVwTW9udGhzXCIpKSwgXCJNXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gbmV4dCBtb250aC95ZWFyIG9uIGFsdCArcmlnaHRcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDQwOiBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsICs3LCBcIkRcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vICsxIHdlZWsgb24gY3RybCBvciBjb21tYW5kICtkb3duXG5cdFx0XHRcdGRlZmF1bHQ6IGhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDM2ICYmIGV2ZW50LmN0cmxLZXkpIHsgLy8gZGlzcGxheSB0aGUgZGF0ZSBwaWNrZXIgb24gY3RybCtob21lXG5cdFx0XHQkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoYW5kbGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKGhhbmRsZWQpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cblx0LyogRmlsdGVyIGVudGVyZWQgY2hhcmFjdGVycyAtIGJhc2VkIG9uIGRhdGUgZm9ybWF0LiAqL1xuXHRfZG9LZXlQcmVzczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgY2hhcnMsIGNocixcblx0XHRcdGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KTtcblxuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImNvbnN0cmFpbklucHV0XCIpKSB7XG5cdFx0XHRjaGFycyA9ICQuZGF0ZXBpY2tlci5fcG9zc2libGVDaGFycygkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIikpO1xuXHRcdFx0Y2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSA9PSBudWxsID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlKTtcblx0XHRcdHJldHVybiBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgKGNociA8IFwiIFwiIHx8ICFjaGFycyB8fCBjaGFycy5pbmRleE9mKGNocikgPiAtMSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFN5bmNocm9uaXNlIG1hbnVhbCBlbnRyeSBhbmQgZmllbGQvYWx0ZXJuYXRlIGZpZWxkLiAqL1xuXHRfZG9LZXlVcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgZGF0ZSxcblx0XHRcdGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KTtcblxuXHRcdGlmIChpbnN0LmlucHV0LnZhbCgpICE9PSBpbnN0Lmxhc3RWYWwpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGUgPSAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFwiZGF0ZUZvcm1hdFwiKSxcblx0XHRcdFx0XHQoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBudWxsKSxcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XG5cblx0XHRcdFx0aWYgKGRhdGUpIHsgLy8gb25seSBpZiB2YWxpZFxuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZChpbnN0KTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyogUG9wLXVwIHRoZSBkYXRlIHBpY2tlciBmb3IgYSBnaXZlbiBpbnB1dCBmaWVsZC5cblx0ICogSWYgZmFsc2UgcmV0dXJuZWQgZnJvbSBiZWZvcmVTaG93IGV2ZW50IGhhbmRsZXIgZG8gbm90IHNob3cuXG5cdCAqIEBwYXJhbSAgaW5wdXQgIGVsZW1lbnQgLSB0aGUgaW5wdXQgZmllbGQgYXR0YWNoZWQgdG8gdGhlIGRhdGUgcGlja2VyIG9yXG5cdCAqXHRcdFx0XHRcdGV2ZW50IC0gaWYgdHJpZ2dlcmVkIGJ5IGZvY3VzXG5cdCAqL1xuXHRfc2hvd0RhdGVwaWNrZXI6IGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0aW5wdXQgPSBpbnB1dC50YXJnZXQgfHwgaW5wdXQ7XG5cdFx0aWYgKGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiaW5wdXRcIikgeyAvLyBmaW5kIGZyb20gYnV0dG9uL2ltYWdlIHRyaWdnZXJcblx0XHRcdGlucHV0ID0gJChcImlucHV0XCIsIGlucHV0LnBhcmVudE5vZGUpWzBdO1xuXHRcdH1cblxuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2lzRGlzYWJsZWREYXRlcGlja2VyKGlucHV0KSB8fCAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9PT0gaW5wdXQpIHsgLy8gYWxyZWFkeSBoZXJlXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGluc3QsIGJlZm9yZVNob3csIGJlZm9yZVNob3dTZXR0aW5ncywgaXNGaXhlZCxcblx0XHRcdG9mZnNldCwgc2hvd0FuaW0sIGR1cmF0aW9uO1xuXG5cdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChpbnB1dCk7XG5cdFx0aWYgKCQuZGF0ZXBpY2tlci5fY3VySW5zdCAmJiAkLmRhdGVwaWNrZXIuX2N1ckluc3QgIT09IGluc3QpIHtcblx0XHRcdCQuZGF0ZXBpY2tlci5fY3VySW5zdC5kcERpdi5zdG9wKHRydWUsIHRydWUpO1xuXHRcdFx0aWYgKCBpbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgKSB7XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoICQuZGF0ZXBpY2tlci5fY3VySW5zdC5pbnB1dFswXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJlZm9yZVNob3cgPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImJlZm9yZVNob3dcIik7XG5cdFx0YmVmb3JlU2hvd1NldHRpbmdzID0gYmVmb3JlU2hvdyA/IGJlZm9yZVNob3cuYXBwbHkoaW5wdXQsIFtpbnB1dCwgaW5zdF0pIDoge307XG5cdFx0aWYoYmVmb3JlU2hvd1NldHRpbmdzID09PSBmYWxzZSl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGV4dGVuZFJlbW92ZShpbnN0LnNldHRpbmdzLCBiZWZvcmVTaG93U2V0dGluZ3MpO1xuXG5cdFx0aW5zdC5sYXN0VmFsID0gbnVsbDtcblx0XHQkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9IGlucHV0O1xuXHRcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZChpbnN0KTtcblxuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2luRGlhbG9nKSB7IC8vIGhpZGUgY3Vyc29yXG5cdFx0XHRpbnB1dC52YWx1ZSA9IFwiXCI7XG5cdFx0fVxuXHRcdGlmICghJC5kYXRlcGlja2VyLl9wb3MpIHsgLy8gcG9zaXRpb24gYmVsb3cgaW5wdXRcblx0XHRcdCQuZGF0ZXBpY2tlci5fcG9zID0gJC5kYXRlcGlja2VyLl9maW5kUG9zKGlucHV0KTtcblx0XHRcdCQuZGF0ZXBpY2tlci5fcG9zWzFdICs9IGlucHV0Lm9mZnNldEhlaWdodDsgLy8gYWRkIHRoZSBoZWlnaHRcblx0XHR9XG5cblx0XHRpc0ZpeGVkID0gZmFsc2U7XG5cdFx0JChpbnB1dCkucGFyZW50cygpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpc0ZpeGVkIHw9ICQodGhpcykuY3NzKFwicG9zaXRpb25cIikgPT09IFwiZml4ZWRcIjtcblx0XHRcdHJldHVybiAhaXNGaXhlZDtcblx0XHR9KTtcblxuXHRcdG9mZnNldCA9IHtsZWZ0OiAkLmRhdGVwaWNrZXIuX3Bvc1swXSwgdG9wOiAkLmRhdGVwaWNrZXIuX3Bvc1sxXX07XG5cdFx0JC5kYXRlcGlja2VyLl9wb3MgPSBudWxsO1xuXHRcdC8vdG8gYXZvaWQgZmxhc2hlcyBvbiBGaXJlZm94XG5cdFx0aW5zdC5kcERpdi5lbXB0eSgpO1xuXHRcdC8vIGRldGVybWluZSBzaXppbmcgb2Zmc2NyZWVuXG5cdFx0aW5zdC5kcERpdi5jc3Moe3Bvc2l0aW9uOiBcImFic29sdXRlXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiwgdG9wOiBcIi0xMDAwcHhcIn0pO1xuXHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHQvLyBmaXggd2lkdGggZm9yIGR5bmFtaWMgbnVtYmVyIG9mIGRhdGUgcGlja2Vyc1xuXHRcdC8vIGFuZCBhZGp1c3QgcG9zaXRpb24gYmVmb3JlIHNob3dpbmdcblx0XHRvZmZzZXQgPSAkLmRhdGVwaWNrZXIuX2NoZWNrT2Zmc2V0KGluc3QsIG9mZnNldCwgaXNGaXhlZCk7XG5cdFx0aW5zdC5kcERpdi5jc3Moe3Bvc2l0aW9uOiAoJC5kYXRlcGlja2VyLl9pbkRpYWxvZyAmJiAkLmJsb2NrVUkgP1xuXHRcdFx0XCJzdGF0aWNcIiA6IChpc0ZpeGVkID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiKSksIGRpc3BsYXk6IFwibm9uZVwiLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgKyBcInB4XCIsIHRvcDogb2Zmc2V0LnRvcCArIFwicHhcIn0pO1xuXG5cdFx0aWYgKCFpbnN0LmlubGluZSkge1xuXHRcdFx0c2hvd0FuaW0gPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInNob3dBbmltXCIpO1xuXHRcdFx0ZHVyYXRpb24gPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcImR1cmF0aW9uXCIpO1xuXHRcdFx0aW5zdC5kcERpdi56SW5kZXgoJChpbnB1dCkuekluZGV4KCkrMSk7XG5cdFx0XHQkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgc2hvd0FuaW0gXSApIHtcblx0XHRcdFx0aW5zdC5kcERpdi5zaG93KHNob3dBbmltLCAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcInNob3dPcHRpb25zXCIpLCBkdXJhdGlvbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbnN0LmRwRGl2W3Nob3dBbmltIHx8IFwic2hvd1wiXShzaG93QW5pbSA/IGR1cmF0aW9uIDogbnVsbCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggJC5kYXRlcGlja2VyLl9zaG91bGRGb2N1c0lucHV0KCBpbnN0ICkgKSB7XG5cdFx0XHRcdGluc3QuaW5wdXQuZm9jdXMoKTtcblx0XHRcdH1cblxuXHRcdFx0JC5kYXRlcGlja2VyLl9jdXJJbnN0ID0gaW5zdDtcblx0XHR9XG5cdH0sXG5cblx0LyogR2VuZXJhdGUgdGhlIGRhdGUgcGlja2VyIGNvbnRlbnQuICovXG5cdF91cGRhdGVEYXRlcGlja2VyOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dGhpcy5tYXhSb3dzID0gNDsgLy9SZXNldCB0aGUgbWF4IG51bWJlciBvZiByb3dzIGJlaW5nIGRpc3BsYXllZCAoc2VlICM3MDQzKVxuXHRcdGluc3RBY3RpdmUgPSBpbnN0OyAvLyBmb3IgZGVsZWdhdGUgaG92ZXIgZXZlbnRzXG5cdFx0aW5zdC5kcERpdi5lbXB0eSgpLmFwcGVuZCh0aGlzLl9nZW5lcmF0ZUhUTUwoaW5zdCkpO1xuXHRcdHRoaXMuX2F0dGFjaEhhbmRsZXJzKGluc3QpO1xuXHRcdGluc3QuZHBEaXYuZmluZChcIi5cIiArIHRoaXMuX2RheU92ZXJDbGFzcyArIFwiIGFcIikubW91c2VvdmVyKCk7XG5cblx0XHR2YXIgb3JpZ3llYXJzaHRtbCxcblx0XHRcdG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKGluc3QpLFxuXHRcdFx0Y29scyA9IG51bU1vbnRoc1sxXSxcblx0XHRcdHdpZHRoID0gMTc7XG5cblx0XHRpbnN0LmRwRGl2LnJlbW92ZUNsYXNzKFwidWktZGF0ZXBpY2tlci1tdWx0aS0yIHVpLWRhdGVwaWNrZXItbXVsdGktMyB1aS1kYXRlcGlja2VyLW11bHRpLTRcIikud2lkdGgoXCJcIik7XG5cdFx0aWYgKGNvbHMgPiAxKSB7XG5cdFx0XHRpbnN0LmRwRGl2LmFkZENsYXNzKFwidWktZGF0ZXBpY2tlci1tdWx0aS1cIiArIGNvbHMpLmNzcyhcIndpZHRoXCIsICh3aWR0aCAqIGNvbHMpICsgXCJlbVwiKTtcblx0XHR9XG5cdFx0aW5zdC5kcERpdlsobnVtTW9udGhzWzBdICE9PSAxIHx8IG51bU1vbnRoc1sxXSAhPT0gMSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArXG5cdFx0XHRcIkNsYXNzXCJdKFwidWktZGF0ZXBpY2tlci1tdWx0aVwiKTtcblx0XHRpbnN0LmRwRGl2Wyh0aGlzLl9nZXQoaW5zdCwgXCJpc1JUTFwiKSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArXG5cdFx0XHRcIkNsYXNzXCJdKFwidWktZGF0ZXBpY2tlci1ydGxcIik7XG5cblx0XHRpZiAoaW5zdCA9PT0gJC5kYXRlcGlja2VyLl9jdXJJbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgJC5kYXRlcGlja2VyLl9zaG91bGRGb2N1c0lucHV0KCBpbnN0ICkgKSB7XG5cdFx0XHRpbnN0LmlucHV0LmZvY3VzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gZGVmZmVyZWQgcmVuZGVyIG9mIHRoZSB5ZWFycyBzZWxlY3QgKHRvIGF2b2lkIGZsYXNoZXMgb24gRmlyZWZveClcblx0XHRpZiggaW5zdC55ZWFyc2h0bWwgKXtcblx0XHRcdG9yaWd5ZWFyc2h0bWwgPSBpbnN0LnllYXJzaHRtbDtcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0Ly9hc3N1cmUgdGhhdCBpbnN0LnllYXJzaHRtbCBkaWRuJ3QgY2hhbmdlLlxuXHRcdFx0XHRpZiggb3JpZ3llYXJzaHRtbCA9PT0gaW5zdC55ZWFyc2h0bWwgJiYgaW5zdC55ZWFyc2h0bWwgKXtcblx0XHRcdFx0XHRpbnN0LmRwRGl2LmZpbmQoXCJzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyOmZpcnN0XCIpLnJlcGxhY2VXaXRoKGluc3QueWVhcnNodG1sKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcmlneWVhcnNodG1sID0gaW5zdC55ZWFyc2h0bWwgPSBudWxsO1xuXHRcdFx0fSwgMCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vICM2Njk0IC0gZG9uJ3QgZm9jdXMgdGhlIGlucHV0IGlmIGl0J3MgYWxyZWFkeSBmb2N1c2VkXG5cdC8vIHRoaXMgYnJlYWtzIHRoZSBjaGFuZ2UgZXZlbnQgaW4gSUVcblx0Ly8gU3VwcG9ydDogSUUgYW5kIGpRdWVyeSA8MS45XG5cdF9zaG91bGRGb2N1c0lucHV0OiBmdW5jdGlvbiggaW5zdCApIHtcblx0XHRyZXR1cm4gaW5zdC5pbnB1dCAmJiBpbnN0LmlucHV0LmlzKCBcIjp2aXNpYmxlXCIgKSAmJiAhaW5zdC5pbnB1dC5pcyggXCI6ZGlzYWJsZWRcIiApICYmICFpbnN0LmlucHV0LmlzKCBcIjpmb2N1c1wiICk7XG5cdH0sXG5cblx0LyogQ2hlY2sgcG9zaXRpb25pbmcgdG8gcmVtYWluIG9uIHNjcmVlbi4gKi9cblx0X2NoZWNrT2Zmc2V0OiBmdW5jdGlvbihpbnN0LCBvZmZzZXQsIGlzRml4ZWQpIHtcblx0XHR2YXIgZHBXaWR0aCA9IGluc3QuZHBEaXYub3V0ZXJXaWR0aCgpLFxuXHRcdFx0ZHBIZWlnaHQgPSBpbnN0LmRwRGl2Lm91dGVySGVpZ2h0KCksXG5cdFx0XHRpbnB1dFdpZHRoID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJXaWR0aCgpIDogMCxcblx0XHRcdGlucHV0SGVpZ2h0ID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJIZWlnaHQoKSA6IDAsXG5cdFx0XHR2aWV3V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggKyAoaXNGaXhlZCA/IDAgOiAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkpLFxuXHRcdFx0dmlld0hlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgKyAoaXNGaXhlZCA/IDAgOiAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSk7XG5cblx0XHRvZmZzZXQubGVmdCAtPSAodGhpcy5fZ2V0KGluc3QsIFwiaXNSVExcIikgPyAoZHBXaWR0aCAtIGlucHV0V2lkdGgpIDogMCk7XG5cdFx0b2Zmc2V0LmxlZnQgLT0gKGlzRml4ZWQgJiYgb2Zmc2V0LmxlZnQgPT09IGluc3QuaW5wdXQub2Zmc2V0KCkubGVmdCkgPyAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgOiAwO1xuXHRcdG9mZnNldC50b3AgLT0gKGlzRml4ZWQgJiYgb2Zmc2V0LnRvcCA9PT0gKGluc3QuaW5wdXQub2Zmc2V0KCkudG9wICsgaW5wdXRIZWlnaHQpKSA/ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDogMDtcblxuXHRcdC8vIG5vdyBjaGVjayBpZiBkYXRlcGlja2VyIGlzIHNob3dpbmcgb3V0c2lkZSB3aW5kb3cgdmlld3BvcnQgLSBtb3ZlIHRvIGEgYmV0dGVyIHBsYWNlIGlmIHNvLlxuXHRcdG9mZnNldC5sZWZ0IC09IE1hdGgubWluKG9mZnNldC5sZWZ0LCAob2Zmc2V0LmxlZnQgKyBkcFdpZHRoID4gdmlld1dpZHRoICYmIHZpZXdXaWR0aCA+IGRwV2lkdGgpID9cblx0XHRcdE1hdGguYWJzKG9mZnNldC5sZWZ0ICsgZHBXaWR0aCAtIHZpZXdXaWR0aCkgOiAwKTtcblx0XHRvZmZzZXQudG9wIC09IE1hdGgubWluKG9mZnNldC50b3AsIChvZmZzZXQudG9wICsgZHBIZWlnaHQgPiB2aWV3SGVpZ2h0ICYmIHZpZXdIZWlnaHQgPiBkcEhlaWdodCkgP1xuXHRcdFx0TWF0aC5hYnMoZHBIZWlnaHQgKyBpbnB1dEhlaWdodCkgOiAwKTtcblxuXHRcdHJldHVybiBvZmZzZXQ7XG5cdH0sXG5cblx0LyogRmluZCBhbiBvYmplY3QncyBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuLiAqL1xuXHRfZmluZFBvczogZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIHBvc2l0aW9uLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3Qob2JqKSxcblx0XHRcdGlzUlRMID0gdGhpcy5fZ2V0KGluc3QsIFwiaXNSVExcIik7XG5cblx0XHR3aGlsZSAob2JqICYmIChvYmoudHlwZSA9PT0gXCJoaWRkZW5cIiB8fCBvYmoubm9kZVR5cGUgIT09IDEgfHwgJC5leHByLmZpbHRlcnMuaGlkZGVuKG9iaikpKSB7XG5cdFx0XHRvYmogPSBvYmpbaXNSVEwgPyBcInByZXZpb3VzU2libGluZ1wiIDogXCJuZXh0U2libGluZ1wiXTtcblx0XHR9XG5cblx0XHRwb3NpdGlvbiA9ICQob2JqKS5vZmZzZXQoKTtcblx0XHRyZXR1cm4gW3Bvc2l0aW9uLmxlZnQsIHBvc2l0aW9uLnRvcF07XG5cdH0sXG5cblx0LyogSGlkZSB0aGUgZGF0ZSBwaWNrZXIgZnJvbSB2aWV3LlxuXHQgKiBAcGFyYW0gIGlucHV0ICBlbGVtZW50IC0gdGhlIGlucHV0IGZpZWxkIGF0dGFjaGVkIHRvIHRoZSBkYXRlIHBpY2tlclxuXHQgKi9cblx0X2hpZGVEYXRlcGlja2VyOiBmdW5jdGlvbihpbnB1dCkge1xuXHRcdHZhciBzaG93QW5pbSwgZHVyYXRpb24sIHBvc3RQcm9jZXNzLCBvbkNsb3NlLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2N1ckluc3Q7XG5cblx0XHRpZiAoIWluc3QgfHwgKGlucHV0ICYmIGluc3QgIT09ICQuZGF0YShpbnB1dCwgUFJPUF9OQU1FKSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fZGF0ZXBpY2tlclNob3dpbmcpIHtcblx0XHRcdHNob3dBbmltID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd0FuaW1cIik7XG5cdFx0XHRkdXJhdGlvbiA9IHRoaXMuX2dldChpbnN0LCBcImR1cmF0aW9uXCIpO1xuXHRcdFx0cG9zdFByb2Nlc3MgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0JC5kYXRlcGlja2VyLl90aWR5RGlhbG9nKGluc3QpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gREVQUkVDQVRFRDogYWZ0ZXIgQkMgZm9yIDEuOC54ICQuZWZmZWN0c1sgc2hvd0FuaW0gXSBpcyBub3QgbmVlZGVkXG5cdFx0XHRpZiAoICQuZWZmZWN0cyAmJiAoICQuZWZmZWN0cy5lZmZlY3RbIHNob3dBbmltIF0gfHwgJC5lZmZlY3RzWyBzaG93QW5pbSBdICkgKSB7XG5cdFx0XHRcdGluc3QuZHBEaXYuaGlkZShzaG93QW5pbSwgJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJzaG93T3B0aW9uc1wiKSwgZHVyYXRpb24sIHBvc3RQcm9jZXNzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluc3QuZHBEaXZbKHNob3dBbmltID09PSBcInNsaWRlRG93blwiID8gXCJzbGlkZVVwXCIgOlxuXHRcdFx0XHRcdChzaG93QW5pbSA9PT0gXCJmYWRlSW5cIiA/IFwiZmFkZU91dFwiIDogXCJoaWRlXCIpKV0oKHNob3dBbmltID8gZHVyYXRpb24gOiBudWxsKSwgcG9zdFByb2Nlc3MpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNob3dBbmltKSB7XG5cdFx0XHRcdHBvc3RQcm9jZXNzKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kYXRlcGlja2VyU2hvd2luZyA9IGZhbHNlO1xuXG5cdFx0XHRvbkNsb3NlID0gdGhpcy5fZ2V0KGluc3QsIFwib25DbG9zZVwiKTtcblx0XHRcdGlmIChvbkNsb3NlKSB7XG5cdFx0XHRcdG9uQ2xvc2UuYXBwbHkoKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCksIFsoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBcIlwiKSwgaW5zdF0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sYXN0SW5wdXQgPSBudWxsO1xuXHRcdFx0aWYgKHRoaXMuX2luRGlhbG9nKSB7XG5cdFx0XHRcdHRoaXMuX2RpYWxvZ0lucHV0LmNzcyh7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIGxlZnQ6IFwiMFwiLCB0b3A6IFwiLTEwMHB4XCIgfSk7XG5cdFx0XHRcdGlmICgkLmJsb2NrVUkpIHtcblx0XHRcdFx0XHQkLnVuYmxvY2tVSSgpO1xuXHRcdFx0XHRcdCQoXCJib2R5XCIpLmFwcGVuZCh0aGlzLmRwRGl2KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5faW5EaWFsb2cgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0LyogVGlkeSB1cCBhZnRlciBhIGRpYWxvZyBkaXNwbGF5LiAqL1xuXHRfdGlkeURpYWxvZzogZnVuY3Rpb24oaW5zdCkge1xuXHRcdGluc3QuZHBEaXYucmVtb3ZlQ2xhc3ModGhpcy5fZGlhbG9nQ2xhc3MpLnVuYmluZChcIi51aS1kYXRlcGlja2VyLWNhbGVuZGFyXCIpO1xuXHR9LFxuXG5cdC8qIENsb3NlIGRhdGUgcGlja2VyIGlmIGNsaWNrZWQgZWxzZXdoZXJlLiAqL1xuXHRfY2hlY2tFeHRlcm5hbENsaWNrOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmICghJC5kYXRlcGlja2VyLl9jdXJJbnN0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyICR0YXJnZXQgPSAkKGV2ZW50LnRhcmdldCksXG5cdFx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KCR0YXJnZXRbMF0pO1xuXG5cdFx0aWYgKCAoICggJHRhcmdldFswXS5pZCAhPT0gJC5kYXRlcGlja2VyLl9tYWluRGl2SWQgJiZcblx0XHRcdFx0JHRhcmdldC5wYXJlbnRzKFwiI1wiICsgJC5kYXRlcGlja2VyLl9tYWluRGl2SWQpLmxlbmd0aCA9PT0gMCAmJlxuXHRcdFx0XHQhJHRhcmdldC5oYXNDbGFzcygkLmRhdGVwaWNrZXIubWFya2VyQ2xhc3NOYW1lKSAmJlxuXHRcdFx0XHQhJHRhcmdldC5jbG9zZXN0KFwiLlwiICsgJC5kYXRlcGlja2VyLl90cmlnZ2VyQ2xhc3MpLmxlbmd0aCAmJlxuXHRcdFx0XHQkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICEoJC5kYXRlcGlja2VyLl9pbkRpYWxvZyAmJiAkLmJsb2NrVUkpICkgKSB8fFxuXHRcdFx0KCAkdGFyZ2V0Lmhhc0NsYXNzKCQuZGF0ZXBpY2tlci5tYXJrZXJDbGFzc05hbWUpICYmICQuZGF0ZXBpY2tlci5fY3VySW5zdCAhPT0gaW5zdCApICkge1xuXHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEFkanVzdCBvbmUgb2YgdGhlIGRhdGUgc3ViLWZpZWxkcy4gKi9cblx0X2FkanVzdERhdGU6IGZ1bmN0aW9uKGlkLCBvZmZzZXQsIHBlcmlvZCkge1xuXHRcdHZhciB0YXJnZXQgPSAkKGlkKSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldFswXSk7XG5cblx0XHRpZiAodGhpcy5faXNEaXNhYmxlZERhdGVwaWNrZXIodGFyZ2V0WzBdKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9hZGp1c3RJbnN0RGF0ZShpbnN0LCBvZmZzZXQgK1xuXHRcdFx0KHBlcmlvZCA9PT0gXCJNXCIgPyB0aGlzLl9nZXQoaW5zdCwgXCJzaG93Q3VycmVudEF0UG9zXCIpIDogMCksIC8vIHVuZG8gcG9zaXRpb25pbmdcblx0XHRcdHBlcmlvZCk7XG5cdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIGN1cnJlbnQgbGluay4gKi9cblx0X2dvdG9Ub2RheTogZnVuY3Rpb24oaWQpIHtcblx0XHR2YXIgZGF0ZSxcblx0XHRcdHRhcmdldCA9ICQoaWQpLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblxuXHRcdGlmICh0aGlzLl9nZXQoaW5zdCwgXCJnb3RvQ3VycmVudFwiKSAmJiBpbnN0LmN1cnJlbnREYXkpIHtcblx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXk7XG5cdFx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoO1xuXHRcdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gaW5zdC5jdXJyZW50WWVhcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcblx0XHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHR9XG5cdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHRcdHRoaXMuX2FkanVzdERhdGUodGFyZ2V0KTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIHNlbGVjdGluZyBhIG5ldyBtb250aC95ZWFyLiAqL1xuXHRfc2VsZWN0TW9udGhZZWFyOiBmdW5jdGlvbihpZCwgc2VsZWN0LCBwZXJpb2QpIHtcblx0XHR2YXIgdGFyZ2V0ID0gJChpZCksXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXG5cdFx0aW5zdFtcInNlbGVjdGVkXCIgKyAocGVyaW9kID09PSBcIk1cIiA/IFwiTW9udGhcIiA6IFwiWWVhclwiKV0gPVxuXHRcdGluc3RbXCJkcmF3XCIgKyAocGVyaW9kID09PSBcIk1cIiA/IFwiTW9udGhcIiA6IFwiWWVhclwiKV0gPVxuXHRcdFx0cGFyc2VJbnQoc2VsZWN0Lm9wdGlvbnNbc2VsZWN0LnNlbGVjdGVkSW5kZXhdLnZhbHVlLDEwKTtcblxuXHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcblx0XHR0aGlzLl9hZGp1c3REYXRlKHRhcmdldCk7XG5cdH0sXG5cblx0LyogQWN0aW9uIGZvciBzZWxlY3RpbmcgYSBkYXkuICovXG5cdF9zZWxlY3REYXk6IGZ1bmN0aW9uKGlkLCBtb250aCwgeWVhciwgdGQpIHtcblx0XHR2YXIgaW5zdCxcblx0XHRcdHRhcmdldCA9ICQoaWQpO1xuXG5cdFx0aWYgKCQodGQpLmhhc0NsYXNzKHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzKSB8fCB0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlcih0YXJnZXRbMF0pKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5ID0gJChcImFcIiwgdGQpLmh0bWwoKTtcblx0XHRpbnN0LnNlbGVjdGVkTW9udGggPSBpbnN0LmN1cnJlbnRNb250aCA9IG1vbnRoO1xuXHRcdGluc3Quc2VsZWN0ZWRZZWFyID0gaW5zdC5jdXJyZW50WWVhciA9IHllYXI7XG5cdFx0dGhpcy5fc2VsZWN0RGF0ZShpZCwgdGhpcy5fZm9ybWF0RGF0ZShpbnN0LFxuXHRcdFx0aW5zdC5jdXJyZW50RGF5LCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50WWVhcikpO1xuXHR9LFxuXG5cdC8qIEVyYXNlIHRoZSBpbnB1dCBmaWVsZCBhbmQgaGlkZSB0aGUgZGF0ZSBwaWNrZXIuICovXG5cdF9jbGVhckRhdGU6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQoaWQpO1xuXHRcdHRoaXMuX3NlbGVjdERhdGUodGFyZ2V0LCBcIlwiKTtcblx0fSxcblxuXHQvKiBVcGRhdGUgdGhlIGlucHV0IGZpZWxkIHdpdGggdGhlIHNlbGVjdGVkIGRhdGUuICovXG5cdF9zZWxlY3REYXRlOiBmdW5jdGlvbihpZCwgZGF0ZVN0cikge1xuXHRcdHZhciBvblNlbGVjdCxcblx0XHRcdHRhcmdldCA9ICQoaWQpLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblxuXHRcdGRhdGVTdHIgPSAoZGF0ZVN0ciAhPSBudWxsID8gZGF0ZVN0ciA6IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCkpO1xuXHRcdGlmIChpbnN0LmlucHV0KSB7XG5cdFx0XHRpbnN0LmlucHV0LnZhbChkYXRlU3RyKTtcblx0XHR9XG5cdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXG5cdFx0b25TZWxlY3QgPSB0aGlzLl9nZXQoaW5zdCwgXCJvblNlbGVjdFwiKTtcblx0XHRpZiAob25TZWxlY3QpIHtcblx0XHRcdG9uU2VsZWN0LmFwcGx5KChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwpLCBbZGF0ZVN0ciwgaW5zdF0pOyAgLy8gdHJpZ2dlciBjdXN0b20gY2FsbGJhY2tcblx0XHR9IGVsc2UgaWYgKGluc3QuaW5wdXQpIHtcblx0XHRcdGluc3QuaW5wdXQudHJpZ2dlcihcImNoYW5nZVwiKTsgLy8gZmlyZSB0aGUgY2hhbmdlIGV2ZW50XG5cdFx0fVxuXG5cdFx0aWYgKGluc3QuaW5saW5lKXtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHR0aGlzLl9sYXN0SW5wdXQgPSBpbnN0LmlucHV0WzBdO1xuXHRcdFx0aWYgKHR5cGVvZihpbnN0LmlucHV0WzBdKSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHRpbnN0LmlucHV0LmZvY3VzKCk7IC8vIHJlc3RvcmUgZm9jdXNcblx0XHRcdH1cblx0XHRcdHRoaXMuX2xhc3RJbnB1dCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFVwZGF0ZSBhbnkgYWx0ZXJuYXRlIGZpZWxkIHRvIHN5bmNocm9uaXNlIHdpdGggdGhlIG1haW4gZmllbGQuICovXG5cdF91cGRhdGVBbHRlcm5hdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgYWx0Rm9ybWF0LCBkYXRlLCBkYXRlU3RyLFxuXHRcdFx0YWx0RmllbGQgPSB0aGlzLl9nZXQoaW5zdCwgXCJhbHRGaWVsZFwiKTtcblxuXHRcdGlmIChhbHRGaWVsZCkgeyAvLyB1cGRhdGUgYWx0ZXJuYXRlIGZpZWxkIHRvb1xuXHRcdFx0YWx0Rm9ybWF0ID0gdGhpcy5fZ2V0KGluc3QsIFwiYWx0Rm9ybWF0XCIpIHx8IHRoaXMuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIik7XG5cdFx0XHRkYXRlID0gdGhpcy5fZ2V0RGF0ZShpbnN0KTtcblx0XHRcdGRhdGVTdHIgPSB0aGlzLmZvcm1hdERhdGUoYWx0Rm9ybWF0LCBkYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xuXHRcdFx0JChhbHRGaWVsZCkuZWFjaChmdW5jdGlvbigpIHsgJCh0aGlzKS52YWwoZGF0ZVN0cik7IH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKiBTZXQgYXMgYmVmb3JlU2hvd0RheSBmdW5jdGlvbiB0byBwcmV2ZW50IHNlbGVjdGlvbiBvZiB3ZWVrZW5kcy5cblx0ICogQHBhcmFtICBkYXRlICBEYXRlIC0gdGhlIGRhdGUgdG8gY3VzdG9taXNlXG5cdCAqIEByZXR1cm4gW2Jvb2xlYW4sIHN0cmluZ10gLSBpcyB0aGlzIGRhdGUgc2VsZWN0YWJsZT8sIHdoYXQgaXMgaXRzIENTUyBjbGFzcz9cblx0ICovXG5cdG5vV2Vla2VuZHM6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcblx0XHRyZXR1cm4gWyhkYXkgPiAwICYmIGRheSA8IDYpLCBcIlwiXTtcblx0fSxcblxuXHQvKiBTZXQgYXMgY2FsY3VsYXRlV2VlayB0byBkZXRlcm1pbmUgdGhlIHdlZWsgb2YgdGhlIHllYXIgYmFzZWQgb24gdGhlIElTTyA4NjAxIGRlZmluaXRpb24uXG5cdCAqIEBwYXJhbSAgZGF0ZSAgRGF0ZSAtIHRoZSBkYXRlIHRvIGdldCB0aGUgd2VlayBmb3Jcblx0ICogQHJldHVybiAgbnVtYmVyIC0gdGhlIG51bWJlciBvZiB0aGUgd2VlayB3aXRoaW4gdGhlIHllYXIgdGhhdCBjb250YWlucyB0aGlzIGRhdGVcblx0ICovXG5cdGlzbzg2MDFXZWVrOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIHRpbWUsXG5cdFx0XHRjaGVja0RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG5cblx0XHQvLyBGaW5kIFRodXJzZGF5IG9mIHRoaXMgd2VlayBzdGFydGluZyBvbiBNb25kYXlcblx0XHRjaGVja0RhdGUuc2V0RGF0ZShjaGVja0RhdGUuZ2V0RGF0ZSgpICsgNCAtIChjaGVja0RhdGUuZ2V0RGF5KCkgfHwgNykpO1xuXG5cdFx0dGltZSA9IGNoZWNrRGF0ZS5nZXRUaW1lKCk7XG5cdFx0Y2hlY2tEYXRlLnNldE1vbnRoKDApOyAvLyBDb21wYXJlIHdpdGggSmFuIDFcblx0XHRjaGVja0RhdGUuc2V0RGF0ZSgxKTtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJvdW5kKCh0aW1lIC0gY2hlY2tEYXRlKSAvIDg2NDAwMDAwKSAvIDcpICsgMTtcblx0fSxcblxuXHQvKiBQYXJzZSBhIHN0cmluZyB2YWx1ZSBpbnRvIGEgZGF0ZSBvYmplY3QuXG5cdCAqIFNlZSBmb3JtYXREYXRlIGJlbG93IGZvciB0aGUgcG9zc2libGUgZm9ybWF0cy5cblx0ICpcblx0ICogQHBhcmFtICBmb3JtYXQgc3RyaW5nIC0gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgZGF0ZVxuXHQgKiBAcGFyYW0gIHZhbHVlIHN0cmluZyAtIHRoZSBkYXRlIGluIHRoZSBhYm92ZSBmb3JtYXRcblx0ICogQHBhcmFtICBzZXR0aW5ncyBPYmplY3QgLSBhdHRyaWJ1dGVzIGluY2x1ZGU6XG5cdCAqXHRcdFx0XHRcdHNob3J0WWVhckN1dG9mZiAgbnVtYmVyIC0gdGhlIGN1dG9mZiB5ZWFyIGZvciBkZXRlcm1pbmluZyB0aGUgY2VudHVyeSAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdGRheU5hbWVzU2hvcnRcdHN0cmluZ1s3XSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNcdFx0c3RyaW5nWzddIC0gbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzU2hvcnQgc3RyaW5nWzEyXSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzXHRcdHN0cmluZ1sxMl0gLSBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICogQHJldHVybiAgRGF0ZSAtIHRoZSBleHRyYWN0ZWQgZGF0ZSB2YWx1ZSBvciBudWxsIGlmIHZhbHVlIGlzIGJsYW5rXG5cdCAqL1xuXHRwYXJzZURhdGU6IGZ1bmN0aW9uIChmb3JtYXQsIHZhbHVlLCBzZXR0aW5ncykge1xuXHRcdGlmIChmb3JtYXQgPT0gbnVsbCB8fCB2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBcIkludmFsaWQgYXJndW1lbnRzXCI7XG5cdFx0fVxuXG5cdFx0dmFsdWUgPSAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlICsgXCJcIik7XG5cdFx0aWYgKHZhbHVlID09PSBcIlwiKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgaUZvcm1hdCwgZGltLCBleHRyYSxcblx0XHRcdGlWYWx1ZSA9IDAsXG5cdFx0XHRzaG9ydFllYXJDdXRvZmZUZW1wID0gKHNldHRpbmdzID8gc2V0dGluZ3Muc2hvcnRZZWFyQ3V0b2ZmIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuc2hvcnRZZWFyQ3V0b2ZmLFxuXHRcdFx0c2hvcnRZZWFyQ3V0b2ZmID0gKHR5cGVvZiBzaG9ydFllYXJDdXRvZmZUZW1wICE9PSBcInN0cmluZ1wiID8gc2hvcnRZZWFyQ3V0b2ZmVGVtcCA6XG5cdFx0XHRcdG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArIHBhcnNlSW50KHNob3J0WWVhckN1dG9mZlRlbXAsIDEwKSksXG5cdFx0XHRkYXlOYW1lc1Nob3J0ID0gKHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzU2hvcnQsXG5cdFx0XHRkYXlOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXMsXG5cdFx0XHRtb250aE5hbWVzU2hvcnQgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzU2hvcnQsXG5cdFx0XHRtb250aE5hbWVzID0gKHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lcyA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXMsXG5cdFx0XHR5ZWFyID0gLTEsXG5cdFx0XHRtb250aCA9IC0xLFxuXHRcdFx0ZGF5ID0gLTEsXG5cdFx0XHRkb3kgPSAtMSxcblx0XHRcdGxpdGVyYWwgPSBmYWxzZSxcblx0XHRcdGRhdGUsXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0XHRsb29rQWhlYWQgPSBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9IChpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgMSkgPT09IG1hdGNoKTtcblx0XHRcdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdFx0XHRpRm9ybWF0Kys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gRXh0cmFjdCBhIG51bWJlciBmcm9tIHRoZSBzdHJpbmcgdmFsdWVcblx0XHRcdGdldE51bWJlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdHZhciBpc0RvdWJsZWQgPSBsb29rQWhlYWQobWF0Y2gpLFxuXHRcdFx0XHRcdHNpemUgPSAobWF0Y2ggPT09IFwiQFwiID8gMTQgOiAobWF0Y2ggPT09IFwiIVwiID8gMjAgOlxuXHRcdFx0XHRcdChtYXRjaCA9PT0gXCJ5XCIgJiYgaXNEb3VibGVkID8gNCA6IChtYXRjaCA9PT0gXCJvXCIgPyAzIDogMikpKSksXG5cdFx0XHRcdFx0ZGlnaXRzID0gbmV3IFJlZ0V4cChcIl5cXFxcZHsxLFwiICsgc2l6ZSArIFwifVwiKSxcblx0XHRcdFx0XHRudW0gPSB2YWx1ZS5zdWJzdHJpbmcoaVZhbHVlKS5tYXRjaChkaWdpdHMpO1xuXHRcdFx0XHRpZiAoIW51bSkge1xuXHRcdFx0XHRcdHRocm93IFwiTWlzc2luZyBudW1iZXIgYXQgcG9zaXRpb24gXCIgKyBpVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aVZhbHVlICs9IG51bVswXS5sZW5ndGg7XG5cdFx0XHRcdHJldHVybiBwYXJzZUludChudW1bMF0sIDEwKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBFeHRyYWN0IGEgbmFtZSBmcm9tIHRoZSBzdHJpbmcgdmFsdWUgYW5kIGNvbnZlcnQgdG8gYW4gaW5kZXhcblx0XHRcdGdldE5hbWUgPSBmdW5jdGlvbihtYXRjaCwgc2hvcnROYW1lcywgbG9uZ05hbWVzKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IC0xLFxuXHRcdFx0XHRcdG5hbWVzID0gJC5tYXAobG9va0FoZWFkKG1hdGNoKSA/IGxvbmdOYW1lcyA6IHNob3J0TmFtZXMsIGZ1bmN0aW9uICh2LCBrKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBbaywgdl0gXTtcblx0XHRcdFx0XHR9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gLShhWzFdLmxlbmd0aCAtIGJbMV0ubGVuZ3RoKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHQkLmVhY2gobmFtZXMsIGZ1bmN0aW9uIChpLCBwYWlyKSB7XG5cdFx0XHRcdFx0dmFyIG5hbWUgPSBwYWlyWzFdO1xuXHRcdFx0XHRcdGlmICh2YWx1ZS5zdWJzdHIoaVZhbHVlLCBuYW1lLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHBhaXJbMF07XG5cdFx0XHRcdFx0XHRpVmFsdWUgKz0gbmFtZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdHJldHVybiBpbmRleCArIDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgXCJVbmtub3duIG5hbWUgYXQgcG9zaXRpb24gXCIgKyBpVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyBDb25maXJtIHRoYXQgYSBsaXRlcmFsIGNoYXJhY3RlciBtYXRjaGVzIHRoZSBzdHJpbmcgdmFsdWVcblx0XHRcdGNoZWNrTGl0ZXJhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodmFsdWUuY2hhckF0KGlWYWx1ZSkgIT09IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHR0aHJvdyBcIlVuZXhwZWN0ZWQgbGl0ZXJhbCBhdCBwb3NpdGlvbiBcIiArIGlWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpVmFsdWUrKztcblx0XHRcdH07XG5cblx0XHRmb3IgKGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XG5cdFx0XHRpZiAobGl0ZXJhbCkge1xuXHRcdFx0XHRpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PT0gXCInXCIgJiYgIWxvb2tBaGVhZChcIidcIikpIHtcblx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdGNhc2UgXCJkXCI6XG5cdFx0XHRcdFx0XHRkYXkgPSBnZXROdW1iZXIoXCJkXCIpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIkRcIjpcblx0XHRcdFx0XHRcdGdldE5hbWUoXCJEXCIsIGRheU5hbWVzU2hvcnQsIGRheU5hbWVzKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJvXCI6XG5cdFx0XHRcdFx0XHRkb3kgPSBnZXROdW1iZXIoXCJvXCIpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIm1cIjpcblx0XHRcdFx0XHRcdG1vbnRoID0gZ2V0TnVtYmVyKFwibVwiKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRcdFx0XHRtb250aCA9IGdldE5hbWUoXCJNXCIsIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwieVwiOlxuXHRcdFx0XHRcdFx0eWVhciA9IGdldE51bWJlcihcInlcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiQFwiOlxuXHRcdFx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKGdldE51bWJlcihcIkBcIikpO1xuXHRcdFx0XHRcdFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcblx0XHRcdFx0XHRcdGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIiFcIjpcblx0XHRcdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSgoZ2V0TnVtYmVyKFwiIVwiKSAtIHRoaXMuX3RpY2tzVG8xOTcwKSAvIDEwMDAwKTtcblx0XHRcdFx0XHRcdHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdFx0XHRtb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG5cdFx0XHRcdFx0XHRkYXkgPSBkYXRlLmdldERhdGUoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRpZiAobG9va0FoZWFkKFwiJ1wiKSl7XG5cdFx0XHRcdFx0XHRcdGNoZWNrTGl0ZXJhbCgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaVZhbHVlIDwgdmFsdWUubGVuZ3RoKXtcblx0XHRcdGV4dHJhID0gdmFsdWUuc3Vic3RyKGlWYWx1ZSk7XG5cdFx0XHRpZiAoIS9eXFxzKy8udGVzdChleHRyYSkpIHtcblx0XHRcdFx0dGhyb3cgXCJFeHRyYS91bnBhcnNlZCBjaGFyYWN0ZXJzIGZvdW5kIGluIGRhdGU6IFwiICsgZXh0cmE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHllYXIgPT09IC0xKSB7XG5cdFx0XHR5ZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdH0gZWxzZSBpZiAoeWVhciA8IDEwMCkge1xuXHRcdFx0eWVhciArPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgLSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgK1xuXHRcdFx0XHQoeWVhciA8PSBzaG9ydFllYXJDdXRvZmYgPyAwIDogLTEwMCk7XG5cdFx0fVxuXG5cdFx0aWYgKGRveSA+IC0xKSB7XG5cdFx0XHRtb250aCA9IDE7XG5cdFx0XHRkYXkgPSBkb3k7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGRpbSA9IHRoaXMuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoIC0gMSk7XG5cdFx0XHRcdGlmIChkYXkgPD0gZGltKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bW9udGgrKztcblx0XHRcdFx0ZGF5IC09IGRpbTtcblx0XHRcdH0gd2hpbGUgKHRydWUpO1xuXHRcdH1cblxuXHRcdGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSkpO1xuXHRcdGlmIChkYXRlLmdldEZ1bGxZZWFyKCkgIT09IHllYXIgfHwgZGF0ZS5nZXRNb250aCgpICsgMSAhPT0gbW9udGggfHwgZGF0ZS5nZXREYXRlKCkgIT09IGRheSkge1xuXHRcdFx0dGhyb3cgXCJJbnZhbGlkIGRhdGVcIjsgLy8gRS5nLiAzMS8wMi8wMFxuXHRcdH1cblx0XHRyZXR1cm4gZGF0ZTtcblx0fSxcblxuXHQvKiBTdGFuZGFyZCBkYXRlIGZvcm1hdHMuICovXG5cdEFUT006IFwieXktbW0tZGRcIiwgLy8gUkZDIDMzMzkgKElTTyA4NjAxKVxuXHRDT09LSUU6IFwiRCwgZGQgTSB5eVwiLFxuXHRJU09fODYwMTogXCJ5eS1tbS1kZFwiLFxuXHRSRkNfODIyOiBcIkQsIGQgTSB5XCIsXG5cdFJGQ184NTA6IFwiREQsIGRkLU0teVwiLFxuXHRSRkNfMTAzNjogXCJELCBkIE0geVwiLFxuXHRSRkNfMTEyMzogXCJELCBkIE0geXlcIixcblx0UkZDXzI4MjI6IFwiRCwgZCBNIHl5XCIsXG5cdFJTUzogXCJELCBkIE0geVwiLCAvLyBSRkMgODIyXG5cdFRJQ0tTOiBcIiFcIixcblx0VElNRVNUQU1QOiBcIkBcIixcblx0VzNDOiBcInl5LW1tLWRkXCIsIC8vIElTTyA4NjAxXG5cblx0X3RpY2tzVG8xOTcwOiAoKCgxOTcwIC0gMSkgKiAzNjUgKyBNYXRoLmZsb29yKDE5NzAgLyA0KSAtIE1hdGguZmxvb3IoMTk3MCAvIDEwMCkgK1xuXHRcdE1hdGguZmxvb3IoMTk3MCAvIDQwMCkpICogMjQgKiA2MCAqIDYwICogMTAwMDAwMDApLFxuXG5cdC8qIEZvcm1hdCBhIGRhdGUgb2JqZWN0IGludG8gYSBzdHJpbmcgdmFsdWUuXG5cdCAqIFRoZSBmb3JtYXQgY2FuIGJlIGNvbWJpbmF0aW9ucyBvZiB0aGUgZm9sbG93aW5nOlxuXHQgKiBkICAtIGRheSBvZiBtb250aCAobm8gbGVhZGluZyB6ZXJvKVxuXHQgKiBkZCAtIGRheSBvZiBtb250aCAodHdvIGRpZ2l0KVxuXHQgKiBvICAtIGRheSBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm9zKVxuXHQgKiBvbyAtIGRheSBvZiB5ZWFyICh0aHJlZSBkaWdpdClcblx0ICogRCAgLSBkYXkgbmFtZSBzaG9ydFxuXHQgKiBERCAtIGRheSBuYW1lIGxvbmdcblx0ICogbSAgLSBtb250aCBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm8pXG5cdCAqIG1tIC0gbW9udGggb2YgeWVhciAodHdvIGRpZ2l0KVxuXHQgKiBNICAtIG1vbnRoIG5hbWUgc2hvcnRcblx0ICogTU0gLSBtb250aCBuYW1lIGxvbmdcblx0ICogeSAgLSB5ZWFyICh0d28gZGlnaXQpXG5cdCAqIHl5IC0geWVhciAoZm91ciBkaWdpdClcblx0ICogQCAtIFVuaXggdGltZXN0YW1wIChtcyBzaW5jZSAwMS8wMS8xOTcwKVxuXHQgKiAhIC0gV2luZG93cyB0aWNrcyAoMTAwbnMgc2luY2UgMDEvMDEvMDAwMSlcblx0ICogXCIuLi5cIiAtIGxpdGVyYWwgdGV4dFxuXHQgKiAnJyAtIHNpbmdsZSBxdW90ZVxuXHQgKlxuXHQgKiBAcGFyYW0gIGZvcm1hdCBzdHJpbmcgLSB0aGUgZGVzaXJlZCBmb3JtYXQgb2YgdGhlIGRhdGVcblx0ICogQHBhcmFtICBkYXRlIERhdGUgLSB0aGUgZGF0ZSB2YWx1ZSB0byBmb3JtYXRcblx0ICogQHBhcmFtICBzZXR0aW5ncyBPYmplY3QgLSBhdHRyaWJ1dGVzIGluY2x1ZGU6XG5cdCAqXHRcdFx0XHRcdGRheU5hbWVzU2hvcnRcdHN0cmluZ1s3XSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNcdFx0c3RyaW5nWzddIC0gbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzU2hvcnQgc3RyaW5nWzEyXSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzXHRcdHN0cmluZ1sxMl0gLSBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICogQHJldHVybiAgc3RyaW5nIC0gdGhlIGRhdGUgaW4gdGhlIGFib3ZlIGZvcm1hdFxuXHQgKi9cblx0Zm9ybWF0RGF0ZTogZnVuY3Rpb24gKGZvcm1hdCwgZGF0ZSwgc2V0dGluZ3MpIHtcblx0XHRpZiAoIWRhdGUpIHtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblxuXHRcdHZhciBpRm9ybWF0LFxuXHRcdFx0ZGF5TmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lc1Nob3J0LFxuXHRcdFx0ZGF5TmFtZXMgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lcyA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzLFxuXHRcdFx0bW9udGhOYW1lc1Nob3J0ID0gKHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lc1Nob3J0IDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMubW9udGhOYW1lc1Nob3J0LFxuXHRcdFx0bW9udGhOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXMgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzLFxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdFx0bG9va0FoZWFkID0gZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXMgPSAoaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoaUZvcm1hdCArIDEpID09PSBtYXRjaCk7XG5cdFx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdFx0aUZvcm1hdCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdFx0fSxcblx0XHRcdC8vIEZvcm1hdCBhIG51bWJlciwgd2l0aCBsZWFkaW5nIHplcm8gaWYgbmVjZXNzYXJ5XG5cdFx0XHRmb3JtYXROdW1iZXIgPSBmdW5jdGlvbihtYXRjaCwgdmFsdWUsIGxlbikge1xuXHRcdFx0XHR2YXIgbnVtID0gXCJcIiArIHZhbHVlO1xuXHRcdFx0XHRpZiAobG9va0FoZWFkKG1hdGNoKSkge1xuXHRcdFx0XHRcdHdoaWxlIChudW0ubGVuZ3RoIDwgbGVuKSB7XG5cdFx0XHRcdFx0XHRudW0gPSBcIjBcIiArIG51bTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bTtcblx0XHRcdH0sXG5cdFx0XHQvLyBGb3JtYXQgYSBuYW1lLCBzaG9ydCBvciBsb25nIGFzIHJlcXVlc3RlZFxuXHRcdFx0Zm9ybWF0TmFtZSA9IGZ1bmN0aW9uKG1hdGNoLCB2YWx1ZSwgc2hvcnROYW1lcywgbG9uZ05hbWVzKSB7XG5cdFx0XHRcdHJldHVybiAobG9va0FoZWFkKG1hdGNoKSA/IGxvbmdOYW1lc1t2YWx1ZV0gOiBzaG9ydE5hbWVzW3ZhbHVlXSk7XG5cdFx0XHR9LFxuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblxuXHRcdGlmIChkYXRlKSB7XG5cdFx0XHRmb3IgKGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XG5cdFx0XHRcdGlmIChsaXRlcmFsKSB7XG5cdFx0XHRcdFx0aWYgKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkgPT09IFwiJ1wiICYmICFsb29rQWhlYWQoXCInXCIpKSB7XG5cdFx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzd2l0Y2ggKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHRcdGNhc2UgXCJkXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoXCJkXCIsIGRhdGUuZ2V0RGF0ZSgpLCAyKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiRFwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0TmFtZShcIkRcIiwgZGF0ZS5nZXREYXkoKSwgZGF5TmFtZXNTaG9ydCwgZGF5TmFtZXMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJvXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoXCJvXCIsXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5yb3VuZCgobmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDApLmdldFRpbWUoKSkgLyA4NjQwMDAwMCksIDMpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJtXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoXCJtXCIsIGRhdGUuZ2V0TW9udGgoKSArIDEsIDIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROYW1lKFwiTVwiLCBkYXRlLmdldE1vbnRoKCksIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcInlcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IChsb29rQWhlYWQoXCJ5XCIpID8gZGF0ZS5nZXRGdWxsWWVhcigpIDpcblx0XHRcdFx0XHRcdFx0XHQoZGF0ZS5nZXRZZWFyKCkgJSAxMDAgPCAxMCA/IFwiMFwiIDogXCJcIikgKyBkYXRlLmdldFllYXIoKSAlIDEwMCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIkBcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGRhdGUuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCIhXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBkYXRlLmdldFRpbWUoKSAqIDEwMDAwICsgdGhpcy5fdGlja3NUbzE5NzA7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdFx0aWYgKGxvb2tBaGVhZChcIidcIikpIHtcblx0XHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gXCInXCI7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fSxcblxuXHQvKiBFeHRyYWN0IGFsbCBwb3NzaWJsZSBjaGFyYWN0ZXJzIGZyb20gdGhlIGRhdGUgZm9ybWF0LiAqL1xuXHRfcG9zc2libGVDaGFyczogZnVuY3Rpb24gKGZvcm1hdCkge1xuXHRcdHZhciBpRm9ybWF0LFxuXHRcdFx0Y2hhcnMgPSBcIlwiLFxuXHRcdFx0bGl0ZXJhbCA9IGZhbHNlLFxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdFx0bG9va0FoZWFkID0gZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXMgPSAoaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoaUZvcm1hdCArIDEpID09PSBtYXRjaCk7XG5cdFx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdFx0aUZvcm1hdCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdFx0fTtcblxuXHRcdGZvciAoaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcblx0XHRcdGlmIChsaXRlcmFsKSB7XG5cdFx0XHRcdGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09PSBcIidcIiAmJiAhbG9va0FoZWFkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGFycyArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzd2l0Y2ggKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcblx0XHRcdFx0XHRjYXNlIFwiZFwiOiBjYXNlIFwibVwiOiBjYXNlIFwieVwiOiBjYXNlIFwiQFwiOlxuXHRcdFx0XHRcdFx0Y2hhcnMgKz0gXCIwMTIzNDU2Nzg5XCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiRFwiOiBjYXNlIFwiTVwiOlxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIEFjY2VwdCBhbnl0aGluZ1xuXHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRpZiAobG9va0FoZWFkKFwiJ1wiKSkge1xuXHRcdFx0XHRcdFx0XHRjaGFycyArPSBcIidcIjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNoYXJzICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNoYXJzO1xuXHR9LFxuXG5cdC8qIEdldCBhIHNldHRpbmcgdmFsdWUsIGRlZmF1bHRpbmcgaWYgbmVjZXNzYXJ5LiAqL1xuXHRfZ2V0OiBmdW5jdGlvbihpbnN0LCBuYW1lKSB7XG5cdFx0cmV0dXJuIGluc3Quc2V0dGluZ3NbbmFtZV0gIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRpbnN0LnNldHRpbmdzW25hbWVdIDogdGhpcy5fZGVmYXVsdHNbbmFtZV07XG5cdH0sXG5cblx0LyogUGFyc2UgZXhpc3RpbmcgZGF0ZSBhbmQgaW5pdGlhbGlzZSBkYXRlIHBpY2tlci4gKi9cblx0X3NldERhdGVGcm9tRmllbGQ6IGZ1bmN0aW9uKGluc3QsIG5vRGVmYXVsdCkge1xuXHRcdGlmIChpbnN0LmlucHV0LnZhbCgpID09PSBpbnN0Lmxhc3RWYWwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZGF0ZUZvcm1hdCA9IHRoaXMuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIiksXG5cdFx0XHRkYXRlcyA9IGluc3QubGFzdFZhbCA9IGluc3QuaW5wdXQgPyBpbnN0LmlucHV0LnZhbCgpIDogbnVsbCxcblx0XHRcdGRlZmF1bHREYXRlID0gdGhpcy5fZ2V0RGVmYXVsdERhdGUoaW5zdCksXG5cdFx0XHRkYXRlID0gZGVmYXVsdERhdGUsXG5cdFx0XHRzZXR0aW5ncyA9IHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRkYXRlID0gdGhpcy5wYXJzZURhdGUoZGF0ZUZvcm1hdCwgZGF0ZXMsIHNldHRpbmdzKSB8fCBkZWZhdWx0RGF0ZTtcblx0XHR9IGNhdGNoIChldmVudCkge1xuXHRcdFx0ZGF0ZXMgPSAobm9EZWZhdWx0ID8gXCJcIiA6IGRhdGVzKTtcblx0XHR9XG5cdFx0aW5zdC5zZWxlY3RlZERheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRpbnN0LmN1cnJlbnREYXkgPSAoZGF0ZXMgPyBkYXRlLmdldERhdGUoKSA6IDApO1xuXHRcdGluc3QuY3VycmVudE1vbnRoID0gKGRhdGVzID8gZGF0ZS5nZXRNb250aCgpIDogMCk7XG5cdFx0aW5zdC5jdXJyZW50WWVhciA9IChkYXRlcyA/IGRhdGUuZ2V0RnVsbFllYXIoKSA6IDApO1xuXHRcdHRoaXMuX2FkanVzdEluc3REYXRlKGluc3QpO1xuXHR9LFxuXG5cdC8qIFJldHJpZXZlIHRoZSBkZWZhdWx0IGRhdGUgc2hvd24gb24gb3BlbmluZy4gKi9cblx0X2dldERlZmF1bHREYXRlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Jlc3RyaWN0TWluTWF4KGluc3QsXG5cdFx0XHR0aGlzLl9kZXRlcm1pbmVEYXRlKGluc3QsIHRoaXMuX2dldChpbnN0LCBcImRlZmF1bHREYXRlXCIpLCBuZXcgRGF0ZSgpKSk7XG5cdH0sXG5cblx0LyogQSBkYXRlIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gZXhhY3QgdmFsdWUgb3IgYSByZWxhdGl2ZSBvbmUuICovXG5cdF9kZXRlcm1pbmVEYXRlOiBmdW5jdGlvbihpbnN0LCBkYXRlLCBkZWZhdWx0RGF0ZSkge1xuXHRcdHZhciBvZmZzZXROdW1lcmljID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHRcdHZhciBkYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdFx0ZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgb2Zmc2V0KTtcblx0XHRcdFx0cmV0dXJuIGRhdGU7XG5cdFx0XHR9LFxuXHRcdFx0b2Zmc2V0U3RyaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZGF0ZXBpY2tlci5wYXJzZURhdGUoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXCJkYXRlRm9ybWF0XCIpLFxuXHRcdFx0XHRcdFx0b2Zmc2V0LCAkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHQvLyBJZ25vcmVcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkYXRlID0gKG9mZnNldC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9eYy8pID9cblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2dldERhdGUoaW5zdCkgOiBudWxsKSB8fCBuZXcgRGF0ZSgpLFxuXHRcdFx0XHRcdHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCksXG5cdFx0XHRcdFx0bW9udGggPSBkYXRlLmdldE1vbnRoKCksXG5cdFx0XHRcdFx0ZGF5ID0gZGF0ZS5nZXREYXRlKCksXG5cdFx0XHRcdFx0cGF0dGVybiA9IC8oWytcXC1dP1swLTldKylcXHMqKGR8RHx3fFd8bXxNfHl8WSk/L2csXG5cdFx0XHRcdFx0bWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xuXG5cdFx0XHRcdHdoaWxlIChtYXRjaGVzKSB7XG5cdFx0XHRcdFx0c3dpdGNoIChtYXRjaGVzWzJdIHx8IFwiZFwiKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFwiZFwiIDogY2FzZSBcIkRcIiA6XG5cdFx0XHRcdFx0XHRcdGRheSArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwid1wiIDogY2FzZSBcIldcIiA6XG5cdFx0XHRcdFx0XHRcdGRheSArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKSAqIDc7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIm1cIiA6IGNhc2UgXCJNXCIgOlxuXHRcdFx0XHRcdFx0XHRtb250aCArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKTtcblx0XHRcdFx0XHRcdFx0ZGF5ID0gTWF0aC5taW4oZGF5LCAkLmRhdGVwaWNrZXIuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcInlcIjogY2FzZSBcIllcIiA6XG5cdFx0XHRcdFx0XHRcdHllYXIgKz0gcGFyc2VJbnQobWF0Y2hlc1sxXSwxMCk7XG5cdFx0XHRcdFx0XHRcdGRheSA9IE1hdGgubWluKGRheSwgJC5kYXRlcGlja2VyLl9nZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcblx0XHRcdH0sXG5cdFx0XHRuZXdEYXRlID0gKGRhdGUgPT0gbnVsbCB8fCBkYXRlID09PSBcIlwiID8gZGVmYXVsdERhdGUgOiAodHlwZW9mIGRhdGUgPT09IFwic3RyaW5nXCIgPyBvZmZzZXRTdHJpbmcoZGF0ZSkgOlxuXHRcdFx0XHQodHlwZW9mIGRhdGUgPT09IFwibnVtYmVyXCIgPyAoaXNOYU4oZGF0ZSkgPyBkZWZhdWx0RGF0ZSA6IG9mZnNldE51bWVyaWMoZGF0ZSkpIDogbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpKSkpO1xuXG5cdFx0bmV3RGF0ZSA9IChuZXdEYXRlICYmIG5ld0RhdGUudG9TdHJpbmcoKSA9PT0gXCJJbnZhbGlkIERhdGVcIiA/IGRlZmF1bHREYXRlIDogbmV3RGF0ZSk7XG5cdFx0aWYgKG5ld0RhdGUpIHtcblx0XHRcdG5ld0RhdGUuc2V0SG91cnMoMCk7XG5cdFx0XHRuZXdEYXRlLnNldE1pbnV0ZXMoMCk7XG5cdFx0XHRuZXdEYXRlLnNldFNlY29uZHMoMCk7XG5cdFx0XHRuZXdEYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ld0RhdGUpO1xuXHR9LFxuXG5cdC8qIEhhbmRsZSBzd2l0Y2ggdG8vZnJvbSBkYXlsaWdodCBzYXZpbmcuXG5cdCAqIEhvdXJzIG1heSBiZSBub24temVybyBvbiBkYXlsaWdodCBzYXZpbmcgY3V0LW92ZXI6XG5cdCAqID4gMTIgd2hlbiBtaWRuaWdodCBjaGFuZ2VvdmVyLCBidXQgdGhlbiBjYW5ub3QgZ2VuZXJhdGVcblx0ICogbWlkbmlnaHQgZGF0ZXRpbWUsIHNvIGp1bXAgdG8gMUFNLCBvdGhlcndpc2UgcmVzZXQuXG5cdCAqIEBwYXJhbSAgZGF0ZSAgKERhdGUpIHRoZSBkYXRlIHRvIGNoZWNrXG5cdCAqIEByZXR1cm4gIChEYXRlKSB0aGUgY29ycmVjdGVkIGRhdGVcblx0ICovXG5cdF9kYXlsaWdodFNhdmluZ0FkanVzdDogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdGlmICghZGF0ZSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGRhdGUuc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpID4gMTIgPyBkYXRlLmdldEhvdXJzKCkgKyAyIDogMCk7XG5cdFx0cmV0dXJuIGRhdGU7XG5cdH0sXG5cblx0LyogU2V0IHRoZSBkYXRlKHMpIGRpcmVjdGx5LiAqL1xuXHRfc2V0RGF0ZTogZnVuY3Rpb24oaW5zdCwgZGF0ZSwgbm9DaGFuZ2UpIHtcblx0XHR2YXIgY2xlYXIgPSAhZGF0ZSxcblx0XHRcdG9yaWdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCxcblx0XHRcdG9yaWdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIsXG5cdFx0XHRuZXdEYXRlID0gdGhpcy5fcmVzdHJpY3RNaW5NYXgoaW5zdCwgdGhpcy5fZGV0ZXJtaW5lRGF0ZShpbnN0LCBkYXRlLCBuZXcgRGF0ZSgpKSk7XG5cblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5ID0gbmV3RGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBpbnN0LmN1cnJlbnRNb250aCA9IG5ld0RhdGUuZ2V0TW9udGgoKTtcblx0XHRpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBpbnN0LmN1cnJlbnRZZWFyID0gbmV3RGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGlmICgob3JpZ01vbnRoICE9PSBpbnN0LnNlbGVjdGVkTW9udGggfHwgb3JpZ1llYXIgIT09IGluc3Quc2VsZWN0ZWRZZWFyKSAmJiAhbm9DaGFuZ2UpIHtcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcblx0XHR9XG5cdFx0dGhpcy5fYWRqdXN0SW5zdERhdGUoaW5zdCk7XG5cdFx0aWYgKGluc3QuaW5wdXQpIHtcblx0XHRcdGluc3QuaW5wdXQudmFsKGNsZWFyID8gXCJcIiA6IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCkpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBSZXRyaWV2ZSB0aGUgZGF0ZShzKSBkaXJlY3RseS4gKi9cblx0X2dldERhdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgc3RhcnREYXRlID0gKCFpbnN0LmN1cnJlbnRZZWFyIHx8IChpbnN0LmlucHV0ICYmIGluc3QuaW5wdXQudmFsKCkgPT09IFwiXCIpID8gbnVsbCA6XG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShcblx0XHRcdGluc3QuY3VycmVudFllYXIsIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnREYXkpKSk7XG5cdFx0XHRyZXR1cm4gc3RhcnREYXRlO1xuXHR9LFxuXG5cdC8qIEF0dGFjaCB0aGUgb254eHggaGFuZGxlcnMuICBUaGVzZSBhcmUgZGVjbGFyZWQgc3RhdGljYWxseSBzb1xuXHQgKiB0aGV5IHdvcmsgd2l0aCBzdGF0aWMgY29kZSB0cmFuc2Zvcm1lcnMgbGlrZSBDYWphLlxuXHQgKi9cblx0X2F0dGFjaEhhbmRsZXJzOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIHN0ZXBNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgXCJzdGVwTW9udGhzXCIpLFxuXHRcdFx0aWQgPSBcIiNcIiArIGluc3QuaWQucmVwbGFjZSggL1xcXFxcXFxcL2csIFwiXFxcXFwiICk7XG5cdFx0aW5zdC5kcERpdi5maW5kKFwiW2RhdGEtaGFuZGxlcl1cIikubWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBoYW5kbGVyID0ge1xuXHRcdFx0XHRwcmV2OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGlkLCAtc3RlcE1vbnRocywgXCJNXCIpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGlkLCArc3RlcE1vbnRocywgXCJNXCIpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRoaWRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0b2RheTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ290b1RvZGF5KGlkKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0RGF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZWxlY3REYXkoaWQsICt0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtbW9udGhcIiksICt0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEteWVhclwiKSwgdGhpcyk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RNb250aDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2VsZWN0TW9udGhZZWFyKGlkLCB0aGlzLCBcIk1cIik7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RZZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZWxlY3RNb250aFllYXIoaWQsIHRoaXMsIFwiWVwiKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHQkKHRoaXMpLmJpbmQodGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWV2ZW50XCIpLCBoYW5kbGVyW3RoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1oYW5kbGVyXCIpXSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyogR2VuZXJhdGUgdGhlIEhUTUwgZm9yIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBkYXRlIHBpY2tlci4gKi9cblx0X2dlbmVyYXRlSFRNTDogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBtYXhEcmF3LCBwcmV2VGV4dCwgcHJldiwgbmV4dFRleHQsIG5leHQsIGN1cnJlbnRUZXh0LCBnb3RvRGF0ZSxcblx0XHRcdGNvbnRyb2xzLCBidXR0b25QYW5lbCwgZmlyc3REYXksIHNob3dXZWVrLCBkYXlOYW1lcywgZGF5TmFtZXNNaW4sXG5cdFx0XHRtb250aE5hbWVzLCBtb250aE5hbWVzU2hvcnQsIGJlZm9yZVNob3dEYXksIHNob3dPdGhlck1vbnRocyxcblx0XHRcdHNlbGVjdE90aGVyTW9udGhzLCBkZWZhdWx0RGF0ZSwgaHRtbCwgZG93LCByb3csIGdyb3VwLCBjb2wsIHNlbGVjdGVkRGF0ZSxcblx0XHRcdGNvcm5lckNsYXNzLCBjYWxlbmRlciwgdGhlYWQsIGRheSwgZGF5c0luTW9udGgsIGxlYWREYXlzLCBjdXJSb3dzLCBudW1Sb3dzLFxuXHRcdFx0cHJpbnREYXRlLCBkUm93LCB0Ym9keSwgZGF5U2V0dGluZ3MsIG90aGVyTW9udGgsIHVuc2VsZWN0YWJsZSxcblx0XHRcdHRlbXBEYXRlID0gbmV3IERhdGUoKSxcblx0XHRcdHRvZGF5ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoXG5cdFx0XHRcdG5ldyBEYXRlKHRlbXBEYXRlLmdldEZ1bGxZZWFyKCksIHRlbXBEYXRlLmdldE1vbnRoKCksIHRlbXBEYXRlLmdldERhdGUoKSkpLCAvLyBjbGVhciB0aW1lXG5cdFx0XHRpc1JUTCA9IHRoaXMuX2dldChpbnN0LCBcImlzUlRMXCIpLFxuXHRcdFx0c2hvd0J1dHRvblBhbmVsID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd0J1dHRvblBhbmVsXCIpLFxuXHRcdFx0aGlkZUlmTm9QcmV2TmV4dCA9IHRoaXMuX2dldChpbnN0LCBcImhpZGVJZk5vUHJldk5leHRcIiksXG5cdFx0XHRuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KGluc3QsIFwibmF2aWdhdGlvbkFzRGF0ZUZvcm1hdFwiKSxcblx0XHRcdG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKGluc3QpLFxuXHRcdFx0c2hvd0N1cnJlbnRBdFBvcyA9IHRoaXMuX2dldChpbnN0LCBcInNob3dDdXJyZW50QXRQb3NcIiksXG5cdFx0XHRzdGVwTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFwic3RlcE1vbnRoc1wiKSxcblx0XHRcdGlzTXVsdGlNb250aCA9IChudW1Nb250aHNbMF0gIT09IDEgfHwgbnVtTW9udGhzWzFdICE9PSAxKSxcblx0XHRcdGN1cnJlbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoKCFpbnN0LmN1cnJlbnREYXkgPyBuZXcgRGF0ZSg5OTk5LCA5LCA5KSA6XG5cdFx0XHRcdG5ldyBEYXRlKGluc3QuY3VycmVudFllYXIsIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnREYXkpKSksXG5cdFx0XHRtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1pblwiKSxcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWF4XCIpLFxuXHRcdFx0ZHJhd01vbnRoID0gaW5zdC5kcmF3TW9udGggLSBzaG93Q3VycmVudEF0UG9zLFxuXHRcdFx0ZHJhd1llYXIgPSBpbnN0LmRyYXdZZWFyO1xuXG5cdFx0aWYgKGRyYXdNb250aCA8IDApIHtcblx0XHRcdGRyYXdNb250aCArPSAxMjtcblx0XHRcdGRyYXdZZWFyLS07XG5cdFx0fVxuXHRcdGlmIChtYXhEYXRlKSB7XG5cdFx0XHRtYXhEcmF3ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUobWF4RGF0ZS5nZXRGdWxsWWVhcigpLFxuXHRcdFx0XHRtYXhEYXRlLmdldE1vbnRoKCkgLSAobnVtTW9udGhzWzBdICogbnVtTW9udGhzWzFdKSArIDEsIG1heERhdGUuZ2V0RGF0ZSgpKSk7XG5cdFx0XHRtYXhEcmF3ID0gKG1pbkRhdGUgJiYgbWF4RHJhdyA8IG1pbkRhdGUgPyBtaW5EYXRlIDogbWF4RHJhdyk7XG5cdFx0XHR3aGlsZSAodGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgMSkpID4gbWF4RHJhdykge1xuXHRcdFx0XHRkcmF3TW9udGgtLTtcblx0XHRcdFx0aWYgKGRyYXdNb250aCA8IDApIHtcblx0XHRcdFx0XHRkcmF3TW9udGggPSAxMTtcblx0XHRcdFx0XHRkcmF3WWVhci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGluc3QuZHJhd01vbnRoID0gZHJhd01vbnRoO1xuXHRcdGluc3QuZHJhd1llYXIgPSBkcmF3WWVhcjtcblxuXHRcdHByZXZUZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwicHJldlRleHRcIik7XG5cdFx0cHJldlRleHQgPSAoIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBwcmV2VGV4dCA6IHRoaXMuZm9ybWF0RGF0ZShwcmV2VGV4dCxcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGggLSBzdGVwTW9udGhzLCAxKSksXG5cdFx0XHR0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpKTtcblxuXHRcdHByZXYgPSAodGhpcy5fY2FuQWRqdXN0TW9udGgoaW5zdCwgLTEsIGRyYXdZZWFyLCBkcmF3TW9udGgpID9cblx0XHRcdFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItcHJldiB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J3ByZXYnIGRhdGEtZXZlbnQ9J2NsaWNrJ1wiICtcblx0XHRcdFwiIHRpdGxlPSdcIiArIHByZXZUZXh0ICsgXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwiZVwiIDogXCJ3XCIpICsgXCInPlwiICsgcHJldlRleHQgKyBcIjwvc3Bhbj48L2E+XCIgOlxuXHRcdFx0KGhpZGVJZk5vUHJldk5leHQgPyBcIlwiIDogXCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1wcmV2IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGlzYWJsZWQnIHRpdGxlPSdcIisgcHJldlRleHQgK1wiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cIiArICggaXNSVEwgPyBcImVcIiA6IFwid1wiKSArIFwiJz5cIiArIHByZXZUZXh0ICsgXCI8L3NwYW4+PC9hPlwiKSk7XG5cblx0XHRuZXh0VGV4dCA9IHRoaXMuX2dldChpbnN0LCBcIm5leHRUZXh0XCIpO1xuXHRcdG5leHRUZXh0ID0gKCFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gbmV4dFRleHQgOiB0aGlzLmZvcm1hdERhdGUobmV4dFRleHQsXG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShkcmF3WWVhciwgZHJhd01vbnRoICsgc3RlcE1vbnRocywgMSkpLFxuXHRcdFx0dGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKSk7XG5cblx0XHRuZXh0ID0gKHRoaXMuX2NhbkFkanVzdE1vbnRoKGluc3QsICsxLCBkcmF3WWVhciwgZHJhd01vbnRoKSA/XG5cdFx0XHRcIjxhIGNsYXNzPSd1aS1kYXRlcGlja2VyLW5leHQgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSduZXh0JyBkYXRhLWV2ZW50PSdjbGljaydcIiArXG5cdFx0XHRcIiB0aXRsZT0nXCIgKyBuZXh0VGV4dCArIFwiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cIiArICggaXNSVEwgPyBcIndcIiA6IFwiZVwiKSArIFwiJz5cIiArIG5leHRUZXh0ICsgXCI8L3NwYW4+PC9hPlwiIDpcblx0XHRcdChoaWRlSWZOb1ByZXZOZXh0ID8gXCJcIiA6IFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItbmV4dCB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWRpc2FibGVkJyB0aXRsZT0nXCIrIG5leHRUZXh0ICsgXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwid1wiIDogXCJlXCIpICsgXCInPlwiICsgbmV4dFRleHQgKyBcIjwvc3Bhbj48L2E+XCIpKTtcblxuXHRcdGN1cnJlbnRUZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFwiY3VycmVudFRleHRcIik7XG5cdFx0Z290b0RhdGUgPSAodGhpcy5fZ2V0KGluc3QsIFwiZ290b0N1cnJlbnRcIikgJiYgaW5zdC5jdXJyZW50RGF5ID8gY3VycmVudERhdGUgOiB0b2RheSk7XG5cdFx0Y3VycmVudFRleHQgPSAoIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBjdXJyZW50VGV4dCA6XG5cdFx0XHR0aGlzLmZvcm1hdERhdGUoY3VycmVudFRleHQsIGdvdG9EYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpKTtcblxuXHRcdGNvbnRyb2xzID0gKCFpbnN0LmlubGluZSA/IFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSd1aS1kYXRlcGlja2VyLWNsb3NlIHVpLXN0YXRlLWRlZmF1bHQgdWktcHJpb3JpdHktcHJpbWFyeSB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J2hpZGUnIGRhdGEtZXZlbnQ9J2NsaWNrJz5cIiArXG5cdFx0XHR0aGlzLl9nZXQoaW5zdCwgXCJjbG9zZVRleHRcIikgKyBcIjwvYnV0dG9uPlwiIDogXCJcIik7XG5cblx0XHRidXR0b25QYW5lbCA9IChzaG93QnV0dG9uUGFuZWwpID8gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWJ1dHRvbnBhbmUgdWktd2lkZ2V0LWNvbnRlbnQnPlwiICsgKGlzUlRMID8gY29udHJvbHMgOiBcIlwiKSArXG5cdFx0XHQodGhpcy5faXNJblJhbmdlKGluc3QsIGdvdG9EYXRlKSA/IFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSd1aS1kYXRlcGlja2VyLWN1cnJlbnQgdWktc3RhdGUtZGVmYXVsdCB1aS1wcmlvcml0eS1zZWNvbmRhcnkgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSd0b2RheScgZGF0YS1ldmVudD0nY2xpY2snXCIgK1xuXHRcdFx0XCI+XCIgKyBjdXJyZW50VGV4dCArIFwiPC9idXR0b24+XCIgOiBcIlwiKSArIChpc1JUTCA/IFwiXCIgOiBjb250cm9scykgKyBcIjwvZGl2PlwiIDogXCJcIjtcblxuXHRcdGZpcnN0RGF5ID0gcGFyc2VJbnQodGhpcy5fZ2V0KGluc3QsIFwiZmlyc3REYXlcIiksMTApO1xuXHRcdGZpcnN0RGF5ID0gKGlzTmFOKGZpcnN0RGF5KSA/IDAgOiBmaXJzdERheSk7XG5cblx0XHRzaG93V2VlayA9IHRoaXMuX2dldChpbnN0LCBcInNob3dXZWVrXCIpO1xuXHRcdGRheU5hbWVzID0gdGhpcy5fZ2V0KGluc3QsIFwiZGF5TmFtZXNcIik7XG5cdFx0ZGF5TmFtZXNNaW4gPSB0aGlzLl9nZXQoaW5zdCwgXCJkYXlOYW1lc01pblwiKTtcblx0XHRtb250aE5hbWVzID0gdGhpcy5fZ2V0KGluc3QsIFwibW9udGhOYW1lc1wiKTtcblx0XHRtb250aE5hbWVzU2hvcnQgPSB0aGlzLl9nZXQoaW5zdCwgXCJtb250aE5hbWVzU2hvcnRcIik7XG5cdFx0YmVmb3JlU2hvd0RheSA9IHRoaXMuX2dldChpbnN0LCBcImJlZm9yZVNob3dEYXlcIik7XG5cdFx0c2hvd090aGVyTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd090aGVyTW9udGhzXCIpO1xuXHRcdHNlbGVjdE90aGVyTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFwic2VsZWN0T3RoZXJNb250aHNcIik7XG5cdFx0ZGVmYXVsdERhdGUgPSB0aGlzLl9nZXREZWZhdWx0RGF0ZShpbnN0KTtcblx0XHRodG1sID0gXCJcIjtcblx0XHRkb3c7XG5cdFx0Zm9yIChyb3cgPSAwOyByb3cgPCBudW1Nb250aHNbMF07IHJvdysrKSB7XG5cdFx0XHRncm91cCA9IFwiXCI7XG5cdFx0XHR0aGlzLm1heFJvd3MgPSA0O1xuXHRcdFx0Zm9yIChjb2wgPSAwOyBjb2wgPCBudW1Nb250aHNbMV07IGNvbCsrKSB7XG5cdFx0XHRcdHNlbGVjdGVkRGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGgsIGluc3Quc2VsZWN0ZWREYXkpKTtcblx0XHRcdFx0Y29ybmVyQ2xhc3MgPSBcIiB1aS1jb3JuZXItYWxsXCI7XG5cdFx0XHRcdGNhbGVuZGVyID0gXCJcIjtcblx0XHRcdFx0aWYgKGlzTXVsdGlNb250aCkge1xuXHRcdFx0XHRcdGNhbGVuZGVyICs9IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci1ncm91cFwiO1xuXHRcdFx0XHRcdGlmIChudW1Nb250aHNbMV0gPiAxKSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKGNvbCkge1xuXHRcdFx0XHRcdFx0XHRjYXNlIDA6IGNhbGVuZGVyICs9IFwiIHVpLWRhdGVwaWNrZXItZ3JvdXAtZmlyc3RcIjtcblx0XHRcdFx0XHRcdFx0XHRjb3JuZXJDbGFzcyA9IFwiIHVpLWNvcm5lci1cIiArIChpc1JUTCA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgbnVtTW9udGhzWzFdLTE6IGNhbGVuZGVyICs9IFwiIHVpLWRhdGVwaWNrZXItZ3JvdXAtbGFzdFwiO1xuXHRcdFx0XHRcdFx0XHRcdGNvcm5lckNsYXNzID0gXCIgdWktY29ybmVyLVwiICsgKGlzUlRMID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpOyBicmVhaztcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDogY2FsZW5kZXIgKz0gXCIgdWktZGF0ZXBpY2tlci1ncm91cC1taWRkbGVcIjsgY29ybmVyQ2xhc3MgPSBcIlwiOyBicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gXCInPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGVuZGVyICs9IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci1oZWFkZXIgdWktd2lkZ2V0LWhlYWRlciB1aS1oZWxwZXItY2xlYXJmaXhcIiArIGNvcm5lckNsYXNzICsgXCInPlwiICtcblx0XHRcdFx0XHQoL2FsbHxsZWZ0Ly50ZXN0KGNvcm5lckNsYXNzKSAmJiByb3cgPT09IDAgPyAoaXNSVEwgPyBuZXh0IDogcHJldikgOiBcIlwiKSArXG5cdFx0XHRcdFx0KC9hbGx8cmlnaHQvLnRlc3QoY29ybmVyQ2xhc3MpICYmIHJvdyA9PT0gMCA/IChpc1JUTCA/IHByZXYgOiBuZXh0KSA6IFwiXCIpICtcblx0XHRcdFx0XHR0aGlzLl9nZW5lcmF0ZU1vbnRoWWVhckhlYWRlcihpbnN0LCBkcmF3TW9udGgsIGRyYXdZZWFyLCBtaW5EYXRlLCBtYXhEYXRlLFxuXHRcdFx0XHRcdHJvdyA+IDAgfHwgY29sID4gMCwgbW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0KSArIC8vIGRyYXcgbW9udGggaGVhZGVyc1xuXHRcdFx0XHRcdFwiPC9kaXY+PHRhYmxlIGNsYXNzPSd1aS1kYXRlcGlja2VyLWNhbGVuZGFyJz48dGhlYWQ+XCIgK1xuXHRcdFx0XHRcdFwiPHRyPlwiO1xuXHRcdFx0XHR0aGVhZCA9IChzaG93V2VlayA/IFwiPHRoIGNsYXNzPSd1aS1kYXRlcGlja2VyLXdlZWstY29sJz5cIiArIHRoaXMuX2dldChpbnN0LCBcIndlZWtIZWFkZXJcIikgKyBcIjwvdGg+XCIgOiBcIlwiKTtcblx0XHRcdFx0Zm9yIChkb3cgPSAwOyBkb3cgPCA3OyBkb3crKykgeyAvLyBkYXlzIG9mIHRoZSB3ZWVrXG5cdFx0XHRcdFx0ZGF5ID0gKGRvdyArIGZpcnN0RGF5KSAlIDc7XG5cdFx0XHRcdFx0dGhlYWQgKz0gXCI8dGhcIiArICgoZG93ICsgZmlyc3REYXkgKyA2KSAlIDcgPj0gNSA/IFwiIGNsYXNzPSd1aS1kYXRlcGlja2VyLXdlZWstZW5kJ1wiIDogXCJcIikgKyBcIj5cIiArXG5cdFx0XHRcdFx0XHRcIjxzcGFuIHRpdGxlPSdcIiArIGRheU5hbWVzW2RheV0gKyBcIic+XCIgKyBkYXlOYW1lc01pbltkYXldICsgXCI8L3NwYW4+PC90aD5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxlbmRlciArPSB0aGVhZCArIFwiPC90cj48L3RoZWFkPjx0Ym9keT5cIjtcblx0XHRcdFx0ZGF5c0luTW9udGggPSB0aGlzLl9nZXREYXlzSW5Nb250aChkcmF3WWVhciwgZHJhd01vbnRoKTtcblx0XHRcdFx0aWYgKGRyYXdZZWFyID09PSBpbnN0LnNlbGVjdGVkWWVhciAmJiBkcmF3TW9udGggPT09IGluc3Quc2VsZWN0ZWRNb250aCkge1xuXHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBNYXRoLm1pbihpbnN0LnNlbGVjdGVkRGF5LCBkYXlzSW5Nb250aCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGVhZERheXMgPSAodGhpcy5fZ2V0Rmlyc3REYXlPZk1vbnRoKGRyYXdZZWFyLCBkcmF3TW9udGgpIC0gZmlyc3REYXkgKyA3KSAlIDc7XG5cdFx0XHRcdGN1clJvd3MgPSBNYXRoLmNlaWwoKGxlYWREYXlzICsgZGF5c0luTW9udGgpIC8gNyk7IC8vIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHJvd3MgdG8gZ2VuZXJhdGVcblx0XHRcdFx0bnVtUm93cyA9IChpc011bHRpTW9udGggPyB0aGlzLm1heFJvd3MgPiBjdXJSb3dzID8gdGhpcy5tYXhSb3dzIDogY3VyUm93cyA6IGN1clJvd3MpOyAvL0lmIG11bHRpcGxlIG1vbnRocywgdXNlIHRoZSBoaWdoZXIgbnVtYmVyIG9mIHJvd3MgKHNlZSAjNzA0Mylcblx0XHRcdFx0dGhpcy5tYXhSb3dzID0gbnVtUm93cztcblx0XHRcdFx0cHJpbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgMSAtIGxlYWREYXlzKSk7XG5cdFx0XHRcdGZvciAoZFJvdyA9IDA7IGRSb3cgPCBudW1Sb3dzOyBkUm93KyspIHsgLy8gY3JlYXRlIGRhdGUgcGlja2VyIHJvd3Ncblx0XHRcdFx0XHRjYWxlbmRlciArPSBcIjx0cj5cIjtcblx0XHRcdFx0XHR0Ym9keSA9ICghc2hvd1dlZWsgPyBcIlwiIDogXCI8dGQgY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1jb2wnPlwiICtcblx0XHRcdFx0XHRcdHRoaXMuX2dldChpbnN0LCBcImNhbGN1bGF0ZVdlZWtcIikocHJpbnREYXRlKSArIFwiPC90ZD5cIik7XG5cdFx0XHRcdFx0Zm9yIChkb3cgPSAwOyBkb3cgPCA3OyBkb3crKykgeyAvLyBjcmVhdGUgZGF0ZSBwaWNrZXIgZGF5c1xuXHRcdFx0XHRcdFx0ZGF5U2V0dGluZ3MgPSAoYmVmb3JlU2hvd0RheSA/XG5cdFx0XHRcdFx0XHRcdGJlZm9yZVNob3dEYXkuYXBwbHkoKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCksIFtwcmludERhdGVdKSA6IFt0cnVlLCBcIlwiXSk7XG5cdFx0XHRcdFx0XHRvdGhlck1vbnRoID0gKHByaW50RGF0ZS5nZXRNb250aCgpICE9PSBkcmF3TW9udGgpO1xuXHRcdFx0XHRcdFx0dW5zZWxlY3RhYmxlID0gKG90aGVyTW9udGggJiYgIXNlbGVjdE90aGVyTW9udGhzKSB8fCAhZGF5U2V0dGluZ3NbMF0gfHxcblx0XHRcdFx0XHRcdFx0KG1pbkRhdGUgJiYgcHJpbnREYXRlIDwgbWluRGF0ZSkgfHwgKG1heERhdGUgJiYgcHJpbnREYXRlID4gbWF4RGF0ZSk7XG5cdFx0XHRcdFx0XHR0Ym9keSArPSBcIjx0ZCBjbGFzcz0nXCIgK1xuXHRcdFx0XHRcdFx0XHQoKGRvdyArIGZpcnN0RGF5ICsgNikgJSA3ID49IDUgPyBcIiB1aS1kYXRlcGlja2VyLXdlZWstZW5kXCIgOiBcIlwiKSArIC8vIGhpZ2hsaWdodCB3ZWVrZW5kc1xuXHRcdFx0XHRcdFx0XHQob3RoZXJNb250aCA/IFwiIHVpLWRhdGVwaWNrZXItb3RoZXItbW9udGhcIiA6IFwiXCIpICsgLy8gaGlnaGxpZ2h0IGRheXMgZnJvbSBvdGhlciBtb250aHNcblx0XHRcdFx0XHRcdFx0KChwcmludERhdGUuZ2V0VGltZSgpID09PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpICYmIGRyYXdNb250aCA9PT0gaW5zdC5zZWxlY3RlZE1vbnRoICYmIGluc3QuX2tleUV2ZW50KSB8fCAvLyB1c2VyIHByZXNzZWQga2V5XG5cdFx0XHRcdFx0XHRcdChkZWZhdWx0RGF0ZS5nZXRUaW1lKCkgPT09IHByaW50RGF0ZS5nZXRUaW1lKCkgJiYgZGVmYXVsdERhdGUuZ2V0VGltZSgpID09PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpKSA/XG5cdFx0XHRcdFx0XHRcdC8vIG9yIGRlZmF1bHREYXRlIGlzIGN1cnJlbnQgcHJpbnRlZERhdGUgYW5kIGRlZmF1bHREYXRlIGlzIHNlbGVjdGVkRGF0ZVxuXHRcdFx0XHRcdFx0XHRcIiBcIiArIHRoaXMuX2RheU92ZXJDbGFzcyA6IFwiXCIpICsgLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxuXHRcdFx0XHRcdFx0XHQodW5zZWxlY3RhYmxlID8gXCIgXCIgKyB0aGlzLl91bnNlbGVjdGFibGVDbGFzcyArIFwiIHVpLXN0YXRlLWRpc2FibGVkXCI6IFwiXCIpICsgIC8vIGhpZ2hsaWdodCB1bnNlbGVjdGFibGUgZGF5c1xuXHRcdFx0XHRcdFx0XHQob3RoZXJNb250aCAmJiAhc2hvd090aGVyTW9udGhzID8gXCJcIiA6IFwiIFwiICsgZGF5U2V0dGluZ3NbMV0gKyAvLyBoaWdobGlnaHQgY3VzdG9tIGRhdGVzXG5cdFx0XHRcdFx0XHRcdChwcmludERhdGUuZ2V0VGltZSgpID09PSBjdXJyZW50RGF0ZS5nZXRUaW1lKCkgPyBcIiBcIiArIHRoaXMuX2N1cnJlbnRDbGFzcyA6IFwiXCIpICsgLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxuXHRcdFx0XHRcdFx0XHQocHJpbnREYXRlLmdldFRpbWUoKSA9PT0gdG9kYXkuZ2V0VGltZSgpID8gXCIgdWktZGF0ZXBpY2tlci10b2RheVwiIDogXCJcIikpICsgXCInXCIgKyAvLyBoaWdobGlnaHQgdG9kYXkgKGlmIGRpZmZlcmVudClcblx0XHRcdFx0XHRcdFx0KCghb3RoZXJNb250aCB8fCBzaG93T3RoZXJNb250aHMpICYmIGRheVNldHRpbmdzWzJdID8gXCIgdGl0bGU9J1wiICsgZGF5U2V0dGluZ3NbMl0ucmVwbGFjZSgvJy9nLCBcIiYjMzk7XCIpICsgXCInXCIgOiBcIlwiKSArIC8vIGNlbGwgdGl0bGVcblx0XHRcdFx0XHRcdFx0KHVuc2VsZWN0YWJsZSA/IFwiXCIgOiBcIiBkYXRhLWhhbmRsZXI9J3NlbGVjdERheScgZGF0YS1ldmVudD0nY2xpY2snIGRhdGEtbW9udGg9J1wiICsgcHJpbnREYXRlLmdldE1vbnRoKCkgKyBcIicgZGF0YS15ZWFyPSdcIiArIHByaW50RGF0ZS5nZXRGdWxsWWVhcigpICsgXCInXCIpICsgXCI+XCIgKyAvLyBhY3Rpb25zXG5cdFx0XHRcdFx0XHRcdChvdGhlck1vbnRoICYmICFzaG93T3RoZXJNb250aHMgPyBcIiYjeGEwO1wiIDogLy8gZGlzcGxheSBmb3Igb3RoZXIgbW9udGhzXG5cdFx0XHRcdFx0XHRcdCh1bnNlbGVjdGFibGUgPyBcIjxzcGFuIGNsYXNzPSd1aS1zdGF0ZS1kZWZhdWx0Jz5cIiArIHByaW50RGF0ZS5nZXREYXRlKCkgKyBcIjwvc3Bhbj5cIiA6IFwiPGEgY2xhc3M9J3VpLXN0YXRlLWRlZmF1bHRcIiArXG5cdFx0XHRcdFx0XHRcdChwcmludERhdGUuZ2V0VGltZSgpID09PSB0b2RheS5nZXRUaW1lKCkgPyBcIiB1aS1zdGF0ZS1oaWdobGlnaHRcIiA6IFwiXCIpICtcblx0XHRcdFx0XHRcdFx0KHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IGN1cnJlbnREYXRlLmdldFRpbWUoKSA/IFwiIHVpLXN0YXRlLWFjdGl2ZVwiIDogXCJcIikgKyAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XG5cdFx0XHRcdFx0XHRcdChvdGhlck1vbnRoID8gXCIgdWktcHJpb3JpdHktc2Vjb25kYXJ5XCIgOiBcIlwiKSArIC8vIGRpc3Rpbmd1aXNoIGRhdGVzIGZyb20gb3RoZXIgbW9udGhzXG5cdFx0XHRcdFx0XHRcdFwiJyBocmVmPScjJz5cIiArIHByaW50RGF0ZS5nZXREYXRlKCkgKyBcIjwvYT5cIikpICsgXCI8L3RkPlwiOyAvLyBkaXNwbGF5IHNlbGVjdGFibGUgZGF0ZVxuXHRcdFx0XHRcdFx0cHJpbnREYXRlLnNldERhdGUocHJpbnREYXRlLmdldERhdGUoKSArIDEpO1xuXHRcdFx0XHRcdFx0cHJpbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QocHJpbnREYXRlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gdGJvZHkgKyBcIjwvdHI+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZHJhd01vbnRoKys7XG5cdFx0XHRcdGlmIChkcmF3TW9udGggPiAxMSkge1xuXHRcdFx0XHRcdGRyYXdNb250aCA9IDA7XG5cdFx0XHRcdFx0ZHJhd1llYXIrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxlbmRlciArPSBcIjwvdGJvZHk+PC90YWJsZT5cIiArIChpc011bHRpTW9udGggPyBcIjwvZGl2PlwiICtcblx0XHRcdFx0XHRcdFx0KChudW1Nb250aHNbMF0gPiAwICYmIGNvbCA9PT0gbnVtTW9udGhzWzFdLTEpID8gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLXJvdy1icmVhayc+PC9kaXY+XCIgOiBcIlwiKSA6IFwiXCIpO1xuXHRcdFx0XHRncm91cCArPSBjYWxlbmRlcjtcblx0XHRcdH1cblx0XHRcdGh0bWwgKz0gZ3JvdXA7XG5cdFx0fVxuXHRcdGh0bWwgKz0gYnV0dG9uUGFuZWw7XG5cdFx0aW5zdC5fa2V5RXZlbnQgPSBmYWxzZTtcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgbW9udGggYW5kIHllYXIgaGVhZGVyLiAqL1xuXHRfZ2VuZXJhdGVNb250aFllYXJIZWFkZXI6IGZ1bmN0aW9uKGluc3QsIGRyYXdNb250aCwgZHJhd1llYXIsIG1pbkRhdGUsIG1heERhdGUsXG5cdFx0XHRzZWNvbmRhcnksIG1vbnRoTmFtZXMsIG1vbnRoTmFtZXNTaG9ydCkge1xuXG5cdFx0dmFyIGluTWluWWVhciwgaW5NYXhZZWFyLCBtb250aCwgeWVhcnMsIHRoaXNZZWFyLCBkZXRlcm1pbmVZZWFyLCB5ZWFyLCBlbmRZZWFyLFxuXHRcdFx0Y2hhbmdlTW9udGggPSB0aGlzLl9nZXQoaW5zdCwgXCJjaGFuZ2VNb250aFwiKSxcblx0XHRcdGNoYW5nZVllYXIgPSB0aGlzLl9nZXQoaW5zdCwgXCJjaGFuZ2VZZWFyXCIpLFxuXHRcdFx0c2hvd01vbnRoQWZ0ZXJZZWFyID0gdGhpcy5fZ2V0KGluc3QsIFwic2hvd01vbnRoQWZ0ZXJZZWFyXCIpLFxuXHRcdFx0aHRtbCA9IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci10aXRsZSc+XCIsXG5cdFx0XHRtb250aEh0bWwgPSBcIlwiO1xuXG5cdFx0Ly8gbW9udGggc2VsZWN0aW9uXG5cdFx0aWYgKHNlY29uZGFyeSB8fCAhY2hhbmdlTW9udGgpIHtcblx0XHRcdG1vbnRoSHRtbCArPSBcIjxzcGFuIGNsYXNzPSd1aS1kYXRlcGlja2VyLW1vbnRoJz5cIiArIG1vbnRoTmFtZXNbZHJhd01vbnRoXSArIFwiPC9zcGFuPlwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbk1pblllYXIgPSAobWluRGF0ZSAmJiBtaW5EYXRlLmdldEZ1bGxZZWFyKCkgPT09IGRyYXdZZWFyKTtcblx0XHRcdGluTWF4WWVhciA9IChtYXhEYXRlICYmIG1heERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gZHJhd1llYXIpO1xuXHRcdFx0bW9udGhIdG1sICs9IFwiPHNlbGVjdCBjbGFzcz0ndWktZGF0ZXBpY2tlci1tb250aCcgZGF0YS1oYW5kbGVyPSdzZWxlY3RNb250aCcgZGF0YS1ldmVudD0nY2hhbmdlJz5cIjtcblx0XHRcdGZvciAoIG1vbnRoID0gMDsgbW9udGggPCAxMjsgbW9udGgrKykge1xuXHRcdFx0XHRpZiAoKCFpbk1pblllYXIgfHwgbW9udGggPj0gbWluRGF0ZS5nZXRNb250aCgpKSAmJiAoIWluTWF4WWVhciB8fCBtb250aCA8PSBtYXhEYXRlLmdldE1vbnRoKCkpKSB7XG5cdFx0XHRcdFx0bW9udGhIdG1sICs9IFwiPG9wdGlvbiB2YWx1ZT0nXCIgKyBtb250aCArIFwiJ1wiICtcblx0XHRcdFx0XHRcdChtb250aCA9PT0gZHJhd01vbnRoID8gXCIgc2VsZWN0ZWQ9J3NlbGVjdGVkJ1wiIDogXCJcIikgK1xuXHRcdFx0XHRcdFx0XCI+XCIgKyBtb250aE5hbWVzU2hvcnRbbW9udGhdICsgXCI8L29wdGlvbj5cIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bW9udGhIdG1sICs9IFwiPC9zZWxlY3Q+XCI7XG5cdFx0fVxuXG5cdFx0aWYgKCFzaG93TW9udGhBZnRlclllYXIpIHtcblx0XHRcdGh0bWwgKz0gbW9udGhIdG1sICsgKHNlY29uZGFyeSB8fCAhKGNoYW5nZU1vbnRoICYmIGNoYW5nZVllYXIpID8gXCImI3hhMDtcIiA6IFwiXCIpO1xuXHRcdH1cblxuXHRcdC8vIHllYXIgc2VsZWN0aW9uXG5cdFx0aWYgKCAhaW5zdC55ZWFyc2h0bWwgKSB7XG5cdFx0XHRpbnN0LnllYXJzaHRtbCA9IFwiXCI7XG5cdFx0XHRpZiAoc2Vjb25kYXJ5IHx8ICFjaGFuZ2VZZWFyKSB7XG5cdFx0XHRcdGh0bWwgKz0gXCI8c3BhbiBjbGFzcz0ndWktZGF0ZXBpY2tlci15ZWFyJz5cIiArIGRyYXdZZWFyICsgXCI8L3NwYW4+XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBkZXRlcm1pbmUgcmFuZ2Ugb2YgeWVhcnMgdG8gZGlzcGxheVxuXHRcdFx0XHR5ZWFycyA9IHRoaXMuX2dldChpbnN0LCBcInllYXJSYW5nZVwiKS5zcGxpdChcIjpcIik7XG5cdFx0XHRcdHRoaXNZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRkZXRlcm1pbmVZZWFyID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgeWVhciA9ICh2YWx1ZS5tYXRjaCgvY1srXFwtXS4qLykgPyBkcmF3WWVhciArIHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZygxKSwgMTApIDpcblx0XHRcdFx0XHRcdCh2YWx1ZS5tYXRjaCgvWytcXC1dLiovKSA/IHRoaXNZZWFyICsgcGFyc2VJbnQodmFsdWUsIDEwKSA6XG5cdFx0XHRcdFx0XHRwYXJzZUludCh2YWx1ZSwgMTApKSk7XG5cdFx0XHRcdFx0cmV0dXJuIChpc05hTih5ZWFyKSA/IHRoaXNZZWFyIDogeWVhcik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHllYXIgPSBkZXRlcm1pbmVZZWFyKHllYXJzWzBdKTtcblx0XHRcdFx0ZW5kWWVhciA9IE1hdGgubWF4KHllYXIsIGRldGVybWluZVllYXIoeWVhcnNbMV0gfHwgXCJcIikpO1xuXHRcdFx0XHR5ZWFyID0gKG1pbkRhdGUgPyBNYXRoLm1heCh5ZWFyLCBtaW5EYXRlLmdldEZ1bGxZZWFyKCkpIDogeWVhcik7XG5cdFx0XHRcdGVuZFllYXIgPSAobWF4RGF0ZSA/IE1hdGgubWluKGVuZFllYXIsIG1heERhdGUuZ2V0RnVsbFllYXIoKSkgOiBlbmRZZWFyKTtcblx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gXCI8c2VsZWN0IGNsYXNzPSd1aS1kYXRlcGlja2VyLXllYXInIGRhdGEtaGFuZGxlcj0nc2VsZWN0WWVhcicgZGF0YS1ldmVudD0nY2hhbmdlJz5cIjtcblx0XHRcdFx0Zm9yICg7IHllYXIgPD0gZW5kWWVhcjsgeWVhcisrKSB7XG5cdFx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIHllYXIgKyBcIidcIiArXG5cdFx0XHRcdFx0XHQoeWVhciA9PT0gZHJhd1llYXIgPyBcIiBzZWxlY3RlZD0nc2VsZWN0ZWQnXCIgOiBcIlwiKSArXG5cdFx0XHRcdFx0XHRcIj5cIiArIHllYXIgKyBcIjwvb3B0aW9uPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3QueWVhcnNodG1sICs9IFwiPC9zZWxlY3Q+XCI7XG5cblx0XHRcdFx0aHRtbCArPSBpbnN0LnllYXJzaHRtbDtcblx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGh0bWwgKz0gdGhpcy5fZ2V0KGluc3QsIFwieWVhclN1ZmZpeFwiKTtcblx0XHRpZiAoc2hvd01vbnRoQWZ0ZXJZZWFyKSB7XG5cdFx0XHRodG1sICs9IChzZWNvbmRhcnkgfHwgIShjaGFuZ2VNb250aCAmJiBjaGFuZ2VZZWFyKSA/IFwiJiN4YTA7XCIgOiBcIlwiKSArIG1vbnRoSHRtbDtcblx0XHR9XG5cdFx0aHRtbCArPSBcIjwvZGl2PlwiOyAvLyBDbG9zZSBkYXRlcGlja2VyX2hlYWRlclxuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdC8qIEFkanVzdCBvbmUgb2YgdGhlIGRhdGUgc3ViLWZpZWxkcy4gKi9cblx0X2FkanVzdEluc3REYXRlOiBmdW5jdGlvbihpbnN0LCBvZmZzZXQsIHBlcmlvZCkge1xuXHRcdHZhciB5ZWFyID0gaW5zdC5kcmF3WWVhciArIChwZXJpb2QgPT09IFwiWVwiID8gb2Zmc2V0IDogMCksXG5cdFx0XHRtb250aCA9IGluc3QuZHJhd01vbnRoICsgKHBlcmlvZCA9PT0gXCJNXCIgPyBvZmZzZXQgOiAwKSxcblx0XHRcdGRheSA9IE1hdGgubWluKGluc3Quc2VsZWN0ZWREYXksIHRoaXMuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkgKyAocGVyaW9kID09PSBcIkRcIiA/IG9mZnNldCA6IDApLFxuXHRcdFx0ZGF0ZSA9IHRoaXMuX3Jlc3RyaWN0TWluTWF4KGluc3QsIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpKSk7XG5cblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGlmIChwZXJpb2QgPT09IFwiTVwiIHx8IHBlcmlvZCA9PT0gXCJZXCIpIHtcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcblx0XHR9XG5cdH0sXG5cblx0LyogRW5zdXJlIGEgZGF0ZSBpcyB3aXRoaW4gYW55IG1pbi9tYXggYm91bmRzLiAqL1xuXHRfcmVzdHJpY3RNaW5NYXg6IGZ1bmN0aW9uKGluc3QsIGRhdGUpIHtcblx0XHR2YXIgbWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXCJtaW5cIiksXG5cdFx0XHRtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcIm1heFwiKSxcblx0XHRcdG5ld0RhdGUgPSAobWluRGF0ZSAmJiBkYXRlIDwgbWluRGF0ZSA/IG1pbkRhdGUgOiBkYXRlKTtcblx0XHRyZXR1cm4gKG1heERhdGUgJiYgbmV3RGF0ZSA+IG1heERhdGUgPyBtYXhEYXRlIDogbmV3RGF0ZSk7XG5cdH0sXG5cblx0LyogTm90aWZ5IGNoYW5nZSBvZiBtb250aC95ZWFyLiAqL1xuXHRfbm90aWZ5Q2hhbmdlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIG9uQ2hhbmdlID0gdGhpcy5fZ2V0KGluc3QsIFwib25DaGFuZ2VNb250aFllYXJcIik7XG5cdFx0aWYgKG9uQ2hhbmdlKSB7XG5cdFx0XHRvbkNoYW5nZS5hcHBseSgoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsKSxcblx0XHRcdFx0W2luc3Quc2VsZWN0ZWRZZWFyLCBpbnN0LnNlbGVjdGVkTW9udGggKyAxLCBpbnN0XSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIG1vbnRocyB0byBzaG93LiAqL1xuXHRfZ2V0TnVtYmVyT2ZNb250aHM6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgbnVtTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFwibnVtYmVyT2ZNb250aHNcIik7XG5cdFx0cmV0dXJuIChudW1Nb250aHMgPT0gbnVsbCA/IFsxLCAxXSA6ICh0eXBlb2YgbnVtTW9udGhzID09PSBcIm51bWJlclwiID8gWzEsIG51bU1vbnRoc10gOiBudW1Nb250aHMpKTtcblx0fSxcblxuXHQvKiBEZXRlcm1pbmUgdGhlIGN1cnJlbnQgbWF4aW11bSBkYXRlIC0gZW5zdXJlIG5vIHRpbWUgY29tcG9uZW50cyBhcmUgc2V0LiAqL1xuXHRfZ2V0TWluTWF4RGF0ZTogZnVuY3Rpb24oaW5zdCwgbWluTWF4KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RldGVybWluZURhdGUoaW5zdCwgdGhpcy5fZ2V0KGluc3QsIG1pbk1heCArIFwiRGF0ZVwiKSwgbnVsbCk7XG5cdH0sXG5cblx0LyogRmluZCB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSBnaXZlbiBtb250aC4gKi9cblx0X2dldERheXNJbk1vbnRoOiBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuXHRcdHJldHVybiAzMiAtIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCAzMikpLmdldERhdGUoKTtcblx0fSxcblxuXHQvKiBGaW5kIHRoZSBkYXkgb2YgdGhlIHdlZWsgb2YgdGhlIGZpcnN0IG9mIGEgbW9udGguICovXG5cdF9nZXRGaXJzdERheU9mTW9udGg6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKS5nZXREYXkoKTtcblx0fSxcblxuXHQvKiBEZXRlcm1pbmVzIGlmIHdlIHNob3VsZCBhbGxvdyBhIFwibmV4dC9wcmV2XCIgbW9udGggZGlzcGxheSBjaGFuZ2UuICovXG5cdF9jYW5BZGp1c3RNb250aDogZnVuY3Rpb24oaW5zdCwgb2Zmc2V0LCBjdXJZZWFyLCBjdXJNb250aCkge1xuXHRcdHZhciBudW1Nb250aHMgPSB0aGlzLl9nZXROdW1iZXJPZk1vbnRocyhpbnN0KSxcblx0XHRcdGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShjdXJZZWFyLFxuXHRcdFx0Y3VyTW9udGggKyAob2Zmc2V0IDwgMCA/IG9mZnNldCA6IG51bU1vbnRoc1swXSAqIG51bU1vbnRoc1sxXSksIDEpKTtcblxuXHRcdGlmIChvZmZzZXQgPCAwKSB7XG5cdFx0XHRkYXRlLnNldERhdGUodGhpcy5fZ2V0RGF5c0luTW9udGgoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2lzSW5SYW5nZShpbnN0LCBkYXRlKTtcblx0fSxcblxuXHQvKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgYWNjZXB0ZWQgcmFuZ2U/ICovXG5cdF9pc0luUmFuZ2U6IGZ1bmN0aW9uKGluc3QsIGRhdGUpIHtcblx0XHR2YXIgeWVhclNwbGl0LCBjdXJyZW50WWVhcixcblx0XHRcdG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFwibWluXCIpLFxuXHRcdFx0bWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXCJtYXhcIiksXG5cdFx0XHRtaW5ZZWFyID0gbnVsbCxcblx0XHRcdG1heFllYXIgPSBudWxsLFxuXHRcdFx0eWVhcnMgPSB0aGlzLl9nZXQoaW5zdCwgXCJ5ZWFyUmFuZ2VcIik7XG5cdFx0XHRpZiAoeWVhcnMpe1xuXHRcdFx0XHR5ZWFyU3BsaXQgPSB5ZWFycy5zcGxpdChcIjpcIik7XG5cdFx0XHRcdGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRtaW5ZZWFyID0gcGFyc2VJbnQoeWVhclNwbGl0WzBdLCAxMCk7XG5cdFx0XHRcdG1heFllYXIgPSBwYXJzZUludCh5ZWFyU3BsaXRbMV0sIDEwKTtcblx0XHRcdFx0aWYgKCB5ZWFyU3BsaXRbMF0ubWF0Y2goL1srXFwtXS4qLykgKSB7XG5cdFx0XHRcdFx0bWluWWVhciArPSBjdXJyZW50WWVhcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHllYXJTcGxpdFsxXS5tYXRjaCgvWytcXC1dLiovKSApIHtcblx0XHRcdFx0XHRtYXhZZWFyICs9IGN1cnJlbnRZZWFyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRyZXR1cm4gKCghbWluRGF0ZSB8fCBkYXRlLmdldFRpbWUoKSA+PSBtaW5EYXRlLmdldFRpbWUoKSkgJiZcblx0XHRcdCghbWF4RGF0ZSB8fCBkYXRlLmdldFRpbWUoKSA8PSBtYXhEYXRlLmdldFRpbWUoKSkgJiZcblx0XHRcdCghbWluWWVhciB8fCBkYXRlLmdldEZ1bGxZZWFyKCkgPj0gbWluWWVhcikgJiZcblx0XHRcdCghbWF4WWVhciB8fCBkYXRlLmdldEZ1bGxZZWFyKCkgPD0gbWF4WWVhcikpO1xuXHR9LFxuXG5cdC8qIFByb3ZpZGUgdGhlIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MgZm9yIGZvcm1hdHRpbmcvcGFyc2luZy4gKi9cblx0X2dldEZvcm1hdENvbmZpZzogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBzaG9ydFllYXJDdXRvZmYgPSB0aGlzLl9nZXQoaW5zdCwgXCJzaG9ydFllYXJDdXRvZmZcIik7XG5cdFx0c2hvcnRZZWFyQ3V0b2ZmID0gKHR5cGVvZiBzaG9ydFllYXJDdXRvZmYgIT09IFwic3RyaW5nXCIgPyBzaG9ydFllYXJDdXRvZmYgOlxuXHRcdFx0bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgcGFyc2VJbnQoc2hvcnRZZWFyQ3V0b2ZmLCAxMCkpO1xuXHRcdHJldHVybiB7c2hvcnRZZWFyQ3V0b2ZmOiBzaG9ydFllYXJDdXRvZmYsXG5cdFx0XHRkYXlOYW1lc1Nob3J0OiB0aGlzLl9nZXQoaW5zdCwgXCJkYXlOYW1lc1Nob3J0XCIpLCBkYXlOYW1lczogdGhpcy5fZ2V0KGluc3QsIFwiZGF5TmFtZXNcIiksXG5cdFx0XHRtb250aE5hbWVzU2hvcnQ6IHRoaXMuX2dldChpbnN0LCBcIm1vbnRoTmFtZXNTaG9ydFwiKSwgbW9udGhOYW1lczogdGhpcy5fZ2V0KGluc3QsIFwibW9udGhOYW1lc1wiKX07XG5cdH0sXG5cblx0LyogRm9ybWF0IHRoZSBnaXZlbiBkYXRlIGZvciBkaXNwbGF5LiAqL1xuXHRfZm9ybWF0RGF0ZTogZnVuY3Rpb24oaW5zdCwgZGF5LCBtb250aCwgeWVhcikge1xuXHRcdGlmICghZGF5KSB7XG5cdFx0XHRpbnN0LmN1cnJlbnREYXkgPSBpbnN0LnNlbGVjdGVkRGF5O1xuXHRcdFx0aW5zdC5jdXJyZW50TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGg7XG5cdFx0XHRpbnN0LmN1cnJlbnRZZWFyID0gaW5zdC5zZWxlY3RlZFllYXI7XG5cdFx0fVxuXHRcdHZhciBkYXRlID0gKGRheSA/ICh0eXBlb2YgZGF5ID09PSBcIm9iamVjdFwiID8gZGF5IDpcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpKSkgOlxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoaW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSkpKTtcblx0XHRyZXR1cm4gdGhpcy5mb3JtYXREYXRlKHRoaXMuX2dldChpbnN0LCBcImRhdGVGb3JtYXRcIiksIGRhdGUsIHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XG5cdH1cbn0pO1xuXG4vKlxuICogQmluZCBob3ZlciBldmVudHMgZm9yIGRhdGVwaWNrZXIgZWxlbWVudHMuXG4gKiBEb25lIHZpYSBkZWxlZ2F0ZSBzbyB0aGUgYmluZGluZyBvbmx5IG9jY3VycyBvbmNlIGluIHRoZSBsaWZldGltZSBvZiB0aGUgcGFyZW50IGRpdi5cbiAqIEdsb2JhbCBpbnN0QWN0aXZlLCBzZXQgYnkgX3VwZGF0ZURhdGVwaWNrZXIgYWxsb3dzIHRoZSBoYW5kbGVycyB0byBmaW5kIHRoZWlyIHdheSBiYWNrIHRvIHRoZSBhY3RpdmUgcGlja2VyLlxuICovXG5mdW5jdGlvbiBiaW5kSG92ZXIoZHBEaXYpIHtcblx0dmFyIHNlbGVjdG9yID0gXCJidXR0b24sIC51aS1kYXRlcGlja2VyLXByZXYsIC51aS1kYXRlcGlja2VyLW5leHQsIC51aS1kYXRlcGlja2VyLWNhbGVuZGFyIHRkIGFcIjtcblx0cmV0dXJuIGRwRGl2LmRlbGVnYXRlKHNlbGVjdG9yLCBcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLXN0YXRlLWhvdmVyXCIpO1xuXHRcdFx0aWYgKHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoXCJ1aS1kYXRlcGlja2VyLXByZXZcIikgIT09IC0xKSB7XG5cdFx0XHRcdCQodGhpcykucmVtb3ZlQ2xhc3MoXCJ1aS1kYXRlcGlja2VyLXByZXYtaG92ZXJcIik7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcInVpLWRhdGVwaWNrZXItbmV4dFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLWRhdGVwaWNrZXItbmV4dC1ob3ZlclwiKTtcblx0XHRcdH1cblx0XHR9KVxuXHRcdC5kZWxlZ2F0ZShzZWxlY3RvciwgXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKXtcblx0XHRcdGlmICghJC5kYXRlcGlja2VyLl9pc0Rpc2FibGVkRGF0ZXBpY2tlciggaW5zdEFjdGl2ZS5pbmxpbmUgPyBkcERpdi5wYXJlbnQoKVswXSA6IGluc3RBY3RpdmUuaW5wdXRbMF0pKSB7XG5cdFx0XHRcdCQodGhpcykucGFyZW50cyhcIi51aS1kYXRlcGlja2VyLWNhbGVuZGFyXCIpLmZpbmQoXCJhXCIpLnJlbW92ZUNsYXNzKFwidWktc3RhdGUtaG92ZXJcIik7XG5cdFx0XHRcdCQodGhpcykuYWRkQ2xhc3MoXCJ1aS1zdGF0ZS1ob3ZlclwiKTtcblx0XHRcdFx0aWYgKHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoXCJ1aS1kYXRlcGlja2VyLXByZXZcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5hZGRDbGFzcyhcInVpLWRhdGVwaWNrZXItcHJldi1ob3ZlclwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcInVpLWRhdGVwaWNrZXItbmV4dFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKFwidWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG59XG5cbi8qIGpRdWVyeSBleHRlbmQgbm93IGlnbm9yZXMgbnVsbHMhICovXG5mdW5jdGlvbiBleHRlbmRSZW1vdmUodGFyZ2V0LCBwcm9wcykge1xuXHQkLmV4dGVuZCh0YXJnZXQsIHByb3BzKTtcblx0Zm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xuXHRcdGlmIChwcm9wc1tuYW1lXSA9PSBudWxsKSB7XG5cdFx0XHR0YXJnZXRbbmFtZV0gPSBwcm9wc1tuYW1lXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSW52b2tlIHRoZSBkYXRlcGlja2VyIGZ1bmN0aW9uYWxpdHkuXG4gICBAcGFyYW0gIG9wdGlvbnMgIHN0cmluZyAtIGEgY29tbWFuZCwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgb3Jcblx0XHRcdFx0XHRPYmplY3QgLSBzZXR0aW5ncyBmb3IgYXR0YWNoaW5nIG5ldyBkYXRlcGlja2VyIGZ1bmN0aW9uYWxpdHlcbiAgIEByZXR1cm4gIGpRdWVyeSBvYmplY3QgKi9cbiQuZm4uZGF0ZXBpY2tlciA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXG5cdC8qIFZlcmlmeSBhbiBlbXB0eSBjb2xsZWN0aW9uIHdhc24ndCBwYXNzZWQgLSBGaXhlcyAjNjk3NiAqL1xuXHRpZiAoICF0aGlzLmxlbmd0aCApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qIEluaXRpYWxpc2UgdGhlIGRhdGUgcGlja2VyLiAqL1xuXHRpZiAoISQuZGF0ZXBpY2tlci5pbml0aWFsaXplZCkge1xuXHRcdCQoZG9jdW1lbnQpLm1vdXNlZG93bigkLmRhdGVwaWNrZXIuX2NoZWNrRXh0ZXJuYWxDbGljayk7XG5cdFx0JC5kYXRlcGlja2VyLmluaXRpYWxpemVkID0gdHJ1ZTtcblx0fVxuXG5cdC8qIEFwcGVuZCBkYXRlcGlja2VyIG1haW4gY29udGFpbmVyIHRvIGJvZHkgaWYgbm90IGV4aXN0LiAqL1xuXHRpZiAoJChcIiNcIiskLmRhdGVwaWNrZXIuX21haW5EaXZJZCkubGVuZ3RoID09PSAwKSB7XG5cdFx0JChcImJvZHlcIikuYXBwZW5kKCQuZGF0ZXBpY2tlci5kcERpdik7XG5cdH1cblxuXHR2YXIgb3RoZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0aWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICYmIChvcHRpb25zID09PSBcImlzRGlzYWJsZWRcIiB8fCBvcHRpb25zID09PSBcImdldERhdGVcIiB8fCBvcHRpb25zID09PSBcIndpZGdldFwiKSkge1xuXHRcdHJldHVybiAkLmRhdGVwaWNrZXJbXCJfXCIgKyBvcHRpb25zICsgXCJEYXRlcGlja2VyXCJdLlxuXHRcdFx0YXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc1swXV0uY29uY2F0KG90aGVyQXJncykpO1xuXHR9XG5cdGlmIChvcHRpb25zID09PSBcIm9wdGlvblwiICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiAkLmRhdGVwaWNrZXJbXCJfXCIgKyBvcHRpb25zICsgXCJEYXRlcGlja2VyXCJdLlxuXHRcdFx0YXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc1swXV0uY29uY2F0KG90aGVyQXJncykpO1xuXHR9XG5cdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0dHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0JC5kYXRlcGlja2VyW1wiX1wiICsgb3B0aW9ucyArIFwiRGF0ZXBpY2tlclwiXS5cblx0XHRcdFx0YXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc10uY29uY2F0KG90aGVyQXJncykpIDpcblx0XHRcdCQuZGF0ZXBpY2tlci5fYXR0YWNoRGF0ZXBpY2tlcih0aGlzLCBvcHRpb25zKTtcblx0fSk7XG59O1xuXG4kLmRhdGVwaWNrZXIgPSBuZXcgRGF0ZXBpY2tlcigpOyAvLyBzaW5nbGV0b24gaW5zdGFuY2VcbiQuZGF0ZXBpY2tlci5pbml0aWFsaXplZCA9IGZhbHNlO1xuJC5kYXRlcGlja2VyLnV1aWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiQuZGF0ZXBpY2tlci52ZXJzaW9uID0gXCIxLjEwLjRcIjtcblxufSkoalF1ZXJ5KTtcbiIsInZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnJlcXVpcmUoJy4vY29yZScpO1xucmVxdWlyZSgnLi9tb3VzZScpO1xucmVxdWlyZSgnLi93aWRnZXQnKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgRHJhZ2dhYmxlIDEuMTAuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9kcmFnZ2FibGUvXG4gKlxuICogRGVwZW5kczpcbiAqXHRqcXVlcnkudWkuY29yZS5qc1xuICpcdGpxdWVyeS51aS5tb3VzZS5qc1xuICpcdGpxdWVyeS51aS53aWRnZXQuanNcbiAqL1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQud2lkZ2V0KFwidWkuZHJhZ2dhYmxlXCIsICQudWkubW91c2UsIHtcblx0dmVyc2lvbjogXCIxLjEwLjRcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwiZHJhZ1wiLFxuXHRvcHRpb25zOiB7XG5cdFx0YWRkQ2xhc3NlczogdHJ1ZSxcblx0XHRhcHBlbmRUbzogXCJwYXJlbnRcIixcblx0XHRheGlzOiBmYWxzZSxcblx0XHRjb25uZWN0VG9Tb3J0YWJsZTogZmFsc2UsXG5cdFx0Y29udGFpbm1lbnQ6IGZhbHNlLFxuXHRcdGN1cnNvcjogXCJhdXRvXCIsXG5cdFx0Y3Vyc29yQXQ6IGZhbHNlLFxuXHRcdGdyaWQ6IGZhbHNlLFxuXHRcdGhhbmRsZTogZmFsc2UsXG5cdFx0aGVscGVyOiBcIm9yaWdpbmFsXCIsXG5cdFx0aWZyYW1lRml4OiBmYWxzZSxcblx0XHRvcGFjaXR5OiBmYWxzZSxcblx0XHRyZWZyZXNoUG9zaXRpb25zOiBmYWxzZSxcblx0XHRyZXZlcnQ6IGZhbHNlLFxuXHRcdHJldmVydER1cmF0aW9uOiA1MDAsXG5cdFx0c2NvcGU6IFwiZGVmYXVsdFwiLFxuXHRcdHNjcm9sbDogdHJ1ZSxcblx0XHRzY3JvbGxTZW5zaXRpdml0eTogMjAsXG5cdFx0c2Nyb2xsU3BlZWQ6IDIwLFxuXHRcdHNuYXA6IGZhbHNlLFxuXHRcdHNuYXBNb2RlOiBcImJvdGhcIixcblx0XHRzbmFwVG9sZXJhbmNlOiAyMCxcblx0XHRzdGFjazogZmFsc2UsXG5cdFx0ekluZGV4OiBmYWxzZSxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGRyYWc6IG51bGwsXG5cdFx0c3RhcnQ6IG51bGwsXG5cdFx0c3RvcDogbnVsbFxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGVscGVyID09PSBcIm9yaWdpbmFsXCIgJiYgISgvXig/OnJ8YXxmKS8pLnRlc3QodGhpcy5lbGVtZW50LmNzcyhcInBvc2l0aW9uXCIpKSkge1xuXHRcdFx0dGhpcy5lbGVtZW50WzBdLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmFkZENsYXNzZXMpe1xuXHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktZHJhZ2dhYmxlXCIpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKXtcblx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLWRyYWdnYWJsZS1kaXNhYmxlZFwiKTtcblx0XHR9XG5cblx0XHR0aGlzLl9tb3VzZUluaXQoKTtcblxuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktZHJhZ2dhYmxlIHVpLWRyYWdnYWJsZS1kcmFnZ2luZyB1aS1kcmFnZ2FibGUtZGlzYWJsZWRcIiApO1xuXHRcdHRoaXMuX21vdXNlRGVzdHJveSgpO1xuXHR9LFxuXG5cdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucztcblxuXHRcdC8vIGFtb25nIG90aGVycywgcHJldmVudCBhIGRyYWcgb24gYSByZXNpemFibGUtaGFuZGxlXG5cdFx0aWYgKHRoaXMuaGVscGVyIHx8IG8uZGlzYWJsZWQgfHwgJChldmVudC50YXJnZXQpLmNsb3Nlc3QoXCIudWktcmVzaXphYmxlLWhhbmRsZVwiKS5sZW5ndGggPiAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9RdWl0IGlmIHdlJ3JlIG5vdCBvbiBhIHZhbGlkIGhhbmRsZVxuXHRcdHRoaXMuaGFuZGxlID0gdGhpcy5fZ2V0SGFuZGxlKGV2ZW50KTtcblx0XHRpZiAoIXRoaXMuaGFuZGxlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0JChvLmlmcmFtZUZpeCA9PT0gdHJ1ZSA/IFwiaWZyYW1lXCIgOiBvLmlmcmFtZUZpeCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdCQoXCI8ZGl2IGNsYXNzPSd1aS1kcmFnZ2FibGUtaWZyYW1lRml4JyBzdHlsZT0nYmFja2dyb3VuZDogI2ZmZjsnPjwvZGl2PlwiKVxuXHRcdFx0LmNzcyh7XG5cdFx0XHRcdHdpZHRoOiB0aGlzLm9mZnNldFdpZHRoK1wicHhcIiwgaGVpZ2h0OiB0aGlzLm9mZnNldEhlaWdodCtcInB4XCIsXG5cdFx0XHRcdHBvc2l0aW9uOiBcImFic29sdXRlXCIsIG9wYWNpdHk6IFwiMC4wMDFcIiwgekluZGV4OiAxMDAwXG5cdFx0XHR9KVxuXHRcdFx0LmNzcygkKHRoaXMpLm9mZnNldCgpKVxuXHRcdFx0LmFwcGVuZFRvKFwiYm9keVwiKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucztcblxuXHRcdC8vQ3JlYXRlIGFuZCBhcHBlbmQgdGhlIHZpc2libGUgaGVscGVyXG5cdFx0dGhpcy5oZWxwZXIgPSB0aGlzLl9jcmVhdGVIZWxwZXIoZXZlbnQpO1xuXG5cdFx0dGhpcy5oZWxwZXIuYWRkQ2xhc3MoXCJ1aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIik7XG5cblx0XHQvL0NhY2hlIHRoZSBoZWxwZXIgc2l6ZVxuXHRcdHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTtcblxuXHRcdC8vSWYgZGRtYW5hZ2VyIGlzIHVzZWQgZm9yIGRyb3BwYWJsZXMsIHNldCB0aGUgZ2xvYmFsIGRyYWdnYWJsZVxuXHRcdGlmKCQudWkuZGRtYW5hZ2VyKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5jdXJyZW50ID0gdGhpcztcblx0XHR9XG5cblx0XHQvKlxuXHRcdCAqIC0gUG9zaXRpb24gZ2VuZXJhdGlvbiAtXG5cdFx0ICogVGhpcyBibG9jayBnZW5lcmF0ZXMgZXZlcnl0aGluZyBwb3NpdGlvbiByZWxhdGVkIC0gaXQncyB0aGUgY29yZSBvZiBkcmFnZ2FibGVzLlxuXHRcdCAqL1xuXG5cdFx0Ly9DYWNoZSB0aGUgbWFyZ2lucyBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudFxuXHRcdHRoaXMuX2NhY2hlTWFyZ2lucygpO1xuXG5cdFx0Ly9TdG9yZSB0aGUgaGVscGVyJ3MgY3NzIHBvc2l0aW9uXG5cdFx0dGhpcy5jc3NQb3NpdGlvbiA9IHRoaXMuaGVscGVyLmNzcyggXCJwb3NpdGlvblwiICk7XG5cdFx0dGhpcy5zY3JvbGxQYXJlbnQgPSB0aGlzLmhlbHBlci5zY3JvbGxQYXJlbnQoKTtcblx0XHR0aGlzLm9mZnNldFBhcmVudCA9IHRoaXMuaGVscGVyLm9mZnNldFBhcmVudCgpO1xuXHRcdHRoaXMub2Zmc2V0UGFyZW50Q3NzUG9zaXRpb24gPSB0aGlzLm9mZnNldFBhcmVudC5jc3MoIFwicG9zaXRpb25cIiApO1xuXG5cdFx0Ly9UaGUgZWxlbWVudCdzIGFic29sdXRlIHBvc2l0aW9uIG9uIHRoZSBwYWdlIG1pbnVzIG1hcmdpbnNcblx0XHR0aGlzLm9mZnNldCA9IHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XG5cdFx0dGhpcy5vZmZzZXQgPSB7XG5cdFx0XHR0b3A6IHRoaXMub2Zmc2V0LnRvcCAtIHRoaXMubWFyZ2lucy50b3AsXG5cdFx0XHRsZWZ0OiB0aGlzLm9mZnNldC5sZWZ0IC0gdGhpcy5tYXJnaW5zLmxlZnRcblx0XHR9O1xuXG5cdFx0Ly9SZXNldCBzY3JvbGwgY2FjaGVcblx0XHR0aGlzLm9mZnNldC5zY3JvbGwgPSBmYWxzZTtcblxuXHRcdCQuZXh0ZW5kKHRoaXMub2Zmc2V0LCB7XG5cdFx0XHRjbGljazogeyAvL1doZXJlIHRoZSBjbGljayBoYXBwZW5lZCwgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0bGVmdDogZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5sZWZ0LFxuXHRcdFx0XHR0b3A6IGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQudG9wXG5cdFx0XHR9LFxuXHRcdFx0cGFyZW50OiB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKSxcblx0XHRcdHJlbGF0aXZlOiB0aGlzLl9nZXRSZWxhdGl2ZU9mZnNldCgpIC8vVGhpcyBpcyBhIHJlbGF0aXZlIHRvIGFic29sdXRlIHBvc2l0aW9uIG1pbnVzIHRoZSBhY3R1YWwgcG9zaXRpb24gY2FsY3VsYXRpb24gLSBvbmx5IHVzZWQgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgaGVscGVyXG5cdFx0fSk7XG5cblx0XHQvL0dlbmVyYXRlIHRoZSBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gPSB0aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKGV2ZW50KTtcblx0XHR0aGlzLm9yaWdpbmFsUGFnZVggPSBldmVudC5wYWdlWDtcblx0XHR0aGlzLm9yaWdpbmFsUGFnZVkgPSBldmVudC5wYWdlWTtcblxuXHRcdC8vQWRqdXN0IHRoZSBtb3VzZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGhlbHBlciBpZiBcImN1cnNvckF0XCIgaXMgc3VwcGxpZWRcblx0XHQoby5jdXJzb3JBdCAmJiB0aGlzLl9hZGp1c3RPZmZzZXRGcm9tSGVscGVyKG8uY3Vyc29yQXQpKTtcblxuXHRcdC8vU2V0IGEgY29udGFpbm1lbnQgaWYgZ2l2ZW4gaW4gdGhlIG9wdGlvbnNcblx0XHR0aGlzLl9zZXRDb250YWlubWVudCgpO1xuXG5cdFx0Ly9UcmlnZ2VyIGV2ZW50ICsgY2FsbGJhY2tzXG5cdFx0aWYodGhpcy5fdHJpZ2dlcihcInN0YXJ0XCIsIGV2ZW50KSA9PT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuX2NsZWFyKCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9SZWNhY2hlIHRoZSBoZWxwZXIgc2l6ZVxuXHRcdHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTtcblxuXHRcdC8vUHJlcGFyZSB0aGUgZHJvcHBhYmxlIG9mZnNldHNcblx0XHRpZiAoJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91cikge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHModGhpcywgZXZlbnQpO1xuXHRcdH1cblxuXG5cdFx0dGhpcy5fbW91c2VEcmFnKGV2ZW50LCB0cnVlKTsgLy9FeGVjdXRlIHRoZSBkcmFnIG9uY2UgLSB0aGlzIGNhdXNlcyB0aGUgaGVscGVyIG5vdCB0byBiZSB2aXNpYmxlIGJlZm9yZSBnZXR0aW5nIGl0cyBjb3JyZWN0IHBvc2l0aW9uXG5cblx0XHQvL0lmIHRoZSBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIHRoYXQgZHJhZ2dpbmcgaGFzIHN0YXJ0ZWQgKHNlZSAjNTAwMylcblx0XHRpZiAoICQudWkuZGRtYW5hZ2VyICkge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIuZHJhZ1N0YXJ0KHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbihldmVudCwgbm9Qcm9wYWdhdGlvbikge1xuXHRcdC8vIHJlc2V0IGFueSBuZWNlc3NhcnkgY2FjaGVkIHByb3BlcnRpZXMgKHNlZSAjNTAwOSlcblx0XHRpZiAoIHRoaXMub2Zmc2V0UGFyZW50Q3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudCA9IHRoaXMuX2dldFBhcmVudE9mZnNldCgpO1xuXHRcdH1cblxuXHRcdC8vQ29tcHV0ZSB0aGUgaGVscGVycyBwb3NpdGlvblxuXHRcdHRoaXMucG9zaXRpb24gPSB0aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKGV2ZW50KTtcblx0XHR0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5fY29udmVydFBvc2l0aW9uVG8oXCJhYnNvbHV0ZVwiKTtcblxuXHRcdC8vQ2FsbCBwbHVnaW5zIGFuZCBjYWxsYmFja3MgYW5kIHVzZSB0aGUgcmVzdWx0aW5nIHBvc2l0aW9uIGlmIHNvbWV0aGluZyBpcyByZXR1cm5lZFxuXHRcdGlmICghbm9Qcm9wYWdhdGlvbikge1xuXHRcdFx0dmFyIHVpID0gdGhpcy5fdWlIYXNoKCk7XG5cdFx0XHRpZih0aGlzLl90cmlnZ2VyKFwiZHJhZ1wiLCBldmVudCwgdWkpID09PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9tb3VzZVVwKHt9KTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wb3NpdGlvbiA9IHVpLnBvc2l0aW9uO1xuXHRcdH1cblxuXHRcdGlmKCF0aGlzLm9wdGlvbnMuYXhpcyB8fCB0aGlzLm9wdGlvbnMuYXhpcyAhPT0gXCJ5XCIpIHtcblx0XHRcdHRoaXMuaGVscGVyWzBdLnN0eWxlLmxlZnQgPSB0aGlzLnBvc2l0aW9uLmxlZnQrXCJweFwiO1xuXHRcdH1cblx0XHRpZighdGhpcy5vcHRpb25zLmF4aXMgfHwgdGhpcy5vcHRpb25zLmF4aXMgIT09IFwieFwiKSB7XG5cdFx0XHR0aGlzLmhlbHBlclswXS5zdHlsZS50b3AgPSB0aGlzLnBvc2l0aW9uLnRvcCtcInB4XCI7XG5cdFx0fVxuXHRcdGlmKCQudWkuZGRtYW5hZ2VyKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5kcmFnKHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlU3RvcDogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdC8vSWYgd2UgYXJlIHVzaW5nIGRyb3BwYWJsZXMsIGluZm9ybSB0aGUgbWFuYWdlciBhYm91dCB0aGUgZHJvcFxuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdGRyb3BwZWQgPSBmYWxzZTtcblx0XHRpZiAoJC51aS5kZG1hbmFnZXIgJiYgIXRoaXMub3B0aW9ucy5kcm9wQmVoYXZpb3VyKSB7XG5cdFx0XHRkcm9wcGVkID0gJC51aS5kZG1hbmFnZXIuZHJvcCh0aGlzLCBldmVudCk7XG5cdFx0fVxuXG5cdFx0Ly9pZiBhIGRyb3AgY29tZXMgZnJvbSBvdXRzaWRlIChhIHNvcnRhYmxlKVxuXHRcdGlmKHRoaXMuZHJvcHBlZCkge1xuXHRcdFx0ZHJvcHBlZCA9IHRoaXMuZHJvcHBlZDtcblx0XHRcdHRoaXMuZHJvcHBlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vaWYgdGhlIG9yaWdpbmFsIGVsZW1lbnQgaXMgbm8gbG9uZ2VyIGluIHRoZSBET00gZG9uJ3QgYm90aGVyIHRvIGNvbnRpbnVlIChzZWUgIzgyNjkpXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuaGVscGVyID09PSBcIm9yaWdpbmFsXCIgJiYgISQuY29udGFpbnMoIHRoaXMuZWxlbWVudFsgMCBdLm93bmVyRG9jdW1lbnQsIHRoaXMuZWxlbWVudFsgMCBdICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYoKHRoaXMub3B0aW9ucy5yZXZlcnQgPT09IFwiaW52YWxpZFwiICYmICFkcm9wcGVkKSB8fCAodGhpcy5vcHRpb25zLnJldmVydCA9PT0gXCJ2YWxpZFwiICYmIGRyb3BwZWQpIHx8IHRoaXMub3B0aW9ucy5yZXZlcnQgPT09IHRydWUgfHwgKCQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMucmV2ZXJ0KSAmJiB0aGlzLm9wdGlvbnMucmV2ZXJ0LmNhbGwodGhpcy5lbGVtZW50LCBkcm9wcGVkKSkpIHtcblx0XHRcdCQodGhpcy5oZWxwZXIpLmFuaW1hdGUodGhpcy5vcmlnaW5hbFBvc2l0aW9uLCBwYXJzZUludCh0aGlzLm9wdGlvbnMucmV2ZXJ0RHVyYXRpb24sIDEwKSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHRoYXQuX3RyaWdnZXIoXCJzdG9wXCIsIGV2ZW50KSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGF0Ll9jbGVhcigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYodGhpcy5fdHJpZ2dlcihcInN0b3BcIiwgZXZlbnQpICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9jbGVhcigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VVcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvL1JlbW92ZSBmcmFtZSBoZWxwZXJzXG5cdFx0JChcImRpdi51aS1kcmFnZ2FibGUtaWZyYW1lRml4XCIpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XG5cdFx0fSk7XG5cblx0XHQvL0lmIHRoZSBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIHRoYXQgZHJhZ2dpbmcgaGFzIHN0b3BwZWQgKHNlZSAjNTAwMylcblx0XHRpZiggJC51aS5kZG1hbmFnZXIgKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5kcmFnU3RvcCh0aGlzLCBldmVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICQudWkubW91c2UucHJvdG90eXBlLl9tb3VzZVVwLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9LFxuXG5cdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cblx0XHRpZih0aGlzLmhlbHBlci5pcyhcIi51aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIikpIHtcblx0XHRcdHRoaXMuX21vdXNlVXAoe30pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jbGVhcigpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0X2dldEhhbmRsZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmhhbmRsZSA/XG5cdFx0XHQhISQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIHRoaXMuZWxlbWVudC5maW5kKCB0aGlzLm9wdGlvbnMuaGFuZGxlICkgKS5sZW5ndGggOlxuXHRcdFx0dHJ1ZTtcblx0fSxcblxuXHRfY3JlYXRlSGVscGVyOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRoZWxwZXIgPSAkLmlzRnVuY3Rpb24oby5oZWxwZXIpID8gJChvLmhlbHBlci5hcHBseSh0aGlzLmVsZW1lbnRbMF0sIFtldmVudF0pKSA6IChvLmhlbHBlciA9PT0gXCJjbG9uZVwiID8gdGhpcy5lbGVtZW50LmNsb25lKCkucmVtb3ZlQXR0cihcImlkXCIpIDogdGhpcy5lbGVtZW50KTtcblxuXHRcdGlmKCFoZWxwZXIucGFyZW50cyhcImJvZHlcIikubGVuZ3RoKSB7XG5cdFx0XHRoZWxwZXIuYXBwZW5kVG8oKG8uYXBwZW5kVG8gPT09IFwicGFyZW50XCIgPyB0aGlzLmVsZW1lbnRbMF0ucGFyZW50Tm9kZSA6IG8uYXBwZW5kVG8pKTtcblx0XHR9XG5cblx0XHRpZihoZWxwZXJbMF0gIT09IHRoaXMuZWxlbWVudFswXSAmJiAhKC8oZml4ZWR8YWJzb2x1dGUpLykudGVzdChoZWxwZXIuY3NzKFwicG9zaXRpb25cIikpKSB7XG5cdFx0XHRoZWxwZXIuY3NzKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGVscGVyO1xuXG5cdH0sXG5cblx0X2FkanVzdE9mZnNldEZyb21IZWxwZXI6IGZ1bmN0aW9uKG9iaikge1xuXHRcdGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRvYmogPSBvYmouc3BsaXQoXCIgXCIpO1xuXHRcdH1cblx0XHRpZiAoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdG9iaiA9IHtsZWZ0OiArb2JqWzBdLCB0b3A6ICtvYmpbMV0gfHwgMH07XG5cdFx0fVxuXHRcdGlmIChcImxlZnRcIiBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPSBvYmoubGVmdCArIHRoaXMubWFyZ2lucy5sZWZ0O1xuXHRcdH1cblx0XHRpZiAoXCJyaWdodFwiIGluIG9iaikge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCA9IHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSBvYmoucmlnaHQgKyB0aGlzLm1hcmdpbnMubGVmdDtcblx0XHR9XG5cdFx0aWYgKFwidG9wXCIgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3AgPSBvYmoudG9wICsgdGhpcy5tYXJnaW5zLnRvcDtcblx0XHR9XG5cdFx0aWYgKFwiYm90dG9tXCIgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3AgPSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIG9iai5ib3R0b20gKyB0aGlzLm1hcmdpbnMudG9wO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0UGFyZW50T2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdC8vR2V0IHRoZSBvZmZzZXRQYXJlbnQgYW5kIGNhY2hlIGl0cyBwb3NpdGlvblxuXHRcdHZhciBwbyA9IHRoaXMub2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIG1vZGlmeSBhIG9mZnNldCBjYWxjdWxhdGVkIG9uIHN0YXJ0LCBzaW5jZSB0aGUgZm9sbG93aW5nIGhhcHBlbmVkOlxuXHRcdC8vIDEuIFRoZSBwb3NpdGlvbiBvZiB0aGUgaGVscGVyIGlzIGFic29sdXRlLCBzbyBpdCdzIHBvc2l0aW9uIGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIG5leHQgcG9zaXRpb25lZCBwYXJlbnRcblx0XHQvLyAyLiBUaGUgYWN0dWFsIG9mZnNldCBwYXJlbnQgaXMgYSBjaGlsZCBvZiB0aGUgc2Nyb2xsIHBhcmVudCwgYW5kIHRoZSBzY3JvbGwgcGFyZW50IGlzbid0IHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhhdFxuXHRcdC8vICAgIHRoZSBzY3JvbGwgaXMgaW5jbHVkZWQgaW4gdGhlIGluaXRpYWwgY2FsY3VsYXRpb24gb2YgdGhlIG9mZnNldCBvZiB0aGUgcGFyZW50LCBhbmQgbmV2ZXIgcmVjYWxjdWxhdGVkIHVwb24gZHJhZ1xuXHRcdGlmKHRoaXMuY3NzUG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiAmJiB0aGlzLnNjcm9sbFBhcmVudFswXSAhPT0gZG9jdW1lbnQgJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSB7XG5cdFx0XHRwby5sZWZ0ICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKTtcblx0XHRcdHBvLnRvcCArPSB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKTtcblx0XHR9XG5cblx0XHQvL1RoaXMgbmVlZHMgdG8gYmUgYWN0dWFsbHkgZG9uZSBmb3IgYWxsIGJyb3dzZXJzLCBzaW5jZSBwYWdlWC9wYWdlWSBpbmNsdWRlcyB0aGlzIGluZm9ybWF0aW9uXG5cdFx0Ly9VZ2x5IElFIGZpeFxuXHRcdGlmKCh0aGlzLm9mZnNldFBhcmVudFswXSA9PT0gZG9jdW1lbnQuYm9keSkgfHxcblx0XHRcdCh0aGlzLm9mZnNldFBhcmVudFswXS50YWdOYW1lICYmIHRoaXMub2Zmc2V0UGFyZW50WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJodG1sXCIgJiYgJC51aS5pZSkpIHtcblx0XHRcdHBvID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBwby50b3AgKyAocGFyc2VJbnQodGhpcy5vZmZzZXRQYXJlbnQuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksMTApIHx8IDApLFxuXHRcdFx0bGVmdDogcG8ubGVmdCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIiksMTApIHx8IDApXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9nZXRSZWxhdGl2ZU9mZnNldDogZnVuY3Rpb24oKSB7XG5cblx0XHRpZih0aGlzLmNzc1Bvc2l0aW9uID09PSBcInJlbGF0aXZlXCIpIHtcblx0XHRcdHZhciBwID0gdGhpcy5lbGVtZW50LnBvc2l0aW9uKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0b3A6IHAudG9wIC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcInRvcFwiKSwxMCkgfHwgMCkgKyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSxcblx0XHRcdFx0bGVmdDogcC5sZWZ0IC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcImxlZnRcIiksMTApIHx8IDApICsgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0fSxcblxuXHRfY2FjaGVNYXJnaW5zOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLm1hcmdpbnMgPSB7XG5cdFx0XHRsZWZ0OiAocGFyc2VJbnQodGhpcy5lbGVtZW50LmNzcyhcIm1hcmdpbkxlZnRcIiksMTApIHx8IDApLFxuXHRcdFx0dG9wOiAocGFyc2VJbnQodGhpcy5lbGVtZW50LmNzcyhcIm1hcmdpblRvcFwiKSwxMCkgfHwgMCksXG5cdFx0XHRyaWdodDogKHBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXCJtYXJnaW5SaWdodFwiKSwxMCkgfHwgMCksXG5cdFx0XHRib3R0b206IChwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFwibWFyZ2luQm90dG9tXCIpLDEwKSB8fCAwKVxuXHRcdH07XG5cdH0sXG5cblx0X2NhY2hlSGVscGVyUHJvcG9ydGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMgPSB7XG5cdFx0XHR3aWR0aDogdGhpcy5oZWxwZXIub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiB0aGlzLmhlbHBlci5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0fSxcblxuXHRfc2V0Q29udGFpbm1lbnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG92ZXIsIGMsIGNlLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICggIW8uY29udGFpbm1lbnQgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gbnVsbDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQgPT09IFwid2luZG93XCIgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0XHQkKCB3aW5kb3cgKS5zY3JvbGxMZWZ0KCkgLSB0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0IC0gdGhpcy5vZmZzZXQucGFyZW50LmxlZnQsXG5cdFx0XHRcdCQoIHdpbmRvdyApLnNjcm9sbFRvcCgpIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcCxcblx0XHRcdFx0JCggd2luZG93ICkuc2Nyb2xsTGVmdCgpICsgJCggd2luZG93ICkud2lkdGgoKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCxcblx0XHRcdFx0JCggd2luZG93ICkuc2Nyb2xsVG9wKCkgKyAoICQoIHdpbmRvdyApLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQgKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcFxuXHRcdFx0XTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQgPT09IFwiZG9jdW1lbnRcIikge1xuXHRcdFx0dGhpcy5jb250YWlubWVudCA9IFtcblx0XHRcdFx0MCxcblx0XHRcdFx0MCxcblx0XHRcdFx0JCggZG9jdW1lbnQgKS53aWR0aCgpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0XHQoICQoIGRvY3VtZW50ICkuaGVpZ2h0KCkgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbEhlaWdodCApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XHRdO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggby5jb250YWlubWVudC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gby5jb250YWlubWVudDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQgPT09IFwicGFyZW50XCIgKSB7XG5cdFx0XHRvLmNvbnRhaW5tZW50ID0gdGhpcy5oZWxwZXJbIDAgXS5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdGMgPSAkKCBvLmNvbnRhaW5tZW50ICk7XG5cdFx0Y2UgPSBjWyAwIF07XG5cblx0XHRpZiggIWNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG92ZXIgPSBjLmNzcyggXCJvdmVyZmxvd1wiICkgIT09IFwiaGlkZGVuXCI7XG5cblx0XHR0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0KCBwYXJzZUludCggYy5jc3MoIFwiYm9yZGVyTGVmdFdpZHRoXCIgKSwgMTAgKSB8fCAwICkgKyAoIHBhcnNlSW50KCBjLmNzcyggXCJwYWRkaW5nTGVmdFwiICksIDEwICkgfHwgMCApLFxuXHRcdFx0KCBwYXJzZUludCggYy5jc3MoIFwiYm9yZGVyVG9wV2lkdGhcIiApLCAxMCApIHx8IDAgKSArICggcGFyc2VJbnQoIGMuY3NzKCBcInBhZGRpbmdUb3BcIiApLCAxMCApIHx8IDAgKSAsXG5cdFx0XHQoIG92ZXIgPyBNYXRoLm1heCggY2Uuc2Nyb2xsV2lkdGgsIGNlLm9mZnNldFdpZHRoICkgOiBjZS5vZmZzZXRXaWR0aCApIC0gKCBwYXJzZUludCggYy5jc3MoIFwiYm9yZGVyUmlnaHRXaWR0aFwiICksIDEwICkgfHwgMCApIC0gKCBwYXJzZUludCggYy5jc3MoIFwicGFkZGluZ1JpZ2h0XCIgKSwgMTAgKSB8fCAwICkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gdGhpcy5tYXJnaW5zLmxlZnQgLSB0aGlzLm1hcmdpbnMucmlnaHQsXG5cdFx0XHQoIG92ZXIgPyBNYXRoLm1heCggY2Uuc2Nyb2xsSGVpZ2h0LCBjZS5vZmZzZXRIZWlnaHQgKSA6IGNlLm9mZnNldEhlaWdodCApIC0gKCBwYXJzZUludCggYy5jc3MoIFwiYm9yZGVyQm90dG9tV2lkdGhcIiApLCAxMCApIHx8IDAgKSAtICggcGFyc2VJbnQoIGMuY3NzKCBcInBhZGRpbmdCb3R0b21cIiApLCAxMCApIHx8IDAgKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcCAgLSB0aGlzLm1hcmdpbnMuYm90dG9tXG5cdFx0XTtcblx0XHR0aGlzLnJlbGF0aXZlX2NvbnRhaW5lciA9IGM7XG5cdH0sXG5cblx0X2NvbnZlcnRQb3NpdGlvblRvOiBmdW5jdGlvbihkLCBwb3MpIHtcblxuXHRcdGlmKCFwb3MpIHtcblx0XHRcdHBvcyA9IHRoaXMucG9zaXRpb247XG5cdFx0fVxuXG5cdFx0dmFyIG1vZCA9IGQgPT09IFwiYWJzb2x1dGVcIiA/IDEgOiAtMSxcblx0XHRcdHNjcm9sbCA9IHRoaXMuY3NzUG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiAmJiAhKCB0aGlzLnNjcm9sbFBhcmVudFsgMCBdICE9PSBkb2N1bWVudCAmJiAkLmNvbnRhaW5zKCB0aGlzLnNjcm9sbFBhcmVudFsgMCBdLCB0aGlzLm9mZnNldFBhcmVudFsgMCBdICkgKSA/IHRoaXMub2Zmc2V0UGFyZW50IDogdGhpcy5zY3JvbGxQYXJlbnQ7XG5cblx0XHQvL0NhY2hlIHRoZSBzY3JvbGxcblx0XHRpZiAoIXRoaXMub2Zmc2V0LnNjcm9sbCkge1xuXHRcdFx0dGhpcy5vZmZzZXQuc2Nyb2xsID0ge3RvcCA6IHNjcm9sbC5zY3JvbGxUb3AoKSwgbGVmdCA6IHNjcm9sbC5zY3JvbGxMZWZ0KCl9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblx0XHRcdFx0cG9zLnRvcFx0K1x0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAqIG1vZCArXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0dGhpcy5vZmZzZXQucGFyZW50LnRvcCAqIG1vZCAtXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQoICggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpIDogdGhpcy5vZmZzZXQuc2Nyb2xsLnRvcCApICogbW9kIClcblx0XHRcdCksXG5cdFx0XHRsZWZ0OiAoXG5cdFx0XHRcdHBvcy5sZWZ0ICtcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0ICogbW9kICtcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQubGVmdCAqIG1vZFx0LVx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KCAoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiB0aGlzLm9mZnNldC5zY3JvbGwubGVmdCApICogbW9kIClcblx0XHRcdClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2dlbmVyYXRlUG9zaXRpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgY29udGFpbm1lbnQsIGNvLCB0b3AsIGxlZnQsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0c2Nyb2xsID0gdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiICYmICEoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0gIT09IGRvY3VtZW50ICYmICQuY29udGFpbnMoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0sIHRoaXMub2Zmc2V0UGFyZW50WyAwIF0gKSApID8gdGhpcy5vZmZzZXRQYXJlbnQgOiB0aGlzLnNjcm9sbFBhcmVudCxcblx0XHRcdHBhZ2VYID0gZXZlbnQucGFnZVgsXG5cdFx0XHRwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuXG5cdFx0Ly9DYWNoZSB0aGUgc2Nyb2xsXG5cdFx0aWYgKCF0aGlzLm9mZnNldC5zY3JvbGwpIHtcblx0XHRcdHRoaXMub2Zmc2V0LnNjcm9sbCA9IHt0b3AgOiBzY3JvbGwuc2Nyb2xsVG9wKCksIGxlZnQgOiBzY3JvbGwuc2Nyb2xsTGVmdCgpfTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCAqIC0gUG9zaXRpb24gY29uc3RyYWluaW5nIC1cblx0XHQgKiBDb25zdHJhaW4gdGhlIHBvc2l0aW9uIHRvIGEgbWl4IG9mIGdyaWQsIGNvbnRhaW5tZW50LlxuXHRcdCAqL1xuXG5cdFx0Ly8gSWYgd2UgYXJlIG5vdCBkcmFnZ2luZyB5ZXQsIHdlIHdvbid0IGNoZWNrIGZvciBvcHRpb25zXG5cdFx0aWYgKCB0aGlzLm9yaWdpbmFsUG9zaXRpb24gKSB7XG5cdFx0XHRpZiAoIHRoaXMuY29udGFpbm1lbnQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5yZWxhdGl2ZV9jb250YWluZXIgKXtcblx0XHRcdFx0XHRjbyA9IHRoaXMucmVsYXRpdmVfY29udGFpbmVyLm9mZnNldCgpO1xuXHRcdFx0XHRcdGNvbnRhaW5tZW50ID0gW1xuXHRcdFx0XHRcdFx0dGhpcy5jb250YWlubWVudFsgMCBdICsgY28ubGVmdCxcblx0XHRcdFx0XHRcdHRoaXMuY29udGFpbm1lbnRbIDEgXSArIGNvLnRvcCxcblx0XHRcdFx0XHRcdHRoaXMuY29udGFpbm1lbnRbIDIgXSArIGNvLmxlZnQsXG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRhaW5tZW50WyAzIF0gKyBjby50b3Bcblx0XHRcdFx0XHRdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRhaW5tZW50ID0gdGhpcy5jb250YWlubWVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA8IGNvbnRhaW5tZW50WzBdKSB7XG5cdFx0XHRcdFx0cGFnZVggPSBjb250YWlubWVudFswXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPCBjb250YWlubWVudFsxXSkge1xuXHRcdFx0XHRcdHBhZ2VZID0gY29udGFpbm1lbnRbMV0gKyB0aGlzLm9mZnNldC5jbGljay50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID4gY29udGFpbm1lbnRbMl0pIHtcblx0XHRcdFx0XHRwYWdlWCA9IGNvbnRhaW5tZW50WzJdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+IGNvbnRhaW5tZW50WzNdKSB7XG5cdFx0XHRcdFx0cGFnZVkgPSBjb250YWlubWVudFszXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihvLmdyaWQpIHtcblx0XHRcdFx0Ly9DaGVjayBmb3IgZ3JpZCBlbGVtZW50cyBzZXQgdG8gMCB0byBwcmV2ZW50IGRpdmlkZSBieSAwIGVycm9yIGNhdXNpbmcgaW52YWxpZCBhcmd1bWVudCBlcnJvcnMgaW4gSUUgKHNlZSB0aWNrZXQgIzY5NTApXG5cdFx0XHRcdHRvcCA9IG8uZ3JpZFsxXSA/IHRoaXMub3JpZ2luYWxQYWdlWSArIE1hdGgucm91bmQoKHBhZ2VZIC0gdGhpcy5vcmlnaW5hbFBhZ2VZKSAvIG8uZ3JpZFsxXSkgKiBvLmdyaWRbMV0gOiB0aGlzLm9yaWdpbmFsUGFnZVk7XG5cdFx0XHRcdHBhZ2VZID0gY29udGFpbm1lbnQgPyAoKHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSBjb250YWlubWVudFsxXSB8fCB0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPiBjb250YWlubWVudFszXSkgPyB0b3AgOiAoKHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSBjb250YWlubWVudFsxXSkgPyB0b3AgLSBvLmdyaWRbMV0gOiB0b3AgKyBvLmdyaWRbMV0pKSA6IHRvcDtcblxuXHRcdFx0XHRsZWZ0ID0gby5ncmlkWzBdID8gdGhpcy5vcmlnaW5hbFBhZ2VYICsgTWF0aC5yb3VuZCgocGFnZVggLSB0aGlzLm9yaWdpbmFsUGFnZVgpIC8gby5ncmlkWzBdKSAqIG8uZ3JpZFswXSA6IHRoaXMub3JpZ2luYWxQYWdlWDtcblx0XHRcdFx0cGFnZVggPSBjb250YWlubWVudCA/ICgobGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPj0gY29udGFpbm1lbnRbMF0gfHwgbGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPiBjb250YWlubWVudFsyXSkgPyBsZWZ0IDogKChsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+PSBjb250YWlubWVudFswXSkgPyBsZWZ0IC0gby5ncmlkWzBdIDogbGVmdCArIG8uZ3JpZFswXSkpIDogbGVmdDtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblx0XHRcdFx0cGFnZVkgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0dGhpcy5vZmZzZXQuY2xpY2sudG9wXHQtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2xpY2sgb2Zmc2V0IChyZWxhdGl2ZSB0byB0aGUgZWxlbWVudClcblx0XHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0dGhpcy5vZmZzZXQucGFyZW50LnRvcCArXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCkgOiB0aGlzLm9mZnNldC5zY3JvbGwudG9wIClcblx0XHRcdCksXG5cdFx0XHRsZWZ0OiAoXG5cdFx0XHRcdHBhZ2VYIC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQubGVmdCArXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpIDogdGhpcy5vZmZzZXQuc2Nyb2xsLmxlZnQgKVxuXHRcdFx0KVxuXHRcdH07XG5cblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVscGVyLnJlbW92ZUNsYXNzKFwidWktZHJhZ2dhYmxlLWRyYWdnaW5nXCIpO1xuXHRcdGlmKHRoaXMuaGVscGVyWzBdICE9PSB0aGlzLmVsZW1lbnRbMF0gJiYgIXRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbCkge1xuXHRcdFx0dGhpcy5oZWxwZXIucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHRoaXMuaGVscGVyID0gbnVsbDtcblx0XHR0aGlzLmNhbmNlbEhlbHBlclJlbW92YWwgPSBmYWxzZTtcblx0fSxcblxuXHQvLyBGcm9tIG5vdyBvbiBidWxrIHN0dWZmIC0gbWFpbmx5IGhlbHBlcnNcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24odHlwZSwgZXZlbnQsIHVpKSB7XG5cdFx0dWkgPSB1aSB8fCB0aGlzLl91aUhhc2goKTtcblx0XHQkLnVpLnBsdWdpbi5jYWxsKHRoaXMsIHR5cGUsIFtldmVudCwgdWldKTtcblx0XHQvL1RoZSBhYnNvbHV0ZSBwb3NpdGlvbiBoYXMgdG8gYmUgcmVjYWxjdWxhdGVkIGFmdGVyIHBsdWdpbnNcblx0XHRpZih0eXBlID09PSBcImRyYWdcIikge1xuXHRcdFx0dGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKFwiYWJzb2x1dGVcIik7XG5cdFx0fVxuXHRcdHJldHVybiAkLldpZGdldC5wcm90b3R5cGUuX3RyaWdnZXIuY2FsbCh0aGlzLCB0eXBlLCBldmVudCwgdWkpO1xuXHR9LFxuXG5cdHBsdWdpbnM6IHt9LFxuXG5cdF91aUhhc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRoZWxwZXI6IHRoaXMuaGVscGVyLFxuXHRcdFx0cG9zaXRpb246IHRoaXMucG9zaXRpb24sXG5cdFx0XHRvcmlnaW5hbFBvc2l0aW9uOiB0aGlzLm9yaWdpbmFsUG9zaXRpb24sXG5cdFx0XHRvZmZzZXQ6IHRoaXMucG9zaXRpb25BYnNcblx0XHR9O1xuXHR9XG5cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJjb25uZWN0VG9Tb3J0YWJsZVwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLCBvID0gaW5zdC5vcHRpb25zLFxuXHRcdFx0dWlTb3J0YWJsZSA9ICQuZXh0ZW5kKHt9LCB1aSwgeyBpdGVtOiBpbnN0LmVsZW1lbnQgfSk7XG5cdFx0aW5zdC5zb3J0YWJsZXMgPSBbXTtcblx0XHQkKG8uY29ubmVjdFRvU29ydGFibGUpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc29ydGFibGUgPSAkLmRhdGEodGhpcywgXCJ1aS1zb3J0YWJsZVwiKTtcblx0XHRcdGlmIChzb3J0YWJsZSAmJiAhc29ydGFibGUub3B0aW9ucy5kaXNhYmxlZCkge1xuXHRcdFx0XHRpbnN0LnNvcnRhYmxlcy5wdXNoKHtcblx0XHRcdFx0XHRpbnN0YW5jZTogc29ydGFibGUsXG5cdFx0XHRcdFx0c2hvdWxkUmV2ZXJ0OiBzb3J0YWJsZS5vcHRpb25zLnJldmVydFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29ydGFibGUucmVmcmVzaFBvc2l0aW9ucygpO1x0Ly8gQ2FsbCB0aGUgc29ydGFibGUncyByZWZyZXNoUG9zaXRpb25zIGF0IGRyYWcgc3RhcnQgdG8gcmVmcmVzaCB0aGUgY29udGFpbmVyQ2FjaGUgc2luY2UgdGhlIHNvcnRhYmxlIGNvbnRhaW5lciBjYWNoZSBpcyB1c2VkIGluIGRyYWcgYW5kIG5lZWRzIHRvIGJlIHVwIHRvIGRhdGUgKHRoaXMgd2lsbCBlbnN1cmUgaXQncyBpbml0aWFsaXNlZCBhcyB3ZWxsIGFzIGJlaW5nIGtlcHQgaW4gc3RlcCB3aXRoIGFueSBjaGFuZ2VzIHRoYXQgbWlnaHQgaGF2ZSBoYXBwZW5lZCBvbiB0aGUgcGFnZSkuXG5cdFx0XHRcdHNvcnRhYmxlLl90cmlnZ2VyKFwiYWN0aXZhdGVcIiwgZXZlbnQsIHVpU29ydGFibGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0Ly9JZiB3ZSBhcmUgc3RpbGwgb3ZlciB0aGUgc29ydGFibGUsIHdlIGZha2UgdGhlIHN0b3AgZXZlbnQgb2YgdGhlIHNvcnRhYmxlLCBidXQgYWxzbyByZW1vdmUgaGVscGVyXG5cdFx0dmFyIGluc3QgPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIiksXG5cdFx0XHR1aVNvcnRhYmxlID0gJC5leHRlbmQoe30sIHVpLCB7IGl0ZW06IGluc3QuZWxlbWVudCB9KTtcblxuXHRcdCQuZWFjaChpbnN0LnNvcnRhYmxlcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZih0aGlzLmluc3RhbmNlLmlzT3Zlcikge1xuXG5cdFx0XHRcdHRoaXMuaW5zdGFuY2UuaXNPdmVyID0gMDtcblxuXHRcdFx0XHRpbnN0LmNhbmNlbEhlbHBlclJlbW92YWwgPSB0cnVlOyAvL0Rvbid0IHJlbW92ZSB0aGUgaGVscGVyIGluIHRoZSBkcmFnZ2FibGUgaW5zdGFuY2Vcblx0XHRcdFx0dGhpcy5pbnN0YW5jZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gZmFsc2U7IC8vUmVtb3ZlIGl0IGluIHRoZSBzb3J0YWJsZSBpbnN0YW5jZSAoc28gc29ydGFibGUgcGx1Z2lucyBsaWtlIHJldmVydCBzdGlsbCB3b3JrKVxuXG5cdFx0XHRcdC8vVGhlIHNvcnRhYmxlIHJldmVydCBpcyBzdXBwb3J0ZWQsIGFuZCB3ZSBoYXZlIHRvIHNldCBhIHRlbXBvcmFyeSBkcm9wcGVkIHZhcmlhYmxlIG9uIHRoZSBkcmFnZ2FibGUgdG8gc3VwcG9ydCByZXZlcnQ6IFwidmFsaWQvaW52YWxpZFwiXG5cdFx0XHRcdGlmKHRoaXMuc2hvdWxkUmV2ZXJ0KSB7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vcHRpb25zLnJldmVydCA9IHRoaXMuc2hvdWxkUmV2ZXJ0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9UcmlnZ2VyIHRoZSBzdG9wIG9mIHRoZSBzb3J0YWJsZVxuXHRcdFx0XHR0aGlzLmluc3RhbmNlLl9tb3VzZVN0b3AoZXZlbnQpO1xuXG5cdFx0XHRcdHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5oZWxwZXIgPSB0aGlzLmluc3RhbmNlLm9wdGlvbnMuX2hlbHBlcjtcblxuXHRcdFx0XHQvL0lmIHRoZSBoZWxwZXIgaGFzIGJlZW4gdGhlIG9yaWdpbmFsIGl0ZW0sIHJlc3RvcmUgcHJvcGVydGllcyBpbiB0aGUgc29ydGFibGVcblx0XHRcdFx0aWYoaW5zdC5vcHRpb25zLmhlbHBlciA9PT0gXCJvcmlnaW5hbFwiKSB7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5jdXJyZW50SXRlbS5jc3MoeyB0b3A6IFwiYXV0b1wiLCBsZWZ0OiBcImF1dG9cIiB9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluc3RhbmNlLmNhbmNlbEhlbHBlclJlbW92YWwgPSBmYWxzZTsgLy9SZW1vdmUgdGhlIGhlbHBlciBpbiB0aGUgc29ydGFibGUgaW5zdGFuY2Vcblx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fdHJpZ2dlcihcImRlYWN0aXZhdGVcIiwgZXZlbnQsIHVpU29ydGFibGUpO1xuXHRcdFx0fVxuXG5cdFx0fSk7XG5cblx0fSxcblx0ZHJhZzogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cblx0XHR2YXIgaW5zdCA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKSwgdGhhdCA9IHRoaXM7XG5cblx0XHQkLmVhY2goaW5zdC5zb3J0YWJsZXMsIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR2YXIgaW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gZmFsc2UsXG5cdFx0XHRcdHRoaXNTb3J0YWJsZSA9IHRoaXM7XG5cblx0XHRcdC8vQ29weSBvdmVyIHNvbWUgdmFyaWFibGVzIHRvIGFsbG93IGNhbGxpbmcgdGhlIHNvcnRhYmxlJ3MgbmF0aXZlIF9pbnRlcnNlY3RzV2l0aFxuXHRcdFx0dGhpcy5pbnN0YW5jZS5wb3NpdGlvbkFicyA9IGluc3QucG9zaXRpb25BYnM7XG5cdFx0XHR0aGlzLmluc3RhbmNlLmhlbHBlclByb3BvcnRpb25zID0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucztcblx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LmNsaWNrID0gaW5zdC5vZmZzZXQuY2xpY2s7XG5cblx0XHRcdGlmKHRoaXMuaW5zdGFuY2UuX2ludGVyc2VjdHNXaXRoKHRoaXMuaW5zdGFuY2UuY29udGFpbmVyQ2FjaGUpKSB7XG5cdFx0XHRcdGlubmVybW9zdEludGVyc2VjdGluZyA9IHRydWU7XG5cdFx0XHRcdCQuZWFjaChpbnN0LnNvcnRhYmxlcywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UucG9zaXRpb25BYnMgPSBpbnN0LnBvc2l0aW9uQWJzO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuaGVscGVyUHJvcG9ydGlvbnMgPSBpbnN0LmhlbHBlclByb3BvcnRpb25zO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LmNsaWNrID0gaW5zdC5vZmZzZXQuY2xpY2s7XG5cdFx0XHRcdFx0aWYgKHRoaXMgIT09IHRoaXNTb3J0YWJsZSAmJlxuXHRcdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5faW50ZXJzZWN0c1dpdGgodGhpcy5pbnN0YW5jZS5jb250YWluZXJDYWNoZSkgJiZcblx0XHRcdFx0XHRcdCQuY29udGFpbnModGhpc1NvcnRhYmxlLmluc3RhbmNlLmVsZW1lbnRbMF0sIHRoaXMuaW5zdGFuY2UuZWxlbWVudFswXSlcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdGlubmVybW9zdEludGVyc2VjdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaW5uZXJtb3N0SW50ZXJzZWN0aW5nO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXG5cdFx0XHRpZihpbm5lcm1vc3RJbnRlcnNlY3RpbmcpIHtcblx0XHRcdFx0Ly9JZiBpdCBpbnRlcnNlY3RzLCB3ZSB1c2UgYSBsaXR0bGUgaXNPdmVyIHZhcmlhYmxlIGFuZCBzZXQgaXQgb25jZSwgc28gb3VyIG1vdmUtaW4gc3R1ZmYgZ2V0cyBmaXJlZCBvbmx5IG9uY2Vcblx0XHRcdFx0aWYoIXRoaXMuaW5zdGFuY2UuaXNPdmVyKSB7XG5cblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmlzT3ZlciA9IDE7XG5cdFx0XHRcdFx0Ly9Ob3cgd2UgZmFrZSB0aGUgc3RhcnQgb2YgZHJhZ2dpbmcgZm9yIHRoZSBzb3J0YWJsZSBpbnN0YW5jZSxcblx0XHRcdFx0XHQvL2J5IGNsb25pbmcgdGhlIGxpc3QgZ3JvdXAgaXRlbSwgYXBwZW5kaW5nIGl0IHRvIHRoZSBzb3J0YWJsZSBhbmQgdXNpbmcgaXQgYXMgaW5zdC5jdXJyZW50SXRlbVxuXHRcdFx0XHRcdC8vV2UgY2FuIHRoZW4gZmlyZSB0aGUgc3RhcnQgZXZlbnQgb2YgdGhlIHNvcnRhYmxlIHdpdGggb3VyIHBhc3NlZCBicm93c2VyIGV2ZW50LCBhbmQgb3VyIG93biBoZWxwZXIgKHNvIGl0IGRvZXNuJ3QgY3JlYXRlIGEgbmV3IG9uZSlcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmN1cnJlbnRJdGVtID0gJCh0aGF0KS5jbG9uZSgpLnJlbW92ZUF0dHIoXCJpZFwiKS5hcHBlbmRUbyh0aGlzLmluc3RhbmNlLmVsZW1lbnQpLmRhdGEoXCJ1aS1zb3J0YWJsZS1pdGVtXCIsIHRydWUpO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5faGVscGVyID0gdGhpcy5pbnN0YW5jZS5vcHRpb25zLmhlbHBlcjsgLy9TdG9yZSBoZWxwZXIgb3B0aW9uIHRvIGxhdGVyIHJlc3RvcmUgaXRcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGVscGVyID0gZnVuY3Rpb24oKSB7IHJldHVybiB1aS5oZWxwZXJbMF07IH07XG5cblx0XHRcdFx0XHRldmVudC50YXJnZXQgPSB0aGlzLmluc3RhbmNlLmN1cnJlbnRJdGVtWzBdO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuX21vdXNlQ2FwdHVyZShldmVudCwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fbW91c2VTdGFydChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG5cblx0XHRcdFx0XHQvL0JlY2F1c2UgdGhlIGJyb3dzZXIgZXZlbnQgaXMgd2F5IG9mZiB0aGUgbmV3IGFwcGVuZGVkIHBvcnRsZXQsIHdlIG1vZGlmeSBhIGNvdXBsZSBvZiB2YXJpYWJsZXMgdG8gcmVmbGVjdCB0aGUgY2hhbmdlc1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LmNsaWNrLnRvcCA9IGluc3Qub2Zmc2V0LmNsaWNrLnRvcDtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9mZnNldC5jbGljay5sZWZ0ID0gaW5zdC5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9mZnNldC5wYXJlbnQubGVmdCAtPSBpbnN0Lm9mZnNldC5wYXJlbnQubGVmdCAtIHRoaXMuaW5zdGFuY2Uub2Zmc2V0LnBhcmVudC5sZWZ0O1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LnBhcmVudC50b3AgLT0gaW5zdC5vZmZzZXQucGFyZW50LnRvcCAtIHRoaXMuaW5zdGFuY2Uub2Zmc2V0LnBhcmVudC50b3A7XG5cblx0XHRcdFx0XHRpbnN0Ll90cmlnZ2VyKFwidG9Tb3J0YWJsZVwiLCBldmVudCk7XG5cdFx0XHRcdFx0aW5zdC5kcm9wcGVkID0gdGhpcy5pbnN0YW5jZS5lbGVtZW50OyAvL2RyYWdnYWJsZSByZXZlcnQgbmVlZHMgdGhhdFxuXHRcdFx0XHRcdC8vaGFjayBzbyByZWNlaXZlL3VwZGF0ZSBjYWxsYmFja3Mgd29yayAobW9zdGx5KVxuXHRcdFx0XHRcdGluc3QuY3VycmVudEl0ZW0gPSBpbnN0LmVsZW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5mcm9tT3V0c2lkZSA9IGluc3Q7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vUHJvdmlkZWQgd2UgZGlkIGFsbCB0aGUgcHJldmlvdXMgc3RlcHMsIHdlIGNhbiBmaXJlIHRoZSBkcmFnIGV2ZW50IG9mIHRoZSBzb3J0YWJsZSBvbiBldmVyeSBkcmFnZ2FibGUgZHJhZywgd2hlbiBpdCBpbnRlcnNlY3RzIHdpdGggdGhlIHNvcnRhYmxlXG5cdFx0XHRcdGlmKHRoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW0pIHtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLl9tb3VzZURyYWcoZXZlbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly9JZiBpdCBkb2Vzbid0IGludGVyc2VjdCB3aXRoIHRoZSBzb3J0YWJsZSwgYW5kIGl0IGludGVyc2VjdGVkIGJlZm9yZSxcblx0XHRcdFx0Ly93ZSBmYWtlIHRoZSBkcmFnIHN0b3Agb2YgdGhlIHNvcnRhYmxlLCBidXQgbWFrZSBzdXJlIGl0IGRvZXNuJ3QgcmVtb3ZlIHRoZSBoZWxwZXIgYnkgdXNpbmcgY2FuY2VsSGVscGVyUmVtb3ZhbFxuXHRcdFx0XHRpZih0aGlzLmluc3RhbmNlLmlzT3Zlcikge1xuXG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5pc092ZXIgPSAwO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IHRydWU7XG5cblx0XHRcdFx0XHQvL1ByZXZlbnQgcmV2ZXJ0aW5nIG9uIHRoaXMgZm9yY2VkIHN0b3Bcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLm9wdGlvbnMucmV2ZXJ0ID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBUaGUgb3V0IGV2ZW50IG5lZWRzIHRvIGJlIHRyaWdnZXJlZCBpbmRlcGVuZGVudGx5XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fdHJpZ2dlcihcIm91dFwiLCBldmVudCwgdGhpcy5pbnN0YW5jZS5fdWlIYXNoKHRoaXMuaW5zdGFuY2UpKTtcblxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuX21vdXNlU3RvcChldmVudCwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vcHRpb25zLmhlbHBlciA9IHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5faGVscGVyO1xuXG5cdFx0XHRcdFx0Ly9Ob3cgd2UgcmVtb3ZlIG91ciBjdXJyZW50SXRlbSwgdGhlIGxpc3QgZ3JvdXAgY2xvbmUgYWdhaW4sIGFuZCB0aGUgcGxhY2Vob2xkZXIsIGFuZCBhbmltYXRlIHRoZSBoZWxwZXIgYmFjayB0byBpdCdzIG9yaWdpbmFsIHNpemVcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmN1cnJlbnRJdGVtLnJlbW92ZSgpO1xuXHRcdFx0XHRcdGlmKHRoaXMuaW5zdGFuY2UucGxhY2Vob2xkZXIpIHtcblx0XHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UucGxhY2Vob2xkZXIucmVtb3ZlKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5zdC5fdHJpZ2dlcihcImZyb21Tb3J0YWJsZVwiLCBldmVudCk7XG5cdFx0XHRcdFx0aW5zdC5kcm9wcGVkID0gZmFsc2U7IC8vZHJhZ2dhYmxlIHJldmVydCBuZWVkcyB0aGF0XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSk7XG5cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcImN1cnNvclwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdCA9ICQoXCJib2R5XCIpLCBvID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLm9wdGlvbnM7XG5cdFx0aWYgKHQuY3NzKFwiY3Vyc29yXCIpKSB7XG5cdFx0XHRvLl9jdXJzb3IgPSB0LmNzcyhcImN1cnNvclwiKTtcblx0XHR9XG5cdFx0dC5jc3MoXCJjdXJzb3JcIiwgby5jdXJzb3IpO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbyA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKS5vcHRpb25zO1xuXHRcdGlmIChvLl9jdXJzb3IpIHtcblx0XHRcdCQoXCJib2R5XCIpLmNzcyhcImN1cnNvclwiLCBvLl9jdXJzb3IpO1xuXHRcdH1cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcIm9wYWNpdHlcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIHQgPSAkKHVpLmhlbHBlciksIG8gPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIikub3B0aW9ucztcblx0XHRpZih0LmNzcyhcIm9wYWNpdHlcIikpIHtcblx0XHRcdG8uX29wYWNpdHkgPSB0LmNzcyhcIm9wYWNpdHlcIik7XG5cdFx0fVxuXHRcdHQuY3NzKFwib3BhY2l0eVwiLCBvLm9wYWNpdHkpO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgbyA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKS5vcHRpb25zO1xuXHRcdGlmKG8uX29wYWNpdHkpIHtcblx0XHRcdCQodWkuaGVscGVyKS5jc3MoXCJvcGFjaXR5XCIsIG8uX29wYWNpdHkpO1xuXHRcdH1cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcInNjcm9sbFwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaSA9ICQodGhpcykuZGF0YShcInVpLWRyYWdnYWJsZVwiKTtcblx0XHRpZihpLnNjcm9sbFBhcmVudFswXSAhPT0gZG9jdW1lbnQgJiYgaS5zY3JvbGxQYXJlbnRbMF0udGFnTmFtZSAhPT0gXCJIVE1MXCIpIHtcblx0XHRcdGkub3ZlcmZsb3dPZmZzZXQgPSBpLnNjcm9sbFBhcmVudC5vZmZzZXQoKTtcblx0XHR9XG5cdH0sXG5cdGRyYWc6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdHZhciBpID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLCBvID0gaS5vcHRpb25zLCBzY3JvbGxlZCA9IGZhbHNlO1xuXG5cdFx0aWYoaS5zY3JvbGxQYXJlbnRbMF0gIT09IGRvY3VtZW50ICYmIGkuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUgIT09IFwiSFRNTFwiKSB7XG5cblx0XHRcdGlmKCFvLmF4aXMgfHwgby5heGlzICE9PSBcInhcIikge1xuXHRcdFx0XHRpZigoaS5vdmVyZmxvd09mZnNldC50b3AgKyBpLnNjcm9sbFBhcmVudFswXS5vZmZzZXRIZWlnaHQpIC0gZXZlbnQucGFnZVkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0aS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wID0gc2Nyb2xsZWQgPSBpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgKyBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9IGVsc2UgaWYoZXZlbnQucGFnZVkgLSBpLm92ZXJmbG93T2Zmc2V0LnRvcCA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCAtIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYoIW8uYXhpcyB8fCBvLmF4aXMgIT09IFwieVwiKSB7XG5cdFx0XHRcdGlmKChpLm92ZXJmbG93T2Zmc2V0LmxlZnQgKyBpLnNjcm9sbFBhcmVudFswXS5vZmZzZXRXaWR0aCkgLSBldmVudC5wYWdlWCA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0ID0gc2Nyb2xsZWQgPSBpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0ICsgby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0fSBlbHNlIGlmKGV2ZW50LnBhZ2VYIC0gaS5vdmVyZmxvd09mZnNldC5sZWZ0IDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgLSBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZighby5heGlzIHx8IG8uYXhpcyAhPT0gXCJ4XCIpIHtcblx0XHRcdFx0aWYoZXZlbnQucGFnZVkgLSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSAtIG8uc2Nyb2xsU3BlZWQpO1xuXHRcdFx0XHR9IGVsc2UgaWYoJCh3aW5kb3cpLmhlaWdodCgpIC0gKGV2ZW50LnBhZ2VZIC0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpICsgby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYoIW8uYXhpcyB8fCBvLmF4aXMgIT09IFwieVwiKSB7XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VYIC0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgLSBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdFx0fSBlbHNlIGlmKCQod2luZG93KS53aWR0aCgpIC0gKGV2ZW50LnBhZ2VYIC0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpICsgby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmKHNjcm9sbGVkICE9PSBmYWxzZSAmJiAkLnVpLmRkbWFuYWdlciAmJiAhby5kcm9wQmVoYXZpb3VyKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyhpLCBldmVudCk7XG5cdFx0fVxuXG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJzbmFwXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGkgPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIiksXG5cdFx0XHRvID0gaS5vcHRpb25zO1xuXG5cdFx0aS5zbmFwRWxlbWVudHMgPSBbXTtcblxuXHRcdCQoby5zbmFwLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcgPyAoIG8uc25hcC5pdGVtcyB8fCBcIjpkYXRhKHVpLWRyYWdnYWJsZSlcIiApIDogby5zbmFwKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyICR0ID0gJCh0aGlzKSxcblx0XHRcdFx0JG8gPSAkdC5vZmZzZXQoKTtcblx0XHRcdGlmKHRoaXMgIT09IGkuZWxlbWVudFswXSkge1xuXHRcdFx0XHRpLnNuYXBFbGVtZW50cy5wdXNoKHtcblx0XHRcdFx0XHRpdGVtOiB0aGlzLFxuXHRcdFx0XHRcdHdpZHRoOiAkdC5vdXRlcldpZHRoKCksIGhlaWdodDogJHQub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0XHR0b3A6ICRvLnRvcCwgbGVmdDogJG8ubGVmdFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdHZhciB0cywgYnMsIGxzLCBycywgbCwgciwgdCwgYiwgaSwgZmlyc3QsXG5cdFx0XHRpbnN0ID0gJCh0aGlzKS5kYXRhKFwidWktZHJhZ2dhYmxlXCIpLFxuXHRcdFx0byA9IGluc3Qub3B0aW9ucyxcblx0XHRcdGQgPSBvLnNuYXBUb2xlcmFuY2UsXG5cdFx0XHR4MSA9IHVpLm9mZnNldC5sZWZ0LCB4MiA9IHgxICsgaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCxcblx0XHRcdHkxID0gdWkub2Zmc2V0LnRvcCwgeTIgPSB5MSArIGluc3QuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0O1xuXG5cdFx0Zm9yIChpID0gaW5zdC5zbmFwRWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXG5cdFx0XHRsID0gaW5zdC5zbmFwRWxlbWVudHNbaV0ubGVmdDtcblx0XHRcdHIgPSBsICsgaW5zdC5zbmFwRWxlbWVudHNbaV0ud2lkdGg7XG5cdFx0XHR0ID0gaW5zdC5zbmFwRWxlbWVudHNbaV0udG9wO1xuXHRcdFx0YiA9IHQgKyBpbnN0LnNuYXBFbGVtZW50c1tpXS5oZWlnaHQ7XG5cblx0XHRcdGlmICggeDIgPCBsIC0gZCB8fCB4MSA+IHIgKyBkIHx8IHkyIDwgdCAtIGQgfHwgeTEgPiBiICsgZCB8fCAhJC5jb250YWlucyggaW5zdC5zbmFwRWxlbWVudHNbIGkgXS5pdGVtLm93bmVyRG9jdW1lbnQsIGluc3Quc25hcEVsZW1lbnRzWyBpIF0uaXRlbSApICkge1xuXHRcdFx0XHRpZihpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZykge1xuXHRcdFx0XHRcdChpbnN0Lm9wdGlvbnMuc25hcC5yZWxlYXNlICYmIGluc3Qub3B0aW9ucy5zbmFwLnJlbGVhc2UuY2FsbChpbnN0LmVsZW1lbnQsIGV2ZW50LCAkLmV4dGVuZChpbnN0Ll91aUhhc2goKSwgeyBzbmFwSXRlbTogaW5zdC5zbmFwRWxlbWVudHNbaV0uaXRlbSB9KSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3Quc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nID0gZmFsc2U7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihvLnNuYXBNb2RlICE9PSBcImlubmVyXCIpIHtcblx0XHRcdFx0dHMgPSBNYXRoLmFicyh0IC0geTIpIDw9IGQ7XG5cdFx0XHRcdGJzID0gTWF0aC5hYnMoYiAtIHkxKSA8PSBkO1xuXHRcdFx0XHRscyA9IE1hdGguYWJzKGwgLSB4MikgPD0gZDtcblx0XHRcdFx0cnMgPSBNYXRoLmFicyhyIC0geDEpIDw9IGQ7XG5cdFx0XHRcdGlmKHRzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogdCAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LCBsZWZ0OiAwIH0pLnRvcCAtIGluc3QubWFyZ2lucy50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoYnMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiBiLCBsZWZ0OiAwIH0pLnRvcCAtIGluc3QubWFyZ2lucy50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYobHMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogbCAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggfSkubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHJzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IDAsIGxlZnQ6IHIgfSkubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZpcnN0ID0gKHRzIHx8IGJzIHx8IGxzIHx8IHJzKTtcblxuXHRcdFx0aWYoby5zbmFwTW9kZSAhPT0gXCJvdXRlclwiKSB7XG5cdFx0XHRcdHRzID0gTWF0aC5hYnModCAtIHkxKSA8PSBkO1xuXHRcdFx0XHRicyA9IE1hdGguYWJzKGIgLSB5MikgPD0gZDtcblx0XHRcdFx0bHMgPSBNYXRoLmFicyhsIC0geDEpIDw9IGQ7XG5cdFx0XHRcdHJzID0gTWF0aC5hYnMociAtIHgyKSA8PSBkO1xuXHRcdFx0XHRpZih0cykge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IHQsIGxlZnQ6IDAgfSkudG9wIC0gaW5zdC5tYXJnaW5zLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihicykge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IGIgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLmhlaWdodCwgbGVmdDogMCB9KS50b3AgLSBpbnN0Lm1hcmdpbnMudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGxzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IDAsIGxlZnQ6IGwgfSkubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHJzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IDAsIGxlZnQ6IHIgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLndpZHRoIH0pLmxlZnQgLSBpbnN0Lm1hcmdpbnMubGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZighaW5zdC5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmcgJiYgKHRzIHx8IGJzIHx8IGxzIHx8IHJzIHx8IGZpcnN0KSkge1xuXHRcdFx0XHQoaW5zdC5vcHRpb25zLnNuYXAuc25hcCAmJiBpbnN0Lm9wdGlvbnMuc25hcC5zbmFwLmNhbGwoaW5zdC5lbGVtZW50LCBldmVudCwgJC5leHRlbmQoaW5zdC5fdWlIYXNoKCksIHsgc25hcEl0ZW06IGluc3Quc25hcEVsZW1lbnRzW2ldLml0ZW0gfSkpKTtcblx0XHRcdH1cblx0XHRcdGluc3Quc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nID0gKHRzIHx8IGJzIHx8IGxzIHx8IHJzIHx8IGZpcnN0KTtcblxuXHRcdH1cblxuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsIFwic3RhY2tcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1pbixcblx0XHRcdG8gPSB0aGlzLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIikub3B0aW9ucyxcblx0XHRcdGdyb3VwID0gJC5tYWtlQXJyYXkoJChvLnN0YWNrKSkuc29ydChmdW5jdGlvbihhLGIpIHtcblx0XHRcdFx0cmV0dXJuIChwYXJzZUludCgkKGEpLmNzcyhcInpJbmRleFwiKSwxMCkgfHwgMCkgLSAocGFyc2VJbnQoJChiKS5jc3MoXCJ6SW5kZXhcIiksMTApIHx8IDApO1xuXHRcdFx0fSk7XG5cblx0XHRpZiAoIWdyb3VwLmxlbmd0aCkgeyByZXR1cm47IH1cblxuXHRcdG1pbiA9IHBhcnNlSW50KCQoZ3JvdXBbMF0pLmNzcyhcInpJbmRleFwiKSwgMTApIHx8IDA7XG5cdFx0JChncm91cCkuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHQkKHRoaXMpLmNzcyhcInpJbmRleFwiLCBtaW4gKyBpKTtcblx0XHR9KTtcblx0XHR0aGlzLmNzcyhcInpJbmRleFwiLCAobWluICsgZ3JvdXAubGVuZ3RoKSk7XG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJ6SW5kZXhcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIHQgPSAkKHVpLmhlbHBlciksIG8gPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIikub3B0aW9ucztcblx0XHRpZih0LmNzcyhcInpJbmRleFwiKSkge1xuXHRcdFx0by5fekluZGV4ID0gdC5jc3MoXCJ6SW5kZXhcIik7XG5cdFx0fVxuXHRcdHQuY3NzKFwiekluZGV4XCIsIG8uekluZGV4KTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIG8gPSAkKHRoaXMpLmRhdGEoXCJ1aS1kcmFnZ2FibGVcIikub3B0aW9ucztcblx0XHRpZihvLl96SW5kZXgpIHtcblx0XHRcdCQodWkuaGVscGVyKS5jc3MoXCJ6SW5kZXhcIiwgby5fekluZGV4KTtcblx0XHR9XG5cdH1cbn0pO1xuXG59KShqUXVlcnkpO1xuIiwidmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xucmVxdWlyZSgnLi93aWRnZXQnKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgTW91c2UgMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL21vdXNlL1xuICpcbiAqIERlcGVuZHM6XG4gKlx0anF1ZXJ5LnVpLndpZGdldC5qc1xuICovXG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xuJCggZG9jdW1lbnQgKS5tb3VzZXVwKCBmdW5jdGlvbigpIHtcblx0bW91c2VIYW5kbGVkID0gZmFsc2U7XG59KTtcblxuJC53aWRnZXQoXCJ1aS5tb3VzZVwiLCB7XG5cdHZlcnNpb246IFwiMS4xMC40XCIsXG5cdG9wdGlvbnM6IHtcblx0XHRjYW5jZWw6IFwiaW5wdXQsdGV4dGFyZWEsYnV0dG9uLHNlbGVjdCxvcHRpb25cIixcblx0XHRkaXN0YW5jZTogMSxcblx0XHRkZWxheTogMFxuXHR9LFxuXHRfbW91c2VJbml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5iaW5kKFwibW91c2Vkb3duLlwiK3RoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlRG93bihldmVudCk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoXCJjbGljay5cIit0aGlzLndpZGdldE5hbWUsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGlmICh0cnVlID09PSAkLmRhdGEoZXZlbnQudGFyZ2V0LCB0aGF0LndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKSkge1xuXHRcdFx0XHRcdCQucmVtb3ZlRGF0YShldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIpO1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcblx0fSxcblxuXHQvLyBUT0RPOiBtYWtlIHN1cmUgZGVzdHJveWluZyBvbmUgaW5zdGFuY2Ugb2YgbW91c2UgZG9lc24ndCBtZXNzIHdpdGhcblx0Ly8gb3RoZXIgaW5zdGFuY2VzIG9mIG1vdXNlXG5cdF9tb3VzZURlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC51bmJpbmQoXCIuXCIrdGhpcy53aWRnZXROYW1lKTtcblx0XHRpZiAoIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlICkge1xuXHRcdFx0JChkb2N1bWVudClcblx0XHRcdFx0LnVuYmluZChcIm1vdXNlbW92ZS5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKVxuXHRcdFx0XHQudW5iaW5kKFwibW91c2V1cC5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9tb3VzZURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Ly8gZG9uJ3QgbGV0IG1vcmUgdGhhbiBvbmUgd2lkZ2V0IGhhbmRsZSBtb3VzZVN0YXJ0XG5cdFx0aWYoIG1vdXNlSGFuZGxlZCApIHsgcmV0dXJuOyB9XG5cblx0XHQvLyB3ZSBtYXkgaGF2ZSBtaXNzZWQgbW91c2V1cCAob3V0IG9mIHdpbmRvdylcblx0XHQodGhpcy5fbW91c2VTdGFydGVkICYmIHRoaXMuX21vdXNlVXAoZXZlbnQpKTtcblxuXHRcdHRoaXMuX21vdXNlRG93bkV2ZW50ID0gZXZlbnQ7XG5cblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRidG5Jc0xlZnQgPSAoZXZlbnQud2hpY2ggPT09IDEpLFxuXHRcdFx0Ly8gZXZlbnQudGFyZ2V0Lm5vZGVOYW1lIHdvcmtzIGFyb3VuZCBhIGJ1ZyBpbiBJRSA4IHdpdGhcblx0XHRcdC8vIGRpc2FibGVkIGlucHV0cyAoIzc2MjApXG5cdFx0XHRlbElzQ2FuY2VsID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMuY2FuY2VsID09PSBcInN0cmluZ1wiICYmIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA/ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KHRoaXMub3B0aW9ucy5jYW5jZWwpLmxlbmd0aCA6IGZhbHNlKTtcblx0XHRpZiAoIWJ0bklzTGVmdCB8fCBlbElzQ2FuY2VsIHx8ICF0aGlzLl9tb3VzZUNhcHR1cmUoZXZlbnQpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLm1vdXNlRGVsYXlNZXQgPSAhdGhpcy5vcHRpb25zLmRlbGF5O1xuXHRcdGlmICghdGhpcy5tb3VzZURlbGF5TWV0KSB7XG5cdFx0XHR0aGlzLl9tb3VzZURlbGF5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Lm1vdXNlRGVsYXlNZXQgPSB0cnVlO1xuXHRcdFx0fSwgdGhpcy5vcHRpb25zLmRlbGF5KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbW91c2VEaXN0YW5jZU1ldChldmVudCkgJiYgdGhpcy5fbW91c2VEZWxheU1ldChldmVudCkpIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9ICh0aGlzLl9tb3VzZVN0YXJ0KGV2ZW50KSAhPT0gZmFsc2UpO1xuXHRcdFx0aWYgKCF0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2xpY2sgZXZlbnQgbWF5IG5ldmVyIGhhdmUgZmlyZWQgKEdlY2tvICYgT3BlcmEpXG5cdFx0aWYgKHRydWUgPT09ICQuZGF0YShldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIpKSB7XG5cdFx0XHQkLnJlbW92ZURhdGEoZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiKTtcblx0XHR9XG5cblx0XHQvLyB0aGVzZSBkZWxlZ2F0ZXMgYXJlIHJlcXVpcmVkIHRvIGtlZXAgY29udGV4dFxuXHRcdHRoaXMuX21vdXNlTW92ZURlbGVnYXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZU1vdmUoZXZlbnQpO1xuXHRcdH07XG5cdFx0dGhpcy5fbW91c2VVcERlbGVnYXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZVVwKGV2ZW50KTtcblx0XHR9O1xuXHRcdCQoZG9jdW1lbnQpXG5cdFx0XHQuYmluZChcIm1vdXNlbW92ZS5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKVxuXHRcdFx0LmJpbmQoXCJtb3VzZXVwLlwiK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VVcERlbGVnYXRlKTtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRtb3VzZUhhbmRsZWQgPSB0cnVlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZU1vdmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Ly8gSUUgbW91c2V1cCBjaGVjayAtIG1vdXNldXAgaGFwcGVuZWQgd2hlbiBtb3VzZSB3YXMgb3V0IG9mIHdpbmRvd1xuXHRcdGlmICgkLnVpLmllICYmICggIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA5ICkgJiYgIWV2ZW50LmJ1dHRvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21vdXNlVXAoZXZlbnQpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcblx0XHRcdHRoaXMuX21vdXNlRHJhZyhldmVudCk7XG5cdFx0XHRyZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbW91c2VEaXN0YW5jZU1ldChldmVudCkgJiYgdGhpcy5fbW91c2VEZWxheU1ldChldmVudCkpIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9XG5cdFx0XHRcdCh0aGlzLl9tb3VzZVN0YXJ0KHRoaXMuX21vdXNlRG93bkV2ZW50LCBldmVudCkgIT09IGZhbHNlKTtcblx0XHRcdCh0aGlzLl9tb3VzZVN0YXJ0ZWQgPyB0aGlzLl9tb3VzZURyYWcoZXZlbnQpIDogdGhpcy5fbW91c2VVcChldmVudCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiAhdGhpcy5fbW91c2VTdGFydGVkO1xuXHR9LFxuXG5cdF9tb3VzZVVwOiBmdW5jdGlvbihldmVudCkge1xuXHRcdCQoZG9jdW1lbnQpXG5cdFx0XHQudW5iaW5kKFwibW91c2Vtb3ZlLlwiK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUpXG5cdFx0XHQudW5iaW5kKFwibW91c2V1cC5cIit0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XG5cblx0XHRpZiAodGhpcy5fbW91c2VTdGFydGVkKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPSBmYWxzZTtcblxuXHRcdFx0aWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5fbW91c2VEb3duRXZlbnQudGFyZ2V0KSB7XG5cdFx0XHRcdCQuZGF0YShldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tb3VzZVN0b3AoZXZlbnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VEaXN0YW5jZU1ldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gKE1hdGgubWF4KFxuXHRcdFx0XHRNYXRoLmFicyh0aGlzLl9tb3VzZURvd25FdmVudC5wYWdlWCAtIGV2ZW50LnBhZ2VYKSxcblx0XHRcdFx0TWF0aC5hYnModGhpcy5fbW91c2VEb3duRXZlbnQucGFnZVkgLSBldmVudC5wYWdlWSlcblx0XHRcdCkgPj0gdGhpcy5vcHRpb25zLmRpc3RhbmNlXG5cdFx0KTtcblx0fSxcblxuXHRfbW91c2VEZWxheU1ldDogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZURlbGF5TWV0O1xuXHR9LFxuXG5cdC8vIFRoZXNlIGFyZSBwbGFjZWhvbGRlciBtZXRob2RzLCB0byBiZSBvdmVycmlkZW4gYnkgZXh0ZW5kaW5nIHBsdWdpblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHt9LFxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbigvKiBldmVudCAqLykge30sXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKC8qIGV2ZW50ICovKSB7fSxcblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHsgcmV0dXJuIHRydWU7IH1cbn0pO1xuXG59KShqUXVlcnkpO1xuIiwidmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBXaWRnZXQgMS4xMC40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2pRdWVyeS53aWRnZXQvXG4gKi9cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdXVpZCA9IDAsXG5cdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXHRfY2xlYW5EYXRhID0gJC5jbGVhbkRhdGE7XG4kLmNsZWFuRGF0YSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0Zm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdCQoIGVsZW0gKS50cmlnZ2VySGFuZGxlciggXCJyZW1vdmVcIiApO1xuXHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzgyMzVcblx0XHR9IGNhdGNoKCBlICkge31cblx0fVxuXHRfY2xlYW5EYXRhKCBlbGVtcyApO1xufTtcblxuJC53aWRnZXQgPSBmdW5jdGlvbiggbmFtZSwgYmFzZSwgcHJvdG90eXBlICkge1xuXHR2YXIgZnVsbE5hbWUsIGV4aXN0aW5nQ29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLCBiYXNlUHJvdG90eXBlLFxuXHRcdC8vIHByb3hpZWRQcm90b3R5cGUgYWxsb3dzIHRoZSBwcm92aWRlZCBwcm90b3R5cGUgdG8gcmVtYWluIHVubW9kaWZpZWRcblx0XHQvLyBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGFzIGEgbWl4aW4gZm9yIG11bHRpcGxlIHdpZGdldHMgKCM4ODc2KVxuXHRcdHByb3hpZWRQcm90b3R5cGUgPSB7fSxcblx0XHRuYW1lc3BhY2UgPSBuYW1lLnNwbGl0KCBcIi5cIiApWyAwIF07XG5cblx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDEgXTtcblx0ZnVsbE5hbWUgPSBuYW1lc3BhY2UgKyBcIi1cIiArIG5hbWU7XG5cblx0aWYgKCAhcHJvdG90eXBlICkge1xuXHRcdHByb3RvdHlwZSA9IGJhc2U7XG5cdFx0YmFzZSA9ICQuV2lkZ2V0O1xuXHR9XG5cblx0Ly8gY3JlYXRlIHNlbGVjdG9yIGZvciBwbHVnaW5cblx0JC5leHByWyBcIjpcIiBdWyBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpIF0gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGZ1bGxOYW1lICk7XG5cdH07XG5cblx0JFsgbmFtZXNwYWNlIF0gPSAkWyBuYW1lc3BhY2UgXSB8fCB7fTtcblx0ZXhpc3RpbmdDb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF07XG5cdGNvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXHRcdC8vIGFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBcIm5ld1wiIGtleXdvcmRcblx0XHRpZiAoICF0aGlzLl9jcmVhdGVXaWRnZXQgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGNvbnN0cnVjdG9yKCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly8gYWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IGluaXRpYWxpemluZyBmb3Igc2ltcGxlIGluaGVyaXRhbmNlXG5cdFx0Ly8gbXVzdCB1c2UgXCJuZXdcIiBrZXl3b3JkICh0aGUgY29kZSBhYm92ZSBhbHdheXMgcGFzc2VzIGFyZ3MpXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fY3JlYXRlV2lkZ2V0KCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXHR9O1xuXHQvLyBleHRlbmQgd2l0aCB0aGUgZXhpc3RpbmcgY29uc3RydWN0b3IgdG8gY2Fycnkgb3ZlciBhbnkgc3RhdGljIHByb3BlcnRpZXNcblx0JC5leHRlbmQoIGNvbnN0cnVjdG9yLCBleGlzdGluZ0NvbnN0cnVjdG9yLCB7XG5cdFx0dmVyc2lvbjogcHJvdG90eXBlLnZlcnNpb24sXG5cdFx0Ly8gY29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdFx0Ly8gcmVkZWZpbmUgdGhlIHdpZGdldCBsYXRlclxuXHRcdF9wcm90bzogJC5leHRlbmQoIHt9LCBwcm90b3R5cGUgKSxcblx0XHQvLyB0cmFjayB3aWRnZXRzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgd2lkZ2V0IGluIGNhc2UgdGhpcyB3aWRnZXQgaXNcblx0XHQvLyByZWRlZmluZWQgYWZ0ZXIgYSB3aWRnZXQgaW5oZXJpdHMgZnJvbSBpdFxuXHRcdF9jaGlsZENvbnN0cnVjdG9yczogW11cblx0fSk7XG5cblx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XG5cdC8vIHdlIG5lZWQgdG8gbWFrZSB0aGUgb3B0aW9ucyBoYXNoIGEgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5ldyBpbnN0YW5jZVxuXHQvLyBvdGhlcndpc2Ugd2UnbGwgbW9kaWZ5IHRoZSBvcHRpb25zIGhhc2ggb24gdGhlIHByb3RvdHlwZSB0aGF0IHdlJ3JlXG5cdC8vIGluaGVyaXRpbmcgZnJvbVxuXHRiYXNlUHJvdG90eXBlLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LCBiYXNlUHJvdG90eXBlLm9wdGlvbnMgKTtcblx0JC5lYWNoKCBwcm90b3R5cGUsIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRpZiAoICEkLmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIF9zdXBlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBiYXNlLnByb3RvdHlwZVsgcHJvcCBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0X3N1cGVyQXBwbHkgPSBmdW5jdGlvbiggYXJncyApIHtcblx0XHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX19zdXBlciA9IHRoaXMuX3N1cGVyLFxuXHRcdFx0XHRcdF9fc3VwZXJBcHBseSA9IHRoaXMuX3N1cGVyQXBwbHksXG5cdFx0XHRcdFx0cmV0dXJuVmFsdWU7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfc3VwZXJBcHBseTtcblxuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHZhbHVlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9fc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXHR9KTtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gJC53aWRnZXQuZXh0ZW5kKCBiYXNlUHJvdG90eXBlLCB7XG5cdFx0Ly8gVE9ETzogcmVtb3ZlIHN1cHBvcnQgZm9yIHdpZGdldEV2ZW50UHJlZml4XG5cdFx0Ly8gYWx3YXlzIHVzZSB0aGUgbmFtZSArIGEgY29sb24gYXMgdGhlIHByZWZpeCwgZS5nLiwgZHJhZ2dhYmxlOnN0YXJ0XG5cdFx0Ly8gZG9uJ3QgcHJlZml4IGZvciB3aWRnZXRzIHRoYXQgYXJlbid0IERPTS1iYXNlZFxuXHRcdHdpZGdldEV2ZW50UHJlZml4OiBleGlzdGluZ0NvbnN0cnVjdG9yID8gKGJhc2VQcm90b3R5cGUud2lkZ2V0RXZlbnRQcmVmaXggfHwgbmFtZSkgOiBuYW1lXG5cdH0sIHByb3hpZWRQcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXG5cdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0d2lkZ2V0TmFtZTogbmFtZSxcblx0XHR3aWRnZXRGdWxsTmFtZTogZnVsbE5hbWVcblx0fSk7XG5cblx0Ly8gSWYgdGhpcyB3aWRnZXQgaXMgYmVpbmcgcmVkZWZpbmVkIHRoZW4gd2UgbmVlZCB0byBmaW5kIGFsbCB3aWRnZXRzIHRoYXRcblx0Ly8gYXJlIGluaGVyaXRpbmcgZnJvbSBpdCBhbmQgcmVkZWZpbmUgYWxsIG9mIHRoZW0gc28gdGhhdCB0aGV5IGluaGVyaXQgZnJvbVxuXHQvLyB0aGUgbmV3IHZlcnNpb24gb2YgdGhpcyB3aWRnZXQuIFdlJ3JlIGVzc2VudGlhbGx5IHRyeWluZyB0byByZXBsYWNlIG9uZVxuXHQvLyBsZXZlbCBpbiB0aGUgcHJvdG90eXBlIGNoYWluLlxuXHRpZiAoIGV4aXN0aW5nQ29uc3RydWN0b3IgKSB7XG5cdFx0JC5lYWNoKCBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycywgZnVuY3Rpb24oIGksIGNoaWxkICkge1xuXHRcdFx0dmFyIGNoaWxkUHJvdG90eXBlID0gY2hpbGQucHJvdG90eXBlO1xuXG5cdFx0XHQvLyByZWRlZmluZSB0aGUgY2hpbGQgd2lkZ2V0IHVzaW5nIHRoZSBzYW1lIHByb3RvdHlwZSB0aGF0IHdhc1xuXHRcdFx0Ly8gb3JpZ2luYWxseSB1c2VkLCBidXQgaW5oZXJpdCBmcm9tIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGUgYmFzZVxuXHRcdFx0JC53aWRnZXQoIGNoaWxkUHJvdG90eXBlLm5hbWVzcGFjZSArIFwiLlwiICsgY2hpbGRQcm90b3R5cGUud2lkZ2V0TmFtZSwgY29uc3RydWN0b3IsIGNoaWxkLl9wcm90byApO1xuXHRcdH0pO1xuXHRcdC8vIHJlbW92ZSB0aGUgbGlzdCBvZiBleGlzdGluZyBjaGlsZCBjb25zdHJ1Y3RvcnMgZnJvbSB0aGUgb2xkIGNvbnN0cnVjdG9yXG5cdFx0Ly8gc28gdGhlIG9sZCBjaGlsZCBjb25zdHJ1Y3RvcnMgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG5cdFx0ZGVsZXRlIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzO1xuXHR9IGVsc2Uge1xuXHRcdGJhc2UuX2NoaWxkQ29uc3RydWN0b3JzLnB1c2goIGNvbnN0cnVjdG9yICk7XG5cdH1cblxuXHQkLndpZGdldC5icmlkZ2UoIG5hbWUsIGNvbnN0cnVjdG9yICk7XG59O1xuXG4kLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHR2YXIgaW5wdXQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSxcblx0XHRpbnB1dEluZGV4ID0gMCxcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHRrZXksXG5cdFx0dmFsdWU7XG5cdGZvciAoIDsgaW5wdXRJbmRleCA8IGlucHV0TGVuZ3RoOyBpbnB1dEluZGV4KysgKSB7XG5cdFx0Zm9yICgga2V5IGluIGlucHV0WyBpbnB1dEluZGV4IF0gKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0WyBpbnB1dEluZGV4IF1bIGtleSBdO1xuXHRcdFx0aWYgKCBpbnB1dFsgaW5wdXRJbmRleCBdLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBDbG9uZSBvYmplY3RzXG5cdFx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSAkLmlzUGxhaW5PYmplY3QoIHRhcmdldFsga2V5IF0gKSA/XG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB0YXJnZXRbIGtleSBdLCB2YWx1ZSApIDpcblx0XHRcdFx0XHRcdC8vIERvbid0IGV4dGVuZCBzdHJpbmdzLCBhcnJheXMsIGV0Yy4gd2l0aCBvYmplY3RzXG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB2YWx1ZSApO1xuXHRcdFx0XHQvLyBDb3B5IGV2ZXJ5dGhpbmcgZWxzZSBieSByZWZlcmVuY2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbiQud2lkZ2V0LmJyaWRnZSA9IGZ1bmN0aW9uKCBuYW1lLCBvYmplY3QgKSB7XG5cdHZhciBmdWxsTmFtZSA9IG9iamVjdC5wcm90b3R5cGUud2lkZ2V0RnVsbE5hbWUgfHwgbmFtZTtcblx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGlzTWV0aG9kQ2FsbCA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLFxuXHRcdFx0cmV0dXJuVmFsdWUgPSB0aGlzO1xuXG5cdFx0Ly8gYWxsb3cgbXVsdGlwbGUgaGFzaGVzIHRvIGJlIHBhc3NlZCBvbiBpbml0XG5cdFx0b3B0aW9ucyA9ICFpc01ldGhvZENhbGwgJiYgYXJncy5sZW5ndGggP1xuXHRcdFx0JC53aWRnZXQuZXh0ZW5kLmFwcGx5KCBudWxsLCBbIG9wdGlvbnMgXS5jb25jYXQoYXJncykgKSA6XG5cdFx0XHRvcHRpb25zO1xuXG5cdFx0aWYgKCBpc01ldGhvZENhbGwgKSB7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBtZXRob2RWYWx1ZSxcblx0XHRcdFx0XHRpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwiY2Fubm90IGNhbGwgbWV0aG9kcyBvbiBcIiArIG5hbWUgKyBcIiBwcmlvciB0byBpbml0aWFsaXphdGlvbjsgXCIgK1xuXHRcdFx0XHRcdFx0XCJhdHRlbXB0ZWQgdG8gY2FsbCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJ1wiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCBpbnN0YW5jZVtvcHRpb25zXSApIHx8IG9wdGlvbnMuY2hhckF0KCAwICkgPT09IFwiX1wiICkge1xuXHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcIm5vIHN1Y2ggbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIicgZm9yIFwiICsgbmFtZSArIFwiIHdpZGdldCBpbnN0YW5jZVwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWV0aG9kVmFsdWUgPSBpbnN0YW5jZVsgb3B0aW9ucyBdLmFwcGx5KCBpbnN0YW5jZSwgYXJncyApO1xuXHRcdFx0XHRpZiAoIG1ldGhvZFZhbHVlICE9PSBpbnN0YW5jZSAmJiBtZXRob2RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gbWV0aG9kVmFsdWUgJiYgbWV0aG9kVmFsdWUuanF1ZXJ5ID9cblx0XHRcdFx0XHRcdHJldHVyblZhbHVlLnB1c2hTdGFjayggbWV0aG9kVmFsdWUuZ2V0KCkgKSA6XG5cdFx0XHRcdFx0XHRtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRpbnN0YW5jZS5vcHRpb24oIG9wdGlvbnMgfHwge30gKS5faW5pdCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQuZGF0YSggdGhpcywgZnVsbE5hbWUsIG5ldyBvYmplY3QoIG9wdGlvbnMsIHRoaXMgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG59O1xuXG4kLldpZGdldCA9IGZ1bmN0aW9uKCAvKiBvcHRpb25zLCBlbGVtZW50ICovICkge307XG4kLldpZGdldC5fY2hpbGRDb25zdHJ1Y3RvcnMgPSBbXTtcblxuJC5XaWRnZXQucHJvdG90eXBlID0ge1xuXHR3aWRnZXROYW1lOiBcIndpZGdldFwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGRpdj5cIixcblx0b3B0aW9uczoge1xuXHRcdGRpc2FibGVkOiBmYWxzZSxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGNyZWF0ZTogbnVsbFxuXHR9LFxuXHRfY3JlYXRlV2lkZ2V0OiBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHRlbGVtZW50ID0gJCggZWxlbWVudCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMgKVsgMCBdO1xuXHRcdHRoaXMuZWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLnV1aWQgPSB1dWlkKys7XG5cdFx0dGhpcy5ldmVudE5hbWVzcGFjZSA9IFwiLlwiICsgdGhpcy53aWRnZXROYW1lICsgdGhpcy51dWlkO1xuXHRcdHRoaXMub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sXG5cdFx0XHR0aGlzLm9wdGlvbnMsXG5cdFx0XHR0aGlzLl9nZXRDcmVhdGVPcHRpb25zKCksXG5cdFx0XHRvcHRpb25zICk7XG5cblx0XHR0aGlzLmJpbmRpbmdzID0gJCgpO1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gJCgpO1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gJCgpO1xuXG5cdFx0aWYgKCBlbGVtZW50ICE9PSB0aGlzICkge1xuXHRcdFx0JC5kYXRhKCBlbGVtZW50LCB0aGlzLndpZGdldEZ1bGxOYW1lLCB0aGlzICk7XG5cdFx0XHR0aGlzLl9vbiggdHJ1ZSwgdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSAkKCBlbGVtZW50LnN0eWxlID9cblx0XHRcdFx0Ly8gZWxlbWVudCB3aXRoaW4gdGhlIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQub3duZXJEb2N1bWVudCA6XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgd2luZG93IG9yIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQuZG9jdW1lbnQgfHwgZWxlbWVudCApO1xuXHRcdFx0dGhpcy53aW5kb3cgPSAkKCB0aGlzLmRvY3VtZW50WzBdLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jdW1lbnRbMF0ucGFyZW50V2luZG93ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJjcmVhdGVcIiwgbnVsbCwgdGhpcy5fZ2V0Q3JlYXRlRXZlbnREYXRhKCkgKTtcblx0XHR0aGlzLl9pbml0KCk7XG5cdH0sXG5cdF9nZXRDcmVhdGVPcHRpb25zOiAkLm5vb3AsXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcblx0X2NyZWF0ZTogJC5ub29wLFxuXHRfaW5pdDogJC5ub29wLFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2Rlc3Ryb3koKTtcblx0XHQvLyB3ZSBjYW4gcHJvYmFibHkgcmVtb3ZlIHRoZSB1bmJpbmQgY2FsbHMgaW4gMi4wXG5cdFx0Ly8gYWxsIGV2ZW50IGJpbmRpbmdzIHNob3VsZCBnbyB0aHJvdWdoIHRoaXMuX29uKClcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0Ly8gMS45IEJDIGZvciAjNzgxMFxuXHRcdFx0Ly8gVE9ETyByZW1vdmUgZHVhbCBzdG9yYWdlXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXROYW1lIClcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldEZ1bGxOYW1lIClcblx0XHRcdC8vIHN1cHBvcnQ6IGpxdWVyeSA8MS42LjNcblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzk0MTNcblx0XHRcdC5yZW1vdmVEYXRhKCAkLmNhbWVsQ2FzZSggdGhpcy53aWRnZXRGdWxsTmFtZSApICk7XG5cdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0LnVuYmluZCggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKVxuXHRcdFx0LnJlbW92ZUNsYXNzKFxuXHRcdFx0XHR0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWQgXCIgK1xuXHRcdFx0XHRcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblxuXHRcdC8vIGNsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXG5cdFx0dGhpcy5iaW5kaW5ncy51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblx0XHR0aGlzLmhvdmVyYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0dGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHR9LFxuXHRfZGVzdHJveTogJC5ub29wLFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0fSxcblxuXHRvcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBvcHRpb25zID0ga2V5LFxuXHRcdFx0cGFydHMsXG5cdFx0XHRjdXJPcHRpb24sXG5cdFx0XHRpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0Ly8gZG9uJ3QgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBoYXNoXG5cdFx0XHRyZXR1cm4gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Ly8gaGFuZGxlIG5lc3RlZCBrZXlzLCBlLmcuLCBcImZvby5iYXJcIiA9PiB7IGZvbzogeyBiYXI6IF9fXyB9IH1cblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHBhcnRzID0ga2V5LnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0a2V5ID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdGlmICggcGFydHMubGVuZ3RoICkge1xuXHRcdFx0XHRjdXJPcHRpb24gPSBvcHRpb25zWyBrZXkgXSA9ICQud2lkZ2V0LmV4dGVuZCgge30sIHRoaXMub3B0aW9uc1sga2V5IF0gKTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKysgKSB7XG5cdFx0XHRcdFx0Y3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gPSBjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSB8fCB7fTtcblx0XHRcdFx0XHRjdXJPcHRpb24gPSBjdXJPcHRpb25bIHBhcnRzWyBpIF0gXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXkgPSBwYXJ0cy5wb3AoKTtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiBjdXJPcHRpb25bIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogY3VyT3B0aW9uWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdXJPcHRpb25bIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1sga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0aGlzLm9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0T3B0aW9ucyggb3B0aW9ucyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIGtleSwgb3B0aW9uc1sga2V5IF0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dGhpcy5vcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCB0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWQgdWktc3RhdGUtZGlzYWJsZWRcIiwgISF2YWx1ZSApXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgdmFsdWUgKTtcblx0XHRcdHRoaXMuaG92ZXJhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdHRoaXMuZm9jdXNhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgZmFsc2UgKTtcblx0fSxcblx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbiggXCJkaXNhYmxlZFwiLCB0cnVlICk7XG5cdH0sXG5cblx0X29uOiBmdW5jdGlvbiggc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgZGVsZWdhdGVFbGVtZW50LFxuXHRcdFx0aW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0Ly8gbm8gc3VwcHJlc3NEaXNhYmxlZENoZWNrIGZsYWcsIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0aWYgKCB0eXBlb2Ygc3VwcHJlc3NEaXNhYmxlZENoZWNrICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSBzdXBwcmVzc0Rpc2FibGVkQ2hlY2s7XG5cdFx0XHRzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBubyBlbGVtZW50IGFyZ3VtZW50LCBzaHVmZmxlIGFuZCB1c2UgdGhpcy5lbGVtZW50XG5cdFx0aWYgKCAhaGFuZGxlcnMgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0ZGVsZWdhdGVFbGVtZW50ID0gdGhpcy53aWRnZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYWNjZXB0IHNlbGVjdG9ycywgRE9NIGVsZW1lbnRzXG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuYWRkKCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBoYW5kbGVycywgZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyICkge1xuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0XHQvLyBhbGxvdyB3aWRnZXRzIHRvIGN1c3RvbWl6ZSB0aGUgZGlzYWJsZWQgaGFuZGxpbmdcblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBjbGFzcyBhcyBtZXRob2QgZm9yIGRpc2FibGluZyBpbmRpdmlkdWFsIHBhcnRzXG5cdFx0XHRcdGlmICggIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJlxuXHRcdFx0XHRcdFx0KCBpbnN0YW5jZS5vcHRpb25zLmRpc2FibGVkID09PSB0cnVlIHx8XG5cdFx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxuXHRcdFx0XHRcdGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoID0gZXZlbnQubWF0Y2goIC9eKFxcdyspXFxzKiguKikkLyApLFxuXHRcdFx0XHRldmVudE5hbWUgPSBtYXRjaFsxXSArIGluc3RhbmNlLmV2ZW50TmFtZXNwYWNlLFxuXHRcdFx0XHRzZWxlY3RvciA9IG1hdGNoWzJdO1xuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0ZGVsZWdhdGVFbGVtZW50LmRlbGVnYXRlKCBzZWxlY3RvciwgZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQuYmluZCggZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfb2ZmOiBmdW5jdGlvbiggZWxlbWVudCwgZXZlbnROYW1lICkge1xuXHRcdGV2ZW50TmFtZSA9IChldmVudE5hbWUgfHwgXCJcIikuc3BsaXQoIFwiIFwiICkuam9pbiggdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIFwiICkgKyB0aGlzLmV2ZW50TmFtZXNwYWNlO1xuXHRcdGVsZW1lbnQudW5iaW5kKCBldmVudE5hbWUgKS51bmRlbGVnYXRlKCBldmVudE5hbWUgKTtcblx0fSxcblxuXHRfZGVsYXk6IGZ1bmN0aW9uKCBoYW5kbGVyLCBkZWxheSApIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVyUHJveHkoKSB7XG5cdFx0XHRyZXR1cm4gKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJzdHJpbmdcIiA/IGluc3RhbmNlWyBoYW5kbGVyIF0gOiBoYW5kbGVyIClcblx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0fVxuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0cmV0dXJuIHNldFRpbWVvdXQoIGhhbmRsZXJQcm94eSwgZGVsYXkgfHwgMCApO1xuXHR9LFxuXG5cdF9ob3ZlcmFibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gdGhpcy5ob3ZlcmFibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdG1vdXNlZW50ZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X2ZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSB0aGlzLmZvY3VzYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0Zm9jdXNpbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3Vzb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X3RyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgZGF0YSApIHtcblx0XHR2YXIgcHJvcCwgb3JpZyxcblx0XHRcdGNhbGxiYWNrID0gdGhpcy5vcHRpb25zWyB0eXBlIF07XG5cblx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRldmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdFx0ZXZlbnQudHlwZSA9ICggdHlwZSA9PT0gdGhpcy53aWRnZXRFdmVudFByZWZpeCA/XG5cdFx0XHR0eXBlIDpcblx0XHRcdHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHQvLyB0aGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WyAwIF07XG5cblx0XHQvLyBjb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdFx0b3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCBvcmlnICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRpZiAoICEoIHByb3AgaW4gZXZlbnQgKSApIHtcblx0XHRcdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhICk7XG5cdFx0cmV0dXJuICEoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSAmJlxuXHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMuZWxlbWVudFswXSwgWyBldmVudCBdLmNvbmNhdCggZGF0YSApICkgPT09IGZhbHNlIHx8XG5cdFx0XHRldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApO1xuXHR9XG59O1xuXG4kLmVhY2goIHsgc2hvdzogXCJmYWRlSW5cIiwgaGlkZTogXCJmYWRlT3V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgZGVmYXVsdEVmZmVjdCApIHtcblx0JC5XaWRnZXQucHJvdG90eXBlWyBcIl9cIiArIG1ldGhvZCBdID0gZnVuY3Rpb24oIGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBlZmZlY3Q6IG9wdGlvbnMgfTtcblx0XHR9XG5cdFx0dmFyIGhhc09wdGlvbnMsXG5cdFx0XHRlZmZlY3ROYW1lID0gIW9wdGlvbnMgP1xuXHRcdFx0XHRtZXRob2QgOlxuXHRcdFx0XHRvcHRpb25zID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiID9cblx0XHRcdFx0XHRkZWZhdWx0RWZmZWN0IDpcblx0XHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuXHRcdH1cblx0XHRoYXNPcHRpb25zID0gISQuaXNFbXB0eU9iamVjdCggb3B0aW9ucyApO1xuXHRcdG9wdGlvbnMuY29tcGxldGUgPSBjYWxsYmFjaztcblx0XHRpZiAoIG9wdGlvbnMuZGVsYXkgKSB7XG5cdFx0XHRlbGVtZW50LmRlbGF5KCBvcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXHRcdGlmICggaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgbWV0aG9kIF0oIG9wdGlvbnMgKTtcblx0XHR9IGVsc2UgaWYgKCBlZmZlY3ROYW1lICE9PSBtZXRob2QgJiYgZWxlbWVudFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgZWZmZWN0TmFtZSBdKCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC5xdWV1ZShmdW5jdGlvbiggbmV4dCApIHtcblx0XHRcdFx0JCggdGhpcyApWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGVsZW1lbnRbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn0pO1xuXG59KSggalF1ZXJ5ICk7XG4iLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgR2VuZXJpY0ZpbHRlck1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL2dlbmVyaWMtZmlsdGVyLW1vZGVsJyk7XG52YXIgT3JnUm9sZUZpbHRlck1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL29yZy1yb2xlLWZpbHRlci1tb2RlbCcpO1xudmFyIFllYXJzRmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMveWVhcnMtZmlsdGVyLW1vZGVsJyk7XG52YXIgWWVhcnNPbmx5RmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMveWVhcnMtb25seS1maWx0ZXItbW9kZWwnKTtcblxuXG4vL1RPRE86IG1vdmUgbW9zdCBjb2RlIGZyb20gZmlsdGVycy12aWV3IGhlcmUuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgdXJsOiAnL3Jlc3QvZmlsdGVycycsXG4gIF9sb2FkZWQ6IG51bGwsXG4gIF9hbGxEZWZlcnJlZHM6IFtdLFxuICBvcmdDb2xsZWN0aW9uOiBudWxsLFxuICBvcmdHcm91cENvbGxlY3Rpb246IG51bGwsXG4gIG9yZ1R5cGVDb2xsZWN0aW9uOiBudWxsLFxuICBjb21wb25lbnRDYWxsZXI6IG51bGwsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obW9kZWxzLG9wdGlvbnMpIHtcbiAgICB0aGlzLm9uKCdhZGQnLCB0aGlzLl9jbGVhblVwQWZ0ZXJBZGQpO1xuICAgIHRoaXMubG9hZCgpO1xuICAgIGlmIChvcHRpb25zLmNhbGxlcikge1xuICAgIFx0Y29tcG9uZW50Q2FsbGVyID0gb3B0aW9ucy5jYWxsZXI7XG4gICAgfVxuICB9LFxuXG4gIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmKCF0aGlzLl9sb2FkZWQpe1xuICAgICAgdGhpcy5fbG9hZGVkID0gbmV3ICQuRGVmZXJyZWQoKTtcbiAgICAgIHRoaXMuX2FsbERlZmVycmVkcy5wdXNoKHRoaXMuX2NyZWF0ZU9yZ0ZpbHRlcnMoKSk7XG5cbiAgICAgIHRoaXMuZmV0Y2goe3JlbW92ZTogZmFsc2V9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB3aGVuIGFsbCBjaGlsZCBjYWxscyBhcmUgZG9uZSByZXNvbHZlLlxuICAgICAgICAkLndoZW4uYXBwbHkoJCwgc2VsZi5fYWxsRGVmZXJyZWRzKVxuICAgICAgICAgIC5kb25lKHNlbGYuX2xvYWRlZC5yZXNvbHZlKVxuICAgICAgICAgIC5mYWlsKHNlbGYuX2xvYWRlZC5yZWplY3QpO1xuICAgICAgfSkuZmFpbChzZWxmLl9sb2FkZWQucmVqZWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbG9hZGVkO1xuICB9LFxuXG4gIF9jbGVhblVwQWZ0ZXJBZGQ6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIHJlbW92ZSBpZiB1aSBmYWxzZSBhbHNvIGNhdGNoZXMgZW1wdHkgZHVtbXkgZmlsdGVycyB3ZSBhZGQgaW4gJ21vZGVsJyBmdW5jdGlvbiBiZWxvdy5cbiAgICBpZiAoIW1vZGVsLmdldCgndWknKSkge1xuICAgICAgc2VsZi5yZW1vdmUobW9kZWwpO1xuICAgIH1cbiAgICAvL3JlbW92ZSBpZiB0aGUgZW5kcG9pbnQgcmV0dXJucyB0aGUgZmlsdGVyIHR5cGUgKGRhc2hib2FyZCx0YWJzLHJlcG9ydHMgYW5kL29yIEdJUykgZm9yIHdoaWNoXG4gICAgLy90aGUgbW9kZWwgc2hvdWxkIGJlIHZpc2libGUgYW5kIHRoZSBjYWxsZXIgaXMgbm90IG9mIHRoZSBzYW1lIHRwZVxuICAgIFxuICAgIGlmIChtb2RlbC5nZXQoJ2ZpbHRlclR5cGUnKSkge1xuICAgIFx0Ly8gQ09OU1RBTlRJTjogaGVyZSBmaWx0ZXJpbmcgaXJyZWxldmFudCBjb2x1bW5zIGZvciB0aGUgc2V0IGZpbHRlciB0eXBlIGFyZSBmaWx0ZXJlZCBvdXRcbiAgICBcdHZhciBpc09mUmVxdWlyZWRUeXBlID0gXy5zb21lKCBtb2RlbC5nZXQoJ2ZpbHRlclR5cGUnKSwgZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgXHQgICAgcmV0dXJuIHR5cGUgPT09IGNvbXBvbmVudENhbGxlciB8fCB0eXBlID09PSBcIkFMTFwiO1xuICAgIFx0fSk7XG4gICAgXHQvL2NvbnNvbGUubG9nKFwiZGVjaWRlZCB3aGV0aGVyIHRvIHNob3cgY29sdW1uIFwiICsgbW9kZWwuZ2V0KFwibmFtZVwiKSArIFwiOiBcIiArIGlzT2ZSZXF1aXJlZFR5cGUpXG4gICAgXHRpZiAoIWlzT2ZSZXF1aXJlZFR5cGUpIHtcbiAgICBcdFx0c2VsZi5yZW1vdmUgKG1vZGVsKTtcbiAgICBcdH1cbiAgICB9XG4gICAgLy8gRXhwb3NlIHRoaXMgZmllbGQgZm9yIGxhdGVyIHVzYWdlLlxuICAgIHRoaXMuY29tcG9uZW50Q2FsbGVyID0gY29tcG9uZW50Q2FsbGVyO1xuICB9LFxuXG5cbi8vICBjb250YWluczogZnVuY3Rpb24oa2V5KSB7XG4vL1x0ICBpZiAoKVxuLy8gIH0sXG4gIFxuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIC8vb25seSBrZWVwIGZpbHRlcnMgd2l0aCB1aSA9PSB0cnVlO1xuICAgIGRhdGEgPSBfLmZpbHRlcihkYXRhLCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmoudWk7XG4gICAgfSk7XG5cbiAgICAvL3JlbW92ZSBvcmdzLCBncm91cHMsIGFuZCB0eXBlcywgYmVjYXVzZSB0aGV5IGFyZSBub3QgZmlsdGVycyBvbiB0aGVpciBvd24uXG4gICAgLy8gV2UgdXNlIHRoZW0gZG93biBiZWxvdy5cbiAgICBkYXRhID0gXy5maWx0ZXIoZGF0YSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gKG9iai5lbmRwb2ludCAhPT0gJy9yZXN0L2ZpbHRlcnMvb3JnLWdyb3VwcycgJiZcbiAgICAgICAgb2JqLmVuZHBvaW50ICE9PSAnL3Jlc3QvZmlsdGVycy9vcmctdHlwZXMnICYmXG4gICAgICAgIG9iai5lbmRwb2ludCAhPT0gJy9yZXN0L2ZpbHRlcnMvb3JnLXJvbGVzJyAmJlxuICAgICAgICBvYmouZW5kcG9pbnQgIT09ICcvcmVzdC9maWx0ZXJzL29yZ3MnKTtcbiAgICB9KTtcblxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cblxuICBtb2RlbDogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICB2YXIgdG1wTW9kZWwgPSBudWxsO1xuXG4gICAgLy8gc2xpZ2h0bHkgdW5jb252ZW50aW9uYWwsIGJ1dCBtb2RlbCBpcyBzcGVjaWFsIGNhc2Ugc2luY2UgaXQncyBjYWxsZWQgd2l0aFxuICAgIC8vIG5ldyBzbyAndGhpcycgd29udCBiZSB0aGUgY29sbGVjdGlvbi5cbiAgICB2YXIgc2VsZiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcblxuICAgIC8vIHN3aXRjaCBmb3IgbW9kZWwgcG9seW1vcnBoaXNtLlxuICAgIHN3aXRjaCAoYXR0cnMuaWQpIHtcbiAgICAgIGNhc2UgJ1Byb2dyYW1zJzpcbiAgICAgIGNhc2UgJ1NlY3RvcnMnOlxuICAgICAgICBzZWxmLl9hbGxEZWZlcnJlZHMucHVzaChzZWxmLl9nb09uZURlZXBlcihzZWxmLCBhdHRycykpO1xuICAgICAgICAvL3RtcCBoYWNrIGJlY2F1c2Ugd2UgbmVlZCB0byByZXR1cm4gc29tZXRoaW5nLlxuICAgICAgICB0bXBNb2RlbCA9IG5ldyBCYWNrYm9uZS5Nb2RlbCh7dWk6ZmFsc2V9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIFxuICAgICAgZGVmYXVsdDpcbiAgICBcdCAgaWYgKGF0dHJzLmlkID09ICdEYXRlcycgfHwgKGF0dHJzLmlkLmxlbmd0aCA+IDQgJiYgYXR0cnMuaWQuc3Vic3RyaW5nKGF0dHJzLmlkLmxlbmd0aCAtIDQpID09ICdEYXRlJykpIHtcbiAgICBcdFx0ICB0bXBNb2RlbCA9IG5ldyBZZWFyc0ZpbHRlck1vZGVsKGF0dHJzKTsgIC8vIGhhY2t5IGJ1dCBsZXNzIGhhY2t5IHRoYW4gZW51bWVyYXRpbmcgdGhlbS4gTG9uZyB0ZXJtIHNvbHV0aW9uIC0+IHRoZSBlbmRwb2ludCBzaG91bGQgcmV0dXJuIGEgZmllbGQgdGVsbGluZyB0aGUgdHlwZSBvZiBhIGZpZWxkXG4gICAgXHQgIH0gZWxzZSBpZiAoYXR0cnMuaWQgPT0gJ2NvbXB1dGVkWWVhcicpIHtcbiAgICBcdFx0ICB0bXBNb2RlbCA9IG5ldyBZZWFyc09ubHlGaWx0ZXJNb2RlbChhdHRycyk7XG4gICAgXHQgIH0gZWxzZSB7XG4gICAgXHRcdCAgdG1wTW9kZWwgPSBuZXcgR2VuZXJpY0ZpbHRlck1vZGVsKGF0dHJzKTtcbiAgICBcdFx0ICBzZWxmLl9hbGxEZWZlcnJlZHMucHVzaCh0bXBNb2RlbC5nZXRUcmVlKCkpO1xuICAgIFx0ICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRtcE1vZGVsO1xuICB9LFxuXG4gIC8vIGdldCBlbmRwb2ludCdzIGNoaWxkcmVuIGFuZCBsb2FkIHRoZW0gaW50byBzZWxmLi4uXG4gIF9nb09uZURlZXBlcjogZnVuY3Rpb24oc2VsZiwgYXR0cnMpIHtcbiAgICB2YXIgdXJsID0gYXR0cnMuZW5kcG9pbnQ7XG4gICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuICAgIHZhciB0bXBEZWZlcnJlZHMgPSBbXTtcblxuICAgIHZhciB0bXBDb2xsZWN0aW9uID0gbmV3IEJhY2tib25lLkNvbGxlY3Rpb24oKTtcbiAgICB0bXBDb2xsZWN0aW9uLnVybCA9IHVybDtcbiAgICB0bXBDb2xsZWN0aW9uLmZldGNoKCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICBfLmVhY2goZGF0YSwgZnVuY3Rpb24oQVBJRmlsdGVyKSB7XG4gICAgICAgIHZhciB0bXBNb2RlbCA9IG5ldyBHZW5lcmljRmlsdGVyTW9kZWwoe1xuICAgICAgICAgIHVybDogdXJsICsgJy8nICsgQVBJRmlsdGVyLmlkLFxuICAgICAgICAgIG5hbWU6IEFQSUZpbHRlci5uYW1lLFxuICAgICAgICAgIHRhYjogQVBJRmlsdGVyLnRhYixcbiAgICAgICAgICB1aTogdHJ1ZSxcbiAgICAgICAgICBncm91cDogYXR0cnMuaWQsXG4gICAgICAgICAgZW1wdHk6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLmFkZCh0bXBNb2RlbCk7XG4gICAgICAgIHRtcERlZmVycmVkcy5wdXNoKHRtcE1vZGVsLmdldFRyZWUoKSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKF8uaXNFbXB0eShkYXRhKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZpbHRlcnMgQVBJIHJldHVybmVkIGVtcHR5JywgdXJsKTtcbiAgICAgICAgLy8gQ3JlYXRlIGVtcHR5IG1vZGVsIHNvIHRoZSB2aWV3IGRvZXNudCBmYWlsLlxuICAgICAgICB2YXIgdG1wTW9kZWwgPSBuZXcgR2VuZXJpY0ZpbHRlck1vZGVsKHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgbmFtZTogYXR0cnMubmFtZSxcbiAgICAgICAgICAgIHVpOiB0cnVlLFxuICAgICAgICAgICAgZ3JvdXA6IGF0dHJzLmlkLFxuICAgICAgICAgICAgZW1wdHk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmFkZCh0bXBNb2RlbCk7XG4gICAgICAgICAgdG1wRGVmZXJyZWRzLnB1c2godG1wTW9kZWwuZ2V0VHJlZSgpKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgJC53aGVuLmFwcGx5KCQsIHRtcERlZmVycmVkcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH0sXG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTcGVjaWFsIG9yZyBhbmQgZG9ub3Igc3BlY2lmaWMgY29kZSBzaW5jZSBpdCBoYXMgc3BlY2lhbCBiZWhhdmlvdXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIF9jcmVhdGVPcmdGaWx0ZXJzOmZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIENyZWF0ZSAnam9pbnMnIGZvciBlYWNoIHR5cGUgYWRkIHJlZiB0byBncm91cHMsIGFuZCBmb3IgZWFjaCBncm91cCBhZGQgcmVmcyB0byBvcmdzLlxuICAgIHJldHVybiB0aGlzLl9mZXRjaE9yZ0NvbGxlY3Rpb25zKCkudGhlbihmdW5jdGlvbigpIHtcblxuICAgICAgLy8ganNvbmlmeSBvcmdzIGFuZCBzZXQgdGhlbSBhcyBjaGlsZHJlbiBpbiBncm91cHMuXG5cbiAgICAgIHNlbGYubWFrZVRyZWVIZWxwZXIoc2VsZi5vcmdHcm91cENvbGxlY3Rpb24sIHNlbGYub3JnQ29sbGVjdGlvbiwgJ29yZ0lkcycsICdjaGlsZHJlbicpO1xuXG5cbiAgICAgIC8vIEZvciBlYWNoIHJvbGUgY3JlYXRlIGEgZmlsdGVyIHdpdGggY29sbGVjdGlvbiBvZiBqdXN0IG9yZ3MgdGhhdCBtYXRjaC5cbiAgICAgIHNlbGYub3JnUm9sZXNDb2xsZWN0aW9uLmVhY2goZnVuY3Rpb24ocm9sZSkge1xuICAgICAgICB2YXIgdG1wSlNPTiA9IHJvbGUudG9KU09OKCk7XG5cbiAgICAgICAgLy8gdHJlYXQgZG9ub3IgZGlmZmVyZW50bHkuLi5cbiAgICAgICAgaWYgKHJvbGUuZ2V0KCduYW1lJykgPT09ICdEb25vcicpIHtcbiAgICAgICAgICBzZWxmLm1ha2VUcmVlSGVscGVyKHNlbGYub3JnVHlwZUNvbGxlY3Rpb24sIHNlbGYub3JnR3JvdXBDb2xsZWN0aW9uLCAnZ3JvdXBJZHMnLCAnY2hpbGRyZW4nKTtcbiAgICAgICAgICAvLyBDcmVhdGUgdHJlZSByb290Tm9kZSBhbmQgcmF3IEpTT04uXG4gICAgICAgICAgXy5leHRlbmQodG1wSlNPTixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdWk6IHRydWUsXG4gICAgICAgICAgICAgIGdyb3VwOiAnRG9ub3InLFxuICAgICAgICAgICAgICB0YWI6ICdGdW5kaW5nIE9yZ2FuaXphdGlvbnMnLFxuICAgICAgICAgICAgICBkYXRhOiBzZWxmLm9yZ1R5cGVDb2xsZWN0aW9uLnRvSlNPTigpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGZpbHRlciBvcmdzLi4uXG4gICAgICAgICAgdG1wSlNPTi5kYXRhID0gc2VsZi5fZmlsdGVyRG9ub3JPcmdzKHRtcEpTT04uZGF0YSwgcm9sZS5pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIHRyZWUgcm9vdE5vZGUgYW5kIHJhdyBKU09OLlxuICAgICAgICAgIF8uZXh0ZW5kKHRtcEpTT04sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHVpOiB0cnVlLFxuICAgICAgICAgICAgICBncm91cDogJ1JvbGUnLCAvL1RPRE86ID9zaG91bGQgdGhpcyBiZSAnUm9sZScgb3Igcm9sZS5pZCBvciByb2xlLmdldCgnbmFtZScpP1xuICAgICAgICAgICAgICB0YWI6ICdBbGwgQWdlbmNpZXMnLFxuICAgICAgICAgICAgICBkYXRhOiBzZWxmLm9yZ0dyb3VwQ29sbGVjdGlvbi50b0pTT04oKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvL3JlbW92ZSBhbGwgb3JncyB0aGF0IGRvbid0IGJlbG9uZyBpbiB0aGlzIHJvbGVcbiAgICAgICAgICB0bXBKU09OLmRhdGEgPSBzZWxmLl9maWx0ZXJPcmdzKHRtcEpTT04uZGF0YSwgcm9sZS5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG1wSlNPTi5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgXHQvL1RoZSByb2xlIG5hbWUgaXMgRG9ub3IgYW5kIHRoZSBiYWNrIGVuZCwgZm9yIGRvbm9yLCBpcyBleHBlY3RpbmcgZWl0aGVyIERvbm9yIElkIG9yIERvbm9yIEFnZW5jeVxuICAgICAgICAgIHZhciBjdXJyZW50RmlsdGVySWQgPSByb2xlLmdldCgnbmFtZScpICsgKHJvbGUuZ2V0KCduYW1lJykgPT09ICdEb25vcic/IFwiIEFnZW5jeVwiOlwiXCIpO1xuICAgICAgICAgIHRtcEpTT04uZGF0YSA9IHNlbGYuX3NldEZpbHRlcklkKHRtcEpTT04uZGF0YSwgY3VycmVudEZpbHRlcklkKTtcbiAgICAgICAgICBzZWxmLmFkZChuZXcgT3JnUm9sZUZpbHRlck1vZGVsKHRtcEpTT04pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vb25seSBuZWVkZWQgZm9yIGRvbm9yIGlmIHdlIHdhbnQgdG8gZG8gc3BlY2lhbCBsaXN0ZW5pbmcuLi4uOlxuICAgICAgLy8gc2VsZi5qb2luSGVscGVyKHNlbGYub3JnVHlwZUNvbGxlY3Rpb24sIHNlbGYub3JnR3JvdXBDb2xsZWN0aW9uLCAnZ3JvdXBJZHMnLCAnZ3JvdXBzJyk7XG4gICAgICAvLyBzZWxmLmpvaW5IZWxwZXIoc2VsZi5vcmdHcm91cENvbGxlY3Rpb24sIHNlbGYub3JnQ29sbGVjdGlvbiwgJ29yZ0lkcycsICdvcmdzJyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gZXhwbGljaXRseSBzZXRzIHRoZSBmaWx0ZXIgaWQgb24gYWxsIHRoZSBvcmdzLlxuICBfc2V0RmlsdGVySWQ6IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGZpbHRlcklkKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXy5lYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKG9yZykge1xuICAgICAgLy9vbmx5IHNldCBmaWx0ZXJJZCBvbiBvcmdzLCBub3QgZ3JvdXAgb3IgdHlwZSwgb3IgaXQgd2lsbCBjYXVzZSBidWdzLlxuICAgICAgaWYob3JnLnJvbGVzSWRzKXtcbiAgICAgICAgb3JnLmZpbHRlcklkID0gZmlsdGVySWQ7XG4gICAgICB9XG4gICAgICBpZihvcmcuY2hpbGRyZW4pe1xuICAgICAgICBvcmcuY2hpbGRyZW4gPSBzZWxmLl9zZXRGaWx0ZXJJZChvcmcuY2hpbGRyZW4sIGZpbHRlcklkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9LFxuXG5cblxuICAvLyBmaWx0ZXIgb3JncyB0cmVlIHRvIG9ubHkgb3JncyB0aGF0IGFwcGVhciBhcyB0aGUgZ2l2ZW4gcm9sZUlEXG4gIF9maWx0ZXJPcmdzOiBmdW5jdGlvbihvcmdHcm91cHNKU09OLCByb2xlSUQpIHtcbiAgICBvcmdHcm91cHNKU09OID0gXy5maWx0ZXIob3JnR3JvdXBzSlNPTiwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgIGdyb3VwLmNoaWxkcmVuID0gXy5maWx0ZXIoZ3JvdXAuY2hpbGRyZW4sIGZ1bmN0aW9uKG9yZykge1xuICAgICAgICByZXR1cm4gKG9yZy5yb2xlc0lkcy5pbmRleE9mKHJvbGVJRCkgPiAtMSk7XG4gICAgICB9KTtcbiAgICAgIGdyb3VwLmlzU2VsZWN0YWJsZSA9IGZhbHNlOyAvL3N0b3BzIHRyZWUgZnJvbSBjcmVhdGluZyAndW5rb3duJyBjaGlsZHJlbi5cbiAgICAgIHJldHVybiAoZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoID4gMCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9yZ0dyb3Vwc0pTT047XG4gIH0sXG5cblxuXHQgIC8vIHNwZWNpYWwgY2FzZSBmb3IgZG9ub3IgdHJlZSwgc2luY2UgaXQgaGFzIHR5cGVcblx0X2ZpbHRlckRvbm9yT3JncyA6IGZ1bmN0aW9uKG9yZ1R5cGVzSlNPTiwgcm9sZUlEKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdG9yZ1R5cGVzSlNPTiA9IF8uZmlsdGVyKG9yZ1R5cGVzSlNPTiwgZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dHlwZS5jaGlsZHJlbiA9IHNlbGYuX2ZpbHRlck9yZ3ModHlwZS5jaGlsZHJlbiwgcm9sZUlEKTtcblx0XG5cdFx0XHRfLmVhY2godHlwZS5jaGlsZHJlbiwgZnVuY3Rpb24oZ3JvdXApIHtcblx0XHRcdFx0Z3JvdXAuZmlsdGVySWQgPSAnRG9ub3IgR3JvdXAnO1xuXHRcdFx0fSk7XHRcblxuXHRcdFx0dHlwZS5maWx0ZXJJZCA9ICdEb25vciBUeXBlJztcblx0XHRcdHR5cGUuaXNTZWxlY3RhYmxlID0gZmFsc2U7IC8vIHN0b3BzIHRyZWUgZnJvbSBjcmVhdGluZyAndW5rb3duJyBjaGlsZHJlbi5cblx0XHRcdHJldHVybiAodHlwZS5jaGlsZHJlbi5sZW5ndGggPiAwKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gb3JnVHlwZXNKU09OO1xuXHR9LFxuXG4gICAgLy8gMS4gZ2V0IGFsbCBvcmdzLCBncm91cHMsIHR5cGVzLCBhbmQgcm9sZXNcbiAgX2ZldGNoT3JnQ29sbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmaWx0ZXJEZWZlcnJlZHMgPSBbXTtcblxuICAgIHRoaXMub3JnQ29sbGVjdGlvbiA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKCk7XG4gICAgdGhpcy5vcmdDb2xsZWN0aW9uLnVybCA9ICcvcmVzdC9maWx0ZXJzL29yZ3MnO1xuICAgIGZpbHRlckRlZmVycmVkcy5wdXNoKHRoaXMub3JnQ29sbGVjdGlvbi5mZXRjaCgpKTtcblxuICAgIHRoaXMub3JnR3JvdXBDb2xsZWN0aW9uID0gbmV3IEJhY2tib25lLkNvbGxlY3Rpb24oKTtcbiAgICB0aGlzLm9yZ0dyb3VwQ29sbGVjdGlvbi51cmwgPSAnL3Jlc3QvZmlsdGVycy9vcmctZ3JvdXBzJztcbiAgICBmaWx0ZXJEZWZlcnJlZHMucHVzaCh0aGlzLm9yZ0dyb3VwQ29sbGVjdGlvbi5mZXRjaCgpKTtcblxuICAgIHRoaXMub3JnVHlwZUNvbGxlY3Rpb24gPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbigpO1xuICAgIHRoaXMub3JnVHlwZUNvbGxlY3Rpb24udXJsID0gJy9yZXN0L2ZpbHRlcnMvb3JnLXR5cGVzJztcbiAgICBmaWx0ZXJEZWZlcnJlZHMucHVzaCh0aGlzLm9yZ1R5cGVDb2xsZWN0aW9uLmZldGNoKCkpO1xuXG4gICAgdGhpcy5vcmdSb2xlc0NvbGxlY3Rpb24gPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbigpO1xuICAgIHRoaXMub3JnUm9sZXNDb2xsZWN0aW9uLnVybCA9ICcvcmVzdC9maWx0ZXJzL29yZy1yb2xlcyc7XG4gICAgZmlsdGVyRGVmZXJyZWRzLnB1c2godGhpcy5vcmdSb2xlc0NvbGxlY3Rpb24uZmV0Y2goe30pKTtcblxuICAgIHJldHVybiAkLndoZW4uYXBwbHkoJCwgZmlsdGVyRGVmZXJyZWRzKTtcbiAgfSxcblxuXG4gIC8vIEFkZHMgcmVmZXJlbmNlcyB0byBjb2xsZWN0aW9uQiBpbnRvIGNvbGxlY3Rpb25BIGpvaW5pbmcgb24gZ2l2ZW4gZm9yZWlnbiBrZXlcbiAgLy8gVE9ETzogb3B0aW9uIHRvIGFkZCBiaS1kaXJlY3Rpb25hbCByZWZlcmVuY2UuXG4gIGpvaW5IZWxwZXI6IGZ1bmN0aW9uKGNvbGxlY3Rpb25BLCBjb2xsZWN0aW9uQiwga2V5Rm9yRm9yZWlnbklELCBrZXlGb3JDb2xsZWN0aW9uRGVzdGluYXRpb24pIHtcbiAgICBjb2xsZWN0aW9uQS5lYWNoKGZ1bmN0aW9uKG1vZGVsQSkge1xuICAgICAgdmFyIGlkc1RvSm9pbiA9IG1vZGVsQS5nZXQoa2V5Rm9yRm9yZWlnbklEKTtcbiAgICAgIHZhciB0ZW1wQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb25CLmZpbHRlcihmdW5jdGlvbihtb2RlbEIpIHtcbiAgICAgICAgcmV0dXJuIF8uaW5kZXhPZihpZHNUb0pvaW4sIG1vZGVsQi5nZXQoJ2lkJykpID49IDA7XG4gICAgICB9KTtcblxuICAgICAgbW9kZWxBLnNldChrZXlGb3JDb2xsZWN0aW9uRGVzdGluYXRpb24sIHRlbXBDb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgfSxcblxuICBtYWtlVHJlZUhlbHBlciA6IGZ1bmN0aW9uKHBhcmVudENvbGxlY3Rpb24sIGNoaWxkQ29sbGVjdGlvbiwga2V5Rm9yRm9yZWlnbklELCBrZXlGb3JDb2xsZWN0aW9uRGVzdGluYXRpb24pIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdmFyIGRvbm9yUm9sZSA9IF8uZmlsdGVyKHNlbGYub3JnUm9sZXNDb2xsZWN0aW9uLm1vZGVscywgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuIGl0ZW0uZ2V0KCduYW1lJykgPT09ICdEb25vcic7XG5cdFx0fSlbMF07XG5cdFx0cGFyZW50Q29sbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKHBhcmVudCkge1xuXHRcdFx0dmFyIGlkc1RvSm9pbiA9IHBhcmVudC5nZXQoa2V5Rm9yRm9yZWlnbklEKTtcblx0XHRcdHZhciB0ZW1wQ29sbGVjdGlvbiA9IGNoaWxkQ29sbGVjdGlvbi50b0pTT04oKTtcblx0XHRcdFxuXHRcdFx0Ly8gQmVjYXVzZSBvZiB0aGUgYnVzaW5lc3MgbG9naWMgb2Ygb2xkIGZpbHRlcnMsIGlmIGFuIG9yZ2FuaXphdGlvbiBoYXMgYmVlbiB1c2VkIGFzIGEgZnVuZGluZyBvcmdcblx0XHRcdC8vIChwcmVzZW50IGluIGFtcF9mdW5kaW5nKSB0aGVuIHdlIG5lZWQgdG9cblx0XHRcdC8vIGFkZCBpdCB0byB0aGUgbGlzdCBvZiAnRG9ub3JzJyBubyBtYXR0ZXIgd2hpY2ggaXMgdGhlICdyb2xlJyBvZiB0aGF0IG9yZ2FuaXphdGlvbiwgc28gaW4gb3JkZXIgdG9cblx0XHRcdC8vIG1ha2UgaXQgYXBwZWFyIGluIHRoZSB0cmVlIHdlIGFsc28gbmVlZCB0b1xuXHRcdFx0Ly8gYWRkIHRoZSAnRE4nIHJvbCB0byBpdCwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgaWdub3JlZCBldmVuIGlmIGl0cyBpbiB0ZW1wQ29sbGVjdGlvbi5cblx0XHRcdHRlbXBDb2xsZWN0aW9uID0gXy5lYWNoKHRlbXBDb2xsZWN0aW9uLGZ1bmN0aW9uKGF1eCkge1xuXHRcdFx0XHRpZiAoYXV4Lmhhc0Z1bmRpbmdzID09PSB0cnVlICYmIGF1eC5yb2xlc0lkcyAhPSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRhdXgucm9sZXNJZHMucHVzaChkb25vclJvbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRlbXBDb2xsZWN0aW9uID0gXy5maWx0ZXIodGVtcENvbGxlY3Rpb24sZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRcdHJldHVybiBfLmNvbnRhaW5zKGlkc1RvSm9pbiwgdmFsLmlkKTtcblx0XHRcdH0pO1xuXHRcdFx0cGFyZW50LnNldChrZXlGb3JDb2xsZWN0aW9uRGVzdGluYXRpb24sIHRlbXBDb2xsZWN0aW9uKTtcblx0XHR9KTtcblx0fVxufSk7XG4iLCJcbnZhciBEZWZlcnJlZCA9IHJlcXVpcmUoJ2pxdWVyeScpLkRlZmVycmVkO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIFNldHRpbmcgPSByZXF1aXJlKCcuLi9tb2RlbHMvc2V0dGluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyAgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cdFx0bW9kZWwgOiBTZXR0aW5nLFxuXHRcdHVybCA6ICcvcmVzdC9hbXAvc2V0dGluZ3MnXG59KTtcblxuIiwiLyohIGpRdWVyeSBVSSAtIHYxLjEwLjQgLSAyMDE0LTAxLTE3XG4qIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiogSW5jbHVkZXM6IGpxdWVyeS51aS5kYXRlcGlja2VyLWFmLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1hci1EWi5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItYXIuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWF6LmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1iZS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItYmcuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWJzLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1jYS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItY3MuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWN5LUdCLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1kYS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItZGUuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWVsLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1lbi1BVS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItZW4tR0IuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWVuLU5aLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1lby5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItZXMuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWV0LmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1ldS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItZmEuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWZpLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1mby5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItZnItQ0EuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWZyLUNILmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1mci5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItZ2wuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWhlLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1oaS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItaHIuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWh1LmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1oeS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItaWQuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWlzLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1pdC5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItamEuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWthLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1ray5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXIta20uanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWtvLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1reS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItbGIuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLWx0LmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1sdi5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItbWsuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLW1sLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1tcy5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItbmIuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLW5sLUJFLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1ubC5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItbm4uanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLW5vLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1wbC5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItcHQtQlIuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXB0LmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1ybS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItcm8uanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXJ1LmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1zay5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItc2wuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXNxLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci1zci1TUi5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItc3IuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXN2LmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci10YS5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItdGguanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXRqLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci10ci5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItdWsuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXZpLmpzLCBqcXVlcnkudWkuZGF0ZXBpY2tlci16aC1DTi5qcywganF1ZXJ5LnVpLmRhdGVwaWNrZXItemgtSEsuanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLXpoLVRXLmpzXG4qIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnM7IExpY2Vuc2VkIE1JVCAqL1xuLyogQWZyaWthYW5zIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgUmVuaWVyIFByZXRvcml1cy4gKi9cbi8qQUxURVJFRCBGT1IgQU1QIC0tIEFEREVEIFRFVFVNIExPQ0FMRSovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnYWYnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdTZWxla3RlZXInLFxuXHRcdHByZXZUZXh0OiAnVm9yaWdlJyxcblx0XHRuZXh0VGV4dDogJ1ZvbGdlbmRlJyxcblx0XHRjdXJyZW50VGV4dDogJ1ZhbmRhZycsXG5cdFx0bW9udGhOYW1lczogWydKYW51YXJpZScsJ0ZlYnJ1YXJpZScsJ01hYXJ0JywnQXByaWwnLCdNZWknLCdKdW5pZScsXG5cdFx0J0p1bGllJywnQXVndXN0dXMnLCdTZXB0ZW1iZXInLCdPa3RvYmVyJywnTm92ZW1iZXInLCdEZXNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCAnRmViJywgJ01ydCcsICdBcHInLCAnTWVpJywgJ0p1bicsXG5cdFx0J0p1bCcsICdBdWcnLCAnU2VwJywgJ09rdCcsICdOb3YnLCAnRGVzJ10sXG5cdFx0ZGF5TmFtZXM6IFsnU29uZGFnJywgJ01hYW5kYWcnLCAnRGluc2RhZycsICdXb2Vuc2RhZycsICdEb25kZXJkYWcnLCAnVnJ5ZGFnJywgJ1NhdGVyZGFnJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydTb24nLCAnTWFhJywgJ0RpbicsICdXb2UnLCAnRG9uJywgJ1ZyeScsICdTYXQnXSxcblx0XHRkYXlOYW1lc01pbjogWydTbycsJ01hJywnRGknLCdXbycsJ0RvJywnVnInLCdTYSddLFxuXHRcdHdlZWtIZWFkZXI6ICdXaycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2FmJ10pO1xufSk7XG5cbi8qIEFsZ2VyaWFuIEFyYWJpYyBUcmFuc2xhdGlvbiBmb3IgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKGNhbiBiZSB1c2VkIGZvciBUdW5pc2lhKSovXG4vKiBNb2hhbWVkIENoZXJpZiBCT1VDSEVMQUdIRU0gLS0gY2hlcmlmYm91Y2hlbGFnaGVtQHlhaG9vLmZyICovXG5cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydhci1EWiddID0ge1xuXHRcdGNsb3NlVGV4dDogJ9il2LrZhNin2YInLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M72KfZhNiz2KfYqNmCJyxcblx0XHRuZXh0VGV4dDogJ9in2YTYqtin2YTZiiYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICfYp9mE2YrZiNmFJyxcblx0XHRtb250aE5hbWVzOiBbJ9is2KfZhtmB2YonLCAn2YHZitmB2LHZiicsICfZhdin2LHYsycsICfYo9mB2LHZitmEJywgJ9mF2KfZiicsICfYrNmI2KfZhicsXG5cdFx0J9is2YjZitmE2YrYqScsICfYo9mI2KonLCAn2LPYqNiq2YXYqNixJywn2KPZg9iq2YjYqNixJywgJ9mG2YjZgdmF2KjYsScsICfYr9mK2LPZhdio2LEnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnMTAnLCAnMTEnLCAnMTInXSxcblx0XHRkYXlOYW1lczogWyfYp9mE2KPYrdivJywgJ9in2YTYp9ir2YbZitmGJywgJ9in2YTYq9mE2KfYq9in2KEnLCAn2KfZhNij2LHYqNi52KfYoScsICfYp9mE2K7ZhdmK2LMnLCAn2KfZhNis2YXYudipJywgJ9in2YTYs9io2KonXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ9in2YTYo9it2K8nLCAn2KfZhNin2KvZhtmK2YYnLCAn2KfZhNir2YTYp9ir2KfYoScsICfYp9mE2KPYsdio2LnYp9ihJywgJ9in2YTYrtmF2YrYsycsICfYp9mE2KzZhdi52KknLCAn2KfZhNiz2KjYqiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ9in2YTYo9it2K8nLCAn2KfZhNin2KvZhtmK2YYnLCAn2KfZhNir2YTYp9ir2KfYoScsICfYp9mE2KPYsdio2LnYp9ihJywgJ9in2YTYrtmF2YrYsycsICfYp9mE2KzZhdi52KknLCAn2KfZhNiz2KjYqiddLFxuXHRcdHdlZWtIZWFkZXI6ICfYo9iz2KjZiNi5Jyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiA2LFxuICBcdFx0aXNSVEw6IHRydWUsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2FyLURaJ10pO1xufSk7XG5cbi8qIEFyYWJpYyBUcmFuc2xhdGlvbiBmb3IgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIEtoYWxlZCBBbGhvdXJhbmkgLS0gbWVAa2hhbGVkYWxob3VyYW5pLmNvbSAqL1xuLyogTk9URTogbW9udGhOYW1lcyBhcmUgdGhlIG9yaWdpbmFsIG1vbnRocyBuYW1lcyBhbmQgdGhleSBhcmUgdGhlIEFyYWJpYyBuYW1lcywgbm90IHRoZSBuZXcgbW9udGhzIG5hbWUg2YHYqNix2KfZitixIC0g2YrZhtin2YrYsSBhbmQgdGhlcmUgaXNuJ3QgYW55IEFyYWJpYyByb290cyBmb3IgdGhlc2UgbW9udGhzICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnYXInXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfYpdi62YTYp9mCJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO9in2YTYs9in2KjZgicsXG5cdFx0bmV4dFRleHQ6ICfYp9mE2KrYp9mE2YomI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn2KfZhNmK2YjZhScsXG5cdFx0bW9udGhOYW1lczogWyfZg9in2YbZiNmGINin2YTYq9in2YbZiicsICfYtNio2KfYtycsICfYotiw2KfYsScsICfZhtmK2LPYp9mGJywgJ9mF2KfZitmIJywgJ9it2LLZitix2KfZhicsXG5cdFx0J9iq2YXZiNiyJywgJ9ii2KgnLCAn2KPZitmE2YjZhCcsXHQn2KrYtNix2YrZhiDYp9mE2KPZiNmEJywgJ9iq2LTYsdmK2YYg2KfZhNir2KfZhtmKJywgJ9mD2KfZhtmI2YYg2KfZhNij2YjZhCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWycxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICcxMCcsICcxMScsICcxMiddLFxuXHRcdGRheU5hbWVzOiBbJ9in2YTYo9it2K8nLCAn2KfZhNin2KvZhtmK2YYnLCAn2KfZhNir2YTYp9ir2KfYoScsICfYp9mE2KPYsdio2LnYp9ihJywgJ9in2YTYrtmF2YrYsycsICfYp9mE2KzZhdi52KknLCAn2KfZhNiz2KjYqiddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn2KfZhNij2K3YrycsICfYp9mE2KfYq9mG2YrZhicsICfYp9mE2KvZhNin2KvYp9ihJywgJ9in2YTYo9ix2KjYudin2KEnLCAn2KfZhNiu2YXZitizJywgJ9in2YTYrNmF2LnYqScsICfYp9mE2LPYqNiqJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn2K0nLCAn2YYnLCAn2KsnLCAn2LEnLCAn2K4nLCAn2KwnLCAn2LMnXSxcblx0XHR3ZWVrSGVhZGVyOiAn2KPYs9io2YjYuScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogNixcbiAgXHRcdGlzUlRMOiB0cnVlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydhciddKTtcbn0pO1xuXG4vKiBBemVyYmFpamFuaSAoVVRGLTgpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgSmFtaWwgTmFqYWZvdiAobmVjZWZvdjMzQGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCkge1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2F6J10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnQmHEn2xhJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO0dlcmknLFxuXHRcdG5leHRUZXh0OiAnxLByyZlsaSYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdCdWfDvG4nLFxuXHRcdG1vbnRoTmFtZXM6IFsnWWFudmFyJywnRmV2cmFsJywnTWFydCcsJ0FwcmVsJywnTWF5JywnxLB5dW4nLFxuXHRcdCfEsHl1bCcsJ0F2cXVzdCcsJ1NlbnR5YWJyJywnT2t0eWFicicsJ05veWFicicsJ0Rla2FiciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydZYW4nLCdGZXYnLCdNYXInLCdBcHInLCdNYXknLCfEsHl1bicsXG5cdFx0J8SweXVsJywnQXZxJywnU2VuJywnT2t0JywnTm95JywnRGVrJ10sXG5cdFx0ZGF5TmFtZXM6IFsnQmF6YXInLCdCYXphciBlcnTJmXNpJywnw4fJmXLFn8mZbmLJmSBheMWfYW3EsScsJ8OHyZlyxZ/JmW5iyZknLCdDw7xtyZkgYXjFn2FtxLEnLCdDw7xtyZknLCfFnsmZbmLJmSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnQicsJ0JlJywnw4dhJywnw4cnLCdDYScsJ0MnLCfFniddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0InLCdCJywnw4cnLCfQoScsJ8OHJywnQycsJ8WeJ10sXG5cdFx0d2Vla0hlYWRlcjogJ0hmJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnYXonXSk7XG59KTtcblxuLyogQmVsYXJ1c2lhbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IFBhdmVsIFNlbGl0c2thcyA8cC5zZWxpdHNrYXNAZ21haWwuY29tPiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2JlJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn0JfQsNGH0YvQvdGW0YbRjCcsXG5cdFx0cHJldlRleHQ6ICcmbGFycjvQn9Cw0L/Rj9GALicsXG5cdFx0bmV4dFRleHQ6ICfQndCw0YHRgi4mcmFycjsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn0KHRkdC90YzQvdGPJyxcblx0XHRtb250aE5hbWVzOiBbJ9Ch0YLRg9C00LfQtdC90YwnLCfQm9GO0YLRiycsJ9Ch0LDQutCw0LLRltC6Jywn0JrRgNCw0YHQsNCy0ZbQuicsJ9Ci0YDQsNCy0LXQvdGMJywn0KfRjdGA0LLQtdC90YwnLFxuXHRcdCfQm9GW0L/QtdC90YwnLCfQltC90ZbQstC10L3RjCcsJ9CS0LXRgNCw0YHQtdC90YwnLCfQmtCw0YHRgtGA0YvRh9C90ZbQuicsJ9Cb0ZbRgdGC0LDQv9Cw0LQnLCfQodGM0L3QtdC20LDQvdGMJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ9Ch0YLRgycsJ9Cb0Y7RgicsJ9Ch0LDQuicsJ9Ca0YDQsCcsJ9Ci0YDQsCcsJ9Cn0Y3RgCcsXG5cdFx0J9Cb0ZbQvycsJ9CW0L3RlicsJ9CS0LXRgCcsJ9Ca0LDRgScsJ9Cb0ZbRgScsJ9Ch0YzQvSddLFxuXHRcdGRheU5hbWVzOiBbJ9C90Y/QtNC30LXQu9GPJywn0L/QsNC90Y/QtNC30LXQu9Cw0LonLCfQsNGe0YLQvtGA0LDQuicsJ9GB0LXRgNCw0LTQsCcsJ9GH0LDRhtGM0LLQtdGAJywn0L/Rj9GC0L3RltGG0LAnLCfRgdGD0LHQvtGC0LAnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ9C90LTQtycsJ9C/0L3QtCcsJ9Cw0Z7RgicsJ9GB0YDQtCcsJ9GH0YbQsicsJ9C/0YLQvScsJ9GB0LHRgiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ9Cd0LQnLCfQn9C9Jywn0JDRnicsJ9Ch0YAnLCfQp9GGJywn0J/RgicsJ9Ch0LEnXSxcblx0XHR3ZWVrSGVhZGVyOiAn0KLQtCcsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2JlJ10pO1xufSk7XG5cbi8qIEJ1bGdhcmlhbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IFN0b3lhbiBLeW9zZXYgKGh0dHA6Ly9zdmVzdC5vcmcpLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2JnJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn0LfQsNGC0LLQvtGA0LgnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M70L3QsNC30LDQtCcsXG5cdFx0bmV4dFRleHQ6ICfQvdCw0L/RgNC10LQmI3gzRTsnLFxuXHRcdG5leHRCaWdUZXh0OiAnJiN4M0U7JiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ9C00L3QtdGBJyxcblx0XHRtb250aE5hbWVzOiBbJ9Cv0L3Rg9Cw0YDQuCcsJ9Ck0LXQstGA0YPQsNGA0LgnLCfQnNCw0YDRgicsJ9CQ0L/RgNC40LsnLCfQnNCw0LknLCfQrtC90LgnLFxuXHRcdCfQrtC70LgnLCfQkNCy0LPRg9GB0YInLCfQodC10L/RgtC10LzQstGA0LgnLCfQntC60YLQvtC80LLRgNC4Jywn0J3QvtC10LzQstGA0LgnLCfQlNC10LrQtdC80LLRgNC4J10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ9Cv0L3RgycsJ9Ck0LXQsicsJ9Cc0LDRgCcsJ9CQ0L/RgCcsJ9Cc0LDQuScsJ9Cu0L3QuCcsXG5cdFx0J9Cu0LvQuCcsJ9CQ0LLQsycsJ9Ch0LXQvycsJ9Ce0LrRgicsJ9Cd0L7QsicsJ9CU0LXQuiddLFxuXHRcdGRheU5hbWVzOiBbJ9Cd0LXQtNC10LvRjycsJ9Cf0L7QvdC10LTQtdC70L3QuNC6Jywn0JLRgtC+0YDQvdC40LonLCfQodGA0Y/QtNCwJywn0KfQtdGC0LLRitGA0YLRitC6Jywn0J/QtdGC0YrQuicsJ9Ch0YrQsdC+0YLQsCddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn0J3QtdC0Jywn0J/QvtC9Jywn0JLRgtC+Jywn0KHRgNGPJywn0KfQtdGCJywn0J/QtdGCJywn0KHRitCxJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn0J3QtScsJ9Cf0L4nLCfQktGCJywn0KHRgCcsJ9Cn0LUnLCfQn9C1Jywn0KHRiiddLFxuXHRcdHdlZWtIZWFkZXI6ICdXaycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2JnJ10pO1xufSk7XG5cbi8qIEJvc25pYW4gaTE4biBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IEtlbmFuIEtvbmpvLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2JzJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnWmF0dm9yaScsXG5cdFx0cHJldlRleHQ6ICcmI3gzQzsnLFxuXHRcdG5leHRUZXh0OiAnJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ0RhbmFzJyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcicsJ0ZlYnJ1YXInLCdNYXJ0JywnQXByaWwnLCdNYWonLCdKdW5pJyxcblx0XHQnSnVsaScsJ0F1Z3VzdCcsJ1NlcHRlbWJhcicsJ09rdG9iYXInLCdOb3ZlbWJhcicsJ0RlY2VtYmFyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZlYicsJ01hcicsJ0FwcicsJ01haicsJ0p1bicsXG5cdFx0J0p1bCcsJ0F1ZycsJ1NlcCcsJ09rdCcsJ05vdicsJ0RlYyddLFxuXHRcdGRheU5hbWVzOiBbJ05lZGVsamEnLCdQb25lZGVsamFrJywnVXRvcmFrJywnU3JpamVkYScsJ8SMZXR2cnRhaycsJ1BldGFrJywnU3Vib3RhJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydOZWQnLCdQb24nLCdVdG8nLCdTcmknLCfEjGV0JywnUGV0JywnU3ViJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnTmUnLCdQbycsJ1V0JywnU3InLCfEjGUnLCdQZScsJ1N1J10sXG5cdFx0d2Vla0hlYWRlcjogJ1drJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnYnMnXSk7XG59KTtcblxuLyogSW5pY2lhbGl0emFjacOzIGVuIGNhdGFsw6AgcGVyIGEgbCdleHRlbnNpw7MgJ1VJIGRhdGUgcGlja2VyJyBwZXIgalF1ZXJ5LiAqL1xuLyogV3JpdGVyczogKGpvYW4ubGVvbkBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2NhJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnVGFuY2EnLFxuXHRcdHByZXZUZXh0OiAnQW50ZXJpb3InLFxuXHRcdG5leHRUZXh0OiAnU2Vnw7xlbnQnLFxuXHRcdGN1cnJlbnRUZXh0OiAnQXZ1aScsXG5cdFx0bW9udGhOYW1lczogWydnZW5lcicsJ2ZlYnJlcicsJ21hcsOnJywnYWJyaWwnLCdtYWlnJywnanVueScsXG5cdFx0J2p1bGlvbCcsJ2Fnb3N0Jywnc2V0ZW1icmUnLCdvY3R1YnJlJywnbm92ZW1icmUnLCdkZXNlbWJyZSddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydnZW4nLCdmZWInLCdtYXLDpycsJ2FicicsJ21haWcnLCdqdW55Jyxcblx0XHQnanVsJywnYWcnLCdzZXQnLCdvY3QnLCdub3YnLCdkZXMnXSxcblx0XHRkYXlOYW1lczogWydkaXVtZW5nZScsJ2RpbGx1bnMnLCdkaW1hcnRzJywnZGltZWNyZXMnLCdkaWpvdXMnLCdkaXZlbmRyZXMnLCdkaXNzYWJ0ZSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnZGcnLCdkbCcsJ2R0JywnZGMnLCdkaicsJ2R2JywnZHMnXSxcblx0XHRkYXlOYW1lc01pbjogWydkZycsJ2RsJywnZHQnLCdkYycsJ2RqJywnZHYnLCdkcyddLFxuXHRcdHdlZWtIZWFkZXI6ICdTZXQnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydjYSddKTtcbn0pO1xuXG4vKiBDemVjaCBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IFRvbWFzIE11bGxlciAodG9tYXNAdG9tYXMtbXVsbGVyLm5ldCkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnY3MnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdaYXbFmcOtdCcsXG5cdFx0cHJldlRleHQ6ICcmI3gzQztExZnDrXZlJyxcblx0XHRuZXh0VGV4dDogJ1BvemTEm2ppJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ055bsOtJyxcblx0XHRtb250aE5hbWVzOiBbJ2xlZGVuJywnw7pub3InLCdixZllemVuJywnZHViZW4nLCdrdsSbdGVuJywnxI1lcnZlbicsXG5cdFx0J8SNZXJ2ZW5lYycsJ3NycGVuJywnesOhxZnDrScsJ8WZw61qZW4nLCdsaXN0b3BhZCcsJ3Byb3NpbmVjJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ2xlZCcsJ8O6bm8nLCdixZllJywnZHViJywna3bEmycsJ8SNZXInLFxuXHRcdCfEjXZjJywnc3JwJywnesOhxZknLCfFmcOtaicsJ2xpcycsJ3BybyddLFxuXHRcdGRheU5hbWVzOiBbJ25lZMSbbGUnLCAncG9uZMSbbMOtJywgJ8O6dGVyw70nLCAnc3TFmWVkYScsICfEjXR2cnRlaycsICdww6F0ZWsnLCAnc29ib3RhJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyduZScsICdwbycsICfDunQnLCAnc3QnLCAnxI10JywgJ3DDoScsICdzbyddLFxuXHRcdGRheU5hbWVzTWluOiBbJ25lJywncG8nLCfDunQnLCdzdCcsJ8SNdCcsJ3DDoScsJ3NvJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1TDvWQnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydjcyddKTtcbn0pO1xuXG4vKiBXZWxzaC9VSyBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IFdpbGxpYW0gR3JpZmZpdGhzLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2N5LUdCJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnRG9uZScsXG5cdFx0cHJldlRleHQ6ICdQcmV2Jyxcblx0XHRuZXh0VGV4dDogJ05leHQnLFxuXHRcdGN1cnJlbnRUZXh0OiAnVG9kYXknLFxuXHRcdG1vbnRoTmFtZXM6IFsnSW9uYXdyJywnQ2h3ZWZyb3InLCdNYXdydGgnLCdFYnJpbGwnLCdNYWknLCdNZWhlZmluJyxcblx0XHQnR29yZmZlbm5hZicsJ0F3c3QnLCdNZWRpJywnSHlkcmVmJywnVGFjaHdlZGQnLCdSaGFnZnlyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0lvbicsICdDaHcnLCAnTWF3JywgJ0VicicsICdNYWknLCAnTWVoJyxcblx0XHQnR29yJywgJ0F3cycsICdNZWQnLCAnSHlkJywgJ1RhYycsICdSaGEnXSxcblx0XHRkYXlOYW1lczogWydEeWRkIFN1bCcsICdEeWRkIExsdW4nLCAnRHlkZCBNYXdydGgnLCAnRHlkZCBNZXJjaGVyJywgJ0R5ZGQgSWF1JywgJ0R5ZGQgR3dlbmVyJywgJ0R5ZGQgU2Fkd3JuJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydTdWwnLCAnTGx1JywgJ01hdycsICdNZXInLCAnSWF1JywgJ0d3ZScsICdTYWQnXSxcblx0XHRkYXlOYW1lc01pbjogWydTdScsJ0xsJywnTWEnLCdNZScsJ0lhJywnR3cnLCdTYSddLFxuXHRcdHdlZWtIZWFkZXI6ICdXeScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2N5LUdCJ10pO1xufSk7XG5cbi8qIERhbmlzaCBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IEphbiBDaHJpc3RlbnNlbiAoIGRlbGV0ZXN0dWZmQGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZGEnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdMdWsnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7Rm9ycmlnZScsXG5cdFx0bmV4dFRleHQ6ICdOw6ZzdGUmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnSWRhZycsXG5cdFx0bW9udGhOYW1lczogWydKYW51YXInLCdGZWJydWFyJywnTWFydHMnLCdBcHJpbCcsJ01haicsJ0p1bmknLFxuXHRcdCdKdWxpJywnQXVndXN0JywnU2VwdGVtYmVyJywnT2t0b2JlcicsJ05vdmVtYmVyJywnRGVjZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywnRmViJywnTWFyJywnQXByJywnTWFqJywnSnVuJyxcblx0XHQnSnVsJywnQXVnJywnU2VwJywnT2t0JywnTm92JywnRGVjJ10sXG5cdFx0ZGF5TmFtZXM6IFsnU8O4bmRhZycsJ01hbmRhZycsJ1RpcnNkYWcnLCdPbnNkYWcnLCdUb3JzZGFnJywnRnJlZGFnJywnTMO4cmRhZyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnU8O4bicsJ01hbicsJ1RpcicsJ09ucycsJ1RvcicsJ0ZyZScsJ0zDuHInXSxcblx0XHRkYXlOYW1lc01pbjogWydTw7gnLCdNYScsJ1RpJywnT24nLCdUbycsJ0ZyJywnTMO4J10sXG5cdFx0d2Vla0hlYWRlcjogJ1VnZScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLW1tLXl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2RhJ10pO1xufSk7XG5cbi8qIEdlcm1hbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IE1pbGlhbiBXb2xmZiAobWFpbEBtaWxpYW53LmRlKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydkZSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ1NjaGxpZcOfZW4nLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7WnVyw7xjaycsXG5cdFx0bmV4dFRleHQ6ICdWb3ImI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnSGV1dGUnLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyJywnRmVicnVhcicsJ03DpHJ6JywnQXByaWwnLCdNYWknLCdKdW5pJyxcblx0XHQnSnVsaScsJ0F1Z3VzdCcsJ1NlcHRlbWJlcicsJ09rdG9iZXInLCdOb3ZlbWJlcicsJ0RlemVtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZlYicsJ03DpHInLCdBcHInLCdNYWknLCdKdW4nLFxuXHRcdCdKdWwnLCdBdWcnLCdTZXAnLCdPa3QnLCdOb3YnLCdEZXonXSxcblx0XHRkYXlOYW1lczogWydTb25udGFnJywnTW9udGFnJywnRGllbnN0YWcnLCdNaXR0d29jaCcsJ0Rvbm5lcnN0YWcnLCdGcmVpdGFnJywnU2Ftc3RhZyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnU28nLCdNbycsJ0RpJywnTWknLCdEbycsJ0ZyJywnU2EnXSxcblx0XHRkYXlOYW1lc01pbjogWydTbycsJ01vJywnRGknLCdNaScsJ0RvJywnRnInLCdTYSddLFxuXHRcdHdlZWtIZWFkZXI6ICdLVycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2RlJ10pO1xufSk7XG5cbi8qIEdyZWVrIChlbCkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBBbGV4IENpY292aWMgKGh0dHA6Ly93d3cuYWxleGNpY292aWMuY29tKSAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2VsJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnzprOu861zq/Pg865zrzOvycsXG5cdFx0cHJldlRleHQ6ICfOoM+Bzr/Ot86zzr/Pjc68zrXOvc6/z4InLFxuXHRcdG5leHRUZXh0OiAnzpXPgM+MzrzOtc69zr/PgicsXG5cdFx0Y3VycmVudFRleHQ6ICfOpM+Bzq3Ph8+Jzr0gzpzOrs69zrHPgicsXG5cdFx0bW9udGhOYW1lczogWyfOmc6xzr3Ov8+FzqzPgc65zr/PgicsJ86mzrXOss+Bzr/Phc6sz4HOuc6/z4InLCfOnM6sz4HPhM65zr/PgicsJ86Rz4DPgc6vzrvOuc6/z4InLCfOnM6szrnOv8+CJywnzpnOv8+Nzr3Ouc6/z4InLFxuXHRcdCfOmc6/z43Ou865zr/PgicsJ86Rz43Os86/z4XPg8+Ezr/PgicsJ86jzrXPgM+Ezq3OvM6yz4HOuc6/z4InLCfOn866z4TPjs6yz4HOuc6/z4InLCfOnc6/zq3OvM6yz4HOuc6/z4InLCfOlM61zrrOrc68zrLPgc65zr/PgiddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfOmc6xzr0nLCfOps61zrInLCfOnM6xz4EnLCfOkc+Az4EnLCfOnM6xzrknLCfOmc6/z4XOvScsXG5cdFx0J86Zzr/Phc67JywnzpHPhc6zJywnzqPOtc+AJywnzp/Ous+EJywnzp3Ov861JywnzpTOtc66J10sXG5cdFx0ZGF5TmFtZXM6IFsnzprPhc+BzrnOsc66zq4nLCfOlM61z4XPhM6tz4HOsScsJ86kz4HOr8+EzrcnLCfOpM61z4TOrM+Bz4TOtycsJ86gzq3OvM+Az4TOtycsJ86gzrHPgc6xz4POus61z4XOricsJ86jzqzOss6yzrHPhM6/J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfOms+Fz4EnLCfOlM61z4UnLCfOpM+BzrknLCfOpM61z4QnLCfOoM61zrwnLCfOoM6xz4EnLCfOo86xzrInXSxcblx0XHRkYXlOYW1lc01pbjogWyfOms+FJywnzpTOtScsJ86kz4EnLCfOpM61JywnzqDOtScsJ86gzrEnLCfOo86xJ10sXG5cdFx0d2Vla0hlYWRlcjogJ86VzrLOtCcsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2VsJ10pO1xufSk7XG5cbi8qIEVuZ2xpc2gvQXVzdHJhbGlhIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIEJhc2VkIG9uIHRoZSBlbi1HQiBpbml0aWFsaXNhdGlvbi4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlbi1BVSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0RvbmUnLFxuXHRcdHByZXZUZXh0OiAnUHJldicsXG5cdFx0bmV4dFRleHQ6ICdOZXh0Jyxcblx0XHRjdXJyZW50VGV4dDogJ1RvZGF5Jyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcnknLCdGZWJydWFyeScsJ01hcmNoJywnQXByaWwnLCdNYXknLCdKdW5lJyxcblx0XHQnSnVseScsJ0F1Z3VzdCcsJ1NlcHRlbWJlcicsJ09jdG9iZXInLCdOb3ZlbWJlcicsJ0RlY2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJyxcblx0XHQnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcblx0XHRkYXlOYW1lczogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU3UnLCdNbycsJ1R1JywnV2UnLCdUaCcsJ0ZyJywnU2EnXSxcblx0XHR3ZWVrSGVhZGVyOiAnV2snLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlbi1BVSddKTtcbn0pO1xuXG4vKiBFbmdsaXNoL1VLIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgU3R1YXJ0LiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2VuLUdCJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnRG9uZScsXG5cdFx0cHJldlRleHQ6ICdQcmV2Jyxcblx0XHRuZXh0VGV4dDogJ05leHQnLFxuXHRcdGN1cnJlbnRUZXh0OiAnVG9kYXknLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyeScsJ0ZlYnJ1YXJ5JywnTWFyY2gnLCdBcHJpbCcsJ01heScsJ0p1bmUnLFxuXHRcdCdKdWx5JywnQXVndXN0JywnU2VwdGVtYmVyJywnT2N0b2JlcicsJ05vdmVtYmVyJywnRGVjZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLFxuXHRcdCdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuXHRcdGRheU5hbWVzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcblx0XHRkYXlOYW1lc01pbjogWydTdScsJ01vJywnVHUnLCdXZScsJ1RoJywnRnInLCdTYSddLFxuXHRcdHdlZWtIZWFkZXI6ICdXaycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2VuLUdCJ10pO1xufSk7XG5cbi8qIEVuZ2xpc2gvTmV3IFplYWxhbmQgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogQmFzZWQgb24gdGhlIGVuLUdCIGluaXRpYWxpc2F0aW9uLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2VuLU5aJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnRG9uZScsXG5cdFx0cHJldlRleHQ6ICdQcmV2Jyxcblx0XHRuZXh0VGV4dDogJ05leHQnLFxuXHRcdGN1cnJlbnRUZXh0OiAnVG9kYXknLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyeScsJ0ZlYnJ1YXJ5JywnTWFyY2gnLCdBcHJpbCcsJ01heScsJ0p1bmUnLFxuXHRcdCdKdWx5JywnQXVndXN0JywnU2VwdGVtYmVyJywnT2N0b2JlcicsJ05vdmVtYmVyJywnRGVjZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLFxuXHRcdCdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuXHRcdGRheU5hbWVzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcblx0XHRkYXlOYW1lc01pbjogWydTdScsJ01vJywnVHUnLCdXZScsJ1RoJywnRnInLCdTYSddLFxuXHRcdHdlZWtIZWFkZXI6ICdXaycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2VuLU5aJ10pO1xufSk7XG5cbi8qIEVzcGVyYW50byBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IE9saXZpZXIgTS4gKG9saXZpZXJ3ZWJAaWZyYW5jZS5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2VvJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnRmVybWknLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7QW50YScsXG5cdFx0bmV4dFRleHQ6ICdTZWt2JiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ051bmEnLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFudWFybycsJ0ZlYnJ1YXJvJywnTWFydG8nLCdBcHJpbG8nLCdNYWpvJywnSnVuaW8nLFxuXHRcdCdKdWxpbycsJ0HFrWd1c3RvJywnU2VwdGVtYnJvJywnT2t0b2JybycsJ05vdmVtYnJvJywnRGVjZW1icm8nXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywnRmViJywnTWFyJywnQXByJywnTWFqJywnSnVuJyxcblx0XHQnSnVsJywnQcWtZycsJ1NlcCcsJ09rdCcsJ05vdicsJ0RlYyddLFxuXHRcdGRheU5hbWVzOiBbJ0RpbWFuxIlvJywnTHVuZG8nLCdNYXJkbycsJ01lcmtyZWRvJywnxLRhxa1kbycsJ1ZlbmRyZWRvJywnU2FiYXRvJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydEaW0nLCdMdW4nLCdNYXInLCdNZXInLCfEtGHFrScsJ1ZlbicsJ1NhYiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0RpJywnTHUnLCdNYScsJ01lJywnxLRhJywnVmUnLCdTYSddLFxuXHRcdHdlZWtIZWFkZXI6ICdTYicsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMCxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2VvJ10pO1xufSk7XG5cbi8qIEluaWNpYWxpemFjacOzbiBlbiBlc3Bhw7FvbCBwYXJhIGxhIGV4dGVuc2nDs24gJ1VJIGRhdGUgcGlja2VyJyBwYXJhIGpRdWVyeS4gKi9cbi8qIFRyYWR1Y2lkbyBwb3IgVmVzdGVyICh4dmVzdGVyQGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZXMnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdDZXJyYXInLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7QW50Jyxcblx0XHRuZXh0VGV4dDogJ1NpZyYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdIb3knLFxuXHRcdG1vbnRoTmFtZXM6IFsnZW5lcm8nLCdmZWJyZXJvJywnbWFyem8nLCdhYnJpbCcsJ21heW8nLCdqdW5pbycsXG5cdFx0J2p1bGlvJywnYWdvc3RvJywnc2VwdGllbWJyZScsJ29jdHVicmUnLCdub3ZpZW1icmUnLCdkaWNpZW1icmUnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnZW5lJywnZmViJywnbWFyJywnYWJyJywnbWF5JywnanVuJyxcblx0XHQnanVsJywnb2dvJywnc2VwJywnb2N0Jywnbm92JywnZGljJ10sXG5cdFx0ZGF5TmFtZXM6IFsnZG9taW5nbycsJ2x1bmVzJywnbWFydGVzJywnbWnDqXJjb2xlcycsJ2p1ZXZlcycsJ3ZpZXJuZXMnLCdzw6FiYWRvJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydkb20nLCdsdW4nLCdtYXInLCdtacOpJywnanV2JywndmllJywnc8OhYiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0QnLCdMJywnTScsJ1gnLCdKJywnVicsJ1MnXSxcblx0XHR3ZWVrSGVhZGVyOiAnU20nLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydlcyddKTtcbn0pO1xuXG4vKiBFc3RvbmlhbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IE1hcnQgU8O1bWVybWFhIChtcnRzLnB5ZGV2IGF0IGdtYWlsIGNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZXQnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdTdWxnZScsXG5cdFx0cHJldlRleHQ6ICdFZWxuZXYnLFxuXHRcdG5leHRUZXh0OiAnSsOkcmduZXYnLFxuXHRcdGN1cnJlbnRUZXh0OiAnVMOkbmEnLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFhbnVhcicsJ1ZlZWJydWFyJywnTcOkcnRzJywnQXByaWxsJywnTWFpJywnSnV1bmknLFxuXHRcdCdKdXVsaScsJ0F1Z3VzdCcsJ1NlcHRlbWJlcicsJ09rdG9vYmVyJywnTm92ZW1iZXInLCdEZXRzZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFhbicsICdWZWVicicsICdNw6RydHMnLCAnQXByJywgJ01haScsICdKdXVuaScsXG5cdFx0J0p1dWxpJywgJ0F1ZycsICdTZXB0JywgJ09rdCcsICdOb3YnLCAnRGV0cyddLFxuXHRcdGRheU5hbWVzOiBbJ1DDvGhhcMOkZXYnLCAnRXNtYXNww6RldicsICdUZWlzaXDDpGV2JywgJ0tvbG1hcMOkZXYnLCAnTmVsamFww6RldicsICdSZWVkZScsICdMYXVww6RldiddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnUMO8aGFwJywgJ0VzbWFzcCcsICdUZWlzaXAnLCAnS29sbWFwJywgJ05lbGphcCcsICdSZWVkZScsICdMYXVwJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnUCcsJ0UnLCdUJywnSycsJ04nLCdSJywnTCddLFxuXHRcdHdlZWtIZWFkZXI6ICduw6RkJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZXQnXSk7XG59KTtcblxuLyogRXVza2FyYWtvIG9pbmFycmlhICdVSSBkYXRlIHBpY2tlcicganF1ZXJ5LWtvIGV4dGVudHNpb2FyZW50emF0ICovXG4vKiBLYXJyaWthcy1layBpdHp1bGlhIChrYXJyaWthc0BrYXJyaWthcy5jb20pICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZXUnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdFZ2luYScsXG5cdFx0cHJldlRleHQ6ICcmI3gzQztBdXInLFxuXHRcdG5leHRUZXh0OiAnSHVyJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ0dhdXInLFxuXHRcdG1vbnRoTmFtZXM6IFsndXJ0YXJyaWxhJywnb3RzYWlsYScsJ21hcnR4b2EnLCdhcGlyaWxhJywnbWFpYXR6YScsJ2VrYWluYScsXG5cdFx0XHQndXp0YWlsYScsJ2FidXp0dWEnLCdpcmFpbGEnLCd1cnJpYScsJ2F6YXJvYScsJ2FiZW5kdWEnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsndXJ0LicsJ290cy4nLCdtYXIuJywnYXBpLicsJ21haS4nLCdla2EuJyxcblx0XHRcdCd1enQuJywnYWJ1LicsJ2lyYS4nLCd1cnIuJywnYXphLicsJ2FiZS4nXSxcblx0XHRkYXlOYW1lczogWydpZ2FuZGVhJywnYXN0ZWxlaGVuYScsJ2FzdGVhcnRlYScsJ2FzdGVhemtlbmEnLCdvc3RlZ3VuYScsJ29zdGlyYWxhJywnbGFydW5iYXRhJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydpZy4nLCdhbC4nLCdhci4nLCdhei4nLCdvZy4nLCdvbC4nLCdsci4nXSxcblx0XHRkYXlOYW1lc01pbjogWydpZycsJ2FsJywnYXInLCdheicsJ29nJywnb2wnLCdsciddLFxuXHRcdHdlZWtIZWFkZXI6ICdBcycsXG5cdFx0ZGF0ZUZvcm1hdDogJ3l5LW1tLWRkJyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2V1J10pO1xufSk7XG5cbi8qIFBlcnNpYW4gKEZhcnNpKSBUcmFuc2xhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBKYXZhZCBNb3dsYW5lemhhZCAtLSBqbW93bGFAZ21haWwuY29tICovXG4vKiBKYWxhbGkgY2FsZW5kYXIgc2hvdWxkIHN1cHBvcnRlZCBzb29uISAoSXRzIGltcGxlbWVudGVkIGJ1dCBJIGhhdmUgdG8gdGVzdCBpdCkgKi9cbmpRdWVyeShmdW5jdGlvbigkKSB7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZmEnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfYqNiz2KrZhicsXG5cdFx0cHJldlRleHQ6ICcmI3gzQzvZgtio2YTbjCcsXG5cdFx0bmV4dFRleHQ6ICfYqNi52K/bjCYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICfYp9mF2LHZiNiyJyxcblx0XHRtb250aE5hbWVzOiBbXG5cdFx0XHQn2YHYsdmI2LHYr9mK2YYnLFxuXHRcdFx0J9in2LHYr9mK2KjZh9i02KonLFxuXHRcdFx0J9iu2LHYr9in2K8nLFxuXHRcdFx0J9iq2YrYsScsXG5cdFx0XHQn2YXYsdiv2KfYrycsXG5cdFx0XHQn2LTZh9ix2YrZiNixJyxcblx0XHRcdCfZhdmH2LEnLFxuXHRcdFx0J9ii2KjYp9mGJyxcblx0XHRcdCfYotiw2LEnLFxuXHRcdFx0J9iv24wnLFxuXHRcdFx0J9io2YfZhdmGJyxcblx0XHRcdCfYp9iz2YHZhtivJ1xuXHRcdF0sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJzEnLCcyJywnMycsJzQnLCc1JywnNicsJzcnLCc4JywnOScsJzEwJywnMTEnLCcxMiddLFxuXHRcdGRheU5hbWVzOiBbXG5cdFx0XHQn2Yraqdi02YbYqNmHJyxcblx0XHRcdCfYr9mI2LTZhtio2YcnLFxuXHRcdFx0J9iz2YfigIzYtNmG2KjZhycsXG5cdFx0XHQn2obZh9in2LHYtNmG2KjZhycsXG5cdFx0XHQn2b7Zhtis2LTZhtio2YcnLFxuXHRcdFx0J9is2YXYudmHJyxcblx0XHRcdCfYtNmG2KjZhydcblx0XHRdLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFtcblx0XHRcdCfbjCcsXG5cdFx0XHQn2K8nLFxuXHRcdFx0J9izJyxcblx0XHRcdCfahicsXG5cdFx0XHQn2b4nLFxuXHRcdFx0J9isJyxcblx0XHRcdCfYtCdcblx0XHRdLFxuXHRcdGRheU5hbWVzTWluOiBbXG5cdFx0XHQn24wnLFxuXHRcdFx0J9ivJyxcblx0XHRcdCfYsycsXG5cdFx0XHQn2oYnLFxuXHRcdFx0J9m+Jyxcblx0XHRcdCfYrCcsXG5cdFx0XHQn2LQnXG5cdFx0XSxcblx0XHR3ZWVrSGVhZGVyOiAn2YfZgScsXG5cdFx0ZGF0ZUZvcm1hdDogJ3l5L21tL2RkJyxcblx0XHRmaXJzdERheTogNixcblx0XHRpc1JUTDogdHJ1ZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZmEnXSk7XG59KTtcblxuLyogRmlubmlzaCBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IEhhcnJpIEtpbHBpw7YgKGhhcnJpa2lscGlvQGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZmknXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdTdWxqZScsXG5cdFx0cHJldlRleHQ6ICcmI3hBQjtFZGVsbGluZW4nLFxuXHRcdG5leHRUZXh0OiAnU2V1cmFhdmEmI3hCQjsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnVMOkbsOkw6RuJyxcblx0XHRtb250aE5hbWVzOiBbJ1RhbW1pa3V1JywnSGVsbWlrdXUnLCdNYWFsaXNrdXUnLCdIdWh0aWt1dScsJ1RvdWtva3V1JywnS2Vzw6RrdXUnLFxuXHRcdCdIZWluw6RrdXUnLCdFbG9rdXUnLCdTeXlza3V1JywnTG9rYWt1dScsJ01hcnJhc2t1dScsJ0pvdWx1a3V1J10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ1RhbW1pJywnSGVsbWknLCdNYWFsaXMnLCdIdWh0aScsJ1RvdWtvJywnS2Vzw6QnLFxuXHRcdCdIZWluw6QnLCdFbG8nLCdTeXlzJywnTG9rYScsJ01hcnJhcycsJ0pvdWx1J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydTdScsJ01hJywnVGknLCdLZScsJ1RvJywnUGUnLCdMYSddLFxuXHRcdGRheU5hbWVzOiBbJ1N1bm51bnRhaScsJ01hYW5hbnRhaScsJ1RpaXN0YWknLCdLZXNraXZpaWtrbycsJ1RvcnN0YWknLCdQZXJqYW50YWknLCdMYXVhbnRhaSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ1N1JywnTWEnLCdUaScsJ0tlJywnVG8nLCdQZScsJ0xhJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1ZrJyxcblx0XHRkYXRlRm9ybWF0OiAnZC5tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2ZpJ10pO1xufSk7XG5cbi8qIEZhcm9lc2UgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luICovXG4vKiBXcml0dGVuIGJ5IFN2ZXJyaSBNb2hyIE9sc2VuLCBzdmVycmltb0BnbWFpbC5jb20gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydmbyddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0xhdCBhZnR1cicsXG5cdFx0cHJldlRleHQ6ICcmI3gzQztGeXJyYScsXG5cdFx0bmV4dFRleHQ6ICdOw6ZzdGEmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnw40gZGFnJyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcicsJ0ZlYnJ1YXInLCdNYXJzJywnQXByw61sJywnTWVpJywnSnVuaScsXG5cdFx0J0p1bGknLCdBdWd1c3QnLCdTZXB0ZW1iZXInLCdPa3RvYmVyJywnTm92ZW1iZXInLCdEZXNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCdGZWInLCdNYXInLCdBcHInLCdNZWknLCdKdW4nLFxuXHRcdCdKdWwnLCdBdWcnLCdTZXAnLCdPa3QnLCdOb3YnLCdEZXMnXSxcblx0XHRkYXlOYW1lczogWydTdW5udWRhZ3VyJywnTcOhbmFkYWd1cicsJ1TDvXNkYWd1cicsJ01pa3VkYWd1cicsJ0jDs3NkYWd1cicsJ0Zyw61nZ2phZGFndXInLCdMZXlhcmRhZ3VyJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydTdW4nLCdNw6FuJywnVMO9cycsJ01paycsJ0jDs3MnLCdGcsOtJywnTGV5J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU3UnLCdNw6EnLCdUw70nLCdNaScsJ0jDsycsJ0ZyJywnTGUnXSxcblx0XHR3ZWVrSGVhZGVyOiAnVmsnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC1tbS15eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydmbyddKTtcbn0pO1xuXG4vKiBDYW5hZGlhbi1GcmVuY2ggaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xualF1ZXJ5KGZ1bmN0aW9uICgkKSB7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZnItQ0EnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdGZXJtZXInLFxuXHRcdHByZXZUZXh0OiAnUHLDqWPDqWRlbnQnLFxuXHRcdG5leHRUZXh0OiAnU3VpdmFudCcsXG5cdFx0Y3VycmVudFRleHQ6ICdBdWpvdXJkXFwnaHVpJyxcblx0XHRtb250aE5hbWVzOiBbJ2phbnZpZXInLCAnZsOpdnJpZXInLCAnbWFycycsICdhdnJpbCcsICdtYWknLCAnanVpbicsXG5cdFx0XHQnanVpbGxldCcsICdhb8O7dCcsICdzZXB0ZW1icmUnLCAnb2N0b2JyZScsICdub3ZlbWJyZScsICdkw6ljZW1icmUnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnamFudi4nLCAnZsOpdnIuJywgJ21hcnMnLCAnYXZyaWwnLCAnbWFpJywgJ2p1aW4nLFxuXHRcdFx0J2p1aWwuJywgJ2Fvw7t0JywgJ3NlcHQuJywgJ29jdC4nLCAnbm92LicsICdkw6ljLiddLFxuXHRcdGRheU5hbWVzOiBbJ2RpbWFuY2hlJywgJ2x1bmRpJywgJ21hcmRpJywgJ21lcmNyZWRpJywgJ2pldWRpJywgJ3ZlbmRyZWRpJywgJ3NhbWVkaSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnZGltLicsICdsdW4uJywgJ21hci4nLCAnbWVyLicsICdqZXUuJywgJ3Zlbi4nLCAnc2FtLiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0QnLCAnTCcsICdNJywgJ00nLCAnSicsICdWJywgJ1MnXSxcblx0XHR3ZWVrSGVhZGVyOiAnU2VtLicsXG5cdFx0ZGF0ZUZvcm1hdDogJ3l5LW1tLWRkJyxcblx0XHRmaXJzdERheTogMCxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ1xuXHR9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydmci1DQSddKTtcbn0pO1xuXG4vKiBTd2lzcy1GcmVuY2ggaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBNYXJ0aW4gVm9lbGtsZSAobWFydGluLnZvZWxrbGVAZS10Yy5jaCkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZnItQ0gnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdGZXJtZXInLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7UHLDqWMnLFxuXHRcdG5leHRUZXh0OiAnU3VpdiYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdDb3VyYW50Jyxcblx0XHRtb250aE5hbWVzOiBbJ2phbnZpZXInLCAnZsOpdnJpZXInLCAnbWFycycsICdhdnJpbCcsICdtYWknLCAnanVpbicsXG5cdFx0XHQnanVpbGxldCcsICdhb8O7dCcsICdzZXB0ZW1icmUnLCAnb2N0b2JyZScsICdub3ZlbWJyZScsICdkw6ljZW1icmUnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnamFudi4nLCAnZsOpdnIuJywgJ21hcnMnLCAnYXZyaWwnLCAnbWFpJywgJ2p1aW4nLFxuXHRcdFx0J2p1aWwuJywgJ2Fvw7t0JywgJ3NlcHQuJywgJ29jdC4nLCAnbm92LicsICdkw6ljLiddLFxuXHRcdGRheU5hbWVzOiBbJ2RpbWFuY2hlJywgJ2x1bmRpJywgJ21hcmRpJywgJ21lcmNyZWRpJywgJ2pldWRpJywgJ3ZlbmRyZWRpJywgJ3NhbWVkaSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnZGltLicsICdsdW4uJywgJ21hci4nLCAnbWVyLicsICdqZXUuJywgJ3Zlbi4nLCAnc2FtLiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0QnLCAnTCcsICdNJywgJ00nLCAnSicsICdWJywgJ1MnXSxcblx0XHR3ZWVrSGVhZGVyOiAnU20nLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydmci1DSCddKTtcbn0pO1xuXG4vKiBGcmVuY2ggaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBLZWl0aCBXb29kIChrYndvb2R7YXR9aWluZXQuY29tLmF1KSxcblx0XHRcdCAgU3TDqXBoYW5lIE5haG1hbmkgKHNob2xieUBzaG9sYnkubmV0KSxcblx0XHRcdCAgU3TDqXBoYW5lIFJhaW1iYXVsdCA8c3RlcGhhbmUucmFpbWJhdWx0QGdtYWlsLmNvbT4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydmciddID0ge1xuXHRcdGNsb3NlVGV4dDogJ0Zlcm1lcicsXG5cdFx0cHJldlRleHQ6ICdQcsOpY8OpZGVudCcsXG5cdFx0bmV4dFRleHQ6ICdTdWl2YW50Jyxcblx0XHRjdXJyZW50VGV4dDogJ0F1am91cmRcXCdodWknLFxuXHRcdG1vbnRoTmFtZXM6IFsnamFudmllcicsICdmw6l2cmllcicsICdtYXJzJywgJ2F2cmlsJywgJ21haScsICdqdWluJyxcblx0XHRcdCdqdWlsbGV0JywgJ2Fvw7t0JywgJ3NlcHRlbWJyZScsICdvY3RvYnJlJywgJ25vdmVtYnJlJywgJ2TDqWNlbWJyZSddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydqYW52LicsICdmw6l2ci4nLCAnbWFycycsICdhdnJpbCcsICdtYWknLCAnanVpbicsXG5cdFx0XHQnanVpbC4nLCAnYW/Du3QnLCAnc2VwdC4nLCAnb2N0LicsICdub3YuJywgJ2TDqWMuJ10sXG5cdFx0ZGF5TmFtZXM6IFsnZGltYW5jaGUnLCAnbHVuZGknLCAnbWFyZGknLCAnbWVyY3JlZGknLCAnamV1ZGknLCAndmVuZHJlZGknLCAnc2FtZWRpJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydkaW0uJywgJ2x1bi4nLCAnbWFyLicsICdtZXIuJywgJ2pldS4nLCAndmVuLicsICdzYW0uJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnRCcsJ0wnLCdNJywnTScsJ0onLCdWJywnUyddLFxuXHRcdHdlZWtIZWFkZXI6ICdTZW0uJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZnInXSk7XG59KTtcblxuLyogR2FsaWNpYW4gbG9jYWxpemF0aW9uIGZvciAnVUkgZGF0ZSBwaWNrZXInIGpRdWVyeSBleHRlbnNpb24uICovXG4vKiBUcmFuc2xhdGVkIGJ5IEpvcmdlIEJhcnJlaXJvIDx5b3J0eC5iYXJyeUBnbWFpbC5jb20+LiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2dsJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnUGVjaGFyJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO0FudCcsXG5cdFx0bmV4dFRleHQ6ICdTZWcmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnSG94ZScsXG5cdFx0bW9udGhOYW1lczogWydYYW5laXJvJywnRmVicmVpcm8nLCdNYXJ6bycsJ0FicmlsJywnTWFpbycsJ1h1w7FvJyxcblx0XHQnWHVsbG8nLCdBZ29zdG8nLCdTZXRlbWJybycsJ091dHVicm8nLCdOb3ZlbWJybycsJ0RlY2VtYnJvJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ1hhbicsJ0ZlYicsJ01hcicsJ0FicicsJ01haScsJ1h1w7EnLFxuXHRcdCdYdWwnLCdBZ28nLCdTZXQnLCdPdXQnLCdOb3YnLCdEZWMnXSxcblx0XHRkYXlOYW1lczogWydEb21pbmdvJywnTHVucycsJ01hcnRlcycsJ03DqXJjb3JlcycsJ1hvdmVzJywnVmVucmVzJywnU8OhYmFkbyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnRG9tJywnTHVuJywnTWFyJywnTcOpcicsJ1hvdicsJ1ZlbicsJ1PDoWInXSxcblx0XHRkYXlOYW1lc01pbjogWydEbycsJ0x1JywnTWEnLCdNw6knLCdYbycsJ1ZlJywnU8OhJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1NtJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZ2wnXSk7XG59KTtcblxuLyogSGVicmV3IGluaXRpYWxpc2F0aW9uIGZvciB0aGUgVUkgRGF0ZXBpY2tlciBleHRlbnNpb24uICovXG4vKiBXcml0dGVuIGJ5IEFtaXIgSGFyZG9uIChhaGFyZG9uIGF0IGdtYWlsIGRvdCBjb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2hlJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn16HXkteV16gnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M715TXp9eV15PXnScsXG5cdFx0bmV4dFRleHQ6ICfXlNeR15AmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn15TXmdeV150nLFxuXHRcdG1vbnRoTmFtZXM6IFsn15nXoNeV15DXqCcsJ9ek15HXqNeV15DXqCcsJ9ee16jXpScsJ9eQ16TXqNeZ15wnLCfXnteQ15knLCfXmdeV16DXmScsXG5cdFx0J9eZ15XXnNeZJywn15DXldeS15XXodeYJywn16HXpNeY157XkdeoJywn15DXlden15jXldeR16gnLCfXoNeV15HXnteR16gnLCfXk9em157XkdeoJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ9eZ16DXlScsJ9ek15HXqCcsJ9ee16jXpScsJ9eQ16TXqCcsJ9ee15DXmScsJ9eZ15XXoNeZJyxcblx0XHQn15nXldec15knLCfXkNeV15InLCfXodek15gnLCfXkNeV16cnLCfXoNeV15EnLCfXk9em154nXSxcblx0XHRkYXlOYW1lczogWyfXqNeQ16nXldefJywn16nXoNeZJywn16nXnNeZ16nXmScsJ9eo15HXmdei15knLCfXl9ee15nXqdeZJywn16nXmdep15knLCfXqdeR16onXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ9eQXFwnJywn15FcXCcnLCfXklxcJycsJ9eTXFwnJywn15RcXCcnLCfXlVxcJycsJ9ep15HXqiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ9eQXFwnJywn15FcXCcnLCfXklxcJycsJ9eTXFwnJywn15RcXCcnLCfXlVxcJycsJ9ep15HXqiddLFxuXHRcdHdlZWtIZWFkZXI6ICdXaycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMCxcblx0XHRpc1JUTDogdHJ1ZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnaGUnXSk7XG59KTtcblxuLyogSGluZGkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBNaWNoYWVsIERhd2FydC4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydoaSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ+CkrOCkguCkpicsXG5cdFx0cHJldlRleHQ6ICfgpKrgpL/gpJvgpLLgpL4nLFxuXHRcdG5leHRUZXh0OiAn4KSF4KSX4KSy4KS+Jyxcblx0XHRjdXJyZW50VGV4dDogJ+CkhuCknCcsXG5cdFx0bW9udGhOYW1lczogWyfgpJzgpKjgpLXgpLDgpYAgJywn4KSr4KSw4KS14KSw4KWAJywn4KSu4KS+4KSw4KWN4KSaJywn4KSF4KSq4KWN4KSw4KWH4KSyJywn4KSu4KSIJywn4KSc4KWC4KSoJyxcblx0XHQn4KSc4KWC4KSy4KS+4KSIJywn4KSF4KSX4KS44KWN4KSkICcsJ+CkuOCkv+CkpOCkruCljeCkrOCksCcsJ+CkheCkleCljeCkn+ClguCkrOCksCcsJ+CkqOCkteCkruCljeCkrOCksCcsJ+CkpuCkv+CkuOCkruCljeCkrOCksCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfgpJzgpKgnLCAn4KSr4KSwJywgJ+CkruCkvuCksOCljeCkmicsICfgpIXgpKrgpY3gpLDgpYfgpLInLCAn4KSu4KSIJywgJ+CknOClguCkqCcsXG5cdFx0J+CknOClguCksuCkvuCkiCcsICfgpIXgpJcnLCAn4KS44KS/4KSkJywgJ+CkheCkleCljeCknycsICfgpKjgpLUnLCAn4KSm4KS/J10sXG5cdFx0ZGF5TmFtZXM6IFsn4KSw4KS14KS/4KS14KS+4KSwJywgJ+CkuOCli+CkruCkteCkvuCksCcsICfgpK7gpILgpJfgpLLgpLXgpL7gpLAnLCAn4KSs4KWB4KSn4KS14KS+4KSwJywgJ+Ckl+ClgeCksOClgeCkteCkvuCksCcsICfgpLbgpYHgpJXgpY3gpLDgpLXgpL7gpLAnLCAn4KS24KSo4KS/4KS14KS+4KSwJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfgpLDgpLXgpL8nLCAn4KS44KWL4KSuJywgJ+CkruCkguCkl+CksicsICfgpKzgpYHgpKcnLCAn4KSX4KWB4KSw4KWBJywgJ+CktuClgeCkleCljeCksCcsICfgpLbgpKjgpL8nXSxcblx0XHRkYXlOYW1lc01pbjogWyfgpLDgpLXgpL8nLCAn4KS44KWL4KSuJywgJ+CkruCkguCkl+CksicsICfgpKzgpYHgpKcnLCAn4KSX4KWB4KSw4KWBJywgJ+CktuClgeCkleCljeCksCcsICfgpLbgpKjgpL8nXSxcblx0XHR3ZWVrSGVhZGVyOiAn4KS54KSr4KWN4KSk4KS+Jyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnaGknXSk7XG59KTtcblxuLyogQ3JvYXRpYW4gaTE4biBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IFZqZWtvc2xhdiBOZXNlay4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydociddID0ge1xuXHRcdGNsb3NlVGV4dDogJ1phdHZvcmknLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7Jyxcblx0XHRuZXh0VGV4dDogJyYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdEYW5hcycsXG5cdFx0bW9udGhOYW1lczogWydTaWplxI1hbmonLCdWZWxqYcSNYScsJ0/FvnVqYWsnLCdUcmF2YW5qJywnU3ZpYmFuaicsJ0xpcGFuaicsXG5cdFx0J1NycGFuaicsJ0tvbG92b3onLCdSdWphbicsJ0xpc3RvcGFkJywnU3R1ZGVuaScsJ1Byb3NpbmFjJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ1NpaicsJ1ZlbGonLCdPxb51JywnVHJhJywnU3ZpJywnTGlwJyxcblx0XHQnU3JwJywnS29sJywnUnVqJywnTGlzJywnU3R1JywnUHJvJ10sXG5cdFx0ZGF5TmFtZXM6IFsnTmVkamVsamEnLCdQb25lZGplbGphaycsJ1V0b3JhaycsJ1NyaWplZGEnLCfEjGV0dnJ0YWsnLCdQZXRhaycsJ1N1Ym90YSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnTmVkJywnUG9uJywnVXRvJywnU3JpJywnxIxldCcsJ1BldCcsJ1N1YiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ05lJywnUG8nLCdVdCcsJ1NyJywnxIxlJywnUGUnLCdTdSddLFxuXHRcdHdlZWtIZWFkZXI6ICdUamUnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eS4nLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnaHInXSk7XG59KTtcblxuLyogSHVuZ2FyaWFuIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgSXN0dmFuIEthcmFzemkgKGpxdWVyeUBzcGFtLnJhc3ppLmh1KS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydodSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ2JlesOhcicsXG5cdFx0cHJldlRleHQ6ICd2aXNzemEnLFxuXHRcdG5leHRUZXh0OiAnZWzFkXJlJyxcblx0XHRjdXJyZW50VGV4dDogJ21hJyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnXDoXInLCAnRmVicnXDoXInLCAnTcOhcmNpdXMnLCAnw4FwcmlsaXMnLCAnTcOhanVzJywgJ0rDum5pdXMnLFxuXHRcdCdKw7psaXVzJywgJ0F1Z3VzenR1cycsICdTemVwdGVtYmVyJywgJ09rdMOzYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTcOhcicsICfDgXByJywgJ03DoWonLCAnSsO6bicsXG5cdFx0J0rDumwnLCAnQXVnJywgJ1N6ZXAnLCAnT2t0JywgJ05vdicsICdEZWMnXSxcblx0XHRkYXlOYW1lczogWydWYXPDoXJuYXAnLCAnSMOpdGbFkScsICdLZWRkJywgJ1N6ZXJkYScsICdDc8O8dMO2cnTDtmsnLCAnUMOpbnRlaycsICdTem9tYmF0J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydWYXMnLCAnSMOpdCcsICdLZWQnLCAnU3plJywgJ0Nzw7wnLCAnUMOpbicsICdTem8nXSxcblx0XHRkYXlOYW1lc01pbjogWydWJywgJ0gnLCAnSycsICdTemUnLCAnQ3MnLCAnUCcsICdTem8nXSxcblx0XHR3ZWVrSGVhZGVyOiAnSMOpdCcsXG5cdFx0ZGF0ZUZvcm1hdDogJ3l5Lm1tLmRkLicsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogdHJ1ZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2h1J10pO1xufSk7XG5cbi8qIEFybWVuaWFuKFVURi04KSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IExldm9uIFpha2FyeWFuIChsZXZvbi56YWthcnlhbkBnbWFpbC5jb20pKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydoeSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ9WT1aHVr9Wl1awnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M71YbVodWtLicsXG5cdFx0bmV4dFRleHQ6ICfVgNWh1bsuJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ9Sx1bXVvdaF1oAnLFxuXHRcdG1vbnRoTmFtZXM6IFsn1YDVuNaC1bbVvtWh1oAnLCfVk9Wl1b/WgNW+1aHWgCcsJ9WE1aHWgNW/Jywn1LHVutaA1avVrCcsJ9WE1aHVtdWr1b0nLCfVgNW41oLVttWr1b0nLFxuXHRcdCfVgNW41oLVrNWr1b0nLCfVldWj1bjVvdW/1bjVvScsJ9WN1aXVutW/1aXVtNWi1aXWgCcsJ9WA1bjVr9W/1aXVtNWi1aXWgCcsJ9WG1bjVtdWl1bTVotWl1oAnLCfUtNWl1a/Vv9Wl1bTVotWl1oAnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn1YDVuNaC1bbVvicsJ9WT1aXVv9aAJywn1YTVodaA1b8nLCfUsdW61oAnLCfVhNWh1bXVq9W9Jywn1YDVuNaC1bbVq9W9Jyxcblx0XHQn1YDVuNaC1awnLCfVldWj1b0nLCfVjdWl1bonLCfVgNW41a8nLCfVhtW41bUnLCfUtNWl1a8nXSxcblx0XHRkYXlOYW1lczogWyfVr9Wr1oDVodWv1asnLCfVpdWv1bjWgtW31aHVotWp1asnLCfVpdaA1aXWhNW31aHVotWp1asnLCfVudW41oDVpdaE1bfVodWi1anVqycsJ9Ww1avVttWj1bfVodWi1anVqycsJ9W41oLWgNWi1aHVqScsJ9W31aHVotWh1aknXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ9Wv1avWgCcsJ9Wl1oDVrycsJ9Wl1oDWhCcsJ9W51oDWhCcsJ9Ww1bbVoycsJ9W41oLWgNWiJywn1bfVotWpJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn1a/Vq9aAJywn1aXWgNWvJywn1aXWgNaEJywn1bnWgNaEJywn1bDVttWjJywn1bjWgtaA1aInLCfVt9Wi1aknXSxcblx0XHR3ZWVrSGVhZGVyOiAn1YfUstWPJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnaHknXSk7XG59KTtcblxuLyogSW5kb25lc2lhbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IERlZGVuIEZhdGh1cmFobWFuIChkZWRlbmZAZ21haWwuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydpZCddID0ge1xuXHRcdGNsb3NlVGV4dDogJ1R1dHVwJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO211bmR1cicsXG5cdFx0bmV4dFRleHQ6ICdtYWp1JiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ2hhcmkgaW5pJyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcmknLCdGZWJydWFyaScsJ01hcmV0JywnQXByaWwnLCdNZWknLCdKdW5pJyxcblx0XHQnSnVsaScsJ0FndXN0dXMnLCdTZXB0ZW1iZXInLCdPa3RvYmVyJywnTm9wZW1iZXInLCdEZXNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCdGZWInLCdNYXInLCdBcHInLCdNZWknLCdKdW4nLFxuXHRcdCdKdWwnLCdBZ3VzJywnU2VwJywnT2t0JywnTm9wJywnRGVzJ10sXG5cdFx0ZGF5TmFtZXM6IFsnTWluZ2d1JywnU2VuaW4nLCdTZWxhc2EnLCdSYWJ1JywnS2FtaXMnLCdKdW1hdCcsJ1NhYnR1J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydNaW4nLCdTZW4nLCdTZWwnLCdSYWInLCdrYW0nLCdKdW0nLCdTYWInXSxcblx0XHRkYXlOYW1lc01pbjogWydNZycsJ1NuJywnU2wnLCdSYicsJ0ttJywnam0nLCdTYiddLFxuXHRcdHdlZWtIZWFkZXI6ICdNZycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMCxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2lkJ10pO1xufSk7XG5cbi8qIEljZWxhbmRpYyBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IEhhdWt1ciBILiBUaG9yc3NvbiAoaGF1a3VyQGVza2lsbC5pcykuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnaXMnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdMb2thJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDOyBGeXJyaScsXG5cdFx0bmV4dFRleHQ6ICdOw6ZzdGkgJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ8ONIGRhZycsXG5cdFx0bW9udGhOYW1lczogWydKYW7DumFyJywnRmVicsO6YXInLCdNYXJzJywnQXByw61sJywnTWHDrScsJ0rDum7DrScsXG5cdFx0J0rDumzDrScsJ8OBZ8O6c3QnLCdTZXB0ZW1iZXInLCdPa3TDs2JlcicsJ07Ds3ZlbWJlcicsJ0Rlc2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZlYicsJ01hcicsJ0FwcicsJ01hw60nLCdKw7puJyxcblx0XHQnSsO6bCcsJ8OBZ8O6JywnU2VwJywnT2t0JywnTsOzdicsJ0RlcyddLFxuXHRcdGRheU5hbWVzOiBbJ1N1bm51ZGFndXInLCdNw6FudWRhZ3VyJywnw55yacOwanVkYWd1cicsJ01pw7B2aWt1ZGFndXInLCdGaW1tdHVkYWd1cicsJ0bDtnN0dWRhZ3VyJywnTGF1Z2FyZGFndXInXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ1N1bicsJ03DoW4nLCfDnnJpJywnTWnDsCcsJ0ZpbScsJ0bDtnMnLCdMYXUnXSxcblx0XHRkYXlOYW1lc01pbjogWydTdScsJ03DoScsJ8OecicsJ01pJywnRmknLCdGw7YnLCdMYSddLFxuXHRcdHdlZWtIZWFkZXI6ICdWaWthJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAwLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnaXMnXSk7XG59KTtcblxuLyogSXRhbGlhbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IEFudG9uZWxsbyBQYXNlbGxhIChhbnRvbmVsbG8ucGFzZWxsYUBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2l0J10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnQ2hpdWRpJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO1ByZWMnLFxuXHRcdG5leHRUZXh0OiAnU3VjYyYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdPZ2dpJyxcblx0XHRtb250aE5hbWVzOiBbJ0dlbm5haW8nLCdGZWJicmFpbycsJ01hcnpvJywnQXByaWxlJywnTWFnZ2lvJywnR2l1Z25vJyxcblx0XHRcdCdMdWdsaW8nLCdBZ29zdG8nLCdTZXR0ZW1icmUnLCdPdHRvYnJlJywnTm92ZW1icmUnLCdEaWNlbWJyZSddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydHZW4nLCdGZWInLCdNYXInLCdBcHInLCdNYWcnLCdHaXUnLFxuXHRcdFx0J0x1ZycsJ0FnbycsJ1NldCcsJ090dCcsJ05vdicsJ0RpYyddLFxuXHRcdGRheU5hbWVzOiBbJ0RvbWVuaWNhJywnTHVuZWTDrCcsJ01hcnRlZMOsJywnTWVyY29sZWTDrCcsJ0dpb3ZlZMOsJywnVmVuZXJkw6wnLCdTYWJhdG8nXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ0RvbScsJ0x1bicsJ01hcicsJ01lcicsJ0dpbycsJ1ZlbicsJ1NhYiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0RvJywnTHUnLCdNYScsJ01lJywnR2knLCdWZScsJ1NhJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1NtJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnaXQnXSk7XG59KTtcblxuLyogSmFwYW5lc2UgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBLZW50YXJvIFNBVE8gKGtlbnRhcm9AcmFudmlzLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnamEnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfplonjgZjjgosnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M75YmNJyxcblx0XHRuZXh0VGV4dDogJ+asoSYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICfku4rml6UnLFxuXHRcdG1vbnRoTmFtZXM6IFsnMeaciCcsJzLmnIgnLCcz5pyIJywnNOaciCcsJzXmnIgnLCc25pyIJyxcblx0XHQnN+aciCcsJzjmnIgnLCc55pyIJywnMTDmnIgnLCcxMeaciCcsJzEy5pyIJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJzHmnIgnLCcy5pyIJywnM+aciCcsJzTmnIgnLCc15pyIJywnNuaciCcsXG5cdFx0JzfmnIgnLCc45pyIJywnOeaciCcsJzEw5pyIJywnMTHmnIgnLCcxMuaciCddLFxuXHRcdGRheU5hbWVzOiBbJ+aXpeabnOaXpScsJ+aciOabnOaXpScsJ+eBq+abnOaXpScsJ+awtOabnOaXpScsJ+acqOabnOaXpScsJ+mHkeabnOaXpScsJ+Wcn+abnOaXpSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsn5pelJywn5pyIJywn54GrJywn5rC0Jywn5pyoJywn6YeRJywn5ZyfJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn5pelJywn5pyIJywn54GrJywn5rC0Jywn5pyoJywn6YeRJywn5ZyfJ10sXG5cdFx0d2Vla0hlYWRlcjogJ+mAsScsXG5cdFx0ZGF0ZUZvcm1hdDogJ3l5L21tL2RkJyxcblx0XHRmaXJzdERheTogMCxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiB0cnVlLFxuXHRcdHllYXJTdWZmaXg6ICflubQnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnamEnXSk7XG59KTtcblxuLyogR2VvcmdpYW4gKFVURi04KSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IExhZG8gTG9taWR6ZSAobGFkby5sb21pZHplQGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsna2EnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfhg5Phg5Dhg67hg6Phg6Dhg5Xhg5AnLFxuXHRcdHByZXZUZXh0OiAnJiN4M2M7IOGDrOGDmOGDnOGDkCcsXG5cdFx0bmV4dFRleHQ6ICfhg6jhg5Thg5vhg5Phg5Thg5Lhg5ggJiN4M2U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ+GDk+GDpuGDlOGDoScsXG5cdFx0bW9udGhOYW1lczogWyfhg5jhg5Dhg5zhg5Xhg5Dhg6Dhg5gnLCfhg5fhg5Thg5Hhg5Thg6Dhg5Xhg5Dhg5rhg5gnLCfhg5vhg5Dhg6Dhg6Lhg5gnLCfhg5Dhg57hg6Dhg5jhg5rhg5gnLCfhg5vhg5Dhg5jhg6Hhg5gnLCfhg5jhg5Xhg5zhg5jhg6Hhg5gnLCAn4YOY4YOV4YOa4YOY4YOh4YOYJywn4YOQ4YOS4YOV4YOY4YOh4YOi4YOdJywn4YOh4YOU4YOl4YOi4YOU4YOb4YOR4YOU4YOg4YOYJywn4YOd4YOl4YOi4YOd4YOb4YOR4YOU4YOg4YOYJywn4YOc4YOd4YOU4YOb4YOR4YOU4YOg4YOYJywn4YOT4YOU4YOZ4YOU4YOb4YOR4YOU4YOg4YOYJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ+GDmOGDkOGDnCcsJ+GDl+GDlOGDkScsJ+GDm+GDkOGDoCcsJ+GDkOGDnuGDoCcsJ+GDm+GDkOGDmCcsJ+GDmOGDleGDnCcsICfhg5jhg5Xhg5onLCfhg5Dhg5Lhg5UnLCfhg6Hhg5Thg6UnLCfhg53hg6Xhg6InLCfhg5zhg53hg5QnLCfhg5Phg5Thg5knXSxcblx0XHRkYXlOYW1lczogWyfhg5nhg5Xhg5jhg6Dhg5AnLCfhg53hg6Dhg6jhg5Dhg5Hhg5Dhg5fhg5gnLCfhg6Hhg5Dhg5vhg6jhg5Dhg5Hhg5Dhg5fhg5gnLCfhg53hg5fhg67hg6jhg5Dhg5Hhg5Dhg5fhg5gnLCfhg67hg6Phg5fhg6jhg5Dhg5Hhg5Dhg5fhg5gnLCfhg57hg5Dhg6Dhg5Dhg6Hhg5nhg5Thg5Xhg5gnLCfhg6jhg5Dhg5Hhg5Dhg5fhg5gnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ+GDmeGDlScsJ+GDneGDoOGDqCcsJ+GDoeGDkOGDmycsJ+GDneGDl+GDricsJ+GDruGDo+GDlycsJ+GDnuGDkOGDoCcsJ+GDqOGDkOGDkSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ+GDmeGDlScsJ+GDneGDoOGDqCcsJ+GDoeGDkOGDmycsJ+GDneGDl+GDricsJ+GDruGDo+GDlycsJ+GDnuGDkOGDoCcsJ+GDqOGDkOGDkSddLFxuXHRcdHdlZWtIZWFkZXI6ICfhg5nhg5Xhg5jhg6Dhg5AnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC1tbS15eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydrYSddKTtcbn0pO1xuXG4vKiBLYXpha2ggKFVURi04KSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IERtaXRyaXkgS2FyYXN5b3YgKGRtaXRyaXkua2FyYXN5b3ZAZ21haWwuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydrayddID0ge1xuXHRcdGNsb3NlVGV4dDogJ9CW0LDQsdGDJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO9CQ0LvQtNGL0qPSk9GLJyxcblx0XHRuZXh0VGV4dDogJ9Ca0LXQu9C10YHRliYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICfQkdKv0LPRltC9Jyxcblx0XHRtb250aE5hbWVzOiBbJ9Ka0LDSo9GC0LDRgCcsJ9CQ0pvQv9Cw0L0nLCfQndCw0YPRgNGL0LcnLCfQodOZ0YPRltGAJywn0JzQsNC80YvRgCcsJ9Cc0LDRg9GB0YvQvCcsXG5cdFx0J9Co0ZbQu9C00LUnLCfQotCw0LzRi9C3Jywn0prRi9GA0LrSr9C50LXQuicsJ9Ka0LDQt9Cw0L0nLCfSmtCw0YDQsNGI0LAnLCfQltC10LvRgtC+0pvRgdCw0L0nXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn0prQsNKjJywn0JDSm9C/Jywn0J3QsNGDJywn0KHTmdGDJywn0JzQsNC8Jywn0JzQsNGDJyxcblx0XHQn0KjRltC7Jywn0KLQsNC8Jywn0prRi9GAJywn0prQsNC3Jywn0prQsNGAJywn0JbQtdC7J10sXG5cdFx0ZGF5TmFtZXM6IFsn0JbQtdC60YHQtdC90LHRlicsJ9CU0q/QudGB0LXQvdCx0ZYnLCfQodC10LnRgdC10L3QsdGWJywn0KHTmdGA0YHQtdC90LHRlicsJ9CR0LXQudGB0LXQvdCx0ZYnLCfQltKx0LzQsCcsJ9Ch0LXQvdCx0ZYnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ9C20LrRgScsJ9C00YHQvScsJ9GB0YHQvScsJ9GB0YDRgScsJ9Cx0YHQvScsJ9C20LzQsCcsJ9GB0L3QsSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ9CW0LonLCfQlNGBJywn0KHRgScsJ9Ch0YAnLCfQkdGBJywn0JbQvCcsJ9Ch0L0nXSxcblx0XHR3ZWVrSGVhZGVyOiAn0J3QtScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2trJ10pO1xufSk7XG5cbi8qIEtobWVyIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IGNhbGVuZGFyIGV4dGVuc2lvbi4gKi9cbi8qIFdyaXR0ZW4gYnkgQ2hhbmRhcmEgT20gKGNoYW5kYXJhLnRlYWNoZXJAZ21haWwuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydrbSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ+GekuGfkuGenOGevuKAi+GemuGeveGehScsXG5cdFx0cHJldlRleHQ6ICfhnpjhnrvhnpMnLFxuXHRcdG5leHRUZXh0OiAn4Z6U4Z6T4Z+S4Z6R4Z624Z6U4Z+LJyxcblx0XHRjdXJyZW50VGV4dDogJ+GekOGfkuGehOGfg+KAi+Gek+GfgeGfhycsXG5cdFx0bW9udGhOYW1lczogWyfhnpjhnoDhnprhnrYnLCfhnoDhnrvhnpjhn5Lhnpfhn4gnLCfhnpjhnrjhnpPhnrYnLCfhnpjhn4Hhnp/hnrYnLCfhnqfhnp/hnpfhnrYnLCfhnpjhnrfhnpDhnrvhnpPhnrYnLFxuXHRcdCfhnoDhnoDhn5LhnoDhnorhnrYnLCfhnp/hnrjhnqDhnrYnLCfhnoDhnonhn5LhnonhnrYnLCfhno/hnrvhnpvhnrYnLCfhnpzhnrfhnoXhn5LhnobhnrfhnoDhnrYnLCfhnpLhn5LhnpPhnrwnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn4Z6Y4Z6A4Z6a4Z62Jywn4Z6A4Z674Z6Y4Z+S4Z6X4Z+IJywn4Z6Y4Z644Z6T4Z62Jywn4Z6Y4Z+B4Z6f4Z62Jywn4Z6n4Z6f4Z6X4Z62Jywn4Z6Y4Z634Z6Q4Z674Z6T4Z62Jyxcblx0XHQn4Z6A4Z6A4Z+S4Z6A4Z6K4Z62Jywn4Z6f4Z644Z6g4Z62Jywn4Z6A4Z6J4Z+S4Z6J4Z62Jywn4Z6P4Z674Z6b4Z62Jywn4Z6c4Z634Z6F4Z+S4Z6G4Z634Z6A4Z62Jywn4Z6S4Z+S4Z6T4Z68J10sXG5cdFx0ZGF5TmFtZXM6IFsn4Z6i4Z624Z6R4Z634Z6P4Z+S4Z6ZJywgJ+GeheGek+GfkuGekScsICfhnqLhnoThn5LhnoLhnrbhnponLCAn4Z6W4Z674Z6SJywgJ+GeluGfkuGemuGeoOGen+GfkuGelOGej+Get+GfjScsICfhnp/hnrvhnoDhn5LhnponLCAn4Z6f4Z+F4Z6a4Z+NJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfhnqLhnrYnLCAn4Z6FJywgJ+GeoicsICfhnpbhnrsnLCAn4Z6W4Z+S4Z6a4Z6gJywgJ+Gen+GeuycsICfhnp/hn4UnXSxcblx0XHRkYXlOYW1lc01pbjogWyfhnqLhnrYnLCAn4Z6FJywgJ+GeoicsICfhnpbhnrsnLCAn4Z6W4Z+S4Z6a4Z6gJywgJ+Gen+GeuycsICfhnp/hn4UnXSxcblx0XHR3ZWVrSGVhZGVyOiAn4Z6f4Z6U4Z+S4Z6K4Z624Z6g4Z+NJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQtbW0teXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsna20nXSk7XG59KTtcblxuLyogS29yZWFuIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IGNhbGVuZGFyIGV4dGVuc2lvbi4gKi9cbi8qIFdyaXR0ZW4gYnkgRGFlS3dvbiBLYW5nIChuY3Jhc2guZGtAZ21haWwuY29tKSwgRWRpdGVkIGJ5IEdlbmllLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2tvJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn64ur6riwJyxcblx0XHRwcmV2VGV4dDogJ+ydtOyghOuLrCcsXG5cdFx0bmV4dFRleHQ6ICfri6TsnYzri6wnLFxuXHRcdGN1cnJlbnRUZXh0OiAn7Jik64qYJyxcblx0XHRtb250aE5hbWVzOiBbJzHsm5QnLCcy7JuUJywnM+yblCcsJzTsm5QnLCc17JuUJywnNuyblCcsXG5cdFx0Jzfsm5QnLCc47JuUJywnOeyblCcsJzEw7JuUJywnMTHsm5QnLCcxMuyblCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWycx7JuUJywnMuyblCcsJzPsm5QnLCc07JuUJywnNeyblCcsJzbsm5QnLFxuXHRcdCc37JuUJywnOOyblCcsJznsm5QnLCcxMOyblCcsJzEx7JuUJywnMTLsm5QnXSxcblx0XHRkYXlOYW1lczogWyfsnbzsmpTsnbwnLCfsm5TsmpTsnbwnLCftmZTsmpTsnbwnLCfsiJjsmpTsnbwnLCfrqqnsmpTsnbwnLCfquIjsmpTsnbwnLCfthqDsmpTsnbwnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ+ydvCcsJ+yblCcsJ+2ZlCcsJ+yImCcsJ+uqqScsJ+q4iCcsJ+2GoCddLFxuXHRcdGRheU5hbWVzTWluOiBbJ+ydvCcsJ+yblCcsJ+2ZlCcsJ+yImCcsJ+uqqScsJ+q4iCcsJ+2GoCddLFxuXHRcdHdlZWtIZWFkZXI6ICdXaycsXG5cdFx0ZGF0ZUZvcm1hdDogJ3l5LW1tLWRkJyxcblx0XHRmaXJzdERheTogMCxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiB0cnVlLFxuXHRcdHllYXJTdWZmaXg6ICfrhYQnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsna28nXSk7XG59KTtcblxuLyogS3lyZ3l6IChVVEYtOCkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBTZXJnZXkgS2FydGFzaG92IChlYmlzaGtla0B5YW5kZXgucnUpLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2t5J10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn0JbQsNCx0YPRgycsXG5cdFx0cHJldlRleHQ6ICcmI3gzYzvQnNGD0YAnLFxuXHRcdG5leHRUZXh0OiAn0JrQuNC5JiN4M2U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ9CR0q/Qs9Kv0L0nLFxuXHRcdG1vbnRoTmFtZXM6IFsn0K/QvdCy0LDRgNGMJywn0KTQtdCy0YDQsNC70YwnLCfQnNCw0YDRgicsJ9CQ0L/RgNC10LvRjCcsJ9Cc0LDQuScsJ9CY0Y7QvdGMJyxcblx0XHQn0JjRjtC70YwnLCfQkNCy0LPRg9GB0YInLCfQodC10L3RgtGP0LHRgNGMJywn0J7QutGC0Y/QsdGA0YwnLCfQndC+0Y/QsdGA0YwnLCfQlNC10LrQsNCx0YDRjCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfQr9C90LInLCfQpNC10LInLCfQnNCw0YAnLCfQkNC/0YAnLCfQnNCw0LknLCfQmNGO0L0nLFxuXHRcdCfQmNGO0LsnLCfQkNCy0LMnLCfQodC10L0nLCfQntC60YInLCfQndC+0Y8nLCfQlNC10LonXSxcblx0XHRkYXlOYW1lczogWyfQttC10LrRiNC10LzQsdC4JywgJ9C00q/QudGI06nQvNCx0q8nLCAn0YjQtdC50YjQtdC80LHQuCcsICfRiNCw0YDRiNC10LzQsdC4JywgJ9Cx0LXQudGI0LXQvNCx0LgnLCAn0LbRg9C80LAnLCAn0LjRiNC10LzQsdC4J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfQttC10LonLCAn0LTSr9C5JywgJ9GI0LXQuScsICfRiNCw0YAnLCAn0LHQtdC5JywgJ9C20YPQvCcsICfQuNGI0LUnXSxcblx0XHRkYXlOYW1lc01pbjogWyfQltC6Jywn0JTRiCcsJ9Co0YgnLCfQqNGAJywn0JHRiCcsJ9CW0LwnLCfQmNGIJ10sXG5cdFx0d2Vla0hlYWRlcjogJ9CW0YPQvCcsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ1xuXHR9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydreSddKTtcbn0pO1xuXG4vKiBMdXhlbWJvdXJnaXNoIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgTWljaGVsIFdlaW1lcnNraXJjaCA8bWljaGVsQHdlaW1lcnNraXJjaC5uZXQ+ICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnbGInXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdGw6RlcmRlZycsXG5cdFx0cHJldlRleHQ6ICdacsOpY2snLFxuXHRcdG5leHRUZXh0OiAnV2VpZGVyJyxcblx0XHRjdXJyZW50VGV4dDogJ0hhdXQnLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyJywnRmVicnVhcicsJ03DpGVyeicsJ0FicsOrbGwnLCdNZWUnLCdKdW5pJyxcblx0XHQnSnVsaScsJ0F1Z3VzdCcsJ1NlcHRlbWJlcicsJ09rdG9iZXInLCdOb3ZlbWJlcicsJ0RlemVtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTcOkZScsICdBYnInLCAnTWVlJywgJ0p1bicsXG5cdFx0J0p1bCcsICdBdWcnLCAnU2VwJywgJ09rdCcsICdOb3YnLCAnRGV6J10sXG5cdFx0ZGF5TmFtZXM6IFsnU29ubmRlZycsICdNw6lpbmRlZycsICdEw6tuc2NoZGVnJywgJ03Dq3R0d29jaCcsICdEb25uZXNjaGRlZycsICdGcmVpZGVnJywgJ1NhbXNjaGRlZyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnU29uJywgJ03DqWknLCAnRMOrbicsICdNw6t0JywgJ0RvbicsICdGcmUnLCAnU2FtJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU28nLCdNw6knLCdEw6snLCdNw6snLCdEbycsJ0ZyJywnU2EnXSxcblx0XHR3ZWVrSGVhZGVyOiAnVycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2xiJ10pO1xufSk7XG5cbi8qIExpdGh1YW5pYW4gKFVURi04KSBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBAYXV0aG9yIEFydHVyYXMgUGFsZWljaWthcyA8YXJ0dXJhc0BhdmFsb24ubHQ+ICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnbHQnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdVxb5kYXJ5dGknLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7QXRnYWwnLFxuXHRcdG5leHRUZXh0OiAnUGlybXluJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ8WgaWFuZGllbicsXG5cdFx0bW9udGhOYW1lczogWydTYXVzaXMnLCdWYXNhcmlzJywnS292YXMnLCdCYWxhbmRpcycsJ0dlZ3XFvsSXJywnQmlyxb5lbGlzJyxcblx0XHQnTGllcGEnLCdSdWdwasWrdGlzJywnUnVnc8SXamlzJywnU3BhbGlzJywnTGFwa3JpdGlzJywnR3J1b2RpcyddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydTYXUnLCdWYXMnLCdLb3YnLCdCYWwnLCdHZWcnLCdCaXInLFxuXHRcdCdMaWUnLCdSdWdwJywnUnVncycsJ1NwYScsJ0xhcCcsJ0dydSddLFxuXHRcdGRheU5hbWVzOiBbJ3Nla21hZGllbmlzJywncGlybWFkaWVuaXMnLCdhbnRyYWRpZW5pcycsJ3RyZcSNaWFkaWVuaXMnLCdrZXR2aXJ0YWRpZW5pcycsJ3Blbmt0YWRpZW5pcycsJ8WhZcWhdGFkaWVuaXMnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ3NlaycsJ3BpcicsJ2FudCcsJ3RyZScsJ2tldCcsJ3BlbicsJ8WhZcWhJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU2UnLCdQcicsJ0FuJywnVHInLCdLZScsJ1BlJywnxaBlJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1NBVicsXG5cdFx0ZGF0ZUZvcm1hdDogJ3l5LW1tLWRkJyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiB0cnVlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnbHQnXSk7XG59KTtcblxuLyogTGF0dmlhbiAoVVRGLTgpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIEBhdXRob3IgQXJ0dXJhcyBQYWxlaWNpa2FzIDxhcnR1cmFzLnBhbGVpY2lrYXNAbWV0YXNpdGUubmV0PiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2x2J10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnQWl6dsSTcnQnLFxuXHRcdHByZXZUZXh0OiAnSWVwci4nLFxuXHRcdG5leHRUZXh0OiAnTsSBay4nLFxuXHRcdGN1cnJlbnRUZXh0OiAnxaBvZGllbicsXG5cdFx0bW9udGhOYW1lczogWydKYW52xIFyaXMnLCdGZWJydcSBcmlzJywnTWFydHMnLCdBcHLEq2xpcycsJ01haWpzJywnSsWrbmlqcycsXG5cdFx0J0rFq2xpanMnLCdBdWd1c3RzJywnU2VwdGVtYnJpcycsJ09rdG9icmlzJywnTm92ZW1icmlzJywnRGVjZW1icmlzJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZlYicsJ01hcicsJ0FwcicsJ01haScsJ0rFq24nLFxuXHRcdCdKxatsJywnQXVnJywnU2VwJywnT2t0JywnTm92JywnRGVjJ10sXG5cdFx0ZGF5TmFtZXM6IFsnc3bEk3RkaWVuYScsJ3Bpcm1kaWVuYScsJ290cmRpZW5hJywndHJlxaFkaWVuYScsJ2NldHVydGRpZW5hJywncGlla3RkaWVuYScsJ3Nlc3RkaWVuYSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnc3Z0JywncHJtJywnb3RyJywndHJlJywnY3RyJywncGt0Jywnc3N0J10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnU3YnLCdQcicsJ090JywnVHInLCdDdCcsJ1BrJywnU3MnXSxcblx0XHR3ZWVrSGVhZGVyOiAnTmVkLicsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ2x2J10pO1xufSk7XG5cbi8qIE1hY2Vkb25pYW4gaTE4biBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IFN0b2pjZSBTbGF2a292c2tpLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ21rJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn0JfQsNGC0LLQvtGA0LgnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7Jyxcblx0XHRuZXh0VGV4dDogJyYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICfQlNC10L3QtdGBJyxcblx0XHRtb250aE5hbWVzOiBbJ9CI0LDQvdGD0LDRgNC4Jywn0KTQtdCy0YDRg9Cw0YDQuCcsJ9Cc0LDRgNGCJywn0JDQv9GA0LjQuycsJ9Cc0LDRmCcsJ9CI0YPQvdC4Jyxcblx0XHQn0IjRg9C70LgnLCfQkNCy0LPRg9GB0YInLCfQodC10L/RgtC10LzQstGA0LgnLCfQntC60YLQvtC80LLRgNC4Jywn0J3QvtC10LzQstGA0LgnLCfQlNC10LrQtdC80LLRgNC4J10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ9CI0LDQvScsJ9Ck0LXQsicsJ9Cc0LDRgCcsJ9CQ0L/RgCcsJ9Cc0LDRmCcsJ9CI0YPQvScsXG5cdFx0J9CI0YPQuycsJ9CQ0LLQsycsJ9Ch0LXQvycsJ9Ce0LrRgicsJ9Cd0L7QtScsJ9CU0LXQuiddLFxuXHRcdGRheU5hbWVzOiBbJ9Cd0LXQtNC10LvQsCcsJ9Cf0L7QvdC10LTQtdC70L3QuNC6Jywn0JLRgtC+0YDQvdC40LonLCfQodGA0LXQtNCwJywn0KfQtdGC0LLRgNGC0L7QuicsJ9Cf0LXRgtC+0LonLCfQodCw0LHQvtGC0LAnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ9Cd0LXQtCcsJ9Cf0L7QvScsJ9CS0YLQvicsJ9Ch0YDQtScsJ9Cn0LXRgicsJ9Cf0LXRgicsJ9Ch0LDQsSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ9Cd0LUnLCfQn9C+Jywn0JLRgicsJ9Ch0YAnLCfQp9C1Jywn0J/QtScsJ9Ch0LAnXSxcblx0XHR3ZWVrSGVhZGVyOiAn0KHQtdC0Jyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnbWsnXSk7XG59KTtcblxuLyogTWFsYXlhbGFtIChVVEYtOCkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBTYWppIE5lZGl5YW5jaGF0aCAoc2FqaTg5QGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnbWwnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfgtLbgtLDgtL8nLFxuXHRcdHByZXZUZXh0OiAn4LSu4LWB4LSo4LWN4LSo4LSk4LWN4LSk4LWGJyxcblx0XHRuZXh0VGV4dDogJ+C0heC0n+C1geC0pOC1jeC0pOC0pOC1jSAnLFxuXHRcdGN1cnJlbnRUZXh0OiAn4LSH4LSo4LWN4LSo4LWNJyxcblx0XHRtb250aE5hbWVzOiBbJ+C0nOC0qOC1geC0teC0sOC0vycsJ+C0q+C1huC0rOC1jeC0sOC1geC0teC0sOC0vycsJ+C0ruC0vuC0sOC1jeKAjeC0muC1jeC0muC1jScsJ+C0j+C0quC1jeC0sOC0v+C0suC1jeKAjScsJ+C0ruC1h+C0r+C1jScsJ+C0nOC1guC0o+C1jeKAjScsXG5cdFx0J+C0nOC1guC0suC1iCcsJ+C0huC0l+C0uOC1jeC0seC1jeC0seC1jScsJ+C0uOC1huC0quC1jeC0seC1jeC0seC0guC0rOC0sOC1jeKAjScsJ+C0kuC0leC1jeC0n+C1i+C0rOC0sOC1jeKAjScsJ+C0qOC0teC0guC0rOC0sOC1jeKAjScsJ+C0oeC0v+C0uOC0guC0rOC0sOC1jeKAjSddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfgtJzgtKjgtYEnLCAn4LSr4LWG4LSs4LWNJywgJ+C0ruC0vuC0sOC1jeKAjScsICfgtI/gtKrgtY3gtLDgtL8nLCAn4LSu4LWH4LSv4LWNJywgJ+C0nOC1guC0o+C1jeKAjScsXG5cdFx0J+C0nOC1guC0suC0vicsICfgtIbgtJcnLCAn4LS44LWG4LSq4LWNJywgJ+C0kuC0leC1jeC0n+C1iycsICfgtKjgtLXgtIInLCAn4LSh4LS/4LS4J10sXG5cdFx0ZGF5TmFtZXM6IFsn4LSe4LS+4LSv4LSw4LWN4oCNJywgJ+C0pOC0v+C0meC1jeC0leC0s+C1jeKAjScsICfgtJrgtYrgtLXgtY3gtLUnLCAn4LSs4LWB4LSn4LSo4LWN4oCNJywgJ+C0teC1jeC0r+C0vuC0tOC0gicsICfgtLXgtYbgtLPgtY3gtLPgtL8nLCAn4LS24LSo4LS/J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfgtJ7gtL7gtK8nLCAn4LSk4LS/4LSZ4LWN4LSVJywgJ+C0muC1iuC0teC1jeC0tScsICfgtKzgtYHgtKcnLCAn4LS14LWN4LSv4LS+4LS04LSCJywgJ+C0teC1huC0s+C1jeC0s+C0vycsICfgtLbgtKjgtL8nXSxcblx0XHRkYXlOYW1lc01pbjogWyfgtJ7gtL4nLCfgtKTgtL8nLCfgtJrgtYonLCfgtKzgtYEnLCfgtLXgtY3gtK/gtL4nLCfgtLXgtYYnLCfgtLYnXSxcblx0XHR3ZWVrSGVhZGVyOiAn4LSGJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnbWwnXSk7XG59KTtcblxuLyogTWFsYXlzaWFuIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgTW9oZCBOYXdhd2kgTW9oYW1hZCBKYW1pbGkgKG5hd2F3aUByb25nZ2VuZy5uZXQpLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ21zJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnVHV0dXAnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7U2ViZWx1bScsXG5cdFx0bmV4dFRleHQ6ICdTZWxlcGFzJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ2hhcmkgaW5pJyxcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcmknLCdGZWJydWFyaScsJ01hYycsJ0FwcmlsJywnTWVpJywnSnVuJyxcblx0XHQnSnVsYWknLCdPZ29zJywnU2VwdGVtYmVyJywnT2t0b2JlcicsJ05vdmVtYmVyJywnRGlzZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywnRmViJywnTWFjJywnQXByJywnTWVpJywnSnVuJyxcblx0XHQnSnVsJywnT2dvJywnU2VwJywnT2t0JywnTm92JywnRGlzJ10sXG5cdFx0ZGF5TmFtZXM6IFsnQWhhZCcsJ0lzbmluJywnU2VsYXNhJywnUmFidScsJ0toYW1pcycsJ0p1bWFhdCcsJ1NhYnR1J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydBaGEnLCdJc24nLCdTZWwnLCdSYWInLCdraGEnLCdKdW0nLCdTYWInXSxcblx0XHRkYXlOYW1lc01pbjogWydBaCcsJ0lzJywnU2UnLCdSYScsJ0toJywnSnUnLCdTYSddLFxuXHRcdHdlZWtIZWFkZXI6ICdNZycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMCxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ21zJ10pO1xufSk7XG5cbi8qIE5vcndlZ2lhbiBCb2ttw6VsIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgQmrDuHJuIEpvaGFuc2VuIChwb3N0QGJqb3Juam9oYW5zZW4ubm8pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ25iJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnTHVraycsXG5cdFx0cHJldlRleHQ6ICcmI3hBQjtGb3JyaWdlJyxcblx0XHRuZXh0VGV4dDogJ05lc3RlJiN4QkI7Jyxcblx0XHRjdXJyZW50VGV4dDogJ0kgZGFnJyxcblx0XHRtb250aE5hbWVzOiBbJ2phbnVhcicsJ2ZlYnJ1YXInLCdtYXJzJywnYXByaWwnLCdtYWknLCdqdW5pJywnanVsaScsJ2F1Z3VzdCcsJ3NlcHRlbWJlcicsJ29rdG9iZXInLCdub3ZlbWJlcicsJ2Rlc2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ2phbicsJ2ZlYicsJ21hcicsJ2FwcicsJ21haScsJ2p1bicsJ2p1bCcsJ2F1ZycsJ3NlcCcsJ29rdCcsJ25vdicsJ2RlcyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnc8O4bicsJ21hbicsJ3RpcicsJ29ucycsJ3RvcicsJ2ZyZScsJ2zDuHInXSxcblx0XHRkYXlOYW1lczogWydzw7huZGFnJywnbWFuZGFnJywndGlyc2RhZycsJ29uc2RhZycsJ3RvcnNkYWcnLCdmcmVkYWcnLCdsw7hyZGFnJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnc8O4JywnbWEnLCd0aScsJ29uJywndG8nLCdmcicsJ2zDuCddLFxuXHRcdHdlZWtIZWFkZXI6ICdVa2UnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJydcblx0fTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnbmInXSk7XG59KTtcblxuLyogRHV0Y2ggKEJlbGdpdW0pIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIERhdmlkIERlIFNsb292ZXJlIEBEYXZpZERlU2xvb3ZlcmUgKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydubC1CRSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ1NsdWl0ZW4nLFxuXHRcdHByZXZUZXh0OiAn4oaQJyxcblx0XHRuZXh0VGV4dDogJ+KGkicsXG5cdFx0Y3VycmVudFRleHQ6ICdWYW5kYWFnJyxcblx0XHRtb250aE5hbWVzOiBbJ2phbnVhcmknLCAnZmVicnVhcmknLCAnbWFhcnQnLCAnYXByaWwnLCAnbWVpJywgJ2p1bmknLFxuXHRcdCdqdWxpJywgJ2F1Z3VzdHVzJywgJ3NlcHRlbWJlcicsICdva3RvYmVyJywgJ25vdmVtYmVyJywgJ2RlY2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ2phbicsICdmZWInLCAnbXJ0JywgJ2FwcicsICdtZWknLCAnanVuJyxcblx0XHQnanVsJywgJ2F1ZycsICdzZXAnLCAnb2t0JywgJ25vdicsICdkZWMnXSxcblx0XHRkYXlOYW1lczogWyd6b25kYWcnLCAnbWFhbmRhZycsICdkaW5zZGFnJywgJ3dvZW5zZGFnJywgJ2RvbmRlcmRhZycsICd2cmlqZGFnJywgJ3phdGVyZGFnJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyd6b24nLCAnbWFhJywgJ2RpbicsICd3b2UnLCAnZG9uJywgJ3ZyaScsICd6YXQnXSxcblx0XHRkYXlOYW1lc01pbjogWyd6bycsICdtYScsICdkaScsICd3bycsICdkbycsICd2cicsICd6YSddLFxuXHRcdHdlZWtIZWFkZXI6ICdXaycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ25sLUJFJ10pO1xufSk7XG5cbi8qIER1dGNoIChVVEYtOCkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBNYXRoaWFzIEJ5bmVucyA8aHR0cDovL21hdGhpYXNieW5lbnMuYmUvPiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWwubmwgPSB7XG5cdFx0Y2xvc2VUZXh0OiAnU2x1aXRlbicsXG5cdFx0cHJldlRleHQ6ICfihpAnLFxuXHRcdG5leHRUZXh0OiAn4oaSJyxcblx0XHRjdXJyZW50VGV4dDogJ1ZhbmRhYWcnLFxuXHRcdG1vbnRoTmFtZXM6IFsnamFudWFyaScsICdmZWJydWFyaScsICdtYWFydCcsICdhcHJpbCcsICdtZWknLCAnanVuaScsXG5cdFx0J2p1bGknLCAnYXVndXN0dXMnLCAnc2VwdGVtYmVyJywgJ29rdG9iZXInLCAnbm92ZW1iZXInLCAnZGVjZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnamFuJywgJ2ZlYicsICdtcnQnLCAnYXByJywgJ21laScsICdqdW4nLFxuXHRcdCdqdWwnLCAnYXVnJywgJ3NlcCcsICdva3QnLCAnbm92JywgJ2RlYyddLFxuXHRcdGRheU5hbWVzOiBbJ3pvbmRhZycsICdtYWFuZGFnJywgJ2RpbnNkYWcnLCAnd29lbnNkYWcnLCAnZG9uZGVyZGFnJywgJ3ZyaWpkYWcnLCAnemF0ZXJkYWcnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ3pvbicsICdtYWEnLCAnZGluJywgJ3dvZScsICdkb24nLCAndnJpJywgJ3phdCddLFxuXHRcdGRheU5hbWVzTWluOiBbJ3pvJywgJ21hJywgJ2RpJywgJ3dvJywgJ2RvJywgJ3ZyJywgJ3phJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1drJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQtbW0teXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbC5ubCk7XG59KTtcblxuLyogTm9yd2VnaWFuIE55bm9yc2sgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBCasO4cm4gSm9oYW5zZW4gKHBvc3RAYmpvcm5qb2hhbnNlbi5ubykuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnbm4nXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdMdWtrJyxcblx0XHRwcmV2VGV4dDogJyYjeEFCO0bDuHJyZScsXG5cdFx0bmV4dFRleHQ6ICdOZXN0ZSYjeEJCOycsXG5cdFx0Y3VycmVudFRleHQ6ICdJIGRhZycsXG5cdFx0bW9udGhOYW1lczogWydqYW51YXInLCdmZWJydWFyJywnbWFycycsJ2FwcmlsJywnbWFpJywnanVuaScsJ2p1bGknLCdhdWd1c3QnLCdzZXB0ZW1iZXInLCdva3RvYmVyJywnbm92ZW1iZXInLCdkZXNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydqYW4nLCdmZWInLCdtYXInLCdhcHInLCdtYWknLCdqdW4nLCdqdWwnLCdhdWcnLCdzZXAnLCdva3QnLCdub3YnLCdkZXMnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ3N1bicsJ23DpW4nLCd0eXMnLCdvbnMnLCd0b3InLCdmcmUnLCdsYXUnXSxcblx0XHRkYXlOYW1lczogWydzdW5kYWcnLCdtw6VuZGFnJywndHlzZGFnJywnb25zZGFnJywndG9yc2RhZycsJ2ZyZWRhZycsJ2xhdXJkYWcnXSxcblx0XHRkYXlOYW1lc01pbjogWydzdScsJ23DpScsJ3R5Jywnb24nLCd0bycsJ2ZyJywnbGEnXSxcblx0XHR3ZWVrSGVhZGVyOiAnVmVrZScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ1xuXHR9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydubiddKTtcbn0pO1xuXG4vKiBOb3J3ZWdpYW4gaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBOYWltZGpvbiBUYWtoaXJvdiAobmFpbWRqb25AZ21haWwuY29tKS4gKi9cblxualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ25vJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnTHVraycsXG5cdFx0cHJldlRleHQ6ICcmI3hBQjtGb3JyaWdlJyxcblx0XHRuZXh0VGV4dDogJ05lc3RlJiN4QkI7Jyxcblx0XHRjdXJyZW50VGV4dDogJ0kgZGFnJyxcblx0XHRtb250aE5hbWVzOiBbJ2phbnVhcicsJ2ZlYnJ1YXInLCdtYXJzJywnYXByaWwnLCdtYWknLCdqdW5pJywnanVsaScsJ2F1Z3VzdCcsJ3NlcHRlbWJlcicsJ29rdG9iZXInLCdub3ZlbWJlcicsJ2Rlc2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ2phbicsJ2ZlYicsJ21hcicsJ2FwcicsJ21haScsJ2p1bicsJ2p1bCcsJ2F1ZycsJ3NlcCcsJ29rdCcsJ25vdicsJ2RlcyddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnc8O4bicsJ21hbicsJ3RpcicsJ29ucycsJ3RvcicsJ2ZyZScsJ2zDuHInXSxcblx0XHRkYXlOYW1lczogWydzw7huZGFnJywnbWFuZGFnJywndGlyc2RhZycsJ29uc2RhZycsJ3RvcnNkYWcnLCdmcmVkYWcnLCdsw7hyZGFnJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnc8O4JywnbWEnLCd0aScsJ29uJywndG8nLCdmcicsJ2zDuCddLFxuXHRcdHdlZWtIZWFkZXI6ICdVa2UnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJydcblx0fTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnbm8nXSk7XG59KTtcblxuLyogUG9saXNoIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgSmFjZWsgV3lzb2NraSAoamFjZWsud3lzb2NraUBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3BsJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnWmFta25paicsXG5cdFx0cHJldlRleHQ6ICcmI3gzQztQb3ByemVkbmknLFxuXHRcdG5leHRUZXh0OiAnTmFzdMSZcG55JiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ0R6acWbJyxcblx0XHRtb250aE5hbWVzOiBbJ1N0eWN6ZcWEJywnTHV0eScsJ01hcnplYycsJ0t3aWVjaWXFhCcsJ01haicsJ0N6ZXJ3aWVjJyxcblx0XHQnTGlwaWVjJywnU2llcnBpZcWEJywnV3J6ZXNpZcWEJywnUGHFumR6aWVybmlrJywnTGlzdG9wYWQnLCdHcnVkemllxYQnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnU3R5JywnTHUnLCdNYXInLCdLdycsJ01haicsJ0N6ZScsXG5cdFx0J0xpcCcsJ1NpZScsJ1dyeicsJ1BhJywnTGlzJywnR3J1J10sXG5cdFx0ZGF5TmFtZXM6IFsnTmllZHppZWxhJywnUG9uaWVkemlhxYJlaycsJ1d0b3JlaycsJ8Wacm9kYScsJ0N6d2FydGVrJywnUGnEhXRlaycsJ1NvYm90YSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnTmllJywnUG4nLCdXdCcsJ8WacicsJ0N6dycsJ1B0JywnU28nXSxcblx0XHRkYXlOYW1lc01pbjogWydOJywnUG4nLCdXdCcsJ8WacicsJ0N6JywnUHQnLCdTbyddLFxuXHRcdHdlZWtIZWFkZXI6ICdUeWR6Jyxcblx0XHRkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsncGwnXSk7XG59KTtcblxuLyogQnJhemlsaWFuIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgTGVvbmlsZG8gQ29zdGEgU2lsdmEgKGxlb2NzaWx2YUBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3B0LUJSJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnRmVjaGFyJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO0FudGVyaW9yJyxcblx0XHRuZXh0VGV4dDogJ1Byw7N4aW1vJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ0hvamUnLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFuZWlybycsJ0ZldmVyZWlybycsJ01hcsOnbycsJ0FicmlsJywnTWFpbycsJ0p1bmhvJyxcblx0XHQnSnVsaG8nLCdBZ29zdG8nLCdTZXRlbWJybycsJ091dHVicm8nLCdOb3ZlbWJybycsJ0RlemVtYnJvJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZldicsJ01hcicsJ0FicicsJ01haScsJ0p1bicsXG5cdFx0J0p1bCcsJ0FnbycsJ1NldCcsJ091dCcsJ05vdicsJ0RleiddLFxuXHRcdGRheU5hbWVzOiBbJ0RvbWluZ28nLCdTZWd1bmRhLWZlaXJhJywnVGVyw6dhLWZlaXJhJywnUXVhcnRhLWZlaXJhJywnUXVpbnRhLWZlaXJhJywnU2V4dGEtZmVpcmEnLCdTw6FiYWRvJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydEb20nLCdTZWcnLCdUZXInLCdRdWEnLCdRdWknLCdTZXgnLCdTw6FiJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnRG9tJywnU2VnJywnVGVyJywnUXVhJywnUXVpJywnU2V4JywnU8OhYiddLFxuXHRcdHdlZWtIZWFkZXI6ICdTbScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMCxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3B0LUJSJ10pO1xufSk7XG5cbi8qIFBvcnR1Z3Vlc2UgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3B0J10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnRmVjaGFyJyxcblx0XHRwcmV2VGV4dDogJ0FudGVyaW9yJyxcblx0XHRuZXh0VGV4dDogJ1NlZ3VpbnRlJyxcblx0XHRjdXJyZW50VGV4dDogJ0hvamUnLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFuZWlybycsJ0ZldmVyZWlybycsJ01hcsOnbycsJ0FicmlsJywnTWFpbycsJ0p1bmhvJyxcblx0XHQnSnVsaG8nLCdBZ29zdG8nLCdTZXRlbWJybycsJ091dHVicm8nLCdOb3ZlbWJybycsJ0RlemVtYnJvJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZldicsJ01hcicsJ0FicicsJ01haScsJ0p1bicsXG5cdFx0J0p1bCcsJ0FnbycsJ1NldCcsJ091dCcsJ05vdicsJ0RleiddLFxuXHRcdGRheU5hbWVzOiBbJ0RvbWluZ28nLCdTZWd1bmRhLWZlaXJhJywnVGVyw6dhLWZlaXJhJywnUXVhcnRhLWZlaXJhJywnUXVpbnRhLWZlaXJhJywnU2V4dGEtZmVpcmEnLCdTw6FiYWRvJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydEb20nLCdTZWcnLCdUZXInLCdRdWEnLCdRdWknLCdTZXgnLCdTw6FiJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnRG9tJywnU2VnJywnVGVyJywnUXVhJywnUXVpJywnU2V4JywnU8OhYiddLFxuXHRcdHdlZWtIZWFkZXI6ICdTZW0nLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDAsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydwdCddKTtcbn0pO1xuXG4vKiBSb21hbnNoIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgWXZvbm5lIEdpZW5hbCAoeXZvbm5lLmdpZW5hbEBlZHVjYS5jaCkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsncm0nXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdTZXJyYXInLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7U3VhbmRhbnQnLFxuXHRcdG5leHRUZXh0OiAnUHJlY2VkZW50JiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ0FjdHVhbCcsXG5cdFx0bW9udGhOYW1lczogWydTY2hhbmVyJywnRmF2cmVyJywnTWFycycsJ0F2cmlnbCcsJ01hdGcnLCdaZXJjbGFkdXInLCAnRmFuYWR1cicsJ0F2dXN0JywnU2V0dGVtYmVyJywnT2N0b2JlcicsJ05vdmVtYmVyJywnRGVjZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnU2NoYScsJ0ZldicsJ01hcicsJ0F2cicsJ01hdGcnLCdaZXInLCAnRmFuJywnQXZ1JywnU2V0dCcsJ09jdCcsJ05vdicsJ0RlYyddLFxuXHRcdGRheU5hbWVzOiBbJ0R1bWVuZ2lhJywnR2xpbmRlc2RpJywnTWFyZGknLCdNZXNlbW5hJywnR2lldmdpYScsJ1ZlbmRlcmRpJywnU29uZGEnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ0R1bScsJ0dsaScsJ01hcicsJ01lcycsJ0dpZScsJ1ZlbicsJ1NvbSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ0R1JywnR2wnLCdNYScsJ01lJywnR2knLCdWZScsJ1NvJ10sXG5cdFx0d2Vla0hlYWRlcjogJ2VtbmEnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydybSddKTtcbn0pO1xuXG4vKiBSb21hbmlhbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uXG4gKlxuICogV3JpdHRlbiBieSBFZG1vbmQgTC4gKGxsX2VkbW9uZEB3YWxsYS5jb20pXG4gKiBhbmQgSW9udXQgRy4gU3RhbiAoaW9udXQuZy5zdGFuQGdtYWlsLmNvbSlcbiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3JvJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnw45uY2hpZGUnLFxuXHRcdHByZXZUZXh0OiAnJiN4QUI7IEx1bmEgcHJlY2VkZW50xIMnLFxuXHRcdG5leHRUZXh0OiAnTHVuYSB1cm3Eg3RvYXJlICYjeEJCOycsXG5cdFx0Y3VycmVudFRleHQ6ICdBemknLFxuXHRcdG1vbnRoTmFtZXM6IFsnSWFudWFyaWUnLCdGZWJydWFyaWUnLCdNYXJ0aWUnLCdBcHJpbGllJywnTWFpJywnSXVuaWUnLFxuXHRcdCdJdWxpZScsJ0F1Z3VzdCcsJ1NlcHRlbWJyaWUnLCdPY3RvbWJyaWUnLCdOb2llbWJyaWUnLCdEZWNlbWJyaWUnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSWFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01haScsICdJdW4nLFxuXHRcdCdJdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuXHRcdGRheU5hbWVzOiBbJ0R1bWluaWPEgycsICdMdW5pJywgJ01hcsWjaScsICdNaWVyY3VyaScsICdKb2knLCAnVmluZXJpJywgJ1PDom1ixIN0xIMnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ0R1bScsICdMdW4nLCAnTWFyJywgJ01pZScsICdKb2knLCAnVmluJywgJ1PDom0nXSxcblx0XHRkYXlOYW1lc01pbjogWydEdScsJ0x1JywnTWEnLCdNaScsJ0pvJywnVmknLCdTw6InXSxcblx0XHR3ZWVrSGVhZGVyOiAnU8SDcHQnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWydybyddKTtcbn0pO1xuXG4vKiBSdXNzaWFuIChVVEYtOCkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBBbmRyZXcgU3Ryb21ub3YgKHN0cm9tbm92QGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsncnUnXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfQl9Cw0LrRgNGL0YLRjCcsXG5cdFx0cHJldlRleHQ6ICcmI3gzQzvQn9GA0LXQtCcsXG5cdFx0bmV4dFRleHQ6ICfQodC70LXQtCYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICfQodC10LPQvtC00L3RjycsXG5cdFx0bW9udGhOYW1lczogWyfQr9C90LLQsNGA0YwnLCfQpNC10LLRgNCw0LvRjCcsJ9Cc0LDRgNGCJywn0JDQv9GA0LXQu9GMJywn0JzQsNC5Jywn0JjRjtC90YwnLFxuXHRcdCfQmNGO0LvRjCcsJ9CQ0LLQs9GD0YHRgicsJ9Ch0LXQvdGC0Y/QsdGA0YwnLCfQntC60YLRj9Cx0YDRjCcsJ9Cd0L7Rj9Cx0YDRjCcsJ9CU0LXQutCw0LHRgNGMJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ9Cv0L3QsicsJ9Ck0LXQsicsJ9Cc0LDRgCcsJ9CQ0L/RgCcsJ9Cc0LDQuScsJ9CY0Y7QvScsXG5cdFx0J9CY0Y7QuycsJ9CQ0LLQsycsJ9Ch0LXQvScsJ9Ce0LrRgicsJ9Cd0L7RjycsJ9CU0LXQuiddLFxuXHRcdGRheU5hbWVzOiBbJ9Cy0L7RgdC60YDQtdGB0LXQvdGM0LUnLCfQv9C+0L3QtdC00LXQu9GM0L3QuNC6Jywn0LLRgtC+0YDQvdC40LonLCfRgdGA0LXQtNCwJywn0YfQtdGC0LLQtdGA0LMnLCfQv9GP0YLQvdC40YbQsCcsJ9GB0YPQsdCx0L7RgtCwJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfQstGB0LonLCfQv9C90LQnLCfQstGC0YAnLCfRgdGA0LQnLCfRh9GC0LInLCfQv9GC0L0nLCfRgdCx0YInXSxcblx0XHRkYXlOYW1lc01pbjogWyfQktGBJywn0J/QvScsJ9CS0YInLCfQodGAJywn0KfRgicsJ9Cf0YInLCfQodCxJ10sXG5cdFx0d2Vla0hlYWRlcjogJ9Cd0LXQtCcsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3J1J10pO1xufSk7XG5cbi8qIFNsb3ZhayBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IFZvanRlY2ggUmluaWsgKHZvanRvQGhtbS5zaykuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnc2snXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdaYXZyaWXFpScsXG5cdFx0cHJldlRleHQ6ICcmI3gzQztQcmVkY2jDoWR6YWrDumNpJyxcblx0XHRuZXh0VGV4dDogJ05hc2xlZHVqw7pjaSYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdEbmVzJyxcblx0XHRtb250aE5hbWVzOiBbJ2phbnXDoXInLCdmZWJydcOhcicsJ21hcmVjJywnYXByw61sJywnbcOhaicsJ2rDum4nLFxuXHRcdCdqw7psJywnYXVndXN0Jywnc2VwdGVtYmVyJywnb2t0w7NiZXInLCdub3ZlbWJlcicsJ2RlY2VtYmVyJ10sXG5cdFx0bW9udGhOYW1lc1Nob3J0OiBbJ0phbicsJ0ZlYicsJ01hcicsJ0FwcicsJ03DoWonLCdKw7puJyxcblx0XHQnSsO6bCcsJ0F1ZycsJ1NlcCcsJ09rdCcsJ05vdicsJ0RlYyddLFxuXHRcdGRheU5hbWVzOiBbJ25lZGXEvmEnLCdwb25kZWxvaycsJ3V0b3JvaycsJ3N0cmVkYScsJ8WhdHZydG9rJywncGlhdG9rJywnc29ib3RhJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydOZWQnLCdQb24nLCdVdG8nLCdTdHInLCfFoHR2JywnUGlhJywnU29iJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnTmUnLCdQbycsJ1V0JywnU3QnLCfFoHQnLCdQaWEnLCdTbyddLFxuXHRcdHdlZWtIZWFkZXI6ICdUeScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3NrJ10pO1xufSk7XG5cbi8qIFNsb3ZlbmlhbiBpbml0aWFsaXNhdGlvbiBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IEpha2EgSmFuY2FyIChqYWthQGt1YmplLm9yZykuICovXG4vKiBjID0gxI0sIHMgPSDFoSB6ID0gxb4gQyA9IMSMIFMgPSDFoCBaID0gxb0gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydzbCddID0ge1xuXHRcdGNsb3NlVGV4dDogJ1phcHJpJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO1ByZWrFoW5qaScsXG5cdFx0bmV4dFRleHQ6ICdOYXNsZWRuamkmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnVHJlbnV0bmknLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFudWFyJywnRmVicnVhcicsJ01hcmVjJywnQXByaWwnLCdNYWonLCdKdW5paicsXG5cdFx0J0p1bGlqJywnQXZndXN0JywnU2VwdGVtYmVyJywnT2t0b2JlcicsJ05vdmVtYmVyJywnRGVjZW1iZXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywnRmViJywnTWFyJywnQXByJywnTWFqJywnSnVuJyxcblx0XHQnSnVsJywnQXZnJywnU2VwJywnT2t0JywnTm92JywnRGVjJ10sXG5cdFx0ZGF5TmFtZXM6IFsnTmVkZWxqYScsJ1BvbmVkZWxqZWsnLCdUb3JlaycsJ1NyZWRhJywnxIxldHJ0ZWsnLCdQZXRlaycsJ1NvYm90YSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnTmVkJywnUG9uJywnVG9yJywnU3JlJywnxIxldCcsJ1BldCcsJ1NvYiddLFxuXHRcdGRheU5hbWVzTWluOiBbJ05lJywnUG8nLCdUbycsJ1NyJywnxIxlJywnUGUnLCdTbyddLFxuXHRcdHdlZWtIZWFkZXI6ICdUZWRlbicsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3NsJ10pO1xufSk7XG5cbi8qIEFsYmFuaWFuIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgRmxha3JvbiBCeXR5cWkgKGZsYWtyb25AZ21haWwuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydzcSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ21ieWxsZScsXG5cdFx0cHJldlRleHQ6ICcmI3gzQzttYnJhcGEnLFxuXHRcdG5leHRUZXh0OiAnUMOrcnBhcmEmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnc290Jyxcblx0XHRtb250aE5hbWVzOiBbJ0phbmFyJywnU2hrdXJ0JywnTWFycycsJ1ByaWxsJywnTWFqJywnUWVyc2hvcicsXG5cdFx0J0tvcnJpaycsJ0d1c2h0JywnU2h0YXRvcicsJ1RldG9yJywnTsOrbnRvcicsJ0RoamV0b3InXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywnU2hrJywnTWFyJywnUHJpJywnTWFqJywnUWVyJyxcblx0XHQnS29yJywnR3VzJywnU2h0JywnVGV0JywnTsOrbicsJ0RoaiddLFxuXHRcdGRheU5hbWVzOiBbJ0UgRGllbCcsJ0UgSMOrbsOrJywnRSBNYXJ0w6snLCdFIE3Dq3JrdXLDqycsJ0UgRW5qdGUnLCdFIFByZW10ZScsJ0UgU2h0dW5lJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydEaScsJ0jDqycsJ01hJywnTcOrJywnRW4nLCdQcicsJ1NoJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnRGknLCdIw6snLCdNYScsJ03DqycsJ0VuJywnUHInLCdTaCddLFxuXHRcdHdlZWtIZWFkZXI6ICdKYScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3NxJ10pO1xufSk7XG5cbi8qIFNlcmJpYW4gaTE4biBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IERlamFuIERpbWnEhy4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydzci1TUiddID0ge1xuXHRcdGNsb3NlVGV4dDogJ1phdHZvcmknLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7Jyxcblx0XHRuZXh0VGV4dDogJyYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICdEYW5hcycsXG5cdFx0bW9udGhOYW1lczogWydKYW51YXInLCdGZWJydWFyJywnTWFydCcsJ0FwcmlsJywnTWFqJywnSnVuJyxcblx0XHQnSnVsJywnQXZndXN0JywnU2VwdGVtYmFyJywnT2t0b2JhcicsJ05vdmVtYmFyJywnRGVjZW1iYXInXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywnRmViJywnTWFyJywnQXByJywnTWFqJywnSnVuJyxcblx0XHQnSnVsJywnQXZnJywnU2VwJywnT2t0JywnTm92JywnRGVjJ10sXG5cdFx0ZGF5TmFtZXM6IFsnTmVkZWxqYScsJ1BvbmVkZWxqYWsnLCdVdG9yYWsnLCdTcmVkYScsJ8SMZXR2cnRhaycsJ1BldGFrJywnU3Vib3RhJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydOZWQnLCdQb24nLCdVdG8nLCdTcmUnLCfEjGV0JywnUGV0JywnU3ViJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsnTmUnLCdQbycsJ1V0JywnU3InLCfEjGUnLCdQZScsJ1N1J10sXG5cdFx0d2Vla0hlYWRlcjogJ1NlZCcsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3NyLVNSJ10pO1xufSk7XG5cbi8qIFNlcmJpYW4gaTE4biBmb3IgdGhlIGpRdWVyeSBVSSBkYXRlIHBpY2tlciBwbHVnaW4uICovXG4vKiBXcml0dGVuIGJ5IERlamFuIERpbWnEhy4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWydzciddID0ge1xuXHRcdGNsb3NlVGV4dDogJ9CX0LDRgtCy0L7RgNC4Jyxcblx0XHRwcmV2VGV4dDogJyYjeDNDOycsXG5cdFx0bmV4dFRleHQ6ICcmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn0JTQsNC90LDRgScsXG5cdFx0bW9udGhOYW1lczogWyfQiNCw0L3Rg9Cw0YAnLCfQpNC10LHRgNGD0LDRgCcsJ9Cc0LDRgNGCJywn0JDQv9GA0LjQuycsJ9Cc0LDRmCcsJ9CI0YPQvScsXG5cdFx0J9CI0YPQuycsJ9CQ0LLQs9GD0YHRgicsJ9Ch0LXQv9GC0LXQvNCx0LDRgCcsJ9Ce0LrRgtC+0LHQsNGAJywn0J3QvtCy0LXQvNCx0LDRgCcsJ9CU0LXRhtC10LzQsdCw0YAnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn0IjQsNC9Jywn0KTQtdCxJywn0JzQsNGAJywn0JDQv9GAJywn0JzQsNGYJywn0IjRg9C9Jyxcblx0XHQn0IjRg9C7Jywn0JDQstCzJywn0KHQtdC/Jywn0J7QutGCJywn0J3QvtCyJywn0JTQtdGGJ10sXG5cdFx0ZGF5TmFtZXM6IFsn0J3QtdC00LXRmdCwJywn0J/QvtC90LXQtNC10ZnQsNC6Jywn0KPRgtC+0YDQsNC6Jywn0KHRgNC10LTQsCcsJ9Cn0LXRgtCy0YDRgtCw0LonLCfQn9C10YLQsNC6Jywn0KHRg9Cx0L7RgtCwJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfQndC10LQnLCfQn9C+0L0nLCfQo9GC0L4nLCfQodGA0LUnLCfQp9C10YInLCfQn9C10YInLCfQodGD0LEnXSxcblx0XHRkYXlOYW1lc01pbjogWyfQndC1Jywn0J/QvicsJ9Cj0YInLCfQodGAJywn0KfQtScsJ9Cf0LUnLCfQodGDJ10sXG5cdFx0d2Vla0hlYWRlcjogJ9Ch0LXQtCcsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3NyJ10pO1xufSk7XG5cbi8qIFN3ZWRpc2ggaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBBbmRlcnMgRWtkYWhsICggYW5kZXJzQG5vbWFkaXouc2UpLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3N2J10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnU3TDpG5nJyxcblx0XHRwcmV2VGV4dDogJyYjeEFCO0bDtnJyYScsXG5cdFx0bmV4dFRleHQ6ICdOw6RzdGEmI3hCQjsnLFxuXHRcdGN1cnJlbnRUZXh0OiAnSWRhZycsXG5cdFx0bW9udGhOYW1lczogWydKYW51YXJpJywnRmVicnVhcmknLCdNYXJzJywnQXByaWwnLCdNYWonLCdKdW5pJyxcblx0XHQnSnVsaScsJ0F1Z3VzdGknLCdTZXB0ZW1iZXInLCdPa3RvYmVyJywnTm92ZW1iZXInLCdEZWNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCdGZWInLCdNYXInLCdBcHInLCdNYWonLCdKdW4nLFxuXHRcdCdKdWwnLCdBdWcnLCdTZXAnLCdPa3QnLCdOb3YnLCdEZWMnXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ1PDtm4nLCdNw6VuJywnVGlzJywnT25zJywnVG9yJywnRnJlJywnTMO2ciddLFxuXHRcdGRheU5hbWVzOiBbJ1PDtm5kYWcnLCdNw6VuZGFnJywnVGlzZGFnJywnT25zZGFnJywnVG9yc2RhZycsJ0ZyZWRhZycsJ0zDtnJkYWcnXSxcblx0XHRkYXlOYW1lc01pbjogWydTw7YnLCdNw6UnLCdUaScsJ09uJywnVG8nLCdGcicsJ0zDtiddLFxuXHRcdHdlZWtIZWFkZXI6ICdWZScsXG5cdFx0ZGF0ZUZvcm1hdDogJ3l5LW1tLWRkJyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3N2J10pO1xufSk7XG5cbi8qIFRhbWlsIChVVEYtOCkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBTIEEgU3VyZXNoa3VtYXIgKHNhc2t1bWFyQGxpdmUuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWyd0YSddID0ge1xuXHRcdGNsb3NlVGV4dDogJ+CuruCvguCun+CvgScsXG5cdFx0cHJldlRleHQ6ICfgrq7gr4Hgrqngr43grqngr4jgrq/grqTgr4EnLFxuXHRcdG5leHRUZXh0OiAn4K6F4K6f4K+B4K6k4K+N4K6k4K6k4K+BJyxcblx0XHRjdXJyZW50VGV4dDogJ+Cuh+CuqeCvjeCuseCvgScsXG5cdFx0bW9udGhOYW1lczogWyfgrqTgr4gnLCfgrq7grr7grprgrr8nLCfgrqrgrpngr43grpXgr4Hgrqngrr8nLCfgrprgrr/grqTgr43grqTgrr/grrDgr4gnLCfgrrXgr4jgrpXgrr7grprgrr8nLCfgrobgrqngrr8nLFxuXHRcdCfgrobgrp/grr8nLCfgrobgrrXgrqPgrr8nLCfgrqrgr4HgrrDgrp/gr43grp/grr7grprgrr8nLCfgrpDgrqrgr43grqrgrprgrr8nLCfgrpXgrr7grrDgr43grqTgr43grqTgrr/grpXgr4gnLCfgrq7grr7grrDgr43grpXgrrTgrr8nXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn4K6k4K+IJywn4K6u4K6+4K6a4K6/Jywn4K6q4K6Z4K+NJywn4K6a4K6/4K6k4K+NJywn4K614K+I4K6V4K6+Jywn4K6G4K6p4K6/Jyxcblx0XHQn4K6G4K6f4K6/Jywn4K6G4K61Jywn4K6q4K+B4K6wJywn4K6Q4K6q4K+NJywn4K6V4K6+4K6w4K+NJywn4K6u4K6+4K6w4K+NJ10sXG5cdFx0ZGF5TmFtZXM6IFsn4K6e4K6+4K6v4K6/4K6x4K+N4K6x4K+B4K6V4K+N4K6V4K6/4K604K6u4K+IJywn4K6k4K6/4K6Z4K+N4K6V4K6f4K+N4K6V4K6/4K604K6u4K+IJywn4K6a4K+G4K614K+N4K614K6+4K6v4K+N4K6V4K+N4K6V4K6/4K604K6u4K+IJywn4K6q4K+B4K6k4K6p4K+N4K6V4K6/4K604K6u4K+IJywn4K614K6/4K6v4K6+4K604K6V4K+N4K6V4K6/4K604K6u4K+IJywn4K614K+G4K6z4K+N4K6z4K6/4K6V4K+N4K6V4K6/4K604K6u4K+IJywn4K6a4K6p4K6/4K6V4K+N4K6V4K6/4K604K6u4K+IJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfgrp7grr7grq/grr/grrHgr4EnLCfgrqTgrr/grpngr43grpXgrrPgr40nLCfgrprgr4bgrrXgr43grrXgrr7grq/gr40nLCfgrqrgr4HgrqTgrqngr40nLCfgrrXgrr/grq/grr7grrTgrqngr40nLCfgrrXgr4bgrrPgr43grrPgrr8nLCfgrprgrqngrr8nXSxcblx0XHRkYXlOYW1lc01pbjogWyfgrp7grr4nLCfgrqTgrr8nLCfgrprgr4YnLCfgrqrgr4EnLCfgrrXgrr8nLCfgrrXgr4YnLCfgrponXSxcblx0XHR3ZWVrSGVhZGVyOiAn0J3QtScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3RhJ10pO1xufSk7XG5cbi8qIFRoYWkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBwaXBvIChwaXBvQHNpeGhlYWQuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWyd0aCddID0ge1xuXHRcdGNsb3NlVGV4dDogJ+C4m+C4tOC4lCcsXG5cdFx0cHJldlRleHQ6ICcmI3hBQjsmI3hBMDvguKLguYnguK3guJknLFxuXHRcdG5leHRUZXh0OiAn4LiW4Lix4LiU4LmE4LibJiN4QTA7JiN4QkI7Jyxcblx0XHRjdXJyZW50VGV4dDogJ+C4p+C4seC4meC4meC4teC5iScsXG5cdFx0bW9udGhOYW1lczogWyfguKHguIHguKPguLLguITguKEnLCfguIHguLjguKHguKDguLLguJ7guLHguJnguJjguYwnLCfguKHguLXguJnguLLguITguKEnLCfguYDguKHguKnguLLguKLguJknLCfguJ7guKTguKnguKDguLLguITguKEnLCfguKHguLTguJbguLjguJnguLLguKLguJknLFxuXHRcdCfguIHguKPguIHguI7guLLguITguKEnLCfguKrguLTguIfguKvguLLguITguKEnLCfguIHguLHguJnguKLguLLguKLguJknLCfguJXguLjguKXguLLguITguKEnLCfguJ7guKTguKjguIjguLTguIHguLLguKLguJknLCfguJjguLHguJnguKfguLLguITguKEnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn4LihLuC4hC4nLCfguIEu4LieLicsJ+C4oeC4tS7guIQuJywn4LmA4LihLuC4oi4nLCfguJ4u4LiELicsJ+C4oeC4tC7guKIuJyxcblx0XHQn4LiBLuC4hC4nLCfguKou4LiELicsJ+C4gS7guKIuJywn4LiVLuC4hC4nLCfguJ4u4LiiLicsJ+C4mC7guIQuJ10sXG5cdFx0ZGF5TmFtZXM6IFsn4Lit4Liy4LiX4Li04LiV4Lii4LmMJywn4LiI4Lix4LiZ4LiX4Lij4LmMJywn4Lit4Lix4LiH4LiE4Liy4LijJywn4Lie4Li44LiYJywn4Lie4Lik4Lir4Lix4Liq4Lia4LiU4Li1Jywn4Lio4Li44LiB4Lij4LmMJywn4LmA4Liq4Liy4Lij4LmMJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfguK3guLIuJywn4LiILicsJ+C4rS4nLCfguJ4uJywn4Lie4LikLicsJ+C4qC4nLCfguKouJ10sXG5cdFx0ZGF5TmFtZXNNaW46IFsn4Lit4LiyLicsJ+C4iC4nLCfguK0uJywn4LieLicsJ+C4nuC4pC4nLCfguKguJywn4LiqLiddLFxuXHRcdHdlZWtIZWFkZXI6ICdXaycsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMCxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3RoJ10pO1xufSk7XG5cbi8qIFRhamlraSAoVVRGLTgpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgQWJkdXJhaG1vbiBTYWlkb3YgKHNhaWRvdmFiQGdtYWlsLmNvbSkuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsndGonXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfQmNC00L7QvNCwJyxcblx0XHRwcmV2VGV4dDogJyYjeDNjO9Ka0LDRhNC+Jyxcblx0XHRuZXh0VGV4dDogJ9Cf0LXRiCYjeDNlOycsXG5cdFx0Y3VycmVudFRleHQ6ICfQmNC80YDTr9C3Jyxcblx0XHRtb250aE5hbWVzOiBbJ9Cv0L3QstCw0YAnLCfQpNC10LLRgNCw0LsnLCfQnNCw0YDRgicsJ9CQ0L/RgNC10LsnLCfQnNCw0LknLCfQmNGO0L0nLFxuXHRcdCfQmNGO0LsnLCfQkNCy0LPRg9GB0YInLCfQodC10L3RgtGP0LHRgCcsJ9Ce0LrRgtGP0LHRgCcsJ9Cd0L7Rj9Cx0YAnLCfQlNC10LrQsNCx0YAnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn0K/QvdCyJywn0KTQtdCyJywn0JzQsNGAJywn0JDQv9GAJywn0JzQsNC5Jywn0JjRjtC9Jyxcblx0XHQn0JjRjtC7Jywn0JDQstCzJywn0KHQtdC9Jywn0J7QutGCJywn0J3QvtGPJywn0JTQtdC6J10sXG5cdFx0ZGF5TmFtZXM6IFsn0Y/QutGI0LDQvdCx0LUnLCfQtNGD0YjQsNC90LHQtScsJ9GB0LXRiNCw0L3QsdC1Jywn0YfQvtGA0YjQsNC90LHQtScsJ9C/0LDQvdK30YjQsNC90LHQtScsJ9K30YPQvNGK0LAnLCfRiNCw0L3QsdC1J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfRj9C60YgnLCfQtNGD0YgnLCfRgdC10YgnLCfRh9C+0YAnLCfQv9Cw0L0nLCfSt9GD0LwnLCfRiNCw0L0nXSxcblx0XHRkYXlOYW1lc01pbjogWyfQr9C6Jywn0JTRiCcsJ9Ch0YgnLCfQp9GIJywn0J/RiCcsJ9K20LwnLCfQqNC9J10sXG5cdFx0d2Vla0hlYWRlcjogJ9Cl0YQnLFxuXHRcdGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdFx0eWVhclN1ZmZpeDogJyd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWyd0aiddKTtcbn0pO1xuXG4vKiBUZXR1bSAoVVRGLTgpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgQWxleGFuZHJ1IENhcnRhbGVhbnUgKGFjYXJ0YWxlYW51QGRldmVsb3BtZW50Z2F0ZXdheS5vcmcpLiAqL1xuLyogTE9DQUwgQU1QIENPREUgLS0gVEhJUyBXSUxMIERJU0FQUEVBUiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3RtJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAnSGFsbycsXG5cdFx0cHJldlRleHQ6ICdVbHVrJyxcblx0XHRuZXh0VGV4dDogJ1R1aXIgbWFpJyxcblx0XHRjdXJyZW50VGV4dDogJ09oaW4gbG9yb24nLFxuXHRcdG1vbnRoTmFtZXM6IFsnSmFuZWlydScsJ0ZldnJlaXJ1JywnTWFyc3UnLCdBYnJpbCcsJ01haXUnLCdKdW5odScsXG5cdFx0J0p1bGh1JywnQWdvc3R1JywnU2VwdGVtYnJ1JywnT3R1YnJ1JywnTm92ZW1icnUnLCdEZXpyZW1icnUnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZldicsICdNYXInLCAnQWJyJywgJ01haScsICdKdW4nLFxuXHRcdCdKdWwnLCAnQWdvJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RleiddLFxuXHRcdGRheU5hbWVzOiBbJ0R1bWluZ3UnLCAnU2VndW5kYScsICdUZXJzYScsICdLdWFydGEnLCAnS2ludGEnLCAnU2VzdGEnLCAnU2FiYWR1J10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWydEdW0nLCAnU2VnJywgJ1RlcicsICdLcnQnLCAnS2luJywgJ1NlcycsICdTYWInXSxcblx0XHRkYXlOYW1lc01pbjogWydEbScsJ1NnJywnVHInLCdLdCcsJ0tuJywnU3MnLCdTYiddLFxuXHRcdHdlZWtIZWFkZXI6ICdTbScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3RtJ10pO1xufSk7XG4vKiBUdXJraXNoIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgSXp6ZXQgRW1yZSBFcmthbiAoa2FyYUBrYXJhbGFtYWxhci5uZXQpLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3RyJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAna2FwYXQnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7Z2VyaScsXG5cdFx0bmV4dFRleHQ6ICdpbGVyaSYjeDNlJyxcblx0XHRjdXJyZW50VGV4dDogJ2J1Z8O8bicsXG5cdFx0bW9udGhOYW1lczogWydPY2FrJywnxZ51YmF0JywnTWFydCcsJ05pc2FuJywnTWF5xLFzJywnSGF6aXJhbicsXG5cdFx0J1RlbW11eicsJ0HEn3VzdG9zJywnRXlsw7xsJywnRWtpbScsJ0thc8SxbScsJ0FyYWzEsWsnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnT2NhJywnxZ51YicsJ01hcicsJ05pcycsJ01heScsJ0hheicsXG5cdFx0J1RlbScsJ0HEn3UnLCdFeWwnLCdFa2knLCdLYXMnLCdBcmEnXSxcblx0XHRkYXlOYW1lczogWydQYXphcicsJ1BhemFydGVzaScsJ1NhbMSxJywnw4dhcsWfYW1iYScsJ1BlcsWfZW1iZScsJ0N1bWEnLCdDdW1hcnRlc2knXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ1B6JywnUHQnLCdTYScsJ8OHYScsJ1BlJywnQ3UnLCdDdCddLFxuXHRcdGRheU5hbWVzTWluOiBbJ1B6JywnUHQnLCdTYScsJ8OHYScsJ1BlJywnQ3UnLCdDdCddLFxuXHRcdHdlZWtIZWFkZXI6ICdIZicsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkLm1tLnl5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3RyJ10pO1xufSk7XG5cbi8qIFVrcmFpbmlhbiAoVVRGLTgpIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgTWF4aW0gRHJvZ29iaXRza2l5IChtYXhkYW9AZ21haWwuY29tKS4gKi9cbi8qIENvcnJlY3RlZCBieSBJZ29yIE1pbGxhIChpZ29yLmZzcC5taWxsYUBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3VrJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn0JfQsNC60YDQuNGC0LgnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7Jyxcblx0XHRuZXh0VGV4dDogJyYjeDNFOycsXG5cdFx0Y3VycmVudFRleHQ6ICfQodGM0L7Qs9C+0LTQvdGWJyxcblx0XHRtb250aE5hbWVzOiBbJ9Ch0ZbRh9C10L3RjCcsJ9Cb0Y7RgtC40LknLCfQkdC10YDQtdC30LXQvdGMJywn0JrQstGW0YLQtdC90YwnLCfQotGA0LDQstC10L3RjCcsJ9Cn0LXRgNCy0LXQvdGMJyxcblx0XHQn0JvQuNC/0LXQvdGMJywn0KHQtdGA0L/QtdC90YwnLCfQktC10YDQtdGB0LXQvdGMJywn0JbQvtCy0YLQtdC90YwnLCfQm9C40YHRgtC+0L/QsNC0Jywn0JPRgNGD0LTQtdC90YwnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn0KHRltGHJywn0JvRjtGCJywn0JHQtdGAJywn0JrQstGWJywn0KLRgNCwJywn0KfQtdGAJyxcblx0XHQn0JvQuNC/Jywn0KHQtdGAJywn0JLQtdGAJywn0JbQvtCyJywn0JvQuNGBJywn0JPRgNGDJ10sXG5cdFx0ZGF5TmFtZXM6IFsn0L3QtdC00ZbQu9GPJywn0L/QvtC90LXQtNGW0LvQvtC6Jywn0LLRltCy0YLQvtGA0L7QuicsJ9GB0LXRgNC10LTQsCcsJ9GH0LXRgtCy0LXRgCcsJ9C/4oCZ0Y/RgtC90LjRhtGPJywn0YHRg9Cx0L7RgtCwJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyfQvdC10LQnLCfQv9C90LQnLCfQstGW0LInLCfRgdGA0LQnLCfRh9GC0LInLCfQv9GC0L0nLCfRgdCx0YInXSxcblx0XHRkYXlOYW1lc01pbjogWyfQndC0Jywn0J/QvScsJ9CS0YInLCfQodGAJywn0KfRgicsJ9Cf0YInLCfQodCxJ10sXG5cdFx0d2Vla0hlYWRlcjogJ9Ci0LjQticsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMSxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3VrJ10pO1xufSk7XG5cbi8qIFZpZXRuYW1lc2UgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogVHJhbnNsYXRlZCBieSBMZSBUaGFuaCBIdXkgKGx0aGFuaGh1eUBjaXQuY3R1LmVkdS52bikuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsndmknXSA9IHtcblx0XHRjbG9zZVRleHQ6ICfEkMOzbmcnLFxuXHRcdHByZXZUZXh0OiAnJiN4M0M7VHLGsOG7m2MnLFxuXHRcdG5leHRUZXh0OiAnVGnhur9wJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ0jDtG0gbmF5Jyxcblx0XHRtb250aE5hbWVzOiBbJ1Row6FuZyBN4buZdCcsICdUaMOhbmcgSGFpJywgJ1Row6FuZyBCYScsICdUaMOhbmcgVMawJywgJ1Row6FuZyBOxINtJywgJ1Row6FuZyBTw6F1Jyxcblx0XHQnVGjDoW5nIELhuqN5JywgJ1Row6FuZyBUw6FtJywgJ1Row6FuZyBDaMOtbicsICdUaMOhbmcgTcaw4budaScsICdUaMOhbmcgTcaw4budaSBN4buZdCcsICdUaMOhbmcgTcaw4budaSBIYWknXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnVGjDoW5nIDEnLCAnVGjDoW5nIDInLCAnVGjDoW5nIDMnLCAnVGjDoW5nIDQnLCAnVGjDoW5nIDUnLCAnVGjDoW5nIDYnLFxuXHRcdCdUaMOhbmcgNycsICdUaMOhbmcgOCcsICdUaMOhbmcgOScsICdUaMOhbmcgMTAnLCAnVGjDoW5nIDExJywgJ1Row6FuZyAxMiddLFxuXHRcdGRheU5hbWVzOiBbJ0No4bunIE5o4bqtdCcsICdUaOG7qSBIYWknLCAnVGjhu6kgQmEnLCAnVGjhu6kgVMawJywgJ1Ro4bupIE7Eg20nLCAnVGjhu6kgU8OhdScsICdUaOG7qSBC4bqjeSddLFxuXHRcdGRheU5hbWVzU2hvcnQ6IFsnQ04nLCAnVDInLCAnVDMnLCAnVDQnLCAnVDUnLCAnVDYnLCAnVDcnXSxcblx0XHRkYXlOYW1lc01pbjogWydDTicsICdUMicsICdUMycsICdUNCcsICdUNScsICdUNicsICdUNyddLFxuXHRcdHdlZWtIZWFkZXI6ICdUdScsXG5cdFx0ZGF0ZUZvcm1hdDogJ2RkL21tL3l5Jyxcblx0XHRmaXJzdERheTogMCxcblx0XHRpc1JUTDogZmFsc2UsXG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblx0XHR5ZWFyU3VmZml4OiAnJ307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3ZpJ10pO1xufSk7XG5cbi8qIENoaW5lc2UgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBDbG91ZHJlYW0gKGNsb3VkcmVhbUBnbWFpbC5jb20pLiAqL1xualF1ZXJ5KGZ1bmN0aW9uKCQpe1xuXHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3poLUNOJ10gPSB7XG5cdFx0Y2xvc2VUZXh0OiAn5YWz6ZetJyxcblx0XHRwcmV2VGV4dDogJyYjeDNDO+S4iuaciCcsXG5cdFx0bmV4dFRleHQ6ICfkuIvmnIgmI3gzRTsnLFxuXHRcdGN1cnJlbnRUZXh0OiAn5LuK5aSpJyxcblx0XHRtb250aE5hbWVzOiBbJ+S4gOaciCcsJ+S6jOaciCcsJ+S4ieaciCcsJ+Wbm+aciCcsJ+S6lOaciCcsJ+WFreaciCcsXG5cdFx0J+S4g+aciCcsJ+WFq+aciCcsJ+S5neaciCcsJ+WNgeaciCcsJ+WNgeS4gOaciCcsJ+WNgeS6jOaciCddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyfkuIDmnIgnLCfkuozmnIgnLCfkuInmnIgnLCflm5vmnIgnLCfkupTmnIgnLCflha3mnIgnLFxuXHRcdCfkuIPmnIgnLCflhavmnIgnLCfkuZ3mnIgnLCfljYHmnIgnLCfljYHkuIDmnIgnLCfljYHkuozmnIgnXSxcblx0XHRkYXlOYW1lczogWyfmmJ/mnJ/ml6UnLCfmmJ/mnJ/kuIAnLCfmmJ/mnJ/kuownLCfmmJ/mnJ/kuIknLCfmmJ/mnJ/lm5snLCfmmJ/mnJ/kupQnLCfmmJ/mnJ/lha0nXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ+WRqOaXpScsJ+WRqOS4gCcsJ+WRqOS6jCcsJ+WRqOS4iScsJ+WRqOWbmycsJ+WRqOS6lCcsJ+WRqOWFrSddLFxuXHRcdGRheU5hbWVzTWluOiBbJ+aXpScsJ+S4gCcsJ+S6jCcsJ+S4iScsJ+WbmycsJ+S6lCcsJ+WFrSddLFxuXHRcdHdlZWtIZWFkZXI6ICflkagnLFxuXHRcdGRhdGVGb3JtYXQ6ICd5eS1tbS1kZCcsXG5cdFx0Zmlyc3REYXk6IDEsXG5cdFx0aXNSVEw6IGZhbHNlLFxuXHRcdHNob3dNb250aEFmdGVyWWVhcjogdHJ1ZSxcblx0XHR5ZWFyU3VmZml4OiAn5bm0J307XG5cdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbJ3poLUNOJ10pO1xufSk7XG5cbi8qIENoaW5lc2UgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBTQ0NZIChzYW11ZWxjeWNoYW5AZ21haWwuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWyd6aC1ISyddID0ge1xuXHRcdGNsb3NlVGV4dDogJ+mXnOmWiScsXG5cdFx0cHJldlRleHQ6ICcmI3gzQzvkuIrmnIgnLFxuXHRcdG5leHRUZXh0OiAn5LiL5pyIJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ+S7iuWkqScsXG5cdFx0bW9udGhOYW1lczogWyfkuIDmnIgnLCfkuozmnIgnLCfkuInmnIgnLCflm5vmnIgnLCfkupTmnIgnLCflha3mnIgnLFxuXHRcdCfkuIPmnIgnLCflhavmnIgnLCfkuZ3mnIgnLCfljYHmnIgnLCfljYHkuIDmnIgnLCfljYHkuozmnIgnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn5LiA5pyIJywn5LqM5pyIJywn5LiJ5pyIJywn5Zub5pyIJywn5LqU5pyIJywn5YWt5pyIJyxcblx0XHQn5LiD5pyIJywn5YWr5pyIJywn5Lmd5pyIJywn5Y2B5pyIJywn5Y2B5LiA5pyIJywn5Y2B5LqM5pyIJ10sXG5cdFx0ZGF5TmFtZXM6IFsn5pif5pyf5pelJywn5pif5pyf5LiAJywn5pif5pyf5LqMJywn5pif5pyf5LiJJywn5pif5pyf5ZubJywn5pif5pyf5LqUJywn5pif5pyf5YWtJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyflkajml6UnLCflkajkuIAnLCflkajkuownLCflkajkuIknLCflkajlm5snLCflkajkupQnLCflkajlha0nXSxcblx0XHRkYXlOYW1lc01pbjogWyfml6UnLCfkuIAnLCfkuownLCfkuIknLCflm5snLCfkupQnLCflha0nXSxcblx0XHR3ZWVrSGVhZGVyOiAn5ZGoJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQtbW0teXknLFxuXHRcdGZpcnN0RGF5OiAwLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IHRydWUsXG5cdFx0eWVhclN1ZmZpeDogJ+W5tCd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWyd6aC1ISyddKTtcbn0pO1xuXG4vKiBDaGluZXNlIGluaXRpYWxpc2F0aW9uIGZvciB0aGUgalF1ZXJ5IFVJIGRhdGUgcGlja2VyIHBsdWdpbi4gKi9cbi8qIFdyaXR0ZW4gYnkgUmVzc29sIChyZXNzb2xAZ21haWwuY29tKS4gKi9cbmpRdWVyeShmdW5jdGlvbigkKXtcblx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsWyd6aC1UVyddID0ge1xuXHRcdGNsb3NlVGV4dDogJ+mXnOmWiScsXG5cdFx0cHJldlRleHQ6ICcmI3gzQzvkuIrmnIgnLFxuXHRcdG5leHRUZXh0OiAn5LiL5pyIJiN4M0U7Jyxcblx0XHRjdXJyZW50VGV4dDogJ+S7iuWkqScsXG5cdFx0bW9udGhOYW1lczogWyfkuIDmnIgnLCfkuozmnIgnLCfkuInmnIgnLCflm5vmnIgnLCfkupTmnIgnLCflha3mnIgnLFxuXHRcdCfkuIPmnIgnLCflhavmnIgnLCfkuZ3mnIgnLCfljYHmnIgnLCfljYHkuIDmnIgnLCfljYHkuozmnIgnXSxcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsn5LiA5pyIJywn5LqM5pyIJywn5LiJ5pyIJywn5Zub5pyIJywn5LqU5pyIJywn5YWt5pyIJyxcblx0XHQn5LiD5pyIJywn5YWr5pyIJywn5Lmd5pyIJywn5Y2B5pyIJywn5Y2B5LiA5pyIJywn5Y2B5LqM5pyIJ10sXG5cdFx0ZGF5TmFtZXM6IFsn5pif5pyf5pelJywn5pif5pyf5LiAJywn5pif5pyf5LqMJywn5pif5pyf5LiJJywn5pif5pyf5ZubJywn5pif5pyf5LqUJywn5pif5pyf5YWtJ10sXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyflkajml6UnLCflkajkuIAnLCflkajkuownLCflkajkuIknLCflkajlm5snLCflkajkupQnLCflkajlha0nXSxcblx0XHRkYXlOYW1lc01pbjogWyfml6UnLCfkuIAnLCfkuownLCfkuIknLCflm5snLCfkupQnLCflha0nXSxcblx0XHR3ZWVrSGVhZGVyOiAn5ZGoJyxcblx0XHRkYXRlRm9ybWF0OiAneXkvbW0vZGQnLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IHRydWUsXG5cdFx0eWVhclN1ZmZpeDogJ+W5tCd9O1xuXHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoJC5kYXRlcGlja2VyLnJlZ2lvbmFsWyd6aC1UVyddKTtcbn0pO1xuXG5cbi8qIEVuZ2xpc2gvRU4gaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBTdHVhcnQuICovXG5qUXVlcnkoZnVuY3Rpb24oJCl7XG5cdCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZW4nXSA9IHtcblx0XHRjbG9zZVRleHQ6ICdEb25lJyxcblx0XHRwcmV2VGV4dDogJ1ByZXYnLFxuXHRcdG5leHRUZXh0OiAnTmV4dCcsXG5cdFx0Y3VycmVudFRleHQ6ICdUb2RheScsXG5cdFx0bW9udGhOYW1lczogWydKYW51YXJ5JywnRmVicnVhcnknLCdNYXJjaCcsJ0FwcmlsJywnTWF5JywnSnVuZScsXG5cdFx0J0p1bHknLCdBdWd1c3QnLCdTZXB0ZW1iZXInLCdPY3RvYmVyJywnTm92ZW1iZXInLCdEZWNlbWJlciddLFxuXHRcdG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsXG5cdFx0J0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG5cdFx0ZGF5TmFtZXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcblx0XHRkYXlOYW1lc1Nob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuXHRcdGRheU5hbWVzTWluOiBbJ1N1JywnTW8nLCdUdScsJ1dlJywnVGgnLCdGcicsJ1NhJ10sXG5cdFx0d2Vla0hlYWRlcjogJ1drJyxcblx0XHRkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuXHRcdGZpcnN0RGF5OiAxLFxuXHRcdGlzUlRMOiBmYWxzZSxcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXHRcdHllYXJTdWZmaXg6ICcnfTtcblx0JC5kYXRlcGlja2VyLnNldERlZmF1bHRzKCQuZGF0ZXBpY2tlci5yZWdpb25hbFsnZW4tR0InXSk7XG59KTsiLCIvKlxuXG4kLkxpbmsgKHBhcnQgb2Ygbm9VaVNsaWRlcikgLSBXVEZQTCAqL1xuKGZ1bmN0aW9uKGMpe2Z1bmN0aW9uIG0oYSxjLGQpe2lmKChhW2NdfHxhW2RdKSYmYVtjXT09PWFbZF0pdGhyb3cgRXJyb3IoXCIoTGluaykgJ1wiK2MrXCInIGNhbid0IG1hdGNoICdcIitkK1wiJy4nXCIpO31mdW5jdGlvbiByKGEpe3ZvaWQgMD09PWEmJihhPXt9KTtpZihcIm9iamVjdFwiIT09dHlwZW9mIGEpdGhyb3cgRXJyb3IoXCIoRm9ybWF0KSAnZm9ybWF0JyBvcHRpb24gbXVzdCBiZSBhbiBvYmplY3QuXCIpO3ZhciBoPXt9O2ModSkuZWFjaChmdW5jdGlvbihjLG4pe2lmKHZvaWQgMD09PWFbbl0paFtuXT1BW2NdO2Vsc2UgaWYodHlwZW9mIGFbbl09PT10eXBlb2YgQVtjXSl7aWYoXCJkZWNpbWFsc1wiPT09biYmKDA+YVtuXXx8NzxhW25dKSl0aHJvdyBFcnJvcihcIihGb3JtYXQpICdmb3JtYXQuZGVjaW1hbHMnIG9wdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgNy5cIik7aFtuXT1hW25dfWVsc2UgdGhyb3cgRXJyb3IoXCIoRm9ybWF0KSAnZm9ybWF0LlwiK24rXCInIG11c3QgYmUgYSBcIit0eXBlb2YgQVtjXStcblwiLlwiKTt9KTttKGgsXCJtYXJrXCIsXCJ0aG91c2FuZFwiKTttKGgsXCJwcmVmaXhcIixcIm5lZ2F0aXZlXCIpO20oaCxcInByZWZpeFwiLFwibmVnYXRpdmVCZWZvcmVcIik7dGhpcy5yPWh9ZnVuY3Rpb24gayhhLGgpe1wib2JqZWN0XCIhPT10eXBlb2YgYSYmYy5lcnJvcihcIihMaW5rKSBJbml0aWFsaXplIHdpdGggYW4gb2JqZWN0LlwiKTtyZXR1cm4gbmV3IGsucHJvdG90eXBlLnAoYS50YXJnZXR8fGZ1bmN0aW9uKCl7fSxhLm1ldGhvZCxhLmZvcm1hdHx8e30saCl9dmFyIHU9XCJkZWNpbWFscyBtYXJrIHRob3VzYW5kIHByZWZpeCBwb3N0Zml4IGVuY29kZXIgZGVjb2RlciBuZWdhdGl2ZSBuZWdhdGl2ZUJlZm9yZSB0byBmcm9tXCIuc3BsaXQoXCIgXCIpLEE9WzIsXCIuXCIsXCJcIixcIlwiLFwiXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGF9LGZ1bmN0aW9uKGEpe3JldHVybiBhfSxcIi1cIixcIlwiLGZ1bmN0aW9uKGEpe3JldHVybiBhfSxmdW5jdGlvbihhKXtyZXR1cm4gYX1dO3IucHJvdG90eXBlLmE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuclthXX07XG5yLnByb3RvdHlwZS5MPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIGEuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIil9YT10aGlzLmEoXCJlbmNvZGVyXCIpKGEpO3ZhciBkPXRoaXMuYShcImRlY2ltYWxzXCIpLG49XCJcIixrPVwiXCIsbT1cIlwiLHI9XCJcIjswPT09cGFyc2VGbG9hdChhLnRvRml4ZWQoZCkpJiYoYT1cIjBcIik7MD5hJiYobj10aGlzLmEoXCJuZWdhdGl2ZVwiKSxrPXRoaXMuYShcIm5lZ2F0aXZlQmVmb3JlXCIpKTthPU1hdGguYWJzKGEpLnRvRml4ZWQoZCkudG9TdHJpbmcoKTthPWEuc3BsaXQoXCIuXCIpO3RoaXMuYShcInRob3VzYW5kXCIpPyhtPWMoYVswXSkubWF0Y2goLy57MSwzfS9nKSxtPWMobS5qb2luKGModGhpcy5hKFwidGhvdXNhbmRcIikpKSkpOm09YVswXTt0aGlzLmEoXCJtYXJrXCIpJiYxPGEubGVuZ3RoJiYocj10aGlzLmEoXCJtYXJrXCIpK2FbMV0pO3JldHVybiB0aGlzLmEoXCJ0b1wiKShrK3RoaXMuYShcInByZWZpeFwiKStuK20rcit0aGlzLmEoXCJwb3N0Zml4XCIpKX07ci5wcm90b3R5cGUudz1cbmZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIGEucmVwbGFjZSgvW1xcLVxcL1xcXFxcXF4kKis/LigpfFxcW1xcXXt9XS9nLFwiXFxcXCQmXCIpfXZhciBkO2lmKG51bGw9PT1hfHx2b2lkIDA9PT1hKXJldHVybiExO2E9dGhpcy5hKFwiZnJvbVwiKShhKTthPWEudG9TdHJpbmcoKTtkPWEucmVwbGFjZShSZWdFeHAoXCJeXCIrYyh0aGlzLmEoXCJuZWdhdGl2ZUJlZm9yZVwiKSkpLFwiXCIpO2EhPT1kPyhhPWQsZD1cIi1cIik6ZD1cIlwiO2E9YS5yZXBsYWNlKFJlZ0V4cChcIl5cIitjKHRoaXMuYShcInByZWZpeFwiKSkpLFwiXCIpO3RoaXMuYShcIm5lZ2F0aXZlXCIpJiYoZD1cIlwiLGE9YS5yZXBsYWNlKFJlZ0V4cChcIl5cIitjKHRoaXMuYShcIm5lZ2F0aXZlXCIpKSksXCItXCIpKTthPWEucmVwbGFjZShSZWdFeHAoYyh0aGlzLmEoXCJwb3N0Zml4XCIpKStcIiRcIiksXCJcIikucmVwbGFjZShSZWdFeHAoYyh0aGlzLmEoXCJ0aG91c2FuZFwiKSksXCJnXCIpLFwiXCIpLnJlcGxhY2UodGhpcy5hKFwibWFya1wiKSxcIi5cIik7YT10aGlzLmEoXCJkZWNvZGVyXCIpKHBhcnNlRmxvYXQoZCtcbmEpKTtyZXR1cm4gaXNOYU4oYSk/ITE6YX07ay5wcm90b3R5cGUuSz1mdW5jdGlvbihhLGgpe3RoaXMubWV0aG9kPWh8fFwiaHRtbFwiO3RoaXMuaj1jKGEucmVwbGFjZShcIi10b29sdGlwLVwiLFwiXCIpfHxcIjxkaXYvPlwiKVswXX07ay5wcm90b3R5cGUuSD1mdW5jdGlvbihhKXt0aGlzLm1ldGhvZD1cInZhbFwiO3RoaXMuaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7dGhpcy5qLm5hbWU9YTt0aGlzLmoudHlwZT1cImhpZGRlblwifTtrLnByb3RvdHlwZS5HPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGgoYSxjKXtyZXR1cm5bYz9udWxsOmEsYz9hOm51bGxdfXZhciBkPXRoaXM7dGhpcy5tZXRob2Q9XCJ2YWxcIjt0aGlzLnRhcmdldD1hLm9uKFwiY2hhbmdlXCIsZnVuY3Rpb24oYSl7ZC5CLnZhbChoKGMoYS50YXJnZXQpLnZhbCgpLGQudCkse2xpbms6ZCxzZXQ6ITB9KX0pfTtrLnByb3RvdHlwZS5wPWZ1bmN0aW9uKGEsaCxkLGspe3RoaXMuZz1kO3RoaXMudXBkYXRlPSFrO2lmKFwic3RyaW5nXCI9PT1cbnR5cGVvZiBhJiYwPT09YS5pbmRleE9mKFwiLXRvb2x0aXAtXCIpKXRoaXMuSyhhLGgpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhJiYwIT09YS5pbmRleE9mKFwiLVwiKSl0aGlzLkgoYSk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSl0aGlzLnRhcmdldD0hMSx0aGlzLm1ldGhvZD1hO2Vsc2V7aWYoYSBpbnN0YW5jZW9mIGN8fGMuemVwdG8mJmMuemVwdG8uaXNaKGEpKXtpZighaCl7aWYoYS5pcyhcImlucHV0LCBzZWxlY3QsIHRleHRhcmVhXCIpKXt0aGlzLkcoYSk7cmV0dXJufWg9XCJodG1sXCJ9aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGh8fFwic3RyaW5nXCI9PT10eXBlb2YgaCYmYVtoXSl7dGhpcy5tZXRob2Q9aDt0aGlzLnRhcmdldD1hO3JldHVybn19dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCIoTGluaykgSW52YWxpZCBMaW5rLlwiKTt9fTtrLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihhLGMsZCxrKXtpZighdGhpcy51cGRhdGV8fCExIT09aylpZih0aGlzLnU9YSx0aGlzLkY9YT1cbnRoaXMuZm9ybWF0KGEpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiB0aGlzLm1ldGhvZCl0aGlzLm1ldGhvZC5jYWxsKHRoaXMudGFyZ2V0WzBdfHxkWzBdLGEsYyxkKTtlbHNlIHRoaXMudGFyZ2V0W3RoaXMubWV0aG9kXShhLGMsZCl9O2sucHJvdG90eXBlLnE9ZnVuY3Rpb24oYSl7dGhpcy5nPW5ldyByKGMuZXh0ZW5kKHt9LGEsdGhpcy5nIGluc3RhbmNlb2Ygcj90aGlzLmcucjp0aGlzLmcpKX07ay5wcm90b3R5cGUuSj1mdW5jdGlvbihhKXt0aGlzLkI9YX07ay5wcm90b3R5cGUuST1mdW5jdGlvbihhKXt0aGlzLnQ9YX07ay5wcm90b3R5cGUuZm9ybWF0PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmcuTChhKX07ay5wcm90b3R5cGUuQT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nLncoYSl9O2sucHJvdG90eXBlLnAucHJvdG90eXBlPWsucHJvdG90eXBlO2MuTGluaz1rfSkod2luZG93LmpRdWVyeXx8d2luZG93LlplcHRvKTsvKlxuXG4kLmZuLm5vVWlTbGlkZXIgLSBXVEZQTCAtIHJlZnJlc2hsZXNzLmNvbS9ub3Vpc2xpZGVyLyAqL1xuKGZ1bmN0aW9uKGMpe2Z1bmN0aW9uIG0oZSl7cmV0dXJuXCJudW1iZXJcIj09PXR5cGVvZiBlJiYhaXNOYU4oZSkmJmlzRmluaXRlKGUpfWZ1bmN0aW9uIHIoZSl7cmV0dXJuIGMuaXNBcnJheShlKT9lOltlXX1mdW5jdGlvbiBrKGUsYil7ZS5hZGRDbGFzcyhiKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5yZW1vdmVDbGFzcyhiKX0sMzAwKX1mdW5jdGlvbiB1KGUsYil7cmV0dXJuIDEwMCpiLyhlWzFdLWVbMF0pfWZ1bmN0aW9uIEEoZSxiKXtpZihiPj1lLmQuc2xpY2UoLTEpWzBdKXJldHVybiAxMDA7Zm9yKHZhciBhPTEsYyxmLGQ7Yj49ZS5kW2FdOylhKys7Yz1lLmRbYS0xXTtmPWUuZFthXTtkPWUuY1thLTFdO2M9W2MsZl07cmV0dXJuIGQrdShjLDA+Y1swXT9iK01hdGguYWJzKGNbMF0pOmItY1swXSkvKDEwMC8oZS5jW2FdLWQpKX1mdW5jdGlvbiBhKGUsYil7aWYoMTAwPD1iKXJldHVybiBlLmQuc2xpY2UoLTEpWzBdO2Zvcih2YXIgYT0xLGMsZixkO2I+PWUuY1thXTspYSsrO2M9XG5lLmRbYS0xXTtmPWUuZFthXTtkPWUuY1thLTFdO2M9W2MsZl07cmV0dXJuIDEwMC8oZS5jW2FdLWQpKihiLWQpKihjWzFdLWNbMF0pLzEwMCtjWzBdfWZ1bmN0aW9uIGgoYSxiKXtmb3IodmFyIGM9MSxnOyhhLmRpcj8xMDAtYjpiKT49YS5jW2NdOyljKys7aWYoYS5tKXJldHVybiBnPWEuY1tjLTFdLGM9YS5jW2NdLGItZz4oYy1nKS8yP2M6ZzthLmhbYy0xXT8oZz1hLmhbYy0xXSxjPWEuY1tjLTFdK01hdGgucm91bmQoKGItYS5jW2MtMV0pL2cpKmcpOmM9YjtyZXR1cm4gY31mdW5jdGlvbiBkKGEsYil7aWYoIW0oYikpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnc3RlcCcgaXMgbm90IG51bWVyaWMuXCIpO2EuaFswXT1ifWZ1bmN0aW9uIG4oYSxiKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGJ8fGMuaXNBcnJheShiKSl0aHJvdyBFcnJvcihcIm5vVWlTbGlkZXI6ICdyYW5nZScgaXMgbm90IGFuIG9iamVjdC5cIik7aWYodm9pZCAwPT09Yi5taW58fHZvaWQgMD09PWIubWF4KXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogTWlzc2luZyAnbWluJyBvciAnbWF4JyBpbiAncmFuZ2UnLlwiKTtcbmMuZWFjaChiLGZ1bmN0aW9uKGIsZyl7dmFyIGQ7XCJudW1iZXJcIj09PXR5cGVvZiBnJiYoZz1bZ10pO2lmKCFjLmlzQXJyYXkoZykpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAncmFuZ2UnIGNvbnRhaW5zIGludmFsaWQgdmFsdWUuXCIpO2Q9XCJtaW5cIj09PWI/MDpcIm1heFwiPT09Yj8xMDA6cGFyc2VGbG9hdChiKTtpZighbShkKXx8IW0oZ1swXSkpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAncmFuZ2UnIHZhbHVlIGlzbid0IG51bWVyaWMuXCIpO2EuYy5wdXNoKGQpO2EuZC5wdXNoKGdbMF0pO2Q/YS5oLnB1c2goaXNOYU4oZ1sxXSk/ITE6Z1sxXSk6aXNOYU4oZ1sxXSl8fChhLmhbMF09Z1sxXSl9KTtjLmVhY2goYS5oLGZ1bmN0aW9uKGIsYyl7aWYoIWMpcmV0dXJuITA7YS5oW2JdPXUoW2EuZFtiXSxhLmRbYisxXV0sYykvKDEwMC8oYS5jW2IrMV0tYS5jW2JdKSl9KX1mdW5jdGlvbiBFKGEsYil7XCJudW1iZXJcIj09PXR5cGVvZiBiJiYoYj1bYl0pO2lmKCFjLmlzQXJyYXkoYil8fCFiLmxlbmd0aHx8XG4yPGIubGVuZ3RoKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ3N0YXJ0JyBvcHRpb24gaXMgaW5jb3JyZWN0LlwiKTthLmI9Yi5sZW5ndGg7YS5zdGFydD1ifWZ1bmN0aW9uIEkoYSxiKXthLm09YjtpZihcImJvb2xlYW5cIiE9PXR5cGVvZiBiKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ3NuYXAnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7fWZ1bmN0aW9uIEooYSxiKXtpZihcImxvd2VyXCI9PT1iJiYxPT09YS5iKWEuaT0xO2Vsc2UgaWYoXCJ1cHBlclwiPT09YiYmMT09PWEuYilhLmk9MjtlbHNlIGlmKCEwPT09YiYmMj09PWEuYilhLmk9MztlbHNlIGlmKCExPT09YilhLmk9MDtlbHNlIHRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ2Nvbm5lY3QnIG9wdGlvbiBkb2Vzbid0IG1hdGNoIGhhbmRsZSBjb3VudC5cIik7fWZ1bmN0aW9uIEQoYSxiKXtzd2l0Y2goYil7Y2FzZSBcImhvcml6b250YWxcIjphLms9MDticmVhaztjYXNlIFwidmVydGljYWxcIjphLms9MTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ29yaWVudGF0aW9uJyBvcHRpb24gaXMgaW52YWxpZC5cIik7XG59fWZ1bmN0aW9uIEsoYSxiKXtpZigyPGEuYy5sZW5ndGgpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnbWFyZ2luJyBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgb24gbGluZWFyIHNsaWRlcnMuXCIpO2EubWFyZ2luPXUoYS5kLGIpO2lmKCFtKGIpKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ21hcmdpbicgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7fWZ1bmN0aW9uIEwoYSxiKXtzd2l0Y2goYil7Y2FzZSBcImx0clwiOmEuZGlyPTA7YnJlYWs7Y2FzZSBcInJ0bFwiOmEuZGlyPTE7YS5pPVswLDIsMSwzXVthLmldO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnZGlyZWN0aW9uJyBvcHRpb24gd2FzIG5vdCByZWNvZ25pemVkLlwiKTt9fWZ1bmN0aW9uIE0oYSxiKXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGIpdGhyb3cgRXJyb3IoXCJub1VpU2xpZGVyOiAnYmVoYXZpb3VyJyBtdXN0IGJlIGEgc3RyaW5nIGNvbnRhaW5pbmcgb3B0aW9ucy5cIik7dmFyIGM9MDw9Yi5pbmRleE9mKFwic25hcFwiKTtcbmEubj17czowPD1iLmluZGV4T2YoXCJ0YXBcIil8fGMsZXh0ZW5kOjA8PWIuaW5kZXhPZihcImV4dGVuZFwiKSx2OjA8PWIuaW5kZXhPZihcImRyYWdcIiksZml4ZWQ6MDw9Yi5pbmRleE9mKFwiZml4ZWRcIiksbTpjfX1mdW5jdGlvbiBOKGEsYixkKXthLm89W2IubG93ZXIsYi51cHBlcl07YS5nPWIuZm9ybWF0O2MuZWFjaChhLm8sZnVuY3Rpb24oYSxlKXtpZighYy5pc0FycmF5KGUpKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ3NlcmlhbGl6YXRpb24uXCIrKGE/XCJ1cHBlclwiOlwibG93ZXJcIikrXCInIG11c3QgYmUgYW4gYXJyYXkuXCIpO2MuZWFjaChlLGZ1bmN0aW9uKCl7aWYoISh0aGlzIGluc3RhbmNlb2YgYy5MaW5rKSl0aHJvdyBFcnJvcihcIm5vVWlTbGlkZXI6ICdzZXJpYWxpemF0aW9uLlwiKyhhP1widXBwZXJcIjpcImxvd2VyXCIpK1wiJyBjYW4gb25seSBjb250YWluIExpbmsgaW5zdGFuY2VzLlwiKTt0aGlzLkkoYSk7dGhpcy5KKGQpO3RoaXMucShiLmZvcm1hdCl9KX0pO2EuZGlyJiYxPGEuYiYmYS5vLnJldmVyc2UoKX1cbmZ1bmN0aW9uIE8oYSxiKXt2YXIgZj17YzpbXSxkOltdLGg6WyExXSxtYXJnaW46MH0sZztnPXtzdGVwOntlOiExLGY6ZH0sc3RhcnQ6e2U6ITAsZjpFfSxjb25uZWN0OntlOiEwLGY6Sn0sZGlyZWN0aW9uOntlOiEwLGY6TH0scmFuZ2U6e2U6ITAsZjpufSxzbmFwOntlOiExLGY6SX0sb3JpZW50YXRpb246e2U6ITEsZjpEfSxtYXJnaW46e2U6ITEsZjpLfSxiZWhhdmlvdXI6e2U6ITAsZjpNfSxzZXJpYWxpemF0aW9uOntlOiEwLGY6Tn19O2E9Yy5leHRlbmQoe2Nvbm5lY3Q6ITEsZGlyZWN0aW9uOlwibHRyXCIsYmVoYXZpb3VyOlwidGFwXCIsb3JpZW50YXRpb246XCJob3Jpem9udGFsXCJ9LGEpO2Euc2VyaWFsaXphdGlvbj1jLmV4dGVuZCh7bG93ZXI6W10sdXBwZXI6W10sZm9ybWF0Ont9fSxhLnNlcmlhbGl6YXRpb24pO2MuZWFjaChnLGZ1bmN0aW9uKGMsZCl7aWYodm9pZCAwPT09YVtjXSl7aWYoZC5lKXRocm93IEVycm9yKFwibm9VaVNsaWRlcjogJ1wiK2MrXCInIGlzIHJlcXVpcmVkLlwiKTtcbnJldHVybiEwfWQuZihmLGFbY10sYil9KTtmLnN0eWxlPWYuaz9cInRvcFwiOlwibGVmdFwiO3JldHVybiBmfWZ1bmN0aW9uIFAoYSxiKXt2YXIgZD1jKFwiPGRpdj48ZGl2Lz48L2Rpdj5cIikuYWRkQ2xhc3MoZlsyXSksZz1bXCItbG93ZXJcIixcIi11cHBlclwiXTthLmRpciYmZy5yZXZlcnNlKCk7ZC5jaGlsZHJlbigpLmFkZENsYXNzKGZbM10rXCIgXCIrZlszXStnW2JdKTtyZXR1cm4gZH1mdW5jdGlvbiBRKGEsYil7Yi5qJiYoYj1uZXcgYy5MaW5rKHt0YXJnZXQ6YyhiLmopLmNsb25lKCkuYXBwZW5kVG8oYSksbWV0aG9kOmIubWV0aG9kLGZvcm1hdDpiLmd9LCEwKSk7cmV0dXJuIGJ9ZnVuY3Rpb24gUihhLGIpe3ZhciBkLGY9W107Zm9yKGQ9MDtkPGEuYjtkKyspe3ZhciBrPWYsaD1kLG09YS5vW2RdLG49YltkXS5jaGlsZHJlbigpLHI9YS5nLHM9dm9pZCAwLHY9W10scz1uZXcgYy5MaW5rKHt9LCEwKTtzLnEocik7di5wdXNoKHMpO2ZvcihzPTA7czxtLmxlbmd0aDtzKyspdi5wdXNoKFEobixtW3NdKSk7XG5rW2hdPXZ9cmV0dXJuIGZ9ZnVuY3Rpb24gUyhhLGIsYyl7c3dpdGNoKGEpe2Nhc2UgMTpiLmFkZENsYXNzKGZbN10pO2NbMF0uYWRkQ2xhc3MoZls2XSk7YnJlYWs7Y2FzZSAzOmNbMV0uYWRkQ2xhc3MoZls2XSk7Y2FzZSAyOmNbMF0uYWRkQ2xhc3MoZls3XSk7Y2FzZSAwOmIuYWRkQ2xhc3MoZls2XSl9fWZ1bmN0aW9uIFQoYSxiKXt2YXIgYyxkPVtdO2ZvcihjPTA7YzxhLmI7YysrKWQucHVzaChQKGEsYykuYXBwZW5kVG8oYikpO3JldHVybiBkfWZ1bmN0aW9uIFUoYSxiKXtiLmFkZENsYXNzKFtmWzBdLGZbOCthLmRpcl0sZls0K2Eua11dLmpvaW4oXCIgXCIpKTtyZXR1cm4gYyhcIjxkaXYvPlwiKS5hcHBlbmRUbyhiKS5hZGRDbGFzcyhmWzFdKX1mdW5jdGlvbiBWKGQsYixtKXtmdW5jdGlvbiBnKCl7cmV0dXJuIHRbW1wid2lkdGhcIixcImhlaWdodFwiXVtiLmtdXSgpfWZ1bmN0aW9uIG4oYSl7dmFyIGIsYz1bcS52YWwoKV07Zm9yKGI9MDtiPGEubGVuZ3RoO2IrKylxLnRyaWdnZXIoYVtiXSxcbmMpfWZ1bmN0aW9uIHUoZCxwLGUpe3ZhciBnPWRbMF0hPT1sWzBdWzBdPzE6MCxIPXhbMF0rYi5tYXJnaW4saz14WzFdLWIubWFyZ2luO2UmJjE8bC5sZW5ndGgmJihwPWc/TWF0aC5tYXgocCxIKTpNYXRoLm1pbihwLGspKTsxMDA+cCYmKHA9aChiLHApKTtwPU1hdGgubWF4KE1hdGgubWluKHBhcnNlRmxvYXQocC50b0ZpeGVkKDcpKSwxMDApLDApO2lmKHA9PT14W2ddKXJldHVybiAxPT09bC5sZW5ndGg/ITE6cD09PUh8fHA9PT1rPzA6ITE7ZC5jc3MoYi5zdHlsZSxwK1wiJVwiKTtkLmlzKFwiOmZpcnN0LWNoaWxkXCIpJiZkLnRvZ2dsZUNsYXNzKGZbMTddLDUwPHApO3hbZ109cDtiLmRpciYmKHA9MTAwLXApO2MoeVtnXSkuZWFjaChmdW5jdGlvbigpe3RoaXMud3JpdGUoYShiLHApLGQuY2hpbGRyZW4oKSxxKX0pO3JldHVybiEwfWZ1bmN0aW9uIEIoYSxiLGMpe2N8fGsocSxmWzE0XSk7dShhLGIsITEpO24oW1wic2xpZGVcIixcInNldFwiLFwiY2hhbmdlXCJdKX1mdW5jdGlvbiB3KGEsYyxkLGUpe2E9XG5hLnJlcGxhY2UoL1xccy9nLFwiLm51aSBcIikrXCIubnVpXCI7Yy5vbihhLGZ1bmN0aW9uKGEpe3ZhciBjPXEuYXR0cihcImRpc2FibGVkXCIpO2lmKHEuaGFzQ2xhc3MoZlsxNF0pfHx2b2lkIDAhPT1jJiZudWxsIT09YylyZXR1cm4hMTthLnByZXZlbnREZWZhdWx0KCk7dmFyIGM9MD09PWEudHlwZS5pbmRleE9mKFwidG91Y2hcIikscD0wPT09YS50eXBlLmluZGV4T2YoXCJtb3VzZVwiKSxGPTA9PT1hLnR5cGUuaW5kZXhPZihcInBvaW50ZXJcIiksZyxrLGw9YTswPT09YS50eXBlLmluZGV4T2YoXCJNU1BvaW50ZXJcIikmJihGPSEwKTthLm9yaWdpbmFsRXZlbnQmJihhPWEub3JpZ2luYWxFdmVudCk7YyYmKGc9YS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCxrPWEuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkpO2lmKHB8fEYpRnx8dm9pZCAwIT09d2luZG93LnBhZ2VYT2Zmc2V0fHwod2luZG93LnBhZ2VYT2Zmc2V0PWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LHdpbmRvdy5wYWdlWU9mZnNldD1cbmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApLGc9YS5jbGllbnRYK3dpbmRvdy5wYWdlWE9mZnNldCxrPWEuY2xpZW50WSt3aW5kb3cucGFnZVlPZmZzZXQ7bC5DPVtnLGtdO2wuY3Vyc29yPXA7YT1sO2EubD1hLkNbYi5rXTtkKGEsZSl9KX1mdW5jdGlvbiBDKGEsYyl7dmFyIGI9Yy5ifHxsLGQsZT0hMSxlPTEwMCooYS5sLWMuc3RhcnQpL2coKSxmPWJbMF1bMF0hPT1sWzBdWzBdPzE6MDt2YXIgaz1jLkQ7ZD1lK2tbMF07ZSs9a1sxXTsxPGIubGVuZ3RoPygwPmQmJihlKz1NYXRoLmFicyhkKSksMTAwPGUmJihkLT1lLTEwMCksZD1bTWF0aC5tYXgoTWF0aC5taW4oZCwxMDApLDApLE1hdGgubWF4KE1hdGgubWluKGUsMTAwKSwwKV0pOmQ9W2QsZV07ZT11KGJbMF0sZFtmXSwxPT09Yi5sZW5ndGgpOzE8Yi5sZW5ndGgmJihlPXUoYlsxXSxkW2Y/MDoxXSwhMSl8fGUpO2UmJm4oW1wic2xpZGVcIl0pfWZ1bmN0aW9uIHMoYSl7YyhcIi5cIitmWzE1XSkucmVtb3ZlQ2xhc3MoZlsxNV0pO1xuYS5jdXJzb3ImJmMoXCJib2R5XCIpLmNzcyhcImN1cnNvclwiLFwiXCIpLm9mZihcIi5udWlcIik7Ry5vZmYoXCIubnVpXCIpO3EucmVtb3ZlQ2xhc3MoZlsxMl0pO24oW1wic2V0XCIsXCJjaGFuZ2VcIl0pfWZ1bmN0aW9uIHYoYSxiKXsxPT09Yi5iLmxlbmd0aCYmYi5iWzBdLmNoaWxkcmVuKCkuYWRkQ2xhc3MoZlsxNV0pO2Euc3RvcFByb3BhZ2F0aW9uKCk7dyh6Lm1vdmUsRyxDLHtzdGFydDphLmwsYjpiLmIsRDpbeFswXSx4W2wubGVuZ3RoLTFdXX0pO3coei5lbmQsRyxzLG51bGwpO2EuY3Vyc29yJiYoYyhcImJvZHlcIikuY3NzKFwiY3Vyc29yXCIsYyhhLnRhcmdldCkuY3NzKFwiY3Vyc29yXCIpKSwxPGwubGVuZ3RoJiZxLmFkZENsYXNzKGZbMTJdKSxjKFwiYm9keVwiKS5vbihcInNlbGVjdHN0YXJ0Lm51aVwiLCExKSl9ZnVuY3Rpb24gRChhKXt2YXIgZD1hLmwsZT0wO2Euc3RvcFByb3BhZ2F0aW9uKCk7Yy5lYWNoKGwsZnVuY3Rpb24oKXtlKz10aGlzLm9mZnNldCgpW2Iuc3R5bGVdfSk7ZT1kPGUvMnx8MT09PWwubGVuZ3RoP1xuMDoxO2QtPXQub2Zmc2V0KClbYi5zdHlsZV07ZD0xMDAqZC9nKCk7QihsW2VdLGQsYi5uLm0pO2Iubi5tJiZ2KGEse2I6W2xbZV1dfSl9ZnVuY3Rpb24gRShhKXt2YXIgYz0oYT1hLmw8dC5vZmZzZXQoKVtiLnN0eWxlXSk/MDoxMDA7YT1hPzA6bC5sZW5ndGgtMTtCKGxbYV0sYywhMSl9dmFyIHE9YyhkKSx4PVstMSwtMV0sdCx5LGw7aWYocS5oYXNDbGFzcyhmWzBdKSl0aHJvdyBFcnJvcihcIlNsaWRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC5cIik7dD1VKGIscSk7bD1UKGIsdCk7eT1SKGIsbCk7UyhiLmkscSxsKTsoZnVuY3Rpb24oYSl7dmFyIGI7aWYoIWEuZml4ZWQpZm9yKGI9MDtiPGwubGVuZ3RoO2IrKyl3KHouc3RhcnQsbFtiXS5jaGlsZHJlbigpLHYse2I6W2xbYl1dfSk7YS5zJiZ3KHouc3RhcnQsdCxELHtiOmx9KTthLmV4dGVuZCYmKHEuYWRkQ2xhc3MoZlsxNl0pLGEucyYmdyh6LnN0YXJ0LHEsRSx7YjpsfSkpO2EudiYmKGI9dC5maW5kKFwiLlwiK2ZbN10pLmFkZENsYXNzKGZbMTBdKSxcbmEuZml4ZWQmJihiPWIuYWRkKHQuY2hpbGRyZW4oKS5ub3QoYikuY2hpbGRyZW4oKSkpLHcoei5zdGFydCxiLHYse2I6bH0pKX0pKGIubik7ZC52U2V0PWZ1bmN0aW9uKCl7dmFyIGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApLGQsZSxnLGgsbSxzLHQ9cihhWzBdKTtcIm9iamVjdFwiPT09dHlwZW9mIGFbMV0/KGQ9YVsxXS5zZXQsZT1hWzFdLmxpbmssZz1hWzFdLnVwZGF0ZSxoPWFbMV0uYW5pbWF0ZSk6ITA9PT1hWzFdJiYoZD0hMCk7Yi5kaXImJjE8Yi5iJiZ0LnJldmVyc2UoKTtoJiZrKHEsZlsxNF0pO2E9MTxsLmxlbmd0aD8zOjE7MT09PXQubGVuZ3RoJiYoYT0xKTtmb3IobT0wO208YTttKyspaD1lfHx5W20lMl1bMF0saD1oLkEodFttJTJdKSwhMSE9PWgmJihoPUEoYixoKSxiLmRpciYmKGg9MTAwLWgpLCEwIT09dShsW20lMl0saCwhMCkmJmMoeVttJTJdKS5lYWNoKGZ1bmN0aW9uKGEpe2lmKCFhKXJldHVybiBzPXRoaXMudSwhMDt0aGlzLndyaXRlKHMsXG5sW20lMl0uY2hpbGRyZW4oKSxxLGcpfSkpOyEwPT09ZCYmbihbXCJzZXRcIl0pO3JldHVybiB0aGlzfTtkLnZHZXQ9ZnVuY3Rpb24oKXt2YXIgYSxjPVtdO2ZvcihhPTA7YTxiLmI7YSsrKWNbYV09eVthXVswXS5GO3JldHVybiAxPT09Yy5sZW5ndGg/Y1swXTpiLmRpcj9jLnJldmVyc2UoKTpjfTtkLmRlc3Ryb3k9ZnVuY3Rpb24oKXtjLmVhY2goeSxmdW5jdGlvbigpe2MuZWFjaCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy50YXJnZXQmJnRoaXMudGFyZ2V0Lm9mZihcIi5udWlcIil9KX0pO2ModGhpcykub2ZmKFwiLm51aVwiKS5yZW1vdmVDbGFzcyhmLmpvaW4oXCIgXCIpKS5lbXB0eSgpO3JldHVybiBtfTtxLnZhbChiLnN0YXJ0KX1mdW5jdGlvbiBXKGEpe2lmKCF0aGlzLmxlbmd0aCl0aHJvdyBFcnJvcihcIm5vVWlTbGlkZXI6IENhbid0IGluaXRpYWxpemUgc2xpZGVyIG9uIGVtcHR5IHNlbGVjdGlvbi5cIik7dmFyIGI9TyhhLHRoaXMpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtWKHRoaXMsXG5iLGEpfSl9ZnVuY3Rpb24gWChhKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGI9Yyh0aGlzKS52YWwoKSxkPXRoaXMuZGVzdHJveSgpLGY9Yy5leHRlbmQoe30sZCxhKTtjKHRoaXMpLm5vVWlTbGlkZXIoZik7ZC5zdGFydD09PWYuc3RhcnQmJmModGhpcykudmFsKGIpfSl9ZnVuY3Rpb24gQigpe3JldHVybiB0aGlzWzBdW2FyZ3VtZW50cy5sZW5ndGg/XCJ2U2V0XCI6XCJ2R2V0XCJdLmFwcGx5KHRoaXNbMF0sYXJndW1lbnRzKX12YXIgRz1jKGRvY3VtZW50KSxDPWMuZm4udmFsLHo9d2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZD97c3RhcnQ6XCJwb2ludGVyZG93blwiLG1vdmU6XCJwb2ludGVybW92ZVwiLGVuZDpcInBvaW50ZXJ1cFwifTp3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ/e3N0YXJ0OlwiTVNQb2ludGVyRG93blwiLG1vdmU6XCJNU1BvaW50ZXJNb3ZlXCIsZW5kOlwiTVNQb2ludGVyVXBcIn06e3N0YXJ0OlwibW91c2Vkb3duIHRvdWNoc3RhcnRcIixtb3ZlOlwibW91c2Vtb3ZlIHRvdWNobW92ZVwiLFxuZW5kOlwibW91c2V1cCB0b3VjaGVuZFwifSxmPVwibm9VaS10YXJnZXQgbm9VaS1iYXNlIG5vVWktb3JpZ2luIG5vVWktaGFuZGxlIG5vVWktaG9yaXpvbnRhbCBub1VpLXZlcnRpY2FsIG5vVWktYmFja2dyb3VuZCBub1VpLWNvbm5lY3Qgbm9VaS1sdHIgbm9VaS1ydGwgbm9VaS1kcmFnYWJsZSAgbm9VaS1zdGF0ZS1kcmFnICBub1VpLXN0YXRlLXRhcCBub1VpLWFjdGl2ZSBub1VpLWV4dGVuZGVkIG5vVWktc3RhY2tpbmdcIi5zcGxpdChcIiBcIik7Yy5mbi52YWw9ZnVuY3Rpb24oKXt2YXIgYT1hcmd1bWVudHMsYj1jKHRoaXNbMF0pO3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMuZWFjaChmdW5jdGlvbigpeyhjKHRoaXMpLmhhc0NsYXNzKGZbMF0pP0I6QykuYXBwbHkoYyh0aGlzKSxhKX0pOihiLmhhc0NsYXNzKGZbMF0pP0I6QykuY2FsbChiKX07Yy5ub1VpU2xpZGVyPXtMaW5rOmMuTGlua307Yy5mbi5ub1VpU2xpZGVyPWZ1bmN0aW9uKGEsYil7cmV0dXJuKGI/WDpXKS5jYWxsKHRoaXMsXG5hKX19KSh3aW5kb3cualF1ZXJ5fHx3aW5kb3cuWmVwdG8pO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuXG4vLyBsb2FkaW5nIGhhY2tzXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG4vL2xvYWRpbmcganF1ZXJ5w5Egb25seSBsb2FkIGl0IGlmXG4vL2l0IGlzIG5vdCBsb2FkZWQgb3IgaWYgdGhlcmUgaXMgYSBqcXVlcnkgbG9hZGVkIGJ1dCB2ZXJzaW9uIGlzIG9sZGVyIHRoYW4gMi54LnhcbmlmICh3aW5kb3cuJCA9PSB1bmRlZmluZWQgfHwgJC5mbi5qcXVlcnkuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpWzBdIDwgMikge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBCYWNrYm9uZS4kID0galF1ZXJ5O1xufVxucmVxdWlyZSgnanF1ZXJ5LXVpL2RyYWdnYWJsZScpO1xucmVxdWlyZSgnYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwJyk7XG5yZXF1aXJlKCcuL2xpYi9qcXVlcnktdWktaTE4bicpXG5cbnZhciBGaWx0ZXJWaWV3ID0gcmVxdWlyZSgnLi92aWV3cy9maWx0ZXJzLXZpZXcnKTtcblxuLy8gc2VlIFJFQURNRS5tZCBmb3IgZG9jdW1lbnRhdGlvbiBvbiB1c2luZyB3aWRnZXQuXG5cblxuZnVuY3Rpb24gV2lkZ2V0KCkge1xuICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuXy5leHRlbmQoV2lkZ2V0LnByb3RvdHlwZSwgQmFja2JvbmUuRXZlbnRzLCB7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7IGRyYWdnYWJsZTogdHJ1ZSB9KTtcbiAgICBpZiAoXy5oYXMob3B0aW9ucywgJ3N5bmMnKSkge1xuICAgICAgQmFja2JvbmUuc3luYyA9IG9wdGlvbnMuc3luYztcbiAgICB9XG4gICAgdGhpcy52aWV3ID0gbmV3IEZpbHRlclZpZXcob3B0aW9ucyk7XG5cbiAgICAvLyB1c2VkIHRvIG1ha2UgYWxsIGZpbHRlcnMgcmVxdWVzdCBmYXN0ZXIuXG4gICAgdGhpcy5fY2FjaGVkQWxsRmlsdGVycyA9IG51bGw7XG5cbiAgICAvLyBsb2FkZWQgZGVmZXJyZWQgdG8gYWxsb3cgZm9yIG90aGVyIGNvZGUgdG8gd2FpdCBmb3IgZmlsdGVycyB0byBmaW5pc2ggbG9hZGluZy5cbiAgICB0aGlzLmxvYWRlZCA9IHRoaXMudmlldy5fbG9hZGVkLnByb21pc2UoKTtcblxuICAgIC8vIHByb3h5IGFsbCBmaWx0ZXIgZXZlbnRzIHRocm91Z2ggaGVyZVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy52aWV3LCAnYWxsJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9KTtcbiAgfSxcblxuICAvLyBwdXQgdGhlIGZpbHRlcnMgaW50byB0aGUgRE9NIHRyZWUgcG9zdC1pbml0aWFsaXphdGlvblxuICBzZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXcuc2V0RWxlbWVudChhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8vIHRoaXMgd2lsbCBzdGFzaCBjdXJyZW50IGZpbHRlciBzdGF0ZSwgc28gaXQgY2FuIGJlIHJlc3RvcmVkIG9uIGNhbmNlbC5cbiAgc2hvd0ZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudmlldy5zaG93RmlsdGVycygpO1xuICB9LFxuXG4gIHNldFN0YXNoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnZpZXcuc2V0U3Rhc2goKTtcbiAgfSxcblxuICAvLyByZXR1cm4gbW9kZWxzIG9mIGFsbCBmaWx0ZXJzLCBldmVuIHVuc2VsZWN0ZWQgb25lcy4uXG4gIGdldEFsbEZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5sb2FkZWQudGhlbihmdW5jdGlvbigpe1xuICAgICAgLy8gY2FjaGUsIGJlY2F1c2Ugd29uJ3QgY2hhbmdlLiBhdm9pZHMgY2FsbGluZyBzZXJpYWxpemUgZXZlcnl0aW1lLlxuICAgICAgaWYoIXRoaXMuX2NhY2hlZEFsbEZpbHRlcnMpe1xuICAgICAgICB0aGlzLl9jYWNoZWRBbGxGaWx0ZXJzID0gc2VsZi52aWV3LnNlcmlhbGl6ZSh7aW5jbHVkZVVuc2VsZWN0ZWQ6IHRydWUsIHdob2xlTW9kZWw6IHRydWV9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRBbGxGaWx0ZXJzO1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIHJldHVybiBtb2RlbHMgb2Ygc2VyaWFsaXplZCBmaWx0ZXIgc3RhdGUsIGhhcyBlbnRpcmUgbW9kZWxzIGluc3RlYWQgb2YganVzdCBpZHMuXG4gIHNlcmlhbGl6ZVRvTW9kZWxzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnNlcmlhbGl6ZSh7d2hvbGVNb2RlbDogdHJ1ZX0pO1xuICB9LFxuXG4gIGZvcm1hdERhdGU6IGZ1bmN0aW9uKGRhdGUpe1xuXHQgIHJldHVybiB0aGlzLnZpZXcuZm9ybWF0RGF0ZShkYXRlKTsgIFxuICB9LFxuICBcbiAgLy8gcmV0dXJuIGpzb24gYmxvYiBvZiBzZXJpYWxpemVkIGZpbHRlciBzdGF0ZSwgaWRzIG9ubHkuXG4gIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5zZXJpYWxpemUoe30pO1xuICB9LFxuXG4gIC8vIHJlc3RvcmVzIGZpbHRlciBzdGF0ZSBnaXZlbiBhIGpzb24gYmxvYiwgaWRzIG9ubHkuXG4gIGRlc2VyaWFsaXplOiBmdW5jdGlvbihzdGF0ZUJsb2IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmRlc2VyaWFsaXplKHN0YXRlQmxvYiwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgLy8gcmVzZXQgZmlsdGVycyB0byBlbXB0eSBzdGF0ZVxuICByZXNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMudmlldy5yZXNldEZpbHRlcnMoKTtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICB0aGlzLnZpZXcuYXBwbHlGaWx0ZXJzKCk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogc2VhcmNoZXMgdGhlIHNldHRpbmdzIGFycmF5IG9mIG1vZGVscyBmb3IgdGhlIG9uZXMgd2hpY2ggaG9sZCB0aGUgbWluL21heCB2YWx1ZXMgaW5zdHJ1Y3RlZCB0byBhbmQsIGlmIGZvdW5kLFxuICAgKiB3cml0ZXMgdGhlbSBpbiBmaWx0ZXJzT3V0Lm90aGVyRmlsdGVycy5kYXRlLntzdGFydH17ZW5kfVxuICAgKlxuICAgKiB1c2UgaXQgYXMgYW4gdXRpbGl0eSBmdW5jdGlvbiAoaXQgZG9lcyBub3QgcmVmZXJlbmNlICd0aGlzJywgc29cbiAgICogaXQgaXMgc2FmZSB0byB1c2UgaXQgYXQgYW55IHBvaW50IGluIHRoZSBsaWZlY3ljbGUgb2YgdGhlIHdpZGdldFxuICAgKi9cbiAgZXh0cmFjdERhdGVzOiBmdW5jdGlvbihzZXR0aW5ncywgZmlsdGVyc091dCwgbWluTmFtZSwgbWF4TmFtZSkge1xuICAgIGZpbHRlcnNPdXQub3RoZXJGaWx0ZXJzID0gZmlsdGVyc091dC5vdGhlckZpbHRlcnMgfHwge307XG4gICAgZmlsdGVyc091dC5vdGhlckZpbHRlcnMuZGF0ZSA9IGZpbHRlcnNPdXQub3RoZXJGaWx0ZXJzLmRhdGUgfHwge1xuICAgICAgICBzdGFydDogJycsXG4gICAgICAgIGVuZDogJydcbiAgICAgIH07XG5cbiAgICB2YXIgZGVmYXVsdE1pbkRhdGUgPSBfLmZpbmQoc2V0dGluZ3MsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmdldCgnaWQnKSA9PT0gbWluTmFtZTtcbiAgICB9KTtcbiAgICBpZiAoZGVmYXVsdE1pbkRhdGUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0TWluRGF0ZS5nZXQoJ25hbWUnKSAhPT0gJycpIHtcbiAgICAgIGZpbHRlcnNPdXQub3RoZXJGaWx0ZXJzLmRhdGUuc3RhcnQgPSBkZWZhdWx0TWluRGF0ZS5nZXQoJ25hbWUnKTtcbiAgICB9XG4gICAgdmFyIGRlZmF1bHRNYXhEYXRlID0gXy5maW5kKHNldHRpbmdzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5nZXQoJ2lkJykgPT09IG1heE5hbWU7XG4gICAgfSk7XG4gICAgaWYgKGRlZmF1bHRNYXhEYXRlICE9PSB1bmRlZmluZWQgJiYgZGVmYXVsdE1heERhdGUuZ2V0KCduYW1lJykgIT09ICcnKSB7XG4gICAgICBmaWx0ZXJzT3V0Lm90aGVyRmlsdGVycy5kYXRlLmVuZCA9IGRlZmF1bHRNYXhEYXRlLmdldCgnbmFtZScpO1xuICAgIH1cbiAgfVxuXG59KTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gV2lkZ2V0O1xuIiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxuICAvLyBQYXJlbnQgbW9kZWwgZm9yIGZpbHRlcnMuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gIGRlZmF1bHRzOiB7XG4gICAgbmFtZTogJ0ZpbHRlciBOYW1lJyxcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIHRvdGFsQ291bnQ6IDAsXG4gICAgYWN0aXZlQ291bnQ6IDAsXG4gICAgX2xvYWRlZDogZmFsc2UsXG4gICAgZW1wdHk6IGZhbHNlXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5zZXQoJ25hbWUnLCBvcHRpb25zLm5hbWUpO1xuICAgIHRoaXMuc2V0KCdncm91cCcsIG9wdGlvbnMuZ3JvdXAgfHwgb3B0aW9ucy5pZCk7XG4gICAgdGhpcy5zZXQoJ21ldGhvZCcsIG9wdGlvbnMubWV0aG9kKTtcbiAgICB0aGlzLnNldCgnY29sdW1ucycsIG9wdGlvbnMuY29sdW1ucyk7XG4gICAgdGhpcy5zZXQoJ2VtcHR5Jywgb3B0aW9ucy5lbXB0eSB8fCBmYWxzZSk7XG4gICAgdGhpcy51cmwgPSAgb3B0aW9ucy51cmwgfHwgb3B0aW9ucy5lbmRwb2ludDtcbiAgfVxuXG59KTtcbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG52YXIgQmFzZUZpbHRlck1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL2Jhc2UtZmlsdGVyLW1vZGVsJyk7XG52YXIgVHJlZU5vZGVNb2RlbCA9IHJlcXVpcmUoJy4uL3RyZWUvdHJlZS1ub2RlLW1vZGVsJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRmlsdGVyTW9kZWwuZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOmZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBCYXNlRmlsdGVyTW9kZWwucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICB0aGlzLnNldCgnbW9kZWxUeXBlJywgJ1RSRUUnKTtcbiAgICB0aGlzLmdldFRyZWUoKTsgLy8gc3RhcnRzIGdldFRyZWUgY2FsbHNcbiAgfSxcblxuICAvLyBsb2FkIHRyZWUgaWYgbmVlZGVkLCBlbHNlIHJldHVybiB3aGF0IHdlIGFscmVhZHkgaGF2ZS4uXG4gIGdldFRyZWU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbG9hZGVkID0gdGhpcy5nZXQoJ19sb2FkZWQnKTtcblxuICAgIGlmICghbG9hZGVkKSB7XG4gICAgICBzZWxmLnNldCgnX2xvYWRlZCcsIHRoaXMuX2NyZWF0ZVRyZWUoKS50aGVuKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHRyaWNrbGUgdXAgbnVtU2VsZWN0ZWQuXG4gICAgXHQgIGlmKHNlbGYuZ2V0KCd0cmVlJykhPSB1bmRlZmluZWQpe1xuICAgICAgICBzZWxmLmdldCgndHJlZScpLm9uKCdjaGFuZ2U6bnVtU2VsZWN0ZWQnLCBmdW5jdGlvbihtb2RlbCwgdmFsdWUpIHtcbiAgICAgICAgICBzZWxmLnNldCgnbnVtU2VsZWN0ZWQnLCB2YWx1ZSk7XG4gICAgICAgICAgc2VsZi5zZXQoJ251bVBvc3NpYmxlJywgc2VsZi5nZXQoJ3RyZWUnKS5nZXQoJ251bVBvc3NpYmxlJykpO1xuICAgICAgICB9KTtcbiAgICBcdCAgfVxuICAgICAgICByZXR1cm4gc2VsZi5nZXQoJ3RyZWUnKTtcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldCgnX2xvYWRlZCcpO1xuICB9LFxuXG4gIGdldE51bVNlbGVjdGVkOiBmdW5jdGlvbigpe1xuICAgIHZhciBudW1TZWxlY3RlZCA9IHRoaXMuZ2V0KCdudW1TZWxlY3RlZCcpO1xuICAgIC8vIGlmIG5vbmUgc2VsZWN0ZWQsIG9yIGFsbCBzZWxlY3RlZCwgdHJlYXQgdGhlIHNhbWUuXG4gICAgaWYgKCFudW1TZWxlY3RlZCB8fCB0aGlzLmdldCgnbnVtU2VsZWN0ZWQnKSA9PT0gdGhpcy5nZXQoJ251bVBvc3NpYmxlJykpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVtU2VsZWN0ZWQ7XG4gICAgfVxuICB9LFxuXG4gIHNlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciB0cmVlID0gdGhpcy5nZXQoJ3RyZWUnKTtcbiAgICBpZiAoIXRyZWUpIHtcbiAgICAgIC8vY29uc29sZS53YXJuKCdubyB0cmVlIGZvdW5kJywgdGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB7fTsgLy9ubyB0cmVlLCBub3RoaW5nIHRvIHNlcmlhbGl6ZS5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRtcEFyeSA9IHRyZWUuc2VyaWFsaXplKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRtcEFyeTtcbiAgICB9XG4gIH0sXG5cbiAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uKGxpc3RPZlNlbGVjdGVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0cmVlID0gdGhpcy5nZXQoJ3RyZWUnKTtcbiAgICBpZiAobGlzdE9mU2VsZWN0ZWQpIHtcbiAgICAgIGlmICghdHJlZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2Rlc2VyaWFsaXplIG5vIHRyZWUgZm91bmQnLCBzZWxmKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvL25vIHRyZWUsIG5vdGhpbmcgdG8gc2VyaWFsaXplLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJlZS5kZXNlcmlhbGl6ZShsaXN0T2ZTZWxlY3RlZCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHJlZSA9IHRoaXMuZ2V0KCd0cmVlJyk7XG4gICAgaWYgKHRyZWUpIHtcbiAgICAgIC8vIFRPRE86IGFkZCBhIHRoaXJkIHR5cGUgZm9yIHNlbWktZmlsbGVkXG4gICAgICAvLyBmb3JjZSB0cmlnZ2VyLCBiZWNhdXNlIG90aGVyd2lzZSBub2RlcyB0aGF0IGFyZSAnaGFsZi1maWxsZWQnIGJ1dCBmYWxzZSB3b24ndCByZWZyZXNoLlxuICAgICAgdHJlZS5zZXQoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICB0cmVlLnNldCgnc2VsZWN0ZWQnLCBmYWxzZSk7XG5cbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZVRyZWU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy51cmwpIHtcbiAgICAgIHRoaXMudXJsID0gdGhpcy5nZXQoJ2VuZHBvaW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmV0Y2goe1xuICAgICAgdHlwZTogdGhpcy5nZXQoJ21ldGhvZCcpLFxuICAgICAgZGF0YTone30nXG4gICAgfSlcbiAgICAuZmFpbChmdW5jdGlvbihqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBnZXQgZmlsdGVyICcsIGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgfSk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7ICAgIFxuXG4gICAgLy9pZiBpdCdzIGFuIG9iaiwgamFtIGl0IGludG8gYW4gYXJyYXkgZmlyc3QsIGhlbHBzIHNvbHZlIGluY29uc2lzdGFuY3kgaW4gQVBJIGZvcm1hdC5cbiAgICBpZiAoIV8uaXNBcnJheShkYXRhKSkge1xuICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc0FycmF5KGRhdGEpICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHJvb3ROb2RlT2JqID0gbnVsbDtcbiAgICAgIC8vIEJ1aWxkcyB0cmVlIG9mIHZpZXdzIGZyb20gcmV0dXJuZWQgZGF0YVxuICAgICAgLy8gSWYgZGF0YSBpcyBhIHNpbmdsZSBlbGVtZW50LCBqdXN0IG1ha2UgaXQgdGhlIHJvb3QuLlxuICAgICAgXG4gICAgICAvKiBUT0RPLUNPTlNUQU5USU46IHRlbXBvcmFyeSBjb21tZW50IHVudGlsIEkgZmluaXNoIGxlYXJuaW5nIEZpbHRlcnMgZnJvbnRlbmRcbiAgICAgIGNvbnNvbGUubG9nKFwiaXRlcmF0aW5nIFwiICsgZGF0YS5sZW5ndGggKyBcIiBlbGVtcy4uLlwiKTtcbiAgICAgIF8uZWFjaChkYXRhLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgXHQgIGNvbnNvbGUubG9nKFwiXFx0bmFtZSA9IFwiICsgZWxlbS5uYW1lICsgXCIsIGlkID0gXCIgKyBlbGVtLmlkKTtcbiAgICAgIH0pO1xuICAgICAgKi9cbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgIFx0aWYoZGF0YVswXS5maWx0ZXJJZCAmJiAhZGF0YVswXS5uYW1lKSB7XG4gICAgICAgICAgZGF0YVswXS5uYW1lID0gIGRhdGFbMF0uZmlsdGVySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZGF0YVswXS52YWx1ZXMpe1xuICAgICAgICAgIGRhdGFbMF0uY2hpbGRyZW4gPSAgZGF0YVswXS52YWx1ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhWzBdLmlzU2VsZWN0YWJsZSA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgLy9kYXRhWzBdLmZpbHRlck5hbWUgPSBkYXRhWzBdLmRpc3BsYXlOYW1lO1xuXG4gICAgICAgIHJvb3ROb2RlT2JqID0gZGF0YVswXTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdE5vZGVPYmogPSB7XG4gICAgICAgICAgaWQ6IC0xLFxuICAgICAgICAgIGNvZGU6ICctMScsXG4gICAgICAgICAgbmFtZTogc2VsZi5nZXQoJ25hbWUnKSxcbiAgICAgICAgICBjaGlsZHJlbjogZGF0YSxcbiAgICAgICAgICBzZWxlY3RlZDogdW5kZWZpbmVkLFxuICAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAgICAgICAgICBpc1NlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGNyZWF0ZVVua293bnM6IHRydWUvKixcbiAgICAgICAgICBmaWx0ZXJOYW1lOiBzZWxmLmdldCgnZGlzcGxheU5hbWUnKSovXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmVlTW9kZWwgPSBuZXcgVHJlZU5vZGVNb2RlbChyb290Tm9kZU9iaik7XG4gICAgICBzZWxmLnNldCgndHJlZScsIHRyZWVNb2RlbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbn0pO1xuXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgR2VuZXJpY0ZpbHRlck1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL2dlbmVyaWMtZmlsdGVyLW1vZGVsJyk7XG52YXIgVHJlZU5vZGVNb2RlbCA9IHJlcXVpcmUoJy4uL3RyZWUvdHJlZS1ub2RlLW1vZGVsJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBHZW5lcmljRmlsdGVyTW9kZWwuZXh0ZW5kKHtcblxuXG4gIGluaXRpYWxpemU6ZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMubG9hZGVkID0gJC5EZWZlcnJlZCgpO1xuICAgIHRoaXMuX2NyZWF0ZVRyZWUob3B0aW9ucy5kYXRhKTtcbiAgICBHZW5lcmljRmlsdGVyTW9kZWwucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgfSxcblxuICAvL29yZyBkb2Vzbid0IGhhdmUgYXN5bmMgcGFydCwgYnV0IHN0aWxsIHVzZSBkZWZlcnJlZCwgc28gYmVoYXZlcyBzYW1lIGFzIGdlbmVyaWMgZmlsdGVyIG1vZGVsXG4gIGdldFRyZWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlZDtcbiAgfSxcblxuICBfY3JlYXRlVHJlZTpmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByb290Tm9kZU9iaiA9IHt9O1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcm9vdE5vZGVPYmogPSBkYXRhWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290Tm9kZU9iaiA9IHtcbiAgICAgICAgaWQ6IC0xLFxuICAgICAgICBjb2RlOiAnLTEnLFxuICAgICAgICBuYW1lOiBzZWxmLmdldCgnZGlzcGxheU5hbWUnKSxcbiAgICAgICAgZmlsdGVySWQ6IHNlbGYuZ2V0KCdmaWx0ZXJJZCcpLFxuICAgICAgICBjaGlsZHJlbjogZGF0YSxcbiAgICAgICAgc2VsZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZXhwYW5kZWQ6IGZhbHNlLFxuICAgICAgICBpc1NlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBjcmVhdGVVbmtvd25zOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgdHJlZU1vZGVsID0gbmV3IFRyZWVOb2RlTW9kZWwocm9vdE5vZGVPYmopO1xuICAgIHRoaXMuc2V0KCd0cmVlJywgdHJlZU1vZGVsKTtcblxuICAgIC8vIHRyaWNrbGUgdXAgbnVtU2VsZWN0ZWQuXG4gICAgc2VsZi5nZXQoJ3RyZWUnKS5vbignY2hhbmdlOm51bVNlbGVjdGVkJywgZnVuY3Rpb24obW9kZWwsIHZhbHVlKSB7XG4gICAgICBzZWxmLnNldCgnbnVtU2VsZWN0ZWQnLCB2YWx1ZSk7XG4gICAgICBzZWxmLnNldCgnbnVtUG9zc2libGUnLCBzZWxmLmdldCgndHJlZScpLmdldCgnbnVtUG9zc2libGUnKSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxvYWRlZC5yZXNvbHZlKHRyZWVNb2RlbCk7XG4gIH1cblxufSk7XG5cbiIsInZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcblx0ZGVmYXVsdHMgOiB7XG5cdFx0aWQgOiBcIlwiLFxuXHRcdG11bHRpIDogXCJcIixcblx0XHRuYW1lIDogXCJcIixcblx0XHRkZWZhdWx0SWQgOiBcIlwiLFxuXHRcdG9wdGlvbnMgOiBbXVxuXHRcdFxuXHR9XG59KTsiLCJ2YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQmFzZUZpbHRlck1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWxzL2Jhc2UtZmlsdGVyLW1vZGVsJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRmlsdGVyTW9kZWwuZXh0ZW5kKHtcblxuXG4gIGRlZmF1bHRzOiB7XG4gICAgc2VsZWN0ZWRTdGFydDogbnVsbCxcbiAgICBzZWxlY3RlZEVuZDogbnVsbCxcbiAgICAvLyByYW5nZSBpcyBwcm92aWRlZCBieSBhcGksIGJ1dCB3aWxsIGZhbGxiYWNrIHRvIHRoaXMgaWYgbm90IHByb3ZpZGVkLCBvciBzZXQgdG8gLTFcbiAgICBzdGFydFllYXI6ICcnLFxuICAgIGVuZFllYXI6ICcnLFxuICAgIG1vZGVsVHlwZTogJ0RBVEUtUkFOR0UtVkFMVUVTJ1xuICB9LFxuICBcbiAgc3luYzogZnVuY3Rpb24gKCkge1xuXHQgIC8qKlxuXHQgICAqIGhhY2tpc2g6IHRoZSBkYXRhIGNvbWluZyBvZmYgdGhlIC9kYXRlcyBlbmRwb2ludCBzaG91bGQgYmUgaWdub3JlZCBhdCBhbGwgbW9tZW50cywgYmVjYXVzZVxuXHQgICAqIDEuIGZvciB0YWJzL3NhaWt1LCBpdCBzaG91bGQgYWx3YXlzIGJlIGVtcHR5XG5cdCAgICogMi4gZm9yIGdpcy9kYXNoYm9hcmRzLCBpdCBpcyBjb21pbmcgb2ZmIHRoZSAvc2V0dGluZyBlbmRwb2ludFxuXHQgICAqIFxuXHQgICAqIEFsbCB0aGUgb3RoZXIgeWVhcnMtZmlsdGVyLW1vZGVsIHNob3VsZCBieSBzcGVjIGJlIGFsd2F5cyBlbXB0eSBhdCB0aGlzIHBvaW50LiBJbiBjYXNlIHRoaXMgd291bGQgY2Vhc2UgdG8gYmUgdHJ1ZSBpbiB0aGUgZnV0dXJlLFxuXHQgICAqIGp1c3QgZmlsdGVyIGJ5IFwibmFtZVwiXG5cdCAgICovIFxuXHQgIFx0XG5cdCAgLy9jb25zb2xlLmVycm9yKCdTWU5DSU5HIFlFQVJTIE1PREVMOiAnICsgdGhpcy5nZXQoJ25hbWUnKSk7XG5cdCAgcmV0dXJuICQud2hlbih0cnVlKTtcbiAgfSxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgQmFzZUZpbHRlck1vZGVsLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLmVuZHBvaW50O1xuICAgIHRoaXMuc2V0KCdfbG9hZGVkJywgJC5EZWZlcnJlZCgpKTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oZGF0YSkge1xuXHQgIGNvbnNvbGUubG9nKCd5ZWFycy1maWx0ZXItbW9kZWwucGFyc2U6IGRhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIGlmICghZGF0YS5zdGFydFllYXIgfHwgZGF0YS5zdGFydFllYXIgPT09IC0xKSB7XG4gICAgICBkYXRhLnN0YXJ0WWVhciA9IHRoaXMuZGVmYXVsdHMuc3RhcnRZZWFyO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnN0YXJ0WWVhciA9IGRhdGEuc3RhcnRZZWFyICsgJy0wMS0wMSc7XG4gICAgfVxuICAgIGlmICghZGF0YS5lbmRZZWFyIHx8IGRhdGEuZW5kWWVhciA9PT0gLTEpIHtcbiAgICAgIGRhdGEuZW5kWWVhciA9IHRoaXMuZGVmYXVsdHMuZW5kWWVhcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5lbmRZZWFyID0gZGF0YS5lbmRZZWFyICsgJy0xMi0zMSc7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhLnNlbGVjdGVkU3RhcnQpIHtcbiAgICBcdC8vIGdvb2Qgb2xlJyBwYXJ0aWFsIGNvcHktcGFzdGUgb2ZmIHBvc3Rwcm9jZXNzKClcbiAgICBcdGRhdGEuc2VsZWN0ZWRTdGFydCA9IGRhdGEuc3RhcnRZZWFyO1xuICAgIFx0ZGF0YS5zZWxlY3RlZEVuZCA9IGRhdGEuZW5kWWVhcjtcbiAgICB9XG4gICAgdGhpcy5nZXQoJ19sb2FkZWQnKS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cbiAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0Ly8gQU1QLTIxMDQxOiBFbmFibGVkIGZpbHRlcmluZyBieSBzdGFydCBPUiBlbmQgZGF0ZS5cbiAgICBpZiAodGhpcy5nZXQoJ3NlbGVjdGVkU3RhcnQnKSB8fCB0aGlzLmdldCgnc2VsZWN0ZWRFbmQnKSkge1xuICAgIFx0ICB2YXIga2V5ID0gXy5maXJzdCh0aGlzLmdldCgnY29sdW1ucycpKSAhPSdOL0EnID8gXy5maXJzdCh0aGlzLmdldCgnY29sdW1ucycpKTogJ2RhdGUnO1xuICAgIFx0ICAvL2NvbnNvbGUubG9nKCdzZXJpYWxpemluZyB5ZWFycy1maWx0ZXItbW9kZWwgZm9yICcgKyBrZXkgKyAnLCBzdGFydCA9ICcgKyB0aGlzLmdldCgnc2VsZWN0ZWRTdGFydCcpICsgJywgZW5kID0gJyArIHRoaXMuZ2V0KCdzZWxlY3RlZEVuZCcpKTsgICAgXHQgIFxuICAgIFx0ICB2YXIgb2JqID0ge307XG4gICAgXHQgIG9ialtrZXldID0ge1xuXHRcdFx0XHQgIC8vc3RhcnQ6IHRoaXMuX2RhdGVDb252ZXJ0KHRoaXMuZ2V0KCdzZWxlY3RlZFN0YXJ0JykpLFxuXHRcdFx0XHQgIC8vZW5kOiB0aGlzLl9kYXRlQ29udmVydCh0aGlzLmdldCgnc2VsZWN0ZWRFbmQnKSlcblx0XHRcdFx0ICBzdGFydDogdGhpcy5nZXQoJ3NlbGVjdGVkU3RhcnQnKSxcblx0XHRcdFx0ICBlbmQ6IHRoaXMuZ2V0KCdzZWxlY3RlZEVuZCcpLFxuXHRcdFx0XHQgIG1vZGVsVHlwZTogdGhpcy5nZXQoJ21vZGVsVHlwZScpXG5cdFx0XHQgfTtcbiAgICBcdCAgcmV0dXJuIG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBwb3N0cHJvY2VzcyBtb2RlbCBhZnRlciBoYXZpbmcgZmV0Y2hlZCBkYXRhIGZyb20gdGhlIHNlcnZlclxuICAgKi9cbiAgcG9zdHByb2Nlc3M6IGZ1bmN0aW9uKCkge1xuXHQgIC8vIG9ubHkgc2V0IGlmIG5vdCBzZXQgYnkgZGVzZXJpYWxpemVcblx0ICBpZiAoIXRoaXMuZ2V0KCdzZWxlY3RlZFN0YXJ0JykpIHtcblx0ICBcdCAgdGhpcy5zZXQoJ3NlbGVjdGVkU3RhcnQnLCB0aGlzLmdldCgnc3RhcnRZZWFyJykpO1xuXHQgIH1cblx0ICAvLyBBTVAtMjEwNDE6IEVuYWJsZWQgZmlsdGVyaW5nIGJ5IHN0YXJ0IE9SIGVuZCBkYXRlLlxuICAgICAgaWYgKCF0aGlzLmdldCgnc2VsZWN0ZWRFbmQnKSkgeyAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgIHRoaXMuc2V0KCdzZWxlY3RlZEVuZCcsIHRoaXMuZ2V0KCdlbmRZZWFyJykpO1xuICAgICAgfVxuICB9LFxuICBcbiAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uKG9iaikge1xuXHR2YXIga2V5ID0gXy5maXJzdCh0aGlzLmdldCgnY29sdW1ucycpKSAhPSdOL0EnID8gXy5maXJzdCh0aGlzLmdldCgnY29sdW1ucycpKSA6ICdkYXRlJztcblx0aWYgKG9iaiAmJiBvYmpba2V5XSkge1xuXHQgIHRoaXMuc2V0KCdzZWxlY3RlZFN0YXJ0JywgdGhpcy5fZGF0ZUNvbnZlcnQob2JqW2tleV0uc3RhcnQpKTtcblx0ICB0aGlzLnNldCgnc2VsZWN0ZWRFbmQnLCB0aGlzLl9kYXRlQ29udmVydChvYmpba2V5XS5lbmQpKTtcbiAgICAgIHRoaXMucG9zdHByb2Nlc3MoKTtcblx0fWVsc2V7XG5cdFx0dGhpcy5zZXQoJ3NlbGVjdGVkU3RhcnQnLCB0aGlzLmdldCgnc3RhcnRZZWFyJykpO1xuXHQgICAgdGhpcy5zZXQoJ3NlbGVjdGVkRW5kJywgdGhpcy5nZXQoJ2VuZFllYXInKSk7XG5cdH1cbiAgfSxcblxuICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXQoJ3NlbGVjdGVkU3RhcnQnLCB0aGlzLmdldCgnc3RhcnRZZWFyJykpO1xuICAgIHRoaXMuc2V0KCdzZWxlY3RlZEVuZCcsIHRoaXMuZ2V0KCdlbmRZZWFyJykpO1xuICB9LFxuXG4gIC8vIGNvbnZlcnRzOiAwMy8wMS8xOTYxID09PiAxOTYxLTAxLTAxIElGIE5FRURFRC5cbiAgLy8gRE9FUyBOT1QgQ09OVkVSVCBmcm9tIHRoZSBcIi1cIiBmb3JtYXQgdG8gXCIvXCIgZm9ybWF0IGFueW1vcmVcbiAgLy8gXG4gIC8vIGFtcCBleHBlY3RzIHdpdGggJy0nIGFuZCBqUXVlcnkgd2FudHMgd2l0aCAnLydcbiAgX2RhdGVDb252ZXJ0OiBmdW5jdGlvbihpbnB1dCl7XG5cdCAgY29uc29sZS5sb2coJ2Fza2VkIHRvIGNvbnZlcnQgaW5wdXQ6ICcgKyBpbnB1dCk7XG4gICAgdmFyIG91dHB1dCA9IG51bGw7XG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuaW5kZXhPZignLycpPi0xKXtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zcGxpdCgnLycpO1xuICAgICAgICBvdXRwdXQgPSBpbnB1dFsyXSArICctJyArIGlucHV0WzFdICsgJy0nICsgaW5wdXRbMF07XG4gICAgICB9IGVsc2Uge1xuICAgIFx0ICBvdXRwdXQgPSBpbnB1dDtcbiAgICAgIH1cbiAgICAgIC8qIGVsc2UgaWYoaW5wdXQuaW5kZXhPZignLScpPi0xKXtcbiAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zcGxpdCgnLScpO1xuICAgICAgICBvdXRwdXQgPSBpbnB1dFsyXSArICcvJyArIGlucHV0WzFdICsgJy8nICsgaW5wdXRbMF07XG4gICAgICB9Ki9cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYXNlRmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvYmFzZS1maWx0ZXItbW9kZWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRmlsdGVyTW9kZWwuZXh0ZW5kKHtcblxuXHRkZWZhdWx0cyA6IHtcblx0XHRzZWxlY3RlZFllYXIgOiB1bmRlZmluZWQsXG5cdFx0ZGVmYXVsdFllYXIgOiB1bmRlZmluZWQsXG5cdFx0bW9kZWxUeXBlIDogJ1lFQVItU0lOR0xFLVZBTFVFJ1xuXHR9LFxuXG5cdGluaXRpYWxpemUgOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0QmFzZUZpbHRlck1vZGVsLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIFsgb3B0aW9ucyBdKTtcblx0XHR0aGlzLnVybCA9IG9wdGlvbnMuZW5kcG9pbnQ7XG5cdFx0dGhpcy5zZXQoJ19sb2FkZWQnLCAkLkRlZmVycmVkKCkpO1xuXHR9LFxuXG5cdHBhcnNlIDogZnVuY3Rpb24oZGF0YSkge1xuXHRcdGlmIChkYXRhICYmIGRhdGEudmFsdWUgJiYgZGF0YS52YWx1ZS5vcHRpb25zKSB7XG5cdFx0XHRkYXRhLmRlZmF1bHRZZWFyID0gXy5maW5kKGRhdGEudmFsdWUub3B0aW9ucywgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gaXRlbS5pZCA9PT0gZGF0YS52YWx1ZS5kZWZhdWx0SWQ7XG5cdFx0XHR9KS52YWx1ZTtcblx0XHR9XG5cdFx0Ly8gY29uc29sZS5sb2coZGF0YSk7XG5cdFx0dGhpcy5nZXQoJ19sb2FkZWQnKS5yZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH0sXG5cblx0c2VyaWFsaXplIDogZnVuY3Rpb24oKSB7XHRcblx0XHRpZiAodGhpcy5nZXQoJ3NlbGVjdGVkWWVhcicpKSB7XG5cdFx0XHR2YXIga2V5ID0gdGhpcy5nZXQoJ2lkJyk7XG5cdFx0XHR2YXIgb2JqID0ge307XG5cdFx0XHRvYmpba2V5XSA9IHtcblx0XHRcdFx0eWVhciA6IHRoaXMuZ2V0KCdzZWxlY3RlZFllYXInKSxcblx0XHRcdFx0bW9kZWxUeXBlIDogdGhpcy5nZXQoJ21vZGVsVHlwZScpLFxuXHRcdFx0XHRkaXNwbGF5TmFtZSA6IHRoaXMuZ2V0KCduYW1lJylcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0ZGVzZXJpYWxpemUgOiBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIga2V5ID0gdGhpcy5nZXQoJ2lkJyk7XG5cdFx0aWYgKG9iaiAmJiBvYmpba2V5XSkge1xuXHRcdFx0dGhpcy5zZXQoJ3NlbGVjdGVkWWVhcicsIG9ialtrZXldLnllYXIpO1xuXHRcdFx0dGhpcy5zZXQoJ2Rpc3BsYXlOYW1lJywgb2JqW2tleV0uZGlzcGxheU5hbWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlc2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zZXQoJ3NlbGVjdGVkWWVhcicsICcnKTtcblx0XHR0aGlzLnNldCgnZGlzcGxheU5hbWUnLCAnJylcblx0fSxcblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgVHJlZU5vZGVNb2RlbDsgLy8gZGVjbGFyZSBoZXJlIHRvIGhlbHAgd2l0aCByZWYgbG9vcCBvZiBjb2xsZWN0aW9uIGFuZCBtb2RlbFxudmFyIFRyZWVOb2RlQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHsgIG1vZGVsOlRyZWVOb2RlTW9kZWwgfSk7XG5cbi8vVE9ETzogcHJvcGFnYXRpb24gYnVnIGlmIG1pZCBsZXZlbCBub2RlIGlzIGhhbGYgZmlsbGVkIGFuZCB5b3UgJ2Rlc2VsZWN0IGFsbCcgaXQgd29uJ3QgcHJvcG9nYXRlIHRvIGNoaWxkcmVuLlxuXG5UcmVlTm9kZU1vZGVsID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgZGVmYXVsdHM6e1xuICAgIHNlbGVjdGVkOiB1bmRlZmluZWQsICAvLyBkZWZhdWx0IGlzIHNlbGVjdGVkLiBjaGFuZ2UgdG8gc3RyaW5nIC8gdGVybmFyeSwgZm9yIG9mZiwgc2VtaSwgYW5kIG9uXG4gICAgZXhwYW5kZWQ6IHRydWUsXG4gICAgdmlzaWJsZTogdHJ1ZSxcbiAgICBudW1TZWxlY3RlZDogMCxcbiAgICBudW1Qb3NzaWJsZTogMCxcbiAgICBjaGlsZHJlbjogbnVsbCwgICAgIC8vIHR5cGUgVHJlZU5vZGVDb2xsZWN0aW9uXG4gICAgaXNTZWxlY3RhYmxlOiBmYWxzZSAgLy8gaXMgdGhpcyBub2RlIGl0c2VsZiBzZWxlY3RhYmxlIChpZS4gc2hvdWxkIGl0IGhhdmUgYW4gJ3Vua293bicgY2hpbGQpXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoaWxkcmVuQ29sbGVjdGlvbiA9IG5ldyBUcmVlTm9kZUNvbGxlY3Rpb24oKTtcbiAgICB0aGlzLnNldCgnY2hpbGRyZW4nLCBjaGlsZHJlbkNvbGxlY3Rpb24pO1xuICAgIFxuICAgIC8qIFRPRE8tQ09OU1RBTlRJTjogdGVtcG9yYXJ5IGNvbW1lbnQgdW50aWwgSSBhbSBmaW5pc2hlZCBsZWFybmluZyBGaWx0ZXJzIGZyb250ZW5kIFxuICAgICBjb25zb2xlLmxvZyhcImJ1aWxkaW5nIGEgdHJlZSBub2RlIG1vZGVsIGZvcjogXCIgKyBKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICAgKi9cbiAgICBcbiAgICAvL2l0ZXJhdGUgb3ZlciBjaGlsZHJlblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5jaGlsZHJlbikpIHtcbiAgICAgIF8uZWFjaChvYmouY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHZhciBuZXdDaGlsZCA9IG5ldyBUcmVlTm9kZU1vZGVsKGNoaWxkKTtcbiAgICAgICAgY2hpbGRyZW5Db2xsZWN0aW9uLmFkZChuZXdDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGNoaWxkcmVuLCB0aGVuIGFkZCBzZWxmIGFzIGEgbGVhZiBub2RlLCAndW5rb3duJ1xuICAgIGlmICghY2hpbGRyZW5Db2xsZWN0aW9uLmlzRW1wdHkoKSAmJiAgdGhpcy5nZXQoJ2lzU2VsZWN0YWJsZScpKSB7XG4gICAgICB2YXIgdW5rb3duTm9kZSA9IG5ldyBUcmVlTm9kZU1vZGVsKHNlbGYudG9KU09OKCkpO1xuICAgICAgdW5rb3duTm9kZS5zZXQoJ25hbWUnLCAndW5rb3duOiAnICsgdGhpcy5nZXQoJ25hbWUnKSk7XG4gICAgICBjaGlsZHJlbkNvbGxlY3Rpb24uYWRkKHVua293bk5vZGUpO1xuICAgIH1cblxuICAgIHRoaXMuX2FkZExpc3RlbmVyc1RvQ2hpbGRyZW4oKTtcblxuICAgIHRoaXMub24oJ2NoYW5nZTpzZWxlY3RlZCcsIHNlbGYuX29uU2VsZWN0Q2hhbmdlKTtcblxuICAgIHRoaXMuX3VwZGF0ZUNvdW50KCk7XG4gIH0sXG5cblxuLy8gbWVyZ2UgYmFzZWQgb24gZmlsdGVySWQgYXMgd2Ugc2VyaWFsaXplLi4uLlxuLy8gb3B0aW9ucy53aG9sZU1vZGVsIHJldHVybnMgd2hvbGUgTW9kZWxzIGluc3RlYWQgb2YganVzdCBpZHNcbi8vIG9wdGlvbnMuaW5jbHVkZVVuc2VsZWN0ZWQgcmV0dXJucyBmdWxsIHRyZWUsIGV2ZW4gaWYgbm9kZXMgYXJlIG5vdCBzZWxlY3RlZC5cbi8vIENvZGUgZXhwbGljaXRseSBpZ25vcmVzIERvbm9yIEdyb3VwLERvbm9yIFR5cGUgYW5kIHRoZSByZXN0IG9mIHRoZSBvcmdhbml6YXRpb25zLlxuLy8gICB0aGV5IG9ubHkgaGF2ZSBGaWx0ZXJJZHMgZm9yIGRlc2VyaWFsaXplIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbi8vIFRPRE86IGNvbnNpZGVyIHB1bGxpbmcgb3V0IG9wdGlvbnMuaW5jbHVkZVVuc2VsZWN0ZWQgaW50byBpdHMgb3duIGZ1bmN0aW9uIGdldEFsbEZpbHRlcnMoKVxuc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgdmFyIHRtcFNlcmlhbGl6ZWQgPSB7fTtcblx0ICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldCgnY2hpbGRyZW4nKTtcblxuICAgIC8qKlxuXHQgICAgICAgIFxuXHQgICAgIFxuXHQgICstLV4tLS0tLS0tLS0tLC0tLS0tLS0tLC0tLS0tLC0tLS0tLS0tXi0sXG5cdCAgfCB8fHx8fHx8fHwgICBgLS0tLS0tLS0nICAgICB8ICAgICAgICAgIE9cblx0ICBgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLV4tLS0tLS0tLS0tfFxuXHQgICAgYFxcXywtLS0tLS0tLS0sLS0tLS0tLS0tLC0tLS0tLS0tLS0tLS0tJ1xuXHQgICAgICAvIFhYWFhYWCAvJ3wgICAgICAgLydcblx0ICAgICAvIFhYWFhYWCAvICBgXFwgICAgLycgICAgICAgICAgICAgICAgICAgICAgVE8gSU5WRVNUSUdBVEU6IHdoeSBpcyB0aGlzIGZ1bmN0aW9uIGNhbGxlZCBmb3IgNCB0aW1lcyAoISEhKSBwZXIgZWFjaCBpdGVtIHdoZW4gcHJlc3NpbmcgXCJhcHBseVwiP1xuXHQgICAgLyBYWFhYWFggL2AtLS0tLS0tJ1xuXHQgICAvIFhYWFhYWCAvXG5cdCAgLyBYWFhYWFggL1xuXHQgKF9fX19fX19fKCAgICAgICAgICAgICAgICBcblx0ICAgXG5cdCAgICBcblx0Ly8gXG5cdC8vICAgIGlmICgodGhpcy5nZXQoJ25hbWUnKT09ICdZZXMnKSB8fCAodGhpcy5nZXQoJ25hbWUnKSA9PSAnTm8nKSB8fCAodGhpcy5nZXQoJ25hbWUnKSA9PSAnQWxsJykgfHwgdGhpcy5nZXQoJ25hbWUnKSA9PSAnSHVtYW5pdGFyaWFuIEFpZCcgfHwgdGhpcy5nZXQoJ25hbWUnKSA9PSAnRGlzYXN0ZXIgUmVzcG9uc2UgTWFya2VyJykge1xuXHQvLyAgICBcdGNvbnNvbGUubG9nKCdzZXJpYWxpemluZyBub2RlIHdpdGggbmFtZSAnICsgdGhpcy5nZXQoJ25hbWUnKSArIFwiLCBzZWxlY3RlZDogXCIgKyB0aGlzLmdldCgnc2VsZWN0ZWQnKSk7XG5cdC8vXG5cdC8vICAgIFx0ZGVidWdnZXI7XG5cdC8vICAgIH1cblx0Ki9cbiAgICBcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlVW5zZWxlY3RlZCkge1xuICAgIFx0aWYgKHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICYmIHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICE9PSAnRG9ub3IgR3JvdXAnICYmIHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICE9PSAnRG9ub3IgVHlwZScgXG4gICAgXHRcdCYmIHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICE9PSAnSW1wbGVtZW50aW5nIEFnZW5jeScgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgIT09ICdCZW5lZmljaWFyeSBBZ2VuY3knICYmIHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICE9PSAnRXhlY3V0aW5nIEFnZW5jeScgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgIT09ICdSZXNwb25zaWJsZSBPcmdhbml6YXRpb24nKSB7XG4gICAgXHRcdFx0dG1wU2VyaWFsaXplZFt0aGlzLmdldCgnZmlsdGVySWQnKV0gPSAob3B0aW9ucy53aG9sZU1vZGVsPyBbdGhpc106W3RoaXMuaWRdKTtcbiAgICBcdH0gZWxzZXtcbiAgICBcdFx0dG1wU2VyaWFsaXplZC51bmFzc2lnbmVkID0gKG9wdGlvbnMud2hvbGVNb2RlbD8gW3RoaXNdOlt0aGlzLmlkXSk7XG4gICAgXHR9XG4gICAgXHR0aGlzLl9zZXJpYWxpemVDaGlsZHJlbih0bXBTZXJpYWxpemVkLCBjaGlsZHJlbiwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICBcdGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgXHRcdC8vIElmIGFsbCBjaGlsZHJlbiBhcmUgc2VsZWN0ZWQsIGFuZCB3ZSBoYXZlIG91ciBvd24gZmlsdGVySWQsIHRoZW4ganVzdCB1c2Ugb3VyIGlkLCBkb24ndCByZWN1cnNlLlxuICAgIFx0XHRpZiAodGhpcy5nZXQoJ251bVNlbGVjdGVkJykgPj0gdGhpcy5nZXQoJ251bVBvc3NpYmxlJykgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgIT09ICdEb25vciBHcm91cCcgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgIT09ICdEb25vciBUeXBlJyBcbiAgICBcdFx0XHQmJiB0aGlzLmdldCgnZmlsdGVySWQnKSAhPT0gJ0ltcGxlbWVudGluZyBBZ2VuY3knICYmIHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICE9PSAnQmVuZWZpY2lhcnkgQWdlbmN5JyAmJiB0aGlzLmdldCgnZmlsdGVySWQnKSAhPT0gJ0V4ZWN1dGluZyBBZ2VuY3knICYmIHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICE9PSAnUmVzcG9uc2libGUgT3JnYW5pemF0aW9uJykge1xuICAgIFx0XHRcdGlmICh0aGlzLmlkID09PSB1bmRlZmluZWQpIC8vIHRvcCBsZXZlbCBvZiBhIG5vbi1oaWVyYXJjaGljYWwgZ3JvdXAgKGxpa2UgdHlwZSBvZiBhc3Npc3RhbmNlKVxuICAgICAgIFx0XHRcdFx0dGhpcy5fc2VyaWFsaXplQ2hpbGRyZW4odG1wU2VyaWFsaXplZCwgY2hpbGRyZW4sIG9wdGlvbnMpO1xuICAgICAgICBcdFx0ZWxzZVxuICAgICAgICBcdFx0XHR0bXBTZXJpYWxpemVkW3RoaXMuZ2V0KCdmaWx0ZXJJZCcpXSA9IChvcHRpb25zLndob2xlTW9kZWw/IFt0aGlzXTpbdGhpcy5pZF0pO1xuICAgIFx0XHR9IGVsc2Uge1xuICAgIFx0XHRcdHRoaXMuX3NlcmlhbGl6ZUNoaWxkcmVuKHRtcFNlcmlhbGl6ZWQsIGNoaWxkcmVuLCBvcHRpb25zKTtcbiAgICBcdFx0fVxuICAgICAgfSBlbHNlIHtcbiAgICBcdCAgLy9ubyBjaGlsZHJlbiBzbyBqdXN0IHJldHVybiBzZWxmLlxuICAgIFx0ICBpZiAodGhpcy5nZXQoJ3NlbGVjdGVkJykpIHtcbiAgICBcdFx0ICBpZiAodGhpcy5nZXQoJ2ZpbHRlcklkJykgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgIT09ICdEb25vciBHcm91cCcgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgIT09ICdEb25vciBUeXBlJyBcbiAgICBcdFx0XHQgICYmIHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICE9PSAnSW1wbGVtZW50aW5nIEFnZW5jeScgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgIT09ICdCZW5lZmljaWFyeSBBZ2VuY3knICYmIHRoaXMuZ2V0KCdmaWx0ZXJJZCcpICE9PSAnRXhlY3V0aW5nIEFnZW5jeScgJiYgdGhpcy5nZXQoJ2ZpbHRlcklkJykgIT09ICdSZXNwb25zaWJsZSBPcmdhbml6YXRpb24nKSB7XG4gICAgXHRcdFx0ICBcdHRtcFNlcmlhbGl6ZWRbdGhpcy5nZXQoJ2ZpbHRlcklkJyldID0gKG9wdGlvbnMud2hvbGVNb2RlbD8gW3RoaXNdOlt0aGlzLmlkXSk7XG4gICAgXHRcdCAgfSBlbHNlIHtcbiAgICBcdFx0XHQgIHRtcFNlcmlhbGl6ZWQudW5hc3NpZ25lZCA9IChvcHRpb25zLndob2xlTW9kZWw/IFt0aGlzXTpbdGhpcy5pZF0pO1xuICAgIFx0XHQgIH1cbiAgICBcdCAgfVxuICAgICAgfVxuICAgfVxuICAgdGhpcy5fbWVyZ2VVbmFzc2lnbmVkKHRtcFNlcmlhbGl6ZWQpO1xuICAgcmV0dXJuIHRtcFNlcmlhbGl6ZWQ7XG59LFxuXG4gIF9zZXJpYWxpemVDaGlsZHJlbjogZnVuY3Rpb24odG1wU2VyaWFsaXplZCwgY2hpbGRyZW4sIG9wdGlvbnMpe1xuICAgIGNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHZhciBzZXJpYWxpemVkQ2hpbGQgPSBjaGlsZC5zZXJpYWxpemUob3B0aW9ucyk7XG4gICAgICBfLmVhY2goc2VyaWFsaXplZENoaWxkLCBmdW5jdGlvbih2LGspe1xuICAgICAgICBpZih2KXtcbiAgICAgICAgICAvL21lcmdlIGlmIGtleSBleGlzdHNcbiAgICAgICAgICBpZiAodG1wU2VyaWFsaXplZFtrXSkge1xuICAgICAgICAgICAgdG1wU2VyaWFsaXplZFtrXSA9IHRtcFNlcmlhbGl6ZWRba10uY29uY2F0KHYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0bXBTZXJpYWxpemVkW2tdID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIF9tZXJnZVVuYXNzaWduZWQ6IGZ1bmN0aW9uKHRtcFNlcmlhbGl6ZWQpe1xuICAgIC8vIGlmIGN1cnJlbnQgbm9kZSBoYXMgYSBmaWx0ZXJJZCBwdXQgYWxsICd1bmFzc2lnbmVkJyBlbGVtZW50cyB1bmRlciB0aGlzLlxuICAgIGlmKHRoaXMuZ2V0KCdmaWx0ZXJJZCcpKXtcbiAgICAgIHZhciBmaWx0ZXJJZCA9IHRoaXMuZ2V0KCdmaWx0ZXJJZCcpO1xuICAgICAgaWYodG1wU2VyaWFsaXplZFtmaWx0ZXJJZF0gJiYgdG1wU2VyaWFsaXplZC51bmFzc2lnbmVkKXtcbiAgICAgICAgdG1wU2VyaWFsaXplZFtmaWx0ZXJJZF0gPSB0bXBTZXJpYWxpemVkW2ZpbHRlcklkXS5jb25jYXQodG1wU2VyaWFsaXplZC51bmFzc2lnbmVkKTtcbiAgICAgICAgZGVsZXRlIHRtcFNlcmlhbGl6ZWQudW5hc3NpZ25lZDtcbiAgICAgIH0gZWxzZSBpZiAodG1wU2VyaWFsaXplZC51bmFzc2lnbmVkKXtcbiAgICAgICAgdG1wU2VyaWFsaXplZFtmaWx0ZXJJZF0gPSB0bXBTZXJpYWxpemVkLnVuYXNzaWduZWQ7XG4gICAgICAgIGRlbGV0ZSB0bXBTZXJpYWxpemVkLnVuYXNzaWduZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc2VyaWFsaXplOiBmdW5jdGlvbihibG9iKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBjaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGlmKCFjaGlsZC5nZXQoJ2ZpbHRlcklkJykgJiYgc2VsZi5nZXQoJ2ZpbHRlcklkJykpe1xuICAgICAgICAgIGNoaWxkLnNldCgnZmlsdGVySWQnLCBzZWxmLmdldCgnZmlsdGVySWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQuZGVzZXJpYWxpemUoYmxvYik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZihibG9iW3RoaXMuZ2V0KCdmaWx0ZXJJZCcpXSl7XG4gICAgICBpZiAoXyhibG9iW3RoaXMuZ2V0KCdmaWx0ZXJJZCcpXSkuaW5kZXhPZih0aGlzLmlkKSA+IC0xKSB7XG4gICAgICAgIHRoaXMuc2V0KCdzZWxlY3RlZCcsIHRydWUsIHtwcm9wYWdhdGlvbjogdHJ1ZX0pO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXQoJ3NlbGVjdGVkJywgZmFsc2UsIHtwcm9wYWdhdGlvbjogdHJ1ZX0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuXG4gIF9vblNlbGVjdENoYW5nZTpmdW5jdGlvbihtb2RlbCwgYXJndW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXQoJ2NoaWxkcmVuJyk7XG5cbiAgICBpZiAodGhpcy5nZXQoJ3NlbGVjdGVkJykpIHtcbiAgICAgIHRoaXMuc2V0KCdudW1TZWxlY3RlZCcsIHRoaXMuZ2V0KCdudW1Qb3NzaWJsZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQoJ251bVNlbGVjdGVkJywgMCk7XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZHJlbi5pc0VtcHR5KCkpIHtcbiAgICAgIHNlbGYuX3VwZGF0ZUNoaWxkTm9kZXMob3B0aW9ucy5wcm9wYWdhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucHJvcGFnYXRpb24pIHtcbiAgICAgIHNlbGYudHJpZ2dlcigndXBkYXRlQ291bnQnKTtcbiAgICB9XG4gIH0sXG5cblxuICBfYWRkTGlzdGVuZXJzVG9DaGlsZHJlbjpmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgY2hpbGQub24oJ2NoYW5nZTp2aXNpYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIElmIG5vIGNoaWxkcmVuIGFyZSB2aXNpYmxlLCB0aGVuIGhpZGUgc2VsZi5cbiAgICAgICAgaWYgKCFjaGlsZHJlbi5maW5kV2hlcmUoe3Zpc2libGU6IHRydWV9KSkge1xuICAgICAgICAgIHNlbGYuc2V0KHt2aXNpYmxlOiBmYWxzZX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuc2V0KHt2aXNpYmxlOiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2hpbGQub24oJ3VwZGF0ZUNvdW50JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuX3VwZGF0ZUNvdW50KCk7XG4gICAgICAgIHNlbGYudHJpZ2dlcigndXBkYXRlQ291bnQnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIF91cGRhdGVDb3VudDpmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldCgnY2hpbGRyZW4nKTtcbiAgICB2YXIgY291bnRUb3RhbCA9IHtcbiAgICAgIHNlbGVjdGVkOiAwLFxuICAgICAgcG9zc2libGU6MFxuICAgIH07XG5cbiAgICBpZiAoIWNoaWxkcmVuLmlzRW1wdHkoKSkge1xuICAgICAgY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBjb3VudFRvdGFsLnNlbGVjdGVkICs9IGNoaWxkLmdldCgnbnVtU2VsZWN0ZWQnKTtcbiAgICAgICAgY291bnRUb3RhbC5wb3NzaWJsZSArPSBjaGlsZC5nZXQoJ251bVBvc3NpYmxlJyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnRUb3RhbCA9IHtcbiAgICAgICAgc2VsZWN0ZWQ6ICh0aGlzLmdldCgnc2VsZWN0ZWQnKSA/IDEgOiAwKSxcbiAgICAgICAgcG9zc2libGU6IDFcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5zZXQoJ251bVNlbGVjdGVkJywgY291bnRUb3RhbC5zZWxlY3RlZCk7XG4gICAgdGhpcy5zZXQoJ251bVBvc3NpYmxlJywgY291bnRUb3RhbC5wb3NzaWJsZSk7XG4gIH0sXG5cbiAgX3VwZGF0ZUNoaWxkTm9kZXM6ZnVuY3Rpb24ocHJvcGFnYXRpb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXQoJ2NoaWxkcmVuJyk7XG5cbiAgICBpZiAoIWNoaWxkcmVuLmlzRW1wdHkoKSkge1xuICAgICAgY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBjaGlsZC5zZXQoJ3NlbGVjdGVkJywgc2VsZi5nZXQoJ3NlbGVjdGVkJyksIHtwcm9wYWdhdGlvbjogcHJvcGFnYXRpb259KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBmaWx0ZXJUZXh0OiBmdW5jdGlvbih0eHQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldCgnY2hpbGRyZW4nKTtcblxuICAgIGlmICghY2hpbGRyZW4uaXNFbXB0eSgpKSB7XG4gICAgICAvLyBpZiB0aGUgbm9kZSBpdHNlbGYgbWF0Y2hlcywgdHVybiBpdCBvbiwgZXZlbiBpZiBubyBjaGlsZHJlbiBhcmUgdmlzaWJsZS5cbiAgICAgIGlmICh0aGlzLmdldCgnbmFtZScpICYmIHRoaXMuZ2V0KCduYW1lJykudG9Mb3dlckNhc2UoKS5pbmRleE9mKHR4dCkgPiAtMSkge1xuICAgICAgICB0aGlzLnNldCgndmlzaWJsZScsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBGWUk6IHB1dHRpbmcgaW5zaWRlIGFuIGVsc2UgYWJvdmUga2VlcHMgY2hpbGRyZW4gdmlzaWJsZSBpZiBwYXJlbnQgbWF0Y2hlcy5cbiAgICAgIGNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuZmlsdGVyVGV4dCh0eHQpO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZ2V0KCduYW1lJykgJiYgdGhpcy5nZXQoJ25hbWUnKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodHh0KSA+IC0xKSB7XG4gICAgICAgIHRoaXMuc2V0KCd2aXNpYmxlJywgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldCgndmlzaWJsZScsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlTm9kZU1vZGVsO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgVGVtcGxhdGUgPSBcIjxkaXYgY2xhc3M9XFxcIm5vZGUgc21hbGxcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwic2VsZWN0YWJsZVxcXCI+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJ0b2dnbGUtbmF2XFxcIj5cXG4gICAgPCUgaWYobmFtZS5sZW5ndGggPiA2Myl7ICU+XFxuICAgICAgPHNwYW4gdGl0bGU9XFxcIjwlPSBuYW1lICU+XFxcIj48JT0gbmFtZS5zdWJzdHJpbmcoMCw2MCkgJT4uLi48L3NwYW4+XFxuICAgIDwlIH0gZWxzZSB7ICU+XFxuICAgICAgPCU9IG5hbWUgJT5cXG4gICAgPCUgfSAlPlxcblxcblxcbiAgICA8c3BhbiBjbGFzcz1cXFwiY291bnRcXFwiPig8JT0gbnVtU2VsZWN0ZWQgJT4gLyA8JT0gbnVtUG9zc2libGUgJT4pPC9zcGFuPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiZXhwYW5kZWRcXFwiPis8L3NwYW4+XFxuICA8L2Rpdj5cXG5cXG4gIDwlIC8qVE9ETzogZml4IGhhcmRjb2RlIG9mICd1bmtvd24nICovXFxuICBpZiAob2JqLm5hbWUgJiYgb2JqLm5hbWUuaW5kZXhPZihcXFwidW5rb3duXFxcIik+LTEpIHsgJT5cXG4gICAgJm5ic3A7PGEgaHJlZj1cXFwiI1xcXCJcXG4gICAgICBkYXRhLXRvZ2dsZT1cXFwicG9wb3ZlclxcXCJcXG4gICAgICBkYXRhLWNvbnRhaW5lcj1cXFwiYm9keVxcXCJcXG4gICAgICBkYXRhLXBsYWNlbWVudD1cXFwicmlnaHRcXFwiXFxuICAgICAgZGF0YS10cmlnZ2VyPVxcXCJjbGlja1xcXCJcXG4gICAgICBkYXRhLWNvbnRlbnQ9XFxcInByb2plY3RzIHRoYXQgYXJlbid0IHRhZ2dlZCB0byBhIHNwZWNpZmljIGNoaWxkLlxcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24taW5mby1zaWduXFxcIj48L3NwYW4+XFxuICAgIDwvYT5cXG4gIDwlfSU+XFxuPC9kaXY+XFxuXCI7XG5cblxudmFyIFRyZWVOb2RlVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcblxuICB0YWdOYW1lOiAnbGknLFxuICBjbGFzc05hbWU6ICdwYXJlbnRfbGknLFxuXG4gIC8vVE9ETzogZGVidWcgYWZ0ZXIgdXNhYmlsaXR5IHRlc3RpbmcsIGN1cnJlbnRseSBzZXR0aW5nIGluIGFkZFVJTGlzdGVuZXJzXG4gIC8vIHdvbid0IHdvcmsgb24gc2Vjb25kIHVzZSBvZiB3aWRnZXQuXG4gIC8vIGV2ZW50czoge1xuICAvLyAgICdjbGljayAuc2VsZWN0YWJsZSc6ICdzZWxlY3QnLFxuICAvLyAgICdjbGljayAgLnRvZ2dsZS1uYXYnOiAnY2xpY2tOYW1lJ1xuICAvLyB9LFxuXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKFRlbXBsYXRlKSxcbiAgaXNSb290OiBmYWxzZSxcbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbihvcHRpb25zKSB7XG5cdCBpZighXy5pc1VuZGVmaW5lZChvcHRpb25zKSAmJiAhXy5pc1VuZGVmaW5lZChvcHRpb25zLmlzUm9vdCkpe1xuXHRcdCB0aGlzLmlzUm9vdCA9IG9wdGlvbnMuaXNSb290O1xuXHQgfVxuXHQgIFxuICB9LFxuXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKG1vZGVsLnRvSlNPTigpKSk7XG4gICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVuZGVyQ2hpbGRyZW46ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVsID0gJCgnPHVsPicpO1xuICAgIHRoaXMuJGVsLmFwcGVuZCh1bCk7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm1vZGVsLmdldCgnY2hpbGRyZW4nKTtcbiAgICBpZiAoIWNoaWxkcmVuLmlzRW1wdHkoKSkge1xuICAgICAgY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgdG1wVmlldyA9IG5ldyBUcmVlTm9kZVZpZXcoKTtcbiAgICAgICAgdWwuYXBwZW5kKHRtcFZpZXcucmVuZGVyKGNoaWxkKS4kZWwpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJCgnLmV4cGFuZGVkJykucmVtb3ZlKCk7XG4gICAgICB0aGlzLiQoJz4gLm5vZGUgPiAudG9nZ2xlLW5hdiA+IC5jb3VudCcpLnRleHQoJycpO1xuICAgIH1cblxuICAgIHRoaXMuX2FkZE1vZGVsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fYWRkVUlMaXN0ZW5lcnMoKTtcblxuICAgIHRoaXMuX3VwZGF0ZVNlbGVjdGlvbigpO1xuICAgIHRoaXMuX3VwZGF0ZUV4cGFuZGVkKHVsKTtcbiAgfSxcblxuICBfYWRkTW9kZWxMaXN0ZW5lcnM6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy9BZGQgbW9kZWwgbGlzdGVuZXJlc1xuICAgIHRoaXMubW9kZWwub24oJ2NoYW5nZTpzZWxlY3RlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fdXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1vZGVsLm9uKCdjaGFuZ2U6ZXhwYW5kZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX3VwZGF0ZUV4cGFuZGVkKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1vZGVsLm9uKCdjaGFuZ2U6bnVtU2VsZWN0ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX3VwZGF0ZUNvdW50VUkoKTtcbiAgICB9KTtcblxuICAgIHRoaXMubW9kZWwub24oJ2NoYW5nZTp2aXNpYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl91cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgX2FkZFVJTGlzdGVuZXJzOmZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLiQoJz4gLm5vZGUgPiAuc2VsZWN0YWJsZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5jbGlja0JveCgpO1xuXG4gICAgfSk7XG4gICAgdGhpcy4kKCc+IC5ub2RlID4gLnRvZ2dsZS1uYXYnKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuY2xpY2tOYW1lKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgX3VwZGF0ZVNlbGVjdGlvbjpmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91cGRhdGVDaGVja2JveEZpbGwoKTtcbiAgfSxcblxuICBfdXBkYXRlQ291bnRVSTpmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMubW9kZWwuZ2V0KCdjaGlsZHJlbicpLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy4kKCc+IC5ub2RlID4gLnRvZ2dsZS1uYXYgPiAuY291bnQnKS50ZXh0KFxuICAgICAgICAnKCcgKyB0aGlzLm1vZGVsLmdldCgnbnVtU2VsZWN0ZWQnKSArICcgLyAnICsgdGhpcy5tb2RlbC5nZXQoJ251bVBvc3NpYmxlJykgKyAnKScpO1xuICAgICAgdGhpcy5fdXBkYXRlQ2hlY2tib3hGaWxsKCk7XG4gICAgfVxuICB9LFxuXG4gIF91cGRhdGVWaXNpYmlsaXR5OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3Zpc2libGUnKSkge1xuICAgICAgdGhpcy4kZWwuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRlbC5oaWRlKCk7XG4gICAgfVxuICB9LFxuXG5cbiAgLy8gRm9yIHVwZGF0aW5nIG5vbi1sZWFmIG5vZGVzXG4gIF91cGRhdGVDaGVja2JveEZpbGw6ZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm1vZGVsLmdldCgnY2hpbGRyZW4nKS5pc0VtcHR5KCkpIHtcbiAgICAgIGlmICh0aGlzLm1vZGVsLmdldCgnbnVtU2VsZWN0ZWQnKSA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdudW1TZWxlY3RlZCcpIDwgdGhpcy5tb2RlbC5nZXQoJ251bVBvc3NpYmxlJykpIHtcbiAgICAgICAgICB0aGlzLiQoJz4gLm5vZGUgPiAuc2VsZWN0YWJsZScpLmFkZENsYXNzKCdoYWxmLWZpbGwnKTtcbiAgICAgICAgICB0aGlzLiQoJz4gLm5vZGUgPiAuc2VsZWN0YWJsZScpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJCgnPiAubm9kZSA+IC5zZWxlY3RhYmxlJykucmVtb3ZlQ2xhc3MoJ2hhbGYtZmlsbCcpO1xuICAgICAgICAgIHRoaXMuJCgnPiAubm9kZSA+IC5zZWxlY3RhYmxlJykuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlbC5nZXQoJ251bVNlbGVjdGVkJykgPT09IDApIHtcbiAgICAgICAgdGhpcy4kKCc+IC5ub2RlID4gLnNlbGVjdGFibGUnKS5yZW1vdmVDbGFzcygnaGFsZi1maWxsJyk7XG4gICAgICAgIHRoaXMuJCgnPiAubm9kZSA+IC5zZWxlY3RhYmxlJykucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gZWxzZSBsZWFmIG5vZGVcbiAgICAgIGlmICh0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWQnKSkge1xuICAgICAgICB0aGlzLiQoJz4gLm5vZGUgPiAuc2VsZWN0YWJsZScpLmFkZENsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kKCc+IC5ub2RlID4gLnNlbGVjdGFibGUnKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX3VwZGF0ZUV4cGFuZGVkOmZ1bmN0aW9uKHVsKSB7XG4gICAgdmFyIGlFbGVtZW50ID0gdGhpcy4kKCc+IC5ub2RlID4gLnRvZ2dsZS1uYXYgPiAuZXhwYW5kZWQnKTtcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2V4cGFuZGVkJykpIHtcbiAgICAgIHRoaXMuZXhwYW5kKCk7XG4gICAgICBpRWxlbWVudC50ZXh0KCctJyk7XG4gICAgICBpRWxlbWVudC5hZGRDbGFzcygnb3BlbicpLnJlbW92ZUNsYXNzKCdjbG9zZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2xsYXBzZSgpO1xuXG4gICAgICAvLyB0byBydW4gb24gZmlyc3QgdGltZS4uLm5lZWQgdG8gdXNlIHVsLCBzaW5jZSBlbCBpcyBub3Qgb24gRE9NIHlldFxuICAgICAgaWYgKHVsKSB7XG4gICAgICAgIHVsLmZpbmQoJz4gbGknKS5oaWRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlFbGVtZW50LnRleHQoJysnKTtcbiAgICAgIGlFbGVtZW50LmFkZENsYXNzKCdjbG9zZWQnKS5yZW1vdmVDbGFzcygnb3BlbicpO1xuICAgIH1cbiAgfSxcblxuXG4gIGNsaWNrQm94OmZ1bmN0aW9uKCkge1xuXHQgIGlmKHRoaXMuaXNSb290KXtcblx0XHQgIHRoaXMubW9kZWwuc2V0KCdzZWxlY3RlZCcsICF0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWQnKSk7XHRcdCAgXG5cdCAgfWVsc2V7XG5cdFx0ICB0aGlzLm1vZGVsLnNldCgnc2VsZWN0ZWQnLCAhdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkJyksIHtwcm9wYWdhdGlvbjogdHJ1ZX0pOyAgXG5cdCAgfSAgICBcbiAgfSxcblxuXG4gIGNsaWNrTmFtZTpmdW5jdGlvbigpIHtcbiAgICAvLyBpZiB3ZSBoYXZlIGNoaWxkcmVuIGV4cGFuZFxuICAgIGlmICghdGhpcy5tb2RlbC5nZXQoJ2NoaWxkcmVuJykuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLm1vZGVsLnNldCgnZXhwYW5kZWQnLCAhdGhpcy5tb2RlbC5nZXQoJ2V4cGFuZGVkJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsZWFmIG5vZGUsIHNvIHByZXRlbmQgdGhlIGNsaWNrZWQgb24gdGhlIGJveFxuICAgICAgdGhpcy5jbGlja0JveCgpO1xuICAgIH1cbiAgfSxcblxuXG4gIGNvbGxhcHNlOmZ1bmN0aW9uKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJGVsLmZpbmQoJyA+IHVsID4gbGknKTtcbiAgICBjaGlsZHJlbi5oaWRlKCdmYXN0Jyk7XG5cbiAgfSxcblxuICBleHBhbmQ6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kZWwuZmluZCgnID4gdWwgPiBsaScpO1xuICAgIGNoaWxkcmVuLnNob3coJ2Zhc3QnKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlTm9kZVZpZXc7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcclxuXHJcbnZhciBleHRyYWN0RGF0ZXMgPSBmdW5jdGlvbihzZXR0aW5ncywgZmlsdGVyc091dCwgbWluTmFtZSwgbWF4TmFtZSkge1xyXG4gICAgZmlsdGVyc091dC5vdGhlckZpbHRlcnMgPSBmaWx0ZXJzT3V0Lm90aGVyRmlsdGVycyB8fCB7fTtcclxuICAgIGZpbHRlcnNPdXQub3RoZXJGaWx0ZXJzLmRhdGUgPSBmaWx0ZXJzT3V0Lm90aGVyRmlsdGVycy5kYXRlIHx8IHtcclxuICAgICAgICBzdGFydDogJycsXHJcbiAgICAgICAgZW5kOiAnJ1xyXG4gICAgICB9O1xyXG5cclxuICAgIHZhciBkZWZhdWx0TWluRGF0ZSA9IF8uZmluZChzZXR0aW5ncywgZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICByZXR1cm4gaXRlbS5nZXQoJ2lkJykgPT09IG1pbk5hbWU7XHJcbiAgICB9KTtcclxuICAgIGlmIChkZWZhdWx0TWluRGF0ZSAhPT0gdW5kZWZpbmVkICYmIGRlZmF1bHRNaW5EYXRlLmdldCgnbmFtZScpICE9PSAnJykge1xyXG4gICAgICBmaWx0ZXJzT3V0Lm90aGVyRmlsdGVycy5kYXRlLnN0YXJ0ID0gZGVmYXVsdE1pbkRhdGUuZ2V0KCduYW1lJyk7XHJcbiAgICB9XHJcbiAgICB2YXIgZGVmYXVsdE1heERhdGUgPSBfLmZpbmQoc2V0dGluZ3MsIGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgcmV0dXJuIGl0ZW0uZ2V0KCdpZCcpID09PSBtYXhOYW1lO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoZGVmYXVsdE1heERhdGUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0TWF4RGF0ZS5nZXQoJ25hbWUnKSAhPT0gJycpIHtcclxuICAgICAgZmlsdGVyc091dC5vdGhlckZpbHRlcnMuZGF0ZS5lbmQgPSBkZWZhdWx0TWF4RGF0ZS5nZXQoJ25hbWUnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRcdGV4dHJhY3REYXRlczogZXh0cmFjdERhdGVzXHJcbn1cclxuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgVGl0bGVUZW1wbGF0ZSA9IFwiPGxpPlxcblxcdDxhIGhyZWY9XFxcIiNcXFwiPlxcblxcdFxcdDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtPCU9IG5hbWUucmVwbGFjZSgvIC9nLCcnKSAlPlxcXCI+XFxuXFx0XFx0XFx0PCU9IG5hbWUgJT5cXG5cXHRcXHQ8L3NwYW4+ICAgXFxuXFx0XFx0PHNwYW4gY2xhc3M9J2ZpbHRlci1jb3VudCBzbWFsbCBwdWxsLXJpZ2h0Jz48L3NwYW4+XFxuXFx0PC9hPlxcbjwvbGk+XCI7XG52YXIgQ29udGVudFRlbXBsYXRlID0gXCI8JVxcbiAgLy8gdGhpcyByZW5kZXJzIHRoZSBcXFwiYmlnXFxcIiBmaWx0ZXIgbGlzdCAodGhlIHRhYnMpXFxuJT5cXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXG4gIDxhIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlIGNhbmNlbFxcXCIgIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj4mdGltZXM7PC9hPlxcbiAgPGgzIGRhdGEtaTE4bj1cXFwiYW1wLmdpczp0aXRsZS1maWx0ZXJzXFxcIiBjbGFzcz1cXFwicGFuZWwtdGl0bGVcXFwiPkZpbHRlcnM8L2gzPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHkgZmlsdGVyLWJvZHlcXFwiPlxcblxcbiAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXRhYnMgZmlsdGVyLXRpdGxlc1xcXCIgcm9sZT1cXFwidGFibGlzdFxcXCI+XFxuICA8L3VsPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwidGFiLWNvbnRlbnQgZmlsdGVyLW9wdGlvbnNcXFwiPlxcbiAgICA8aW1nIHNyYz1cXFwiaW1nXzIvbG9hZGluZy1pY29uLmdpZlxcXCIgLz5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsLWZvb3RlclxcXCI+XFxuICAmbmJzcDtcXG4gIDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IG1hcmdpbi1ib3R0b206IDVweDtcXFwiPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRhbmdlciByZXNldFxcXCIgIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpidXR0b24tcmVzZXRcXFwiICB0aXRsZT1cXFwiVHVybiBvZmYgYWxsIGZpbHRlcnMuXFxcIj5SZXNldDwvYnV0dG9uPlxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLXdhcm5pbmcgY2FuY2VsXFxcIiAgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOmJ1dHRvbi1jYW5jZWxcXFwiICB0aXRsZT1cXFwiUmV2ZXJ0IGZpbHRlcnMgdG8gc3RhdGUgd2hlbiBvcGVuZWQuXFxcIj5DYW5jZWw8L2J1dHRvbj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1zdWNjZXNzIGFwcGx5XFxcIiAgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOmJ1dHRvbi1hcHBseVxcXCIgPkFwcGx5PC9idXR0b24+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcblxuLy8gUGFyZW50IGJhc2UgdmlldyBmb3IgZmlsdGVycy5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogJ2ZpbHRlci10eXBlJyxcblxuICB0aXRsZVRlbXBsYXRlOiBfLnRlbXBsYXRlKFRpdGxlVGVtcGxhdGUpLFxuICBjb250ZW50VGVtcGxhdGU6IF8udGVtcGxhdGUoQ29udGVudFRlbXBsYXRlKSxcblxuICBpbml0aWFsaXplOmZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFwcCA9IG9wdGlvbnMuYXBwO1xuICB9LFxuXG4gIHJlbmRlckZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuXG4gIH0sXG5cbiAgcmVuZGVyVGl0bGU6IGZ1bmN0aW9uKCkge1x0ICBcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy50aXRsZUVsID0gdGhpcy50aXRsZVRlbXBsYXRlKHRoaXMubW9kZWwudG9KU09OKCkpO1xuICAgIHRoaXMuJHRpdGxlRWwgPSAkKHRoaXMudGl0bGVFbCk7XG4gICAgdGhpcy4kdGl0bGVFbC5vbignY2xpY2snLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdoYW5kbGluZyB0aGUgY2xpY2sgb24gbG93LWxldmVsIHRpdGxlRWwuLi4nKTsgQ09OU1RBTlRJTiBURU1QIENPTU1FTlQgV0hJTEUgTEVBUk5JTkcgRklMVEVSU1xuICAgICAgJCh0aGlzKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXG4gICAgICBzZWxmLiRlbC5odG1sKCcnKTtcbiAgICAgIHNlbGYucmVuZGVyRmlsdGVycygpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufSk7XG4iLCIvKipcbiAqIHRoaXMgaXMgdGhlIHZpZXcgd2hpY2ggcmVuZGVycyB0aGUgYmlnIEZpbHRlciBjb250ZW50cyAodGhlIHRhYnMpXG4gKi9cblxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxudmFyIFRyYW5zbGF0b3IgPSByZXF1aXJlKCdhbXAtdHJhbnNsYXRlJyk7XG5cbnZhciBUb3BMZXZlbEZpbHRlclZpZXcgPSByZXF1aXJlKCcuLi92aWV3cy90b3AtbGV2ZWwtZmlsdGVyLXZpZXcnKTtcbnZhciBBbGxGaWx0ZXJDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbnMvYWxsLWZpbHRlcnMtY29sbGVjdGlvbicpO1xuXG5cbnZhciBUZW1wbGF0ZSA9IFwiPCVcXG4gIC8vIHRoaXMgcmVuZGVycyB0aGUgXFxcImJpZ1xcXCIgZmlsdGVyIGxpc3QgKHRoZSB0YWJzKVxcbiU+XFxuPGRpdiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxuICA8YSB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZSBjYW5jZWxcXFwiICBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvYT5cXG4gIDxoMyBkYXRhLWkxOG49XFxcImFtcC5naXM6dGl0bGUtZmlsdGVyc1xcXCIgY2xhc3M9XFxcInBhbmVsLXRpdGxlXFxcIj5GaWx0ZXJzPC9oMz5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5IGZpbHRlci1ib2R5XFxcIj5cXG5cXG4gIDx1bCBjbGFzcz1cXFwibmF2IG5hdi10YWJzIGZpbHRlci10aXRsZXNcXFwiIHJvbGU9XFxcInRhYmxpc3RcXFwiPlxcbiAgPC91bD5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50IGZpbHRlci1vcHRpb25zXFxcIj5cXG4gICAgPGltZyBzcmM9XFxcImltZ18yL2xvYWRpbmctaWNvbi5naWZcXFwiIC8+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJwYW5lbC1mb290ZXJcXFwiPlxcbiAgJm5ic3A7XFxuICA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIiBzdHlsZT1cXFwiZGlzcGxheTogaW5saW5lLWJsb2NrOyBtYXJnaW4tYm90dG9tOiA1cHg7XFxcIj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1kYW5nZXIgcmVzZXRcXFwiICBkYXRhLWkxOG49XFxcImFtcC5naXM6YnV0dG9uLXJlc2V0XFxcIiAgdGl0bGU9XFxcIlR1cm4gb2ZmIGFsbCBmaWx0ZXJzLlxcXCI+UmVzZXQ8L2J1dHRvbj5cXG4gICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi13YXJuaW5nIGNhbmNlbFxcXCIgIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpidXR0b24tY2FuY2VsXFxcIiAgdGl0bGU9XFxcIlJldmVydCBmaWx0ZXJzIHRvIHN0YXRlIHdoZW4gb3BlbmVkLlxcXCI+Q2FuY2VsPC9idXR0b24+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tc3VjY2VzcyBhcHBseVxcXCIgIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpidXR0b24tYXBwbHlcXFwiID5BcHBseTwvYnV0dG9uPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG52YXIgVGl0bGVUZW1wbGF0ZSA9IFwiPCVcXG4vLyByZW5kZXJzIHRoZSB0aXRsZSBvZiBhIHRhYiBcXG4lPlxcbjxsaSBjbGFzcz1cXFwiXFxcIj48YSBkYXRhLWkxOG49XFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLTwlPSBuYW1lLnJlcGxhY2UoLyAvZywnJykgJT5cXFwiIGhyZWY9XFxcIiNmaWx0ZXItcGFuZS08JT0gbmFtZS5yZXBsYWNlKC8gL2csJycpICU+XFxcIiByb2xlPVxcXCJ0YWJcXFwiIGRhdGEtdG9nZ2xlPVxcXCJ0YWJcXFwiPjwlPSBuYW1lICU+PC9hPjwvbGk+XFxuXCI7XG52YXIgZmlsdGVyc1ZpZXdMb2cgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vcmVhbXAvdG9vbHMvbG9nXCIpKCdhbXA6ZmlsdGVyczp0b3AtbGV2ZWw6dmlldycpO1xuXG52YXIgU2V0dGluZ3NDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbnMvc2V0dGluZ3MtY29sbGVjdGlvbicpO1xuXG52YXIgRGF0ZVV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZGF0ZS11dGlscycpO1xuXG52YXIgZmlsdGVySW5zdGFuY2VzTmFtZXMgPSB7ZG9ub3JzOiAnRnVuZGluZyBPcmdhbml6YXRpb25zJywgc2VjdG9ycyA6ICdTZWN0b3JzJywgcHJvZ3JhbXM6ICdQcm9ncmFtcycsIFxuXHQgIGFjdGl2aXR5OiAnQWN0aXZpdHknLCBhbGxBZ2VuY2llczogJ0FsbCBBZ2VuY2llcycsIGZpbmFuY2lhbHM6ICdGaW5hbmNpYWwnLFxuXHRcdCAgbG9jYXRpb25zOiAnTG9jYXRpb24nLCBvdGhlcnM6ICdPdGhlcid9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICBpZDogJ3Rvb2wtZmlsdGVycycsXG4gIG5hbWU6ICdGaWx0ZXJzJyxcbiAgYXBpVVJMOiAnL3Jlc3QvZmlsdGVycycsXG5cbiAgZXZlbnRzOiB7XG4gICAgJ2NsaWNrIC5hcHBseSc6ICdhcHBseUZpbHRlcnMnLFxuICAgICdjbGljayAuY2FuY2VsJzogJ2NhbmNlbCcsXG4gICAgJ2NsaWNrIC5yZXNldCc6ICdyZXNldEZpbHRlcnMnXG4gIH0sXG5cbiAgLy8gY29sbGVjdGlvbiBvZiB0b3AtbGV2ZWwtZmlsdGVyIHZpZXdzLi5cbiAgZmlsdGVyVmlld3NJbnN0YW5jZXM6e30sXG5cbiAgdGVtcGxhdGU6IF8udGVtcGxhdGUoVGVtcGxhdGUpLFxuICB0aXRsZVRlbXBsYXRlOiBfLnRlbXBsYXRlKFRpdGxlVGVtcGxhdGUpLFxuICBQQVJBTVNfREFURV9GT1JNQVQ6J3l5LW1tLWRkJywgLy9iYWNrZW5kIGV4cGVjdHMgZmlsdGVycyB0byBiZSBzdWJtaXR0ZWQgaW4gdGhpcyBmb3JtYXRcbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZHJhZ2dhYmxlID0gb3B0aW9ucy5kcmFnZ2FibGU7XG4gICAgdGhpcy5jYWxsZXIgPSBvcHRpb25zLmNhbGxlcjtcbiAgICB0aGlzLnNldHRpbmdzID0gbmV3IFNldHRpbmdzQ29sbGVjdGlvbigpO1xuICAgIHRoaXMuc2V0dGluZ3MuZmV0Y2goKTtcbiAgICBcbiAgICB0aGlzLmRhdGVGb3JtYXRNYXBwaW5ncyA9IFtdO1xuICAgIHRoaXMuZGF0ZUZvcm1hdE1hcHBpbmdzLnB1c2goe2FtcGZvcm1hdDogJ2RkL01NTS95eXl5JywgZGF0ZXBpY2tlcmZvcm1hdDonZGQvTS95eSd9KTtcbiAgICB0aGlzLmRhdGVGb3JtYXRNYXBwaW5ncy5wdXNoKHthbXBmb3JtYXQ6ICdNTU0vZGQveXl5eScsIGRhdGVwaWNrZXJmb3JtYXQ6J00vZGQveXknfSk7XG4gICAgdGhpcy5kYXRlRm9ybWF0TWFwcGluZ3MucHVzaCh7YW1wZm9ybWF0OiAnZGQvTU0veXl5eScsIGRhdGVwaWNrZXJmb3JtYXQ6J2RkL21tL3l5J30pO1xuICAgIHRoaXMuZGF0ZUZvcm1hdE1hcHBpbmdzLnB1c2goe2FtcGZvcm1hdDogJ01NL2RkL3l5eXknLCBkYXRlcGlja2VyZm9ybWF0OidtbS9kZC95eSd9KTtcbiAgICBcbiAgICBpZihvcHRpb25zLnRyYW5zbGF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jcmVhdGVUcmFuc2xhdG9yKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNsYXRvciA9IG9wdGlvbnMudHJhbnNsYXRvcjtcbiAgICB9XG5cbiAgICB0aGlzLmZpcnN0UmVuZGVyID0gdHJ1ZTtcbiAgICB0aGlzLl9jcmVhdGVUb3BMZXZlbEZpbHRlclZpZXdzKCk7XG4gICAgdGhpcy5hbGxGaWx0ZXJzID0gbmV3IEFsbEZpbHRlckNvbGxlY3Rpb24oW10sb3B0aW9ucyk7XG4gICAgdGhpcy5fbG9hZGVkID0gIHRoaXMuYWxsRmlsdGVycy5fbG9hZGVkO1xuICAgIHRoaXMuX2dldEZpbHRlckxpc3QoKS50aGVuKGZ1bmN0aW9uKCkgeyAgICBcdFxuICAgICAgICBzZWxmLmFsbEZpbHRlcnMuZWFjaChmdW5jdGlvbihtb2RlbCkgeyAgICAgICAgXHRcbiAgICAgIFx0ICBpZihtb2RlbC5nZXQoJ2VtcHR5JykpeyAgICAgIFx0XHQgICAgIFx0XHQgIFxuICAgICAgXHRcdGZvciAoa2V5IGluIGZpbHRlckluc3RhbmNlc05hbWVzKSB7XG4gICAgXHRcdFx0aWYgKGZpbHRlckluc3RhbmNlc05hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICBcdFx0XHRcdGlmKGZpbHRlckluc3RhbmNlc05hbWVzW2tleV0gPT0gbW9kZWwuZ2V0KCdncm91cCcpKXtcbiAgICBcdFx0XHRcdFx0Ly8gcmVtb3ZlIHRhYiBpZiB0aGVyZSBpcyBubyBkYXRhIGZvciB0aGUgdGFiXG4gICAgXHRcdFx0XHRcdGRlbGV0ZSBmaWx0ZXJJbnN0YW5jZXNOYW1lc1trZXldO1xuICAgIFx0XHRcdFx0XHRkZWxldGUgc2VsZi5maWx0ZXJWaWV3c0luc3RhbmNlc1trZXldO1xuICAgIFx0XHRcdFx0fSAgICBcdFx0XHRcdFxuICAgIFx0XHRcdFx0XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9ICAgICAgXHRcdFxuICAgICAgXHQgIH1lbHNle1xuICAgICAgXHRcdHNlbGYuX2NyZWF0ZUZpbHRlclZpZXdzKG1vZGVsKTsgIFxuICAgICAgXHQgIH1cbiAgICAgIFx0ICBcbiAgICAgIH0pOyAgICAgICAgXG4gICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gIH0sXG5cbiAgXG4vLyAgXG4vLyAgX2dlbmVyYXRlRmlsdGVyVmlld0luc3RhbmNlIDogZnVuY3Rpb24oa2V5bmFtZSkge1xuLy9cdCAgcmV0dXJuIG5ldyBUb3BMZXZlbEZpbHRlclZpZXcoe25hbWU6ZmlsdGVySW5zdGFuY2VzTmFtZXNba2V5bmFtZV0sIHRyYW5zbGF0b3I6IHRoaXMudHJhbnNsYXRvciwgdHJhbnNsYXRlOiB0aGlzLnRyYW5zbGF0ZX0pO1xuLy8gIH0sXHQgIFx0XHRcdFx0XHQgIFxuXHQgIFx0XHRcdFx0XHRcbiAgXG4gIF9jcmVhdGVUb3BMZXZlbEZpbHRlclZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICAvL3RoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMgPSB7XG4gICAgXHRcdGZvciAoa2V5IGluIGZpbHRlckluc3RhbmNlc05hbWVzKSB7XG4gICAgXHRcdFx0aWYgKGZpbHRlckluc3RhbmNlc05hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICBcdFx0XHRcdFxuICAgIFx0XHRcdFx0dGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlc1trZXldID0gbmV3IFRvcExldmVsRmlsdGVyVmlldyh7bmFtZTpmaWx0ZXJJbnN0YW5jZXNOYW1lc1trZXldLCB0cmFuc2xhdG9yOiB0aGlzLnRyYW5zbGF0b3IsIHRyYW5zbGF0ZTogdGhpcy50cmFuc2xhdGUsIGZpbHRlclZpZXc6IHRoaXN9KTtcbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cbiAgICBcdFx0LypcbiAgICAgIGRvbm9yczogbmV3IFRvcExldmVsRmlsdGVyVmlldyh7bmFtZTonRnVuZGluZyBPcmdhbml6YXRpb25zJywgdHJhbnNsYXRvcjogdGhpcy50cmFuc2xhdG9yLCB0cmFuc2xhdGU6IHRoaXMudHJhbnNsYXRlfSksXG4gICAgICBzZWN0b3JzOiBuZXcgVG9wTGV2ZWxGaWx0ZXJWaWV3KHtuYW1lOidTZWN0b3InLCB0cmFuc2xhdG9yOiB0aGlzLnRyYW5zbGF0b3IsIHRyYW5zbGF0ZTogdGhpcy50cmFuc2xhdGV9KSxcbiAgICAgIHByb2dyYW1zOiBuZXcgVG9wTGV2ZWxGaWx0ZXJWaWV3KHtuYW1lOidQcm9ncmFtcycsIHRyYW5zbGF0b3I6IHRoaXMudHJhbnNsYXRvciwgdHJhbnNsYXRlOiB0aGlzLnRyYW5zbGF0ZX0pLFxuICAgICAgYWN0aXZpdHk6IG5ldyBUb3BMZXZlbEZpbHRlclZpZXcoe25hbWU6J0FjdGl2aXR5JywgdHJhbnNsYXRvcjogdGhpcy50cmFuc2xhdG9yLCB0cmFuc2xhdGU6IHRoaXMudHJhbnNsYXRlfSksXG4gICAgICBhbGxBZ2VuY2llczogbmV3IFRvcExldmVsRmlsdGVyVmlldyh7bmFtZTonQWxsIEFnZW5jaWVzJywgdHJhbnNsYXRvcjogdGhpcy50cmFuc2xhdG9yLCB0cmFuc2xhdGU6IHRoaXMudHJhbnNsYXRlfSksXG4gICAgICBmaW5hbmNpYWxzOiBuZXcgVG9wTGV2ZWxGaWx0ZXJWaWV3KHtuYW1lOidGaW5hbmNpYWwnLCB0cmFuc2xhdG9yOiB0aGlzLnRyYW5zbGF0b3IsIHRyYW5zbGF0ZTogdGhpcy50cmFuc2xhdGV9KSxcbiAgICAgIGxvY2F0aW9uczogbmV3IFRvcExldmVsRmlsdGVyVmlldyh7bmFtZTonTG9jYXRpb24nLCB0cmFuc2xhdG9yOiB0aGlzLnRyYW5zbGF0b3IsIHRyYW5zbGF0ZTogdGhpcy50cmFuc2xhdGV9KSxcbiAgICAgIG90aGVyczogbmV3IFRvcExldmVsRmlsdGVyVmlldyh7bmFtZTonT3RoZXInLCB0cmFuc2xhdG9yOiB0aGlzLnRyYW5zbGF0b3IsIHRyYW5zbGF0ZTogdGhpcy50cmFuc2xhdGV9KVxuICAgIH07Ki9cbiAgfSxcblxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuJGVsLmFkZENsYXNzKCdwYW5lbCBwYW5lbC1wcmltYXJ5Jyk7XG4gICAgaWYgKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICB0aGlzLiRlbC5kcmFnZ2FibGUoe2N1cnNvcjogJ21vdmUnLCBjb250YWlubWVudDogJ3dpbmRvdycgfSk7XG4gICAgfVxuICAgIHRoaXMuZmlyc3RSZW5kZXIgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuZmlyc3RSZW5kZXIpIHtcbiAgICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZSh7fSkpO1xuICAgICAgdGhpcy4kZWwuc2hvdygpO1xuXG4gICAgICB0aGlzLl9nZXRGaWx0ZXJMaXN0KCkuZG9uZShmdW5jdGlvbigpIHtcbi8vICAgIFx0c2VsZi5jbGVhbnVwVW51c2VkVGFicygpOyBcbiAgICAgICAgc2VsZi5yZW5kZXJGaWx0ZXJzKCk7XG4gICAgICAgIHNlbGYudHJhbnNsYXRlKHRoaXMuJGVsKTtcbiAgICAgIH0pO1xuICAgICAgLy9kZWJ1Z2dlcjsgLy8gQU1QLTIwNjE3ICB3dGggZG9lcyB0aGluZyBub3Qgd29yayBpbiBzYWlrdT9cbiAgICAgIC8vIGhhbmRsZSBjbGljayBvbiBhIFRhYidzIHRpdGxlOiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0YWJzLWV2ZW50c1xuICAgICAgJChkb2N1bWVudCkub24oJ3Nob3duLmJzLnRhYiBjbGljaycsIFwidWwubmF2LmZpbHRlci10aXRsZXM+bGk+YVtkYXRhLXRvZ2dsZT0ndGFiJ11cIiwgZnVuY3Rpb24gKGUpIHsgIC8vIDwtIHRoaXMgbGluZSBtYWtlcyBsaXR0bGUgc2Vuc2UgYnV0IHdvcmtzIGluIFNhaWt1L1RhYnMgYWxzb1xuICAgICAgICAvL3RoaXMuJGVsLmZpbmQoXCJ1bC5uYXYuZmlsdGVyLXRpdGxlcz5saT5hW2RhdGEtdG9nZ2xlPSd0YWInXVwiKS5vbignc2hvd24uYnMudGFiJywgZnVuY3Rpb24gKGUpIHsgICAvLyA8LSB0aGlzIGxpbmUgd29ya3MgaW4gYW55dGhpbmcgZXhjZXB0IFNhaWt1L1RhYnNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZSAnY2xpY2snIGV2ZW50IGFkZGVkIGJlY2F1c2UgKHdlaXJkbHkpIHRoZSBzaG93bi5icy50YWIgZXZlbnQgbm90IGJlaW5nIGZpcmVkIEFUIEFMTCB1bmRlciBTYWlrdS9UYWJzLiBVbnRpbCB0aGlzIGlzIGludmVzdGlnYXRlZFxuICAgICAgICAgKiBvbiBHSVMvRGFzaGJvYXJkIHRhYnMgdGhpcyBzZWNvbmQgZXZlbnQgaXMgc3VwZXJmbHVvdXNcbiAgICAgICAgICovXG5cbiAgICAgICAgLy9lLnRhcmdldCAvLyBuZXdseSBhY3RpdmF0ZWQgdGFiXG4gICAgICAgIC8vZS5yZWxhdGVkVGFyZ2V0IC8vIHByZXZpb3VzIGFjdGl2ZSB0YWJcblxuICAgICAgICB2YXIgYWN0aXZlVGFiID0gJChlLnRhcmdldC5wYXJlbnRFbGVtZW50KS5pbmRleCgpOyAvLyBzaGFtZWZ1bCBoYWNrLCBidXQgaGF2ZW4ndCBiZWVuIGFibGUgdG8gZmluZCBhIGNsZWFuZXIgc29sdXRpb25cbiAgICAgICAgdmFyIG9sZFRhYk5yID0gZS5yZWxhdGVkVGFyZ2V0ID8gJChlLnJlbGF0ZWRUYXJnZXQucGFyZW50RWxlbWVudCkuaW5kZXgoKSA6IC0xO1xuICAgICAgICBmaWx0ZXJzVmlld0xvZy5sb2coJ3N3aXRjaGluZyBmcm9tIGZpbHRlcnMgdGFiJywgb2xkVGFiTnIsICd0byB0YWInLCBhY3RpdmVUYWIpO1xuICAgICAgICAkKGUudGFyZ2V0KS5jbG9zZXN0KCd1bC5maWx0ZXItdGl0bGVzJykuYXR0cignYWN0aXZlLXRhYi1udW1iZXInLCBhY3RpdmVUYWIpOyAvLyBub3QgdXNlZCBpbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgY29kZVxuXG4gICAgICAgIC8vIHJlbmRlciB0aGUgZmlyc3QgaXRlbSBvZiB0aGUgdGFiXG4gICAgICAgIHZhciB0YWJJZCA9ICQoZS50YXJnZXQpLmF0dHIoJ2hyZWYnKTtcbiAgICAgICAgdmFyIHRhYkZpcnN0Q2hpbGQgPSAkKHRhYklkKS5maW5kKCd1bC5zdWItZmlsdGVycy10aXRsZXM+bGk6Zmlyc3QgYScpO1xuICAgICAgICBpZiAodGFiRmlyc3RDaGlsZClcbiAgICAgICAgICB0YWJGaXJzdENoaWxkLmNsaWNrKCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5maXJzdFJlbmRlciA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnRyYW5zbGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNyZWF0ZVRyYW5zbGF0b3I6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmaWx0ZXJUcmFuc2xhdGVLZXlzID0gSlNPTi5wYXJzZShcIntcXG4gIFxcXCJhbXAuZ2lzOnRpdGxlLUNvdW50cnlcXFwiOiBcXFwiQ291bnRyeVxcXCIsXFxuICBcXFwiYW1wLmdpczp0aXRsZS1SZWdpb25cXFwiOiBcXFwiUmVnaW9uXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnRpdGxlLVpvbmVcXFwiOiBcXFwiWm9uZVxcXCIsXFxuICBcXFwiYW1wLmdpczp0aXRsZS1EaXN0cmljdFxcXCI6IFxcXCJEaXN0cmljdFxcXCIsXFxuICBcXFwiYW1wLmdpczp0aXRsZS1maWx0ZXJzXFxcIjogXFxcIkZpbHRlclxcXCIsXFxuICBcXFwiYW1wLmdpczp0aXRsZS1maWx0ZXJzXFxcIjogXFxcIkZpbHRlclxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtc2VhcmNoXFxcIjogXFxcIkdvXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1zZWxlY3RcXFwiOiBcXFwic2VsZWN0IGFsbFxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtZGVzZWxlY3RcXFwiOiBcXFwiZGVzZWxlY3QgYWxsXFxcIixcXG4gIFxcXCJbcGxhY2Vob2xkZXJdYW1wLmdpczpwYW5lLWZpbHRlcnMtc2VhcmNoLXBsYWNlaG9sZGVyXFxcIjogXFxcIlNlYXJjaC4uLlxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtRnVuZGluZ09yZ2FuaXphdGlvbnNcXFwiOiBcXFwiRnVuZGluZyBPcmdhbml6YXRpb25zXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1TZWN0b3JcXFwiOiBcXFwiU2VjdG9yXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1TZWN0b3JzXFxcIjogXFxcIlNlY3RvcnNcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLVByb2dyYW1zXFxcIjogXFxcIlByb2dyYW1zXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1BY3Rpdml0eVxcXCI6IFxcXCJBY3Rpdml0eVxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtQWxsQWdlbmNpZXNcXFwiOiBcXFwiQWxsIEFnZW5jaWVzXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1GaW5hbmNpYWxcXFwiOiBcXFwiRmluYW5jaWFsXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy1Mb2NhdGlvblxcXCI6IFxcXCJMb2NhdGlvblxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtT3RoZXJcXFwiOiBcXFwiT3RoZXJcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLURvbm9yXFxcIjogXFxcIkRvbm9yXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1QcmltYXJ5XFxcIjogXFxcIlByaW1hcnlcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLVNlY29uZGFyeVxcXCI6IFxcXCJTZWNvbmRhcnlcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLU5hdGlvbmFsUGxhbk9iamVjdGl2ZVxcXCI6IFxcXCJOYXRpb25hbCBQbGFuIE9iamVjdGl2ZVxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtQWN0aXZpdHlTdGF0dXNcXFwiOiBcXFwiQWN0aXZpdHkgU3RhdHVzXFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1BcHByb3ZhbFN0YXR1c1xcXCI6IFxcXCJBcHByb3ZhbCBTdGF0dXNcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLUltcGxlbWVudGluZ0FnZW5jeVxcXCI6IFxcXCJJbXBsZW1lbnRpbmcgQWdlbmN5XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1FeGVjdXRpbmdBZ2VuY3lcXFwiOiBcXFwiRXhlY3V0aW5nIEFnZW5jeVxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtQmVuZWZpY2lhcnlBZ2VuY3lcXFwiOiBcXFwiQmVuZWZpY2lhcnkgQWdlbmN5XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1Db250cmFjdGluZ0FnZW5jeVxcXCI6IFxcXCJDb250cmFjdGluZyBBZ2VuY3lcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLUFpZE1vZGFsaXR5XFxcIjogXFxcIkFpZCBNb2RhbGl0eVxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtVHlwZU9mQXNzaXN0YW5jZVxcXCI6IFxcXCJUeXBlIE9mIEFzc2lzdGFuY2VcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLVJlc3BvbnNpYmxlT3JnYW5pemF0aW9uXFxcIjogXFxcIlJlc3BvbnNpYmxlIE9yZ2FuaXphdGlvblxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtRGF0ZXNcXFwiOiBcXFwiRGF0ZXNcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLVJlZ2lvbmFsR3JvdXBcXFwiOiBcXFwiUmVnaW9uYWwgR3JvdXBcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLVNlY3Rvckdyb3VwXFxcIjogXFxcIlNlY3RvciBHcm91cFxcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtVGVydGlhcnlTZWN0b3JzXFxcIjogXFxcIlRlcnRpYXJ5IFNlY3RvcnNcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLUZpbmFuY2luZ0luc3RydW1lbnRzXFxcIjogXFxcIkZpbmFuY2luZyBJbnN0cnVtZW50c1xcXCIsXFxuICBcXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtYWxsXFxcIjogXFxcImFsbFxcXCIsXFxuICBcXFwiYW1wLmdpczpidXR0b24tcmVzZXRcXFwiOiBcXFwiUmVzZXRcXFwiLFxcbiAgXFxcImFtcC5naXM6YnV0dG9uLWNhbmNlbFxcXCI6IFxcXCJDYW5jZWxcXFwiLFxcbiAgXFxcImFtcC5naXM6YnV0dG9uLWFwcGx5XFxcIjogXFxcIkFwcGx5XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1zdGFydGRhdGVcXFwiOiBcXFwiU3RhcnQgRGF0ZTpcXFwiLFxcbiAgXFxcImFtcC5naXM6cGFuZS1zdWJmaWx0ZXJzLWVuZGRhdGVcXFwiOiBcXFwiRW5kIERhdGU6XFxcIixcXG4gIFxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1lbXB0eVxcXCI6IFxcXCJObyBkYXRhIGZvciB0aGlzIGZpbHRlclxcXCJcXG59XFxuXCIpO1xuICAgIC8vIHNldHVwIGFueSBwb3BvdmVycyBhcyBuZWVkZWQuLi5cbiAgICBzZWxmLnBvcG92ZXJzID0gc2VsZi4kKCdbZGF0YS10b2dnbGU9XCJwb3BvdmVyXCJdJyk7XG4gICAgc2VsZi5wb3BvdmVycy5wb3BvdmVyKCk7XG4gICAgaWYgKGZvcmNlID09PSB0cnVlIHx8IHNlbGYudHJhbnNsYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaWx0ZXJzVmlld0xvZy5vbkRlYnVnKGZ1bmN0aW9uKCkge1xuICAgICAgICBmaWx0ZXJzVmlld0xvZy5sb2coJ0NyZWF0aW5nIHRyYW5zbGF0b3IgZm9yIGZpbHRlcnMgYmVjYXVzZScsIGZvcmNlID09PSB0cnVlID8gJ0kgd2FzIGZvcmNlZCcgOiAndGhlcmUgaXMgbm8gdHJhbnNsYXRvcicpO1xuICAgICAgfSk7XG4gICAgICBzZWxmLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcih7ZGVmYXVsdEtleXM6IGZpbHRlclRyYW5zbGF0ZUtleXN9KTtcbiAgICB9XG4gIH0sXG5cbiAgdHJhbnNsYXRlOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXM7XG4gICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbGVtZW50ID0gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5lbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKGVsZW1lbnQuZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlRE9NKGVsZW1lbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogcmVuZGVycyB0aGUgdGFicyB3aXRoaW4gdGhlIGZpbHRlcnMsIG9ubHkgcmVuZGVyaW5nIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSBhY3RpdmUgdGFiICh0aGUgb3RoZXJzIGRvbid0IGhhdmUgdGhlaXIgZmlyc3QgaXRlbSdzIGNvbnRlbnRzIHJlbmRlcmVkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zKVxuICAgKi9cbiAgcmVuZGVyRmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kKCcuZmlsdGVyLW9wdGlvbnMnKS5odG1sKCcnKTtcblxuICAgIHZhciByZW5kZXJpbmdUaXRsZU51bWJlciA9IC0xO1xuICAgIHZhciBhY3RpdmVUaXRsZU51bWJlciA9IHRoaXMuJCgnLmZpbHRlci10aXRsZXMnKS5hdHRyKCdhY3RpdmUtdGFiLW51bWJlcicpIHx8IDA7XG5cbiAgICBmb3IgKHZhciBmaWx0ZXJWaWV3IGluIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMpIHtcbi8vICAgIFx0Y29uc29sZS5sb2coZmlsdGVyVmlldyk7XG4gICAgICBpZiAodGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShmaWx0ZXJWaWV3KSkge1xuICAgIFx0ICBjb250YWluZWQgPSBmYWxzZTtcbiAgICBcdCAgdmFyIGluZGV4O1xuICAgIFx0ICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmFsbEZpbHRlcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgXHRcdCAgaWYgKCh0aGlzLmFsbEZpbHRlcnMubW9kZWxzW2luZGV4XS5hdHRyaWJ1dGVzLnRhYiA9PT0gdGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlc1tmaWx0ZXJWaWV3XS5uYW1lKSB8fCBcbiAgICBcdFx0ICAodGhpcy5hbGxGaWx0ZXJzLm1vZGVsc1tpbmRleF0uYXR0cmlidXRlcy5ncm91cCA9PT0gdGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlc1tmaWx0ZXJWaWV3XS5uYW1lKSl7XG4gICAgXHRcdFx0ICBjb250YWluZWQgPSB0cnVlO1xuICAgIFx0XHRcdCAgYnJlYWs7XG4gICAgXHRcdCAgfSBcbiAgICBcdCAgfVxuICAgIFx0ICBpZiAoIWNvbnRhaW5lZCkge1xuICAgIFx0XHQgIGRlbGV0ZSB0aGlzLmZpbHRlclZpZXdzSW5zdGFuY2VzW2ZpbHRlclZpZXddO1xuICAgIFx0XHQgIGNvbnRpbnVlO1xuICAgIFx0ICB9XG4gICAgXHRcdCAgXG4gICAgICAgIHZhciB0bXBGaWx0ZXJWaWV3ID0gdGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlc1tmaWx0ZXJWaWV3XTtcbiAgICAgICAgcmVuZGVyaW5nVGl0bGVOdW1iZXIgPSByZW5kZXJpbmdUaXRsZU51bWJlciArIDE7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW5kZXJpbmcgdG9wLWxldmVsLWZpbHRlci12aWV3ICcgKyB0bXBGaWx0ZXJWaWV3Lm5hbWUpOyBDT05TVEFOVElOIC0gY29tbWVudCB0byBiZSByZW1vdmVkIG9uY2UgZmlsdGVycyBzYW5pdGlzYXRpb24gaXMgZG9uZVxuICAgICAgICB0aGlzLiQoJy5maWx0ZXItdGl0bGVzJykuYXBwZW5kKHRtcEZpbHRlclZpZXcucmVuZGVyVGl0bGUoKS50aXRsZUVsKTtcbiAgICAgICAgdmFyIGFjdGl2ZSA9IHJlbmRlcmluZ1RpdGxlTnVtYmVyID09IGFjdGl2ZVRpdGxlTnVtYmVyO1xuICAgICAgICB0aGlzLiQoJy5maWx0ZXItb3B0aW9ucycpLmFwcGVuZCh0bXBGaWx0ZXJWaWV3LnJlbmRlckZpbHRlcnMoYWN0aXZlKS5lbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3BlbnMgdGhlIGZpcnN0IHRhYiBpbiB0aGUgZmlsdGVyXG4gICAgdGhpcy4kKCcuZmlsdGVyLXRpdGxlcyBhOmZpcnN0JykudGFiKCdzaG93Jyk7XG4gIH0sXG5cblxuICBfZ2V0RmlsdGVyTGlzdDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsRmlsdGVycy5sb2FkKCk7XG4gIH0sXG5cbiAgX2NyZWF0ZUZpbHRlclZpZXdzOiBmdW5jdGlvbih0bXBNb2RlbCkge1xuICAgIC8vIFRPRE86IG1hZ2ljIHN0cmluZ3MgYXJlIGRhbmdlcm91cywgY29uZmlnIHNvbWV3aGVyZS4uLlxuICAgIHN3aXRjaCAodG1wTW9kZWwuZ2V0KCdncm91cCcpKSB7XG4gICAgICBjYXNlICdBY3Rpdml0eUJ1ZGdldExpc3QnOlxuICAgICAgY2FzZSAnVHlwZU9mQXNzaXN0YW5jZUxpc3QnOlxuICAgICAgY2FzZSAnTW9kZU9mUGF5bWVudExpc3QnOlxuICAgICAgY2FzZSAnRXhwZW5kaXR1cmVDbGFzc0xpc3QnOlxuICAgICAgY2FzZSAnRmluYW5jaW5nSW5zdHJ1bWVudHNMaXN0JzpcbiAgICAgIGNhc2UgJ0Z1bmRpbmdTdGF0dXMnOlxuICAgICAgY2FzZSAnZWZmZWN0aXZlRnVuZGluZ0RhdGUnOlxuICAgICAgY2FzZSAnZnVuZGluZ0Nsb3NpbmdEYXRlJzpcbiAgICAgICAgdGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlcy5maW5hbmNpYWxzLmZpbHRlckNvbGxlY3Rpb24uYWRkKHRtcE1vZGVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBY3Rpdml0eVN0YXR1c0xpc3QnOlxuICAgICAgY2FzZSAnQWN0aXZpdHlBcHByb3ZhbFN0YXR1cyc6XG4gICAgICAgIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMuYWN0aXZpdHkuZmlsdGVyQ29sbGVjdGlvbi5hZGQodG1wTW9kZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1Byb2dyYW1zJzpcbiAgICAgICAgdGhpcy5maWx0ZXJWaWV3c0luc3RhbmNlcy5wcm9ncmFtcy5maWx0ZXJDb2xsZWN0aW9uLmFkZCh0bXBNb2RlbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnU2VjdG9ycyc6XG4gICAgICAgIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMuc2VjdG9ycy5maWx0ZXJDb2xsZWN0aW9uLmFkZCh0bXBNb2RlbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRG9ub3InOlxuICAgICAgICB0aGlzLmZpbHRlclZpZXdzSW5zdGFuY2VzLmRvbm9ycy5maWx0ZXJDb2xsZWN0aW9uLmFkZCh0bXBNb2RlbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUm9sZSc6XG4gICAgICAgIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMuYWxsQWdlbmNpZXMuZmlsdGVyQ29sbGVjdGlvbi5hZGQodG1wTW9kZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xvY2F0aW9uTGlzdCc6XG4gICAgICAgIHRoaXMuZmlsdGVyVmlld3NJbnN0YW5jZXMubG9jYXRpb25zLmZpbHRlckNvbGxlY3Rpb24uYWRkKHRtcE1vZGVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmZpbHRlclZpZXdzSW5zdGFuY2VzLm90aGVycy5maWx0ZXJDb2xsZWN0aW9uLmFkZCh0bXBNb2RlbCk7XG4gICAgfVxuXG4gIH0sXG4gIFxuICBzZXJpYWxpemVUb01vZGVsczogZnVuY3Rpb24oZmlsdGVyKSB7XG5cdCAgdmFyIF9zZWxmID0gdGhpcztcblx0ICBfc2VsZi52YWx1ZXMgPSB7MDogW10sIDE6IFtdLCAyOiBbXSwgMzogW119OyAvL1RPRE86IEltcGxlbWVudCBjYWxjdWxhdGVGaWx0ZXJEZXB0KCkgZnVuY3Rpb24uXG5cdCAgaWYgKGZpbHRlci5nZXQoJ3RyZWUnKSkge1xuXHRcdCAgdmFyIGVudHJ5UG9pbnQgPSBmaWx0ZXIuZ2V0KCd0cmVlJykuZ2V0KCdjaGlsZHJlbicpO1xuXHRcdCAgdmFyIGN1cnJlbnRMZXZlbCA9IDA7XG5cdFx0ICBpZiAoZmlsdGVyLmdldCgnbnVtU2VsZWN0ZWQnKSAhPT0gZmlsdGVyLmdldCgnbnVtUG9zc2libGUnKSkge1xuXHRcdFx0ICBfLmVhY2goZW50cnlQb2ludC5tb2RlbHMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0ICBfc2VsZi5zZXJpYWxpemVMZXZlbChpdGVtLCAwLCBfc2VsZi52YWx1ZXMpO1xuXHRcdFx0ICB9KTtcblx0XHQgIH1cblx0ICB9IGVsc2Uge1xuXHRcdCAgX3NlbGYudmFsdWVzID0gZmlsdGVyO1xuXHQgIH1cblx0ICByZXR1cm4gX3NlbGYudmFsdWVzO1xuICB9LFxuICAgIFxuICBzZXJpYWxpemVMZXZlbDogZnVuY3Rpb24obm9kZSwgbGV2ZWwsIHZhbHVlcykge1xuXHQvLyBXaGVuIHdlIGVudGVyIGhlcmUgaXQgbWVhbnMgdGhlIHBhcmVudCBpcyBub3QgJ2Z1bGx5IHNlbGVjdGVkJy5cblx0ICB2YXIgX3NlbGYgPSB0aGlzO1xuXHQgIGlmIChub2RlLmdldCgnY2hpbGRyZW4nKS5tb2RlbHMubGVuZ3RoID4gMCkge1xuXHRcdCAgLy8gXCJEb3VibGUgY2hlY2tcIiBiZWNhdXNlIHNvbWUgc2VsZWN0ZWQgbWlkZGxlIG5vZGVzIGhhdmUgZ2V0KCdzZWxlY3RlZCcpID09PSBmYWxzZS4gXG5cdFx0ICBpZiAobm9kZS5nZXQoJ251bVNlbGVjdGVkJykgIT09IG5vZGUuZ2V0KCdudW1Qb3NzaWJsZScpICYmIG5vZGUuZ2V0KCdzZWxlY3RlZCcpID09PSBmYWxzZSkge1xuXHRcdFx0ICBfLmVhY2gobm9kZS5nZXQoJ2NoaWxkcmVuJykubW9kZWxzLCBmdW5jdGlvbihub2RlMikge1x0XHRcdFx0ICBcblx0XHRcdFx0ICBfc2VsZi5zZXJpYWxpemVMZXZlbChub2RlMiwgbGV2ZWwgKyAxLCB2YWx1ZXMpO1xuXHRcdFx0ICB9KTtcblx0XHQgIH0gZWxzZSB7XG5cdFx0XHQgIGlmICh2YWx1ZXNbbGV2ZWxdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ICB2YWx1ZXMgPDwgW107XG5cdFx0XHQgIH1cblx0XHRcdCAgdmFsdWVzW2xldmVsXS5wdXNoKHsnbGV2ZWwnOiBsZXZlbCwgJ2xldmVsTmFtZSc6IG5vZGUuZ2V0KCdmaWx0ZXJJZCcpLCBuYW1lOiBub2RlLmdldCgnbmFtZScpfSk7XG5cdFx0ICB9XG5cdCAgfSBlbHNlIHsgLy8gV2UgcmVhY2hlZCB0aGUgbGFzdCBsZXZlbC4uXG5cdFx0ICBpZiAobm9kZS5nZXQoJ3NlbGVjdGVkJykgPT09IHRydWUpIHtcblx0XHRcdCAgaWYgKHZhbHVlc1tsZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQgIHZhbHVlcyA8PCBbXTtcblx0XHRcdCAgfVxuXHRcdFx0ICB2YWx1ZXNbbGV2ZWxdLnB1c2goeydsZXZlbCc6IGxldmVsLCAnbGV2ZWxOYW1lJzogbm9kZS5nZXQoJ2ZpbHRlcklkJyksIG5hbWU6IG5vZGUuZ2V0KCduYW1lJyl9KTtcblx0XHQgIH1cblx0ICB9XHQgIFxuICB9LFxuICBcbiAgLy9UT0RPOiBtb3ZlIGZyb20gdmlldyB0byBhbGwtY29sbGVjdGlvblxuICBzZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNlcmlhbGl6ZWRGaWx0ZXJzID0geydjb2x1bW5GaWx0ZXJzJzp7fSwgJ290aGVyRmlsdGVycyc6e30gfTtcblxuICAgIHRoaXMuYWxsRmlsdGVycy5lYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgLy8gVE9ETzogYnVpbGQgYSB1dGlsIGZvciBiZXR0ZXJtZXJnZSB0aGF0IGNvbmNhdCdzIGFycmF5IGlmXG4gICAgICAvLyBkdXBsaWNhdGUga2V5cyBpbiBvYmplY3RzLi4uXG4gICAgICBpZiAoZmlsdGVyLmdldCgnaWQnKSB8fCBmaWx0ZXIudXJsKSB7XG4gICAgICAgIGlmIChmaWx0ZXIuZ2V0KCdtb2RlbFR5cGUnKSA9PT0gJ0RBVEUtUkFOR0UtVkFMVUVTJykge1xuICAgICAgICAgIF8uZXh0ZW5kKHNlcmlhbGl6ZWRGaWx0ZXJzLm90aGVyRmlsdGVycywgZmlsdGVyLnNlcmlhbGl6ZShvcHRpb25zKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyLmdldCgnbW9kZWxUeXBlJykgPT09ICdZRUFSLVNJTkdMRS1WQUxVRScpIHtcbiAgICAgICAgICAgIF8uZXh0ZW5kKHNlcmlhbGl6ZWRGaWx0ZXJzLm90aGVyRmlsdGVycywgZmlsdGVyLnNlcmlhbGl6ZShvcHRpb25zKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBmaWx0ZXIuc2VyaWFsaXplKG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChvcHRpb25zLndob2xlTW9kZWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IodmFyIGsgaW4gc2VyaWFsaXplZCkga2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgaWYgKGtleXNbMF0gIT09IHVuZGVmaW5lZCAmJiBzZXJpYWxpemVkW2tleXNbMF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc2VyaWFsaXplZFtrZXlzWzBdXS5maWx0ZXJOYW1lID0gKGZpbHRlci5nZXQoJ2Rpc3BsYXlOYW1lJykgfHwgZmlsdGVyLmdldCgnbmFtZScpKTtcbiAgICAgICAgICAgICAgc2VyaWFsaXplZFtrZXlzWzBdXS5zZXJpYWxpemVkVG9Nb2RlbHMgPSBzZWxmLnNlcmlhbGl6ZVRvTW9kZWxzKGZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF8uZXh0ZW5kKHNlcmlhbGl6ZWRGaWx0ZXJzLmNvbHVtbkZpbHRlcnMsIHNlcmlhbGl6ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvL3JlbW92ZSBlbXB0eSAvIGZhbHNlIHZhbHVlcy5cbiAgICBfLmVhY2goc2VyaWFsaXplZEZpbHRlcnMsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgIGlmKCF2IHx8IF8uaXNFbXB0eSh2KSkge1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZEZpbHRlcnNba107XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2VyaWFsaXplZEZpbHRlcnM7XG4gIH0sXG4gZGVzZXJpYWxpemU6IGZ1bmN0aW9uKGJsb2IsIG9wdGlvbnMpIHtcbiAgICBpZiAoYmxvYikge1xuICAgICAgaWYoXy5pc1VuZGVmaW5lZCh0aGlzLmluaXRpYWxGaWx0ZXJzKSl7XG4gICAgXHQgIHRoaXMuaW5pdGlhbEZpbHRlcnMgPSBibG9iO1xuICAgICAgfSAgICAgXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGF0LmFsbEZpbHRlcnMuZWFjaChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgaWYgKGZpbHRlci5nZXQoJ2lkJykgfHwgZmlsdGVyLnVybCkge1xuICAgICAgICAgIGlmKGZpbHRlci5nZXQoJ21vZGVsVHlwZScpID09PSAnREFURS1SQU5HRS1WQUxVRVMnKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0VtcHR5KGJsb2Iub3RoZXJGaWx0ZXJzKSl7IFxuICAgICAgICAgICAgXHR0aGF0LnNldERlZmF1bHREYXRlcyhibG9iKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgICAgIGZpbHRlci5kZXNlcmlhbGl6ZShibG9iLm90aGVyRmlsdGVycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXIuZ2V0KCdtb2RlbFR5cGUnKSA9PT0gJ1lFQVItU0lOR0xFLVZBTFVFJykge1xuICAgICAgICBcdCAgZmlsdGVyLmRlc2VyaWFsaXplKGJsb2Iub3RoZXJGaWx0ZXJzKTsgIFxuICAgICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgIGZpbHRlci5kZXNlcmlhbGl6ZShibG9iLmNvbHVtbkZpbHRlcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignY291bGQgbm90IGRlc2VyaWFsaXplIGJsb2I6JywgYmxvYik7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIHRoaXMuYXBwbHlGaWx0ZXJzKCk7ICAvLyB0cmlnZ2VycyB0aGUgXCJhcHBseVwiIGV2ZW50XG4gICAgfVxuICB9LFxuXG4gIHNob3dGaWx0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbmRlcigpO1xuICAgIHRoaXMuZmlsdGVyU3Rhc2ggPSBudWxsOyAgLy8gaW4gY2FzZSB0aGV5IGhhdmVuJ3QgbG9hZGVkIHlldCwgZG9uJ3QgdHJ5IHRvIC5zZXJpYWxpemUoKVxuICAgIHRoaXMuX2xvYWRlZC5kb25lKF8uYmluZChmdW5jdGlvbigpIHsgdGhpcy5maWx0ZXJTdGFzaCA9IHRoaXMuc2VyaWFsaXplKHt9KTsgfSwgdGhpcykpO1xuICB9LFxuXG4gIHNldFN0YXNoOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZpbHRlclN0YXNoID0gbnVsbDsgIC8vIGluIGNhc2UgdGhleSBoYXZlbid0IGxvYWRlZCB5ZXQsIGRvbid0IHRyeSB0byAuc2VyaWFsaXplKClcbiAgICB0aGlzLl9sb2FkZWQuZG9uZShfLmJpbmQoZnVuY3Rpb24oKSB7IHRoaXMuZmlsdGVyU3Rhc2ggPSB0aGlzLnNlcmlhbGl6ZSh7fSk7IH0sIHRoaXMpKTtcbiAgfSxcblxuICByZXNldEZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdCB2YXIgYmxvYiA9ICFfLmlzVW5kZWZpbmVkKHRoaXMuaW5pdGlhbEZpbHRlcnMpID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxGaWx0ZXJzKSkgOiB7fTsvL2Nsb25lIGluaXRpYWwgZmlsdGVyc1xuICAgIHRoaXMuYWxsRmlsdGVycy5lYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIuZ2V0KCdtb2RlbFR5cGUnKSA9PT0gJ0RBVEUtUkFOR0UtVkFMVUVTJykge1xuICAgIFx0IGlmIChfLmlzRW1wdHkoYmxvYi5vdGhlckZpbHRlcnMpKXsgXG4gICAgXHRcdCBzZWxmLnNldERlZmF1bHREYXRlcyhibG9iKTtcbiAgICAgICAgIH0gICBcdCBcbiAgICBcdCBmaWx0ZXIuZGVzZXJpYWxpemUoYmxvYi5vdGhlckZpbHRlcnMpO1xuICAgICB9ZWxzZXtcbiAgICBcdCBmaWx0ZXIucmVzZXQoKTtcbiAgICAgfSAgICAgIFxuICAgIH0pO1xuICB9LFxuXG4gIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbG9hZGVkLmRvbmUoXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zZXJpYWxpemUoe30pO1xuICAgICAgdGhpcy50cmlnZ2VyKCdhcHBseScsIHN0YXRlKTtcbiAgICB9LCB0aGlzKSk7XG4gIH0sXG5cbiAgZ2V0RGF0ZUZvcm1hdDogZnVuY3Rpb24oKXtcblx0ICBpZih0aGlzLmRGb3JtYXQpe1xuXHRcdCAgcmV0dXJuIHRoaXMuZEZvcm1hdDtcblx0ICB9XHRcblx0ICBcblx0ICB2YXIgZGF0ZUZvcm1hdFNldHRpbmcgPSB0aGlzLnNldHRpbmdzLmZpbmRXaGVyZSh7IGlkOiAnZGVmYXVsdC1kYXRlLWZvcm1hdCcgfSk7XG5cdCAgaWYoZGF0ZUZvcm1hdFNldHRpbmcgJiYgZGF0ZUZvcm1hdFNldHRpbmcuZ2V0KFwib3B0aW9uc1wiKSAmJiBkYXRlRm9ybWF0U2V0dGluZy5nZXQoXCJvcHRpb25zXCIpLmxlbmd0aCA+IDApe1x0XHRcdFxuXHRcdFx0dmFyIGZvdW5kTWFwcGluZyA9Xy5maW5kV2hlcmUodGhpcy5kYXRlRm9ybWF0TWFwcGluZ3MsIHthbXBmb3JtYXQ6IGRhdGVGb3JtYXRTZXR0aW5nLmdldChcIm9wdGlvbnNcIilbMF0ubmFtZX0pO1xuXHRcdFx0aWYoZm91bmRNYXBwaW5nKXtcblx0XHRcdFx0dGhpcy5kRm9ybWF0ID0gZm91bmRNYXBwaW5nLmRhdGVwaWNrZXJmb3JtYXQ7XG5cdFx0XHR9XG5cdCAgfVx0ICBcblx0ICBpZighdGhpcy5kRm9ybWF0KXtcblx0XHQgIHRoaXMuZEZvcm1hdCA9IHRoaXMuUEFSQU1TX0RBVEVfRk9STUFUO1xuXHQgIH1cdCAgXG5cdCAgcmV0dXJuIHRoaXMuZEZvcm1hdDtcbiAgIH0sXG4gIFxuICAgZm9ybWF0RGF0ZTogZnVuY3Rpb24oZGF0ZSl7XG5cdCAgIHJldHVybiAkLmRhdGVwaWNrZXIuZm9ybWF0RGF0ZSh0aGlzLmdldERhdGVGb3JtYXQoKSwgKCQuZGF0ZXBpY2tlci5wYXJzZURhdGUodGhpcy5QQVJBTVNfREFURV9GT1JNQVQsZGF0ZSkpKTtcbiAgIH0sIFxuICAgc2V0RGVmYXVsdERhdGVzOiBmdW5jdGlvbihibG9iKXtcblx0IHZhciBzZWxmID0gdGhpcztcbiAgXHQgaWYoc2VsZi5jYWxsZXIgPT09IFwiREFTSEJPQVJEXCIpe1xuICBcdFx0IHJldHVybiBEYXRlVXRpbHMuZXh0cmFjdERhdGVzKHNlbGYuc2V0dGluZ3MubW9kZWxzLCBibG9iLCAnZGFzaGJvYXJkLWRlZmF1bHQtbWluLWRhdGUnLCAnZGFzaGJvYXJkLWRlZmF1bHQtbWF4LWRhdGUnKTsgXHQgXG4gIFx0IH1lbHNlIGlmKHNlbGYuY2FsbGVyID09PSBcIkdJU1wiKXtcbiAgXHRcdHJldHVybiBEYXRlVXRpbHMuZXh0cmFjdERhdGVzKHNlbGYuc2V0dGluZ3MubW9kZWxzLCBibG9iLCAnZ2lzLWRlZmF1bHQtbWluLWRhdGUnLCAnZ2lzLWRlZmF1bHQtbWF4LWRhdGUnKTtcbiAgXHQgfVxuICBcdCByZXR1cm4gYmxvYlxuICAgfSxcbiAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLmZpbHRlclN0YXNoKXtcbiAgICAgIHRoaXMuZGVzZXJpYWxpemUodGhpcy5maWx0ZXJTdGFzaCwge3NpbGVudDogdHJ1ZX0pO1xuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIoJ2NhbmNlbCcsIHRoaXMuZmlsdGVyU3Rhc2gpO1xuICB9XG59KTtcblxuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuLy8gdmFyIEdlbmVyaWNGaWx0ZXJNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVscy9nZW5lcmljLWZpbHRlci1tb2RlbCcpO1xudmFyIFRyZWVOb2RlVmlldyA9IHJlcXVpcmUoJy4uL3RyZWUvdHJlZS1ub2RlLXZpZXcnKTtcbnZhciBCYXNlRmlsdGVyVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL2Jhc2UtZmlsdGVyLXZpZXcnKTtcbnZhciBUZW1wbGF0ZSA9IFwiPCUgaWYgKCFlbXB0eSkgeyAlPlxcblxcdDxkaXYgY2xhc3M9XFxcInNlYXJjaC1mb3JtXFxcIj5cXG5cXHQgIDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwIGZvcm0tZ3JvdXBcXFwiPlxcblxcdCAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgZGF0YS1pMThuPVxcXCJbcGxhY2Vob2xkZXJdYW1wLmdpczpwYW5lLWZpbHRlcnMtc2VhcmNoLXBsYWNlaG9sZGVyXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHNlYXJjaC10ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiU2VhcmNoLi4uXFxcIj5cXG5cXHQgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0blxcXCI+XFxuXFx0ICAgICAgPGJ1dHRvbiBkYXRhLWkxOG49XFxcImFtcC5naXM6cGFuZS1maWx0ZXJzLXNlYXJjaFxcXCIgY2xhc3M9XFxcImJ0biBidG4tc3VjY2Vzc1xcXCI+R288L2J1dHRvbj5cXG5cXHQgICAgPC9zcGFuPlxcblxcdCAgPC9kaXY+PCEtLSAvaW5wdXQtZ3JvdXAgLS0+XFxuXFx0PC9kaXY+XFxuXFx0PGRpdiBjbGFzcz1cXFwidG9nZ2xlLWFsbFxcXCI+XFxuXFx0ICA8ZW0+XFxuXFx0ICAgIDxhIGhyZWY9XFxcIiNcXFwiIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtc2VsZWN0XFxcIiBjbGFzcz1cXFwic2VsZWN0LWFsbFxcXCIgPnNlbGVjdCBhbGw8L2E+IC9cXG5cXHQgICAgPGEgaHJlZj1cXFwiI1xcXCIgIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpwYW5lLWZpbHRlcnMtZGVzZWxlY3RcXFwiIGNsYXNzPVxcXCJzZWxlY3Qtbm9uZVxcXCIgPmRlc2VsZWN0IGFsbDwvYT5cXG5cXHQgIDwvZW0+XFxuXFx0PC9kaXY+XFxuXFx0XFxuXFx0PGRpdiBjbGFzcz1cXFwidHJlZSB0cmVlLWNvbnRhaW5lclxcXCIgc3R5bGU9XFxcIlxcXCI+PC9kaXY+PCEtLWRpc3BsYXk6bm9uZTstLT5cXG48JSB9IGVsc2UgeyAlPlxcblxcdDxzcGFuIGRhdGEtaTE4bj0nYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtZW1wdHknPjwvc3Bhbj5cXG48JSB9ICU+XFxuXCI7XG5cblxuLy8gVGhpcyBpcyBhIGdlbmVyaWMgbW9kZWwgZm9yIGZpbHRlcnMuIEl0IGFzc3VtZXMgYSB0cmVlIHN0cnVjdHVyZS5cbi8vIElmIHlvdSBkb24ndCB3YW50IGEgdHJlZSBzdHJ1Y3R1cmUganVzdCBleHRlbmQgYmFzZS1maWx0ZXJcbm1vZHVsZS5leHBvcnRzID0gQmFzZUZpbHRlclZpZXcuZXh0ZW5kKHtcblxuICBjbGFzc05hbWU6IEJhc2VGaWx0ZXJWaWV3LnByb3RvdHlwZS5jbGFzc05hbWUgKyAnIGZpbHRlci1nZW5lcmljJyxcbiAgdGVtcGxhdGU6IF8udGVtcGxhdGUoVGVtcGxhdGUpLFxuICBfbG9hZGVkOiBudWxsLFxuXG4gIGV2ZW50czp7XG4gICAgLy8gYXR0YWNoIGluIGZpbHRlciByZW5kZXIgaW5zdGVhZCBzaW5jZSB0aGVzZSBldmVudHMgYXJlIGF0dGFjaGVkIHRvIHRoZSBlbCBvYmplY3RcbiAgICAvLyBhbmQgdGhlbiBuYW1lc3BhY2VkLiB0aGlzIG1lYW5zIHRoYXQgdGhlIHdheSB3ZSByZS11c2VcbiAgICAvLyBET00gZWxlbWVudHMgd2lsbCBhY2NpZGVudGFsbHkgdHJpZ2dlciBtdWx0aXBsZSBldmVudHMuXG4gICAgLy8gJ2NsaWNrICAuc2VsZWN0LWFsbCc6ICdfc2VsZWN0QWxsJyxcbiAgICAvLyAnY2xpY2sgIC5zZWxlY3Qtbm9uZSc6ICdfc2VsZWN0Tm9uZScsXG4gICAgLy8na2V5dXAgaW5wdXQuc2VhcmNoLXRleHQnOiAnc2VhcmNoS2V5VXAnXG4gIH0sXG5cbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEJhc2VGaWx0ZXJWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG5cbiAgICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICB0aGlzLnRyYW5zbGF0b3IgPSBvcHRpb25zLnRyYW5zbGF0b3I7XG4gICAgdGhpcy50cmFuc2xhdGUgPSBvcHRpb25zLnRyYW5zbGF0ZTtcbiAgICB0aGlzLnRyZWVWaWV3ID0gbmV3IFRyZWVOb2RlVmlldyh7aXNSb290OnRydWV9KTtcblxuICAgIC8vIENyZWF0ZSB0cmVlIHZpZXdcbiAgICAvLyBUT0RPOiBtYWtlIHRyZWUgbG9hZGluZyBjb250ZW50IHJlc3BvbnNpYmlsaXR5IG9mIG1vZGVsLCBub3Qgdmlldy4uLlxuICAgIHRoaXMubW9kZWwuZ2V0VHJlZSgpLnRoZW4oZnVuY3Rpb24odHJlZU1vZGVsKSB7XG4gICAgICBpZiAodHJlZU1vZGVsKSB7XG4gICAgICAgIHNlbGYuX3VwZGF0ZUNvdW50SW5NZW51KCk7XG4gICAgICAgIHRyZWVNb2RlbC5vbignY2hhbmdlOm51bVNlbGVjdGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5fdXBkYXRlQ291bnRJbk1lbnUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ25vIHRyZWUgZm9yOiAnLCBzZWxmLm1vZGVsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBzZWFyY2hLZXlVcDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMgfHwgLy8gUHJlc3NlZCAnZW50ZXInXG4gICAgICB0aGlzLiQoJy5zZWFyY2gtdGV4dCcpLnZhbCgpID09PSAnJyB8fFxuICAgICAgdGhpcy4kKCcuc2VhcmNoLXRleHQnKS52YWwoKS5sZW5ndGggPiAxXG4gICAgICApIHtcbiAgICAgIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuZmlsdGVyVGV4dCh0aGlzLiQoJy5zZWFyY2gtdGV4dCcpLnZhbCgpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgfSxcblxuXG4gIF91cGRhdGVDb3VudEluTWVudTpmdW5jdGlvbigpIHtcdFxuICAgIGlmICh0aGlzLiR0aXRsZUVsICYmIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykpIHtcbiAgICAgIGlmICh0aGlzLm1vZGVsLmdldCgndHJlZScpLmdldCgnbnVtU2VsZWN0ZWQnKSA9PT0gdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5nZXQoJ251bVBvc3NpYmxlJykgfHxcbiAgICAgICAgICB0aGlzLm1vZGVsLmdldCgndHJlZScpLmdldCgnbnVtU2VsZWN0ZWQnKSA9PT0gMCkgeyAgICBcdCAgXG4gICAgXHQgIHRoaXMuJHRpdGxlRWwuZmluZCgnLmZpbHRlci1jb3VudCcpLmF0dHIoJ2RhdGEtaTE4bicsJ2FtcC5naXM6cGFuZS1maWx0ZXJzLWFsbCcpO1xuICAgIFx0ICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7ICAgICBcdCAgXG4gICAgXHQgIHRoaXMudHJhbnNsYXRlKHRoaXMuJHRpdGxlRWwuZmluZCgnLmZpbHRlci1jb3VudCcpLnBhcmVudCgpKTtcbiAgICAgIH0gZWxzZSB7ICAgIFx0XG4gICAgICAgIHRoaXMuJHRpdGxlRWwuZmluZCgnLmZpbHRlci1jb3VudCcpLnRleHQodGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5nZXQoJ251bVNlbGVjdGVkJykgK1xuICAgICAgICAgICcvJyArXG4gICAgICAgICAgdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5nZXQoJ251bVBvc3NpYmxlJykpO1xuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIHRoaXMuJHRpdGxlRWwuZmluZCgnLmZpbHRlci1jb3VudCcpLmF0dHIoJ2RhdGEtaTE4bicsJycpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcdFxuICByZW5kZXJUaXRsZSA6IGZ1bmN0aW9uKCkge1x0ICBcblx0ICBCYXNlRmlsdGVyVmlldy5wcm90b3R5cGUucmVuZGVyVGl0bGUuYXBwbHkodGhpcyk7XG5cdCAgdGhpcy5fdXBkYXRlQ291bnRJbk1lbnUoKTtcblx0ICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW5kZXJGaWx0ZXJzOmZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBCYXNlRmlsdGVyVmlldy5wcm90b3R5cGUucmVuZGVyRmlsdGVycy5hcHBseSh0aGlzKTtcblxuICAgIHRoaXMubW9kZWwuZ2V0VHJlZSgpLnRoZW4oZnVuY3Rpb24odHJlZU1vZGVsKSB7XG4gICAgICBzZWxmLiRlbC5odG1sKHNlbGYudGVtcGxhdGUoc2VsZi5tb2RlbC50b0pTT04oKSkpO1xuXG4gICAgICAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICBzZWxmLiQoJy5zZWxlY3Qtbm9uZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge3NlbGYuX3NlbGVjdE5vbmUoKTsgcmV0dXJuIGZhbHNlO30pOyAvL3JldHVybiBmYWxzZSB0byBzdG9wIHBhZ2UgcmVmcmVzaC5cbiAgICAgIHNlbGYuJCgnLnNlbGVjdC1hbGwnKS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtzZWxmLl9zZWxlY3RBbGwoKTsgcmV0dXJuIGZhbHNlO30pOyAvL3JldHVybiBmYWxzZSB0byBzdG9wIHBhZ2UgcmVmcmVzaC5cbiAgICAgIHNlbGYuJCgnaW5wdXQuc2VhcmNoLXRleHQnKS5vbigna2V5dXAnLCBmdW5jdGlvbihldmVudCkge3NlbGYuc2VhcmNoS2V5VXAoZXZlbnQpO30pO1xuXG4gICAgICBpZiAodHJlZU1vZGVsKSB7XG4gICAgICAgIHNlbGYuJCgnLnRyZWUtY29udGFpbmVyJykuYXBwZW5kKHNlbGYudHJlZVZpZXcucmVuZGVyKHNlbGYubW9kZWwuZ2V0KCd0cmVlJykpLiRlbCk7XG4gICAgICAgIHRyZWVNb2RlbC5zZXQoJ2V4cGFuZGVkJywgdHJ1ZSk7XG4gICAgICAgIHRyZWVNb2RlbC5maWx0ZXJUZXh0KCcnKTsvL2RlZmF1bHQgbm8gZmlsdGVyLlxuICAgICAgfSBlbHNle1xuICAgICAgICBzZWxmLiQoJy50cmVlLWNvbnRhaW5lcicpLmFwcGVuZChcIlwiKTtcbiAgICAgIH1cbiAgICB9KVxuICAgIC5kb25lKGZ1bmN0aW9uKCkge1xuICAgIFx0c2VsZi50cmFuc2xhdGUoc2VsZik7XG4gICAgfSlcbiAgICAuZmFpbChmdW5jdGlvbigpe1xuICAgICAgY29uc29sZS5lcnJvcigncmVuZGVyRmlsdGVycyBmYWlsZWQgOignKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9zZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgIC8vIGZvcmNlIHRyaWdnZXIgZXZlbiBpZiBhbHJlYWR5IHRoaXMgc3RhdGUgKGltcG9ydGFudCBmb3IgaGFsZi1maWxsIHVpXG4gICAgdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5zZXQoJ3NlbGVjdGVkJywgZmFsc2UpO1xuICAgIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuc2V0KCdzZWxlY3RlZCcsIHRydWUpO1xuICAgIC8vdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5zZXQoJ3NlbGVjdGVkJywgdHJ1ZSwge3NpbGVudDogdHJ1ZSB9KTtcbiAgICAvLy5tb2RlbC5nZXQoJ3RyZWUnKS50cmlnZ2VyKCdjaGFuZ2U6c2VsZWN0ZWQnLCB0aGlzLm1vZGVsLmdldCgndHJlZScpLCBudWxsLCB7cHJvcG9nYXRpb246ZmFsc2V9KTtcbiAgfSxcblxuICBfc2VsZWN0Tm9uZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gZm9yY2UgdHJpZ2dlciBldmVuIGlmIGFscmVhZHkgdGhpcyBzdGF0ZSAoaW1wb3J0YW50IGZvciBoYWxmLWZpbGwgdWkpXG4gICAgdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5zZXQoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKS5zZXQoJ3NlbGVjdGVkJywgZmFsc2UpO1xuICAgIC8vIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykuc2V0KCdzZWxlY3RlZCcsIGZhbHNlLCB7c2lsZW50OiB0cnVlIH0pO1xuICAgIC8vIHRoaXMubW9kZWwuZ2V0KCd0cmVlJykudHJpZ2dlcignY2hhbmdlOnNlbGVjdGVkJywgdGhpcy5tb2RlbC5nZXQoJ3RyZWUnKSwgbnVsbCwge3Byb3BvZ2F0aW9uOmZhbHNlfSk7XG4gIH1cblxufSk7XG5cbiIsIlxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xudmFyIFRpdGxlVGVtcGxhdGUgPSBcIjwlXFxuLy8gcmVuZGVycyB0aGUgdGl0bGUgb2YgYSB0YWIgXFxuJT5cXG48bGkgY2xhc3M9XFxcIlxcXCI+PGEgZGF0YS1pMThuPVxcXCJhbXAuZ2lzOnBhbmUtZmlsdGVycy08JT0gbmFtZS5yZXBsYWNlKC8gL2csJycpICU+XFxcIiBocmVmPVxcXCIjZmlsdGVyLXBhbmUtPCU9IG5hbWUucmVwbGFjZSgvIC9nLCcnKSAlPlxcXCIgcm9sZT1cXFwidGFiXFxcIiBkYXRhLXRvZ2dsZT1cXFwidGFiXFxcIj48JT0gbmFtZSAlPjwvYT48L2xpPlxcblwiO1xudmFyIENvbnRlbnRUZW1wbGF0ZSA9IFwiPCVcXG4gLy8gcmVuZGVycyB0aGUgY29udGVudHMgb2YgYSBmaWx0ZXIncyB0YWIgKGUuZy4gZm9yIGV4YW1wbGUgdGhlIFxcXCJDb250cmFjdGluZyAvIEltcGxlbWVudGluZyAvIEV4ZWN1dGluZyAvIFByaW1hcnkgQmVuZWZpY2lhcnkgLyBTZWNvbmRhcnkgQmVuZWZpY2lhcnkgQWdlbmN5XFxcIiBsaXN0IG9mIHRoZSBcXFwiQWxsIEFnZW5jaWVzXFxcIiB0YWIpXFxuIC8vIDxoNj5tZGUgICUtIE1hdGgucmFuZG9tKCkgPC9oNj5cXG4lPlxcbjx1bCBjbGFzcz1cXFwic3ViLWZpbHRlcnMtdGl0bGVzIG5hdiBuYXYtcGlsbHMgbmF2LXN0YWNrZWRcXFwiPlxcbjwvdWw+XFxuPGRpdiBjbGFzcz1cXFwic3ViLWZpbHRlcnMtY29udGVudFxcXCI+XFxuICA8aW1nIHNyYz1cXFwiaW1nXzIvbG9hZGluZy1pY29uLmdpZlxcXCIgLz5cXG48L2Rpdj5cXG5cIjtcblxudmFyIEdlbmVyaWNGaWx0ZXJWaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvZ2VuZXJpYy1maWx0ZXItdmlldycpO1xudmFyIFllYXJzRmlsdGVyVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL3llYXJzLWZpbHRlci12aWV3Jyk7XG52YXIgWWVhcnNPbmx5RmlsdGVyVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL3llYXJzLW9ubHktZmlsdGVyLXZpZXcnKTtcblxudmFyIFllYXJzRmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMveWVhcnMtZmlsdGVyLW1vZGVsJyk7XG52YXIgWWVhcnNPbmx5RmlsdGVyTW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMveWVhcnMtb25seS1maWx0ZXItbW9kZWwnKTtcblxudmFyIGZpbHRlcnNWaWV3TG9nID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL3JlYW1wL3Rvb2xzL2xvZ1wiKSgnYW1wOmZpbHRlcnM6dG9wLWxldmVsOnZpZXcnKTtcbnZhciBTZXR0aW5nc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9zZXR0aW5ncy1jb2xsZWN0aW9uJyk7XG5cbi8vVE9ETzogcmVuYW1lIHRvICdncm91cCcgdG8gYmUgY29uc2lzdGVudFxuLy8gUGFyZW50IGJhc2UgdmlldyBmb3IgZmlsdGVycy5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICBjbGFzc05hbWU6ICAndGFiLXBhbmUnLFxuICB0aXRsZVRlbXBsYXRlOiBfLnRlbXBsYXRlKFRpdGxlVGVtcGxhdGUpLFxuICBjb250ZW50VGVtcGxhdGU6IF8udGVtcGxhdGUoQ29udGVudFRlbXBsYXRlKSxcbiAgZmlsdGVyQ29sbGVjdGlvbjogbnVsbCxcbiAgdmlld0xpc3Q6W10sXG4gIG5hbWU6ICd0YmQnLFxuXG4gIGluaXRpYWxpemU6ZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gb3B0aW9ucy50cmFuc2xhdG9yO1xuICAgIHRoaXMudHJhbnNsYXRlID0gb3B0aW9ucy50cmFuc2xhdGU7XG4gICAgdGhpcy5maWx0ZXJWaWV3ID0gb3B0aW9ucy5maWx0ZXJWaWV3OyBcbiAgICB0aGlzLmZpbHRlckNvbGxlY3Rpb24gPSBuZXcgQmFja2JvbmUuQ29sbGVjdGlvbigpOyAgICBcbiAgICB0aGlzLmZpbHRlckNvbGxlY3Rpb24ub24oJ2NoYW5nZTpudW1TZWxlY3RlZCcsIGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLl9yZWZyZXNoVGl0bGUoKTtcbiAgICB9KTtcbiAgfSxcblxuICBjbGVhbnVwVW51c2VkVGFiczogZnVuY3Rpb24oKSB7XG5cdCAgY29uc29sZS5sb2codGhpcyk7XG4vL1x0ZGVidWdnZXIoc2VsZik7XG4gIH0sXG4gIFxuICBcbiAgLyoqXG4gICAqIHJlbmRlcnMgdGhlIGl0ZW1zIGluIGEgdGFiXG4gICAqIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSB0YWIncyBjb250ZW50cyB3aWxsIGJlIHJlbmRlcmVkIElGRiBvcHRpb25zLnJlbmRlckZpcnN0RWxlbWVudCBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICovXG4gIHJlbmRlckZpbHRlcnM6IGZ1bmN0aW9uKHJlbmRlckZpcnN0RWxlbWVudCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdmlldyA9IG51bGw7XG4gICAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLiRlbC5hdHRyKCdpZCcsICdmaWx0ZXItcGFuZS0nICsgdGhpcy5uYW1lLnJlcGxhY2UoLyAvZywnJykpO1xuICAgIHRoaXMuJGVsLmh0bWwodGhpcy5jb250ZW50VGVtcGxhdGUoKSk7XG4gICAgLy8gcmVuZGVycyB0aGUgdGFicyBvZiB0aGUgZmlsdGVyIChvbmUgdGFiIGZvciBlYWNoIGZpbHRlckNvbGxlY3Rpb24gZWxlbWVudClcbiAgICB0aGlzLmZpbHRlckNvbGxlY3Rpb24uZWFjaChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgIGZpbHRlcnNWaWV3TG9nLm9uRGVidWcoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gQ29uc3RhbnRpbjogaGFybWxlc3MgZGVidWcgbWVzc2FnZSB0byBiZSByZW1vdmVkIG9uY2UgdGhlIGZpbHRlcnMgc2FuaXRpc2F0aW9uIGlzIGRvbmVcbiAgICAgICAgLy8gQENvbnN0YW50aW4sIHdlIGNhbiBkbyBiZXR0ciB0aGFuIHRoaXMsIHNlbnBhaSFcbiAgICAgICAgLy9maWx0ZXJzVmlld0xvZy5sb2coJ3JlbmRlcmluZyBmaWx0ZXInLCBmaWx0ZXIuZ2V0KCduYW1lJykpO1xuICAgICAgfSk7XG4gICAgXHRpZiAoZmlsdGVyIGluc3RhbmNlb2YgWWVhcnNGaWx0ZXJNb2RlbCkgeyAgICBcdFx0XG4gICAgXHRcdHZpZXcgPSBuZXcgWWVhcnNGaWx0ZXJWaWV3KHtcbiAgICBcdFx0XHRtb2RlbDpmaWx0ZXIsXG4gICAgXHRcdFx0ZWw6IHNlbGYuJCgnLnN1Yi1maWx0ZXJzLWNvbnRlbnQnKSxcbiAgICBcdFx0XHR0cmFuc2xhdG9yOiBzZWxmLnRyYW5zbGF0b3IsXG4gICAgXHRcdFx0dHJhbnNsYXRlOiBzZWxmLnRyYW5zbGF0ZSxcbiAgICBcdFx0XHRmaWx0ZXJWaWV3OiBzZWxmLmZpbHRlclZpZXcgICAgXHRcdFx0XG4gICAgXHRcdH0pO1xuICAgIFx0XHRzZWxmLnZpZXdMaXN0LnB1c2godmlldyk7XG4gICAgXHR9IGVsc2UgaWYgKGZpbHRlciBpbnN0YW5jZW9mIFllYXJzT25seUZpbHRlck1vZGVsKSB7XG4gICAgXHRcdHZpZXcgPSBuZXcgWWVhcnNPbmx5RmlsdGVyVmlldyh7XG4gICAgXHRcdFx0bW9kZWw6ZmlsdGVyLFxuICAgIFx0XHRcdGVsOiBzZWxmLiQoJy5zdWItZmlsdGVycy1jb250ZW50JyksXG4gICAgXHRcdFx0dHJhbnNsYXRvcjogc2VsZi50cmFuc2xhdG9yLFxuICAgIFx0XHRcdHRyYW5zbGF0ZTogc2VsZi50cmFuc2xhdGUsXG4gICAgXHRcdFx0ZmlsdGVyVmlldzogc2VsZi5maWx0ZXJWaWV3ICAgIFx0XHRcdFxuICAgIFx0XHR9KTtcbiAgICBcdFx0c2VsZi52aWV3TGlzdC5wdXNoKHZpZXcpO1xuICAgIFx0fSBlbHNlIHtcbiAgICBcdFx0dmlldyA9IG5ldyBHZW5lcmljRmlsdGVyVmlldyh7XG4gICAgXHRcdFx0bW9kZWw6ZmlsdGVyLFxuICAgIFx0XHRcdGVsOiBzZWxmLiQoJy5zdWItZmlsdGVycy1jb250ZW50JyksXG4gICAgXHRcdFx0dHJhbnNsYXRvcjogc2VsZi50cmFuc2xhdG9yLFxuICAgIFx0XHRcdHRyYW5zbGF0ZTogc2VsZi50cmFuc2xhdGVcbiAgICBcdFx0fSk7XG4gICAgXHRcdHNlbGYudmlld0xpc3QucHVzaCh2aWV3KTtcbiAgICBcdH1cblxuICAgIFx0dmFyIHRpdGxlRWxlbSA9IHZpZXcucmVuZGVyVGl0bGUoKS4kdGl0bGVFbDtcbiAgICBcdHNlbGYuJCgnLnN1Yi1maWx0ZXJzLXRpdGxlcycpLmFwcGVuZCh0aXRsZUVsZW0pO1xuXG4gICAgXHQvLyBoYWNreSB3YXkgdG8gb3BlbiBmaXJzdCBvbmUgZm9yIG5vdy5cbiAgICBcdGlmIChmaXJzdCAmJiByZW5kZXJGaXJzdEVsZW1lbnQpIHtcbiAgICBcdFx0Zmlyc3QgPSBmYWxzZTtcbiAgICBcdFx0dmlldy5yZW5kZXJGaWx0ZXJzKCk7XG4gICAgXHRcdHNlbGYuJCgnLnN1Yi1maWx0ZXJzLXRpdGxlcyBsaTpmaXJzdCcpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICBcdH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBXZSBuZWVkIHRvIHJlLXRyYW5zbGF0ZSBzb21lIHN0cmluZ3MgZnJvbSB0aGUgcmlnaHQgcGFuZWwuXG5cdHNlbGYudHJhbnNsYXRlKHRoaXMpO1xuXG4gICBcdHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9yZWZyZXNoVGl0bGU6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRvdGFsU2VsZWN0ZWQgPSAwO1xuICAgIHZhciBjb3VudFN0ciA9Jyc7XG5cbiAgICB0aGlzLmZpbHRlckNvbGxlY3Rpb24uZWFjaChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgIGlmKGZpbHRlci5nZXROdW1TZWxlY3RlZCl7XG4gICAgICAgIHRvdGFsU2VsZWN0ZWQgKz0gZmlsdGVyLmdldE51bVNlbGVjdGVkKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiggdG90YWxTZWxlY3RlZCAhPT0gMCkge1xuICAgICAgY291bnRTdHIgPSB0b3RhbFNlbGVjdGVkO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHNob3VsZCBiZSBsb2NhbGx5IHNjb3BlZCwgbm90IGdsb2JhbCBqcXVlcnkuXG4gICAgJCgnIycrdGhpcy5uYW1lLnJlcGxhY2UoLyAvZywnJykgKyAnIC50aXRsZS1jb3VudCcpLnRleHQoY291bnRTdHIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZW5kZXJzIHRoZSB0aXRsZSBvZiBhIHRhYlxuICAgKi9cbiAgcmVuZGVyVGl0bGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGl0bGVFbCA9IHRoaXMudGl0bGVUZW1wbGF0ZSh7bmFtZTogdGhpcy5uYW1lfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuIiwiXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYXNlRmlsdGVyVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL2Jhc2UtZmlsdGVyLXZpZXcnKTtcblxucmVxdWlyZSgnLi4vbGliL2pxdWVyeS5ub3Vpc2xpZGVyLm1pbi5qcycpO1xucmVxdWlyZSgnanF1ZXJ5LXVpL2RhdGVwaWNrZXInKTtcblxudmFyIFRlbXBsYXRlID0gXCJcXG4gIDxoMyBjbGFzcz1cXFwidGl0bGUgdGV4dC1jZW50ZXJcXFwiPjxzcGFuIGNsYXNzPVxcXCJkYXRlc1xcXCI+PC9zcGFuPjwvaDM+XFxuICAgPGRpdiBjbGFzcz1cXFwieWVhci1zbGlkZXJcXFwiPjwvZGl2PlxcblxcbiAgIDxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMtc3RhcnRkYXRlXFxcIj5TdGFydCBEYXRlOjwvc3Bhbj4mbmJzcDxwPjxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBpZD1cXFwic3RhcnQtZGF0ZVxcXCIgY2xhc3M9XFxcImRhdGUtcGlja2VyXFxcIj48L3A+XFxuICAgPHNwYW4gZGF0YS1pMThuPVxcXCJhbXAuZ2lzOnBhbmUtc3ViZmlsdGVycy1lbmRkYXRlXFxcIj5FbmQgRGF0ZTo8L3NwYW4+Jm5ic3A8cD48aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcImVuZC1kYXRlXFxcIiBjbGFzcz1cXFwiZGF0ZS1waWNrZXJcXFwiPjwvcD5cXG5cIjtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRmlsdGVyVmlldy5leHRlbmQoe1xuXG4gIGNsYXNzTmFtZTogQmFzZUZpbHRlclZpZXcucHJvdG90eXBlLmNsYXNzTmFtZSArICcgZmlsdGVyLXllYXJzJyxcbiAgdGVtcGxhdGU6IF8udGVtcGxhdGUoVGVtcGxhdGUpLFxuICBfbG9hZGVkOiBudWxsLCBcbiAgaW5pdGlhbGl6ZTpmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIHRoaXMuZmlsdGVyVmlldyA9IG9wdGlvbnMuZmlsdGVyVmlldzsgICAgXG4gICAgQmFzZUZpbHRlclZpZXcucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICB0aGlzLnRyYW5zbGF0b3IgPSBvcHRpb25zLnRyYW5zbGF0b3I7XG4gICAgdGhpcy50cmFuc2xhdGUgPSBvcHRpb25zLnRyYW5zbGF0ZTsgICAgXG4vLyAgICBjb25zb2xlLmxvZyhcImp1c3QgYnVpbHQgYSB5ZWFycy1maWx0ZXItdmlldyBmb3IgXCIgKyBzZWxmLm1vZGVsLmdldCgnbmFtZScpKTtcbiAgICB0aGlzLl9sb2FkZWQgPSB0aGlzLm1vZGVsLmZldGNoKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICBcdC8vY29uc29sZS5sb2coXCJqdXN0IGxvYWRlZCBhIHllYXJzLWZpbHRlci12aWV3IGZvcjogXCIgKyBKU09OLnN0cmluZ2lmeSh7bmFtZTogc2VsZi5tb2RlbC5nZXQoJ25hbWUnKSwgc3RhcnQ6IHNlbGYubW9kZWwuZ2V0KCdzZWxlY3RlZFN0YXJ0JyksIGVuZDogc2VsZi5tb2RlbC5nZXQoJ3NlbGVjdGVkRW5kJyl9KSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLl91cGRhdGVUaXRsZSk7XG4gIH0sXG5cblxuICByZW5kZXJGaWx0ZXJzOmZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBCYXNlRmlsdGVyVmlldy5wcm90b3R5cGUucmVuZGVyRmlsdGVycy5hcHBseSh0aGlzKTtcblxuICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZSh0aGlzLm1vZGVsLnRvSlNPTigpKSk7XG5cbiAgICB0aGlzLl9sb2FkZWQudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIC8vc2VsZi5fcmVuZGVyU2xpZGVyKCk7XG4gICAgICBzZWxmLl9yZW5kZXJEYXRlUGlja2VycygpO1xuICAgICAgc2VsZi5fdXBkYXRlVGl0bGUoKTtcbiAgICAgIFxuICAgICAgLy8gV2UgbmVlZCB0byByZS10cmFuc2xhdGUgc29tZSBzdHJpbmdzIGZyb20gdGhlIHJpZ2h0IHBhbmVsLlxuICAgICAgc2VsZi50cmFuc2xhdGUoc2VsZik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfcmVuZGVyRGF0ZVBpY2tlcnM6IGZ1bmN0aW9uKCkge1x0XHRcblx0XG5cdFxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gVE9ETzogZm9ybWF0IGJhc2VkIG9uIGFkbWluIHNldHRpbmcuLi4ubWF5YmUgZ2V0IGZyb20geWVhciBhcGkuLlxuICAgIC8vIFRPRE86IGFic3RyYWN0IGNvbW1vbiBwcm9wZXJ0aWVzIGZyb20gb2JqZWN0IGluaXRzIGJlbG93Li4uXG4gICAgLy8gdmFyIGNvbW1vbk9iaiA9IHt9O1xuXG4gICAgdGhpcy4kKCcjc3RhcnQtZGF0ZScpLmRhdGVwaWNrZXIoe1xuICAgICAgZGVmYXVsdERhdGU6IHRoaXMubW9kZWwuZ2V0KCdzZWxlY3RlZFN0YXJ0JyksXG4gICAgICAvL21pbkRhdGU6IHRoaXMubW9kZWwuZ2V0KCdzdGFydFllYXInKSxcbiAgICAgIC8vbWF4RGF0ZTogdGhpcy5tb2RlbC5nZXQoJ2VuZFllYXInKSxcbiAgICAgIGRhdGVGb3JtYXQ6IHRoaXMuZmlsdGVyVmlldy5nZXREYXRlRm9ybWF0KCksXG4gICAgICBjaGFuZ2VNb250aDogdHJ1ZSxcbiAgICAgIGNoYW5nZVllYXI6IHRydWUsXG4gICAgICBudW1iZXJPZk1vbnRoczogMSxcbiAgICAgIHllYXJSYW5nZTogJ2MtNjA6Yys2MCcsXG4gICAgICBvbkNsb3NlOiBmdW5jdGlvbihzZWxlY3RlZERhdGUpIHtcbiAgICAgICAgc2VsZi4kKCcjZW5kLWRhdGUnKS5kYXRlcGlja2VyKCdvcHRpb24nLCAnbWluRGF0ZScsIHNlbGVjdGVkRGF0ZSk7ICAgICAgICBcbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoJ3NlbGVjdGVkU3RhcnQnLCAkLmRhdGVwaWNrZXIuZm9ybWF0RGF0ZShzZWxmLmZpbHRlclZpZXcuUEFSQU1TX0RBVEVfRk9STUFULCAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKHNlbGYuZmlsdGVyVmlldy5nZXREYXRlRm9ybWF0KCksIHNlbGVjdGVkRGF0ZSkpKTtcbiAgICAgICAgLy8gc2VsZi5fdXBkYXRlVGl0bGUoKTtcbiAgICAgIH1cbiAgICB9KTsgICAgXG5cbiAgICB0aGlzLiQoJyNlbmQtZGF0ZScpLmRhdGVwaWNrZXIoe1xuICAgICAgZGVmYXVsdERhdGU6IHRoaXMubW9kZWwuZ2V0KCdzZWxlY3RlZEVuZCcpLFxuICAgICAgLy9taW5EYXRlOiB0aGlzLm1vZGVsLmdldCgnc3RhcnRZZWFyJyksXG4gICAgICAvL21heERhdGU6IHRoaXMubW9kZWwuZ2V0KCdlbmRZZWFyJyksXG4gICAgICBkYXRlRm9ybWF0OiB0aGlzLmZpbHRlclZpZXcuZ2V0RGF0ZUZvcm1hdCgpLFxuICAgICAgY2hhbmdlTW9udGg6IHRydWUsXG4gICAgICBjaGFuZ2VZZWFyOiB0cnVlLFxuICAgICAgbnVtYmVyT2ZNb250aHM6IDEsXG4gICAgICB5ZWFyUmFuZ2U6ICdjLTYwOmMrNjAnLFxuICAgICAgb25DbG9zZTogZnVuY3Rpb24oc2VsZWN0ZWREYXRlKSB7XG4gICAgICAgIHNlbGYuJCgnI3N0YXJ0LWRhdGUnKS5kYXRlcGlja2VyKCdvcHRpb24nLCAnbWF4RGF0ZScsIHNlbGVjdGVkRGF0ZSk7ICAgICAgICBcbiAgICAgICAgc2VsZi5tb2RlbC5zZXQoJ3NlbGVjdGVkRW5kJywgJC5kYXRlcGlja2VyLmZvcm1hdERhdGUoc2VsZi5maWx0ZXJWaWV3LlBBUkFNU19EQVRFX0ZPUk1BVCwgJC5kYXRlcGlja2VyLnBhcnNlRGF0ZShzZWxmLmZpbHRlclZpZXcuZ2V0RGF0ZUZvcm1hdCgpLCBzZWxlY3RlZERhdGUpKSk7XG4gICAgICAgIC8vIHNlbGYuX3VwZGF0ZVRpdGxlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvL3RoaXMuJCgnI3N0YXJ0LWRhdGUnKS52YWwodGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkU3RhcnQnKSk7XG4gICAgLy90aGlzLiQoJyNlbmQtZGF0ZScpLnZhbCh0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWRFbmQnKSk7XG4gICAgXG4gICAgLy8gU2V0IHRoZSBsYW5ndWFnZSBmb3IgZGF0ZXBpY2tlcnMgaGVyZSAoaW5zdGVhZCBvZiBkb2luZyBpdCBpbiBmaWx0ZXJzLXZpZXcuanMpIHRvIHByZXZlbnQgcmFjZSBjb25kaXRpb25zIHRoYXQgd291bGQgc2V0IHRoZSB3cm9uZyBsYW5ndWFnZS5cbiAgICB2YXIgbGFuZ3VhZ2VTZXR0aW5nID0gdGhpcy5maWx0ZXJWaWV3LnNldHRpbmdzLmZpbmRXaGVyZSh7aWQ6J2xhbmd1YWdlJ30pO1xuXHRpZiAobGFuZ3VhZ2VTZXR0aW5nKSB7XG5cdFx0dmFyIGxhbmcgPSBsYW5ndWFnZVNldHRpbmcuZ2V0KCdkZWZhdWx0SWQnKSBcblx0XHQvL0VuZ2xpc2ggaXMgZGVmYXVsdCBzbyB3ZSBkb250IHNldCBpdC5cbiAgICAgICAgbGFuZyA9IChsYW5nID09PSAnZW4nKSA/ICAnJyA6IGxhbmc7IFxuXHRcdC8vY29uc29sZS5sb2coJ3NldHRpbmcgZGF0ZSBwaWNrZXIgbGFuZzogJyArIGxhbmcpO1xuXHRcdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cygkLmRhdGVwaWNrZXIucmVnaW9uYWxbbGFuZ10pO1xuXHR9XG4gIH0sXG5cbiAgcmVuZGVyVGl0bGU6ZnVuY3Rpb24oKSB7XG5cdEJhc2VGaWx0ZXJWaWV3LnByb3RvdHlwZS5yZW5kZXJUaXRsZS5hcHBseSh0aGlzKTtcbiAgICB0aGlzLl91cGRhdGVUaXRsZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy9UT0RPOiBkbyBtb3JlIGluIHRlbXBsYXRlLlxuICBfdXBkYXRlVGl0bGU6ZnVuY3Rpb24oKSB7XHQgIFxuXHR2YXIgc2VsZWN0ZWRTdGFydCA9IHRoaXMubW9kZWwuZ2V0KCdzZWxlY3RlZFN0YXJ0JykgPyAkLmRhdGVwaWNrZXIuZm9ybWF0RGF0ZSh0aGlzLmZpbHRlclZpZXcuZ2V0RGF0ZUZvcm1hdCgpLCAoJC5kYXRlcGlja2VyLnBhcnNlRGF0ZSh0aGlzLmZpbHRlclZpZXcuUEFSQU1TX0RBVEVfRk9STUFULCB0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWRTdGFydCcpKSkpIDogXCJcIjtcblx0dmFyIHNlbGVjdGVkRW5kID0gdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkRW5kJykgPyAkLmRhdGVwaWNrZXIuZm9ybWF0RGF0ZSh0aGlzLmZpbHRlclZpZXcuZ2V0RGF0ZUZvcm1hdCgpLCAoJC5kYXRlcGlja2VyLnBhcnNlRGF0ZSh0aGlzLmZpbHRlclZpZXcuUEFSQU1TX0RBVEVfRk9STUFULCB0aGlzLm1vZGVsLmdldCgnc2VsZWN0ZWRFbmQnKSkpKVx0OiBcIlwiO1xuXHQkKCcjZGF0ZVBpY2tlcicpLmRhdGVwaWNrZXIoeyBkYXRlRm9ybWF0OiB0aGlzLmZpbHRlclZpZXcuZ2V0RGF0ZUZvcm1hdCgpIH0pO1xuXHR0aGlzLiQoJyNzdGFydC1kYXRlJykuZGF0ZXBpY2tlcihcInNldERhdGVcIiwgc2VsZWN0ZWRTdGFydCk7XG5cdHRoaXMuJCgnI2VuZC1kYXRlJykuZGF0ZXBpY2tlcihcInNldERhdGVcIiwgc2VsZWN0ZWRFbmQpO1x0XG5cdHZhciBkYXRlcyA9IFwiXCI7XG5cdGlmKHNlbGVjdGVkU3RhcnQubGVuZ3RoID4gMCAmJiBzZWxlY3RlZEVuZC5sZW5ndGggPiAwKXtcblx0XHRkYXRlcyA9IHNlbGVjdGVkU3RhcnQgKyAnIC0gJyArICBzZWxlY3RlZEVuZDtcdFx0XG5cdH1lbHNlIGlmKHNlbGVjdGVkU3RhcnQubGVuZ3RoID4gMCAmJiBzZWxlY3RlZEVuZC5sZW5ndGggPT0gMCl7XG5cdFx0ZGF0ZXMgPSAnZnJvbSAnICsgc2VsZWN0ZWRTdGFydDtcdFx0XHRcdFxuXHR9ZWxzZSBpZihzZWxlY3RlZFN0YXJ0Lmxlbmd0aCA9PSAwICYmIHNlbGVjdGVkRW5kLmxlbmd0aCA+IDApe1xuXHRcdGRhdGVzID0gJ3VudGlsICcgKyBzZWxlY3RlZEVuZDtcdFx0XHRcblx0fVxuXHR0aGlzLiR0aXRsZUVsLmZpbmQoJy5maWx0ZXItY291bnQnKS50ZXh0KGRhdGVzKTtcblx0dGhpcy4kKCcuZGF0ZXMnKS50ZXh0KGRhdGVzKTtcdFxuICB9LFxuXG4gIF9yZW5kZXJTbGlkZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIHVzZXMgd2luZG93LmpRdWVyeSBiZWNhdXNlIHRoYXQgd2FzIHRoZSBvbmx5IHdheSBJIGhhZCBsdWNrIHdpdGggYnJvd3NlcmlmeSBzaGltLi4uXG4gICAgLy8gdXNlcyBodHRwczovL2dpdGh1Yi5jb20vbGVvbmdlcnNlbi9ub1VpU2xpZGVyXG4gICAgdGhpcy5zbGlkZXIgPSB3aW5kb3cualF1ZXJ5KHRoaXMuJCgnLnllYXItc2xpZGVyJykpLm5vVWlTbGlkZXIoe1xuICAgICAgc3RhcnQ6IFtzZWxmLm1vZGVsLmdldCgnc2VsZWN0ZWRTdGFydCcpLCBzZWxmLm1vZGVsLmdldCgnc2VsZWN0ZWRFbmQnKV0sXG4gICAgICBzdGVwOiAxLFxuICAgICAgY29ubmVjdDogdHJ1ZSxcbiAgICAgIHJhbmdlOiB7bWluOiBzZWxmLm1vZGVsLmdldCgnc3RhcnRZZWFyJyksIG1heDpzZWxmLm1vZGVsLmdldCgnZW5kWWVhcicpfSxcbiAgICAgIHNlcmlhbGl6YXRpb246IHtcbiAgICAgICAgbG93ZXI6IFtcbiAgICAgICAgICB3aW5kb3cualF1ZXJ5Lkxpbmsoe1xuICAgICAgICAgICAgdGFyZ2V0OiB3aW5kb3cualF1ZXJ5KCcuc3RhcnQteWVhcicpXG4gICAgICAgICAgfSlcbiAgICAgICAgXSxcbiAgICAgICAgdXBwZXI6IFtcbiAgICAgICAgICB3aW5kb3cualF1ZXJ5Lkxpbmsoe1xuICAgICAgICAgICAgdGFyZ2V0OiB3aW5kb3cualF1ZXJ5KCcuZW5kLXllYXInKVxuICAgICAgICAgIH0pXG4gICAgICAgIF0sXG4gICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgIGRlY2ltYWxzOiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vdWdseSwgdG9vIG11Y2ggZGF0YSBpbiB0aGUgZG9tLi4uYnV0IGl0J3MgaG93IHRoZSBleGFtcGxlIGdvZXMuXG4gICAgdGhpcy5zbGlkZXIub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5tb2RlbC5zZXQoJ3NlbGVjdGVkU3RhcnQnLCBwYXJzZUludChzZWxmLiQoJy5zdGFydC15ZWFyJykudGV4dCgpLCAxMCkpO1xuICAgIH0pO1xuXG4gICAgLy91Z2x5LCB0b28gbXVjaCBkYXRhIGluIHRoZSBkb20uLi5idXQgaXQncyBob3cgdGhlIGV4YW1wbGUgZ29lcy5cbiAgICB0aGlzLnNsaWRlci5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm1vZGVsLnNldCgnc2VsZWN0ZWRFbmQnLCAgcGFyc2VJbnQoc2VsZi4kKCcuZW5kLXllYXInKS50ZXh0KCksIDEwKSk7XG4gICAgfSk7XG4gIH1cblxufSk7XG4iLCJcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEJhc2VGaWx0ZXJWaWV3ID0gcmVxdWlyZSgnLi4vdmlld3MvYmFzZS1maWx0ZXItdmlldycpO1xuXG52YXIgVGVtcGxhdGUgPSBcIjxzcGFuIGRhdGEtaTE4bj1cXFwiYW1wLmdpczpwYW5lLXN1YmZpbHRlcnMteWVhclxcXCI+WWVhcjo8L3NwYW4+XFxyXFxuJm5ic3BcXHJcXG48cD5cXHJcXG5cXHQ8c2VsZWN0IGlkPVxcXCJ5ZWFyLXNlbGVjdFxcXCIgY2xhc3M9XFxcIlxcXCI+PC9zZWxlY3Q+XFxyXFxuPC9wPlwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VGaWx0ZXJWaWV3LmV4dGVuZCh7XG5cdGNsYXNzTmFtZSA6IEJhc2VGaWx0ZXJWaWV3LnByb3RvdHlwZS5jbGFzc05hbWUgKyAnIGZpbHRlci15ZWFycycsXG5cdHRlbXBsYXRlIDogXy50ZW1wbGF0ZShUZW1wbGF0ZSksXG5cdF9sb2FkZWQgOiBudWxsLFxuXHRpbml0aWFsaXplIDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdHRoaXMuZmlsdGVyVmlldyA9IG9wdGlvbnMuZmlsdGVyVmlldztcblx0XHRCYXNlRmlsdGVyVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBbIG9wdGlvbnMgXSk7XG5cdFx0dGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG5cdFx0dGhpcy50cmFuc2xhdG9yID0gb3B0aW9ucy50cmFuc2xhdG9yO1xuXHRcdHRoaXMudHJhbnNsYXRlID0gb3B0aW9ucy50cmFuc2xhdGU7XG5cdFx0dGhpcy5fbG9hZGVkID0gdGhpcy5tb2RlbC5mZXRjaCgpLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHQvKmNvbnNvbGUubG9nKFwianVzdCBsb2FkZWQgYSB5ZWFycy1vbmx5LWZpbHRlci12aWV3IGZvcjogXCIgKyBKU09OLnN0cmluZ2lmeSh7XG5cdFx0XHRcdG5hbWUgOiBzZWxmLm1vZGVsLmdldCgnbmFtZScpXG5cdFx0XHR9KSk7Ki9cblx0XHR9KTtcblxuXHRcdHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ2NoYW5nZScsIHRoaXMuX3VwZGF0ZVRpdGxlKTtcblx0fSxcblxuXHRyZW5kZXJGaWx0ZXJzIDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdEJhc2VGaWx0ZXJWaWV3LnByb3RvdHlwZS5yZW5kZXJGaWx0ZXJzLmFwcGx5KHRoaXMpO1xuXG5cdFx0dGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHRoaXMubW9kZWwudG9KU09OKCkpKTtcblxuXHRcdHRoaXMuX2xvYWRlZC50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0c2VsZi5fcmVuZGVyU2VsZWN0b3IoKTtcblxuXHRcdFx0Ly8gV2UgbmVlZCB0byByZS10cmFuc2xhdGUgc29tZSBzdHJpbmdzIGZyb20gdGhlIHJpZ2h0IHBhbmVsLlxuXHRcdFx0c2VsZi50cmFuc2xhdGUoc2VsZik7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcmVuZGVyU2VsZWN0b3IgOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIHNlbGVjdG9yID0gdGhpcy4kKCcjeWVhci1zZWxlY3QnKTtcblx0XHRzZWxlY3Rvci5hcHBlbmQoJChcIjxvcHRpb24+XCIpLmF0dHIoJ3ZhbHVlJywgJycpLnRleHQoJycpKTtcblx0XHRfLmVhY2godGhpcy5tb2RlbC5nZXQoJ3ZhbHVlJykub3B0aW9ucywgZnVuY3Rpb24oaXRlbSwgaSkge1xuXHRcdFx0dmFyIG9wdGlvbiA9ICQoXCI8b3B0aW9uPlwiKS5hdHRyKCd2YWx1ZScsIGl0ZW0udmFsdWUpLnRleHQoaXRlbS52YWx1ZSk7XG5cdFx0XHRpZiAoaXRlbS52YWx1ZSA9PT0gc2VsZi5tb2RlbC5nZXQoJ3NlbGVjdGVkWWVhcicpLnRvU3RyaW5nKCkpIHtcblx0XHRcdFx0JChvcHRpb24pLmF0dHIoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG5cdFx0XHR9XG5cdFx0XHRzZWxlY3Rvci5hcHBlbmQob3B0aW9uKTtcblx0XHR9KTtcblxuXHRcdCQoc2VsZWN0b3IpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYubW9kZWwuc2V0KCdzZWxlY3RlZFllYXInLCB0aGlzLnZhbHVlKTtcblx0XHR9KTtcblx0fSxcblxuXHRfdXBkYXRlVGl0bGUgOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZWN0ZWRZZWFyID0gdGhpcy5tb2RlbC5nZXQoJ3NlbGVjdGVkWWVhcicpO1xuXHRcdHRoaXMuJChcIiN5ZWFyLXNlbGVjdFwiKS52YWwoc2VsZWN0ZWRZZWFyKTtcblx0fSxcblxufSk7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cblxuZnVuY3Rpb24gU3RhdGVMb2FkRXJyb3IobWVzc2FnZSwgb3JpZ2luYWwpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0YXRlTG9hZEVycm9yKSkgeyByZXR1cm4gbmV3IFNhdGVMb2FkRXJyb3IobWVzc2FnZSwgb3JpZ2luYWwpOyB9XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMub3JpZ2luYWwgPSBvcmlnaW5hbDtcblxuICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZSgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlIG5lZWRzIHRvIGJlIGNyZWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nKTtcbiAgfVxuXG4gIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5cbl8uZXh0ZW5kKFN0YXRlLnByb3RvdHlwZSwgQmFja2JvbmUuRXZlbnRzLCB7XG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuc2F2ZWQgPSBvcHRpb25zLnNhdmVkO1xuICAgIC8vIEFueXRoaW5nIHRoYXQgc3RhdGUgbXVzdCByZWdpc3RlciBpdHNlbGYuIFNlZSBgU3RhdGUucmVnaXN0ZXJgLlxuICAgIHRoaXMuX3N0YXRlUmVnaXN0cnkgPSB7fTtcbiAgICAvLyBXaGVuIGxvYWRpbmcgc3RhdGUsIHNvbWUgdGhpbmdzIG1pZ2h0IG5vdCBoYXZlIHJlZ2lzdGVyZWQgeWV0LlxuICAgIC8vIEl0IGdldHMgbWFya2VkIGFzIHVuY2xhaW1lZCwgYW5kIHN0b3JlZCBoZXJlLlxuICAgIHRoaXMuX3VuY2xhaW1lZCA9IHt9O1xuICAgIC8vIHVzZSB0aGUgdXJsLCBpZiB3ZSBoYXZlIGl0XG4gICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICB0aGlzLmxpc3RlblRvVVJMKF8ob3B0aW9ucykucGljaygndXJsJywgJ3ByZWZpeCcsICdhdXRvaW5pdCcpKTtcbiAgICB9XG4gIH0sXG5cbiAgbGlzdGVuVG9VUkw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl91cmwgPSBvcHRpb25zLnVybDtcbiAgICB0aGlzLl91cmxQcmVmaXhlcyA9IG9wdGlvbnMucHJlZml4IHx8IFsnc2F2ZWQvJ107XG5cbiAgICAvLyB3cmFwIHByZWZpeGVzIGluIGFycmF5IHRvIG1ha2UgYmFja3dhcmQgY29tcGF0OlxuICAgIGlmICh0aGlzLl91cmxQcmVmaXhlcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpe1xuICAgICAgdGhpcy5fdXJsUHJlZml4ZXMgPSBbdGhpcy5fdXJsUHJlZml4ZXNdO1xuICAgIH1cblxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5fdXJsLCAnY2hhbmdlJywgdGhpcy51cmxNYXliZUxvYWQpO1xuICAgIGlmIChvcHRpb25zLmF1dG9pbml0ICYmIHRoaXMuX3VybC5oYXNoKCkpIHtcbiAgICAgIHRoaXMudXJsTWF5YmVMb2FkKHRoaXMuX3VybC5oYXNoKCkpO1xuICAgIH0gIC8vIGluaXRpYWwgc3RhdGVcbiAgfSxcblxuICB1cmxNYXliZUxvYWQ6IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1hdGNoRm91bmQgPSBmYWxzZTtcbiAgICBoYXNoID0gaGFzaCB8fCB0aGlzLl91cmwuaGFzaCgpO1xuXG4gICAgLy8gc2VlIGlmIGFueSBwcmVmaXhlcyBtYXRjaCB0aGUgaGFzaC5cbiAgICBfLmVhY2godGhpcy5fdXJsUHJlZml4ZXMsIGZ1bmN0aW9uKHByZWZpeCl7XG4gICAgICAvLyBsb2FkIGEgc3RhdGUgaWYgd2UgZ2V0IHRoZSBVUkwgaGFzaCBmb3Igb25lXG4gICAgICBpZiAoaGFzaC5pbmRleE9mKHByZWZpeCkgPT09IDApIHtcbiAgICAgICAgdmFyIHN0YXRlX29yX2lkID0gaGFzaC5zcGxpdChwcmVmaXgpWzFdO1xuICAgICAgICBpZiAoc3RhdGVfb3JfaWQpIHtcbiAgICAgICAgICBtYXRjaEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmW3NlbGYuc2F2ZWQgPyAnbG9hZEJ5SWQnIDogJ2xvYWQnXShzdGF0ZV9vcl9pZCwgcHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghbWF0Y2hGb3VuZCAmJiBoYXNoID09PSAnJykge1xuICAgICAgc2VsZi5yZXNldCgpO1xuICAgIH1cbiAgfSxcblxuICB0b0hhc2g6IGZ1bmN0aW9uKHN0YXRlX29yX2lkKSB7XG4gICAgaWYgKCFfKHRoaXMpLmhhcygnX3VybCcpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgZ2VuZXJhdGUgVVJMIGhhc2ggd2l0aG91dCBiZWluZyBpbml0aWFsaXplZCB3aXRoIFVSTCBpbnN0YW5jZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXJsUHJlZml4ZXNbMF0gKyBzdGF0ZV9vcl9pZDtcbiAgICB9XG4gIH0sXG5cbiAgbG9hZEJ5SWQ6IGZ1bmN0aW9uKGlkLCBtYXRjaGVkUHJlZml4KSB7XG4gICAgdGhpcy5sb2FkUHJvbWlzZSA9IHRoaXMuc2F2ZWQubG9hZChpZCwgbWF0Y2hlZFByZWZpeCAgKTsvLyBUT0RPOiBkcnM6IGFuZCBwYXNzIG1hdGNoaW5nIHByZWZpeC4uXG4gICAgdGhpcy5sb2FkUHJvbWlzZVxuICAgICAgLmRvbmUoXyhmdW5jdGlvbihzdGF0ZU1vZGVsKSB7XG4gICAgICAgIHRoaXMubG9hZChzdGF0ZU1vZGVsLmdldCgnc3RhdGVCbG9iJykpO1xuICAgICAgfSkuYmluZCh0aGlzKSlcbiAgICAgIC5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgU3RhdGVMb2FkRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIHN0YXRlIGJ5IGlkOiAnICsgaWQpO1xuICAgICAgfSk7XG4gIH0sXG5cbiAgbG9hZDogZnVuY3Rpb24oc3RhdGVzQmxvYikge1xuICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlKHN0YXRlc0Jsb2IpO1xuXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICBfLmVhY2gocGFyc2VkLCBmdW5jdGlvbihzdGF0ZVRvU2V0LCBpZCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9zdGF0ZVJlZ2lzdHJ5W2lkXTtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGN1cnJlbnQpKSB7XG4gICAgICAgIHRoaXMuX3VuY2xhaW1lZFtpZF0gPSBzdGF0ZVRvU2V0O1xuICAgICAgfSBlbHNlIGlmICghXy5pc0VxdWFsKGN1cnJlbnQuZ2V0KCksIHN0YXRlVG9TZXQpKSB7XG4gICAgICAgIGN1cnJlbnQuc2V0KHN0YXRlVG9TZXQpO1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMudHJpZ2dlcignbG9hZCcpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24oc3RhdGVzQmxvYikge1xuICAgIC8vIGJyZWFrIG91dCB0aGUgY2FsbCB0byBKU09OLnBhcnNlIHNvIHRoYXQgbG9hZCBjYW4gc3RpbGwgYmUgb3B0aW1pemVkXG4gICAgdmFyIHBhcnNlZDtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShzdGF0ZXNCbG9iKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBTdGF0ZUxvYWRFcnJvcignQ291bGQgbm90IHBhcnNlIHN0YXRlJywgZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAvLyBSZXN0b3JlIGFsbCBzdGF0ZXMgdG8gdGhlaXIgZGVmYXVsdHMgKHNwZWNpZmllZCBhdCByZWdpc3RyYXRpb24pXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICBfLmVhY2godGhpcy5fc3RhdGVSZWdpc3RyeSwgZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBzdGF0ZS5nZXQoKTtcbiAgICAgIGlmICghXy5pc0VxdWFsKGN1cnJlbnRTdGF0ZSwgc3RhdGUuZW1wdHkpKSB7XG4gICAgICAgIC8vIG9ubHkgY2FsbCAuc2V0IGlmIHJlc2V0dGluZyB3aWxsIGFjdHVhbGx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgIHN0YXRlLnNldChzdGF0ZS5lbXB0eSk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdyZXNldCcpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSxcblxuICBcbiAgZmlsdGVyc0xvYWRlZDogZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGRmZCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcblx0XHQgIGlmIChzZWxmLl9zdGF0ZVJlZ2lzdHJ5LmZpbHRlcnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ICBjbGVhckludGVydmFsKHRpbWVyKTtcblx0XHRcdCAgZGZkLnJlc29sdmUoKTtcblx0XHQgIH1cblx0ICB9LCAxMDAwKTtcblx0ICByZXR1cm4gZGZkLnByb21pc2UoKTsgXG4gIH0sXG4gIFxuICBcbiAgZnJlZXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHN0YXRlU25hcHNob3QgPSB7fTtcbiAgICBfLmVhY2godGhpcy5fc3RhdGVSZWdpc3RyeSwgZnVuY3Rpb24oc3RhdGUsIGlkKSB7XG4gICAgICB2YXIgY3VycmVudFN0YXRlID0gc3RhdGUuZ2V0KCk7XG4gICAgICBzdGF0ZVNuYXBzaG90W2lkXSA9IF8uY2xvbmUoY3VycmVudFN0YXRlKTsgIC8vIFRPRE86IGRlZXAgY2xvbmUoISEpXG4gICAgfSk7XG4gICAgdmFyIHN0YXRlc0Jsb2IgPSBKU09OLnN0cmluZ2lmeShzdGF0ZVNuYXBzaG90KTtcbiAgICBpZiAob3B0aW9ucy50b1VSTCkge1xuICAgICAgaWYgKCF0aGlzLl91cmwpIHsgY29uc29sZS5lcnJvcignU3RhdGUgY2Fubm90IGNoYW5nZSBVUkwgaWYgaXQgZG9lcyBoYXZlIGEgcmVmIHRvIGl0Jyk7IH1cbiAgICAgIHRoaXMuX3VybC5oYXNoKHRoaXMuX3VybFByZWZpeGVzWzBdICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0YXRlc0Jsb2IpKTtcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKCdmcmVlemUnLCBzdGF0ZXNCbG9iKTtcbiAgICByZXR1cm4gc3RhdGVzQmxvYjtcbiAgfSxcblxuICByZWdpc3RlcjogZnVuY3Rpb24ocmVnaXN0cmFibGUsIGlkLCBvcHRpb25zKSB7XG4gICAgaWYgKGlkIGluIHRoaXMuX3N0YXRlUmVnaXN0cnkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHJlZ2lzdHJhdGlvbiBvZiBkdXBsaWNhdGUgc3RhdGUgaWQgJyArIGlkKTtcbiAgICB9XG5cbiAgICAvLyByZWdpc3RlciB0aGUgc3RhdGVcbiAgICB0aGlzLl9zdGF0ZVJlZ2lzdHJ5W2lkXSA9IHtcbiAgICAgIGdldDogXy5iaW5kKG9wdGlvbnMuZ2V0LCByZWdpc3RyYWJsZSksXG4gICAgICBzZXQ6IF8uYmluZChvcHRpb25zLnNldCwgcmVnaXN0cmFibGUpLFxuICAgICAgZW1wdHk6IG9wdGlvbnMuZW1wdHlcbiAgICB9O1xuXG4gICAgLy8gc2V0IHRvIHRoZSBjdXJyZW50bHkgbG9hZGVkIHN0YXRlLCBvciBpdHMgZGVmYXVsdCBlbXB0eSBzdGF0ZVxuICAgIGlmIChpZCBpbiB0aGlzLl91bmNsYWltZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlUmVnaXN0cnlbaWRdLnNldCh0aGlzLl91bmNsYWltZWRbaWRdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl91bmNsYWltZWRbaWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGF0ZVJlZ2lzdHJ5W2lkXS5zZXQob3B0aW9ucy5lbXB0eSk7XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKCdyZWdpc3RlcicpO1xuICB9XG59KTtcblxuXG5TdGF0ZS5TdGF0ZUxvYWRFcnJvciA9IFN0YXRlTG9hZEVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZTtcbiIsIi8vIFRPRE86IG1vdmUgdGhpcyB1cCBhIGRpciwgYW5kIGluc3RhbnRpYXRlIGFuZCBhdHRhY2ggdG8gdGhlIGFwcFxuXG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cbmZ1bmN0aW9uIFRyYW5zbGF0b3Iob3B0aW9ucykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zbGF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2xhdG9yIG5lZWRzIHRvIGJlIGNyZWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nKTtcbiAgfVxuXG4gIC8vIHRoaXMgaXMgdGhlIG9iamVjdCB0aGF0IGhhcyBhbGwgIHRoZSBrZXkgdmFsdWUgcGFpcnMgZm9yIHRoZSB3aWRnZXQuXG4gIHZhciB0cmFuc2xhdG9yRGVmYXVsdHMgPSB7XG4gICAgZGVmYXVsdEtleXM6IHt9LFxuICAgIGF2YWlsYWJsZUxhbmd1YWdlczogbnVsbCwvLyBiYWNrYm9uZSBjb2xsZWN0aW9uXG4gICAgdHJhbnNsYXRpb25zOiB7XG4gICAgICBsb2NhbGVzOiB7XG4gICAgICAgIGVuOm51bGxcbiAgICAgIH1cbiAgICB9LFxuICAgIGFqYXg6ICQuYWpheFxuICB9O1xuXG4gIC8qIEdhdGhlciBvcHRpb25zICovXG4gIGlmIChvcHRpb25zKSB7XG4gICAgLyogRXNwZWNpYWxseSB1c2VmdWwgZm9yIG92ZXJ3cml0aW5nIGRlZmF1bHRLZXlzLCBhdmFpbGFibGVMYW5ndWFnZXMgYW5kIHRyYW5zbGF0aW9ucyAqL1xuICAgIF8uZGVmYXVsdHModGhpcywgb3B0aW9ucywgdHJhbnNsYXRvckRlZmF1bHRzKTtcbiAgfVxuXG4gIHRoaXMuX3Byb21pc2UgPSBudWxsO1xuICB0aGlzLl9jdXJyZW50TG5nID0gJ3RtcCc7XG4gIHRoaXMuX2ZpcnN0R2V0ID0gbnVsbDtcblxuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgbG9jYWwgc3RvcmFnZSB3aXRoIHRpbWVzdGFtcFxuICB0aGlzLmluaXRUcmFuc2xhdGlvbnMgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cbiAgICAvLyB0cnkgd2ViXG4gICAgdGhpcy5fcHJvbWlzZSA9IHRoaXMuZ2V0VHJhbnNsYXRpb25zKHNlbGYuZGVmYXVsdEtleXMpXG4gICAgICAuZmFpbChmdW5jdGlvbihqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignZmFpbGVkICcsIGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICB9KTtcbiAgICB0aGlzLnByb21pc2UgPSB0aGlzLl9wcm9taXNlLnByb21pc2UoKTtcbiAgfTtcblxuICAvKiBVc2UgdGhpcyBmb3IgYWRkaW5nIG1vcmUgZGVmYXVsdEtleXMgb3IgdHJhbnNsYXRpb25zIGJ5IG1vZHVsZVxuICAgKiBpZiB0cmFuc2xhdG9yIGhhcyBhbHJlYWR5IGJlZW4gaW5zdGFudGlhdGVkXG4gICAqL1xuICB0aGlzLmFkZFRyYW5zbGF0b3JPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIC8qIGZvcmNlIGEgcmVxdWVzdCBmcm9tIEFQSSBuZXh0IHRpbWUgKi9cbiAgICBfLmRlZmF1bHRzKHRoaXMuZGVmYXVsdEtleXMsIG9wdGlvbnMuZGVmYXVsdEtleXMpO1xuICAgIHRoaXMuX2ZpcnN0R2V0ID0gbnVsbDtcbiAgfTtcblxuXG4gIHRoaXMuZ2V0QXZhaWxhYmxlTGFuZ3VhZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuXG4gICAgaWYgKHRoaXMuYXZhaWxhYmxlTGFuZ3VhZ2VzKSB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMuYXZhaWxhYmxlTGFuZ3VhZ2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5pdEF2YWlsYWJsZUxhbmd1YWdlcygpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcy5hdmFpbGFibGVMYW5ndWFnZXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9O1xuXG4gIHRoaXMuX2luaXRBdmFpbGFibGVMYW5ndWFnZXMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmF2YWlsYWJsZUxhbmd1YWdlcyA9IG5ldyBCYWNrYm9uZS5Db2xsZWN0aW9uKFtdKTtcbiAgICB0aGlzLmF2YWlsYWJsZUxhbmd1YWdlcy51cmwgPSAnL3Jlc3QvdHJhbnNsYXRpb25zL2xhbmd1YWdlcyc7XG4gICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlTGFuZ3VhZ2VzLmZldGNoKCk7XG4gIH07XG5cblxuICAvLyBpbXBvcnRhbnQgdG8gbGV0IHRoZSBhcGkga25vdywgc28gYWxsIHJlc3BvbnNlcyBhcmUgdHJhbnNsYXRlZC5cbiAgdGhpcy5zZXRMYW5ndWFnZSA9IGZ1bmN0aW9uKGxuZykge1xuICAgIHRoaXMuX2N1cnJlbnRMbmcgPSBsbmc7XG4gICAgcmV0dXJuIHRoaXMuX2FwaUNhbGwoJy9yZXN0L3RyYW5zbGF0aW9ucy9sYW5ndWFnZXMvJyArIGxuZywgbnVsbCwgJ0dFVCcpO1xuICB9O1xuXG5cbiAgdGhpcy50cmFuc2xhdGVET00gPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciAkbmV3RWwgPSAkKGVsKTtcbiAgICAvKiBUT0RPKHRkayk6IFdlIGlkZW50aWZpZWQgYSBtYWpvciBidWcgaGVyZSB3aGVyZSByb290IGltbWVkaWF0ZSBjaGlsZFxuICAgICAqICB0ZW1wbGF0ZSBlbGVtZW50cyB3aXRoIHRyYW5zbGF0aW9ucyBhcmUgbm90IGJlaW5nIGNhdWdodCBieSB0aGlzXG4gICAgICogIHNlbGVjdG9yLlxuICAgICAqXG4gICAgICogIFRvIHdvcmthcm91bmQsIHdlIHNob3VsZCBjbG9uZSwgd3JhcCwgcnVuIHRoZSBzZWxlY3RvciBhbmQgdW53cmFwIHRoZSBET00uXG4gICAgICpcbiAgICAgKiAgUmVtZW1iZXIgdGhpcyBoYXMgdG8gd29yayBmb3IgZWwncyBhcm91bmQgdGhlIGFwcCB0aGF0IGFyZSBib3VuZFxuICAgICAqICBhbmQgbm90IGJvdW5kLlxuICAgICAqL1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNsYXRpb25zKCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAkLmVhY2goZGF0YSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAvKmlmICgkKCdbZGF0YS1pMThuPVwiJyArIGtleSArICdcIl0nLCAkbmV3RWwpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgIGNvbnNvbGUubG9nKGtleSwgJy0+JywgdmFsdWUsJyAkIGZvdW5kLT4nLCAkbmV3RWwuZmluZCgnW2RhdGEtaTE4bj1cIicgKyBrZXkgKyAnXCJdJykudGV4dCgpKTtcbiAgICAgICAgIH0qL1xuXG4gICAgICAgIC8vIFdlIG5lZWQgYSB3YXkgdG8gaWRlbnRpZnkgY29udHJvbHMgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIG5lZWRzIHRvIGJlIHRyYW5zbGF0ZWQgaW5zdGVhZCBvZiB0aGUgdGV4dC5cbiAgICAgICAgaWYgKGtleS5pbmRleE9mKCdbcGxhY2Vob2xkZXJdJykgPiAtMSkge1xuICAgICAgICAgICQoJ1tkYXRhLWkxOG49XCInICsga2V5ICsgJ1wiXScsICRuZXdFbCkuYXR0cigncGxhY2Vob2xkZXInLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5LmluZGV4T2YoJ1t0aXRsZV0nKSA+IC0xKSB7XG4gICAgICAgICAgJCgnW2RhdGEtaTE4bj1cIicgKyBrZXkgKyAnXCJdJywgJG5ld0VsKS5hdHRyKCd0aXRsZScsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkKCdbZGF0YS1pMThuPVwiJyArIGtleSArICdcIl0nLCAkbmV3RWwpLnRleHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAkbmV3RWw7XG4gICAgfSk7XG4gIH07XG5cblxuICAvKlxuICAgKiBQYXNzIGluIGEge1wiYW1wLmdpczpkYXRhLWkxOG4tY29kZVwiOiBcImJhc2UgbGFuZyB3b3Jkc1wiLCAuLi59IG9iamVjdCBmb3JcbiAgICogdHJhbnNsYXRpb24gZS5nLiBwYWdlIHRpdGxlXG4gICAqICovXG4gIC8vIFRPRE86IGRvbid0IGNhbGwgaXQgYSBsaXN0IGlmIGl0J3MgYW4gb2JqZWN0ID8hXG4gIHRoaXMudHJhbnNsYXRlTGlzdCA9IGZ1bmN0aW9uKGxpc3QpIHtcblxuICAgIC8vIHVwZGF0ZSB0cmFuc2xhdGVhYmxlIGVsZW1lbnRzIGluIHRoaXMga2V5LXZhbHVlIHNldFxuICAgIHZhciBfdXBkYXRlTGlzdCA9IGZ1bmN0aW9uKGxpc3QsIGkxOG5EYXRhKSB7XG4gICAgICBfLmVhY2gobGlzdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgbGlzdCkge1xuICAgICAgICBpZiAoaTE4bkRhdGFba2V5XSkge1xuICAgICAgICAgIGxpc3Rba2V5XSA9IGkxOG5EYXRhW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdFtrZXldID0ga2V5W3ZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNsYXRpb25zKCkudGhlbihmdW5jdGlvbihpMThuRGF0YSkge1xuICAgICAgdmFyIG91dExpc3QgPSBfdXBkYXRlTGlzdChsaXN0LCBpMThuRGF0YSk7XG4gICAgICByZXR1cm4gb3V0TGlzdDtcbiAgICB9KTtcbiAgfTtcblxuXG4gIC8qXG4gICAqIFN5bmNocm9ub3VzbHkgZ2V0IGEgKGFscmVhZHktbG9hZGVkKSB0cmFuc2xhdGlvblxuICAgKi9cbiAgdGhpcy50cmFuc2xhdGVTeW5jID0gZnVuY3Rpb24oa2V5LCBhbHQpIHtcbiAgICBpZiAodGhpcy5nZXRUcmFuc2xhdGlvbnMoKS5zdGF0ZSgpICE9PSAncmVzb2x2ZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCd0cmFuc2xhdGVTeW5jIHdhcyBjYWxsZWQgd2hlbiBnZXRUcmFuc2xhdGlvbnMgaXMgbm90IHN1Y2Nlc3NmdWxseSByZXNvbHZlZCcpO1xuICAgIH1cbiAgICB2YXIgdHJhbnNsYXRlZCA9IHRoaXMudHJhbnNsYXRpb25zLmxvY2FsZXNbdGhpcy5fY3VycmVudExuZ11ba2V5XTtcbiAgICBpZiAodHJhbnNsYXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIHRyYW5zbGF0aW9uIGhhcyBiZWVuIGxvYWRlZCBmb3InLCBrZXkpO1xuICAgICAgdHJhbnNsYXRlZCA9IGFsdCB8fCBrZXk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2xhdGVkO1xuICB9O1xuXG5cbiAgLy8gT25seSBkbyBzaW5nbGUgcmVxdWVzdCBvbiBsYXVuY2guXG4gIHRoaXMuZ2V0VHJhbnNsYXRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdGhpcyB3YXkgd29uJ3Qgd29yayB3aXRoIGNoYW5nZSBsYW5ndWFnZXMgbWlkIHdheSB0aG91Z2guXG4gICAgaWYgKCF0aGlzLl9maXJzdEdldCkge1xuICAgICAgdGhpcy5fZmlyc3RHZXQgPSB0aGlzLl9nZXRUcmFuc2xhdGlvbnNGcm9tQVBJKHRoaXMuZGVmYXVsdEtleXMsIHRoaXMuX2N1cnJlbnRMbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmlyc3RHZXQ7XG4gIH07XG5cblxuICB0aGlzLl9nZXRUcmFuc2xhdGlvbnNGcm9tQVBJID0gZnVuY3Rpb24odHJhbnNsYXRlYWJsZXMsIGxuZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdXJsID0gJy9yZXN0L3RyYW5zbGF0aW9ucy9sYWJlbC10cmFuc2xhdGlvbnMnO1xuXG4gICAgcmV0dXJuIHRoaXMuX2FwaUNhbGwodXJsLCB0cmFuc2xhdGVhYmxlcywgJ1BPU1QnKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIC8vY2FjaGUgaWYgd2Uga25vdyB0aGUgbG5nLiBUT0RPOiBnZXQgYXBpIHRvIGFsd2F5cyByZXR1cm4gdGhlIGxuZy5cbiAgICAgIGlmIChsbmcpIHtcbiAgICAgICAgc2VsZi50cmFuc2xhdGlvbnMubG9jYWxlc1tsbmddID0gZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRlbXAgaGFjayB0byBkbyBjYWNoaW5nIGlmIEFQSSBkb2Vzbid0IHJldHVybiBjdXJyZW50IGxuZ1xuICAgICAgICBsbmcgPSB0aGlzLl9jdXJyZW50TG5nO1xuICAgICAgICBzZWxmLnRyYW5zbGF0aW9ucy5sb2NhbGVzW2xuZ10gPSBkYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbiAgfTtcblxuXG4gIC8vIGhlbHBlciB0byB3cmFwIGFwaSBjYWxsXG4gIHRoaXMuX2FwaUNhbGwgPSBmdW5jdGlvbih1cmwsIGRhdGEsIHR5cGUpIHtcbiAgICB2YXIgYWpheE9wdGlvbnMgPSB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC8vIGpzY3M6ZGlzYWJsZSBkaXNhbGxvd1F1b3RlZEtleXNJbk9iamVjdHNcbiAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAvLyBqc2NzOmVuYWJsZSBkaXNhbGxvd1F1b3RlZEtleXNJbk9iamVjdHNcbiAgICAgIH0sXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgfTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgYWpheE9wdGlvbnMuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFqYXgoYWpheE9wdGlvbnMpO1xuICB9O1xuXG4gIHRoaXMuaW5pdFRyYW5zbGF0aW9ucygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zbGF0b3I7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG5cblxuZnVuY3Rpb24gVVJMKCkge1xuICAndXNlIHN0cmljdCc7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVUkwgbmVlZHMgdG8gYmUgY3JlYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLicpO1xuICB9XG4gIGlmICh3aW5kb3cuX2FtcFVybGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbm90aGVyIGluc3RhbmNlIG9mIFVSTCBpcyBhbHJlYWR5IG1hbmFnaW5nIHdpbmRvdy5sb2NhdGlvbicpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5fYW1wVXJsZXIgPSB0cnVlO1xuICB9XG4gIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5cbl8uZXh0ZW5kKFVSTC5wcm90b3R5cGUsIEJhY2tib25lLkV2ZW50cywge1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgXy5iaW5kQWxsKHRoaXMsICdjaGFuZ2UnKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuY2hhbmdlKTsgIC8vIElFIDgrXG4gIH0sXG5cbiAgaGFzaDogZnVuY3Rpb24obmV3SGFzaCwgb3B0aW9ucykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpOyAgLy8gcmVtb3ZlICcjJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHsgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoYW5nZSk7IH0gIC8vIElFIDkrXG4gICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IG5ld0hhc2g7XG4gICAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHsgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoYW5nZSk7IH1cbiAgICB9XG4gIH0sXG5cbiAgZnVsbDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgd2luZG93LmxvY2F0aW9uO1xuICB9LFxuXG4gIGNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzLmhhc2goKSk7XG4gIH1cblxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBVUkw7XG4iLCJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cblx0dmFyIF9kZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblx0dmFyIF9kZWJ1ZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWJ1Zyk7XG5cblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoc2x1Zykge1xuXHQgIHZhciByZXMgPSB7XG5cdCAgICBsb2c6ICgwLCBfZGVidWcyW1wiZGVmYXVsdFwiXSkoc2x1ZyksXG5cdCAgICBlcnI6ICgwLCBfZGVidWcyW1wiZGVmYXVsdFwiXSkoc2x1ZyksXG5cdCAgICB3YXJuOiAoMCwgX2RlYnVnMltcImRlZmF1bHRcIl0pKHNsdWcpLFxuXHQgICAgb25EZWJ1ZzogKDAsIF9kZWJ1ZzJbXCJkZWZhdWx0XCJdKShzbHVnKVxuXHQgIH07XG5cdCAgcmVzLmVyci5sb2cgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUuZXJyb3IsIGNvbnNvbGUpO1xuXHQgIHJlcy53YXJuLmxvZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS53YXJuLCBjb25zb2xlKTtcblx0ICByZXMub25EZWJ1Zy5sb2cgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpbmRleCBpbiBhcmdzKSB7XG5cdCAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGFyZ3NbaW5kZXhdKSB7XG5cdCAgICAgICAgYXJnc1tpbmRleF0oKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgcmV0dXJuIHJlcztcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qKlxuXHQgKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG5cdCAqXG5cdCAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cblx0ICovXG5cblx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0ZXhwb3J0cy5sb2cgPSBsb2c7XG5cdGV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5cdGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5cdGV4cG9ydHMubG9hZCA9IGxvYWQ7XG5cdGV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuXHRleHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG5cdCAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuXHQgICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG5cdCAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cblx0LyoqXG5cdCAqIENvbG9ycy5cblx0ICovXG5cblx0ZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCAgJ2xpZ2h0c2VhZ3JlZW4nLFxuXHQgICdmb3Jlc3RncmVlbicsXG5cdCAgJ2dvbGRlbnJvZCcsXG5cdCAgJ2RvZGdlcmJsdWUnLFxuXHQgICdkYXJrb3JjaGlkJyxcblx0ICAnY3JpbXNvbidcblx0XTtcblxuXHQvKipcblx0ICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcblx0ICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG5cdCAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cblx0ICpcblx0ICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcblx0ICovXG5cblx0ZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQgIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdCAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuXHQgICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHQgICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcblx0ICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuXHQgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdCAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cblx0ICovXG5cblx0ZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG5cdCAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcblx0ICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0ICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cblx0ICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcblx0ICAgICsgdGhpcy5uYW1lc3BhY2Vcblx0ICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuXHQgICAgKyBhcmdzWzBdXG5cdCAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcblx0ICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdCAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG5cdCAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHQgIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuXHQgIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdCAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQgIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHQgIHZhciBpbmRleCA9IDA7XG5cdCAgdmFyIGxhc3RDID0gMDtcblx0ICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcblx0ICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuXHQgICAgaW5kZXgrKztcblx0ICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuXHQgICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0ICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0ICAgICAgbGFzdEMgPSBpbmRleDtcblx0ICAgIH1cblx0ICB9KTtcblxuXHQgIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcblx0ICByZXR1cm4gYXJncztcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cblx0ICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gbG9nKCkge1xuXHQgIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG5cdCAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcblx0ICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG5cdCAgICAmJiBjb25zb2xlLmxvZ1xuXHQgICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdH1cblxuXHQvKipcblx0ICogU2F2ZSBgbmFtZXNwYWNlc2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0ICB0cnkge1xuXHQgICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuXHQgICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG5cdCAgICB9XG5cdCAgfSBjYXRjaChlKSB7fVxuXHR9XG5cblx0LyoqXG5cdCAqIExvYWQgYG5hbWVzcGFjZXNgLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBsb2FkKCkge1xuXHQgIHZhciByO1xuXHQgIHRyeSB7XG5cdCAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuXHQgIH0gY2F0Y2goZSkge31cblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuXHQgKi9cblxuXHRleHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG5cdC8qKlxuXHQgKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG5cdCAqXG5cdCAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuXHQgKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuXHQgKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG5cdCAgfSBjYXRjaCAoZSkge31cblx0fVxuXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0LyoqXG5cdCAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcblx0ICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cblx0ICpcblx0ICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuXHQgKi9cblxuXHRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1Zztcblx0ZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5cdGV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuXHRleHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRleHBvcnRzLmh1bWFuaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHQvKipcblx0ICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCAqL1xuXG5cdGV4cG9ydHMubmFtZXMgPSBbXTtcblx0ZXhwb3J0cy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCAqXG5cdCAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuXHQgKi9cblxuXHRleHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0ICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cblx0ICovXG5cblx0dmFyIHByZXZDb2xvciA9IDA7XG5cblx0LyoqXG5cdCAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG5cdCAqL1xuXG5cdHZhciBwcmV2VGltZTtcblxuXHQvKipcblx0ICogU2VsZWN0IGEgY29sb3IuXG5cdCAqXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuXHQgIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG5cdCAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cblx0ICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcblx0ICB9XG5cdCAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdCAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuXHQgIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cblx0ICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuXHQgICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0ICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG5cdCAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHQgICAgc2VsZi5kaWZmID0gbXM7XG5cdCAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0ICAgIHNlbGYuY3VyciA9IGN1cnI7XG5cdCAgICBwcmV2VGltZSA9IGN1cnI7XG5cblx0ICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG5cdCAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuXHQgICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cblx0ICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuXHQgICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdCAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG5cdCAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG5cdCAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHQgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG5cdCAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0ICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG5cdCAgICAgIGluZGV4Kys7XG5cdCAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0ICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcblx0ICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG5cdCAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdCAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHQgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICBpbmRleC0tO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBtYXRjaDtcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuXHQgICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHQgICAgfVxuXHQgICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcblx0ICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHQgIH1cblx0ICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG5cdCAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cblx0ICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cblx0ICByZXR1cm4gZm47XG5cdH1cblxuXHQvKipcblx0ICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHQgIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuXHQgIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHQgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0ICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXHQgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHQgICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0ICBleHBvcnRzLmVuYWJsZSgnJyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0ICB2YXIgaSwgbGVuO1xuXHQgIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblx0ICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29lcmNlIGB2YWxgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge01peGVkfSB2YWxcblx0ICogQHJldHVybiB7TWl4ZWR9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdCAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHQgIHJldHVybiB2YWw7XG5cdH1cblxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXG5cdCAqIEhlbHBlcnMuXG5cdCAqL1xuXG5cdHZhciBzID0gMTAwMDtcblx0dmFyIG0gPSBzICogNjA7XG5cdHZhciBoID0gbSAqIDYwO1xuXHR2YXIgZCA9IGggKiAyNDtcblx0dmFyIHkgPSBkICogMzY1LjI1O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuXHQgKlxuXHQgKiBPcHRpb25zOlxuXHQgKlxuXHQgKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcblx0ICByZXR1cm4gb3B0aW9ucy5sb25nXG5cdCAgICA/IGxvbmcodmFsKVxuXHQgICAgOiBzaG9ydCh2YWwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG5cdCAgc3RyID0gJycgKyBzdHI7XG5cdCAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkgcmV0dXJuO1xuXHQgIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcblx0ICBpZiAoIW1hdGNoKSByZXR1cm47XG5cdCAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcblx0ICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuXHQgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgY2FzZSAneWVhcnMnOlxuXHQgICAgY2FzZSAneWVhcic6XG5cdCAgICBjYXNlICd5cnMnOlxuXHQgICAgY2FzZSAneXInOlxuXHQgICAgY2FzZSAneSc6XG5cdCAgICAgIHJldHVybiBuICogeTtcblx0ICAgIGNhc2UgJ2RheXMnOlxuXHQgICAgY2FzZSAnZGF5Jzpcblx0ICAgIGNhc2UgJ2QnOlxuXHQgICAgICByZXR1cm4gbiAqIGQ7XG5cdCAgICBjYXNlICdob3Vycyc6XG5cdCAgICBjYXNlICdob3VyJzpcblx0ICAgIGNhc2UgJ2hycyc6XG5cdCAgICBjYXNlICdocic6XG5cdCAgICBjYXNlICdoJzpcblx0ICAgICAgcmV0dXJuIG4gKiBoO1xuXHQgICAgY2FzZSAnbWludXRlcyc6XG5cdCAgICBjYXNlICdtaW51dGUnOlxuXHQgICAgY2FzZSAnbWlucyc6XG5cdCAgICBjYXNlICdtaW4nOlxuXHQgICAgY2FzZSAnbSc6XG5cdCAgICAgIHJldHVybiBuICogbTtcblx0ICAgIGNhc2UgJ3NlY29uZHMnOlxuXHQgICAgY2FzZSAnc2Vjb25kJzpcblx0ICAgIGNhc2UgJ3NlY3MnOlxuXHQgICAgY2FzZSAnc2VjJzpcblx0ICAgIGNhc2UgJ3MnOlxuXHQgICAgICByZXR1cm4gbiAqIHM7XG5cdCAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuXHQgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuXHQgICAgY2FzZSAnbXNlY3MnOlxuXHQgICAgY2FzZSAnbXNlYyc6XG5cdCAgICBjYXNlICdtcyc6XG5cdCAgICAgIHJldHVybiBuO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBzaG9ydChtcykge1xuXHQgIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuXHQgIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuXHQgIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuXHQgIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuXHQgIHJldHVybiBtcyArICdtcyc7XG5cdH1cblxuXHQvKipcblx0ICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBsb25nKG1zKSB7XG5cdCAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG5cdCAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcblx0ICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG5cdCAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuXHQgICAgfHwgbXMgKyAnIG1zJztcblx0fVxuXG5cdC8qKlxuXHQgKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cblx0ICovXG5cblx0ZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG5cdCAgaWYgKG1zIDwgbikgcmV0dXJuO1xuXHQgIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuXHQgIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG5cdH1cblxuXG4vKioqLyB9XG4vKioqKioqLyBdKTsiXX0=
