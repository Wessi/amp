var _ = require('underscore');
var Backbone = require('backbone');


function State() {
  'use strict';

  if (!(this instanceof State)) {
    throw new Error('State needs to be created with the `new` keyword.');
  }

  this.initialize.apply(this, arguments);
}


_.extend(State.prototype, Backbone.Events, {

  initialize: function(options) {
    this.data = options.data;
    // Anything that state must register itself. See `State.register`.
    this._stateRegistry = {};
    // When loading state, some things might not have registered yet.
    // It gets marked as unclaimed, and stored here.
    this._unclaimed = {};
    // use the url, if we have it
    if (options.url) {
      this.listenToURL(_(options).pick('url', 'prefix'));
    }
  },

  listenToURL: function(options) {
    this._urlPrefix = options.prefix || 'saved/';
    this.listenTo(options.url, 'change', this.urlMaybeLoad);
    if (options.url.hash()) { this.urlMaybeLoad(options.url.hash()); }  // initial state
  },

  urlMaybeLoad: function(hash) {
    // load a state if we get the URL hash for one
    if (hash.indexOf(this._urlPrefix) === 0) {
      var id = hash.split(this._urlPrefix)[1];
      if (id) {
        this.loadById(id);
      } else {
        this.reset();
      }
    } else if (hash === '') {
      this.reset();
    } else {
      console.warn('hash changed but not for state:', hash);
    }
  },

  loadById: function(id) {
    this.data.savedMaps.load(id).done(_(function(stateModel) {
      this.load(stateModel.get('stateBlob'));
    }).bind(this));
  },

  load: function(statesBlob) {
    var parsed = JSON.parse(statesBlob);

    var changed = false;
    _.each(parsed, function(stateToSet, id) {
      var current = this._stateRegistry[id];
      if (_.isUndefined(current)) {
        this._unclaimed[id] = stateToSet;
        console.warn('Saving state for unregistered id: ' + id);
      } else if (!_.isEqual(current.get(), stateToSet)) {
        current.set(stateToSet);
        changed = true;
      }
    }, this);

    this.trigger('load');
    if (changed) {
      this.trigger('change');
    }
  },

  reset: function() {
    // Restore all states to their defaults (specified at registration)
    var changed = false;
    _.each(this._stateRegistry, function(state) {
      var currentState = state.get();
      if (!_.isEqual(currentState, state.empty)) {
        // only call .set if resetting will actually change the state.
        state.set(state.empty);
        changed = true;
      }
    }, this);

    this.trigger('reset');
    if (changed) {
      this.trigger('change');
    }
  },

  freeze: function() {
    var stateSnapshot = {};
    _.each(this._stateRegistry, function(state, id) {
      var currentState = state.get();
      stateSnapshot[id] = _.clone(currentState);  // TODO: deep clone(!!)
    });
    var statesBlob = JSON.stringify(stateSnapshot);
    this.trigger('freeze', statesBlob);
    return statesBlob;
  },

  register: function(registrable, id, options) {
    if (id in this._stateRegistry) {
      throw new Error('Attempted registration of duplicate state id ' + id);
    }

    // register the state
    this._stateRegistry[id] = {
      get: _.bind(options.get, registrable),
      set: _.bind(options.set, registrable),
      empty: options.empty
    };

    // set to the currently loaded state, or its default empty state
    if (id in this._unclaimed) {
      console.info('restoring state for previously unregistered id ', id);
      this._stateRegistry[id].set(this._unclaimed[id]);
      delete this._unclaimed[id];
    } else {
      this._stateRegistry[id].set(options.empty);
    }

    this.trigger('register');
  }
});


module.exports = State;
