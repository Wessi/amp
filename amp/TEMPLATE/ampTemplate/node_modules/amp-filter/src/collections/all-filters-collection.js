var Backbone = require('backbone');
var _ = require('underscore');
var $ = require('jquery');

var GenericFilterModel = require('../models/generic-filter-model');
var OrgRoleFilterModel = require('../models/org-role-filter-model');
var YearsFilterModel = require('../models/years-filter-model');
var YearsOnlyFilterModel = require('../models/years-only-filter-model');

var LEVEL_ONE = 1;
var LEVEL_TWO = 2;
var LEVEL_THREE = 3;
var LEVEL_FOUR = 4;

//TODO: move most code from filters-view here.
module.exports = Backbone.Collection.extend({
  url: '/rest/filters',
  _loaded: null,
  _allDeferreds: [],
   componentCaller: null,
  initialize: function(models,options) {
    this.on('add', this._cleanUpAfterAdd);
    this.load();
    if (options.caller) {
    	componentCaller = options.caller;
    }
  },

  load: function() {
    var self = this;
    if(!this._loaded){
      this._loaded = new $.Deferred();
      this.fetch({remove: false}).then(function() {
        // when all child calls are done resolve.
        $.when.apply($, self._allDeferreds)
          .done(self._loaded.resolve)
          .fail(self._loaded.reject);
      }).fail(self._loaded.reject);
    }

    return this._loaded;
  },

  _cleanUpAfterAdd: function(model) {
    var self = this;
    // remove if ui false also catches empty dummy filters we add in 'model' function below.
    if (!model.get('ui')) {
      self.remove(model);
    }
    //remove if the endpoint returns the filter type (dashboard,tabs,reports and/or GIS) for which
    //the model should be visible and the caller is not of the same tpe
    
    if (model.get('filterType')) {
    	var isOfRequiredType = _.some( model.get('filterType'), function( type ) {
    	    return type === componentCaller || type === "ALL";
    	});
    	
    	if (!isOfRequiredType) {
    		self.remove (model);
    	}
    }
    // Expose this field for later usage.
    this.componentCaller = componentCaller;
  },


  parse: function(data) {
    //only keep filters with ui == true;
    data = _.filter(data, function(obj) {
      return obj.ui;
    });

    //remove org, sector EPs
    data = _.filter(data, function(obj) {
      return (obj.endpoint !== '/rest/filters/org-groups' &&
        obj.endpoint !== '/rest/filters/org-types' &&
        obj.endpoint !== '/rest/filters/org-roles' &&
        obj.endpoint !== '/rest/filters/orgs' &&
        obj.endpoint !== '/rest/filters/programs' && 
        obj.endpoint !== '/rest/filters/locations/' &&  
        obj.endpoint !== '/rest/filters/sectors');  
    });

    return data;
  },
  
  model: function(attrs, options) {
    var tmpModel = null;
    var self = options.collection;
    // switch for model polymorphism.
    switch (attrs.id) {
      case 'ProgramList':
      case 'SectorList':
      case 'Orgs':
      case 'LocationList':
    	 self._allDeferreds.push(self._buildTreeImplementation(self, attrs));
         tmpModel = new Backbone.Model({ui:false});
         break;
      default:    	  
    	  if (attrs.id == 'date' || (attrs.id.indexOf('-date') != -1 ) || (attrs.id.indexOf('date-') != -1 )) {
    		  tmpModel = new YearsFilterModel(attrs);  // hacky but less hacky than enumerating them. Long term solution -> the endpoint should return a field telling the type of a field
    	  } else if (attrs.id == 'computed-year') {
    		  tmpModel = new YearsOnlyFilterModel(attrs);
    	  } else {
    		  tmpModel = new GenericFilterModel(attrs);
    		  self._allDeferreds.push(tmpModel.getTree());
    	  }
    }

    return tmpModel;
  },
  
 _getGroup: function(definition, attrs) {
	  var group = definition.name;
	  if (attrs.id === 'Orgs' && definition.name != 'Donor') {
		  group = 'Role';
	  }
	  
	  if (attrs.id === 'SectorList') {
		  group = 'Sectors';
	  }
	  
	  if (attrs.id === 'ProgramList') {
		  group = 'Programs';
	  }	 
	  
	  return group;
   },
  _buildTreeImplementation: function(self, attrs) {
	    var url = attrs.endpoint;
	    var deferred = $.Deferred();
	    var tmpDeferreds = [];
	    var self = this; 	   
	    
	    $.get(url, function( data ) {      
           var listDefinitions = data.listDefinitions;                    
          _.each(listDefinitions, function(def) {          	  
        	  var items = data.items[def.items];         	   
        	  var tree = self._createTree(items, def);    
        	  var tmpModel = new GenericFilterModel({
        	      id: def.id || def.name,        	    
                  data: tree,
                  name: def.name,
                  tab: def.tab,
                  ui: true,
                  group: self._getGroup(def, attrs),
                  empty: false
                });
        	  
        	    self.add(tmpModel);                
                tmpDeferreds.push(tmpModel.getTree());                    
          });    
          
          $.when.apply($, tmpDeferreds).then(function() {
              deferred.resolve();
            });
        });
	    
	    return deferred;
	  },
      
	  _createTree: function(data, definition) {
		  var self = this;
		  var dataCopy = JSON.parse(JSON.stringify(data));
		  var tree = [];	  
		  
		  _.each(dataCopy, function(level1) {
			  var level1 = $.extend({}, level1);
			  level1.filterId = definition.filterIds[0];
			  level1.level = LEVEL_ONE;
			  
			  if (level1.children && level1.children.length > 0) {				  
				    level1.children = self._updateLevelData(level1, definition, LEVEL_TWO, definition.filterIds[1]);
				    
				  _.each(level1.children, function(level2) {					  
					  if (level2.children && level2.children.length > 0) {
						  level2.children = self._updateLevelData(level2, definition, LEVEL_THREE, definition.filterIds[2]);	
						  
						  _.each(level2.children, function(level3) {							  
							  if (level3.children && level3.children.length > 0) {								  
								   level3.children = self._updateLevelData(level3, definition, LEVEL_FOUR, definition.filterIds[3]);								  
								   level3.children.map(function(item) {
								   item.children = [];  //ignore 4th level, filtering supports 3 levels
								});
							  }
							  							  
						  })
					  }		
					  
				  })
			  }
			  
			  tree.push(level1);			  
		   });          
		  
		  return tree;
	  },
	  
	  _updateLevelData: function(node, definition, level, filterId) {				  
		  return node.children.filter(function(item) {
			  if (item.listDefinitionIds) {
				  return item.listDefinitionIds.includes(definition.id);
			  }
			  return true;							  
		  }).map(function(item) {
			  item.filterId = filterId;
			  item.level = level;
			  return item;
		  });	  
  
}
});
