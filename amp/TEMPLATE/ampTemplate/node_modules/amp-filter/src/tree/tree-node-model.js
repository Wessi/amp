var _ = require('underscore');
var Backbone = require('backbone');
var TreeNodeModel; // declare here to help with ref loop of collection and model
var TreeNodeCollection = Backbone.Collection.extend({  model:TreeNodeModel });

//TODO: propogation bug if mid level node is half filled and you 'deselect all' it won't propogate to children.

TreeNodeModel = Backbone.Model.extend({
  defaults:{
    selected: undefined,  // default is selected. change to string / trinary, for off, semi, and on
    expanded: true,
    visible: true,
    numSelected: 0,
    numPossible: 0,
    children: null,     // type TreeNodeCollection
    isSelectable: true  // is this node itself selectable (ie. should it have an 'unkown' child)
  },

  initialize:function(obj) {
    var self = this;
    var childrenCollection = new TreeNodeCollection();
    this.set('children', childrenCollection);

    //iterate over children
    if (Array.isArray(obj.children)) {
      _.each(obj.children, function(child) {
        var newChild = new TreeNodeModel(child);
        childrenCollection.add(newChild);
      });
    }

    // if we have children, then add self as a leaf node, 'unkown'
    if (!childrenCollection.isEmpty() &&  this.get('isSelectable')) {
      var unkownNode = new TreeNodeModel(self.toJSON());
      unkownNode.set('name', 'unkown: ' + this.get('name'));
      childrenCollection.add(unkownNode);
    }

    this._addListenersToChildren();

    this.on('change:selected', self._onSelectChange);

    this._updateCount();
  },


  // merge based on filterId as we serialize....
  // options.wholeModel returns whole Models instead of just ids
  serialize: function(options) {
    var tmp = {};
    var children = this.get('children');
    if (children.length > 0) {
      children.each(function(child) {
        var serializedChild = child.serialize(options);
        _.each(serializedChild, function(v,k){
          if(v){
            if(tmp[k]){
              tmp[k] = tmp[k].concat(v);
            } else{
              tmp[k] = v;
            }

          }
        });
      });

    } else {
      if (this.get('selected') || options.includeUnselected) {
        if(this.get('filterId')){
          tmp[this.get('filterId')] = (options.wholeModel? [this]:[this.id]);
        } else{
          tmp['default'] = (options.wholeModel? [this]:[this.id]);
        }
      }
    }

    // put all 'default' elements under this.
    if(this.get('filterId')){
      var filterId = this.get('filterId');
      if(tmp[filterId] && tmp['default']){
        tmp[filterId] = tmp[filterId].concat(tmp['default']);
        delete tmp['default'];
      } else if (tmp['default']){
        tmp[filterId] = tmp['default'];
        delete tmp['default'];
      }
    }
    return tmp;
  },

  // returns all fitlers, regardless of whether they are selected or not.
  // getAllFilters: function(options) {
  //   var tmp = {};
  //   var children = this.get('children');
  //   if (children.length > 0) {
  //     children.each(function(child) {
  //       var childFilter = child.getAllFilters(options);
  //       _.each(childFilter, function(v,k){
  //         if(v){
  //           if(tmp[k]){
  //             tmp[k] = tmp[k].concat(v);
  //           } else{
  //             tmp[k] = v;
  //           }

  //         }
  //       });
  //     });

  //   } else {
  //       if(this.get('filterId')){
  //         tmp[this.get('filterId')] = ([this]);
  //       } else{
  //         tmp['default'] = ([this]);
  //       }
  //   }

  //   // put all 'default' elements under this.
  //   if(this.get('filterId')){
  //     var filterId = this.get('filterId');
  //     if(tmp[filterId] && tmp['default']){
  //       tmp[filterId] = tmp[filterId].concat(tmp['default']);
  //       delete tmp['default'];
  //     } else if (tmp['default']){
  //       tmp[filterId] = tmp['default'];
  //       delete tmp['default'];
  //     }
  //   }
  //   return tmp;
  // },

  deserialize: function(blob) {
    var self = this;
    var children = this.get('children');
    if (children.length > 0) {
      children.each(function(child) {
        if(!child.get('filterId') && self.get('filterId')){
          child.set('filterId', self.get('filterId'));
        }
        child.deserialize(blob);
      });
    }

    if(blob[this.get('filterId')]){
      if (_(blob[this.get('filterId')]).indexOf(this.id) > -1) {
        this.set('selected', true, {propagation: true});
      } else if (children.length === 0) {
        this.set('selected', false, {propagation: true});
      }
    }
  },


  _onSelectChange:function(model, argument, options) {
    var self = this;
    var children = this.get('children');

    if (this.get('selected')) {
      this.set('numSelected', this.get('numPossible'));
    } else {
      this.set('numSelected', 0);
    }

    if (!children.isEmpty()) {
      self._updateChildNodes(options.propagation);
    }

    if (options.propagation) {
      self.trigger('updateCount');
    }
  },


  _addListenersToChildren:function() {
    var self = this;
    var children = this.get('children');
    children.each(function(child) {
      child.on('change:visible', function() {
        // If no children are visible, then hide self.
        if (!children.findWhere({visible: true})) {
          self.set({visible: false});
        } else {
          self.set({visible: true});
        }
      });
      child.on('updateCount', function() {
        self._updateCount();
        self.trigger('updateCount');
      });
    });
  },

  _updateCount:function() {
    var children = this.get('children');
    var countTotal = {
      selected: 0,
      possible:0
    };

    if (!children.isEmpty()) {
      children.each(function(child) {
        countTotal.selected += child.get('numSelected');
        countTotal.possible += child.get('numPossible');
      });
    } else {
      countTotal = {
        selected: (this.get('selected') ? 1 : 0),
        possible: 1
      };
    }

    this.set('numSelected', countTotal.selected);
    this.set('numPossible', countTotal.possible);
  },

  _updateChildNodes:function(propagation) {
    var self = this;
    var children = this.get('children');

    if (!children.isEmpty()) {
      children.each(function(child) {
        child.set('selected', self.get('selected'), {propagation: propagation});
      });
    }
  },

  filterText: function(txt) {
    var children = this.get('children');

    if (!children.isEmpty()) {
      // if the node itself matches, turn it on, even if no children are visible.
      if (this.get('name') && this.get('name').toLowerCase().indexOf(txt) > -1) {
        this.set('visible', true);
      }

      // FYI: putting inside an else above keeps children visible if parent matches.
      children.each(function(child) {
        child.filterText(txt);
      });

    } else {
      if (this.get('name') && this.get('name').toLowerCase().indexOf(txt) > -1) {
        this.set('visible', true);
      } else {
        this.set('visible', false);
      }
    }
  }

});


module.exports = TreeNodeModel;
