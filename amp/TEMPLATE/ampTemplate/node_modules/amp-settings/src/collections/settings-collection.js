var Deferred = require('jquery').Deferred;
var _ = require('underscore');
var Backbone = require('backbone');
var Setting = require('../models/setting');
var Constants = require('../common/constants');
var Utils = require('../common/utils');
var Config = require('../common/config');

module.exports  = Backbone.Collection.extend({
	model : Setting,
	comparator: 'id',
	firstTime: true,
	initialize: function(models, options) {
		this.options = options;
		this.url = options.definitionUrl;
		this._loaded = new Deferred();
		_.bindAll(this, 'toAPI', 'fromState','load', 'extractNumberFormatSettings','getVisible');
	},
	parse: function(settings) {
	  this.extractNumberFormatSettings(settings);
	  if (Config[this.options.caller]) {
		  return Config[this.options.caller].parse(settings);
	  } else {
		  return settings;
	  }	  
	},
    load: function() {
		if (this.firstTime) {
			this.firstTime = false;
			if (this._loaded.state() !== 'pending') { return this._loaded.promise(); }
			this.fetch({})
			.then(_(function() {
				this._loaded.resolve();
			}).bind(this))
			.fail(_(function() {			       
				this._loaded.reject();
			}).bind(this));
		}    
		return this._loaded.promise();
	},
	toAPI: function(overrides) {
		var tmpJSON = {};
	    var self = this;
		// format selected filter options the way the api wants
		// ignored filters are skipped (overrides are never removed though)
		// overrides should be in the {settingId: settingOptionId} format the api expects
	    this.each(function(setting) {
	    	if (setting.get('options') && _.isUndefined(setting.get('ignore'))) {
	    		if (!setting.get('selected')) {
	    			setting.set('selected', setting.get('defaultId'));
	    		}		         
	    		// find the match.
	    		var match = _.find(setting.get('options'), function(option) {
	    			return ('' + option.id) === ('' + setting.get('selected'));
	    		});
	    		if (match) {
	    			tmpJSON[setting.id] = match.id;
	    		} 
	    	}		     
	    });
	    return tmpJSON
	},
	fromState: function(state) {
		  var self = this;
		    if (state) {
		      _.each(state, function(v, k) {
		        if (self.get(k) !== undefined) {
		          self.get(k).set('selected', v);
		          /* also stash translated item's name */
		          var setting = self.get(k);
		          self.setSettingSelectedName(setting);
		        } else {
		          console.error('cant find setting with key:' + k);
		        }
		      });
		    } else {
		      this.reset(this.map(function(setting) {
		        var clone = setting.clone();
		        clone.set('selected', setting.get('defaultId'));
		        return clone;
		      }));
		      this.each(self.setSettingSelectedName);
		    }
	},
	 /* Make the server-side localized name of the chosen setting value
	   *   available as selectedName on setting model

	   * e.g. selected is: Planned Disbursements,
	   *      so then selectedName is: DebursÄƒri planificate
	   * e.g. selected is: EUR,
	   *      so then selectedName is: Euro
	   */
	setSettingSelectedName: function(setting) {
	    if (setting && setting.get('options')) {
	      var settingObject = _(setting.get('options'))
	            .findWhere({
	              id: setting.get('selected')
	            });
	      if (settingObject !== undefined) {
	        var translatedSetting = settingObject.name;
	        setting.set('selectedName', translatedSetting);
	      }
	    }
	 },
	getVisible: function() {
		return this.filter(function(setting) { return !setting.get('ignore'); });
	},
	
	extractNumberFormatSettings: function(settings) {
		var numberFormat = {}; 
		var foundNF =_.find(settings, function(item) {return item.id === 'number-format'});
		numberFormat.numberFormat = _.find(foundNF.options, function(item) { return item.id === foundNF.defaultId}).name || '#,#.#';

		// If the format pattern doesnt have thousands grouping then ignore 'number-group-separator' param or it will 
		// be used by JS to group by thousands (ie: in the 'Others' columns).
		if(numberFormat.numberFormat.indexOf(',') !== -1) {
			var foundNGS =_.find(settings, function(item) {return item.id === 'number-group-separator'});
			numberFormat.groupSeparator = _.find(foundNGS.options, function(item) { return item.id === foundNGS.defaultId}).name || ',';
		} else {
			numberFormat.groupSeparator = '';
		}
		var foundDS =_.find(settings, function(item) {return item.id === 'number-decimal-separator'});
		numberFormat.decimalSeparator = _.find(foundDS.options, function(item) { return item.id === foundDS.defaultId}).name || '.';
		this.numberFormatSettings = numberFormat;

		var foundNM =_.find(settings, function(item) {return item.id === 'number-multiplier'});
		this.numberMultiplier = _.find(foundNM.options, function(item) { return item.id === foundNM.defaultId});
		if (this.numberMultiplier.name === '1.0') {
			this.numberMultiplierDescription = 'amp.dashboard:chart-tops-inunits';
		} else if(this.numberMultiplier.name === '0.001') {
			this.numberMultiplierDescription = 'amp.dashboard:chart-tops-inthousands';
		} else {
			this.numberMultiplierDescription = 'amp.dashboard:chart-tops-inmillions';
		}
	}
});

