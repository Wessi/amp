var Deferred = require('jquery').Deferred;
var _ = require('underscore');
var Backbone = require('backbone');
var Setting = require('../models/setting');
var Utils = require('../common/utils');
var Config = require('../common/config');

module.exports  = Backbone.Collection.extend({
	model : Setting,
	comparator: 'id',
	firstTime: true,
	initialize: function(models, options) {
		this.options = options;
		this.url = options.definitionUrl;
		this._loaded = new Deferred();
		_.bindAll(this, 'toAPI', 'fromState','load', 'getVisible');
	},
	parse: function(settings) {
	   return settings;	    
	},
    load: function() {
		if (this.firstTime) {
			this.firstTime = false;
			if (this._loaded.state() !== 'pending') { return this._loaded.promise(); }
			this.fetch({})
			.then(_(function() {
				this._loaded.resolve();
			}).bind(this))
			.fail(_(function() {			       
				this._loaded.reject();
			}).bind(this));
		}    
		return this._loaded.promise();
	},
	toAPI: function(overrides) {
		var tmpJSON = {};
	    var self = this;
		// format selected filter options the way the api wants
		// ignored filters are skipped (overrides are never removed though)
		// overrides should be in the {settingId: settingOptionId} format the api expects
	    this.each(function(setting) {
	    	if (setting.get('options') && _.isUndefined(setting.get('ignore'))) {
	    		if (!setting.get('selected')) {
	    			setting.set('selected', setting.get('defaultId'));
	    		}		         
	    		// find the match.
	    		var match = _.find(setting.get('options'), function(option) {
	    			return ('' + option.id) === ('' + setting.get('selected'));
	    		});
	    		if (match) {
	    			tmpJSON[setting.id] = match.id;
	    		} 
	    	}		     
	    });
	    return tmpJSON
	},
	fromState: function(state) {
		  var self = this;
		    if (state) {
		      _.each(state, function(v, k) {
		        if (self.get(k) !== undefined) {
		          self.get(k).set('selected', v);
		          /* also stash translated item's name */
		          var setting = self.get(k);
		          self.setSettingSelectedName(setting);
		        } else {
		          console.error('cant find setting with key:' + k);
		        }
		      });
		    } else {
		      this.reset(this.map(function(setting) {
		        var clone = setting.clone();
		        clone.set('selected', setting.get('defaultId'));
		        return clone;
		      }));
		      this.each(self.setSettingSelectedName);
		    }
	},
	 /* Make the server-side localized name of the chosen setting value
	   *   available as selectedName on setting model

	   * e.g. selected is: Planned Disbursements,
	   *      so then selectedName is: DebursÄƒri planificate
	   * e.g. selected is: EUR,
	   *      so then selectedName is: Euro
	   */
	setSettingSelectedName: function(setting) {
	    if (setting && setting.get('options')) {
	      var settingObject = _(setting.get('options'))
	            .findWhere({
	              id: setting.get('selected')
	            });
	      if (settingObject !== undefined) {
	        var translatedSetting = settingObject.name;
	        setting.set('selectedName', translatedSetting);
	      }
	    }
	 },
	getVisible: function() {
		return this.filter(function(setting) { return !setting.get('ignore'); });
	}
});

