<?xml version="1.0" encoding="utf-8"?>
<!--
	 Copyright (c) 2009 Team Axiis

	 Permission is hereby granted, free of charge, to any person
	 obtaining a copy of this software and associated documentation
	 files (the "Software"), to deal in the Software without
	 restriction, including without limitation the rights to use,
	 copy, modify, merge, publish, distribute, sublicense, and/or sell
	 copies of the Software, and to permit persons to whom the
	 Software is furnished to do so, subject to the following
	 conditions:

	 The above copyright notice and this permission notice shall be
	 included in all copies or substantial portions of the Software.

	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	 OTHER DEALINGS IN THE SOFTWARE.
-->
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:charts="org.axiis.charts.*"
	xmlns:axiis="http://www.axiis.org/2009"
	xmlns:series="org.axiis.charts.series.*"
	xmlns:groupings="org.axiis.charts.groupings.*"
	xmlns:degrafa="http://www.degrafa.com/2007"
	xmlns:states="org.axiis.states.*"
	xmlns:paint="org.axiis.paint.*"
	xmlns:Examples="Examples.*"
	xmlns:axis="org.axiis.charts.axis.*"
	xmlns:labels="org.axiis.charts.labels.*"
	backgroundGradientColors="[0xDDDDDD,0xDDDDDD]"
	layout="absolute"
	creationComplete="application1_creationCompleteHandler(event);"
>
	<mx:HTTPService id="service" url="http://localhost:8081/visualization/dataDispatcher.do?action=getAidTypeGraphData" result="service_resultHandler(event)" >
		<mx:request>
			<format>xml</format>
		</mx:request>
	</mx:HTTPService>
	<!--<mx:Style source="styles/Axiis_Examples.css"/>-->
	<mx:Script>
		<![CDATA[
			import flash.external.ExternalInterface;
			import org.axiis.events.LayoutItemEvent;
			
			import org.axiis.data.DataSet;
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.events.FlexEvent;
			import mx.rpc.events.ResultEvent;
			import mx.utils.ArrayUtil;
			import com.exportUtil.*;
			
			private var ds:DataSet = new DataSet();
			private var groupSeparator:String = null;
			private var decimalSeparator:String = null;
			private var palette:Array = new Array();
			
			/**
			 * This example is using xml data read from the file system. 
			 * In practical usage, you'ld have some data in a model that you want to display
			 * that may be XML or may be in arrayCollections or arrays. In most cases, you'll
			 * need to massage the data into a format that's suitable for the display you're
			 * trying to achieve. 
			 */
			public function start():void
			{
				var categoriesLocal:ArrayCollection = new ArrayCollection(); // Create an array as source for the legend
				
				//service.lastResult.year[x].aidtype[y].amount
				var maxValue:Number = 0;
				var fillCategories:Boolean = false;
				try {
					for(var j:Number = 0; j < service.lastResult.year.aidtype.length; j++){
						try {
							maxValue = service.lastResult.year.aidtype.amount
						} catch (errObject:Error) {
							var currentValue:Number = service.lastResult.year.aidtype[j].amount;
							//Just add the categories in the last iteration
							//if(i == service.lastResult.year.length-1)
							categoriesLocal.addItem(service.lastResult.year.aidtype[j]);
							if (maxValue < currentValue) maxValue = currentValue;
						}
					}
				} catch (errObject:Error) {
					for(var i:Number = 0; i < service.lastResult.year.length; i++){
						for(var j:Number = 0; j < service.lastResult.year[i].aidtype.length; j++){
							var currentValue:Number = service.lastResult.year[i].aidtype[j].amount;
							//Just add the categories in the last iteration
							if(i == service.lastResult.year.length-1)
								categoriesLocal.addItem(service.lastResult.year[i].aidtype[j]);
							if (maxValue < currentValue) maxValue = currentValue;
						}
					}
				}
				categories = categoriesLocal; 
				vScale.maxValue = Math.round(maxValue * 1.05);
				vScale.minValue = 0;
				dataProvider = service.lastResult.year;
				if("length" in service.lastResult.year) // If it's not empty
				{
					dc.visible = true;
					messagePanel.visible = false;
					sizePanel(0, 0);
				}
				else
				{
					dc.visible = false;
					messagePanel.visible = true;
					sizePanel(300, 200);
				}
				dc.visible = true;
				dc.invalidateDisplayList();
				groupSeparator = LoaderInfo(this.root.loaderInfo).parameters.groupSeparator;
				decimalSeparator = LoaderInfo(this.root.loaderInfo).parameters.decimalSeparator;
				var paletteStr:String = null;
				paletteStr = LoaderInfo(this.root.loaderInfo).parameters.palette;
				var palArray = paletteStr.split(",");
				//palette = new Array();
				for (var i:Number = 0; i < palArray.length; i++){
					var tmp:Number = palArray[i];
					palette.push(tmp);
				}
				if (groupSeparator == ""){
					groupSeparator = " ";
				}
				var delayer:Delay = new Delay(captureSnapshot,2000,1); //capture snapshot
				
			}
			
			private function captureSnapshot():void
			{
				var curUrl:String =  String( ExternalInterface.call(" function(){ return document.location.href.toString();}"));
				var strUrl:String ="/visualization/dataDispatcher.do?action=setChartImageFromSnapshot";
				var strDomain:String = "";
				var strProtocol:String = "";
				if(curUrl.indexOf("file://") > -1){
					strProtocol = "http:";
					strDomain = "localhost:8081";
				}
				else
				{
					strProtocol = curUrl.split('/')[0];
					strDomain = curUrl.split('/')[2];
				}
				FlexExporter.ExportToImage(mxc1,"png", strProtocol + "//" + strDomain + strUrl, "FinancingInstrument");
			}
			protected function labelRender(object:Object):String {
				var wrappedLabel:String = null;
				
				if (object != null){
					if(object[childLabelField].length > maxLabelWidth){
						wrappedLabel = "Corto" + object[childLabelField].replace(" ", "\n"); 
					}
					else
					{
						wrappedLabel = object[childLabelField]; 
					}
				}
				return wrappedLabel;
			}
			
			protected function myStack_preRenderHandler(event:Event):void
			{
				// TODO Auto-generated method stub
			}
			protected function service_resultHandler(event:ResultEvent):void
			{
				start();
			}
			
			protected function application1_creationCompleteHandler(event:FlexEvent):void
			{
				var curUrl:String =  String( ExternalInterface.call(" function(){ return document.location.href.toString();}"));
				var strUrl:String ="/visualization/dataDispatcher.do?action=getAidTypeGraphData";
				var strDomain:String = "";
				var strProtocol:String = "";
				if(curUrl.indexOf("file://") > -1){
					strProtocol = "http:";
					strDomain = "localhost:8081";
				}
				else
				{
					strProtocol = curUrl.split('/')[0];
					strDomain = curUrl.split('/')[2];
				}
				service.url = strProtocol + "//" + strDomain + strUrl;
				service.send();
				try {
					ExternalInterface.addCallback("refreshGraph", refreshGraph);			
				}
				catch(errObject:Error){
					//Fail silently when running standalone
				}
			}
			
			/**
			 * The labelFunction property of the LineSeriesGroup, and other components, allow you to 
			 * to determine how each to format each label the component displays
			 */
			private function axisLabel(obj:Object):String
			{
				formatter.decimalSeparatorFrom=decimalSeparator;
				formatter.decimalSeparatorTo=decimalSeparator;
				formatter.thousandsSeparatorFrom=groupSeparator;
				formatter.thousandsSeparatorTo=groupSeparator;
				formatter.useThousandsSeparator=true;
				return formatter.format(obj);
			}
			
			public function refreshGraph():void
			{
				service.send();
				start();
			}
			private function sizePanel(w:uint, h:uint):void {
				messagePanel.width = w;
				messagePanel.height = h;
			}
			public function itemClick(evt:LayoutItemEvent):void{
				ExternalInterface.call("itemClick",evt.item.data.id,"finInstrument",evt.item.data.year);
			}

		]]>
	</mx:Script>
	
	<!-- 
	Provide nice background to chart 
	-->
	<mx:CurrencyFormatter currencySymbol=""
						  precision="0"
						  id="formatter"
						  alignSymbol="right"
						  useThousandsSeparator="true"/>
	
	<!--  GLOBAL VARIABLES -->
	<mx:Object id="dataProvider"/>
	<mx:Object id="categories"/>
	<mx:String id="verticalField"/>
	<mx:String id="dataField">aidtype</mx:String>
	<mx:String id="labelField">name</mx:String>
	<mx:String id="childDataField">amount</mx:String>
	<mx:String id="childLabelField">category</mx:String>
	<mx:Number id="maxLabelWidth">8</mx:Number>
	<mx:Number id="percentGap">.02</mx:Number>
	<mx:Resize id="resize" />
	
	<!--  
	A scale that deals with linear numeric data.
	-->
	<axiis:LinearScale id="vScale" dataProvider="{dataProvider}" minLayout="0"  minValue="0" maxLayout="{hLayout.height}" />
	
	<mx:Canvas id="mxc1" 
			   backgroundColor="white"
			   horizontalCenter="0"
			   verticalCenter="0"
			   width="634" 
			   height="350">
	<!--
	DataCanvas manages the placement and the rendering of layouts.
	They can have backgroundGeometries, foregroundGeometries, and layouts.
	They inherit from Canvas
	-->
	<axiis:DataCanvas top="20"
					  bottom="0"
					  width="{this.width*.9}"
					  id="dc"
					  left="40"
					  right="80"
					  verticalCenter="0"
					  horizontalCenter="0" 
					  showDataTips="true"
					  strokes="{strokes}"
					  fills="{fills}"
					  palettes="{palettes}"
					  visible="false"
					  >
		
		<!-- Background -->
		<!-- backgrounds appear behind the graph. There are also foregroundGeometries for doing annotations on top of the graph 
		verticalScale="{vScale}"			The vertical scale used for scaling data to actual screen units		
		tickStroke="{axisStroke}"			The stroke used to put the hash or tick marks on an axis
		width="{dc.width}"
		height="{myLineGroup.height}"
		showDataTips="false"				A flag that indicates to DataCanvas that it should listen for mouse events that signal the need to create a data tip.
		showGridArea="false"				Whether or not the grid cells are displayed
		showGridLine="false"				Whether or not lines are drawn between grid cells
		showLabels="false"					Whether or not to show labels on the axis
		fontFamily="Myriad Pro"
		fontColor="0"
		fontSize="14"
		tickGap="5"
		majorTickSpacing="50"				The space between successive major tick marks. There is also a minorTickSpacing. Length of marks can be adjusted as well majorTickLength
		labelFunction="{axisLabel}"			A function that is used to determine how each item in the dataProvider should be labeled along the axis.
		-->
		<axiis:backgroundGeometries>
			<axis:VAxis verticalScale="{vScale}"
						tickStroke="{axisStroke}"
						
						width="{dc.width}"
						height="{hLayout.height}"
						showDataTips="false"
						fontFamily="Myriad Pro"
						fontColor="0"
						fontSize="12"
						tickGap="5"
						showGridArea="false"
						labelFunction="{axisLabel}"/>
		</axiis:backgroundGeometries>
		
		<!-- Layouts -->
		<!--
		Layouts are composite components consisting of ReferenceRepeaters (the
		loop that defines a repeated bounding pattern)  DrawingGeometries
		(what you are going to draw) and Layouts (child layouts) 
		
		-->
		<axiis:layouts>
			
			<!--HBoxLayout
			The HBoxLayout is a layout with a referenceRepeater that produces RegularRectangles for each item in its dataProvider. 
			The RegularRectangles are sized and spaced evenly across the width of the layout. This behavior can be used to create column chart-like visualizations.
			
			x="12"											x-location relative to paren
			y="0"											y-location relative to parent
			height="{dc.height-70}"							height of display essentially
			width="{dc.width}"								width
			dataFilterFunction="{filterRows}"				This provides a way to further refine a layouts dataProvider by providing access to a custom filter data filter function. 
			This allows developers to easily visualize subsets of the data without having to change the underlying data structure. 
			dataProvider="{dataProvider}"					EG: var myLines is an ArrayCollection || Array of Line
			Line is an object that has a name property, a plotPointsCollection property of PlotPoint, and an optional index which would be it's order in myLines
			PlotPoint is an object with an index property, an xvalue property used for display of text or the x-value, and a yvalue property which is the y-value
			dataField="value"								The property within each item in the dataProvider that contains the field used to determine the value of the item. (essentially the y value)							
			labelField="pivotName"							The property within each item in the dataProvider that contains the field used to determine the label for the item.
			stroke="{myStroke}"								The stroke used to render lines
			percentGap="{percentGap}"						The amount of whitespace that should be left between RegularRectangles as a percentage of the width of the HBoxLayout
			showDataTips="false"							A flag that indicates to DataCanvas that it should listen for mouse events that signal the need to create a data tip.
			currentDatum									The item in the dataProvider that the layout is currently rendering.
			currentIndex									The index of the item in the dataProvider that the layout is currently rendering.
			currentLabel									The label of the item in the dataProvider that the layout is currently rendering, as determine by taking currentDatum[labelField], if a labelField is defined.
			currentReference								The geometry that is being used to render the current data item as it appears after the necessary iterations of the referenceRepeater have been executed.
			currentValue									The value of the item in the dataProvider that the layout is currently rendering, as determined by taking currentDatum[dataField], if a dataField is defined.
			
			This layout will use the width of the dc and cut it up into dataProvider.length equal parts
			The x value here is the distance from the graphing starts from the vertical axis
			-->
			<axiis:HBoxLayout id="hLayout"
							  x="25"
							  y="0"
							  showDataTips="false"
							  height="{dc.height-50}"
							  width="{dc.width-25}"
							  percentGap="{percentGap}"
							  dataProvider="{dataProvider}" 
							  dataField="{dataField}"
							  labelField="{labelField}"
							  >
				<!--
				Layouts can hold layouts
				-->
				<axiis:layouts>
					
					<!--ColumnCluster
					ColumnCluster groups a series of vertical columns horizontally and labels them. This class is intended to be used to produce multi-series column charts.
					
					x="0"													x-location relative to paren
					y="0"													y-location relative to parent
					width="{hLayout.currentReference.width}"				Using the current geometry reference to set this value in this example
					height="{hLayout.currentReference.height}"				Ditto for height
					dataProvider="{[hLayout.currentDatum.aggregates]}"		Here we're going to use the aggregated data for this datum
					dataField="medal_count_sum"								Using the medal_count_sum value in the aggregate
					labelField="medal_count_sum"							Ditto
					fill="{stackFill}"
					stroke="{colStroke}"
					verticalScale="{vScale}"
					fontFamily="Arial"
					dataFontColor="{outerPalette.currentColor}"
					showLabel="false"										Whether or not labels are shown for each drawingGeometry.				
					showDataLabel="true"									?? Has the same description as showLabel in the docs
					showValueLabel="false"									Whether or not the labels indicating the the value each bar represents are shown.						
					-->					
					
					<!-- Cluster Group
					These are the individual medal columns within a country 
					NOTE: In this example, the width is only .9 of the reference geometry to provide some clearance
					You'll see that the x value is at .05 of that geometry to squeeze it in a bit for the surrounding total column.
					Setting minColumnWidth to width/itemCount otherwise the default value of 15 is implied. If you don't do this, there'll
					be odd behavior for large datasets. This may become the default approach in future builds -->					
					<groupings:ColumnCluster 
						id="myCluster"
						x="{hLayout.currentReference.width*.05}"
						y="0"
						width="{hLayout.currentReference.width*.9}"
						height="{hLayout.currentReference.height}"
						dataProvider="{hLayout.currentValue}"
						dataField="{childDataField}"
						labelField="{childLabelField}"
						percentGap=".1"
						fill="{clusterFill}"
						stroke="{colStroke}"
						verticalScale="{vScale}"
						fontFamily="Myriad Pro"
						fontSize="11"
						dataFontColor="{outerPalette.currentColor}"
						fontColor="{outerPalette.currentColor &amp; -0x333333}"
						showDataLabel="false"
						showLabel="false"
						itemClick="this.itemClick(event);"
						minColumnWidth="{myCluster.width/myCluster.itemCount}"/>
					
					
					
				</axiis:layouts>
				
				<!--HBracket
				A bracket that can be used to denote a group and label items that are laid out horizontally.
				
				height="60"										The height of the bracket from the base of the bracket, how far the sides extend upwards.
				fontFamily="Myriad Pro"							The fontFamily of the label
				fontSize="14"									The font size of the label
				fontColor="{outerPalette.currentColor}"			The color of the label
				y="{hLayout.height+5}"
				x="{hLayout.currentReference.x}"
				labelValue="{hLayout.currentLabel}"				The text of the label placed beneath the bracket.
				markerStroke="{myStroke}"						The stroke used to draw lines of the bracket.					
				-->
				<!-- Bottom Bracket -->
				<axiis:drawingGeometries>
					<labels:HBracket 
						x="{hLayout.currentReference.x}"
						y="{hLayout.height}"
						width="{hLayout.currentReference.width}"
						height="3"
						fontFamily="Myriad Pro"
						fontSize="12"
						fontColor="{outerPalette.currentColor}"
						labelValue="{hLayout.currentLabel}"
						markerStroke="{myStroke}"
						id="hBracket"/>
				</axiis:drawingGeometries>
				
			</axiis:HBoxLayout>
			<axiis:HBoxLayout id="legendLayout" 
							  y="{hLayout.height+25}"
							  width="{hLayout.width}" 
							  height="300"
							  dataProvider="{categories}"
							  dataField="category" 
							  showDataTips="false"
							  
							  > 
				<axiis:drawingGeometries> 
					<degrafa:RasterText 
						id="legendText" 
						y="{legendLayout.currentReference.y}" 
						x="{legendLayout.currentReference.x+12}" 
						text="{legendLayout.currentDatum['category']}" 
						fontFamily="Myriad Pro"
						fontSize="10"
						/> 
					<degrafa:RegularRectangle 
						id="legendSquare" width="10" height="10" fill="{legendFill}" 
						y="{legendLayout.currentReference.y+4}" 
						x="{legendLayout.currentReference.x}"/> 
				</axiis:drawingGeometries> 
			</axiis:HBoxLayout> 
		</axiis:layouts>
	</axiis:DataCanvas>
	</mx:Canvas>
	<!--
	LayoutPalette will generate an Array of colors based on a Layout. The produced colors will be equally distributed between two given anchor colors 
	and will contain x values where x is the number of objects in the Layout's dataProvider. As the Layout renders and its currentIndex property is incremented, 
	the LayoutPalette's currentColor will be incremented as well. Binding on the currentColor allows you vary the color of a fill or stroke used 
	in the Layout's drawingGeometries  as the Layout renders. Very cool.
	
	LayoutPalette will generates an Array of colors for a Layout. By default, LayoutPalette uses the Flex 3 Halo color scheme, but this can be overridden using 
	the colors property. As the currentIndex of the Layout driving this palette changes, the currentColor property is updated to the color at the currentIndex in
	the array. If the layout needs more colors than the array contains, the colors wraps around the array using the mod operator.
	
	NOTE: The major difference between Layout and LayoutAuto: 
	Layout works off of currentIndex for a layout so you only get as many colors as there are for that index values
	LayoutAuto works off the length of the dataProvider to decide how manu colors to generate so there will be many more colors
	If you want a series with repeating colors from series to series use Layout. 
	If you want different colors for all bars, use LayoutAuto
	-->
	<mx:Array id="palettes">
		<axiis:LayoutPalette layout="{hLayout}" colors="[0x000000]" id="outerPalette"/> 
		<axiis:LayoutPalette layout="{myCluster}" colors="{palette}" id="clusterPalette"/> 
		<axiis:LayoutPalette layout="{legendLayout}" colors="{palette}" id="legendPalette"/> 
		<!--<paint:LayoutAutoPalette id="outerPalette" layout="{hLayout}" colorFrom="0xCC3333" colorTo="0x3333CC"/>
		<axiis:LayoutAutoPalette id="clusterPalette" colorFrom="0xCC3333" 
								 colorTo="0x3333CC" layout="{myCluster}"/> 
		<axiis:LayoutAutoPalette id="legendPalette" colorFrom="0xCC3333" 
								 colorTo="0x3333CC" layout="{legendLayout}"/> -->
	</mx:Array>
	
	<!--
	A LinearGradientFill lets you specify a gradient fill
	angle defines the transition across the content
	A GradientStop defines the objects that control a transition as part of a gradient fill. Stops will be equally spaced unless ratio is specified
	-->
	<mx:Array id="fills">
		<degrafa:LinearGradientFill id="clusterFill" angle="45">
			<degrafa:GradientStop color="{clusterPalette.currentColor}"/>
			<degrafa:GradientStop color="{clusterPalette.currentColor | 0x333333}" alpha=".85"/>
		</degrafa:LinearGradientFill>
		<degrafa:SolidFill id="legendFill" 
						   color="{legendPalette.currentColor}" /> 
	</mx:Array>
	
	<!--
	LinearGradientStroke is gradient filled stroke as opposed to just one color. pixelHinting is used to hint strokes to full pixels.
	SolidStroke is typicaly solid stroke. caps define line ends and can put additional lenght on a line. Useful where lines overlap
	-->	
	<mx:Array id="strokes">
		<degrafa:LinearGradientStroke id="colStroke" pixelHinting="true" angle="45">
			<degrafa:GradientStop color="0xFFFFFF" alpha=".7"/>
			<degrafa:GradientStop color="0xFFFFFF" alpha=".3"/>
		</degrafa:LinearGradientStroke>
		<degrafa:SolidStroke 
			color="0xFFFFFF" 
			alpha=".3"/>
		<degrafa:SolidStroke 
			id="axisStroke" 
			color="0x000000" 
			pixelHinting="true"/>
		<degrafa:SolidStroke
			id="myStroke" 
			color="{outerPalette.currentColor}" 
			alpha=".5"/>
		<degrafa:SolidStroke 
			id="myStroke2"
			color="{outerPalette.currentColor}"
			alpha=".7"
			weight="6"
			caps="none"/>
	</mx:Array>
	<mx:Panel x="{(this.width-300)/2}" y="20" title="Empty Dataset" width="0" height="0" id="messagePanel" visible="false" resizeEffect="{resize}">
		<mx:Label id="messageEmpty" fontFamily="Myriad Pro" fontWeight="bold" fontSize="14" color="black" text="No data to show"/>
	</mx:Panel>

</mx:Application>
